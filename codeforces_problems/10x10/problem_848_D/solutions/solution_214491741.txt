{
    "id": 214491741,
    "contestId": 848,
    "creationTimeSeconds": 1689772144,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 848,
        "index": "D",
        "name": "Shake It!",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 2900,
        "tags": [
            "combinatorics",
            "dp",
            "flows",
            "graphs"
        ]
    },
    "author": {
        "contestId": 848,
        "members": [
            {
                "handle": "youbot"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1504272900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 24576000,
    "source": "// Problem: D. Shake It!(2900)\r\n// Contest: Codeforces - Codeforces Round 431 (Div. 1)\r\n// URL: https://codeforces.com/problemset/problem/848/D\r\n// Memory Limit: 256 MB\r\n// Time Limit: 2000 ms\r\n// \r\n// Powered by CP Editor (https://cpeditor.org)\r\n\r\n// dottle bot\r\n#ifndef ONLINE_JUDGE\r\n#define DEBUG\r\n#endif\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <queue>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <set>\r\n#define nln puts(\"\")\r\n#define od(x) printf(\"%d\",x)\r\n#define odb(x) printf(\"%d \",x)\r\n#define odl(x) printf(\"%d\\n\",x)\r\n#define odp(x,y) printf(\"%d %d\\n\",x,y)\r\n#define ol(x) puts(\"\")\r\n#define old(x) printf(\"%lld\",x)\r\n#define oldb(x) printf(\"%lld \",x)\r\n#define oldl(x) printf(\"%lld\\n\",x)\r\n#define oldp(x,y) printf(\"%lld %lld\\n\",x,y)\r\n#define rg(x) for(int i=1;i<=(x);i++){\r\n#define rg_(i,x) for(int i=1;i<=(x);i++){\r\n#define fe(u) for(int i=h[u];i;i=e[i].nxt){int v=e[i].v;\r\n#define gr }\r\n#define rrg(x) for(int i=0;i<(x);i++){\r\n#define rdln(a) a[i]=read();\r\n#define rdln0(a,x) rrg(x) rdln(a) gr\r\n#define rdln1(a,x) rg(x) rdln(a) gr\r\ntemplate<typename T>\r\nvoid print(T x){}\r\ntemplate<>\r\nvoid print<int>(int x){od(x);}\r\ntemplate<>\r\nvoid print<const int>(const int x){od(x);}\r\ntemplate<>\r\nvoid print<long long>(long long x){old(x);}\r\ntemplate<>\r\nvoid print<const long long>(const long long x){old(x);}\r\ntemplate<>\r\nvoid print<char>(char x){putchar(x);}\r\ntemplate<>\r\nvoid print<const char>(const char x){putchar(x);}\r\ntemplate<>\r\nvoid print<double>(double x){printf(\"%.12lf\",x);}\r\ntemplate<typename T,typename... qwq>\r\nvoid print(T x,qwq ...args)\r\n{\r\n\tprint(x);\r\n\tprint(args...);\r\n}\r\n#ifdef DEBUG\r\ntemplate<typename T>\r\nvoid debug(T x){}\r\ntemplate<>\r\nvoid debug<int>(int x){od(x);}\r\ntemplate<>\r\nvoid debug<const int>(const int x){od(x);}\r\ntemplate<>\r\nvoid debug<long long>(long long x){old(x);}\r\ntemplate<>\r\nvoid debug<const long long>(const long long x){old(x);}\r\ntemplate<>\r\nvoid debug<char>(char x){putchar(x);}\r\ntemplate<>\r\nvoid debug<const char>(const char x){putchar(x);}\r\ntemplate<>\r\nvoid debug<double>(double x){printf(\"%.12lf\",x);}\r\ntemplate<typename T,typename... qwq>\r\nvoid debug(T x,qwq ...args)\r\n{\r\n\tdebug(x);\r\n\tdebug(args...);\r\n}\r\n#define dflush fflush\r\n#else\r\n#define dflush(...) 0\r\ntemplate<typename T,typename... qwq>\r\nvoid debug(T x,qwq ...args)\r\n{\r\n\t\r\n}\r\n#endif\r\n\r\n#define int long long\r\nconst int mod=1e9+7;\r\n#ifdef int \r\n#define inf 0x3f3f3f3f3f3f3f3fll\r\n#else \r\n#define inf 0x3f3f3f3f\r\n#endif\r\ninline int min(int a,int b){return a>b?b:a;}\r\ninline int max(int a,int b){return a<b?b:a;}\r\n#define cmlSEGMIN\r\n#define cmlSEGMAX\r\n#define cmlSEGSUM\r\nclass SegTreeAl{\r\n#ifdef cmlSEGMIN\r\n\tint minn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\tint maxn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\tint sum[1000005<<2];\r\n#endif\r\n\tint tag[1000005<<2];\r\n#ifdef cmlSEGSUM\r\n\tvoid pushdown(int o,int l,int r)\r\n#else \r\n\tvoid pushdown(int o)\r\n#endif\r\n\t{\r\n\t\tint&t=tag[o];\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o<<1]+=t;\r\n\t\tminn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o<<1]+=t;\r\n\t\tmaxn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tint m=l+r>>1;\r\n\t\tsum[o<<1]+=t*(m-l+1);\r\n\t\tsum[o<<1|1]+=t*(r-m);\r\n#endif\r\n\t\ttag[o<<1]+=t;\r\n\t\ttag[o<<1|1]+=t;\r\n\t\tt=0;\r\n\t}\r\n\tvoid add(int o,int l,int r,int L,int R,int v)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n#ifdef cmlSEGMAX\r\n\t\t\tmaxn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\t\tminn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\t\tsum[o]+=v*(r-l+1);\r\n#endif\r\n\t\t\ttag[o]+=v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint m=l+r>>1;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)add(o<<1,l,m,L,R,v);\r\n\t\tif(m<R)add(o<<1|1,m+1,r,L,R,v);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t}\r\n#ifdef cmlSEGMIN\r\n\tint qmin(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn minn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=min(res,qmin(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=min(res,qmin(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGMAX\r\n\tint qmax(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn maxn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=-inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=max(res,qmax(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=max(res,qmax(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGSUM\r\n\tint qsum(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn sum[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=0;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res+=qsum(o<<1,l,m,L,R);\r\n\t\tif(m<R)res+=qsum(o<<1|1,m+1,r,L,R);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n};\r\n#define newe(n) struct Edge{int v,w,nxt;}e[2*n+5];\\\r\ntypedef int arr[n+5];\\\r\narr h;\\\r\nint cnt=1;\\\r\ninline void addedge(int u,int v,int w){e[cnt]=(Edge){v,w,h[u]};h[u]=cnt++;}\\\r\nstruct node{\\\r\n\tint u,d;\\\r\n\tbool operator<(const node&b)const{return d>b.d;}\\\r\n};\\\r\nvoid dij(int s,int *d,int N)\\\r\n{\\\r\n\tmemset(d,0x3f,sizeof(int)*(N+3));\\\r\n\td[s]=0;std::priority_queue<node>q;q.push((node){s,0});\\\r\n\twhile(!q.empty())\\\r\n\t{\\\r\n\t\tint u=q.top().u,D=q.top().d;q.pop();if(D!=d[u])continue;\\\r\n\t\tfor(int i=h[u];i;i=e[i].nxt){int v=e[i].v,w=e[i].w;\\\r\n\t\tif(d[u]+w<d[v])d[v]=d[u]+w,q.push((node){v,d[v]});\\\r\n\t\t}\\\r\n\t}\\\r\n}\r\n#define mgs int fa[1<<22],sz[1<<22];\\\r\ninline int f(int x){return x==fa[x]?x:fa[x]=f(fa[x]);}\\\r\ninline int uf(int x,int y)\\\r\n{\\\r\n    int fx=f(x),fy=f(y);\\\r\n    if(fx==fy)return 0;\\\r\n    if(sz[fx]>sz[fy])fx^=fy^=fx^=fy;\\\r\n    fa[fx]=fy,sz[fy]+=sz[fx];\\\r\n    return 1;\\\r\n}\r\ninline int read()\r\n{\r\n    int num=0,f=1;char c=getchar();\r\n    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}\r\n    while(c>47&&c<58)num=num*10+(c^48),c=getchar();\r\n    return num*f;\r\n}\r\ninline int re1d()\r\n{\r\n    char c=getchar();\r\n    while(c<48||c>49)c=getchar();\r\n    return c&1;\r\n}\r\n#ifdef cmlBIT\r\nstruct BIT{int a[1<<20|1],n;\r\nvoid add(int x,int p){while(x<=n)a[x]+=p,x+=x&-x;}\r\nint operator[](int x){int res=0;while(x)res+=a[x],x-=x&-x;return res;}\r\nint operator()(int l,int r){return (*this)[r]-(*this)[l-1];}};\r\n#endif\r\nint rnv[1000005];\r\n#define COMB\r\n#ifdef COMB\r\n#ifndef int\r\n#define int long long\r\n#endif\r\nint fac[1000005],inv[1000005];\r\n#endif\r\nvoid initprog()\r\n{\r\n#ifdef COMB\r\n\tfac[0]=inv[0]=inv[1]=1;\r\n\trg(1000000)fac[i]=fac[i-1]*i%mod;gr\r\n\trg(1000000)if(i>1)inv[i]=inv[mod%i]*(mod-mod/i)%mod;gr\r\n\trg(1000000)rnv[i]=inv[i];gr\r\n\trg(1000000)inv[i]=inv[i]*inv[i-1]%mod;gr\r\n#endif\r\n}\r\n#ifdef COMB\r\nint C(int n,int m)\r\n{\r\n\tif(n==m||m==0)return 1;\r\n\tif(n<m)return 0;\r\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r\n}\r\n#endif\r\ninline int qp(int a,int b){int c=1;while(b){if(b&1)c=c*a%mod;a=a*a%mod;b>>=1;}return c;}\r\ninline int mae(int &a,int b){a+=b;if(a>=mod)a-=mod;return a;}\r\ninline int mde(int &a,int b){a+=mod-b;if(a>=mod)a-=mod;return a;}\r\ninline int mle(int &a,int b){a=a*b%mod;return a;}\r\ninline int mve(int &a,int b){a=a*qp(b,mod-2)%mod;return a;}\r\ninline int mxe(int &a,int b){return a=a>b?a:b;}\r\ninline int mne(int &a,int b){return a=a<b?a:b;}\r\ninline int ae(int a,int b){int c=a+b;return c>=mod?c-mod:c;}\r\ninline int de(int a,int b){return ae(a,mod-b);}\r\ninline int me(int a,int b){return a*b%mod;}\r\ninline int mive(int &a,int b){a=a*rnv[b]%mod;return a;}\r\ninline int ive(int a,int b){return a*rnv[b]%mod;}\r\ninline int ve(int a,int b){return a*qp(b,mod-2)%mod;}\r\n#ifdef cmlST\r\nstruct STmin{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=min(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn min(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\nstruct STmax{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=max(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn max(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\n#endif\r\n#ifdef cmlSAM\r\nstruct SAM{\r\n\tint ch[1000005][26],lnk[1000005],len[1000005],lst=1,cc=1;\r\n\tint sz[1000005];\r\n\tvoid insert(int c)\r\n\t{\r\n\t\tlen[++cc]=len[lst]+1;sz[cc]=1;\r\n\t\tint p=lst;lst=cc;\r\n\t\twhile(p&&ch[p][c]==0)ch[p][c]=cc,p=lnk[p];\r\n\t\tif(p==0)lnk[cc]=1;\r\n\t\telse\r\n\t\t{\r\n\t\t\tint x=ch[p][c];\r\n\t\t\tif(len[p]+1==len[x])lnk[cc]=x;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint q=cc;++cc;\r\n\t\t\t\tlnk[cc]=lnk[x];\r\n\t\t\t\tlnk[x]=lnk[q]=cc;\r\n\t\t\t\tlen[cc]=len[p]+1;\r\n\t\t\t\tmemcpy(ch[cc],ch[x],sizeof(ch[cc]));\r\n\t\t\t\twhile(p&&ch[p][c]==x)ch[p][c]=cc,p=lnk[p];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tnewe(1000005);\r\n\tlong long ans;\r\n\tvoid build()\r\n\t{\r\n\t\trg(cc)addedge(lnk[i],i,0);gr\r\n\t}\r\n\tvoid dfs(int u)\r\n\t{\r\n\t\tfe(u)dfs(v),sz[u]+=sz[v];gr\r\n\t\tif(sz[u]>1)ans=max(ans,1ll*sz[u]*len[u]);\r\n\t}\r\n}t;\r\n#endif\r\nint f[155][155],g[155][155];\r\nint bigc(int n,int m)\r\n{\r\n\tif(n<m)return 0;\r\n\tint res=inv[m];\r\n\tfor(int i=1;i<=m;i++)res=res*(n-i+1)%mod;\r\n\treturn res;\r\n}\r\nint ball(int n,int m)\r\n{\r\n\treturn bigc(n+m-1,m);\r\n}\r\nint tmp[155][155];//tmp: i ops, =j\r\nint dp[55][55];\r\nsigned main()\r\n{\r\n\tinitprog();\r\n\tint n=read(),M=read(),m=n;\r\n\tf[0][1]=g[0][1]=1;\r\n\tg[0][0]=1;\r\n\t// for(int i=2;i<=m;i++)g[0][i]=1;\r\n\t\tdp[0][1]=1;\r\n\tfor(int i=1;i<=n;i++)\r\n\t{\r\n\t\t// int dp[55][55]={},zz[55][55]={};\r\n\t\tfor(int j=0;j<i;j++)\r\n\t\t{\r\n\t\t\t// int tmp[155]={};\r\n\t\t\tfor(int k=0;k<=m;k++)\r\n\t\t\t\tmae(tmp[i][k],me(g[j][k],g[i-j-1][k]));\r\n\t\t\t// for(int k=m;k>=1;k--)\r\n\t\t\t// printf(\"*\");for(int k=0;k<=m;k++)odb(tmp[i][k]);puts(\"\");\r\n\t\t\t// for(int j=1;)\r\n\t\t\t\r\n\t\t\t\t// for(int l=1;l<=n*2+1;l++)\r\n\t\t\t\t\t// mae(f[i][min(k,l)+1],f[j][k]*f[i-j-1][l]%mod);;\r\n\t\t}\r\n\t\tfor(int k=0;k<=m;k++)mde(tmp[i][k],tmp[i][k+1]);\r\n\t\t\r\n\t\tfor(int x=n;x>=0;x--)\r\n\t\t\tfor(int j=1;j*i+x<=n;j++)\r\n\t\t\t\tfor(int o=1;o<=m;o++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint xs=ball(tmp[i][o],j);\r\n\t\t\t\t\t// printf(\"xs %d %d %d(%d)=%d\\n\",i,o,tmp[i][o],j,xs);\r\n\t\t\t\t\tfor(int oh=0;oh+o*j<=m;oh++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// if(xs)odp(j*i+x,o+oh);\r\n\t\t\t\t\t\tmae(dp[j*i+x][o*j+oh],dp[x][oh]*xs%mod);\r\n\t\t\t\t\t\t// if(i==1&&x==0&&o==1&&j==2&&oh==1)\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\t\t// printf(\"!!!%d %d\\n\",dp[x][oh],xs);\r\n\t\t\t\t\t\t\t// odp(j*i+x,o+oh);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\t// printf(\"dp[%d][%d]=%d\\n\",j*i+x,o+oh,dp[j*i+x][o+oh]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t// for(int s=1;s<=i;s++)\r\n\t\t// {\r\n\t\t\t// for(int k=0;k*s<=i;k++)\r\n\t\t\t// {\r\n\t\t\t\t// for(int o=0;o<=m;o++)\r\n\t\t\t\t// {\r\n\t\t\t\t\t// if(!tmp[s][o])continue;\r\n\t\t\t\t\t// int xs=ball(tmp[s][o],k);\r\n\t\t\t\t\t// // printf(\"+%d*%d , %d\\n\",s,k,o);\r\n\t\t\t\t\t// // printf(\"ball %d %d=%d\\n\",tmp[s][o],k,xs);\r\n\t\t\t\t\t// for(int nw=0;nw+s*k<=i;nw++)\r\n\t\t\t\t\t\t// for(int oh=0;oh+o<=m;oh++)\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\t\t// // if(nw==0&&oh==1)odl(xs*dp[nw][oh]),\r\n\t\t\t\t\t\t\t// // printf(\"add ti %d %d\\n\",nw+s*k,oh+o);\r\n\t\t\t\t\t\t\t// mae(zz[nw+s*k][oh+o],xs*dp[nw][oh]);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t// }\r\n\t\t\t// }\r\n\t\t\t// memcpy(dp,zz,sizeof(zz));\r\n\t\t\t// memset(zz,0,sizeof(zz));\r\n\t\t// }\r\n\t\t\r\n\t\tfor(int j=m;j>=0;j--)f[i][j]=dp[i][j],g[i][j]=ae(g[i][j+1],f[i][j]);\r\n\t\t\r\n\t\t// for(int j=0;j<=m;j++)odb(f[i][j]);puts(\"\");\r\n\t\t// for(int j=0;j<=m;j++)odb(g[i][j]);puts(\"\");\r\n\t\t// for(int j=0;j<=m;j++)odb(tmp[i][j]);puts(\"\");\r\n\t\t// puts(\"\");\r\n\t}\r\n\todl(f[n][M]);\r\n\treturn 0;\r\n}"
}