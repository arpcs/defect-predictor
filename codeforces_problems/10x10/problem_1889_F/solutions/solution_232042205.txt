{
    "id": 232042205,
    "contestId": 1889,
    "creationTimeSeconds": 1699520589,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1889,
        "index": "F",
        "name": "Doremy's Average Tree",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1889,
        "members": [
            {
                "handle": "vjudge5"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1698503700
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 156,
    "memoryConsumedBytes": 524390400,
    "source": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n// #define Debug\n// #define LOCAL\n#define TestCases\n\nconst int N = 5000, K = 500;\nconst int E = N << 1, Inf = N << 2;\nconst long long Inff = 1e16;\nconst int SIZE = N << 2;\n\nint n, r, k;\nlong long w[N + 5];\n\nint head[N + 5], to[E + 5], nxt[E + 5], tot = 1;\nvoid add_edge(int u, int v)\n{\n\ttot++;\n\tto[tot] = v;\n\tnxt[tot] = head[u];\n\thead[u] = tot;\n\treturn ;\n}\nvoid add(int u, int v)\n{\n\tadd_edge(u, v);\n\tadd_edge(v, u);\n\treturn ;\n}\n\nstruct Frac\n{\n\tlong long p, q;//p / q\n\tFrac(long long _p = 0, long long _q = 1)\n\t{\n\t\tp = _p, q = _q;\n\t}\n};\nbool operator < (const Frac& x, const Frac& y)\n{\n\treturn x.p * y.q < x.q * y.p;\n}\nbool operator > (const Frac& x, const Frac& y)\n{\n\treturn y < x;\n}\nbool operator == (const Frac& x, const Frac& y)\n{\n\treturn !(x < y) && !(y < x);\n}\nbool operator != (const Frac& x, const Frac& y)\n{\n\treturn x < y || y < x;\n}\nbool operator == (const long long& x, const Frac& y)\n{\n\treturn x * y.q == y.p;\n}\nbool operator == (const Frac& x, const long long& y)\n{\n\treturn y == x;\n}\n\nstruct State\n{\n\tint key[2];//first pos, and the first pos that val diff from first\n\tFrac val[2];\n\t\n\tState(int key1 = Inf, Frac val1 = Frac(Inff, 1), \n\t\tint key2 = Inf, Frac val2 = Frac(Inff, 1))\n\t{\n\t\tkey[0] = key1, key[1] = key2;\n\t\tval[0] = val1, val[1] = val2;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\tvoid print()\n\t{\n\t\tfor (int t = 0; t < 2; t++)\n\t\t{\n\t\t\tcout << key[t] << \" \" << val[t].p << \"/\" << val[t].q << endl;\n\t\t}\n\t\treturn ;\n\t}\n};\nbool operator == (const State& x, const State& y)\n{\n\tfor (int t = 0; t < 2; t++)\n\t\tif (x.key[t] != y.key[t] || x.val[t] != y.val[t])\n\t\t\treturn false;\n\treturn true;\n}\nState operator + (const State& x, const State& y)\n{\n\tpair<int, Frac> tmp[5];\n\tfor (int t = 0; t < 2; t++)\n\t\ttmp[t] = make_pair(x.key[t], x.val[t]);\n\tfor (int t = 2; t < 4; t++)\n\t\ttmp[t] = make_pair(y.key[t - 2], y.val[t - 2]);\n\tsort(tmp, tmp + 4);\n\t\n\tState res;\n\tfor (int t = 0, l = 0, r = 0; t < 2 && l < 4; l = r + 1, t++)\n\t{\n\t\tr = l;\n\t\twhile (r + 1 < 4 && tmp[r + 1].second == tmp[r].second)\n\t\t\tr++;\n\t\tres.key[t] = tmp[l].first;\n\t\tres.val[t] = tmp[l].second;\n\t}\n\treturn res;\n}\nstruct Node\n{\n\tint key, from, rk;//pos, from which son, rank(in son)\n\t\n\tbool operator < (const Node& node) const\n\t{\n\t\treturn key < node.key;\n\t}\n\tvoid tie(int& _key, int& _from, int& _rk)\n\t{\n\t\t_key = key, _from = from, _rk = rk;\n\t\treturn ;\n\t}\n};\n\nint sz[N + 5];\nlong long sum[N + 5];\nFrac ave[N + 5];\nNode seq[N + 5][N + 5];\n\nState state[N + 5][K + 5];\nint dif[N + 5][K + 5];\nint opt[N + 5][K + 5];\nint cnt[N + 5][N + 5];\nint mx[N + 5];\n\nstruct SegmentTree\n{\n\tState v[SIZE + 5];\n\tint tag[SIZE + 5];\n\n\t#define ls(p) (p << 1)\n\t#define rs(p) (p << 1 | 1)\n\n\tvoid pushup(int p)\n\t{\n\t\tv[p] = v[ls(p)] + v[rs(p)];\n\t\treturn ;\n\t}\n\tvoid clear(int p)\n\t{\n\t\ttag[p] = 1;\n\t\tv[p] = State();\n\t\treturn ;\n\t}\n\tvoid pushdown(int p)\n\t{\n\t\tif (tag[p])\n\t\t{\n\t\t\tclear(ls(p));\n\t\t\tclear(rs(p));\n\t\t\ttag[p] = 0;\n\t\t}\n\t\treturn ;\n\t}\n\n\tvoid update(int p, int l, int r, int pos, State val)\n\t{\n\t\tif (l == r)\n\t\t\treturn v[p] = val, void();\n\t\tint mid = (l + r) >> 1;\n\t\tpushdown(p);\n\t\tif (pos <= mid)\n\t\t\tupdate(ls(p), l, mid, pos, val);\n\t\telse\n\t\t\tupdate(rs(p), mid + 1, r, pos, val);\n\t\tpushup(p);\n\t\treturn ;\n\t}\n} tree;\n\nvoid prework(int u, int fa)\n{\n\tsz[u] = 1;\n\tsum[u] = w[u];\n\tseq[u][1] = {u, u, 0};\n\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif (v == fa)\n\t\t\tcontinue;\n\t\tprework(v, u);\n\n\t\tsum[u] += sum[v];\n\t\tfor (int t = 1; t <= sz[v]; t++)\n\t\t\tseq[u][sz[u] + t] = {seq[v][t].key, v, t};\n\t\tsz[u] += sz[v];\n\t}\n\n\tsort(seq[u] + 1, seq[u] + sz[u] + 1);\n\tave[u] = Frac{sum[u], sz[u]};\n\treturn ;\n}\n\nvoid dfs(int u, int fa)\n{\n\t\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif (v != fa)\n\t\t\tdfs(v, u);\n\t}\n\n\ttree.clear(1);\n\tstate[u][0] = State(u, Frac(w[u], 1));\n\ttree.update(1, 1, n, u, state[u][0]);\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif (v == fa)\n\t\t\tcontinue;\n\t\ttree.update(1, 1, n, v, state[v][0]);\n\t\tstate[u][0] = state[u][0] + state[v][0];\n\t\tcnt[u][v] = 0;\n\t}\n\n\tfor (int x = 1, pos = 1; x <= k; x++)\n\t{\n\t\topt[u][x] = 0;\n\n\t\tint p, fr, rk;\n\t\tseq[u][pos].tie(p, fr, rk);\n\n\t\twhile (pos <= sz[u] && \n\t\t\t(u == p || cnt[u][fr] == mx[fr] || dif[fr][cnt[u][fr] + 1] > rk))\n\t\t{\n\t\t\tpos++;\n\t\t\tseq[u][pos].tie(p, fr, rk);\n\t\t}\n\t\tif (pos > sz[u])\n\t\t{\n\t\t\tdif[u][x] = Inf;\n\t\t\tstate[u][x] = State();\n\t\t\tcontinue;\n\t\t}\n\n\t\tcnt[u][fr]++;\n\t\tdif[u][x] = pos;\n\n\t\ttree.update(1, 1, n, fr, state[fr][cnt[u][fr]]);\n\t\tstate[u][x] = tree.v[1];\n\n\n\n\t\t#ifdef Debug\n\t\t#endif\n\t}\n\n\n\t#ifdef Debug\n\n\t// if (u == 2)\n\t// {\n\n\n\tif (u == 7)\n\t{\n\t\tcout << \"check cnt\" << endl;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tcout << i << \" cnt = \" << cnt[u][i] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tcout << \"before update check \" << u << endl;\n\tcout << \"size = \" << sz[u] << \" sum = \" << sum[u] << \" ave = \" << ave[u].p << \"/\" << ave[u].q << endl;\n\tcout << \"seq: \" << endl;\n\tfor (int i = 1; i <= sz[u]; i++)\n\t{\n\t\tprintf(\"key = %d, from = %d, rank = %d\\n\", seq[u][i].key, seq[u][i].from, seq[u][i].rk);\n\t}\n\tcout << \"state: \" << endl;\n\tfor (int t = 0; t <= k; t++)\n\t{\n\t\tcout << \"times = \" << t << \": \" << endl;\n\t\tcout << \"---- dif = \" << dif[u][t] << endl;\n\t\tcout << \"---- state = \";\n\t\tfor (int tt = 0; tt < 2; tt++)\n\t\t\tprintf(\"(%d, %lld/%lld); \", state[u][t].key[tt], state[u][t].val[tt].p, state[u][t].val[tt].q);\n\t\tcout << endl;\n\t\tcout << \"---- opt = \" << opt[u][t] << endl;\n\t}\n\tcout << \"================================================================================================\" << endl;\n\n\t// }\n\t#endif\n\n\n\tfor (int x = 1; x <= k; x++)\n\t{\n\t\tif ((state[u][x].val[0] > ave[u] || \n\t\t\t(state[u][x].val[0] == ave[u] && state[u][x].val[1] > ave[u])) \n\t\t\t&& \n\t\t\t(state[u][x - 1].val[0] > ave[u] || \n\t\t\t(state[u][x - 1].val[0] == ave[u] && state[u][x - 1].val[1] > ave[u])))\n\t\t{\n\t\t\topt[u][x] = 1;\n\t\t\tdif[u][x] = 1;\n\t\t\tstate[u][x] = State(seq[u][1].key, ave[u]);\n\t\t}\n\t}\n\n\tmx[u] = k;\n\twhile (mx[u] > 0 && state[u][mx[u]] == state[u][mx[u] - 1])\n\t\tmx[u]--;\n\t\n\n\t#ifdef Debug\n\tcout << \"check \" << u << endl;\n\tcout << \"size = \" << sz[u] << \" sum = \" << sum[u] << \" ave = \" << ave[u].p << \"/\" << ave[u].q << endl;\n\tcout << \"seq: \" << endl;\n\tfor (int i = 1; i <= sz[u]; i++)\n\t{\n\t\tprintf(\"key = %d, from = %d, rank = %d\\n\", seq[u][i].key, seq[u][i].from, seq[u][i].rk);\n\t}\n\tcout << \"state: \" << endl;\n\tfor (int t = 0; t <= mx[u]; t++)\n\t{\n\t\tcout << \"times = \" << t << \": \" << endl;\n\t\tcout << \"---- dif = \" << dif[u][t] << endl;\n\t\tcout << \"---- state = \";\n\t\tfor (int tt = 0; tt < 2; tt++)\n\t\t\tprintf(\"(%d, %lld/%lld); \", state[u][t].key[tt], state[u][t].val[tt].p, state[u][t].val[tt].q);\n\t\tcout << endl;\n\t\tcout << \"---- opt = \" << opt[u][t] << endl;\n\t}\n\tcout << \"================================================================================================\" << endl;\n\n\t#endif\n\n\treturn ;\n}\n\nint ans[N + 5], top;\nvoid print(int u, int fa, int s)\n{\n\tif (opt[u][s])\n\t\treturn ans[++top] = u, void();\n\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif (v != fa)\n\t\t\tcnt[u][v] = 0;\n\t}\n\n\tfor (int x = 1, pos = 1; x <= s; x++)\n\t{\n\t\tint p, fr, rk;\n\t\tseq[u][pos].tie(p, fr, rk);\n\n\t\twhile (pos <= sz[u] && \n\t\t\t(u == p || cnt[u][fr] == mx[fr] || dif[fr][cnt[u][fr] + 1] > rk))\n\t\t{\n\t\t\tpos++;\n\t\t\tseq[u][pos].tie(p, fr, rk);\n\t\t}\n\n\t\tif (pos > sz[u])\n\t\t\tbreak;\n\n\t\tcnt[u][fr]++;\n\t}\n\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif (v == fa || !cnt[u][v])\n\t\t\tcontinue;\n\t\tprint(v, u, cnt[u][v]);\n\t}\n\treturn ;\n}\n\nvoid solve()\n{\n\tscanf(\"%d%d%d\", &n, &r, &k);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", w + i);\n\tfor (int i = 1, u, v; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v);\n\t}\n\n\tprework(r, 0);\n\tdfs(r, 0);\n\ttop = 0;\n\tprint(r, 0, k);\n\n\tprintf(\"%d\\n\", top);\n\tfor (int i = 1; i <= top; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\n\ttot = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\thead[i] = 0;\n\treturn ;\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"data.in\", \"r\", stdin);\n\tfreopen(\"mycode.out\", \"w\", stdout);\n\t#endif\n\t\n\tint T = 1;\n\t\n\t#ifdef TestCases\n\tscanf(\"%d\", &T);\n\t#endif\n\n\n\n\t// if (T == 4)\n\t// {\n\t// \tcout << \"1\\n2\\n2\\n1 4\\n1\\n5\\n1\\n1\" << endl;\n\t// \treturn 0;\n\t// }\n\t\n\twhile (T--)\n\t\tsolve();\n\treturn 0;\n}\n\t \t   \t  \t       \t   \t\t\t\t \t\t\t \t"
}