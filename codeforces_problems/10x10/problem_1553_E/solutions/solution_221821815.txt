{
    "id": 221821815,
    "contestId": 1553,
    "creationTimeSeconds": 1693834457,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1553,
        "index": "E",
        "name": "Permutation Shift",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 2100,
        "tags": [
            "brute force",
            "combinatorics",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "math"
        ]
    },
    "author": {
        "contestId": 1553,
        "members": [
            {
                "handle": "Mc3X"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1626964500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 49,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 4812800,
    "source": "#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n \r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\nusing namespace std;\r\nusing i64 = uint64_t;\r\n//using i128 = __int128;\r\n#define MAXN 400005\r\n#define MAXM 2605\r\n#define MAXK 65\r\n#define MAXT 102\r\n#define OP 0\r\n#define CLO 1\r\n#define PLUS 0\r\n#define MINUS 1\r\n#define MUL 2\r\n#define HORZ 0\r\n#define VERT 1\r\n#define ITER 65\r\n#define INF 1e9\r\n#define EPS 1e-9\r\n#define MOD 998244353\r\n#define SRC 0\r\n#define PUSH 0\r\n#define POP 1\r\n#define PI acos(-1)\r\n#define UNVISITED INF\r\n#define FOR 0\r\n#define BACK 1\r\n#define OK 2\r\n#define H 18\r\n#define HSH 3\r\ntypedef long long ll;\r\ntypedef ll hash_t;\r\ntypedef __int128_t lint;\r\ntypedef long double ld;\r\ntypedef pair<int,int> ii;\r\ntypedef pair<int,ll> ilp;\r\ntypedef pair<ll,ii> pl;\r\ntypedef pair<ll, ll> pll;\r\ntypedef pair<ll,int> ppll;\r\ntypedef pair<ll,int> li;\r\ntypedef pair<ll,ll> iv;\r\ntypedef pair<double,int> ip;\r\ntypedef tuple<int,int,int> iii;\r\ntypedef tuple<ll, ll, ll> tll;\r\ntypedef tuple<ld, int, int> iit;\r\ntypedef tuple<int,int,ll> i3;\r\ntypedef vector<vector<int>> vv;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\ntypedef vector<ii> vii;\r\ntypedef vector<vector<ll>> vll;\r\n//typedef complex<ld> cd;\r\ntypedef tuple<ll,int,int> tpl;\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ppb pop_back\r\n#define ppf pop_front\r\n#define pf push_front\r\n#define bk back()\r\n#define frnt front()\r\n#define ins insert\r\n#define er erase\r\n#define sc second\r\n#define fr first\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define repl(i,x,y) for (int i = (x); i <= (y); ++i)\r\n#define rep(i,x,y) for (int i = (x); i < (y); ++i)\r\n#define rev(i,x,y) for (int i = (x); i >= (y); --i)\r\n#define repd(i,x,y,d) for (int i = (x); i < (y); i += (d))\r\n#define LSOne(S) (S & (-S))\r\n#define trav(i,v) for (auto &i : v)\r\n#define foreach(it,v) for (auto it = begin(v); it != end(v); ++it)\r\n#define bend(v) begin(v), end(v)\r\n#define rbend(v) (v).rbegin(), (v).rend()\r\n#define sortarr(v) sort(bend(v))\r\n#define rsortarr(v) sort(rbend(v))\r\n#define rdup(v) v.er(unique(bend(v)), end(v))\r\n#define rstreak(v) v.resize(unique(bend(v)) - begin(v))\r\n#define extend(A,B) A.insert(end(A), bend(B))\r\n#define sz(A) (int)(A.size())\r\n#define fill(V) iota(bend(V), (0))\r\n#define vfill(V, st) iota(bend(V), st)\r\n#define sum(V) accumulate(bend(V), 0LL)\r\n#define vsum(V, st) accumulate(bend(V), (ll)(st))\r\n#define freq(V, amt) (int)(count(bend(V), amt))\r\ntemplate<class T> bool ckmin(T &a, T b) { return a > b ? a = b, 1 : 0; };\r\ntemplate<class T> bool ckmax(T &a, T b) { return a < b ? a = b, 1 : 0; };\r\ntemplate<class T> void amax(T &a, T b, T c) { a = max(b, c); };\r\ntemplate<class T> void amin(T &a, T b, T c) { a = min(b, c); };\r\ntemplate<class T> T getmax(vector<T> &v) { return *max_element(bend(v)); };\r\ntemplate<class T> T getmin(vector<T> &v) { return *min_element(bend(v)); };\r\ntemplate<class vi> void distinct(vi &a) { sortarr(a); rdup(a); };\r\ntemplate<class T> int compress(vector<T> &v, T val) { return (int)(lower_bound(bend(v), val) - begin(v)); };\r\ntemplate<class T> auto vfind(vector<T> &v, T val) {\r\n    return find(bend(v), val);\r\n}\r\ntemplate<class T> auto verase(vector<T> &v, T val) {\r\n    return v.er(vfind(v, val));\r\n}\r\ntemplate<class T> void revarr(vector<T> &v) { reverse(bend(v)); };\r\ntemplate<class T> void print(vector<T> &v, char end) { trav(i,v) cout << i << end;\r\n}\r\n \r\nmt19937 gen((int)(chrono::steady_clock::now().time_since_epoch().count()));\r\nll rng(ll l,ll r) {return uniform_int_distribution<ll>(l,r)(gen);}\r\n \r\nvoid fast_io() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL); cout.tie(NULL);\r\n}\r\n \r\nll gcd(ll a, ll b) {\r\n    if (!a) return b;\r\n    return gcd(b % a, a);\r\n}\r\n\r\nvector<ii> mv = {{-1,0}, {0,1}, {1,0}, {0,-1}};\r\nvector<ii> mv2 = {{-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}};\r\n//brute force the value of k\r\n//since m is small, there is a small number of possible values of k\r\n//brute force all possible values of k\r\nvoid solve() {\r\n    int n,m; cin >> n >> m;\r\n    vi v(n), cnt(n);\r\n    rep(i,0,n) {\r\n        int a; cin >> a;\r\n        a--;\r\n        v[i] = a;\r\n        //calculate the distance this element is cyclically shifted forward\r\n        cnt[(i - a + n) % n]++;\r\n    }\r\n    vi ans;\r\n    rep(k,0,n) {\r\n        if (cnt[k] >= n - 2 * m) {\r\n            vi q(n), iden(n);\r\n            //undo the cyclic shift first then try to place elements back\r\n            //to their original position\r\n            rep(i,0,n) q[i] = v[(i + k) % n];\r\n            rep(i,0,n) iden[q[i]] = i;\r\n            int swaps = 0;\r\n            rep(i,0,n) {\r\n                int id = iden[i];\r\n                if (id == i) continue;\r\n                swap(q[i], q[id]);\r\n                swaps++;\r\n                iden[q[i]] = i;\r\n                iden[q[id]] = id;\r\n            }\r\n            if (swaps <= m) ans.pb(k);\r\n        }\r\n    }\r\n    cout << sz(ans) << ' ';\r\n    trav(i,ans) cout << i  << ' ';\r\n    cout << '\\n';\r\n}\r\n\r\nint main() {\r\n    fast_io();\r\n    int t; cin >> t;\r\n    while (t--) solve();\r\n}\r\n"
}