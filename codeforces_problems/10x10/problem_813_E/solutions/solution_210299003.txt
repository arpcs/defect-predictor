{
    "id": 210299003,
    "contestId": 813,
    "creationTimeSeconds": 1687227278,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 813,
        "index": "E",
        "name": "Army Creation",
        "type": "PROGRAMMING",
        "rating": 2200,
        "tags": [
            "binary search",
            "data structures"
        ]
    },
    "author": {
        "contestId": 813,
        "members": [
            {
                "handle": "GoldLight"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1496675100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 11,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 96153600,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid fast(){ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);}\r\n\r\nconst int N=1e5;\r\nint tree[N+1], cur;\r\ndeque<int> dq[N+1];\r\nstruct node{int val, l, r;} st[22*N];\r\nint build(int l, int r){\r\n    if(l==r){\r\n        st[++cur].val=0;\r\n        return cur;\r\n    }\r\n    int mid=(l+r)/2, now=++cur;\r\n    st[now]={0, build(l, mid), build(mid+1, r)};\r\n    return now;\r\n}\r\nint upd(int prev, int l, int r, int x, int v){\r\n    if(l==r){\r\n        st[++cur].val=v;\r\n        return cur;\r\n    }\r\n    int mid=(l+r)/2, now=++cur;\r\n    if(x<=mid) st[now]={0, upd(st[prev].l, l, mid, x, v), st[prev].r};\r\n    else st[now]={0, st[prev].l, upd(st[prev].r, mid+1, r, x, v)};\r\n    st[now].val=st[st[now].l].val+st[st[now].r].val;\r\n    return now;\r\n}\r\nint query(int ql, int qr, int l, int r, int k){\r\n    if(l>=ql && r<=qr) return st[k].val;\r\n    if(l>qr || r<ql) return 0;\r\n    int mid=(l+r)/2;\r\n    return query(ql, qr, l, mid, st[k].l)+query(ql, qr, mid+1, r, st[k].r);\r\n}\r\nint main(){\r\n    fast();\r\n    int n, k, a; cin>>n>>k;\r\n    tree[0]=build(1, n);\r\n    for(int i=1; i<=n; i++){\r\n        cin>>a;\r\n        dq[a].push_back(i);\r\n        if(dq[a].size()>k){\r\n            tree[i]=upd(tree[i-1], 1, n, dq[a][0], 0);\r\n            dq[a].pop_front();\r\n            tree[i]=upd(tree[i], 1, n, i, 1);\r\n        }\r\n        else{\r\n            tree[i]=upd(tree[i-1], 1, n, i, 1);\r\n        }\r\n    }\r\n    int q, l, r, last=0; cin>>q;\r\n    while(q--){\r\n        cin>>l>>r;\r\n        l=(l+last)%n+1;\r\n        r=(r+last)%n+1;\r\n        if(l>r) swap(l, r);\r\n        last=query(l, r, 1, n, tree[r]);\r\n        cout<<last<<'\\n';\r\n    }\r\n}\r\n/*\r\n#define int long long\r\nconst int N=2e5;\r\nint a[N+1], ro[N+1], cur=0;\r\nstruct node{int val, l, r;} st[21*N];\r\nint build(int l, int r){\r\n    if(l==r){\r\n        st[++cur].val=a[l];\r\n        return cur;\r\n    }\r\n    int mid=(l+r)/2, now=++cur;\r\n    st[now]={0, build(l, mid), build(mid+1, r)};\r\n    st[now].val=st[st[now].l].val+st[st[now].r].val;\r\n    return now;\r\n}\r\nint upd(int l, int r, int prev, int id, int v){\r\n    if(l==r){\r\n        st[++cur].val=v;\r\n        return cur;\r\n    }\r\n    int mid=(l+r)/2, now=++cur;\r\n    if(id<=mid) st[now]={0, upd(l, mid, st[prev].l, id, v), st[prev].r};\r\n    else st[now]={0, st[prev].l, upd(mid+1, r, st[prev].r, id, v)};\r\n    st[now].val=st[st[now].l].val+st[st[now].r].val;\r\n    return now;\r\n}\r\nint query(int ql, int qr, int l, int r, int k){\r\n    if(l>=ql && r<=qr) return st[k].val;\r\n    if(l>qr || r<ql) return 0;\r\n    int mid=(l+r)/2;\r\n    return query(ql, qr, l, mid, st[k].l)+query(ql, qr, mid+1, r, st[k].r);\r\n}\r\nsigned main(){\r\n    int n, q; cin>>n>>q;\r\n    for(int i=1; i<=n; i++) cin>>a[i];\r\n    ro[1]=build(1, n);\r\n    int type, k, a, b, id=1;\r\n    while(q--){\r\n        cin>>type;\r\n        if(type==1){\r\n            cin>>k>>a>>b;\r\n            ro[k]=upd(1, n, ro[k], a, b);\r\n        }\r\n        else if(type==2){\r\n            cin>>k>>a>>b;\r\n            cout<<query(a, b, 1, n, ro[k])<<'\\n';\r\n        }\r\n        else{\r\n            cin>>k;\r\n            ro[++id]=ro[k];\r\n        }\r\n    }\r\n}\r\n*/\r\n/*\r\nconst int N=5e5, INF=1e9;\r\nint idx[N+1], cur=0;\r\nstruct node{int val, l, r;} st[22*N];\r\nint build(int l, int r){\r\n    if(l==r){\r\n        st[++cur].val=INF;\r\n        return cur;\r\n    }\r\n    int mid=(l+r)/2, id=++cur;\r\n    st[id]={0, build(l, mid), build(mid+1, r)};\r\n    st[id].val=min(st[st[id].l].val, st[st[id].r].val);\r\n    return id;\r\n}\r\nint upd(int l, int r, int prev, int id, int v){\r\n    if(l==r){\r\n        st[++cur].val=v;\r\n        return cur;\r\n    }\r\n    int mid=(l+r)/2, now=++cur;\r\n    if(id<=mid) st[now]={0, upd(l, mid, st[prev].l, id, v), st[prev].r};\r\n    else st[now]={0, st[prev].l, upd(mid+1, r, st[prev].r, id, v)};\r\n    st[now].val=min(st[st[now].l].val, st[st[now].r].val);\r\n    return now;\r\n}\r\nint query(int ql, int qr, int l, int r, int id){\r\n    if(l>=ql && r<=qr) return st[id].val;\r\n    if(l>qr || r<ql) return INF;\r\n    int mid=(l+r)/2;\r\n    return min(query(ql, qr, l, mid, st[id].l), query(ql, qr, mid+1, r, st[id].r));\r\n}\r\nint main(){\r\n    fast();\r\n    int n, a, q; cin>>n>>q;\r\n    map<int,int> mp;\r\n    idx[0]=build(1, n);\r\n    for(int i=1; i<=n; i++){\r\n        cin>>a;\r\n        if(mp.count(a)) idx[i]=upd(1, n, idx[i-1], mp[a], i-mp[a]);\r\n        else idx[i]=idx[i-1];\r\n        mp[a]=i;\r\n    }\r\n    int l, r, ans;\r\n    while(q--){\r\n        cin>>l>>r;\r\n        ans=query(l, r, 1, n, idx[r]);\r\n        if(ans==INF) cout<<-1;\r\n        else cout<<ans;\r\n        cout<<'\\n';\r\n    }\r\n}\r\n*/\r\n/*\r\nconst int N=5e5, INF=1e9;\r\nstruct node{\r\n    int val;\r\n    node *left, *right;\r\n    node *build(int l, int r){\r\n        val=INF;\r\n        if(l==r) return this;\r\n        int mid=(l+r)/2;\r\n        left=new node();\r\n        right=new node();\r\n        left->build(l, mid);\r\n        right->build(mid+1, r);\r\n        return this;\r\n    }\r\n    node *upd(int l, int r, int idx, int v){\r\n        node *temp=new node();\r\n        if(l==r){\r\n            temp->val=v;\r\n            return temp;\r\n        }\r\n        int mid=(l+r)/2;\r\n        if(idx<=mid){\r\n            temp->left=upd(l, mid, idx, v);\r\n            temp->right=right;\r\n        }\r\n        else{\r\n            temp->right=upd(mid+1, r, idx, v);\r\n            temp->left=left;\r\n        }\r\n        temp->val=min(temp->left->val, temp->right->val);\r\n        return temp;\r\n    }\r\n    int query(int ql, int qr, int l, int r){\r\n        if(l>=ql && r<=qr) return val;\r\n        if(l>qr || r<ql) return INF;\r\n        int mid=(l+r)/2;\r\n        return min(left->query(ql, qr, l, mid), right->query(ql, qr, mid+1, r));\r\n    }\r\n}*st[N+1];\r\n \r\nint main(){\r\n    fast();\r\n    int n, q, a; cin>>n>>q;\r\n    map<int,int> mp;\r\n    st[0]=new node();\r\n    st[0]=st[0]->build(1, n);\r\n    int idx[n+1]; idx[0]=0;\r\n    for(int i=1; i<=n; i++){\r\n        idx[i]=i;\r\n        cin>>a;\r\n        if(mp.count(a)){\r\n            st[i]=st[idx[i-1]]->upd(1, n, mp[a], i-mp[a]);\r\n        }\r\n        else idx[i]=idx[i-1];\r\n        mp[a]=i;\r\n    }\r\n    int l, r, ans;\r\n    while(q--){\r\n        cin>>l>>r;\r\n        ans=st[idx[r]]->query(l, r, 1, n);\r\n        if(ans!=INF) cout<<ans;\r\n        else cout<<-1;\r\n        cout<<\"\\n\";\r\n    }\r\n}\r\n*/\r\n/*\r\nconst int N=5e5, INF=1e9;\r\nstruct node{\r\n    int val;\r\n    node *left, *right;\r\n}*st[N+1];\r\nvoid build(node *now, int l, int r){\r\n    now->val=INF;\r\n    if(l==r) return;\r\n    int mid=(l+r)/2;\r\n    now->left=new node();\r\n    now->right=new node();\r\n    build(now->left, l, mid);\r\n    build(now->right, mid+1, r);\r\n}\r\nvoid upd(node *now, node *prev, int l, int r, int idx, int v){\r\n    int mid=(l+r)/2;\r\n    if(l==r){\r\n        now->val=v;\r\n    }\r\n    else if(idx<=mid){\r\n        now->left=new node();\r\n        now->right=prev->right;\r\n        upd(now->left, prev->left, l, mid, idx, v);\r\n        now->val=min(now->left->val, now->right->val);\r\n    }\r\n    else{\r\n        now->right=new node();\r\n        now->left=prev->left;\r\n        upd(now->right, prev->right, mid+1, r, idx, v);\r\n        now->val=min(now->left->val, now->right->val);\r\n    }\r\n}\r\nint query(node *now, int ql, int qr, int l, int r){\r\n    if(l>=ql && r<=qr){\r\n        //cout<<ql<<' '<<qr<<' '<<l<<' '<<r<<'\\n';\r\n        return now->val;\r\n    }\r\n    if(l>qr || r<ql) return INF;\r\n    int mid=(l+r)/2;\r\n    return min(query(now->left, ql, qr, l, mid), query(now->right, ql, qr, mid+1, r));\r\n}\r\nint main(){\r\n    fast();\r\n    int n, q, a; cin>>n>>q;\r\n    map<int,int> mp;\r\n    st[0]=new node();\r\n    build(st[0], 1, n);\r\n    for(int i=1; i<=n; i++){\r\n        cin>>a;\r\n        if(mp.count(a)){\r\n            st[i]=new node();\r\n            upd(st[i], st[i-1], 1, n, mp[a], i-mp[a]);\r\n        }\r\n        else st[i]=st[i-1];\r\n        mp[a]=i;\r\n    }\r\n    int l, r, ans;\r\n    while(q--){\r\n        cin>>l>>r;\r\n        ans=query(st[r], l, r, 1, n);\r\n        if(ans!=INF) cout<<ans;\r\n        else cout<<-1;\r\n        cout<<'\\n';\r\n    }\r\n}*/"
}