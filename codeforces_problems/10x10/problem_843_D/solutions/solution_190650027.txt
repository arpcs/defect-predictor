{
    "id": 190650027,
    "contestId": 843,
    "creationTimeSeconds": 1674735120,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 843,
        "index": "D",
        "name": "Dynamic Shortest Path",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 3400,
        "tags": [
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 843,
        "members": [
            {
                "handle": "Ptilopsis_w"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1503592500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 195,
    "timeConsumedMillis": 9640,
    "memoryConsumedBytes": 9728000,
    "source": "// LUOGU_RID: 100564046\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nnamespace Octane {\r\n    //non terrae plus ultra dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define OCTANE // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define BUFFER_SIZE 100000 // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define ll long long // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define db double // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define ldb long double // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    char ibuf[100000], obuf[100000], *p1=ibuf,*p2=ibuf,*p3=obuf;\r\n    #ifdef ONLINE_JUDGE//dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define getchar() ((p1==p2) and (p2=(p1=ibuf)+fread(ibuf,1,\\\r\n    BUFFER_SIZE,stdin),p1==p2)?(EOF):(*p1++)) // dqrdqrdqrdqrdqr\r\n    #define putchar(x) ((p3==obuf+BUFFER_SIZE) && (fwrite(obuf,\\\r\n    p3-obuf,1,stdout),p3=obuf),*p3++=x) // dqrdqrdqrdqrdqrdqrdqr\r\n    #endif// fread in OJ, getchar in local dqrdqrdqrdqrdqrdqrdqr\r\n    #define isdigit(ch) (ch>47&&ch<58)//dqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define isspace(ch) (ch<=32&&ch!=EOF)//dqrdqrdqrdqrdqrdqrdqr\r\n    #define isseen(ch) (ch>32) // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    struct Octane_t{~Octane_t(){fwrite(obuf,p3-obuf, 1, stdout);\r\n    }bool flag=false;operator bool(){return flag;} }io; template\r\n    <typename T>inline T read(){T s=0; int w = 1; char ch; while\r\n    (ch=getchar(), !isdigit(ch)&&(ch!=EOF))if(ch == '-') w = -1;\r\n    if(ch == EOF) return 0; while(isdigit(ch)) s = s*10+ch-48,ch\r\n    =getchar(); return s *= w; } template<typename T>inline bool\r\n    read(T &s) { s = 0; int w = 1; char ch; while(ch = getchar()\r\n    ,!isdigit(ch)&&(ch!=EOF))if(ch == '-') w = -1; if(ch == EOF)\r\n    return false;while(isdigit(ch))s = s*10+ch-48, ch=getchar();\r\n    return s*=w,true;}inline bool read(char &s){while(s= getchar\r\n    (), isspace(s)); return s != EOF; } inline bool read(char *s\r\n    ){char ch=getchar();while(isspace(ch))ch= getchar();if(ch ==\r\n    EOF)return false;while(isseen(ch)) *s++ = ch, ch= getchar();\r\n    *s='\\000';return true;}template<typename T> void printv(T a)\r\n    {if(a== 0){ putchar('0'); return void(); }static char st[65]\r\n    ; int top = 0; if (a < 0) putchar ('-'), a = - a; while(a)st\r\n    [++top]='0'+a%10,a/=10;while(top)putchar(st[top--]);} inline\r\n    void printv(char c){putchar(c);}inline void printv(char *s){\r\n    for(int i=0;s[i];i++)putchar(s[i]);}inline void printv(const\r\n    char *s){ for(int i=0;s[i];i++) putchar(s[i]); } inline void\r\n    printv(bool a){ if(a != 0)putchar('1'); else putchar('0'); }\r\n    #ifdef _GLIBCXX_STRING // support for string dqrdqrdqrdqrdqr\r\n    inline bool read(std::string& s) { s = \"\"; char ch; while(ch\r\n    =getchar(), isspace(ch)); if(ch == EOF) return false; while(\r\n    !isspace(ch)) s+=ch,ch=getchar(); return true; } inline bool\r\n    getline(Octane_t &io,std::string s){s=\"\";char ch= getchar();\r\n    if(ch==EOF)return false;while(ch!='\\n' and ch !=EOF)s+=ch,ch\r\n    =getchar();return true;}inline void printv(const std::string\r\n    &a){for(auto i = a.begin(); i != a.end(); ++i) putchar(*i);}\r\n    #endif// dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    template<typename T>inline void print(const char *p,T first)\r\n    { int n = strlen(p) - 1; for(int i = 0; i <= n; i++) { if(p[\r\n    i] == '`') { putchar(p[++ i]); continue; } else if ( p[i] ==\r\n    '{'){printv(first); i++; continue; } else putchar(p[i]); } }\r\n    #if __cplusplus >= 201103L // support for many values dqrdqr\r\n    template<typename T,typename... T1>inline int read(T& a, T1&\r\n    ...other){return read(a)+read(other...); } inline void print\r\n    (const char *p) { printv(p); }template<typename T1, typename\r\n    ... T2>void print(const char*p, T1 first, T2 ...other) { int\r\n    n=strlen(p)-1; for(int i = 0; i <= n; i++) { if(p[i] == '`')\r\n    {putchar(p[++i]);continue;}else if(p[i]=='{'){printv(first);\r\n    print(p+i+2,other...);return void();}else putchar(p[i]); } }\r\n    #endif // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdq\r\n    template <typename T> Octane_t& operator >> (Octane_t &io, T\r\n    &b){return io.flag=read(b),io;}Octane_t& operator>>(Octane_t\r\n    &io, char *b){return io.flag=read(b), io;} template<typename\r\n    T>Octane_t&operator<<(Octane_t&io,T b){return printv(b),io;}\r\n    #define cout io// dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define cin io // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #define endl '\\n' // dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #undef ll// dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #undef db// dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n    #undef ldb//dqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqrdqr\r\n} using namespace Octane;\r\n\r\ntypedef long long ll;\r\ntypedef pair<ll,int> pii;\r\nconst int N = 1e5+10;\r\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\r\n\r\nnamespace graph {\r\n    struct edge {\r\n        int from, to; ll cost;\r\n        int next;\r\n    } e[N];\r\n    int head[N], ecnt;\r\n    void add_edge(int a, int b, ll cost)\r\n    {\r\n        e[++ecnt] = {a, b, cost, head[a]};\r\n        head[a] = ecnt;\r\n    }\r\n} using namespace graph;\r\n\r\nint n, m, q;\r\nbool vis[N];\r\nll dis[N], f[N];\r\n\r\nvoid heap_dij(int s);\r\nvoid bucket_dij(int s);\r\n\r\nint main()\r\n{\r\n    cin >> n >> m >> q;\r\n    for(int i = 1; i <= m; i++)\r\n    {\r\n        int a, b; ll w;\r\n        cin >> a >> b >> w;\r\n        add_edge(a, b, w);\r\n    }\r\n    \r\n    heap_dij(1);\r\n    \r\n    \r\n    for(int i = 1; i <= q; i++)\r\n    {\r\n        int opt; cin >> opt;\r\n        if(opt == 1)\r\n        {\r\n            int v; cin >> v;\r\n            cout << (dis[v] == INF ? -1 : dis[v]) << \"\\n\";\r\n        }\r\n        else\r\n        {\r\n            int c; cin >> c;\r\n            for(int j = 1; j <= c; j++)\r\n            {\r\n                int l; cin >> l;\r\n                e[l].cost++;\r\n            }\r\n            \r\n            bucket_dij(1);\r\n            for(int j = 1; j <= n; j++)\r\n                dis[j] = min(dis[j]+f[j], INF);\r\n        }\r\n    }\r\n}\r\n\r\nvoid heap_dij(int s)\r\n{\r\n    priority_queue<pii,vector<pii>,greater<pii>> q;\r\n    memset(dis, 0x3f, sizeof(dis));\r\n    memset(vis, 0, sizeof(vis));\r\n    q.emplace(0, s); dis[s] = 0;\r\n    while(!q.empty())\r\n    {\r\n        int x = q.top().second; q.pop();\r\n        if(vis[x]) continue; vis[x] = true;\r\n        for(int i = head[x]; i; i = e[i].next)\r\n        {\r\n            if(dis[e[i].to] > dis[x]+e[i].cost)\r\n            {\r\n                dis[e[i].to] = dis[x]+e[i].cost;\r\n                q.emplace(dis[e[i].to], e[i].to);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvector<int> t[N];\r\nvoid bucket_dij(int s)\r\n{\r\n    for(int i = 0; i <= n; i++) t[i].clear();\r\n    memset(vis, 0, sizeof(vis));\r\n    memset(f, 0x3f, sizeof(f));\r\n    t[0].emplace_back(s); f[s] = 0;\r\n    for(int d = 0; d <= n; d++)\r\n    {\r\n        while(!t[d].empty())\r\n        {\r\n            int x = t[d].back(); t[d].pop_back();\r\n            if(vis[x]) continue; vis[x] = true;\r\n            for(int i = head[x]; i; i = e[i].next)\r\n            {\r\n                ll cost = dis[x]+e[i].cost-dis[e[i].to];\r\n                if(f[e[i].to] > f[x]+cost)\r\n                {\r\n                    f[e[i].to] = f[x]+cost;\r\n                    if(f[e[i].to] <= n)\r\n                        t[f[e[i].to]].emplace_back(e[i].to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}