{
    "id": 234968271,
    "contestId": 313,
    "creationTimeSeconds": 1701280973,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 313,
        "index": "B",
        "name": "Ilya and Queries",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1100,
        "tags": [
            "dp",
            "implementation"
        ]
    },
    "author": {
        "contestId": 313,
        "members": [
            {
                "handle": "dasguptaayon55"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1369927800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "/*\r\n\r\n    Created by : Ayon Das Gupta\r\n\r\n*/\r\n\r\n#include <bits/stdc++.h>\r\n#define ll long long int\r\n#define ki(x) cout << x << '\\n'\r\nusing namespace std;\r\n#define N 101\r\nll a[N][N], I[N][N];\r\nll mod = 1e9 + 7;\r\n\r\n\r\nbool prime(ll n) {\r\n    if(n < 2) return false;\r\n    else if(n == 2 or n == 3) return true;\r\n    else if(n % 2 == 0) return false;\r\n    else {\r\n        for(int i=3; i*i <= n; i+=2) {\r\n            if(n%i == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nvoid sieve(vector<bool> &prime, ll limit) {\r\n    prime[0] = prime[1] = false;\r\n\r\n    for(int i=2; i*i<=limit; i++) {\r\n        if(prime[i]) {\r\n           for(int j=i*i; j<=limit; j+=i) {\r\n              prime[j] = false;\r\n           }\r\n        }\r\n    }\r\n}\r\n\r\nll findNearestPrime(vector<bool> &prime, ll n) {\r\n    while (!prime[n]) {\r\n        n--;\r\n    }\r\n    return n;\r\n}\r\n\r\nvoid primefact(ll n) {\r\n\r\n   for(int i=2; i*i<=n; i++) {\r\n      int ans = 0;\r\n       if(n%i == 0) {\r\n         ans++;\r\n          while(n%i==0) {\r\n             n /= i;\r\n          }\r\n         cout<<i<<\"^\"<<ans<<' ';\r\n       }\r\n     }\r\n    if(n>1) cout<<n<<\"^\"<<1<<'\\n';\r\n}\r\n\r\nll power(ll base,ll pow,ll mod) {\r\n    ll res = 1;\r\n\r\n    while(pow) {\r\n        if(pow%2) {\r\n            res = (res*base)%mod;\r\n            pow--;\r\n        }\r\n        else {\r\n            base = (base*base)%mod;\r\n            pow /= 2;\r\n        }\r\n    }\r\n   return res;\r\n}\r\n\r\nvoid mul(ll a[][N], ll b[][N], ll n) {\r\n    ll r[n+1][n+1];\r\n\r\n    for(int i=1; i<=n; i++) {\r\n        for(int j=1; j<=n; j++) {\r\n          r[i][j] = 0;\r\n            for(int k=1; k<=n; k++) {\r\n              ll x = (a[i][k]*b[k][j])%mod;\r\n              r[i][j] = (r[i][j]+x)%mod;\r\n            }\r\n        }\r\n    }\r\n\r\n    for(int i=1; i<=n; i++) {\r\n        for(int j=1; j<=n; j++) {\r\n            a[i][j] = r[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid matrixpower(ll a[][N], ll n, ll pow) {\r\n    for(int i=1; i<=n; i++) {\r\n        for(int j=1; j<=n; j++) {\r\n            if(i == j) I[i][j] = 1;\r\n            else I[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    while(pow) {\r\n        if(pow%2) {\r\n            mul(I,a,n);\r\n            pow--;\r\n        }\r\n        else {\r\n            mul(a,a,n);\r\n            pow /= 2;\r\n        }\r\n    }\r\n\r\n    for(int i=1; i<=n; i++) {\r\n        for(int j=1; j<=n; j++) {\r\n            a[i][j] = I[i][j];\r\n        }\r\n    }\r\n\r\n    for(int i=1; i<=n; i++) {\r\n        for(int j=1; j<=n; j++) {\r\n            cout<<a[i][j]<<' ';\r\n        }\r\n        cout<<'\\n';\r\n    }\r\n}\r\n\r\nvoid sieve2(ll n) {\r\n    bool ok = true, ok2 = true;\r\n    vector<int> ans;\r\n    int count=0;\r\n\r\n    while(n%2 == 0) {\r\n        count++;\r\n        ans.push_back(2);\r\n        n /= 2;\r\n    }\r\n    if(count>0) cout<<\"2^\"<<count<<\" \";\r\n\r\n    for(ll i=3; i*i<=n; i+=2) {\r\n        count=0;\r\n        while(n%i==0) {\r\n          count++;\r\n          ans.push_back(i);\r\n          n /= i;\r\n        }\r\n       if(count>0) cout<<i<<\"^\"<<count<<\" \";\r\n    }\r\n    if(n>1) cout<<n<<\"^\"<<1<<'\\n';\r\n }\r\n\r\n void number_of_divisors(int n) {\r\n     vector<int> ans;\r\n\r\n    for(int i=1; i*i<=n; i++) {\r\n        if(n%i == 0) {\r\n            ans.push_back(i);\r\n            if(i != n/i) ans.push_back(n/i);\r\n        }\r\n    }\r\n\r\n    for(auto &i : ans) cout<<i<<' ';\r\n }\r\n\r\n // If the first elements are equal, then sort by second element in decreasing order.\r\n auto cmp1 = [](const pair<int, int>& a, const pair<int, int>& b) {\r\n    return a.first < b.first || (a.first == b.first && a.second < b.second);\r\n };\r\n// If the first elements are equal, then sort by second element in increasing order.\r\n auto cmp2 = [](const pair<int, int>& a, const pair<int, int>& b) {\r\n    return a.first < b.first || (a.first == b.first && a.second > b.second);\r\n };\r\n\r\n // O(n^2) to O(nlogn) -->\r\nvoid binary_search(vector<int> &v, int l, int h, int x) {\r\n//First occurrence of binary search -> if(x == v[mid]) r = mid - 1;\r\n//Last occurrence of binary search -> if(x == v[mid]) l = mid + 1;\r\n// count = LO - FO + 1\r\n    int ans = 0;\r\n    while(l <= h) {\r\n        int mid = (l + h) / 2;\r\n\r\n        if(x >= v[mid]) l = mid + 1, ans = l;\r\n        if(x < v[mid]) h = mid - 1;\r\n    }\r\n\r\n    cout<<ans<<'\\n';\r\n}\r\n\r\nvoid prefix() {\r\n    int n,m;\r\n    cin>>n>>m;\r\n\r\n    int tmp = m, tmp2 = n;\r\n    if(tmp2 > tmp) swap(tmp,tmp2);\r\n    vector<int> v(n), pref(tmp,0);\r\n    for(int i=0; i<n; i++) cin>>v[i];\r\n\r\n    set<int> s;\r\n    for(int i=n - 1; i>=0; i--) {\r\n        s.insert(v[i]);\r\n        pref[i] = s.size();\r\n    }\r\n\r\n    while(m--) {\r\n        int x;\r\n        cin>>x;\r\n        cout<<pref[x - 1]<<'\\n';\r\n    }\r\n\r\n//    prefix sum -- >\r\n//\r\n//    vector<ll> pref(n + 1, 0);\r\n//\r\n//    for (int i = 0; i < n; ++i) {\r\n//          pref[i + 1] = pref[i] + a[i];\r\n//    }\r\n}\r\n\r\nvoid sliding_window() {\r\n    int n, k;\r\n    cin>>n>>k;\r\n\r\n    vector<int> v(n + 2);\r\n    for(int i=1; i<=n; i++) cin>>v[i];\r\n\r\n    ll sum = 0;\r\n    for(int i=1; i<=k; i++) sum += v[i];//4\r\n\r\n    int x = 1, ans = 1;\r\n    ll min1 = sum;\r\n    while(k < n) {\r\n        sum -= v[x];\r\n        ++x;//2\r\n        ++k;//4\r\n        sum += v[k];\r\n        if(sum < min1) {\r\n           ans = x;\r\n           min1 = sum;\r\n        }\r\n    }\r\n\r\n    cout << ans;\r\n}\r\n\r\nvoid kadanes_algorithm() {\r\n    int n, sum, max1;\r\n    vector<int> v(n+1,0);\r\n    for(int i=0; i<n; i++) cin>>v[i];\r\n\r\n//    int max1 = INT_MIN/LLONG_MIN (jodi a[i]=-1e9 hoy tkhn -1 dile kaaj hobe na), sum = 0;\r\n    for(int i=0; i<n; i++) {\r\n        sum += v[i];\r\n        max1 = max(max1, sum);\r\n\r\n        if(sum < 0 or (v[i]%2 and v[i+1]%2) or (v[i]%2==0 and v[i+1]%2==0) ) {\r\n              sum = 0;\r\n        }\r\n    }\r\n    cout<<max1<<'\\n';\r\n}\r\n\r\nauto cmp = [&](pair<ll,ll> &a, pair<ll,ll> &b) {\r\n             return (a.first+a.second > b.first+b.second);\r\n}; // semicolon must dewa lagbe\r\n\r\nvoid update() {\r\n    int w, count, ans;\r\n    vector<pair<int,int>> ans2;\r\n    bool ok = false;\r\n\r\n    for(auto &i:ans2) {\r\n        if(ans < w) {\r\n            count++;\r\n            ans += (i.first - i.second);\r\n            w -= i.second;;//29\r\n        }\r\n        if(ans >= w) {ok = true; break; }\r\n    }\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n// binary search,prefix sum,sliding window,kadane's algorithm\r\n// brute force,recursion,n - something, max,min chinta\r\n// number theory(sieve,prime,power,divisor)\r\n// two pointer approach,mp.find(i) != mp.end()\r\n// reverse array te chinta\r\n\r\n    string s;\r\n    cin>>s;\r\n    int n, count = 0;\r\n    cin>>n;\r\n\r\n    vector<int> pref(s.size(),0);\r\n    for(int i=0; i<s.size() - 1; i++) {\r\n        if(s[i] == s[i + 1])\r\n        count++;\r\n        pref[i + 1] = count;\r\n    }\r\n\r\n    while(n--) {\r\n        int l,r;\r\n        cin>>l>>r;\r\n        cout<<pref[r - 1] - pref[l - 1]<<'\\n';\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n///Before submit =>\r\n///    *check for integer overflow,array bounds\r\n///    *check for special case, n=1\r\n///    *prevent precision error round(sqrt(d - i * i)), powl();\r\n///    *try many different approach\r\n"
}