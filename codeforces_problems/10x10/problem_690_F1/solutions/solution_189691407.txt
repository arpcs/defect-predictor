{
    "id": 189691407,
    "contestId": 690,
    "creationTimeSeconds": 1674090050,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 690,
        "index": "F1",
        "name": "Tree of Life (easy)",
        "type": "PROGRAMMING",
        "rating": 1300,
        "tags": []
    },
    "author": {
        "contestId": 690,
        "members": [
            {
                "handle": "tranxuantruong"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1468137600
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 19,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 102400,
    "source": "/**\r\n  * Create: Thursday 2023-01-19-07.52.26 GMT+7\r\n  * Title : F1. Tree of Life (easy)\r\n  * Author:\r\n*****/\r\n\r\n\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#ifndef   MY_TEMPLATE\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const stack                 <T>         &stack_)                  {os <<   \"[\";     int n = (int) stack_.size();      vector <T> archive (n);    stack <T>                              stackCopy_ (stack_);   for (int i=0; i<n; ++i) {archive[stackCopy_.size()-1]=stackCopy_.top();       stackCopy_.pop();}     if (!archive.empty())      {for (auto it=archive.begin(); it!=archive.end()-1; ++it)    {os <<*it <<\", \";}     os <<archive.back();}     os <<\" \";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const queue                 <T>         &queue_)                  {os << \"->[\";     int n = (int) queue_.size();      vector <T> archive (n);    queue <T>                              queueCopy_ (queue_);   for (int i=0; i<n; ++i) {archive[queueCopy_.size()-1]=queueCopy_ .front();    queueCopy_.pop();}     if (!archive.empty())      {for (auto it=archive.begin(); it!=archive.end()-1; ++it)    {os <<*it <<\", \";}     os <<archive.back();}     os <<\" \";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const priority_queue        <T,vector<T>,greater<T>>&Queue_)      {os <<   \"[\";     int n = (int) Queue_.size();      vector <T> archive (n);    priority_queue<T,vector<T>,greater<T>> QueueCopy_ (Queue_);   for (int i=0; i<n; ++i) {archive[QueueCopy_.size()-1]=QueueCopy_.top();       QueueCopy_.pop();}     if (!archive.empty())      {for (auto it=archive.begin(); it!=archive.end()-1; ++it)    {os <<*it <<\", \";}     os <<archive.back();}     os <<\" \";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const priority_queue        <T>         &Queue_)                  {os <<   \"[\";     int n = (int) Queue_.size();      vector <T> archive (n);    priority_queue<T>                      QueueCopy_ (Queue_);   for (int i=0; i<n; ++i) {archive[QueueCopy_.size()-1]=QueueCopy_.top();       QueueCopy_.pop();}     if (!archive.empty())      {for (auto it=archive.begin(); it!=archive.end()-1; ++it)    {os <<*it <<\", \";}     os <<archive.back();}     os <<\" \";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const vector                <T>         &vector_)                 {os <<   \"[\";     if (!vector_  .empty())           {for (auto it = vector_  .begin(), i=0; i< (int) vector_   .size()-1; ++i, ++it)         {os <<*it <<\", \";}     os << * (vector_   .rbegin());}     os << \"]\";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const deque                 <T>         &deque_)                  {os <<   \"[\";     if (!deque_   .empty())           {for (auto it = deque_   .begin(), i=0; i< (int) deque_    .size()-1; ++i, ++it)         {os <<*it <<\", \";}     os << * (deque_    .rbegin());}     os << \"]\";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const set                   <T>         &set_)                    {os <<   \"[\";     if (!set_     .empty())           {for (auto it = set_     .begin(), i=0; i< (int) set_      .size()-1; ++i, ++it)         {os <<*it <<\", \";}     os << * (set_      .rbegin());}     os << \"]\";     return os;}\r\ntemplate <typename T>                           ostream& operator << (ostream& os, const multiset              <T>         &multiSet_)               {os <<   \"[\";     if (!multiSet_.empty())           {for (auto it = multiSet_.begin(), i=0; i< (int) multiSet_ .size()-1; ++i, ++it)         {os <<*it <<\", \";}     os << * (multiSet_ .rbegin());}     os << \"]\";     return os;}\r\ntemplate <typename T, typename _>               ostream& operator << (ostream& os, const map                   <T, _>      &map_)                    {os <<   \"[\";     if (!map_     .empty())           {for (auto it = map_     .begin(), i=0; i< (int) map_      .size()-1; ++i, ++it)         {os <<*it <<\", \";}     os << * (map_      .rbegin());}     os << \"]\";     return os;}\r\ntemplate <typename T, typename _>               ostream& operator << (ostream& os, const multimap              <T, _>      &multiMap_)               {os <<   \"[\";     if (!multiMap_.empty())           {for (auto it = multiMap_.begin(), i=0; i< (int) multiMap_ .size()-1; ++i, ++it)         {os <<*it <<\", \";}     os << * (multiMap_ .rbegin());}     os << \"]\";     return os;}\r\ntemplate <typename T, typename _>               ostream& operator << (ostream& os, const pair                  <T, _>      &pair_)                   {os <<   \"{\";                                                                                                                                {os <<pair_.first;     os <<\":\";   os <<pair_.second;}     os << \"}\";     return os;}\r\ntemplate <typename T>                           void     quick_debug (ostream& os, const char *name,           const T     &value)                   {os <<\"[DEBUG]\"   << name <<\" = \" <<value <<endl;};\r\ntemplate <typename T, typename... Args>         void     quick_debug (ostream& os, const char *name,           const T     &value, Args&&... args)   {os <<\"[DEBUG]\";  while (*name != ',')    {os << *name++;}     os << \" = \" << value << endl;    quick_debug (os, name + 1, args...);};\r\n#define  hien(...)                              quick_debug(cerr, \" \" #__VA_ARGS__, __VA_ARGS__)\r\n#define  endl                                   '\\n'\r\n#endif\r\n\r\n\r\nint main() {\r\n   ios_base::sync_with_stdio (0); cin.tie (0);\r\n\r\n   #define trying_to_make_a_lot_of_mistakes_when_allowed\r\n   #define int long long\r\n\r\n\r\n   int n; cin >> n;\r\n\r\n   vector <int> a(n+1);\r\n   for(int i=1; i<n; ++i){\r\n      int from; cin >> from;\r\n      int to; cin >> to;\r\n\r\n      a[from]+=1;\r\n      a[to]+=1;\r\n   }\r\n\r\n\r\n   int ans=0;\r\n   for(int i=1; i<=n; ++i){\r\n      ans+=(a[i])*(a[i]-1)/2;\r\n   }\r\n\r\n   cout <<ans <<endl;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   return 0;\r\n}\r\n"
}