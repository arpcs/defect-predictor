{
    "id": 196200147,
    "contestId": 117,
    "creationTimeSeconds": 1678066792,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 117,
        "index": "E",
        "name": "Tree or not Tree",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2900,
        "tags": [
            "data structures",
            "divide and conquer",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 117,
        "members": [
            {
                "handle": "CutSandstone"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1316790000
    },
    "programmingLanguage": "Java 11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 36,
    "timeConsumedMillis": 3056,
    "memoryConsumedBytes": 37376000,
    "source": "import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\tprivate static final String name = \"balance\";\r\n\tprivate static final int mod = 998244353, inf = Integer.MAX_VALUE;\r\n\tprivate static final int[][] d4 = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n\tprivate static final long inf2 = Long.MAX_VALUE;\r\n\tprivate static PrintWriter out;\r\n\tprivate static FastIO sc;\r\n\tprivate static long time = -1;\r\n\tprivate static long[] fact;\r\n\tprivate static int N, M;\r\n\tprivate static List<Integer>[][][] comp;\r\n\tprivate static int[][] pos, p, depth, par;\r\n\tprivate static int[] top;\r\n\tprivate static Flip[][] f;\r\n\tprivate static Flip up;\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\ttry {\r\n\t\t\tif(name.length() != 0 && new File(name+\".in\").exists()) {\r\n\t\t\t\tsc = new FastIO(name+\".in\");\r\n\t\t\t\tout = new PrintWriter(name+\".out\");\r\n\t\t\t}else if(new File(\"C:\\\\Users\\\\anaba\\\\eclipse-workspace\\\\test\\\\src\\\\main\\\\java\\\\input.in\").exists()){\r\n\t\t\t\tsc = new FastIO(\"C:\\\\Users\\\\anaba\\\\eclipse-workspace\\\\test\\\\src\\\\main\\\\java\\\\input.in\");\r\n\t\t\t\tif(args.length == 1 && args[0].equals(\"testingwithtestcases\"))\r\n\t\t\t\t\tout = new PrintWriter(\"C:\\\\Users\\\\anaba\\\\eclipse-workspace\\\\test\\\\src\\\\main\\\\java\\\\input.out\");\r\n\t\t\t\telse\r\n\t\t\t\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\r\n\t\t\t\ttime = System.currentTimeMillis();\r\n\t\t\t}else {\r\n\t\t\t\tsc = new FastIO(System.in);\r\n\t\t\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\r\n\t\t\t}\r\n\t\t}catch(SecurityException e) {\r\n\t\t\tsc = new FastIO(System.in);\r\n\t\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\r\n\t\t}\r\n\t\tN = sc.nextInt();\r\n\t\tM = sc.nextInt();\r\n\t\tint[][] eg = new int[N][2];\r\n\t\tDSU d = new DSU(N);\r\n\t\tList<Integer>[] g = new List[N];\r\n\t\tfor(int i = 0; i<N; i++) g[i] = new LinkedList<>();\r\n\t\tint[] ex = null;\r\n\t\tfor(int[] a: eg) {\r\n\t\t\ta[0] = sc.nextInt()-1;\r\n\t\t\ta[1] = sc.nextInt()-1;\r\n\t\t\tif(!d.unite(a[0], a[1])) ex = a;\r\n\t\t\telse {\r\n\t\t\t\tg[a[0]].add(a[1]);\r\n\t\t\t\tg[a[1]].add(a[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint[] d2 = getDepth(g, ex[0]);\r\n\t\ttop = new int[d2[ex[1]]+1];\r\n\t\ttop[0] = ex[0];\r\n\t\twhile(ex[0] != ex[1]) {\r\n\t\t\ttop[d2[ex[1]]] = ex[1];\r\n\t\t\tfor(int i: g[ex[1]]) if(d2[i] < d2[ex[1]]) {\r\n\t\t\t\tex[1] = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tList<Integer>[][] t = new List[top.length][];\r\n\t\tf = new Flip[top.length][];\r\n\t\tdepth = new int[top.length][];\r\n\t\tpar = new int[top.length][];\r\n\t\tpos = new int[N][2];\r\n\t\tup = new Flip(top.length);\r\n\t\tfor(int i = 0; i<top.length; i++) {\r\n\t\t\tint cnt = 1;\r\n\t\t\tfor(int j: g[top[i]]) if(j != top[(i+1)%top.length] && j != top[(i-1+top.length)%top.length])\r\n\t\t\t\tcnt+=getCNT(g, j, top[i]);\r\n\t\t\tt[i] = new List[cnt];\r\n\t\t\tfor(int j = 0; j<cnt; j++) t[i][j] = new LinkedList<>();\r\n\t\t\tpos[top[i]][0] = i;\r\n\t\t\tint x = 1;\r\n\t\t\tfor(int j: g[top[i]]) if(j != top[(i+1)%top.length] && j != top[(i-1+top.length)%top.length]) {\r\n\t\t\t\tx = fill(g, j, top[i], t[i], i, x);\r\n\t\t\t\tt[i][0].add(pos[j][1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcomp = new List[top.length][][];\r\n\t\tp = new int[top.length][];\r\n\t\tfor(int i = 0; i<top.length; i++) {\r\n\t\t\tdepth[i] = getDepth(t[i], 0);\r\n\t\t\tcomp[i] = treeComp(t[i]);\r\n\t\t\tp[i] = new int[t[i].length];\r\n\t\t\tf[i] = new Flip[comp[i][1].length];\r\n\t\t\tpar[i] = new int[f[i].length];\r\n\t\t\tfor(int j = 0; j<comp[i][1].length; j++) {\r\n\t\t\t\tfor(int k: comp[i][1][j])\r\n\t\t\t\t\tp[i][k] = j;\r\n\t\t\t\tf[i][j] = new Flip(comp[i][1][j].size()-(j == 0 ? 1:0));\r\n\t\t\t}\r\n\t\t\tArrays.fill(par[i], -1);\r\n\t\t\tfor(int j = 0; j<comp[i][0].length; j++)\r\n\t\t\t\tfor(int k: comp[i][0][j]) par[i][k] = j;\r\n\t\t}\r\n\t\tint ans = N;\r\n\t\tfor(int i = 0; i<M; i++) {\r\n\t\t\tint a = sc.nextInt()-1, b = sc.nextInt()-1;\r\n\t\t\tint t1 = pos[a][0], t2 = pos[b][0];\r\n\t\t\tint ind1 = pos[a][1], ind2 = pos[b][1];\r\n\t\t\tint c1 = p[t1][ind1], c2 = p[t2][ind2];\r\n\t\t\tint dis1 = depth[t1][ind1]-depth[t1][comp[t1][1][c1].get(0)], dis2 = depth[t2][ind2]-depth[t2][comp[t2][1][c2].get(0)];\r\n\t\t\tif(t1 == t2) {\r\n\t\t\t\tif(c1 == c2) {\r\n\t\t\t\t\tans+=f[t1][c1].count();\r\n\t\t\t\t\tf[t1][c1].flip(min(dis1, dis2)+(c1 == 0 ? 0:1), max(dis1, dis2)-(c1 == 0 ? 1:0));\r\n\t\t\t\t\tans-=f[t1][c1].count();\r\n\t\t\t\t}else {\r\n\t\t\t\t\tans+=f[t1][c1].count();\r\n\t\t\t\t\tans+=f[t2][c2].count();\r\n\t\t\t\t\tf[t1][c1].flip(0, dis1-(c1 == 0 ? 1:0));\r\n\t\t\t\t\tf[t2][c2].flip(0, dis2-(c2 == 0 ? 1:0));\r\n\t\t\t\t\tans-=f[t1][c1].count();\r\n\t\t\t\t\tans-=f[t2][c2].count();\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\tup.flip(min(t1, t2), max(t1, t2)-1);\r\n\t\t\t\tboolean cross;\r\n\t\t\t\tif(Math.abs(t1-t2) == top.length-Math.abs(t1-t2)) {\r\n\t\t\t\t\tboolean right = top[(t1+1)%top.length] < top[(t1-1+top.length)%top.length];\r\n\t\t\t\t\tif(right) cross = t1 > t2;\r\n\t\t\t\t\telse cross = t1 < t2;\r\n\t\t\t\t}else cross = Math.abs(t1-t2) > top.length-Math.abs(t1-t2);\r\n\t\t\t\tif(cross) up.flipAll();\r\n\t\t\t\tans+=f[t1][c1].count();\r\n\t\t\t\tans+=f[t2][c2].count();\r\n\t\t\t\tf[t1][c1].flip(0, dis1-(c1 == 0 ? 1:0));\r\n\t\t\t\tf[t2][c2].flip(0, dis2-(c2 == 0 ? 1:0));\r\n\t\t\t\tans-=f[t1][c1].count();\r\n\t\t\t\tans-=f[t2][c2].count();\r\n\t\t\t}\r\n\t\t\tfor(int curr = par[t1][c1]; curr != -1; curr = par[t1][curr]) {\r\n\t\t\t\tans+=f[t1][curr].count();\r\n\t\t\t\tf[t1][curr].flipAll();\r\n\t\t\t\tans-=f[t1][curr].count();\r\n\t\t\t}\r\n\t\t\tfor(int curr = par[t2][c2]; curr != -1; curr = par[t2][curr]) {\r\n\t\t\t\tans+=f[t2][curr].count();\r\n\t\t\t\tf[t2][curr].flipAll();\r\n\t\t\t\tans-=f[t2][curr].count();\r\n\t\t\t}\r\n\t\t\tSystem.out.println(ans-min(up.count(), top.length-1));\r\n\t\t}\r\n\t\tif(time != -1) System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");\r\n        out.close();\r\n\t}\r\n\tprivate static class Flip{\r\n\t\tboolean[] b;\r\n\t\tboolean all;\r\n\t\tpublic Flip(int N) {\r\n\t\t\tb = new boolean[N];\r\n\t\t\tall = true;\r\n\t\t}\r\n\t\tpublic void flip(int s, int e) {\r\n\t\t\tfor(int i = s; i<=e; i++) b[i] = !b[i];\r\n\t\t}\r\n\t\tpublic void flipAll() {\r\n\t\t\tall = !all;\r\n\t\t}\r\n\t\tpublic int count() {\r\n\t\t\tint ans = 0;\r\n\t\t\tfor(boolean x: b) if(x == all) ans++;\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t\tpublic String toString() {\r\n\t\t\tboolean[] x = new boolean[b.length];\r\n\t\t\tfor(int i = 0; i<b.length; i++) x[i] = b[i] == all;\r\n\t\t\treturn Arrays.toString(x);\r\n\t\t}\r\n\t}\r\n\tprivate static int fill(List<Integer>[] g, int s, int p, List<Integer>[] t, int v, int x) {\r\n\t\tpos[s][0] = v;\r\n\t\tpos[s][1] = x++;\r\n\t\tfor(int i: g[s]) if(i != p) {\r\n\t\t\tx = fill(g, i, s, t, v, x);\r\n\t\t\tt[pos[s][1]].add(pos[i][1]);\r\n\t\t}\r\n\t\treturn x;\r\n\t}\r\n\tprivate static int getCNT(List<Integer>[] g, int s, int p) {\r\n\t\tint ans = 1;\r\n\t\tfor(int i: g[s]) if(i != p) ans+=getCNT(g, i, s);\r\n\t\treturn ans;\r\n\t}\r\n\tprivate static List<List<Integer>> SCC(List<Integer>[] g) {\r\n\t\tint N = g.length;\r\n\t\tint[] disc = new int[N];\r\n\t\tint[] low = new int[N];\r\n\t\tArrays.fill(disc, -1);\r\n\t\tArrays.fill(low, -1);\r\n\t\tboolean stackMember[] = new boolean[N];\r\n\t\tLinkedList<Integer> st = new LinkedList<>();\r\n\t\tLinkedList<List<Integer>> ans = new LinkedList<>();\r\n\t\tans.add(new LinkedList<>());\r\n\t\tfor (int i = 0; i<N; i++)\r\n\t\t\tif (disc[i] == -1)\r\n\t\t\t\tSCCUtil(i, low, disc, stackMember, st, 0, g, ans);\r\n\t\tans.pollLast();\r\n\t\treturn ans;\r\n\t}private static int SCCUtil(int s, int[] low, int[] disc, boolean[] stackMember, LinkedList<Integer> st, int time, List<Integer>[] g, List<List<Integer>> ans) {\r\n\t\tdisc[s] = time;\r\n\t\tlow[s] = time;\r\n\t\ttime++;\r\n\t\tstackMember[s] = true;\r\n\t\tst.push(s);\r\n\t\tfor(int i: g[s]){\r\n\t\t\tif (disc[i] == -1) {\r\n\t\t\t\ttime = SCCUtil(i, low, disc, stackMember, st, time, g, ans);\r\n\t\t\t\tlow[s] = min(low[s], low[i]);\r\n\t\t\t} else if(stackMember[i] == true)\r\n\t\t\t\tlow[s] = min(low[s], disc[i]);\r\n\t\t}\r\n\t\tint w = -1;\r\n\t\tif (low[s] == disc[s]) {\r\n\t\t\twhile (w != s) {\r\n\t\t\t\tw = st.pop();\r\n\t\t\t\tans.get(ans.size()-1).add(w);\r\n\t\t\t\tstackMember[w] = false;\r\n\t\t\t}\r\n\t\t\tans.add(new LinkedList<>());\r\n\t\t}\r\n\t\treturn time;\r\n\t}\r\n\tprivate static int[] getDepth(List<Integer>[] g, int s) {\r\n\t\tint[] ans = new int[g.length];\r\n\t\tgetDepthDFS(g, s, -1, ans);\r\n\t\treturn ans;\r\n\t}private static void getDepthDFS(List<Integer>[] g, int s, int p, int[] depth) {\r\n\t\tfor(int i: g[s]) if(i != p) {\r\n\t\t\tdepth[i] = depth[s]+1;\r\n\t\t\tgetDepthDFS(g, i, s, depth);\r\n\t\t}\r\n\t}\r\n\tprivate static List<Integer>[][] treeComp(List<Integer>[] g){\r\n\t\tint N = g.length;\r\n\t\tif(N == 1) {\r\n\t\t\tList<Integer>[][] ans = new List[2][1];\r\n\t\t\tans[0][0] = new LinkedList<>();\r\n\t\t\tans[1][0] = new LinkedList<>();\r\n\t\t\tans[1][0].add(0);\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t\tint[] map = new int[N];\r\n\t\tint K = treeCompGetCount(g, 0, -1, map, 0);\r\n\t\tList<Integer>[][] ans = new List[2][K];\r\n\t\tfor(int i = 0; i<K; i++) {\r\n\t\t\tans[0][i] = new LinkedList<>();\r\n\t\t\tans[1][i] = new LinkedList<>();\r\n\t\t}\r\n\t\ttreeCompDFS(g, map, ans, 0);\r\n\t\treturn ans;\r\n\t}private static int treeCompGetCount(List<Integer>[] g, int s, int p, int[] map, int time) {\r\n\t\tg[s].remove((Integer)p);\r\n\t\tif(p == -1 || g[p].size() != 1) map[s] = time++; else map[s] = -1;\r\n\t\tfor(int i: g[s]) if(i != p) time = treeCompGetCount(g, i, s, map, time);\r\n\t\treturn time;\r\n\t}private static void treeCompDFS(List<Integer>[] g, int[] map, List<Integer>[][] ret, int s) {\r\n\t\tint curr = s;\r\n\t\twhile(g[curr].size() == 1) {\r\n\t\t\tret[1][map[s]].add(curr);\r\n\t\t\tcurr = g[curr].get(0);\r\n\t\t}\r\n\t\tret[1][map[s]].add(curr);\r\n\t\tfor(int i: g[curr]) {\r\n\t\t\tret[0][map[s]].add(map[i]);\r\n\t\t\ttreeCompDFS(g, map, ret, i);\r\n\t\t}\r\n\t}\r\n\tprivate static boolean hasCycle(List<Integer>[] g) {\r\n\t\tbyte[] vis = new byte[g.length];\r\n\t\tfor(int i = 0; i<g.length; i++) if(vis[i] == 0 && hasCycleHelper(g, i, vis)) return true;\r\n\t\treturn false;\r\n\t}private static boolean hasCycleHelper(List<Integer>[] g, int s, byte[] vis) {\r\n\t\tvis[s] = 1;\r\n\t\tfor(int i: g[s]) if(vis[i] == 1) return true;\r\n\t\telse if(vis[i] == 0 && hasCycleHelper(g, i, vis)) return true;\r\n\t\tvis[s] = 2;\r\n\t\treturn false;\r\n\t}\r\n\tprivate static void fact(int max) {\r\n\t\tfact = new long[max];\r\n\t\tfact[0] = 1;\r\n\t\tfor(int i = 1; i<max; i++) fact[i] = (fact[i-1]*i)%mod;\r\n\t}\r\n\tprivate static void print(long[] a) {\r\n\t\tSystem.out.println(Arrays.toString(a));\r\n\t}\r\n\tprivate static void print(int[] a) {\r\n\t\tSystem.out.println(Arrays.toString(a));\r\n\t}\r\n\tprivate static int max(int... x) {\r\n\t\tfor (int i = 1; i < x.length; i++)\r\n\t\t\tx[0] = Math.max(x[0], x[i]);\r\n\t\treturn x[0];\r\n\t}\r\n\tprivate static int min(int... x) {\r\n\t\tfor (int i = 1; i < x.length; i++)\r\n\t\t\tx[0] = Math.min(x[0], x[i]);\r\n\t\treturn x[0];\r\n\t}\r\n\tprivate static long max(long... x) {\r\n\t\tfor (int i = 1; i < x.length; i++)\r\n\t\t\tx[0] = Math.max(x[0], x[i]);\r\n\t\treturn x[0];\r\n\t}\r\n\tprivate static long min(long... x) {\r\n\t\tfor (int i = 1; i < x.length; i++)\r\n\t\t\tx[0] = Math.min(x[0], x[i]);\r\n\t\treturn x[0];\r\n\t}\r\n\tprivate static long[] minPath(int x, List<int[]>[] g) {\r\n\t\tlong[] l = new long[g.length];\r\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Long.compare(l[a], l[b]));\r\n\t\tArrays.fill(l, Long.MAX_VALUE);\r\n\t\tl[x] = 0;\r\n\t\tpq.add(x);\r\n\t\twhile (!pq.isEmpty()) {\r\n\t\t\tint c = pq.poll();\r\n\t\t\tfor (int[] a : g[c])\r\n\t\t\t\tif (l[a[0]] > l[c] + a[1]) {\r\n\t\t\t\t\tl[a[0]] = l[c] + a[1];\r\n\t\t\t\t\tpq.add(a[0]);\r\n\t\t\t\t}\r\n\t\t}\r\n\t\treturn l;\r\n\t}\r\n\tprivate static long inv(long x) {\r\n\t\treturn pow(x, mod - 2);\r\n\t}\r\n\tprivate static long pow(long x, long n) {\r\n\t\tassert (n >= 0);\r\n\t\tx %= mod;\r\n\t\tlong res = 1;\r\n\t\twhile (n > 0) {\r\n\t\t\tif ((n & 1) == 1)\r\n\t\t\t\tres = res * x % mod;\r\n\t\t\tx = x * x % mod;\r\n\t\t\tn >>= 1;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\tprivate static class BS {\r\n\t\tpublic interface Oper {\r\n\t\t\tboolean test(long num);\r\n\t\t}\r\n\r\n\t\tprivate BS() {\r\n\r\n\t\t}\r\n\r\n\t\tpublic static long last(long lo, long hi, Oper oper) {\r\n\t\t\tlo--;\r\n\t\t\twhile (lo < hi) {\r\n\t\t\t\tlong mid = lo + (hi - lo + 1) / 2;\r\n\t\t\t\tif (oper.test(mid)) {\r\n\t\t\t\t\tlo = mid;\r\n\t\t\t\t} else {\r\n\t\t\t\t\thi = mid - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn lo;\r\n\t\t}\r\n\r\n\t\tpublic static long first(long lo, long hi, Oper oper) {\r\n\t\t\thi++;\r\n\t\t\twhile (lo < hi) {\r\n\t\t\t\tlong mid = lo + (hi - lo) / 2;\r\n\t\t\t\tif (oper.test(mid)) {\r\n\t\t\t\t\thi = mid;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlo = mid + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn lo;\r\n\t\t}\r\n\t}\r\n\tprivate static class Merge<T> implements Iterable<T> {\r\n\t\tprivate class Node {\r\n\t\t\tpublic T num;\r\n\t\t\tpublic Node next = null;\r\n\r\n\t\t\tpublic Node(T num) {\r\n\t\t\t\tthis.num = num;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate class mergeIterator implements Iterator<T> {\r\n\t\t\tprivate Node s;\r\n\r\n\t\t\tpublic mergeIterator(Node s) {\r\n\t\t\t\tthis.s = s;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean hasNext() {\r\n\t\t\t\treturn s != null;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic T next() {\r\n\t\t\t\tT ret = s.num;\r\n\t\t\t\ts = s.next;\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate Node s, e;\r\n\t\tprivate int size;\r\n\r\n\t\tpublic Merge() {\r\n\t\t\ts = e = null;\r\n\t\t\tsize = 0;\r\n\t\t}\r\n\r\n\t\tpublic void addF(T n) {\r\n\t\t\tif (s == null)\r\n\t\t\t\ts = e = new Node(n);\r\n\t\t\telse {\r\n\t\t\t\tNode p = new Node(n);\r\n\t\t\t\tp.next = s;\r\n\t\t\t\ts = p;\r\n\t\t\t}\r\n\t\t\tsize++;\r\n\t\t}\r\n\r\n\t\tpublic void add(T n) {\r\n\t\t\tif (s == null)\r\n\t\t\t\ts = e = new Node(n);\r\n\t\t\telse {\r\n\t\t\t\te.next = new Node(n);\r\n\t\t\t\te = e.next;\r\n\t\t\t}\r\n\t\t\tsize++;\r\n\t\t}\r\n\r\n\t\tpublic void addAll(Merge<T> m) {\r\n\t\t\tif (m == this)\r\n\t\t\t\treturn;\r\n\t\t\tif (e == null)\r\n\t\t\t\ts = e = m.s;\r\n\t\t\telse\r\n\t\t\t\te.next = m.s;\r\n\t\t\te = m.e;\r\n\t\t\tsize += m.size;\r\n\t\t}\r\n\r\n\t\tpublic int size() {\r\n\t\t\treturn size;\r\n\t\t}\r\n\r\n\t\tpublic String toString() {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"[\");\r\n\t\t\tfor (T i : this)\r\n\t\t\t\tsb.append(i + \", \");\r\n\t\t\tif (sb.length() > 1)\r\n\t\t\t\tsb.delete(sb.length() - 2, sb.length());\r\n\t\t\tsb.append(\"]\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic Iterator<T> iterator() {\r\n\t\t\treturn new mergeIterator(s);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void clear() {\r\n\t\t\ts = e = null;\r\n\t\t\tsize = 0;\r\n\t\t}\r\n\t}\r\n\tprivate static class DSU {\r\n\t\tprivate static interface Oper {\r\n\t\t\tlong[] combine(long[] a, long[] b);\r\n\t\t}\r\n\t\tprivate long[][] vals;\r\n\t\tprivate int[] par, size;\r\n\t\tprivate Merge<Integer>[] all;\r\n\t\tprivate int cc;\r\n\t\tprivate Oper o;\r\n\t\tpublic DSU(int N, boolean storeAll) {this(N, null, storeAll);}\r\n\t\tpublic DSU(int N, Oper o) {this(N, o, false);}\r\n\t\tpublic DSU(int N) {this(N, null, false);}\r\n\t\tpublic DSU(int N, Oper o, boolean storeAll) {\r\n\t\t\tpar = new int[N];\r\n\t\t\tsize = new int[N];\r\n\t\t\tcc = N;\r\n\t\t\tArrays.fill(par, -1);\r\n\t\t\tArrays.fill(size, 1);\r\n\t\t\tthis.o = o;\r\n\t\t\tif(o != null) vals = new long[N][];\r\n\t\t\tif(storeAll) {\r\n\t\t\t\tall = new Merge[N];\r\n\t\t\t\tfor(int i = 0; i<N; i++) {\r\n\t\t\t\t\tall[i] = new Merge();\r\n\t\t\t\t\tall[i].add(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic long[] getVal(int num) {\r\n\t\t\treturn vals[get(num)];\r\n\t\t}\r\n\t\t\r\n\t\tpublic int size(int num) {\r\n\t\t\treturn size[get(num)];\r\n\t\t}\r\n\r\n\t\tpublic int get(int num) {\r\n\t\t\treturn par[num] == -1 ? num : (par[num] = get(par[num]));\r\n\t\t}\r\n\r\n\t\tpublic boolean isSame(int x, int y) {\r\n\t\t\treturn get(x) == get(y);\r\n\t\t}\r\n\r\n\t\tpublic boolean unite(int x, int y) {\r\n\t\t\tint p1 = get(x), p2 = get(y);\r\n\t\t\tif (p1 == p2)\r\n\t\t\t\treturn false;\r\n\t\t\tlong[] next = o == null ? new long[0]:o.combine(vals[p1], vals[p2]);\r\n\t\t\tMerge<Integer> a = all == null ? null:all[p1], b = all == null ? null:all[p2];\r\n\t\t\tif (size[p1] < size[p2]) {\r\n\t\t\t\tint s = p2;\r\n\t\t\t\tp2 = p1;\r\n\t\t\t\tp1 = s;\r\n\t\t\t\tMerge<Integer> v = a;\r\n\t\t\t\ta = b;\r\n\t\t\t\tb = v;\r\n\t\t\t}\r\n\t\t\tsize[p1] += size[p2];\r\n\t\t\tpar[p2] = p1;\r\n\t\t\tcc--;\r\n\t\t\tif(vals != null) vals[p1] = next;\r\n\t\t\tif(a != null)\r\n\t\t\t\ta.addAll(b);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tpublic int getCC() {\r\n\t\t\treturn cc;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void set(int num, long[] curr) {\r\n\t\t\tvals[get(num)] = curr;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Merge<Integer> getAll(int num) {\r\n\t\t\treturn all[get(num)];\r\n\t\t}\r\n\t}\r\n\tprivate static class Two<A, B> {\r\n\t\tpublic final A a;\r\n\t\tpublic final B b;\r\n\r\n\t\tpublic Two(A a, B b) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (!(obj instanceof Two))\r\n\t\t\t\treturn false;\r\n\t\t\tTwo curr = (Two) obj;\r\n\t\t\treturn curr.a.equals(a) && curr.b.equals(b);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tlong seed = a.hashCode();\r\n\t\t\tseed = seed << 32;\r\n\t\t\tseed |= b.hashCode();\r\n\t\t\tRandom r = new Random();\r\n\t\t\tr.setSeed(seed);\r\n\t\t\treturn r.nextInt();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\r\n\t\t}\r\n\t}\r\n\tprivate static class Cnt<T> {\r\n\r\n\t\tpublic TreeMap<T, Integer> map;\r\n\r\n\t\tpublic Cnt() {\r\n\t\t\tmap = new TreeMap<>();\r\n\t\t}\r\n\r\n\t\tpublic int get(T num) {\r\n\t\t\tInteger get = map.get(num);\r\n\t\t\tif (get == null)\r\n\t\t\t\treturn 0;\r\n\t\t\treturn get;\r\n\t\t}\r\n\r\n\t\tpublic void add(T num) {\r\n\t\t\tadd(num, 1);\r\n\t\t}\r\n\r\n\t\tpublic void rem(T num) {\r\n\t\t\tadd(num, -1);\r\n\t\t}\r\n\r\n\t\tpublic void rem(T num, int cnt) {\r\n\t\t\tadd(num, -cnt);\r\n\t\t}\r\n\r\n\t\tpublic void add(T num, int cnt) {\r\n\t\t\tInteger get = map.get(num);\r\n\t\t\tif (get == null)\r\n\t\t\t\tget = 0;\r\n\t\t\tget += cnt;\r\n\t\t\tif (get == 0)\r\n\t\t\t\tmap.remove(num);\r\n\t\t\telse\r\n\t\t\t\tmap.put(num, get);\r\n\t\t}\r\n\t}\r\n\tprivate static class RevBIT {\r\n\t\tprivate final long[] bit;\r\n\t\tprivate final long[] arr;\r\n\t\tprivate final int len;\r\n\r\n\t\tpublic RevBIT(int len) {\r\n\t\t\tbit = new long[len + 1];\r\n\t\t\tarr = new long[len];\r\n\t\t\tthis.len = len;\r\n\t\t}\r\n\r\n\t\tpublic void set(int ind, long val) {\r\n\t\t\tadd(ind, ind, val - prev(ind));\r\n\t\t}\r\n\r\n\t\tpublic void add(int s, int e, long val) {\r\n\t\t\tadd(s, val);\r\n\t\t\tif (e != len - 1)\r\n\t\t\t\tadd(e + 1, -val);\r\n\t\t}\r\n\r\n\t\tprivate void add(int ind, long val) {\r\n\t\t\tarr[ind] += val;\r\n\t\t\tind++;\r\n\t\t\tfor (; ind <= len; ind += ind & -ind)\r\n\t\t\t\tbit[ind] += val;\r\n\t\t}\r\n\r\n\t\tpublic long prev(int ind) {\r\n\t\t\treturn arr[ind];\r\n\t\t}\r\n\r\n\t\tpublic long get(int ind) {\r\n\t\t\tind++;\r\n\t\t\tlong sum = 0;\r\n\t\t\tfor (; ind > 0; ind -= ind & -ind)\r\n\t\t\t\tsum += bit[ind];\r\n\t\t\treturn sum;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\tStringBuilder ret = new StringBuilder();\r\n\t\t\tret.append(\"[\");\r\n\t\t\tfor (int i = 0; i < len; i++)\r\n\t\t\t\tret.append(get(i) + (i == len - 1 ? \"]\" : \", \"));\r\n\t\t\treturn ret.toString();\r\n\t\t}\r\n\t}\r\n\tprivate static class BIT {\r\n\t\tprivate final long[] bit;\r\n\t\tprivate final long[] arr;\r\n\t\tprivate final int len;\r\n\t\tprivate long all;\r\n\t\t\r\n\t\tpublic BIT(int len) {\r\n\t\t\tbit = new long[len + 1];\r\n\t\t\tarr = new long[len];\r\n\t\t\tthis.len = len;\r\n\t\t\tall = 0;\r\n\t\t}\r\n\t\t\r\n\t\tpublic long get(int ind) {\r\n\t\t\treturn arr[ind];\r\n\t\t}\r\n\r\n\t\tpublic void set(int ind, long val) {\r\n\t\t\tadd(ind, val - arr[ind]);\r\n\t\t}\r\n\r\n\t\tpublic void add(int ind, long val) {\r\n\t\t\tall+=val;\r\n\t\t\tarr[ind] += val;\r\n\t\t\tind++;\r\n\t\t\tfor (; ind <= len; ind += ind & -ind)\r\n\t\t\t\tbit[ind] += val;\r\n\t\t}\r\n\t\t\r\n\t\tpublic long suf(int ind) {\r\n\t\t\treturn all-(ind == 0 ? 0:prev(ind-1));\r\n\t\t}\r\n\t\t\r\n\t\tpublic long prev(int ind) {\r\n\t\t\tif(ind == len-1) return all;\r\n\t\t\tind++;\r\n\t\t\tlong sum = 0;\r\n\t\t\tfor (; ind > 0; ind -= ind & -ind)\r\n\t\t\t\tsum += bit[ind];\r\n\t\t\treturn sum;\r\n\t\t}\r\n\r\n\t\tpublic long sum(int a, int b) {\r\n\t\t\treturn prev(b) - (a == 0 ? 0 : prev(a - 1));\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\tStringBuilder ret = new StringBuilder();\r\n\t\t\tret.append(\"[\");\r\n\t\t\tfor(int i = 0; i<len; i++) ret.append(get(i)+(i == len-1 ? \"]\":\", \"));\r\n\t\t\treturn ret.toString();\r\n\t\t}\r\n\t}\r\n\tpublic static class AST {\r\n\t\tpublic interface Oper {\r\n\t\t\tlong[] solve(long[] a, long[] b);\r\n\t\t}\r\n\r\n\t\tprivate class Node {\r\n\t\t\tpublic long[] val;\r\n\t\t\tpublic Node p, le, ri;\r\n\t\t\tpublic int l, r;\r\n\r\n\t\t\tpublic Node(int l, int r) {\r\n\t\t\t\tthis.l = l;\r\n\t\t\t\tthis.r = r;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate final Oper oper;\r\n\t\tprivate final Node top;\r\n\t\tprivate final Node[] last;\r\n\r\n\t\tpublic AST(int n, Oper oper) {\r\n\t\t\tthis.oper = oper;\r\n\t\t\ttop = new Node(0, n - 1);\r\n\t\t\tlast = new Node[n];\r\n\t\t\tgetNode(top);\r\n\t\t}\r\n\r\n\t\tprivate void getNode(Node t) {\r\n\t\t\tif (t.l == t.r) {\r\n\t\t\t\tlast[t.l] = t;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint mid = (t.l + t.r) >> 1;\r\n\t\t\tt.le = new Node(t.l, mid);\r\n\t\t\tt.ri = new Node(mid + 1, t.r);\r\n\t\t\tgetNode(t.le);\r\n\t\t\tgetNode(t.ri);\r\n\t\t\tt.le.p = t.ri.p = t;\r\n\t\t}\r\n\r\n\t\tpublic void set(int k, long[] num) {\r\n\t\t\tNode t = last[k];\r\n\t\t\tt.val = num;\r\n\t\t\tt = t.p;\r\n\t\t\twhile (t != null) {\r\n\t\t\t\tif (t.le.val != null && t.ri.val != null)\r\n\t\t\t\t\tt.val = oper.solve(t.le.val, t.ri.val);\r\n\t\t\t\tt = t.p;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic long[] all() {\r\n\t\t\treturn top.val;\r\n\t\t}\r\n\r\n\t\tpublic long[] get(int a) {\r\n\t\t\treturn last[a].val;\r\n\t\t}\r\n\r\n\t\tpublic long[] get(int a, int b) {\r\n\t\t\tif (a == b)\r\n\t\t\t\treturn get(a);\r\n\t\t\treturn get(a, b, top);\r\n\t\t}\r\n\r\n\t\tprivate long[] get(int a, int b, Node n) {\r\n\t\t\tif (a == n.l && b == n.r)\r\n\t\t\t\treturn n.val;\r\n\t\t\tNode l = n.le, r = n.ri;\r\n\t\t\tif (l.l <= a && l.r >= b)\r\n\t\t\t\treturn get(a, b, l);\r\n\t\t\tif (r.l <= a && r.r >= b)\r\n\t\t\t\treturn get(a, b, r);\r\n\t\t\tlong[] left = get(a, l.r, l), right = get(r.l, b, r);\r\n\t\t\treturn oper.solve(left, right);\r\n\t\t}\r\n\t}\r\n\tpublic static class ST {\r\n\t\tpublic interface Oper {\r\n\t\t\tlong solve(long a, long b);\r\n\t\t}\r\n\r\n\t\tprivate long[] tree;\r\n\t\tpublic final int n;\r\n\t\tprivate final Oper oper;\r\n\t\tprivate final int def;\r\n\r\n\t\tpublic ST(int n, Oper oper, int def) {\r\n\t\t\tthis.n = n;\r\n\t\t\ttree = new long[n << 1];\r\n\t\t\tthis.oper = oper;\r\n\t\t\tthis.def = def;\r\n\t\t\tfor (int i = 0; i < n; i++)\r\n\t\t\t\tset(i, def);\r\n\t\t}\r\n\r\n\t\tpublic ST(int n, Oper oper) {\r\n\t\t\tthis(n, oper, 0);\r\n\t\t}\r\n\t\t\r\n\t\tpublic ST(int n) {\r\n\t\t\tthis(n, (a, b) -> Math.min(a, b), 0);\r\n\t\t}\r\n\t\t\r\n\t\tpublic long get(int a, int b) {\r\n\t\t\tif (a == b)\r\n\t\t\t\treturn tree[a + n];\r\n\t\t\tif (b < a)\r\n\t\t\t\treturn def;\r\n\t\t\ta += n;\r\n\t\t\tb += n;\r\n\t\t\tlong curr = 0;\r\n\t\t\tboolean checked = false;\r\n\t\t\twhile (a <= b) {\r\n\t\t\t\tif ((a & 1) == 1) {\r\n\t\t\t\t\tif (checked)\r\n\t\t\t\t\t\tcurr = oper.solve(curr, tree[a++]);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcurr = tree[a++];\r\n\t\t\t\t\tchecked = true;\r\n\t\t\t\t}\r\n\t\t\t\tif ((b & 1) == 0) {\r\n\t\t\t\t\tif (checked)\r\n\t\t\t\t\t\tcurr = oper.solve(curr, tree[b--]);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcurr = tree[b--];\r\n\t\t\t\t\tchecked = true;\r\n\t\t\t\t}\r\n\t\t\t\ta = a >> 1;\r\n\t\t\t\tb = b >> 1;\r\n\t\t\t}\r\n\t\t\treturn curr;\r\n\t\t}\r\n\r\n\t\tpublic void set(int index, long val) {\r\n\t\t\tindex += n;\r\n\t\t\ttree[index] = val;\r\n\t\t\tfor (index = index >> 1; index >= 1; index = index >> 1)\r\n\t\t\t\ttree[index] = oper.solve(tree[index << 1], tree[(index << 1) + 1]);\r\n\t\t}\r\n\r\n\t\tpublic long get(int index) {\r\n\t\t\treturn tree[index + n];\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"[\");\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tsb.append(get(i));\r\n\t\t\t\tif (i != n - 1)\r\n\t\t\t\t\tsb.append(\", \");\r\n\t\t\t}\r\n\t\t\tsb.append(\"]\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\t}\r\n\tpublic static class FastIO {\r\n\t\tInputStream dis;\r\n\t\tbyte[] buffer = new byte[500007];\r\n\t\tint pointer = 0, end = 0;\r\n\r\n\t\tpublic FastIO(String fileName) throws Exception {\r\n\t\t\tdis = new FileInputStream(fileName);\r\n\t\t}\r\n\r\n\t\tpublic FastIO(InputStream is) throws Exception {\r\n\t\t\tdis = is;\r\n\t\t}\r\n\r\n\t\tpublic int nextInt() throws Exception {\r\n\t\t\tint ret = 0;\r\n\t\t\tbyte b;\r\n\t\t\tdo {\r\n\t\t\t\tb = nextByte();\r\n\t\t\t} while (b <= ' ');\r\n\t\t\tboolean negative = false;\r\n\t\t\tif (b == '-') {\r\n\t\t\t\tnegative = true;\r\n\t\t\t\tb = nextByte();\r\n\t\t\t}\r\n\t\t\twhile (b >= '0' && b <= '9') {\r\n\t\t\t\tret = 10 * ret + b - '0';\r\n\t\t\t\tb = nextByte();\r\n\t\t\t}\r\n\t\t\treturn (negative) ? -ret : ret;\r\n\t\t}\r\n\r\n\t\tpublic long nextLong() throws Exception {\r\n\t\t\tlong ret = 0;\r\n\t\t\tbyte b;\r\n\t\t\tdo {\r\n\t\t\t\tb = nextByte();\r\n\t\t\t} while (b <= ' ');\r\n\t\t\tboolean negative = false;\r\n\t\t\tif (b == '-') {\r\n\t\t\t\tnegative = true;\r\n\t\t\t\tb = nextByte();\r\n\t\t\t}\r\n\t\t\twhile (b >= '0' && b <= '9') {\r\n\t\t\t\tret = 10 * ret + b - '0';\r\n\t\t\t\tb = nextByte();\r\n\t\t\t}\r\n\t\t\treturn (negative) ? -ret : ret;\r\n\t\t}\r\n\r\n\t\tprivate byte nextByte() throws Exception {\r\n\t\t\twhile (pointer >= end) {\r\n\t\t\t\tend = dis.read(buffer, 0, buffer.length);\r\n\t\t\t\tpointer = 0;\r\n\t\t\t}\r\n\t\t\treturn buffer[pointer++];\r\n\t\t}\r\n\r\n\t\tpublic double nextDouble() throws Exception {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tpublic String next() throws Exception {\r\n\t\t\tStringBuffer ret = new StringBuffer();\r\n\t\t\tbyte b;\r\n\t\t\tdo {\r\n\t\t\t\tb = nextByte();\r\n\t\t\t} while (b <= ' ');\r\n\t\t\twhile (b > ' ') {\r\n\t\t\t\tret.appendCodePoint(b);\r\n\t\t\t\tb = nextByte();\r\n\t\t\t}\r\n\t\t\treturn ret.toString();\r\n\t\t}\r\n\r\n\t\tpublic int[] nextArr() throws Exception {\r\n\t\t\treturn nextArr(nextInt());\r\n\t\t}\r\n\r\n\t\tpublic int[] nextArr(int len) throws Exception {\r\n\t\t\tint[] ans = new int[len];\r\n\t\t\tfor (int i = 0; i < len; i++)\r\n\t\t\t\tans[i] = nextInt();\r\n\t\t\treturn ans;\r\n\t\t}\r\n\r\n\t\tpublic List<Integer>[] nextTree() throws Exception {\r\n\t\t\treturn nextTree(nextInt());\r\n\t\t}\r\n\r\n\t\tpublic LinkedList<Integer>[] nextTree(int n) throws Exception {\r\n\t\t\treturn nextGraph(n, n - 1);\r\n\t\t}\r\n\r\n\t\tpublic LinkedList<Integer>[] nextGraph(int n, int m) throws Exception {\r\n\t\t\tLinkedList<Integer>[] ans = new LinkedList[n];\r\n\t\t\tfor (int i = 0; i < n; i++)\r\n\t\t\t\tans[i] = new LinkedList<>();\r\n\t\t\tfor (int i = 0; i < m; i++) {\r\n\t\t\t\tint a = nextInt() - 1, b = nextInt() - 1;\r\n\t\t\t\tans[a].add(b);\r\n\t\t\t\tans[b].add(a);\r\n\t\t\t}\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t\t\r\n\t\tpublic char[] chars() throws Exception {\r\n\t\t\treturn next().toCharArray();\r\n\t\t}\r\n\t}\r\n}"
}