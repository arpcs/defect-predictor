{
    "id": 236253494,
    "contestId": 1826,
    "creationTimeSeconds": 1701973900,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1826,
        "index": "A",
        "name": "Trust Nobody",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1200,
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1826,
        "members": [
            {
                "handle": "dilshar23"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1683297300
    },
    "programmingLanguage": "Java 17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 409600,
    "source": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.lang.reflect.Array;\r\nimport java.util.*;\r\n\r\npublic class Main16 {\r\n    static int mod = 1000_000_007;\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        DileepReader4 s = new DileepReader4();\r\n        int t = s.nextInt();\r\n\r\n        while (t-- > 0) {\r\n            int n = s.nextInt();\r\n            int[] arr = s.readIntegersAndGetPrimitiveArray(n);\r\n            boolean alleq = true;\r\n            for(int i:arr)alleq=alleq&&(arr[0]==i);\r\n            if(alleq && arr[0]==n){\r\n                System.out.println(-1);\r\n            }else{\r\n                Arrays.sort(arr);\r\n                System.out.println(n-1);\r\n            }\r\n        }\r\n    }\r\n\r\n    static boolean isVowel(char c) {\r\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\r\n    }\r\n\r\n\r\n    static boolean[] sieveOfEratosthenes(int n) {\r\n        boolean[] isPrime = new boolean[n + 1];\r\n        Arrays.fill(isPrime, true);\r\n        isPrime[1] = false;\r\n\r\n        for (int i = 2; i <= n; i++) {\r\n            if (!isPrime[i]) continue;\r\n            for (int j = i + i; j <= n; j += i)\r\n                isPrime[j] = false;\r\n        }\r\n        return isPrime;\r\n    }\r\n\r\n    static int countChildrenOfATree(int i, int par, ArrayList<Integer>[] adj, int[] chlds) {\r\n        chlds[i] = 1;\r\n        for (int ch : adj[i]) {\r\n            if (ch == par) continue;\r\n            chlds[i] += countChildrenOfATree(ch, i, adj, chlds);\r\n        }\r\n        return chlds[i];\r\n\r\n    }\r\n\r\n    static int[] sieveOfEratosthenesForPrimeFactors(int n) {\r\n        int[] lowestPrime = new int[n + 1];\r\n        for (int i = 1; i <= n; i++)\r\n            lowestPrime[i] = i;\r\n        for (int i = 2; i <= n; i += 2)\r\n            lowestPrime[i] = 2;\r\n        for (int i = 3; i <= n; i++) {\r\n            if (lowestPrime[i] != i) continue;\r\n            for (long j = 1l * i * i; j <= n; j += i) {\r\n                if (lowestPrime[(int) j] == j)\r\n                    lowestPrime[(int) j] = i;\r\n            }\r\n        }\r\n        return lowestPrime;\r\n    }\r\n\r\n\r\n    static class BinaryNode {\r\n        int val;\r\n        char v;\r\n        BinaryNode left, right;\r\n\r\n        public BinaryNode(int v) {\r\n            val = v;\r\n        }\r\n    }\r\n\r\n\r\n    static int gcd(int a, int b) {\r\n        if (b == 0) return a;\r\n        return gcd(b, a % b);\r\n    }\r\n\r\n    static boolean sameParity(int n1, int n2) {\r\n        return ((Math.abs(n1) % 2) == ((Math.abs(n2)) % 2));\r\n    }\r\n\r\n\r\n    static boolean isPrime(int n) {\r\n        for (int i = 2; i <= Math.sqrt(n); i++) {\r\n            if (n % i == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static boolean isPrime(long n) {\r\n        for (int i = 2; i <= Math.sqrt(n); i++) {\r\n            if (n % i == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    static boolean isPali(int n) {\r\n        return n == rev(n);\r\n    }\r\n\r\n    static int rev(int n) {\r\n        int ret = 0;\r\n        while (n > 0) {\r\n            ret = ret * 10 + n % 10;\r\n            n /= 10;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    static class DSU {\r\n        int[] par;\r\n        int[] siz;\r\n\r\n        DSU(int n) {\r\n            par = new int[n + 1];\r\n            siz = new int[n + 1];\r\n            for (int i = 0; i <= n; i++) par[i] = i;\r\n            Arrays.fill(siz, 1);\r\n\r\n        }\r\n\r\n\r\n        int fpar(int n) {\r\n            if (par[n] == n) return n;\r\n            return par[n] = fpar(par[n]);\r\n        }\r\n\r\n        void union(int n1, int n2) {\r\n            int p1 = fpar(n1);\r\n            int p2 = fpar(n2);\r\n            if (p1 == p2) return;\r\n            if (siz[p1] < siz[p2]) {\r\n                siz[p2] += siz[p1];\r\n                par[p1] = p2;\r\n            } else {\r\n                siz[p1] += siz[p2];\r\n                par[p2] = p1;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nclass TrieNum {\r\n    static class Node {\r\n        Node[] chlds;\r\n        int val;\r\n\r\n        Node() {\r\n            chlds = new Node[2];\r\n        }\r\n\r\n        Node(int val) {\r\n            chlds = new Node[2];\r\n            this.val = val;\r\n        }\r\n\r\n        boolean containsKey(int ind) {\r\n            return (chlds[ind] != null);\r\n        }\r\n    }\r\n\r\n    Node root;\r\n\r\n    TrieNum() {\r\n        root = new Node();\r\n    }\r\n\r\n\r\n    void insert(int n) {\r\n        Node cur = root;\r\n        for (int i = 31; i >= 0; i--) {\r\n            int ref = ((n >> i) & 1);\r\n            if (cur.chlds[ref] == null) {\r\n                cur.chlds[ref] = new Node();\r\n            }\r\n            cur = cur.chlds[ref];\r\n        }\r\n    }\r\n\r\n    int findMax(int num) {\r\n        int res = 0;\r\n        Node cur = root;\r\n        for (int i = 31; i >= 0; i--) {\r\n            int req = ((num >> i) & 1) == 1 ? 0 : 1;\r\n            if (cur.containsKey(req)) {\r\n                res = res | (1 << i);\r\n                cur = cur.chlds[req];\r\n            } else\r\n\r\n                cur = cur.chlds[1 - req];\r\n\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\nclass TrieChars {\r\n    static class Node {\r\n        Node[] chlds;\r\n        int val;\r\n\r\n        Node() {\r\n            chlds = new Node[26];\r\n            this.val = 1;\r\n        }\r\n\r\n        boolean containsKey(int ind) {\r\n            return (chlds[ind] != null);\r\n        }\r\n    }\r\n\r\n    Node root;\r\n\r\n    TrieChars() {\r\n        root = new Node();\r\n    }\r\n\r\n\r\n    void insert(String str) {\r\n        Node cur = root;\r\n        for (int i = 0; i < str.length(); i++) {\r\n            int curChar = str.charAt(i) - 'a';\r\n            if (cur.chlds[curChar] == null)\r\n                cur.chlds[curChar] = new Node();\r\n            else cur.chlds[curChar].val++;\r\n            cur = cur.chlds[curChar];\r\n        }\r\n    }\r\n\r\n    long countRev(String req) {\r\n\r\n        long totC = 0;\r\n        Node cur = root;\r\n        for (int i = 0; i < req.length(); i++) {\r\n            int curChar = req.charAt(i) - 'a';\r\n            if (cur.chlds[curChar] == null) break;\r\n            totC += cur.chlds[curChar].val;\r\n            cur = cur.chlds[curChar];\r\n        }\r\n        return totC;\r\n    }\r\n}\r\n\r\n\r\nclass DileepReader4 {\r\n    BufferedReader bf;\r\n\r\n    public DileepReader4() {\r\n        bf = new BufferedReader(new InputStreamReader(System.in));\r\n    }\r\n\r\n    String readLine() throws IOException {\r\n        return bf.readLine();\r\n    }\r\n\r\n    int[] readIntegersAndGetPrimitiveArray(int n) throws IOException {\r\n        String[] str = bf.readLine().split(\" \");\r\n        int[] ret = new int[n];\r\n        for (int i = 0; i < str.length; i++) {\r\n            ret[i] = Integer.parseInt(str[i]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    ArrayList<Integer> readIntegersAndGetList(int n) throws IOException {\r\n        String[] str = bf.readLine().split(\" \");\r\n        ArrayList<Integer> ret = new ArrayList<>(n);\r\n        for (int i = 0; i < str.length; i++) {\r\n            ret.set(i, Integer.parseInt(str[i]));\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    long[] readLongsAndGetPrimitiveArray(int n) throws IOException {\r\n        String[] str = bf.readLine().split(\" \");\r\n        long[] ret = new long[n];\r\n        for (int i = 0; i < str.length; i++) {\r\n            ret[i] = Long.parseLong(str[i]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    //    Reads Line\r\n    int nextInt() throws IOException {\r\n        return Integer.parseInt(bf.readLine().trim());\r\n    }\r\n\r\n    String nextLine() throws IOException {\r\n        return bf.readLine();\r\n    }\r\n\r\n    long nextLong() throws IOException {\r\n\r\n        return Long.parseLong(bf.readLine());\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass SegmentTree1 {\r\n    Node root;\r\n\r\n    public SegmentTree1(int[] nums) {\r\n        root = createTree(nums, 0, nums.length - 1);\r\n    }\r\n\r\n    public void update(int index, int val) {\r\n        root.data = update(root, index, val);\r\n    }\r\n\r\n    private int update(Node n, int i, int v) {\r\n        if (i >= n.s && i <= n.e) {\r\n            if (i == n.s && i == n.e) {\r\n                n.data = v;\r\n                return v;\r\n            }\r\n            int left = update(n.left, i, v);\r\n            int right = update(n.right, i, v);\r\n            n.data = left + right;\r\n            return n.data;\r\n        }\r\n        return n.data;\r\n    }\r\n\r\n    public int sumRange(int left, int right) {\r\n        return sum(root, left, right);\r\n    }\r\n\r\n    public boolean sumExists(int left, int right, int req) {\r\n        if (left > right) return false;\r\n        if (left == right) {\r\n            return sumRange(left, right) == req;\r\n        }\r\n        if (sumRange(left, right) == req) return true;\r\n        if (sumRange(left, right) < req) return false;\r\n        int mid = left + (right - left) / 2;\r\n        return sumExists(left, mid, req) || sumExists(mid + 1, right, req);\r\n\r\n    }\r\n\r\n    private int sum(Node n, int l, int r) {\r\n        if (n.e < l || n.s > r) return 0;\r\n        if (n.s >= l && n.e <= r) return n.data;\r\n\r\n        return sum(n.left, l, r) + sum(n.right, l, r);\r\n    }\r\n\r\n    private Node createTree(int[] nums, int s, int e) {\r\n        if (s == e) {\r\n            Node leaf = new Node(s, e);\r\n            leaf.data = nums[s];\r\n\r\n            return leaf;\r\n        }\r\n        int m = s + (e - s) / 2;\r\n        Node left = createTree(nums, s, m);\r\n        Node right = createTree(nums, m + 1, e);\r\n        Node cur = new Node(s, e);\r\n        cur.left = left;\r\n        cur.right = right;\r\n        cur.data = left.data + right.data;\r\n        return cur;\r\n    }\r\n\r\n\r\n    static class Node {\r\n        int data;\r\n        int s, e;\r\n        Node left, right;\r\n\r\n        Node(int s, int e) {\r\n            this.s = s;\r\n            this.e = e;\r\n        }\r\n    }\r\n}\r\n\r\n"
}