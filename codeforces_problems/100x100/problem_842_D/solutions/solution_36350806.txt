{
    "id": 36350806,
    "contestId": 842,
    "creationTimeSeconds": 1521282304,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 842,
        "index": "D",
        "name": "Vitya and Strange Lesson",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "binary search",
            "data structures"
        ]
    },
    "author": {
        "contestId": 842,
        "members": [
            {
                "handle": "Hepic_Antony_Skarlatos"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1504019100
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 592,
    "memoryConsumedBytes": 20377600,
    "source": "/*\r\nID: hepic\r\nPROG: sabotage\r\nLANG: C++11\r\n*/\r\n#include <bits/stdc++.h>\r\n\r\n#define FOR(i, a, b) for(auto i=a; i<=b; ++i)\r\n#define REP(i, a, b) for(auto i=a; i<b; ++i)\r\n#define FORI(i, a, b) for(auto i=a; i!=b+1-2*(a>b); i+=1-2*(a>b))\r\n#define REPI(i, a, b) for(auto i=a-(a>b); i!=b-(a>b); i+=1-2*(a>b))\r\n#define ALL(v) v.begin(),v.end()\r\n#define mp(a, b) make_pair(a, b)\r\n#define pb(a) push_back(a)\r\n#define pf(a) push_front(a)\r\n#define eb(a, b) emplace_back(a, b)\r\n#define fir first\r\n#define sec second\r\n#define what_is(x) cout<<#x<<\" is \"<<x<<endl;\r\n#define type(x) typeid(x).name()\r\n#define ms(arr, val) memset(arr, val, sizeof(arr))\r\n#define min3(a,b,c) min(min(a,b),c)\r\n#define max3(a,b,c) max(max(a,b),c)\r\n#define PI acos(-1)\r\n#define open_read1 freopen(\"a.txt\", \"r\", stdin)\r\n#define open_write1 freopen(\"b.xt\", \"w\", stdout)\r\n#define open_read freopen(\"dirtraverse.in\", \"r\", stdin)\r\n#define open_write freopen(\"dirtraverse.out\", \"w\", stdout)\r\n\r\nusing namespace std;\r\n\r\ntypedef long long LL;\r\ntypedef long double LD;\r\ntypedef unsigned long long ULL;\r\ntypedef pair<double, double> PDD;\r\ntypedef pair<int, int> PII;\r\ntypedef pair<int, PII> PIPII;\r\ntypedef pair<PII, PII> PPIIPII;\r\ntypedef pair<LL, LL> PLL;\r\ntypedef pair<ULL, ULL> PUU;\r\ntypedef pair<LL, PLL> PLPLL;\r\ntypedef pair<PLL, PLL> PPLLPLL;\r\ntypedef pair<int, LL> PIL;\r\ntypedef pair<LL, int> PLI;\r\n\r\n\r\ntemplate<typename T, typename T1>\r\nostream& operator << (ostream &out, pair<T, T1> obj)\r\n{\r\n    out << \"(\" << obj.first << \", \" << obj.second << \")\";\r\n    return out;\r\n}\r\n\r\n\r\ntemplate<typename T, typename T1>\r\nostream& operator << (ostream &out, map<T, T1> cont)\r\n{\r\n    typename map<T, T1>::const_iterator itr = cont.begin();\r\n    typename map<T, T1>::const_iterator ends = cont.end();\r\n\r\n    for(; itr!=ends; ++itr)\r\n        out<<*itr<<\" \";\r\n    out<<endl;\r\n\r\n    return out;\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nostream& operator << (ostream &out, set<T> cont)\r\n{\r\n    typename set<T>::const_iterator itr = cont.begin();\r\n    typename set<T>::const_iterator ends = cont.end();\r\n\r\n    for(; itr!=ends; ++itr)\r\n        out<<*itr<<\" \";\r\n    out<<endl;\r\n\r\n    return out;\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nostream& operator << (ostream &out, multiset<T> cont)\r\n{\r\n    typename multiset<T>::const_iterator itr = cont.begin();\r\n    typename multiset<T>::const_iterator ends = cont.end();\r\n\r\n    for(; itr!=ends; ++itr)\r\n        out<<*itr<<\" \";\r\n    out<<endl;\r\n\r\n    return out;\r\n}\r\n\r\n\r\ntemplate<typename T, template<typename ELEM, typename ALLOC=allocator<ELEM>> class CONT>\r\nostream& operator << (ostream &out, CONT<T> cont)\r\n{\r\n    typename CONT<T>::const_iterator itr = cont.begin();\r\n    typename CONT<T>::const_iterator ends = cont.end();\r\n\r\n    for(; itr!=ends; ++itr)\r\n        out<<*itr<<\" \";\r\n    out<<endl;\r\n\r\n    return out;\r\n}\r\n\r\n\r\ntemplate<typename T, unsigned int N, typename CTy, typename CTr>\r\ntypename enable_if<!is_same<T, char>::value, basic_ostream<CTy, CTr> &>::type\r\noperator << (basic_ostream<CTy, CTr> &out, const T (&arr)[N])\r\n{\r\n     REP(i, 0, N)\r\n        out<<arr[i]<<\" \";\r\n    out<<endl;\r\n\r\n    return out;\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nT gcd(T a, T b)\r\n{\r\n    T min_v = min(a, b);\r\n    T max_v = max(a, b);\r\n\r\n    while(min_v)\r\n    {\r\n        T temp = max_v % min_v;\r\n        max_v = min_v;\r\n        min_v = temp;\r\n    }\r\n\r\n    return max_v;\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nT lcm(T a, T b)\r\n{\r\n    return (a*b) / gcd(a, b);\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nT fast_exp_pow(T base, T exp, T mod)\r\n{\r\n    T res = 1;\r\n\r\n    while(exp)\r\n    {\r\n        if(exp&1)\r\n        {\r\n            res *= base;\r\n            res %= mod;\r\n        }\r\n\r\n        exp >>= 1;\r\n        base *= base;\r\n        base %= mod;\r\n\r\n    }\r\n\r\n    return res % mod;\r\n}\r\n\r\n/*#################################################################################################################\r\n#################################################################################################################\r\n################################################################################################################\r\n#################################################################################################################*/\r\n\r\n#define SIZE 300010\r\n#define HEIGHT 20\r\n\r\nint N, M, X;\r\nint numbers[SIZE], depXors[SIZE];\r\n\r\nstruct Trie {\r\n    Trie *children[2];\r\n    int subSize;\r\n    \r\n    Trie() {\r\n        children[0] = children[1] = NULL;\r\n        subSize = 1;\r\n    }\r\n\r\n    void addNumber(int num) {\r\n        vector<int> digits;\r\n        \r\n        while (num) {\r\n            digits.pb(num & 1);\r\n            num >>= 1;\r\n        }\r\n\r\n        REP (i, digits.size(), HEIGHT) {\r\n            digits.pb(0);\r\n        }\r\n        \r\n        reverse(ALL(digits));\r\n        Trie *node = this;\r\n\r\n        for (auto dig: digits) {\r\n            if (node->children[dig] != NULL) {\r\n                node = node->children[dig];\r\n            } else {\r\n                node->children[dig] = new Trie();\r\n                node = node->children[dig];\r\n            }\r\n        }\r\n    }\r\n\r\n    void calcSubSizes(Trie *node) {\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n        \r\n        REP (i, 0, 2) {\r\n            if (node->children[i] == NULL) {\r\n                continue;\r\n            }\r\n\r\n            calcSubSizes(node->children[i]);\r\n            node->subSize += node->children[i]->subSize;\r\n        }\r\n    }\r\n\r\n    int solve() {\r\n        Trie *node = this;\r\n        int dep = 0, num = 0;\r\n        \r\n        while (1) {\r\n            int zeroFull = (1 << (HEIGHT - dep)) - 1;\r\n            int zeroInd = 0, oneInd = 1;\r\n\r\n            if (depXors[dep] == 1) {\r\n                swap(zeroInd, oneInd);\r\n            }\r\n\r\n            if (node->children[zeroInd] == NULL) {\r\n                break;\r\n            }\r\n\r\n            if (node->children[zeroInd]->subSize < zeroFull) {\r\n                node = node->children[zeroInd];\r\n            } else {\r\n                num += (1 << (HEIGHT - dep - 1));\r\n                \r\n                if (node->children[oneInd] != NULL) {\r\n                    node = node->children[oneInd];\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            ++dep;\r\n        }\r\n\r\n        return num;\r\n    }\r\n\r\n} trie;\r\n\r\n\r\nint main() {\r\n    scanf(\"%d%d\", &N, &M);\r\n\r\n    REP (i, 0, N) {\r\n        scanf(\"%d\", numbers + i);\r\n        trie.addNumber(numbers[i]);\r\n    }\r\n    \r\n    trie.calcSubSizes(&trie);\r\n    \r\n    while (M--) {\r\n        scanf(\"%d\", &X);\r\n        vector<int> digits;\r\n        \r\n        while (X) {\r\n            digits.pb(X & 1);\r\n            X >>= 1;\r\n        }\r\n\r\n        REP (i, digits.size(), HEIGHT) {\r\n            digits.pb(0);\r\n        }\r\n        \r\n        reverse(ALL(digits));\r\n\r\n        REP (i, 0, HEIGHT) {\r\n            depXors[i] ^= digits[i];\r\n        }\r\n\r\n        printf(\"%d\\n\", trie.solve());\r\n    }\r\n\r\n    return 0;\r\n}"
}