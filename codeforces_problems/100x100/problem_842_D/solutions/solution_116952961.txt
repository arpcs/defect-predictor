{
    "id": 116952961,
    "contestId": 842,
    "creationTimeSeconds": 1621623438,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 842,
        "index": "D",
        "name": "Vitya and Strange Lesson",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "binary search",
            "data structures"
        ]
    },
    "author": {
        "contestId": 842,
        "members": [
            {
                "handle": "_prabhakar_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1504019100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 78,
    "memoryConsumedBytes": 12800000,
    "source": "// time-limit: 2000\r\n// problem-url: https://codeforces.com/group/1rv4rhCsHp/contest/321292/problem/D\r\n\r\n//#pragma GCC optimize (\"O3\")\r\n//#pragma GCC target (\"sse4\")\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nnamespace FastIO {\r\n    struct Reader {\r\n    private:\r\n        FILE* file; std::vector<char> buffer; int pos; bool was;\r\n        void read() {\r\n            if (!buffer.empty()) {\r\n                buffer.resize(fread(&buffer[0], 1, (int)buffer.size(), file)); pos = 0; \r\n            }\r\n        }\r\n    public:\r\n        Reader(FILE* file_ = stdin, const int size_ = 1 << 16)\r\n            : file(file_), buffer(size_, '\\0'), pos(size_), was(true) { }\r\n        operator bool() const { return was; }\r\n        char getChar() {\r\n            if (pos == (int)buffer.size()) { read(); }\r\n            if (pos == (int)buffer.size()) { was = false; return EOF; } \r\n            else { was = true; return buffer[pos++]; }\r\n        }\r\n        std::string getStr() {\r\n            char c = ' ';\r\n            while (std::isspace(c)) { c = getChar(); }\r\n            std::string answ;\r\n            while (c != EOF && !std::isspace(c)) { answ.push_back(c); c = getChar(); }\r\n            was = !answ.empty();\r\n            return answ;\r\n        }\r\n        std::string getLine() {\r\n            char c = '\\n';\r\n            while (c == '\\n') { c = getChar(); }\r\n            std::string answ;\r\n            while (c != '\\n' && c != EOF) { answ.push_back(c); c = getChar(); }\r\n            was = !answ.empty();\r\n            return answ;\r\n        }\r\n        template<typename T> T getInt() {\r\n            char c = '?';\r\n            while (!(c == '-' || ('0' <= c && c <= '9') || c == EOF)) { c = getChar(); }\r\n            bool positive = true;\r\n            if (c == '-') { positive = false; c = getChar(); }\r\n            T answ(0);\r\n            bool flag = false;\r\n            while ('0' <= c && c <= '9') { flag = true; (answ *= 10) += (c - '0'); c = getChar(); }\r\n            was = flag;\r\n            return positive ? answ : -answ;\r\n        }\r\n        template<typename T> T getReal() {\r\n            bool flag = false;\r\n            char c = '?';\r\n            while (!(c == '-' || ('0' <= c && c <= '9') || c == EOF)) { c = getChar(); }\r\n            bool positive = (c != '-');\r\n            if (c == '-') { c = getChar(); }\r\n            long long first = 0;\r\n            while ('0' <= c && c <= '9') { flag = true; (first *= 10) += (c - '0'); c = getChar(); }\r\n            was = flag;\r\n            if (c != '.') { return T(positive ? first : -first); }\r\n            c = getChar();\r\n            long long second = 0, pow = 1;\r\n            while ('0' <= c && c <= '9') { (second *= 10) += (c - '0'); c = getChar(); pow *= 10; }\r\n            T answ = first + (T)second / (T)pow;\r\n            return positive ? answ : -answ;\r\n        }\r\n    };\r\n    \r\n    Reader& operator>>(Reader& reader, char& c) { return c = reader.getChar(), reader; }\r\n    \r\n    Reader& operator>>(Reader& reader, std::string& s) { return s = reader.getStr(), reader; }\r\n    \r\n    template<class T> typename std::enable_if<std::is_floating_point<T>::value, Reader&>::type\r\n    operator>>(Reader& reader, T& t) { return t = reader.getReal<T>(), reader; }\r\n    \r\n    template<class T> typename std::enable_if<std::is_integral<T>::value, Reader&>::type\r\n    operator>>(Reader& reader, T& t) { return t = reader.getInt<T>(), reader; }\r\n    \r\n    template<class T> Reader& operator>>(Reader& reader, std::vector<T>& vec) {\r\n        for (auto &it : vec) { reader >> it; }\r\n        return reader;\r\n    }\r\n    \r\n    struct Writer {\r\n    private:\r\n        FILE* file; std::vector<char> buffer; int pos;\r\n        int defaultPrecision, defaultWidth; char defaultFill;\r\n    public:\r\n        Writer(FILE* file_ = stdout, const int size_ = 1 << 16) \r\n            : file(file_), buffer(size_, '\\0'), pos(0), defaultPrecision(6), defaultWidth(0), defaultFill(' ') { }\r\n        ~Writer() { flush(); }\r\n        void flush() { putChar(EOF); }\r\n        void setprecision(int precision) { defaultPrecision = precision; }\r\n        void setw(int width) { defaultWidth = width; }\r\n        void setfill(char fill) { defaultFill = fill; }\r\n        int getPrecision() const { return defaultPrecision; }\r\n        int getWidth() const { return defaultWidth; }\r\n        char getFill() const { return defaultFill; }\r\n        void putChar(char c) {\r\n            if (pos == (int)buffer.size() || c == EOF) { \r\n                fwrite(&buffer[0], 1, pos, file); pos = 0; \r\n            }\r\n            if (c != EOF) { buffer[pos++] = c; }\r\n        }\r\n        void putStr(const std::string& s) { for (auto it : s) putChar(it); }\r\n        template<typename T> void putInt(T value, int width = 0, char fill = ' ') {\r\n            bool positive = !(value < 0);\r\n            if (value < 0) { value = -value; }\r\n            char buf[24]; int p = 0;\r\n            do { buf[p++] = char(value % 10 + '0'); value /= 10; } while (value > 0);\r\n            if (!positive) { buf[p++] = '-'; }\r\n            while (p < width) buf[p++] = fill;\r\n            while (p > 0) putChar(buf[--p]);\r\n        }\r\n        template<typename T> void putReal(T value, int precision = 6, int width = 0, char fill = ' ') {\r\n            putInt((long long)value, width - precision - 1, fill);\r\n            value = std::abs(value-(long long)value);\r\n            if (precision == 0) { return; }\r\n            putChar('.');\r\n            #define PRINT_PART(cnt, pow) \\\r\n                while (precision >= cnt) { \\\r\n                    value *= pow; \\\r\n                    putInt((int)value, cnt, '0'); \\\r\n                    value -= (int)value; \\\r\n                    precision -= cnt; \\\r\n                }\r\n            PRINT_PART(6,1000000)\r\n            PRINT_PART(3,1000)\r\n            PRINT_PART(1,10)\r\n            #undef PRINT_PART\r\n        }\r\n    };\r\n    \r\n    Writer& operator<<(Writer& writer, const char c) { return writer.putChar(c), writer; }\r\n    \r\n    Writer& operator<<(Writer& writer, const std::string& s) { return writer.putStr(s), writer; }\r\n    \r\n    template<class T> typename std::enable_if<std::is_floating_point<T>::value, Writer&>::type\r\n    operator<<(Writer& writer, const T& t) {\r\n        writer.putReal(t, writer.getPrecision(), writer.getWidth(), writer.getFill());\r\n        return writer; \r\n    }\r\n    \r\n    template<class T> typename std::enable_if<std::is_integral<T>::value, Writer&>::type\r\n    operator<<(Writer& writer, const T& t) { \r\n        writer.putInt(t, writer.getWidth(), writer.getFill());\r\n        return writer;\r\n    }\r\n}\r\n\r\nstring to_string(bool b) {\r\n  return (b ? \"true\" : \"false\");\r\n}\r\n \r\ntemplate <size_t N>\r\nstring to_string(bitset<N> v) {\r\n  string res = \"\";\r\n  for (size_t i = 0; i < N; i++) {\r\n    res += static_cast<char>('0' + v[i]);\r\n  }\r\n  return res;\r\n}\r\n \r\ntemplate <typename A>\r\nstring to_string(A v) {\r\n  bool first = true;\r\n  string res = \"{\";\r\n  for (const auto &x : v) {\r\n    if (!first) {\r\n      res += \", \";\r\n    }\r\n    first = false;\r\n    res += to_string(x);\r\n  }\r\n  res += \"}\";\r\n  return res;\r\n}\r\n \r\ntemplate <typename A, typename B>\r\nstring to_string(pair<A, B> p) {\r\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\r\n}\r\n \r\ntemplate <typename A, typename B, typename C>\r\nstring to_string(tuple<A, B, C> p) {\r\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\r\n}\r\n \r\ntemplate <typename A, typename B, typename C, typename D>\r\nstring to_string(tuple<A, B, C, D> p) {\r\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\r\n}\r\n \r\nvoid debug_out() { cerr << endl; }\r\n \r\ntemplate <typename Head, typename... Tail>\r\nvoid debug_out(Head H, Tail... T) {\r\n  cout << \" \" << to_string(H);\r\n  debug_out(T...);\r\n}\r\n \r\n#ifdef LOCAL\r\n#define debug(...) cerr << \"[\" << #VA_ARGS << \"]:\", debug_out(VA_ARGS)\r\n#else\r\n#define debug(...) 42\r\n#endif\r\n\r\ntemplate<typename T,typename T1>T amax(T &a,T1 b){if(b>a)a=b;return a;}\r\ntemplate<typename T,typename T1>T amin(T &a,T1 b){if(b<a)a=b;return a;}\r\n\r\n#define rep(i, a, b)    for(int i = (a); i < (b); ++i)\r\n#define per(i, a, b)    for(int i = (a)-1 ; i >= (b); i--)\r\n#define forn(i,n)       rep(i,0,n)\r\n#define rof(i,n)        per(i,n,0)\r\n#define IOS             ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\r\n#define dbg(x)          cout << #x << \"=\" << x << endl\r\n#define dbg2(x, y)      cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\r\n#define dbg3(x, y,z)    cout << #x << \"=\" << x << \",\" << #y << \"=\" << y <<\",\" << #z << \"=\" << z << endl\r\n#define all(x)          (x).begin(), (x).end()\r\n#define pb              push_back\r\n#define mp              make_pair\r\n#define sz(x)           (int)(x).size()\r\n#define fi              first\r\n#define se              second\r\n#define ll              long long\r\n#define endl            \"\\n\"\r\n#define mem0(a)         memset(a,0,sizeof(a))\r\n#define mem1(a)         memset(a,-1,sizeof(a))\r\n#define memf(a)         memset(a,false,sizeof(a))\r\n#define memt(a)         memset(a,true,sizeof(a))\r\n#define meminf(a)       memset(a,0x7f,sizeof(a))\r\n#define nO              {cout<<\"NO\\n\"; return;}\r\n#define yES             {cout<<\"YES\\n\"; return;}\r\n#define neg             {cout<<\"-1\\n\"; return;}\r\nmt19937_64 \t\t\t\t      rng(std::chrono::steady_clock::now().time_since_epoch().count());\r\n//#define int             long long\r\n \r\ntypedef pair<int,int> pii;\r\ntypedef vector<int> vi;\r\ntypedef vector<pii> vpi;\r\ntypedef vector<vi> vvi;\r\nconst int mod = 1000000007;\r\n\r\nconst int D = 19;\r\nconst int MX = 1 << 19;\r\n\r\nstruct node{\r\n    //req variable\r\n    int sum;\r\n    int len;\r\n    node()\r\n    {\r\n        sum=0;\r\n        len=1;\r\n        //check = false;\r\n    }\r\n};\r\nclass segte {\r\npublic:\r\n    int n{};\r\n    vector<node> tree;\r\n    vector<int> a;\r\n    node neutral;\r\n\r\n    void init(int N) {\r\n        n = N;\r\n        tree.resize(2 * n + 1);\r\n        //default values\r\n        a.assign(n, 0);\r\n    }\r\n\r\n    void put(vector<int> &val) {\r\n        a = val;\r\n    }\r\n\r\n    //merge function\r\n    void merge(node &curr, node &left, node &right) {\r\n        curr.sum = left.sum + right.sum;\r\n        curr.len = left.len + right.len;\r\n    }\r\n\r\n    //for leaf\r\n    void single(node &curr, int idx) {\r\n        curr.sum = a[idx];\r\n    }\r\n\r\n    void build(int index, int ss, int se) {\r\n        if (ss == se) {\r\n            single(tree[index], ss);\r\n            return;\r\n        }\r\n        int mid = (ss + se) / 2;\r\n        build(2 * index, ss, mid);\r\n        build(2 * index + 1, mid + 1, se);\r\n        merge(tree[index], tree[2 * index], tree[2 * index + 1]);\r\n    }\r\n\r\n    void build() {\r\n        build(1, 0, n - 1);\r\n    }\r\n\r\n    int query(int x){\r\n      int idx = 1;\r\n      int level = 0;\r\n      int ans = 0;\r\n      while(level < 19){\r\n        //cout << idx << \" \" << tree[idx].len << \" \" << tree[idx].sum << \" \" << ans <<  endl;\r\n        if((1 << (18-level)) &x){\r\n          if(tree[2*idx+1].sum == tree[2*idx+1].len){\r\n            ans += tree[2*idx+1].len;\r\n            idx = 2*idx;\r\n          }\r\n          else{\r\n            idx = 2*idx+1;\r\n          }\r\n        }\r\n        else{\r\n          if(tree[2*idx].sum == tree[2*idx].len){\r\n            ans += tree[2*idx].len;\r\n            idx = 2*idx+1;\r\n          }\r\n          else{\r\n            idx = 2*idx;\r\n          }\r\n        }\r\n        level++;\r\n      }\r\n      return ans;\r\n    }\r\n\r\n};\r\n\r\n\r\nvoid solve(){\r\n  FastIO::Reader cin;\r\n  FastIO::Writer cout;\r\n  int n,m;\r\n  cin >> n >> m;\r\n  vi v(MX);\r\n  forn(i,n){\r\n    int x; cin >> x;\r\n    v[x] = 1;\r\n  }\r\n  segte tree;\r\n  tree.init(MX);\r\n  tree.put(v);\r\n  tree.build();\r\n  //cout << tree.query(0) << endl;\r\n  //cout << tree.query(5) << endl;\r\n  int val = 0;\r\n  forn(i,m){\r\n    int x; cin >> x;\r\n    val ^= x;\r\n    cout << tree.query(val) << endl;\r\n  }\r\n}\r\n\r\nsigned main(){\r\n  //IOS;\r\n  int tt = 1;\r\n  //cin >> tt;\r\n  for(int ii = 1; ii <= tt; ii++)\r\n    solve();\r\n}\r\n"
}