{
    "id": 75299903,
    "contestId": 842,
    "creationTimeSeconds": 1585877664,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 842,
        "index": "D",
        "name": "Vitya and Strange Lesson",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "binary search",
            "data structures"
        ]
    },
    "author": {
        "contestId": 842,
        "members": [
            {
                "handle": "shinigami336537"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1504019100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 3993600,
    "source": "\r\n    \r\n\r\n    // Success is not final , failure is not fatal : \r\n    //         it is the courage to continue that counts\r\n   \r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ff              first\r\n#define ss              second\r\n#define pb(x)           push_back(x)\r\n#define mp              make_pair\r\n#define sz(x)           x.size()\r\n#define mem(x ,y)       memset(x , y , sizeof x )\r\n#define all(a )         a.begin() , a.end()\r\n#define endl            \"\\n\"\r\n#define pii             pair<int,int> \r\n#define clr(x)          x.clear()\r\n#define sl(x )          scanf(\"%I64d\" ,&x)\r\n#define si(x )          scanf(\"%d\" ,&x)\r\n#define forn(i ,x,n )   for(int i = x ; i <= n ; i++ )\r\n#define ford(i ,x,n )   for(int i = x ; i >= n ; i-- )\r\n#define rep(i,n )       for(int i= 0; i<n ; i++ )\r\n#define repi(i,n )      for(int i= 1; i<=n ; i++ )\r\n#define repit(i, c)     for( __typeof((c).begin()) i = (c).begin(); i != (c).end();++i )\r\n#define dbg(args...)    do {   cerr << #args << ' ' ;  print(args); } while(0); cerr<< endl ;\r\ntypedef long long ll  ;\r\nll mod =  1e9+7, mod2 = 998244353 ; \r\ntypedef unsigned long long  ull ;\r\nint setbit(int n, int pos  ) { return n = n|(1<< pos) ; }\r\nint resetbit(int n,int pos ) {  return n =  n & ~(1<<pos ); }\r\nbool checkbit(int  n,int pos ) { return (bool ) (n&(1<<pos))  ; }\r\ntemplate< typename T > T mul(T x, T y, T mod = mod ) { x %= mod ; y %= mod ; return (x*y)%mod  ;  }\r\ntemplate< typename T > T add(T x, T y, T mod = mod ) { x %= mod ; y %= mod ; return (x+y)%mod ;  }\r\ntemplate< typename T > T sub(T x, T y, T mod = mod ) { x %= mod ; y %= mod ; return ((x-y)%mod+mod )%mod;  }\r\ntemplate< typename T > T ext_gcd(T num1 , T num2, T &X , T &Y ) { T r2,r1, q2, q1 , x2, x1, y2 ,y1 , x,  y, r   ; x2 = 1; y2 = 0;  x1 = 0; y1 = 1; for( r2 =num1 ,r1 = num2 ;r1 != 0 ; y2 = y1, y1 = y,x2 = x1 ,x1 = x ,r2 = r1, r1 = r) {q1 = r2/r1; x = x2 - q1*x1; y = y2 - q1*y1; r = r2%r1 ; } X = x2 ; Y = y2 ; return r2 ;  }\r\ntemplate< typename T > void print(const T& v) {    cerr << v << ' ' ;}\r\ntemplate< typename T1, typename... T2 > void print( const T1& first, const T2&... rest ){ print(first); print(rest...) ;}\r\ntemplate<class T> string to_str(T t){stringstream ss; ss<<t; return ss.str();} \r\ntemplate < typename T > \r\nT  bigmod(T x, T k ,T mod = mod) {\r\n    if(k == 0 ) return (T)1; \r\n    if(k&1  ) { \r\n        return ( (x%mod)*bigmod(x,k-1, mod )%mod )%mod ; \r\n    } else { \r\n        T ret = bigmod(x,k/2  , mod ) ; \r\n        ret %= mod ;             \r\n        return (ret*ret )%mod; \r\n    } \r\n \r\n}\r\ntemplate < typename T > \r\nT  invmod( T x , T m) {  \r\n    return bigmod(x,m-2 , m) ;   \r\n    // long long ret, t ;// \r\n    // ext_gcd( x, m ,ret ,t  ) ;\r\n    // ret %= m ; if(ret<0) ret += m  ; \r\n    // return ret;\r\n} \r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\n// using namespace __gnu_pbds;\r\n// typedef tree<  int    ,     // change type \r\n//               null_type, \r\n//               less_equal  < int  >  ,  // change type ..    \r\n//               rb_tree_tag,\r\n//               tree_order_statistics_node_update> ordered_set;\r\n// debuging ...\r\ntemplate<typename T > \r\nvoid dbg_a(T a[] ,int n=10 ) {\r\n    cerr << \"[ \"; \r\n        for(int i=0;i < n ; i++ )\r\n            cerr<<a[i]<<' ' ; \r\n                cerr<< \" ]\" <<  endl; \r\n} \r\ntemplate < typename F,  typename S >\r\nostream& operator << ( ostream& os, const pair< F, S > & p ) {\r\n    return os << \"[ \" << p.first << \", \" << p.second << \" ]\";\r\n}\r\ntemplate < typename T >\r\nostream &operator << ( ostream & os, const vector< T > &v ) {\r\n    os << \"[ \"; \r\n        for(int i=0; i<sz(v) ; i++ )  \r\n            os << v[i] << ' ' ; \r\n                return os << \" ]\\n\" ; \r\n} \r\ntemplate < typename T >\r\nostream &operator << ( ostream & os, const map< T ,T> &Map  ) {\r\n    os << \"[ \"; \r\n        repit(it , Map )    \r\n            os << \"[\" <<(*it).ff << ' ' << (*it).ss << \"] \"    ; \r\n                return os << \"]\\n\" ; \r\n} \r\ntemplate < typename T >\r\nostream &operator << ( ostream & os, const set< T > &Set  ) {\r\n    os << \"[ \"; \r\n        repit(it , Set )   \r\n            os <<  *it  << ' ' ; \r\n                return os << \" ]\\n\" ; \r\n}  \r\n// int dy[] = {-1, +1,0 , 0 };\r\n// int dx[ 10 ] =  {-2,-2, 2, 2  ,+ 1, -1  , +1, -1 }  ;\r\n// int dy[ 10 ] =  {+1,-1, 1, -1 , +2,+2 , -2,-2  }  ;\r\nconst int maxn  = (int )1e6   ;\r\nconst ll inf  =  1e8+1223 ;\r\n// #define  int  ll  \r\n//////////////////////////////////////////////////////////////\r\n\r\nint a[maxn ]  ; \r\n\r\n\r\nstruct Node {\r\n    int cnt ; \r\n    Node* nxt[2]  ;\r\n    Node() {    cnt = 0; rep(i,2)  nxt[i] = NULL ;  }\r\n} ;\r\nint len =2 ; \r\nstruct Trie {\r\n    Node *head , *curr , *dummy   ;\r\n    Trie() {\r\n        head = curr  = new Node() ;\r\n    }    \r\n        // for(int i=len  ; i>=0 ;  i--  ) {\r\n        //     int tmp =  checkbit(x, i ) ; // edit as req \r\n        //     curr->cnt++ ;\r\n        //     if(curr->nxt[tmp ] == NULL) {\r\n        //         curr->nxt[tmp] = new Node() ;\r\n        //     }\r\n        //     curr = curr->nxt[tmp ] ;\r\n        // }\r\n    void insert(int id ,int x , Node* curr   ) {\r\n        curr->cnt++ ; \r\n        if(id<0) return  ;\r\n        if(checkbit(x,id) ) {\r\n            if(curr->nxt[1]==NULL) curr->nxt[1] = new Node() ; \r\n            insert(id-1, x, curr->nxt[1] )  ; \r\n        } else {\r\n            if(curr->nxt[0]==NULL) curr->nxt[0] = new Node() ; \r\n            insert(id-1, x, curr->nxt[0] )  ; \r\n       \r\n\r\n        }\r\n    }\r\n    void  insert(int  x ) {\r\n        curr = head  ; \r\n        // dbg(\"inserting.. \" , x ) ; \r\n        insert(len , x , curr)  ; \r\n\r\n    }\r\n    int func(int  id  , int  x   , Node  *curr){\r\n        if( curr==0  or id< 0 ) return 0 ; \r\n\r\n\r\n        int  bit  =  checkbit(x, id) , want = 1<<id   , l= 0,r =0 ; \r\n\r\n        // cout << endl ; \r\n        // cout <<  id <<  \"-> \" << endl; \r\n        if(curr->nxt[0]!= 0)  l = curr->nxt[0]->cnt  ; \r\n        if(curr->nxt[1]!=0)   r = curr->nxt[1]->cnt ; \r\n    \r\n        // dbg(id,bit, want , l,r ) ; \r\n\r\n\r\n        if( bit) {\r\n            if( r  <  want )  {\r\n                // dbg(\"inside \") ;\r\n                return func(id-1  , x, curr->nxt[1]) ;\r\n            }\r\n            return  1<<id + func( id-1,x , curr->nxt[0] )  ;  \r\n \r\n\r\n        } else {\r\n            if(  l< want  ) \r\n                return  func( id-1, x, curr->nxt[0] ) ;  \r\n            return 1<<id + func( id-1 , x,  curr->nxt[1] )  ; \r\n\r\n        }\r\n    }\r\n\r\n    // bool search(int id ,int x, Node *curr) {\r\n    //     if( id<0) return 1; \r\n\r\n    //     cout <<  id << \" -> \"  <<  endl   ;  \r\n    //     dbg(curr->cnt )  ; \r\n    //     if( curr->nxt[0] != 0 )   dbg(0 ,  curr->nxt[0]->cnt )  ;\r\n    //     if( curr->nxt[1] != 0 )   dbg(1 ,  curr->nxt[1]->cnt )  ;\r\n\r\n    //     cout <<  endl ; \r\n    //     if( checkbit(x,id) == 1)  {\r\n    //         dbg(\"rigjht\" ) ;\r\n    //         if(curr->nxt[1] == 0 ) return 0 ; \r\n    //         return search(id-1, x, curr->nxt[1]) ; \r\n    //     } else {\r\n    //         dbg(\"left \")  ;\r\n    //         if(curr->nxt[0]==0) return 0; \r\n    //         return search(id-1, x,curr->nxt[0] ) ;  \r\n    //     }\r\n    // }\r\n\r\n\r\n} ; \r\n\r\nvoid solve() {     \r\n    int  n, k,q   , tot = 0 ,f = 1 ,x = 0 , y    ;  \r\n\r\n    cin >> n  >> q   ; \r\n    Trie  t ;  \r\n    // t.insert(0) ; \r\n\r\n    len  =2; \r\n    rep(i,n ) cin >> a[i+1 ]   , t.insert(  a[i+1] )  ;\r\n \r\n    x =  0 ; \r\n    rep(_ ,q)   {\r\n        cin >>  k  ; x^= k ;\r\n        t.curr = t.head ; \r\n        // dbg(x)  ; \r\n        int res =   t.func( len  , x,  t.curr  ) ; \r\n        cout  << res << endl; \r\n\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n}                   \r\nsigned main() { \r\n    #ifndef ONLINE_JUDGE    \r\n       freopen(\"in.txt\", \"r\", stdin);\r\n          // freopen(\"out.tx    t\", \"w\", stdout);\r\n    #endif \r\n    ios :: sync_with_stdio(false);  cin.tie(0);  \r\n    cout.tie(0) ; \r\n    clock_t st = clock() ;\r\n        // cout << fixed << setprecision(12) ;\r\n    int  c = 0 ,t = 1 ;  \r\n    // cin>>t ; \r\n    while(t--) { \r\n        solve()  ;\r\n    }   \r\n    // cerr << \"Execution time : \" << (double  )  (clock()-st )/CLOCKS_PER_SEC << endl ;  \r\n    // 12m476 ~463    6     //   n48 d49 \r\n\r\n    return 0 ;   \r\n \r\n}    \r\n\r\n\r\n\r\n\r\n"
}