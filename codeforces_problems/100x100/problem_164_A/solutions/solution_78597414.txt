{
    "id": 78597414,
    "contestId": 164,
    "creationTimeSeconds": 1588272925,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 164,
        "index": "A",
        "name": "Variable, or There and Back Again",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1700,
        "tags": [
            "dfs and similar",
            "graphs"
        ]
    },
    "author": {
        "contestId": 164,
        "members": [
            {
                "handle": "saurabhs1206"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1333897500
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 36,
    "timeConsumedMillis": 684,
    "memoryConsumedBytes": 48128000,
    "source": "import java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.math.BigInteger;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.BitSet;\r\nimport java.util.Calendar;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedList;\r\nimport java.util.PriorityQueue;\r\nimport java.util.SortedSet;\r\nimport java.util.Stack;\r\nimport java.util.StringTokenizer;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\n\r\n/**\r\n * #\r\n * \r\n * @author pttrung\r\n */\r\npublic class A_VK2012_Round3 {\r\n\r\n\tpublic static long MOD = 1000000007;\r\n\r\n\tstatic int[] f, l;\r\n\tstatic int cur = 0;\r\n\r\n\tpublic static void main(String[] args) throws FileNotFoundException {\r\n\t\t// PrintWriter out = new PrintWriter(new FileOutputStream(new File(\r\n\t\t// \"output.txt\")));\r\n\t\tPrintWriter out = new PrintWriter(System.out);\r\n\t\tScanner in = new Scanner();\r\n\t\tint n = in.nextInt();\r\n\t\tint m = in.nextInt();\r\n\t\tint[] data = new int[n];\r\n\t\tArrayList<Integer>[] map = new ArrayList[n];\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tmap[i] = new ArrayList();\r\n\t\t\tdata[i] = in.nextInt();\r\n\t\t}\r\n\t\tfor (int i = 0; i < m; i++) {\r\n\t\t\tint a = in.nextInt() - 1;\r\n\t\t\tint b = in.nextInt() - 1;\r\n\t\t\tmap[a].add(b);\r\n\t\t}\r\n\t\tint[] re = new int[n];\r\n\t\tf = new int[n];\r\n\t\tl = new int[n];\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tif (data[i] == 1) {\r\n\t\t\t\tcal(i, re, data, new Stack(), map);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i : re) {\r\n\t\t\tout.println(i == 1 ? 1 : 0);\r\n\t\t}\r\n\t\tout.close();\r\n\t}\r\n\r\n\tstatic boolean cal(int index, int[] re, int[] data, Stack<Integer> s,\r\n\t\t\tArrayList<Integer>[] map) {\r\n\t\tf[index] = l[index] = cur++;\r\n\t\tboolean result = false;\r\n\t\tif (data[index] == 2) {\r\n\t\t\tresult = true;\r\n\t\t}\r\n\t\tre[index] = -1;\r\n\t\ts.push(index);\r\n\r\n\t\tfor (int i : map[index]) {\r\n\t\t\tif (data[i] != 1) {\r\n\t\t\t\tif (re[i] == 0) {\r\n\t\t\t\t\tresult |= cal(i, re, data, s, map);\r\n\t\t\t\t\tl[index] = Math.min(l[index], l[i]);\r\n\t\t\t\t} else if (re[i] == -1) {\r\n\t\t\t\t\tl[index] = Math.min(l[index], f[i]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult |= re[i] == 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (f[index] == l[index]) {\r\n\t\t\tArrayList<Integer> list = new ArrayList();\r\n\t\t\twhile (s.peek() != index) {\r\n\t\t\t\tint v = s.pop();\r\n\t\t\t\tlist.add(v);\r\n\t\t\t}\r\n\t\t\tfor (int i : list) {\r\n\t\t\t\tre[i] = result ? 1 : -2;\r\n\t\t\t}\r\n\t\t\ts.pop();\r\n\t\t\tre[index] = result ? 1 : -2;\r\n\t\t}\r\n\t\t// System.out.println(result + \" \" + (index + 1));\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic static int[] KMP(String val) {\r\n\t\tint i = 0;\r\n\t\tint j = -1;\r\n\t\tint[] result = new int[val.length() + 1];\r\n\t\tresult[0] = -1;\r\n\t\twhile (i < val.length()) {\r\n\t\t\twhile (j >= 0 && val.charAt(j) != val.charAt(i)) {\r\n\t\t\t\tj = result[j];\r\n\t\t\t}\r\n\t\t\tj++;\r\n\t\t\ti++;\r\n\t\t\tresult[i] = j;\r\n\t\t}\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tpublic static boolean nextPer(int[] data) {\r\n\t\tint i = data.length - 1;\r\n\t\twhile (i > 0 && data[i] < data[i - 1]) {\r\n\t\t\ti--;\r\n\t\t}\r\n\t\tif (i == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tint j = data.length - 1;\r\n\t\twhile (data[j] < data[i - 1]) {\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tint temp = data[i - 1];\r\n\t\tdata[i - 1] = data[j];\r\n\t\tdata[j] = temp;\r\n\t\tArrays.sort(data, i, data.length);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic static int digit(long n) {\r\n\t\tint result = 0;\r\n\t\twhile (n > 0) {\r\n\t\t\tn /= 10;\r\n\t\t\tresult++;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic static double dist(long a, long b, long x, long y) {\r\n\t\tdouble val = (b - a) * (b - a) + (x - y) * (x - y);\r\n\t\tval = Math.sqrt(val);\r\n\t\tdouble other = x * x + a * a;\r\n\t\tother = Math.sqrt(other);\r\n\t\treturn val + other;\r\n\r\n\t}\r\n\r\n\tpublic static class Point implements Comparable<Point> {\r\n\r\n\t\tint x, y;\r\n\r\n\t\tpublic Point(int start, int end) {\r\n\t\t\tthis.x = start;\r\n\t\t\tthis.y = end;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tint hash = 5;\r\n\t\t\thash = 47 * hash + this.x;\r\n\t\t\thash = 47 * hash + this.y;\r\n\t\t\treturn hash;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (obj == null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (getClass() != obj.getClass()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tfinal Point other = (Point) obj;\r\n\t\t\tif (this.x != other.x) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (this.y != other.y) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int compareTo(Point o) {\r\n\t\t\treturn x - o.x;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static class FT {\r\n\r\n\t\tlong[] data;\r\n\r\n\t\tFT(int n) {\r\n\t\t\tdata = new long[n];\r\n\t\t}\r\n\r\n\t\tpublic void update(int index, long value) {\r\n\t\t\twhile (index < data.length) {\r\n\t\t\t\tdata[index] += value;\r\n\t\t\t\tindex += (index & (-index));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic long get(int index) {\r\n\t\t\tlong result = 0;\r\n\t\t\twhile (index > 0) {\r\n\t\t\t\tresult += data[index];\r\n\t\t\t\tindex -= (index & (-index));\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static long gcd(long a, long b) {\r\n\t\tif (b == 0) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\treturn gcd(b, a % b);\r\n\t}\r\n\r\n\tpublic static long pow(long a, long b) {\r\n\t\tif (b == 0) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (b == 1) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\tlong val = pow(a, b / 2);\r\n\t\tif (b % 2 == 0) {\r\n\t\t\treturn val * val % MOD;\r\n\t\t} else {\r\n\t\t\treturn val * (val * a % MOD) % MOD;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class Scanner {\r\n\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic Scanner() throws FileNotFoundException {\r\n\t\t\t// System.setOut(new PrintStream(new\r\n\t\t\t// BufferedOutputStream(System.out), true));\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\t// br = new BufferedReader(new InputStreamReader(new\r\n\t\t\t// FileInputStream(new File(\"input.txt\"))));\r\n\t\t}\r\n\r\n\t\tpublic String next() {\r\n\r\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tthrow new RuntimeException();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tpublic long nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\r\n\t\tpublic int nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n\r\n\t\tpublic double nextDouble() {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tpublic String nextLine() {\r\n\t\t\tst = null;\r\n\t\t\ttry {\r\n\t\t\t\treturn br.readLine();\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tthrow new RuntimeException();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic boolean endLine() {\r\n\t\t\ttry {\r\n\t\t\t\tString next = br.readLine();\r\n\t\t\t\twhile (next != null && next.trim().isEmpty()) {\r\n\t\t\t\t\tnext = br.readLine();\r\n\t\t\t\t}\r\n\t\t\t\tif (next == null) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tst = new StringTokenizer(next);\r\n\t\t\t\treturn st.hasMoreTokens();\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tthrow new RuntimeException();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}"
}