{
    "id": 1499948,
    "contestId": 164,
    "creationTimeSeconds": 1333899485,
    "relativeTimeSeconds": 1985,
    "problem": {
        "contestId": 164,
        "index": "A",
        "name": "Variable, or There and Back Again",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1700,
        "tags": [
            "dfs and similar",
            "graphs"
        ]
    },
    "author": {
        "contestId": 164,
        "members": [
            {
                "handle": "Slevin"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 4,
        "startTimeSeconds": 1333897500
    },
    "programmingLanguage": "GNU C++",
    "verdict": "WRONG_ANSWER",
    "testset": "PRETESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 60,
    "memoryConsumedBytes": 2355200,
    "source": "#include <cassert>\r\n#include <complex>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n#include <iostream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <numeric>\r\n#include <sstream>\r\n#include <utility>\r\n\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <list>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <stack>\r\n#include <string>\r\n#include <vector>\r\n\r\n#include <memory.h>\r\n//#include \"bigint.h\"\r\n\r\nusing namespace std;\r\n\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(x) ((int)(x).size())\r\n#define init(st) memset(st, 0, sizeof(st))\r\n#define Pi 3.141592653589793\r\n#define ll long long\r\n\r\n// String operations\r\ntemplate<class T>\r\nvoid splitstr(const string &s, vector<T> &out) {\r\n  istringstream in(s);\r\n  out.clear();\r\n  copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\r\n}\r\n\r\ntemplate<class T>\r\nT read_value(string s) {\r\n  T result;\r\n  istringstream sin(s);\r\n  sin >> result;\r\n  return result;\r\n}\r\n\r\n#define read_int(s) read_value<int>(s)\r\n#define read_ll(s) read_value<ll>(s)\r\n#define read_float(s) read_value<float>(s)\r\n#define read_double(s) read_value<double>(s)\r\n\r\nstring read_line() {\r\n  string ret_val;\r\n  getline(std::cin, ret_val);\r\n  return ret_val;\r\n}\r\n\r\ntemplate<class T>\r\nvoid init_array(T *arr, int size, T value) {\r\n  for (int i = 0; i < size; i++)\r\n    arr[i] = value;\r\n}\r\n\r\n// Arithmetic operations\r\ntemplate<class T>\r\ninline T gcd(T a, T b) {\r\n  return (!a) ? b : gcd(b % a, a);\r\n}\r\n\r\ntemplate<class T>\r\ninline T mod(T a, T p) {\r\n  a %= p;\r\n  return (a < 0) ? a + p : a;\r\n}\r\n\r\ntemplate<class T>\r\ninline int numbits(T n) {\r\n  return (!n) ? 0 : 1 + numbits(n & (n - 1));\r\n}\r\n\r\ntemplate<class T>\r\ninline T inverse(T a, T m) {\r\n  a = mod<T>(a,m);\r\n  return (a==1) ? 1 : mod((1-m*inverse(m%a,a))/a,m);\r\n}\r\n\r\ntemplate<class T>\r\ninline bool is_prime(T a) {\r\n  T lim = (T)sqrt((double)a);\r\n  for (T i = 2; i <= T(lim+1E-9); i++)\r\n    if (a % i == 0)\r\n       return false;\r\n  return true;\r\n}\r\n\r\ntemplate<class T>\r\ninline T power(T a, T p, T mod) {\r\n  if (!p) return 1;\r\n  T temp = power(a, p>>1, mod);\r\n  temp = (temp * temp) % mod;\r\n  if (p&1)\r\n    temp = (temp * a) % mod;\r\n  return temp;\r\n}\r\n\r\nvoid get_primes(int start, int end, vector<int> &vi) {\r\n  bool *p = new bool[end + 1];\r\n  init_array<bool>(p, end+1, 0); p[1] = 1;\r\n  for (int i = 2; i <= end; i++) {\r\n    if (!p[i]) {\r\n      if (i >= start)\r\n        vi.push_back(i);\r\n      for (int j = 2*i; j <= end; j += i)\r\n        p[j] = 1;\r\n    }\r\n  }\r\n  delete [] p;\r\n}\r\n\r\n// Graph operations\r\nbool dfs(int current, int final, int total, vector<int> &visited, vector< vector<bool> > &edges, bool flow) {\r\n  if (current == final) return true;\r\n  if (visited[current]) return false;\r\n  visited[current] = true;\r\n  for (int i = 0; i < total; i++)\r\n    if (edges[current][i] && dfs(i, final, total, visited, edges, flow)) {\r\n      if (flow) {\r\n        edges[current][i] = false;\r\n        edges[i][current] = true;\r\n      }\r\n      return true;\r\n    }\r\n  return false;\r\n}\r\n\r\nint flow(int in, int out, int total, vector< vector<bool> > &edges) {\r\n  int result = 0;\r\n  for (vector<int> visited(total, 0); dfs(in, out, total, visited, edges, true); ++result)\r\n    visited = vector<int>(total, 0);\r\n  return result;\r\n}\r\n\r\n// Disjoint datasets\r\nvoid create_set(int x, int *P, int *rank) {\r\n  P[x] = x;\r\n  rank[x] = 0;\r\n}\r\n\r\nint find_set(int x, int *P) {\r\n  if (x != P[x]) P[x] = find_set(P[x], P);\r\n  return P[x];\r\n}\r\n\r\nbool merge_sets(int x, int y, int *P, int *rank) {\r\n  int Px = find_set(x, P);\r\n  int Py = find_set(y, P);\r\n  if(Px == Py) return false;\r\n  if (rank[Px] > rank[Py]) P[Py] = Px;\r\n  else P[Px] = Py;\r\n  if (rank[Px] == rank[Py]) rank[Py]++;\r\n  return true;\r\n}\r\n\r\n// Binary tree operations\r\ntemplate <typename T>\r\nint read_cum_freq(int index, T *tree) {\r\n  int sum = 0;\r\n  while (index) {\r\n    sum += tree[index];\r\n    index -= (index & -index);\r\n  }\r\n  return sum;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid upd_freq(int index, int mxIndex, int value, T *tree) {\r\n  while (index <= mxIndex) {\r\n    tree[index] += value;\r\n    index += (index & -index);\r\n  }\r\n}\r\n\r\ntemplate <typename T>\r\nint read_freq(int index, T *tree) {\r\n  return read_cum_freq(index, tree) - read_cum_freq(index-1, tree);\r\n}\r\n\r\n// String algos.\r\nvoid build_failure_function(const string &str, int *temp_arr) {\r\n  temp_arr[0] = temp_arr[1] = 0;\r\n  for (int i = 2; i <= sz(str); i++) {\r\n    temp_arr[i] = -1;\r\n    for (int ind = temp_arr[i-1]; temp_arr[i] == -1; ind = temp_arr[ind]) {\r\n      if (str[ind] == str[i-1]) {\r\n        temp_arr[i] = ind + 1;\r\n      } else if (ind == 0) {\r\n        temp_arr[i] = 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid KMP(const string &text, const string &pattern, int *res) {\r\n  int *temp_arr = new int[sz(pattern) + 1];\r\n  build_failure_function(pattern, temp_arr);\r\n  int i = 0;\r\n  int ind = 0;\r\n  while (i < sz(text)) {\r\n    if (text[i] == pattern[ind]) {\r\n      res[i] = ++ind;\r\n      if (res[i] == sz(pattern)) {\r\n        ind = temp_arr[ind];\r\n      }\r\n      i++;\r\n    } else if (ind == 0) {\r\n      res[i++] = 0;\r\n    } else {\r\n      ind = temp_arr[ind];\r\n    }\r\n  }\r\n  delete [] temp_arr;\r\n}\r\n\r\ntemplate <typename T, int N>\r\nstruct matrix {\r\n  T m[N][N];\r\n  T md;\r\n\r\n  matrix(T md, bool unary = false) {\r\n    this->md = md;\r\n    init(m);\r\n    if (unary) {\r\n      for (int i = 0; i < N; i++) {\r\n        m[i][i] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  matrix operator*(const matrix &that) const {\r\n    matrix ret_val(md, false);\r\n    for (int i = 0; i < N; i++) {\r\n      for (int j = 0; j < N; j++) {\r\n        for (int k = 0; k < N; k++) {\r\n          ret_val.m[i][j] += this->m[i][k] * that.m[k][j];\r\n          ret_val.m[i][j] %= md;\r\n        }\r\n      }\r\n    }\r\n    return ret_val;\r\n  }\r\n\r\n  vector<T> operator*(const vector<T> &vec) const {\r\n    vector<T> ret_val(vec.size(), 0);\r\n    for (int i = 0; i < N; i++) {\r\n      for (int j = 0; j < N; j++) {\r\n        ret_val[i] += m[i][j] * vec[j];\r\n        ret_val[i] %= md;\r\n      }\r\n    }\r\n    return ret_val;\r\n  }\r\n\r\n  matrix power(int power) const {\r\n  \tmatrix temporary = *this;\r\n  \tmatrix ret_val(md, true);\r\n  \twhile (power) {\r\n  \t\tif (power & 1)\r\n  \t\t\tret_val = ret_val * temporary;\r\n  \t\ttemporary = temporary * temporary;\r\n  \t\tpower >>= 1;\r\n  \t}\r\n  \treturn ret_val;\r\n  }\r\n};\r\n\r\n// Setup\r\nvoid setup(int value, string name) {\r\n  string name_in = name + \".in\";\r\n  string name_out = name + \".out\";\r\n  freopen(name_in.c_str(), \"r\", stdin);\r\n  if (value) freopen(name_out.c_str(), \"w\", stdout);\r\n}\r\n\r\nvector<int> st;\r\nvector<int> res;\r\nmap<int, vector<int> > path1;\r\nmap<int, vector<int> > path2;\r\n\r\nvoid dfs1(int v, bool flag) {\r\n  if (res[v]) return;\r\n  if (st[v] == 1 && flag) return;\r\n  res[v] = 1;\r\n  for (int i = 0; i < path1[v].size(); ++i)\r\n    dfs1(path1[v][i], true);\r\n}\r\n\r\nvoid dfs2(int v) {\r\n  if (res[v] & 2) return;\r\n  res[v] |= 2;\r\n  if (st[v] == 1) return;\r\n  for (int i = 0; i < path2[v].size(); ++i)\r\n    dfs2(path2[v][i]);\r\n}\r\n\r\nvoid run() {\r\n  int n, m; std::cin >> n >> m;\r\n  st.resize(n);\r\n  res.resize(n);\r\n  for (int i = 0; i < n; ++i) {\r\n    std::cin >> st[i];\r\n    res[i] = 0;\r\n  }\r\n  for (int i = 0; i < m; ++i) {\r\n    int a, b; std::cin >> a >> b;\r\n    path1[a-1].push_back(b-1);\r\n    path2[b-1].push_back(a-1);\r\n  }\r\n  for (int i = 0; i < st.size(); ++i) {\r\n    if (st[i] == 1)\r\n      dfs1(i, false);\r\n    if (st[i] == 2)\r\n      dfs2(i);\r\n  }\r\n  for (int i = 0; i < res.size(); ++i) {\r\n    if (res[i] == 3)\r\n      printf(\"1\\n\");\r\n    else\r\n      printf(\"0\\n\");\r\n  }\r\n}\r\n\r\nint main() {\r\n#ifdef LOCAL_HOST\r\n    setup(0, \"temp\");\r\n#endif\r\n    run();\r\n    return 0;\r\n}"
}