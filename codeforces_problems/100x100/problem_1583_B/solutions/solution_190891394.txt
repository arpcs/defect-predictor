{
    "id": 190891394,
    "contestId": 1583,
    "creationTimeSeconds": 1674844047,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1583,
        "index": "B",
        "name": "Omkar and Heavenly Tree",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1200,
        "tags": [
            "constructive algorithms",
            "trees"
        ]
    },
    "author": {
        "contestId": 1583,
        "members": [
            {
                "handle": "sandeep5445"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1634468700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 30,
    "timeConsumedMillis": 373,
    "memoryConsumedBytes": 819200,
    "source": "// #LGM\r\n/// -------------------------------Copyright @Sandeep kumar------------------------------------ ///\r\n/// ------------------------------------OPTIMIZATIONS--------------------------------------- ///\r\n\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n\r\n/// ------------------------------------HEADER-FILES---------------------------------------- ///\r\n#include <bits/stdc++.h>\r\n\r\n/// ------------------------------------NAMESPACES------------------------------------------ ///\r\nusing namespace std;\r\n\r\n/// ------------------------------------DEFINING-MYWAY-------------------------------------- ///\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef pair<int, int> p32;\r\ntypedef pair<ll, ll> p64;\r\ntypedef pair<double, double> pdd;\r\ntypedef vector<ll> v64;\r\ntypedef vector<int> v32;\r\ntypedef vector<vector<int>> vv32;\r\ntypedef vector<vector<ll>> vv64;\r\ntypedef vector<vector<p64>> vvp64;\r\ntypedef vector<p64> vp64;\r\ntypedef vector<p32> vp32;\r\ntypedef map<int, int> m32;\r\ntypedef map<ll, ll> m64;\r\n\r\ndouble eps = 1e-12;\r\n\r\ndouble pi = acos(-1);\r\n\r\n#define forn(i, e) for (ll i = 0; i < e; i++)\r\n#define forsn(i, s, e) for (ll i = s; i < e; i++)\r\n#define rforn(i, s) for (ll i = s; i >= 0; i--)\r\n#define rforsn(i, s, e) for (ll i = s; i >= e; i--)\r\n#define nl \"\\n\"\r\n#define dbg(x) cout << #x << \" = \" << x << ln\r\n#define pb push_back\r\n#define INF 2e18\r\n#define fast_cin()                    \\\r\n    ios_base::sync_with_stdio(false); \\\r\n    cin.tie(NULL);                    \\\r\n    cout.tie(NULL)\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(x) ((ll)(x).size())\r\n\r\n/// ----------------------------------------TRACING------------------------------------- ///\r\n\r\n#ifndef ONLINE_JUDGE\r\n\r\ntemplate <typename T>\r\nvoid __p(T a)\r\n{\r\n    cout << a;\r\n}\r\ntemplate <typename T, typename F>\r\nvoid __p(pair<T, F> a)\r\n{\r\n    cout << \"{\";\r\n    __p(a.first);\r\n    cout << \",\";\r\n    __p(a.second);\r\n    cout << \"}\";\r\n}\r\ntemplate <typename T>\r\nvoid __p(std::vector<T> a)\r\n{\r\n    cout << \"{\";\r\n    for (auto it = a.begin(); it < a.end(); it++)\r\n        __p(*it), cout << \",}\"[it + 1 == a.end()];\r\n}\r\ntemplate <typename T>\r\nvoid __p(std::set<T> a)\r\n{\r\n    cout << \"{\";\r\n    for (auto it = a.begin(); it != a.end();)\r\n    {\r\n        __p(*it);\r\n        cout << \",}\"[++it == a.end()];\r\n    }\r\n}\r\ntemplate <typename T>\r\nvoid __p(std::multiset<T> a)\r\n{\r\n    cout << \"{\";\r\n    for (auto it = a.begin(); it != a.end();)\r\n    {\r\n        __p(*it);\r\n        cout << \",}\"[++it == a.end()];\r\n    }\r\n}\r\ntemplate <typename T, typename F>\r\nvoid __p(std::map<T, F> a)\r\n{\r\n    cout << \"{\\n\";\r\n    for (auto it = a.begin(); it != a.end(); ++it)\r\n    {\r\n        __p(it->first);\r\n        cout << \": \";\r\n        __p(it->second);\r\n        cout << \"\\n\";\r\n    }\r\n    cout << \"}\\n\";\r\n}\r\n\r\ntemplate <typename T, typename... Arg>\r\nvoid __p(T a1, Arg... a)\r\n{\r\n    __p(a1);\r\n    __p(a...);\r\n}\r\ntemplate <typename Arg1>\r\nvoid __f(const char *name, Arg1 &&arg1)\r\n{\r\n    cout << name << \" : \";\r\n    __p(arg1);\r\n    cout << endl;\r\n}\r\ntemplate <typename Arg1, typename... Args>\r\nvoid __f(const char *names, Arg1 &&arg1, Args &&...args)\r\n{\r\n    int bracket = 0, i = 0;\r\n    for (;; i++)\r\n        if (names[i] == ',' && bracket == 0)\r\n            break;\r\n        else if (names[i] == '(')\r\n            bracket++;\r\n        else if (names[i] == ')')\r\n            bracket--;\r\n    const char *comma = names + i;\r\n    cout.write(names, comma - names) << \" : \";\r\n    __p(arg1);\r\n    cout << \" | \";\r\n    __f(comma + 1, args...);\r\n}\r\n#define trace(...) cout << \"Line:\" << __LINE__ << \" \", __f(#__VA_ARGS__, __VA_ARGS__)\r\n#else\r\n#define trace(...)\r\n#define error(...)\r\n#endif\r\n///-------------------------------------------segmentation tree by Sandeep kumar----------------------------------------///\r\nconst ll Nptl = 1; // const ll Nptl = 5e6 + 10;\r\nll tree[Nptl];\r\nll build_seg(ll x, ll be, ll en, vector<ll> &v)\r\n{\r\n    if (be == en)\r\n    {\r\n        tree[x] = v[en];\r\n        return tree[x];\r\n    }\r\n    ll mid = (be + en) / 2;\r\n    build_seg(2 * x, be, mid, v);\r\n    build_seg(2 * x + 1, mid + 1, en, v);\r\n    tree[x] = tree[2 * x] + tree[2 * x + 1];\r\n    return tree[x];\r\n}\r\nll update_seg(ll x, ll be, ll en, ll val, ll k, vector<ll> &v)\r\n{\r\n    if (be == en && be == k)\r\n    {\r\n        tree[x] = val;\r\n        return val;\r\n    }\r\n    if (be > k || en < k)\r\n    {\r\n        return tree[x];\r\n    }\r\n    ll mid = (be + en) / 2;\r\n    ll p1 = update_seg(2 * x, be, mid, val, k, v);\r\n    ll p2 = update_seg(2 * x + 1, mid + 1, en, val, k, v);\r\n    tree[x] = p1 + p2;\r\n    return tree[x];\r\n}\r\nll sumation_seg(ll x, ll be, ll en, ll l, ll r, vector<ll> &v)\r\n{\r\n    if (l <= be && r >= en) // l.be.en.r\r\n    {\r\n        return tree[x];\r\n    }\r\n    if (r < be || en < l) // l...r...be...en || be....en...l...r\r\n    {\r\n        return 0;\r\n    }\r\n    // be....l....en....r || l....be....r....en\r\n    ll mid = (be + en) / 2;\r\n    ll p1 = sumation_seg(2 * x, be, mid, l, r, v);\r\n    ll p2 = sumation_seg(2 * x + 1, mid + 1, en, l, r, v);\r\n    return p1 + p2;\r\n}\r\n/// ----------------------------------------- MATHS by Sandeep kumar ------------------------------------- ///\r\nll fact(ll n);\r\n\r\nll nCr(ll n, ll r)\r\n{\r\n    return fact(n) / (fact(r) * fact(n - r));\r\n}\r\n\r\nll fact(ll n)\r\n{\r\n    if (n == 0)\r\n        return 1;\r\n    ll res = 1;\r\n    for (ll i = 2; i <= n; i++)\r\n        res = res * i;\r\n    return res;\r\n}\r\nbool is_prime(ll n)\r\n{\r\n    if (n == 1)\r\n        return false;\r\n    if (n == 2 || n == 3)\r\n        return true;\r\n    if (n % 2 == 0 || n % 3 == 0)\r\n        return false;\r\n    for (ll i = 5; i * i <= n; i += 6)\r\n    {\r\n        if (n % i == 0 || n % (i + 2) == 0)\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nv64 prime_factor(ll n)\r\n{\r\n\r\n    v64 v;\r\n    if (n <= 1)\r\n        return v;\r\n    while (n % 2 == 0)\r\n    {\r\n        v.push_back(2);\r\n        n /= 2;\r\n    }\r\n    while (n % 3 == 0)\r\n    {\r\n        v.push_back(3);\r\n        n /= 3;\r\n    }\r\n    for (ll i = 5; i <= n; i += 6)\r\n    {\r\n        while (n % i == 0)\r\n        {\r\n            v.push_back(i);\r\n            n /= i;\r\n        }\r\n        while (n % (i + 2) == 0)\r\n        {\r\n            v.push_back(i + 2);\r\n            n /= (i + 2);\r\n        }\r\n    }\r\n    if (n > 3)\r\n    {\r\n        v.push_back(n);\r\n    }\r\n    return v;\r\n}\r\n\r\nll binary_power(ll x, ll y, ll p)\r\n{\r\n    ll res = 1;\r\n    while (y > 0)\r\n    {\r\n        if (y % 2 == 1)\r\n        {\r\n            res %= p;\r\n            res = (res * x);\r\n        }\r\n        y = y >> 1;\r\n        x %= p;\r\n        x = (x * x);\r\n        x %= p;\r\n    }\r\n    return res % p;\r\n}\r\n\r\nll modulo_inv(ll a, ll m)\r\n{\r\n    return binary_power(a, m - 2, m);\r\n}\r\n/// ----------------------------------------------Sorting----------------------------------------------- ///\r\n\r\nbool sortbysec(const pair<int, int> &a,\r\n               const pair<int, int> &b)\r\n{\r\n    return (a.second < b.second);\r\n}\r\nvoid print(ll arr[], ll n)\r\n{\r\n    forn(i, n)\r\n    {\r\n        cout << arr[i] << ' ';\r\n    }\r\n    cout << endl;\r\n}\r\n/// ----------------------------------------------DATA STRUCTURES----------------------------------------------- ///\r\n\r\n/// ----------------------------------------------CODE by Sandeep kumar----------------------------------------------- ///\r\n// const ll N = 1e5 + 1;\r\n// vector<ll> g[N];\r\n\r\nvoid solve(int it)\r\n{\r\n    ll n, m;\r\n    cin >> n >> m;\r\n    // set<ll> st1,st2;\r\n    vector<ll> v(n+1,0);\r\n    while (m--)\r\n    {\r\n        ll a, b, c;\r\n        cin >> a >> b >> c;\r\n        \r\n       v[b]=1;\r\n    }\r\n    ll x1 = 0;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        if(v[i]==0)\r\n        {\r\n            x1=i;\r\n            break;\r\n        }\r\n    }\r\n    // trace(x1);\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        if(i==x1)\r\n        {\r\n            continue;\r\n        }\r\n        else{\r\n            cout<<x1<<\" \"<<i<<endl;\r\n        }\r\n    }\r\n    // trace(st1,st2);\r\n\r\n\r\n    \r\n}\r\nsigned main()\r\n{\r\n    fast_cin();\r\n    // freopen (\"input.txt\" , \"r\" , stdin);\r\n    // freopen (\"output.txt\", \"w\" , stdout);\r\n    // manipulated_seive(MAX_SIZE);\r\n    ll t;\r\n    cin >> t;\r\n    for (int it = 1; it <= t; it++)\r\n    {\r\n        solve(it);\r\n    }\r\n    cerr << \"time taken : \" << (float)clock() * 1000 / CLOCKS_PER_SEC << \" ms\" << endl;\r\n    return 0;\r\n}\r\n"
}