{
    "id": 142640341,
    "contestId": 1282,
    "creationTimeSeconds": 1642098662,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1282,
        "index": "A",
        "name": "Temporarily unavailable",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 900,
        "tags": [
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 1282,
        "members": [
            {
                "handle": "deepak"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1577198100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 0,
    "source": "// Motto:-Fail early,Fail Often,Fail Forward.\r\n//  while(true)\r\n// {\r\n//     if(AC)\r\n//     {\r\n//         break;\r\n//     }\r\n//     else if(Contest Over)\r\n//     {\r\n//         Try.\r\n//         Check out Editorial.\r\n//         Understand.\r\n//         Find out your Mistake.\r\n//         Learn the topic (if new).\r\n//         Solve Problems on that topic (if new).\r\n//         Upsolve that problem.\r\n//         break;\r\n//     }\r\n//     else\r\n//     {\r\n//         Try.\r\n//         Use Pen-Paper.\r\n//         Find errors, edge cases, etc.\r\n//         continue;\r\n//     }\r\n// }\r\n// Getting TLE ? Do check for long long int optimisation.\r\n// If A^x , if x is very large , you can do x%=(MOD-1)\r\n    #include<bits/stdc++.h>\r\n    using namespace std;\r\n    // #include <ext/pb_ds/assoc_container.hpp>\r\n    // #include <ext/pb_ds/tree_policy.hpp>\r\n    // using namespace __gnu_pbds;\r\n  \r\n    // #define ordered_set tree<int, null_type,greater_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\r\n     // #define ordered_set_pair tree<pair<int,int>, null_type,less<pair<int,int> >, rb_tree_tag,tree_order_statistics_node_update>\r\n    //=============================LOL======================\r\n    #define int         long long\r\n    #define double      long double\r\n    #define pb          push_back\r\n    #define pf          push_front\r\n    #define pii         pair<int,int>\r\n    #define vi          vector<int>\r\n    #define vnn         vector<vector<int>>\r\n    #define vii         vector<pii>\r\n    #define vs          vector<string>\r\n    #define all(a)      (a).begin(),(a).end()\r\n    #define rall(a)     (a).rbegin(),(a).rend()\r\n    #define x           first\r\n    #define y           second\r\n    #define endl        '\\n'\r\n    #define sz(x)       (int)(x).size()\r\n    #define thunder     ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\r\n    #ifndef ONLINE_JUDGE\r\n       #define debug(x)    cerr<<#x<<\" \"<<x<<endl;\r\n    #else \r\n       #define debug(x)\r\n    #endif  \r\n    //=============================LOL========================\r\n    //++++++++++++++++++++++++Optimisations+++++++++++++++\r\n    //#pragma GCC optimize(\"O1\") \r\n    //#pragma GCC optimize(\"O2\")\r\n    //#pragma GCC optimize(\"O3\") \r\n    //#pragma GCC optimize(\"Os\") \r\n    //#pragma GCC optimize(\"Ofast\") \r\n    //#pragma GCC optimize(\"Ofast\")  \r\n    //#pragma GCC target(\"avx,avx2,fma\")\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++ \r\n    //=========================Chal,Nikal.ab==========================\r\n    #define fo(i,l,u)   for(i=l;i<u;i++)\r\n    #define rfo(i,l,u)  for(i=l;i>=u;i--)\r\n    #define allfo(s)    for(auto it=(s).begin();it!=(s).end();it++)\r\n    #define _init(b)     memset(b,-1,sizeof(b))\r\n    #define _init0(b)     memset(b,0,sizeof(b))\r\n    #define MOD         1000000007\r\n    #define hell        998244353\r\n    #define output(x) cout << (x ? \"YES\" : \"NO\")<<endl;\r\n    #define Output(x) cout << (x ? \"Yes\" : \"No\")<<endl;\r\n    //=========================Chal,Nikal.ab=============================\r\n    //---------------------------Hushiyari mat dikha---------------------------------\r\n    #define MOD2 (998244353)\r\n    #define MOD3 (1000000009)\r\n    #define PI acos(-1)\r\n    #define eps (1e-8)\r\n    #define INF (1e18) \r\n    template<class A,class B>ostream&operator<<(ostream&out,const pair<A,B>&a){return out<<\"(\"<<a.first<<\",\"<<a.second<<\")\";}\r\n    template<class A>ostream&operator<<(ostream&out,const vector<A>&a){for(const A &it:a)out<<it<<\" \";return out;}\r\n    template<class A,class B>istream&operator>>(istream&in,pair<A,B>&a){return in>>a.first>>a.second;}\r\n    template<class A>istream&operator>>(istream&in,vector<A>&a){for(A &i:a)in>>i;return in;}\r\n    ifstream cinn(\"in.txt\");ofstream coutt(\"out.txt\");\r\n    int poww(const int &a,int b,const int &m=MOD){if(b==0)return 1;int x=poww(a,b/2,m);x=x*x%m;if(b&1)x=x*a%m;return x;} \r\n    //---------------------------Hushiyari mat dikha--------------------------------------\r\n    int gcd(int a, int b) \r\n    { \r\n    if (b == 0) \r\n        return a; \r\n    return gcd(b, a % b);    \r\n    }\r\n    int _sum(int n)\r\n    {\r\n        return (n*(n+1))/2;\r\n    }\r\n    int distSq(pii p, pii q) \r\n    { \r\n    return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);  \r\n    }\r\n    // vi fact(101);/\r\n    // int nCr(int n, int r)\r\n    // {\r\n    //    if(!r) return 1;\r\n    //    return (n*nCr(n-1,r-1))/r;\r\n    // }\r\n    const int N = 2e5 + 5;\r\n    // int k,mx=-1,spe;\r\n    // vi adj[N];int vis[N];\r\n    // int dis[N];\r\n    // map<int,int> mm;\r\n    int isPalindrome(string str)\r\n    {\r\n    int low = 0;\r\n    int high = str.length() - 1;\r\n \r\n    while (low < high)\r\n    {\r\n        // if a mismatch happens\r\n        if (str[low] != str[high]) {\r\n            return -1;\r\n        }\r\n \r\n        low++;\r\n        high--;\r\n    }\r\n    return str.length();\r\n    }\r\n    \r\n    // bool comp (string a,string b)\r\n    // {\r\n    //     if(a.length()==b.length())\r\n    //     {\r\n    //         return a<b;\r\n    //     }\r\n    //     return a.length()<b.length();\r\n    // }\r\n    // void build_tree(int l,int r,vi &v,vi &d,int curd)\r\n    // {\r\n    //     if(l>r) return;\r\n    //     if(l==r)\r\n    //     {\r\n    //         d[l]=curd;\r\n    //     }\r\n    //     int mx=l,i;\r\n    //     fo(i,l+1,r+1)\r\n    //     {\r\n    //         if(v[mx]<v[i])\r\n    //         {\r\n    //             mx=i;\r\n    //         }\r\n    //     }\r\n    //     d[mx]=curd;\r\n    //     build_tree(l,mx-1,v,d,curd+1);\r\n    //     build_tree(mx+1,r,v,d,curd+1);\r\n\r\n    // }\r\n    // int ok=1;\r\n    // vii p;\r\n    // int mn=1e18;\r\n    // int dis=1e18,fi=0;\r\n    // void dfs(int node,int tar,int c=0)\r\n    // {\r\n    //     vis[node]=1;\r\n    //     if(node==tar)\r\n    //     {\r\n    //         fi=1;\r\n    //         dis=min(dis,c);\r\n    //         return;\r\n    //     }\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(!vis[n])\r\n    //         {\r\n    //             dfs(n,tar,c+1);\r\n    //         }\r\n    //     }\r\n    // }\r\n    // int th=-1;\r\n    // void dfs1(int node,int c,int spe)\r\n    // {\r\n    //     vis[node]=1;\r\n    //     if(node==spe) \r\n    //     {\r\n    //         th=c;\r\n    //         return;\r\n    //     }\r\n    //     // if(sz(adj[node])!=2) ok=0;\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(!vis[n])\r\n    //         {\r\n    //             dfs1(n,c+1,spe);\r\n    //         }\r\n    //     }\r\n    // }\r\n    // bool cycleBfs(int node)\r\n    // {\r\n    //     queue<pii> q;\r\n    //     q.push({node,-1});\r\n    //     vis[node]=1;\r\n    //     while(!q.empty())\r\n    //     {\r\n    //         int node =q.front().x;\r\n    //         int prev = q.front().y;\r\n    //         q.pop();\r\n    //         for(int n : adj[node])\r\n    //         {\r\n    //             if(vis[n] && prev!=n) return true;\r\n    //             if(!vis[n])\r\n    //             {\r\n    //                 vis[n]=1;\r\n    //                 q.push({n,node});\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //     return false;\r\n    // }\r\n    // bool cycleDfs(int node,int par)\r\n    // {\r\n    //     vis[node]=1;\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(!vis[n])\r\n    //         {\r\n    //             if(cycleDfs(n,node)) return true;\r\n    //         }\r\n    //         else if(par!=n)\r\n    //         {\r\n    //             return true;\r\n    //         }\r\n    //     }\r\n    //     return false;\r\n    // }\r\n    // int dp[2][N];\r\n    // int maxlen(vi &v,int prev,int o,int i)\r\n    // {\r\n    //     if(i>=sz(v)) return 0;\r\n    //     if(dp[o][i]!=-1) return dp[o][i];\r\n    //     if(o)\r\n    //     {\r\n    //         int mx=1;\r\n    //         if(prev==-1)\r\n    //         {\r\n    //             mx=max(mx,maxlen(v,v[i],o,i+1)+1);\r\n    //             mx=max(mx,maxlen(v,prev,o,i+1));\r\n    //         }\r\n    //         else\r\n    //         {\r\n    //             if(prev<v[i]) \r\n    //             {\r\n    //                     mx=max(mx,maxlen(v,v[i],o,i+1)+1);\r\n    //                     mx=max(mx,maxlen(v,prev,o-1,i+1));\r\n    //             }\r\n    //             else\r\n    //             {\r\n    //                 mx=max(mx,maxlen(v,prev,o-1,i+1));\r\n    //             }\r\n    //         }\r\n    //         return dp[o][i]=mx;\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         int mx=-1;\r\n    //         if(prev==-1)\r\n    //         {\r\n    //             mx=max(mx,maxlen(v,v[i],o,i+1)+1);\r\n    //             mx=max(mx,maxlen(v,prev,o,i+1));\r\n    //         }\r\n    //         else \r\n    //         {\r\n    //             if(prev<v[i]) \r\n    //                     mx=max(mx,maxlen(v,v[i],o,i+1)+1);\r\n    //             else\r\n    //                     mx=max(mx,0LL);\r\n    //         }\r\n    //         return dp[o][i]=mx;\r\n    //     }\r\n    // }\r\n    // bool Bipartitebfs(int node)\r\n    // {\r\n    //     color[node]=0;\r\n    //     queue<int> q;\r\n    //     q.push(node);\r\n    //     while(!q.empty())\r\n    //     {\r\n    //         node=q.front();\r\n    //         q.pop();\r\n    //         for(int n : adj[node])\r\n    //         {\r\n    //             if(color[n]==-1)\r\n    //             {\r\n    //                 color[n]=(color[node]^1);\r\n    //                 q.push(n);\r\n    //             }\r\n    //             else if(color[n]==color[node])\r\n    //             {\r\n    //                 return false;\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //     return true;\r\n    // }\r\n    // bool Bipartitedfs(int node,int col)\r\n    // {\r\n    //     color[node]=col;\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(color[n]==-1)\r\n    //         {\r\n    //             if(!Bipartitedfs(n,col^1)) return false;\r\n    //         }\r\n    //         else if(color[n]==color[node])\r\n    //         {\r\n    //             return false;\r\n    //         }\r\n    //     }\r\n    //     return true;\r\n    // }\r\n    // bool cycleDIRdfs(int node)\r\n    // {\r\n    //     vis[node]=1;\r\n    //     dfsvis[node]=1;\r\n\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(!vis[n])\r\n    //         {\r\n    //             if(cycleDIRdfs(n)) return true;\r\n    //         }\r\n    //         else if(dfsvis[n]) return true;\r\n    //     }\r\n    //     dfsvis[node]=0;\r\n    //     return false;\r\n    // }\r\n    // stack<int> s;\r\n    // void TopoSortDFS(int node)\r\n    // {\r\n    //     vis[node]=1;\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(!vis[n]) TopoSortDFS(n);\r\n    //     }\r\n    //     s.push(node);\r\n    // }\r\n    // vi dist(N,1e18);\r\n    // void dijkstra(int src)\r\n    // {\r\n    //     priority_queue<pii,vii,greater<pair<int,int>> > pq;\r\n    //     dist[src]=0;\r\n    //     pq.push({0,src});\r\n    //     while(!pq.empty())\r\n    //     {\r\n    //         int d=pq.top().x;\r\n    //         src = pq.top().y;\r\n    //         pq.pop();\r\n    //         for(pii a : adj[src])\r\n    //         {\r\n    //             int node=a.x;\r\n    //             int wt = a.y;\r\n    //             if(d+wt<dist[node])\r\n    //             {\r\n    //                 dist[node]=d+wt;\r\n    //                 pq.push({dist[node],node});\r\n    //             }\r\n    //         }\r\n    //     }\r\n    // }\r\n    int query(int l,int r)\r\n    {\r\n        cout<<\"?\"<<\" \"<<l<<\" \"<<r<<endl;\r\n        cout.flush();\r\n        int s;\r\n        cin>>s;\r\n        return s;\r\n    }\r\n    bool isprime(int n)\r\n    {\r\n        int i;\r\n        if(n==1) return false;\r\n        for(i=2;i*i<=n;i++)\r\n        {\r\n            if(n%i==0) return false;\r\n        }\r\n        return true;\r\n    }\r\n    // vi adj[N];\r\n    // int vis[N]={};\r\n    // vi ans(N,1e18);\r\n    // void bfs(int node)\r\n    // {\r\n    //     queue<pii> q;\r\n    //     q.push({node,0});\r\n    //     vis[node]=1;\r\n    //     while(!q.empty())\r\n    //     {\r\n    //         node=q.front().x;\r\n    //         int dis=q.front().y;\r\n    //         ans[node]=min(ans[node],dis);\r\n    //         q.pop();\r\n    //         for(int n : adj[node])\r\n    //         {\r\n    //             if(vis[n]) ans[n]=min(ans[n],dis+1);\r\n    //             else if(!vis[n])\r\n    //             {\r\n    //                 q.push({n,dis+1});\r\n    //                 vis[n]=1;\r\n    //             }\r\n    //         }\r\n    //     }\r\n    // }\r\n    // void dfs(int node,int &cntv,int &cnte)\r\n    // {\r\n    //     vis[node]=1;\r\n    //     cntv++;\r\n    //     cnte+=sz(adj[node]);\r\n    //     for(int n : adj[node])\r\n    //     {\r\n    //         if(!vis[n])\r\n    //         {\r\n    //             dfs(n,cntv,cnte);\r\n    //         }\r\n    //     }\r\n    // }\r\n    // bool possible(int len,int s,int n)\r\n    // {\r\n        // int c=1,d=n;\r\n        // int mx=0,mn=0,i;\r\n        // if((len*(len+1))/2<=s && ((n*(n+1))-(n-len)*(n-len+1))/2>=s)\r\n        // {\r\n            // return true;\r\n        // }\r\n        // return false;\r\n    // }\r\n    // bool check(string s,string kk,int n,int m)\r\n    // {\r\n    //     int i,j;\r\n    //     int ans1=0;\r\n    //     fo(i,0,n-m+1)\r\n    //     {\r\n    //         int f=0;\r\n    //         fo(j,0,m)\r\n    //         {\r\n    //             if(s[i+j]!=kk[j])\r\n    //             {\r\n    //                     f=1;\r\n    //                     break;\r\n    //             }\r\n    //         }\r\n    //         if(!f) ans1++;\r\n    //     }\r\n    //     if(ans1==1) return true;\r\n    //     return false;\r\n    // }\r\n    // int merge(vi &v,int st,int mid,int en)\r\n    // {\r\n    //     int i=st,j=mid,k=0;\r\n    //     vi temp(en-st+1);\r\n    //     int cnt=0;\r\n    //     while(i<mid && j<=en)\r\n    //     {\r\n    //         if(v[i]<v[j])\r\n    //         {\r\n    //             cnt+=(en-j+1)*v[i];\r\n    //             temp[k++]=v[i++];\r\n    //         }\r\n    //         else\r\n    //         {\r\n    //             temp[k++]=v[j++];\r\n    //         }\r\n    //     }\r\n    //     while(i<mid) temp[k++]=v[i++];\r\n    //     while(j<=en) temp[k++]=v[j++];\r\n    //     k=0;\r\n    //     fo(i,st,en+1)\r\n    //     {\r\n    //         v[i]=temp[k++];\r\n    //     }\r\n    //     return cnt;\r\n    // }\r\n    // int count_of_inversions(vi &v,int st,int en)\r\n    // {\r\n    //     if(en<=st) return 0;\r\n    //     int mid=(st+en)/2;\r\n    //     int lefcnt=count_of_inversions(v,st,mid);\r\n    //     int ricnt=count_of_inversions(v,mid+1,en);\r\n    //     int mgcnt=merge(v,st,mid+1,en);\r\n    //     return lefcnt+ricnt+mgcnt;\r\n    // }\r\n\r\n    signed main()\r\n    {\r\n        thunder;\r\n        int t,c,b,f,f2,k,t2,t3,i,j,ans1,mnt,mxt,j1,a,n,m;\r\n        cin>>t;\r\n        // t=1;\r\n        while(t--)\r\n        {\r\n            int r;\r\n            cin>>a>>b>>c>>r;\r\n            int l = c - r;\r\n            int r2 = c + r;\r\n            if(a>b) swap(a,b);\r\n            int l1 = max(l,a);\r\n            int r1 = min(r2,b);\r\n            if(r1<l1) cout<<(b-a)<<endl;\r\n            else cout<<(b-a)-max(0LL,r1-l1)<<endl;\r\n\r\n        }\r\n        \r\n        \r\n\t}\r\n\t        \r\n"
}