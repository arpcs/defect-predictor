{
    "id": 187580230,
    "contestId": 758,
    "creationTimeSeconds": 1672638825,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 758,
        "index": "C",
        "name": "Unfair Poll",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "binary search",
            "constructive algorithms",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 758,
        "members": [
            {
                "handle": "Awab"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1484838300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 111,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 102400,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define all(v)          ((v).begin()), ((v).end())\r\n#define sz(v)           ((int)((v).size()))\r\n#define clr(v, d)        memset(v,d, sizeof(v))\r\n#define rep(i, v)        for(int i = 0; i < sz(v); i++)\r\n#define lp(i, n)         for(int i = 0; i < (int)n; i++)\r\n#define lp1(i, n)         for(int i = 1; i <= (int)n; i++)\r\n#define lpi(i, j, n)     for(int i = (j); i < (int)(n); i++)\r\n#define lpd(i, j, n)     for(int i = (j); i >= (int)(n); i--)\r\n#define pb               push_back\r\n#define MP               make_pair\r\n#define X real()\r\n#define Y imag()\r\n#define sqr(x) ((x)*(x))\r\n#define lets_Go ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\r\n\r\n// You can rewrite any of following as functions\r\n#define angle(a)                (atan2((a).imag(), (a).real()))\r\n#define vec(a,b)                ((b)-(a))\r\n\r\n#define length(a)               (hypot((a).imag(), (a).real()))\r\n#define normalize(a)            (a)/length(a)\r\n\r\n// dp = a*b cos(T), if zero -> prep\r\n#define dp(a,b)                 ((conj(a)*(b)).real())\r\n// cp = a*b sin(T), if zero -> parllel\r\n#define cp(a,b)         ((conj(a)*(b)).imag())\r\n#define same(p1,p2)     (dp(vec(p1,p2),vec(p1,p2)) < EPS)\r\n#define lengthSqr(p)    dp(p,p)\r\n#define rotateO(p,ang)          ((p)*exp(point(0,ang)))\r\n#define rotateA(p,ang,about)    (rotateO(vec(about,p),ang)+about)\r\n#define reflect(v,m)            (conj((v)/(m))*(m))\r\n\r\n\r\n\r\ntypedef long long   ll;\r\ntypedef vector<int> vi;\r\ntypedef long double ld;\r\ntypedef vector<double> vd;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<vd> vvd;\r\ntypedef vector<string> vs;\r\ntypedef complex <double> point;\r\ntypedef pair<int,int> pi;\r\n \r\nconst int OO = (int)2e9;\r\nconst double PI = acos(-1.0);\r\nconst double EPS = (1e-10);\r\nint dcmp(double x, double y) { return fabs(x-y) <= EPS ? 0 : x < y ? -1 : 1;}\r\nstruct Point {\r\n    double i, j;\r\n    \r\n    Point(const double i, const double j) : i(i) , j(j) {}\r\n    \r\n};\r\n\r\nint distSq(int x1 , int y1, int x2, int y2)\r\n{\r\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\r\n}\r\n\r\nbool isSquare(int x1 , int y1, int x2, int y2, int x3, int y3, int x4, int y4)\r\n{\r\n    int d2 = distSq(x1, y1,x2,y2); // from p1 to p2\r\n    int d3 = distSq(x1, y1,x3,y3); // from p1 to p3\r\n    int d4 = distSq(x1, y1,x4,y4); // from p1 to p4\r\n \r\n    if (d2 == 0 || d3 == 0 || d4 == 0)\r\n        return false;\r\n \r\n    if (d2 == d3 && 2 * d2 == d4\r\n        && 2 * distSq(x2, y2,x4,y4) == distSq(x2, y2,x3,y3)) {\r\n        return true;\r\n    }\r\n\r\n    if (d3 == d4 && 2 * d3 == d2\r\n        && 2 * distSq(x3, y3,x2,y2) == distSq(x3, y3,x4,y4)) {\r\n        return true;\r\n    }\r\n    if (d2 == d4 && 2 * d2 == d3\r\n        && 2 * distSq(x2, y2,x3,y3) == distSq(x2, y2,x4,y4)) {\r\n        return true;\r\n    }\r\n \r\n    return false;\r\n}\r\n\r\ndouble fixAngle(double A){\r\n    return A > 1 ? 1 : (A < -1 ? -1 : A);\r\n}\r\n\r\n\r\ndouble getAngle_A_abc(double a, double b, double c){\r\n    return acos( fixAngle( (b*b+c*c-a*a)/(2*b*c)) );\r\n}\r\n\r\nvoid merge_sort(vector<int> &v) {\r\n    int n = (int)v.size();\r\n    if (n == 1)\r\n        return;\r\n\r\n    vector<int> a, b;\r\n    for (int i = 0; i < n / 2; i++) {\r\n        a.push_back(v[i]);\r\n    }\r\n    for (int i = n / 2; i < n; i++) {\r\n        b.push_back(v[i]);\r\n    }\r\n    merge_sort(a);\r\n    merge_sort(b);\r\n\r\n    v.clear();\r\n\r\n    // merging a and b into v\r\n    int i = 0, j = 0;\r\n    while (i < a.size() && j < b.size()) {\r\n        if (a[i] < b[j]) {\r\n            v.push_back(a[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            v.push_back(b[j]);\r\n            j++;\r\n        }\r\n    }\r\n    if (i != a.size()) {\r\n        for (; i < a.size(); i++) {\r\n            v.push_back(a[i]);\r\n        }\r\n    }\r\n    if (j != b.size()) {\r\n        for (; j < b.size(); j++) {\r\n            v.push_back(b[j]);\r\n        }\r\n    }\r\n}\r\nvector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\r\n    stack<int>stack;\r\n    map<int,int>map;\r\n    vector<int>ans;\r\n    for(int i=0;i<nums2.size();i++){\r\n        while(!stack.empty()){\r\n            if(stack.top()<nums2[i]){\r\n                map.insert(pair<int,int>(stack.top(),nums2[i]));\r\n                stack.pop();\r\n            }else break;\r\n        }\r\n        stack.push(nums2[i]);\r\n    }\r\n    \r\n    for(int i=0;i<nums1.size();i++){\r\n        int val = map[nums1[i]];\r\n        if(val==0)ans.push_back(-1);\r\n        else ans.push_back(val);\r\n    }\r\n    return ans;\r\n}\r\nbool is_prime(ll n) {\r\n    if (n == 2) return true;\r\n    if (n < 2 || n % 2 == 0) return false;\r\n    for(ll i = 3; i * i <= n; i += 2){\r\n        if(n%i == 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nbool cmp(const pair<pair<int,int>,pair<int,int>> &a,\r\n              const pair<pair<int,int>,pair<int,int>> &b)\r\n{\r\n    if(a.first.first < b.first.first) return true;\r\n    else if(a.first.first == b.first.first){\r\n        if(a.first.second < b.first.second) return true;\r\n        else if(a.first.second == b.first.second){\r\n            if(a.second.first < b.second.first) return true;\r\n            else return false;\r\n        }\r\n        else return false;\r\n    }\r\n    else return false;\r\n}\r\n\r\ndouble toRadian(double degree){\r\n    return (degree*PI/180.0);\r\n}\r\n\r\nint gcd(int a , int b){\r\n    return (b == 0) ? a : gcd(b,a%b);\r\n}\r\n\r\nint lcm(int a, int b){\r\n    return a * b / gcd(a,b);\r\n}\r\n\r\nstring DecimalToBinaryString(int a)\r\n{\r\n    string binary = \"\";\r\n    int mask = 1;\r\n    for(int i = 0; i < 31; i++)\r\n    {                                                          \r\n        if((mask&a) >= 1)\r\n            binary = \"1\"+binary;\r\n        else\r\n            binary = \"0\"+binary;\r\n        mask<<=1;\r\n    }\r\n    return binary;\r\n}\r\n\r\n\r\n\r\nstruct edge{\r\n    int from , to , w;\r\n    edge(int from, int to, int w) : from(from), to(to), w(w) {}\r\n    \r\n    bool operator < (const edge &e) const{      // STL priority_queue need it > , or modify data -ve, or use parameter less\r\n        return w > e.w;\r\n    }\r\n};\r\n\r\n\r\nstruct UnionFind{\r\n    vi rank , parent;\r\n    int forests;        // Number of current forests\r\n    UnionFind(int n){\r\n        parent = vi(n); rank = vi(n);\r\n        lp(i,n){ parent[i] = i ; rank[i] = 1;}\r\n    }\r\n    \r\n    int findSet(int x){\r\n        // while(x != parent[x]) x = parent[x];\r\n        if(parent[x] == x) return x;\r\n        return parent[x] = findSet(parent[x]);\r\n    }\r\n    void link(int x, int y){\r\n        if(rank[x] > rank[y]) swap(x,y);\r\n        parent[x] = y;\r\n        if(rank[x] == rank[y]) rank[y] ++;\r\n    }\r\n    bool unionSets(int x, int y){\r\n        x = findSet(x); y = findSet(y);\r\n        if(x != y){\r\n            link(x,y);\r\n            forests --;     // After merging two forests\r\n        }\r\n        return x != y;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////// Other Utilities //////////////////////////////\r\n    bool sameSet(int x, int y){\r\n        return findSet(x) == findSet(y);\r\n    }\r\n    \r\n    vector<vi> connectedComponents(){\r\n        vector<vi> list(sz(parent));\r\n        lp(i,sz(parent))    list[findSet(i)].pb(i);\r\n        return list;\r\n    }\r\n};\r\n\r\n\r\n\r\n \r\npair<int, vector<edge> > MSTKruskal(vector<edge> edgeList, int n){\r\n    UnionFind uf(n);\r\n    vector<edge> edges;\r\n    int mstCost = 0;\r\n    priority_queue<edge> q;\r\n    rep(i,edgeList)     q.push(edgeList[i]);\r\n    while(!q.empty()){\r\n        edge e = q.top(); q.pop();\r\n        if(uf.unionSets(e.from,e.to)){\r\n            edges.pb(e);\r\n            mstCost += e.w;\r\n        }\r\n    }\r\n    if(sz(edges) != (n-1))      return MP(-OO, vector<edge>());\r\n    return MP(mstCost,edges);\r\n}\r\n\r\n\r\nll factorial(ll n){\r\n    ll fact = 1;\r\n    for(ll i = 2; i <= n; i++)\r\n        fact = fact * i;\r\n    return fact;\r\n}\r\n\r\nll nCr2(ll n, ll r){\r\n    ll z = 1;\r\n    for(int i = 0; i < r; i++)\r\n        z = z * (n-i) / (i+1);\r\n    return z;\r\n}\r\n\r\n\r\nll power(ll x, ll y, ll m){\r\n    if(y == 0) return 1;\r\n    ll p = power(x, y/2, m) % m;\r\n    p = (p * p) % m;\r\n    \r\n    return (y % 2 == 0) ? p : (x*p) % m;\r\n}\r\n\r\n\r\nll cubr(ll x){\r\n    ll l = 0, r = OO;\r\n    while(l != r){\r\n        ll m = (l + r + 1) / 2;\r\n        if(m * m * m > x) r = m - 1;\r\n        else l = m;\r\n    }\r\n    return l;\r\n}\r\n\r\nvector<ll> generate_divisors(ll n){         //  O( sqrt(n) )\r\n    vector<ll> divisors;\r\n    ll i;\r\n    for(i = 1; i * i < n; i++){\r\n        if(n % i == 0){\r\n            divisors.push_back(i);\r\n            divisors.push_back(n/i);\r\n        }\r\n    }\r\n    if(i * i == n)\r\n        divisors.push_back(i);\r\n    return divisors;            // Not sorted\r\n}\r\n\r\n\r\nll perfectSquareSum(ll n){\r\n    return (n*(n+1) * (2*n+1)) / 6;\r\n}\r\n\r\nll summation(ll n){\r\n    return n*(n+1) / 2;\r\n}\r\n\r\n\r\nint ccw(point p0, point p1, point p2){\r\n    point v1(p1-p0), v2(p2-p0);\r\n    if(cp(v1,v2) > +EPS) return +1;\r\n    if(cp(v1,v2) < -EPS) return -1;\r\n    if(v1.X*v2.X < -EPS || v1.Y*v2.X < -EPS) return -1;\r\n    if(norm(v1) < norm(v2) - EPS) return +1;\r\n    return 0;\r\n}\r\n\r\nbool intersect(point p1, point p2, point p3, point p4){\r\n    bool x = (p1 == p2), y = (p3 == p4);\r\n    if(x & y) return (p1 == p3);\r\n    if(x) return ccw(p3,p4,p1) == 0;\r\n    if(y) return ccw(p1,p2,p3) == 0;\r\n    return ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0;\r\n}\r\n\r\nbool intersectSegments(point a, point b, point c, point d, point &intersect){\r\n    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);\r\n    if(fabs(d1) < EPS) return false;   // Parallel || Identical\r\n    double t1 = d2 / d1, t2 = d3 / d1;\r\n    intersect = a + (b-a)*t1;\r\n    if(t1 < -EPS || t2 < -EPS || t2 > 1 + EPS) return false; // e.g ab is ray cd is segment... change to whatever\r\n    return true;\r\n}\r\n\r\n\r\npair<double, point> findCircle(point a, point b, point c){\r\n    // create median, vector, its prependicular\r\n    point m1 = (b+a)*0.5, v1 = (b-a), pv1 = point(v1.Y, -v1.X);\r\n    point m2 = (b+c)*0.5, v2 = (b-c), pv2 = point(v2.Y, -v2.X);\r\n    point end1 = m1 + pv1, end2 = m2 + pv2, center;\r\n    intersectSegments(m1,end1,m2,end2,center);\r\n    return MP(length(a-center), center);\r\n}\r\n\r\nvector<point> intersectCircleCircle(point c1, double r1, point c2, double r2){\r\n    // Handle infinity case first : same center / radius and r > 0\r\n    if(same(c1,c2) && dcmp(r1,r2) == 0 && dcmp(r1,0) > 0)\r\n        return vector<point> (3,c1);    // infinity : 2 same circles (not points)\r\n    \r\n    // Compute 2 intersection case and handle 0, 1, 2 cases\r\n    double ang1 = angle(c2 - c1), ang2 = getAngle_A_abc(r2,r1,length(c2-c1));\r\n    \r\n    if(::isnan(ang2))   // if r1 or d(length(c2-c1)) = 0 => nan in getAngle_A_abc(/0)\r\n        ang2 = 0;       // fix corruption\r\n    \r\n    vector<point> v(1, polar(r1, ang1 + ang2) + c1);\r\n    \r\n    // if point NOT on the 2 circles = no intersection\r\n    if(dcmp(dp(v[0]-c1,v[0]-c1), r1*r1) != 0 || dcmp(dp(v[0] - c2,v[0] - c2), r2*r2) != 0) return vector<point> ();\r\n    \r\n    v.pb(polar(r1, ang1 - ang2) + c1);\r\n    if(same(v[0],v[1])) v.pop_back();     // if same then 1 intersection only\r\n    return v;\r\n}\r\n\r\n\r\nbool cmpPoints(const point &a,\r\n              const point &b)\r\n{\r\n    if(dcmp(a.X,b.X) == -1) return true;\r\n    else if(dcmp(a.X,b.X) == 0){\r\n        if(dcmp(a.Y,b.Y) == -1) return true;\r\n        return false;\r\n    }\r\n    return false;\r\n}\r\n\r\nint dx[8] = { 0, 0, -1, 1, 1, 1, -1, -1 };\r\nint dy[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\r\n\r\nll stu[100][100];\r\n\r\nint main()\r\n{\r\n    //    freopen(\"input.txt\", \"r\", stdin);\r\n    //    freopen(\"output.txt\", \"w\", stdout);\r\n    lets_Go;\r\n    ll n, m, k, x, y;\r\n    cin>>n>>m>>k>>x>>y;\r\n    ll T = n*m + (n-2)*m;\r\n    if(n == 1) T = m;\r\n    for(int i = 0; i < n; i++){\r\n        for(int j = 0; j < m; j++){\r\n            stu[i][j] = k / T;\r\n            if(i > 0 && i < n-1) stu[i][j] *= 2;\r\n        }\r\n    }\r\n    ll rem = k % T;\r\n    int i = 0;\r\n    bool rev = false;\r\n    while(rem > 0){\r\n        int j = 0;\r\n        while(j < m && rem > 0){\r\n            stu[i][j] ++;\r\n            rem--;\r\n            j++;\r\n        }\r\n        if(i == n-1) rev = true;\r\n        else if(i == 0) rev = false;\r\n        if(rev) i --;\r\n        else i++;\r\n        if(i == n || i == -1) i = 0;\r\n    }\r\n    if(n != 1)\r\n        cout<<max({stu[0][0],stu[1][0],stu[n-2][0]})<<' '<<stu[n-1][m-1]<<' '<<stu[x-1][y-1]<<'\\n';\r\n    else\r\n        cout<<stu[0][0]<<' '<<stu[n-1][m-1]<<' '<<stu[x-1][y-1]<<'\\n';\r\n    return 0;\r\n}\r\n"
}