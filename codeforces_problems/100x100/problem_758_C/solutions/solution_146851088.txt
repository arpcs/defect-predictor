{
    "id": 146851088,
    "contestId": 758,
    "creationTimeSeconds": 1645201258,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 758,
        "index": "C",
        "name": "Unfair Poll",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "binary search",
            "constructive algorithms",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 758,
        "members": [
            {
                "handle": "shohan_01"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1484838300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n//#include <ext/pb_ds/assoc_container.hpp>\r\n//#include <ext/pb_ds/tree_policy.hpp>\r\n#include<unordered_set>\r\n\r\n\r\n#define debug(x) cout<<#x<<\" = \"<<x<<endl; \r\n#define fix(prec) cout << setprecision(prec) << fixed;\r\n#define ms(arr, v) memset(arr, v, sizeof(arr))\r\n#define pb push_back\r\n#define lcm(a,b) (a*b)/(__gcd(a,b))\r\n#define max3(a,b,c) max(max(a,b),c)\r\n#define min3(a,b,c) min(min(a,b),c)\r\n#define google(t) cout<<\"Case #\"<<t<<\": \"; \r\nusing namespace std;\r\n//using namespace __gnu_pbds;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\n\r\n\r\n//typedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>  ordered_set;\r\n\r\n\r\nconstexpr ll MAXX = 2e18;\r\nconstexpr ld EPS = 1e-9;\r\nconstexpr ll P = 1000000007;//998244853;\r\n\r\n\r\n\r\n\r\nll  mod_add(ll a, ll b, ll m) { a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll  mod_mul(ll a, ll b, ll m) { a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll  mod_sub(ll a, ll b, ll m) { a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\n\r\n\r\ntemplate <typename T> ostream& operator <<(ostream& output, const vector<T>& data)\r\n{\r\n      for (const T& x : data)\r\n            output << x <<\" \";\r\n      return output;\r\n}\r\n\r\n\r\ntemplate <typename T> istream& operator>>(istream& input,vector<T>& data)\r\n{\r\n      for (auto& item : data)\r\n      {\r\n           input >> item;\r\n      }\r\n      return input;\r\n}\r\n\r\n\r\n/************************************* SIEVE OF ERASTOSTHENES ***************************************************************/\r\n\r\n\r\nvector<bool> seive(ll n)\r\n{\r\n      vector<bool>arr(n+1, true);\r\n      for( int i=2; i*i <= n ; i++ )\r\n      {\r\n            if(arr[i])\r\n            {\r\n                 for(int j=i*i; j<=n; j+=i)\r\n                 {\r\n                      arr[j] = false;\r\n                 }\r\n            }\r\n      }\r\n      return arr;\r\n}\r\n\r\n\r\nvector<ll> lp;\r\nvector<ll> prime;\r\nvoid seive_op( ll n )\r\n{\r\n      lp.assign(n+1,0);\r\n      ll m=0;\r\n      for(int i=2;i<=n;i++)\r\n      {\r\n           if(lp[i] == 0)\r\n           {\r\n               lp[i]=i;\r\n               prime.push_back(i);\r\n               m++;\r\n           }\r\n           for(int j=0 ; (j<m) && (prime[j]<=lp[i]) && (i*prime[j]<=n) ; j++)\r\n           {\r\n                lp[i*prime[j]] = prime[j];\r\n           }\r\n      }\r\n}\r\n\r\n\r\n/***********************************************************************************************************************************/\r\nmap<ll,ll> primefactorisation(ll n)\r\n{\r\n       map<ll,ll>mp;\r\n       while(n!=1)\r\n       {\r\n             mp[lp[n]]++;\r\n             n/=(lp[n]);\r\n       }\r\n       return mp;\r\n\r\n\r\n}\r\n\r\n\r\n//Modular Exponetiation (2^k ary method) \r\nll mod_exp(ll x, ll y, ll p)\r\n{\r\n      ll ans=1LL,r=1LL;\r\n      x%=p;\r\n      while(r>0&&r<=y)\r\n      {\r\n           if(r&y)\r\n           {\r\n                ans*=x;\r\n                ans%=p;\r\n           }\r\n           r = (r<<1LL);\r\n           x*=x;\r\n           x%=p;\r\n      }\r\n      return ans;\r\n}\r\nll  mod_inv(ll n, ll p)\r\n{\r\n      /* This works because n and p are coprime as p is already prime in most questions\r\n         and n<p for most question (ie n is not a multiple of p) */\r\n       return mod_exp(n, p - 2LL, p);\r\n}\r\n\r\n\r\nll mod_gp(ll a, ll n, ll p)\r\n{\r\n     // this is for computing 1+(a^2)+(a^3)+(a^4)+...(a^n) \r\n     // total number of terms is n+1\r\n     if(n==0) return 1;\r\n        if(n==1) return (1+a);\r\n        ll ans=(1+a);\r\n     ll temp=1LL;\r\n     if(n%2==1)\r\n     {\r\n              temp=mod_gp(mod_mul(a,a,P),(n-1)/2,P);\r\n                return mod_mul(ans,temp,P);\r\n     }\r\n     else\r\n     {\r\n              temp=mod_gp(mod_mul(a,a,P),(n/2)-1,P);\r\n              ans=mod_mul(ans,temp,P);\r\n              ans=mod_mul(ans,a,P);\r\n              ans=mod_add(ans,1LL,P);\r\n     }\r\n     return ans;\r\n}\r\n\r\n\r\nbool isprime(ll x)\r\n{\r\n        for (ll i=2; i*i<=x; i++)\r\n        {\r\n              if ( x%i==0 )\r\n              {\r\n                    return 0;\r\n              }\r\n        }\r\n        return 1;\r\n}\r\n\r\n\r\nbool cmp(pair<ll,ll> p1, pair<ll,ll> p2)\r\n{\r\n        return (p1.first > p2.first);\r\n}\r\n\r\n\r\n/***************************************** NCR MOD P ****************************************************************************/\r\n\r\n\r\nvector<ll> fact;\r\nvector<ll> mod_in;\r\nvoid pre_fermat()\r\n{\r\n       fact.assign( 1000001, 1);\r\n       mod_in.assign( 1000001,1);\r\n       fact[0]=1;\r\n       for(int i=1; i<= (1000000); i++)\r\n       {\r\n             fact[i] = mod_mul(fact[i-1], i, P);\r\n             mod_in[i]=mod_inv(fact[i],P);\r\n       }\r\n}\r\nll ncr(ll n, ll r, ll p)\r\n{\r\n        if (n < r)\r\n        {\r\n            return 0LL;\r\n        }\r\n\r\n\r\n        if (r == 0) \r\n        {\r\n                return 1LL; \r\n        }\r\n\r\n\r\n       ll ans=mod_mul(fact[n],mod_mul(mod_in[r],mod_in[n-r],P),P);\r\n       return ans;\r\n}\r\n\r\n\r\n/************************************************************************************************************************************/\r\n\r\n\r\nvector<ll> bfs(vector<vector<ll>>&edge, ll start, ll n)\r\n{\r\n      ll curr = start;\r\n      vector<bool> visited(n+1,0);\r\n      vector<ll> lvl(n+1);\r\n      lvl[curr]=0;\r\n      queue<ll> qq;\r\n      qq.push(curr);\r\n      visited[curr]=1;\r\n\r\n\r\n        while(!qq.empty()) \r\n        {\r\n               curr=qq.front(); \r\n               for( ll x : edge[curr] ) \r\n            {\r\n                  if(!visited[x]) \r\n                  {\r\n                        lvl[x] = 1 + lvl[curr];\r\n                        qq.push(x);\r\n                        visited[x] = 1;\r\n                  }\r\n            }\r\n            qq.pop();\r\n      }\r\n      return lvl;\r\n}\r\n\r\n\r\nvoid dfs(vector<vector<ll>>&edge, ll curr, ll prev)\r\n{\r\n       for(ll x:edge[curr])\r\n       {\r\n            if(x!=prev)\r\n            {\r\n                  dfs(edge,x,curr);\r\n            }\r\n       }\r\n}\r\n\r\n\r\nvector <string> bor = {\"YES\",\"NO\"};\r\n\r\n\r\nvoid solve()\r\n{\r\n      ll n;\r\n      cin>>n;\r\n      ll m,k;\r\n      cin>>m>>k;\r\n      ll x,y;\r\n      cin>>x>>y;\r\n      ll temp=(k/(2*n-2));\r\n      ll r=temp%(2*n-2);\r\n      vector<vector<ll>>arr(n+1,vector<ll>(m+1));\r\n      for(int i=1;i<=(n);i++)\r\n      {\r\n            for(int j=1;j<=m;j++)\r\n            {\r\n                  arr[i][j]=temp;\r\n            }\r\n      }\r\n       for(int i=n-2;i>=(2);i--)\r\n      {\r\n            for(int j=1;j<=m;j++)\r\n            {\r\n                  arr[i][j]=temp;\r\n            }\r\n      }\r\n      ll xx=1,yy=1;\r\n      k=r;\r\n      bool fg=1;\r\n      while(k--)\r\n      {\r\n            arr[xx][yy]++;\r\n            yy++;\r\n            if(yy==m+1)\r\n            {\r\n                  yy=1;\r\n                  if(fg)\r\n                  {\r\n                        if(xx==n)\r\n                        {\r\n                              fg=0;\r\n                              xx--;\r\n                        }\r\n                        else\r\n                        {\r\n                              xx++;\r\n                        }\r\n                  }\r\n                  else{\r\n                        if(xx==1)\r\n                        {\r\n                              fg=1;\r\n                              xx++;\r\n                        }\r\n                        else\r\n                        {\r\n                              xx--;\r\n                        }\r\n                  }\r\n            }\r\n      }\r\n      ll maxx=0,minn=INT_MIN;\r\n      for(int i=0;i<n;i++)\r\n      {\r\n            for(int j=0;j<m;j++)\r\n            {\r\n                  maxx=max(arr[i+1][j+1],maxx);\r\n                  minn=min(arr[i+1][j+1],minn);\r\n            }\r\n      }\r\n      \r\ncout<<maxx<<\" \"<<minn<<\" \"<<arr[x][y]<<\"\\n\";\r\n       \r\n       \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n     ios::sync_with_stdio(0);\r\n     cin.tie(0);\r\n     cout.tie(0);\r\n     ll t=1;\r\n     \r\n     while (t--)\r\n     {\r\n          solve();\r\n     }\r\n\r\n\r\n     return 0;\r\n}\r\n"
}