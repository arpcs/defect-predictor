{
    "id": 196595889,
    "contestId": 1665,
    "creationTimeSeconds": 1678351324,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1665,
        "index": "C",
        "name": "Tree Infection",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1600,
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "trees"
        ]
    },
    "author": {
        "contestId": 1665,
        "members": [
            {
                "handle": "sjNxksbzj"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1649428500
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 27,
    "timeConsumedMillis": 514,
    "memoryConsumedBytes": 35123200,
    "source": "import sys\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nfrom math import inf, gcd, lcm, log, log2, floor, ceil, sqrt, isqrt\r\nfrom collections import defaultdict, deque, Counter\r\nfrom heapq import heappush, heappop, heapify\r\nfrom functools import lru_cache\r\nfrom itertools import permutations, accumulate, groupby\r\nfrom bisect import insort, bisect_left, bisect_right\r\nimport random\r\n\r\n#template taken from https://codeforces.com/contest/1703/submission/164030692 - Author mkawa2\r\nclass DefaultDict:\r\n    def __init__(self, default=None):\r\n        self.default = default\r\n        self.x = random.randrange(1, 1 << 31)\r\n        self.dd = defaultdict(default)\r\n    def __repr__(self):\r\n        return \"{\"+\", \".join(f\"{k ^ self.x}: {v}\" for k, v in self.dd.items())+\"}\"\r\n    def __eq__(self, other):\r\n        for k in set(self) | set(other):\r\n            if self[k] != other[k]: return False\r\n        return True\r\n    def __or__(self, other):\r\n        res = DefaultDict(self.default)\r\n        for k, v in self.dd: res[k] = v\r\n        for k, v in other.dd: res[k] = v\r\n        return res\r\n    def __len__(self):\r\n        return len(self.dd)\r\n    def __getitem__(self, item):\r\n        return self.dd[item ^ self.x]\r\n    def __setitem__(self, key, value):\r\n        self.dd[key ^ self.x] = value\r\n    def __delitem__(self, key):\r\n        del self.dd[key ^ self.x]\r\n    def __contains__(self, item):\r\n        return item ^ self.x in self.dd\r\n    def items(self):\r\n        for k, v in self.dd.items(): yield (k ^ self.x, v)\r\n    def keys(self):\r\n        for k in self.dd: yield k ^ self.x\r\n    def values(self):\r\n        for v in self.dd.values(): yield v\r\n    def __iter__(self):\r\n        for k in self.dd: yield k ^ self.x\r\nclass CounterInt(DefaultDict):\r\n    def __init__(self, aa=[]):\r\n        super().__init__(int)\r\n        for a in aa: self.dd[a ^ self.x] += 1\r\n    def __add__(self, other):\r\n        res = CounterInt()\r\n        for k in set(self) | set(other):\r\n            v = self[k]+other[k]\r\n            if v > 0: res[k] = v\r\n        return res\r\n    def __sub__(self, other):\r\n        res = CounterInt()\r\n        for k in set(self) | set(other):\r\n            v = self[k]-other[k]\r\n            if v > 0: res[k] = v\r\n        return res\r\n    def __and__(self, other):\r\n        res = CounterInt()\r\n        for k in self:\r\n            v = min(self[k], other[k])\r\n            if v > 0: res[k] = v\r\n        return res\r\n    def __or__(self, other):\r\n        res = CounterInt()\r\n        for k in set(self) | set(other):\r\n            v = max(self[k], other[k])\r\n            if v > 0: res[k] = v\r\n        return res\r\nclass Set:\r\n    def __init__(self, aa=[]):\r\n        self.x = random.randrange(1, 1 << 31)\r\n        self.st = set()\r\n        for a in aa: self.st.add(a ^ self.x)\r\n    def __repr__(self):\r\n        return \"{\"+\", \".join(str(k ^ self.x) for k in self.st)+\"}\"\r\n    def __len__(self):\r\n        return len(self.st)\r\n    def add(self, item):\r\n        self.st.add(item ^ self.x)\r\n    def discard(self, item):\r\n        self.st.discard(item ^ self.x)\r\n    def __contains__(self, item):\r\n        return item ^ self.x in self.st\r\n    def __iter__(self):\r\n        for k in self.st: yield k ^ self.x\r\n    def pop(self):\r\n        return self.st.pop() ^ self.x\r\n    def __or__(self, other):\r\n        res = Set(self)\r\n        for a in other: res.add(a)\r\n        return res\r\n    def __and__(self, other):\r\n        res = Set()\r\n        for a in self:\r\n            if a in other: res.add(a)\r\n        for a in other:\r\n            if a in self: res.add(a)\r\n        return res\r\n\r\n \r\n#https://leetcode.com/problems/create-sorted-array-through-instructions/discuss/1245397/C%2B%2BJavaPython-Binary-Indexed-Tree-Feel-free-to-reuse   \r\nclass BIT:\r\n    def __init__(self, size):\r\n        self.bit = [0] * (size + 1)\r\n\r\n    def getSum(self, idx):  # Get sum in range [0..idx], 1-based indexing\r\n        s = 0\r\n        while idx > 0:\r\n            s += self.bit[idx]\r\n            idx -= idx & (-idx)\r\n        return s\r\n\r\n    def getSumRange(self, left, right):  # left, right inclusive, 1-based indexing\r\n        return self.getSum(right) - self.getSum(left - 1)\r\n\r\n    def addValue(self, idx, val):  # 1-based indexing\r\n        while idx < len(self.bit):\r\n            self.bit[idx] += val\r\n            idx += idx & (-idx)\r\n            \r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = defaultdict(TrieNode)\r\n        self.word = None\r\n\r\n    def addWord(self, word):\r\n        cur = self\r\n        for c in word:\r\n            cur = cur.children[c]\r\n        cur.word = \"*\"\r\n\r\nclass UnionFind:\r\n    def __init__(self, n):\r\n        self.parent = list(range(n))\r\n        self.size = [1] * n\r\n        self.num_sets = n\r\n\r\n    def find(self, a):\r\n        acopy = a\r\n        while a != self.parent[a]:\r\n            a = self.parent[a]\r\n        while acopy != a:\r\n            self.parent[acopy], acopy = a, self.parent[acopy]\r\n        return a\r\n\r\n    def union(self, a, b):\r\n        a, b = self.find(a), self.find(b)\r\n        if a != b:\r\n            if self.size[a] < self.size[b]:\r\n                a, b = b, a\r\n\r\n            self.num_sets -= 1\r\n            self.parent[b] = a\r\n            self.size[a] += self.size[b]\r\n\r\n    def set_size(self, a):\r\n        return self.size[self.find(a)]\r\n\r\n    def __len__(self):\r\n        return self.num_sets\r\n    \r\nclass LazySegmentTree:\r\n    def __init__(self, data, default=0, func=max):\r\n        \"\"\"initialize the lazy segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n        self._lazy = [0] * (4 * _size)\r\n\r\n        self.data = [default] * (4 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def _push(self, idx):\r\n        \"\"\"push query on idx to its children\"\"\"\r\n        # Let the children know of the queries\r\n        q, self._lazy[idx] = self._lazy[idx], 0\r\n\r\n        self._lazy[2 * idx] += q\r\n        self._lazy[2 * idx + 1] += q\r\n        self.data[2 * idx] += q\r\n        self.data[2 * idx + 1] += q\r\n\r\n    def _update(self, idx):\r\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\r\n        for i in reversed(range(1, idx.bit_length())):\r\n            self._push(idx >> i)\r\n\r\n    def _build(self, idx):\r\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\r\n            idx >>= 1\r\n\r\n    def add(self, start, stop, value):\r\n        \"\"\"lazily add value to [start, stop)\"\"\"\r\n        start = start_copy = start + self._size\r\n        stop = stop_copy = stop + self._size\r\n        while start < stop:\r\n            if start & 1:\r\n                self._lazy[start] += value\r\n                self.data[start] += value\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                self._lazy[stop] += value\r\n                self.data[stop] += value\r\n            start >>= 1\r\n            stop >>= 1\r\n\r\n        # Tell all nodes above of the updated area of the updates\r\n        self._build(start_copy)\r\n        self._build(stop_copy - 1)\r\n\r\n    def query(self, start, stop, default=0):\r\n        \"\"\"func of data[start, stop)\"\"\"\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        # Apply all the lazily stored queries\r\n        self._update(start)\r\n        self._update(stop - 1)\r\n\r\n        res = default\r\n        while start < stop:\r\n            if start & 1:\r\n                res = self._func(res, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res = self._func(res, self.data[stop])\r\n            start >>= 1\r\n            stop >>= 1\r\n        return res\r\n\r\n    def __repr__(self):\r\n        return \"LazySegmentTree({0})\".format(self.data)\r\n    \r\n#Author: beethoven97\r\ndef sieve(n):\r\n    prim = [False] * (n + 1)\r\n    ret = []\r\n    for i in range(2, n + 1):\r\n        if not prim[i]:\r\n            ret.append(i)\r\n            for j in range(i, n + 1, i):\r\n                prim[j] = 1\r\n \r\n    return ret\r\n\r\n# find smallest prime factor for all numbers <= n\r\nclass Prime:\r\n    \r\n    def __init__(self,n):\r\n        self.n = n\r\n        self.smallest_prime = [0]*(self.n+5)\r\n\r\n        for i in range(2, self.n + 1):\r\n            if not self.smallest_prime[i]:\r\n                for j in range(i, self.n + 1, i):\r\n                    self.smallest_prime[j] = i\r\n                    \r\n    def factorise(self,num):\r\n        \r\n        ans = []\r\n        while self.smallest_prime[num] != 0:\r\n            k = self.smallest_prime[num]\r\n            ans.append(k)\r\n            while num % k == 0:\r\n                num //= k\r\n                \r\n        return ans\r\n    \r\n\r\n# Function to find the value of\r\n# P * Q^-1 mod 998244353 (G4G)\r\ndef mod_inverse(p, q, mod):\r\n    \r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\n\r\n#PyRival\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        to = f(*args, **kwargs)\r\n        while True:\r\n            if type(to) is GeneratorType:\r\n                stack.append(to)\r\n                to = next(to)\r\n            else:\r\n                stack.pop()\r\n                if not stack:\r\n                    break\r\n                to = stack[-1].send(to)\r\n        return to\r\n\r\n    return wrappedfunc\r\n\r\n#Author: huikang\r\ndef remove_consecutive_duplicates(lst):\r\n    res = []\r\n    for x in lst:\r\n        if res and x == res[-1]:\r\n            continue\r\n        res.append(x)\r\n    return res\r\n\r\n#nmax = 2000000\r\n#fact = [1] * (nmax+1)\r\n#for i in range(2, nmax+1):\r\n#    fact[i] = fact[i-1] * i % MOD\r\n#    \r\n#inv = [1] * (nmax+1)\r\n#inv[-1] = pow(fact[-1], MOD-2, MOD)\r\n#for i in range(nmax-1, 0, -1):\r\n#    inv[i] = inv[i+1] * (i+1) % MOD\r\n \r\n \r\n#def C(n, m):\r\n#    return fact[n] * inv[m] % MOD * inv[n-m] % MOD if 0 <= m <= n else 0\r\n\r\ndef sumtoN(n):\r\n    return ((n)*(n+1)) // 2\r\n\r\ndef powerOf2(n):\r\n    return n > 0 and n & (n-1) == 0\r\n\r\ndef query(a,b):\r\n    print(\"? {} {}\".format(a,b), flush=True)\r\n    response = int(input())\r\n    return response\r\n \r\ndef alert(num):\r\n    print(\"! {}\".format(num), flush=True)\r\n\r\n# d4 = [(0, 1), (-1, 0), (0, -1), (1, 0)]\r\n# d8 = [(0, 1), (-1, 0), (0, -1), (1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\r\n#mod = 1000000007\r\n\r\n'''\r\nKey formulas:\r\n1 XOR n = n-1 when n is odd\r\n1 XOR n = n+1 when n is even\r\na|b = a + b - a & b\r\nXOR and AND is commutative\r\nWhen gcd appears also consider lcm\r\nlowest_ind = graph.index(min(graph, key = len)) #doesnt give the index with minimum length\r\nceiling more feasible to take (val+1)//2 instead of ceil(val/2)\r\n'''\r\n\r\n\r\n\r\ndef read_int(): return(int(input()))\r\ndef read_ints(): return(map(int,input().split()))\r\ndef read_list(): return(list(map(int,input().split())))\r\ndef read_matrix(m,n):\r\n    ans = []\r\n    for _ in range(m):\r\n        ans.append(read_list())\r\n    return ans\r\n\r\n\r\n#for Counter on integers use CounterInt, else use Counter\r\ndef solve(n,arr):\r\n    \r\n    child = [[] for _ in range(n+1)]\r\n    child.append([1])\r\n    for i,x in enumerate(arr):\r\n        child[x].append(i+2)\r\n        \r\n    child.sort(key = len, reverse = True)\r\n    while len(child[-1]) == 0:\r\n        child.pop()\r\n    \r\n    #print(child)\r\n    #each group needs one inject operation\r\n    \r\n    def check(mid):\r\n        rem_injects = mid - len(child)\r\n        #so we have (mid-i) inject operations left\r\n        #can we infect everything\r\n        for i in range(len(child)):\r\n            #inject at time i+1\r\n            start = i\r\n            for x in child[i]:\r\n                start += 1\r\n                if start > mid:\r\n                    #if its past mid time, we use inject, so we dont do anything after mid time\r\n                    rem_injects -= 1\r\n                    \r\n        #is it sufficient\r\n        return rem_injects >= 0\r\n    \r\n    l, r = len(child), 10**6\r\n    while l < r:\r\n        mid = l+r >> 1\r\n        if check(mid):\r\n            r = mid\r\n        else:\r\n            l = mid+1\r\n            \r\n    return l\r\n\r\n            \r\n    \r\n    \r\n        \r\n\r\n    \r\n       \r\n \r\nt = read_int()\r\nfor _ in range(t):\r\n    n = read_int()\r\n    #n,k = read_ints()\r\n    #arr = input()\r\n    arr = read_list()\r\n    print(solve(n,arr))\r\n    #if solve(n,arr):\r\n    #    print(\"YES\")\r\n    #else:\r\n    #    print(\"NO\")\r\n    "
}