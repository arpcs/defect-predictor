{
    "id": 228611194,
    "contestId": 1881,
    "creationTimeSeconds": 1697586117,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1881,
        "index": "D",
        "name": "Divide and Equalize",
        "type": "PROGRAMMING",
        "rating": 1300,
        "tags": [
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1881,
        "members": [
            {
                "handle": "Eslam_Ahmed"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1697121300
    },
    "programmingLanguage": "Java 11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 34,
    "timeConsumedMillis": 202,
    "memoryConsumedBytes": 0,
    "source": "import java.io.*;\r\nimport java.lang.invoke.VarHandle;\r\nimport java.util.*;\r\n\r\n\r\npublic class Main {\r\n\r\n    static Reader input = new Reader();\r\n    static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\r\n    static int grid[][] = {{0, 0, 1, -1, 1, 1, -1, -1}, {1, -1, 0, 0, 1, -1, 1, -1}};\r\n    static int dp2[];\r\n    static int dp[][][];\r\n    static int mod = 998244353;\r\n    static int nu;\r\n    static long res;\r\n    static ArrayList<Integer> conCom;\r\n    static int num[], lowesLink[];\r\n    static boolean inStack[];\r\n    static Stack<Integer> st;\r\n    static LinkedList<ArrayList<Integer>> stronConCom;\r\n    static boolean cycle[], vi[];\r\n    static ArrayList<Integer>[] g;\r\n    static long cost[], result[], sum[], s;\r\n    static ArrayList<Character> ans;\r\n    static int max;\r\n    static int plus;\r\n    static int stop;\r\n    static TreeMap<tem, Integer> d;\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        //        Reader input = new Reader(\"inp.txt\");\r\n        //      BufferedWriter log = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"output.txt\")));\r\n        int pr[] = new int[(int) 1e6 + 5];\r\n        for (int i = 2; i < pr.length; i++) {\r\n            pr[i] = i;\r\n        }\r\n        for (int i = 2; i*i < pr.length; i++) {\r\n            if (pr[i] == i) {\r\n                for (int j = i; j < pr.length; j += i) {\r\n                    if(pr[j]==j){\r\n                        pr[j] = i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        int test = input.nextInt();\r\n        next:\r\n        for (int te = 1; te <= test; te++) {\r\n            int n = input.nextInt();\r\n            int x;\r\n            HashMap<Integer, Integer> fre = new HashMap<>();\r\n            for (int i = 0; i < n; i++) {\r\n                x = input.nextInt();\r\n                while (x != 1) {\r\n                    if (fre.get(pr[x]) == null) {\r\n                        fre.put(pr[x], 0);\r\n                    }\r\n                    fre.put(pr[x], fre.get(pr[x]) + 1);\r\n                    x /= pr[x];\r\n                }\r\n            }\r\n            for (Map.Entry<Integer, Integer> m : fre.entrySet()) {\r\n                int v = m.getValue();\r\n                if (v % n != 0) {\r\n                    log.write(\"NO\\n\");\r\n                    continue next;\r\n                }\r\n            }\r\n            log.write(\"YES\\n\");\r\n        }\r\n        log.flush();\r\n    }\r\n\r\n    static void dfs(int i, int j, ArrayList<pair> g[][], boolean vi[][], char ch[][]) {\r\n        ans.add(ch[i][j]);\r\n        vi[i][j] = true;\r\n        for (pair p : g[i][j]) {\r\n            if (!vi[p.x][p.y]) {\r\n                dfs(p.x, p.y, g, vi, ch);\r\n            }\r\n        }\r\n    }\r\n\r\n    static class tem {\r\n        int val;\r\n        int sum;\r\n        int idx;\r\n\r\n        public tem(int val, int sum, int idx) {\r\n            this.val = val;\r\n            this.sum = sum;\r\n            this.idx = idx;\r\n        }\r\n    }\r\n\r\n    static boolean check(int year, long sec) {\r\n        if ((year % 400 == 0) || (year % 100 != 0 && year % 4 == 0)) {\r\n            long s = 60 * 60 * 24 * 366;\r\n            return s <= sec;\r\n        } else {\r\n            long s = 60 * 60 * 24 * 365;\r\n            return s <= sec;\r\n        }\r\n    }\r\n\r\n    static void solve(int node, int par) {\r\n        result[node] = result[par] - (sum[node] + cost[node]) + (s - sum[node]) + cost[node];\r\n        for (Integer child : g[node]) {\r\n            if (child != par) {\r\n                solve(child, node);\r\n            }\r\n        }\r\n    }\r\n\r\n    static void dfs(int node, int par, long a[]) {\r\n        sum[node] += a[node];\r\n        for (Integer child : g[node]) {\r\n            if (child != par) {\r\n                dfs(child, node, a);\r\n                cost[node] += sum[child] + cost[child];\r\n                sum[node] += sum[child];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public static int[] bfs(int node) {\r\n        Queue<Integer> q = new LinkedList<>();\r\n        q.add(node);\r\n        int distances[] = new int[g.length];\r\n        Arrays.fill(distances, -1);\r\n        distances[node] = 0;\r\n        while (!q.isEmpty()) {\r\n            ArrayList<Integer> nodes = g[q.peek()];\r\n            int cost = distances[q.poll()];\r\n            for (Integer node1 : nodes) {\r\n                if (distances[node1] == -1) {\r\n                    q.add(node1);\r\n                    distances[node1] = cost + 1;\r\n                }\r\n            }\r\n        }\r\n        return distances;\r\n    }\r\n\r\n    static void tarjan(int node, int par) {\r\n        num[node] = lowesLink[node] = nu++;\r\n        st.add(node);\r\n        inStack[node] = true;\r\n        for (Integer ch : g[node]) {\r\n            if (ch == par) continue;\r\n            if (num[ch] == 0) {\r\n                tarjan(ch, node);\r\n                lowesLink[node] = Math.min(lowesLink[node], lowesLink[ch]);\r\n            } else if (inStack[ch]) {\r\n                lowesLink[node] = Math.min(lowesLink[node], num[ch]);\r\n            }\r\n        }\r\n        if (lowesLink[node] == num[node]) {\r\n            int x = -1;\r\n            stronConCom.add(new ArrayList<>());\r\n            while (x != node) {\r\n                x = st.pop();\r\n                inStack[x] = false;\r\n                stronConCom.getLast().add(x);\r\n            }\r\n        }\r\n    }\r\n\r\n    static long add(long a, long b) {\r\n        a += b;\r\n        if (a >= mod) {\r\n            a -= mod;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    static long mul(long a, long b) {\r\n        return (long) ((long) ((a % mod) * (b % mod)) % mod);\r\n    }\r\n\r\n    static long modinv(long x) {\r\n        return fast_pow(x, mod - 2, mod);\r\n    }\r\n\r\n    static long Div(long x, long y) {\r\n        return mul(x, modinv(y));\r\n\r\n    }\r\n\r\n    static long mod(long a, long b) {\r\n        long r = a % b;\r\n        return r < 0 ? r + b : r;\r\n    }\r\n\r\n    static long Sub(long x, long y) {\r\n        long z = x - y;\r\n        if (z < 0) {\r\n            z += mod;\r\n        }\r\n        return z;\r\n    }\r\n\r\n    static long fast_pow(long a, long p, long mod) {\r\n        long res = 1;\r\n        while (p > 0) {\r\n            if (p % 2 == 0) {\r\n                a = ((a % mod) * (a % mod)) % mod;\r\n                p /= 2;\r\n            } else {\r\n                res = ((res % mod) * (a % mod)) % mod;\r\n                p--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n\r\n    public static pair[] dijkstra(int node, ArrayList<pair> a[]) {\r\n        PriorityQueue<tri> q = new PriorityQueue<>(new Comparator<tri>() {\r\n            @Override\r\n            public int compare(tri o1, tri o2) {\r\n                if (o1.y > o2.y) {\r\n                    return 1;\r\n                } else if (o1.y < o2.y) {\r\n                    return -1;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n        });\r\n        q.add(new tri(node, 0, -1));\r\n        pair distance[] = new pair[a.length];\r\n        while (!q.isEmpty()) {\r\n            tri p = q.poll();\r\n            int cost = p.y;\r\n            if (distance[p.x] != null) {\r\n                continue;\r\n            }\r\n            distance[p.x] = new pair(p.pa, cost);\r\n            ArrayList<pair> nodes = a[p.x];\r\n            for (pair node1 : nodes) {\r\n                if (distance[node1.x] == null) {\r\n                    tri pa = new tri(node1.x, cost + node1.y, p.x);\r\n                    q.add(pa);\r\n                }\r\n            }\r\n        }\r\n        return distance;\r\n    }\r\n\r\n    static class tri {\r\n\r\n        int x;\r\n        int y;\r\n        int pa;\r\n\r\n        public tri(int x, int y, int pa) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.pa = pa;\r\n        }\r\n\r\n    }\r\n\r\n    static class SparseTable {\r\n        int[][] st; // Sparse table\r\n        int[] log; // Logarithm lookup table\r\n\r\n        public SparseTable(int[] arr) {\r\n            int n = arr.length;\r\n            int logn = (int) (Math.log(n) / Math.log(2)) + 1;\r\n\r\n            st = new int[n][logn];\r\n            log = new int[n + 1];\r\n\r\n            // Fill the logarithm lookup table\r\n            for (int i = 2; i <= n; i++) {\r\n                log[i] = log[i / 2] + 1;\r\n            }\r\n\r\n            // Fill the first column of the sparse table\r\n            for (int i = 0; i < n; i++) {\r\n                st[i][0] = arr[i];\r\n            }\r\n\r\n            // Compute the sparse table\r\n            for (int j = 1; j < logn; j++) {\r\n                for (int i = 0; i + (1 << j) <= n; i++) {\r\n                    st[i][j] = Math.min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        public int query(int l, int r) {\r\n            int k = log[r - l + 1];\r\n            return Math.min(st[l][k], st[r - (1 << k) + 1][k]);\r\n        }\r\n    }\r\n\r\n    static void dfs(int node, ArrayList<Integer> g[], ArrayList<Integer> con, boolean vi[]) {\r\n        vi[node] = true;\r\n        con.add(node);\r\n        for (Integer x : g[node]) {\r\n            if (!vi[x]) {\r\n                dfs(x, g, con, vi);\r\n            }\r\n        }\r\n    }\r\n\r\n    static long sqrt(long v) {\r\n        long max = (long) 4e9;\r\n        long min = 0;\r\n        long ans = 0;\r\n        while (max >= min) {\r\n            long mid = (max + min) / 2;\r\n            if (mid * mid > v) {\r\n                max = mid - 1;\r\n            } else {\r\n                ans = mid;\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static long cbrt(long v) {\r\n        long max = (long) 3e6;\r\n        long min = 0;\r\n        long ans = 0;\r\n        while (max >= min) {\r\n            long mid = (max + min) / 2;\r\n            if (mid * mid > v) {\r\n                max = mid - 1;\r\n            } else {\r\n                ans = mid;\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static int revI(int n) {\r\n        int re = 0;\r\n        while (n > 0) {\r\n            re = re * 10 + n % 10;\r\n            n /= 10;\r\n        }\r\n        return re;\r\n    }\r\n\r\n    static class Edge {\r\n        int u, v;\r\n        long cost;\r\n\r\n        public Edge(int u, int v, long cost) {\r\n            this.u = u;\r\n            this.v = v;\r\n            this.cost = cost;\r\n        }\r\n\r\n        public String toString() {\r\n            return u + \" \" + v + \" \" + cost;\r\n        }\r\n    }\r\n\r\n    static class SegmentTree {\r\n\r\n        int size;\r\n        int seg[];\r\n        int arr[];\r\n\r\n        public SegmentTree(int size, int a[]) {\r\n            this.size = size;\r\n            seg = new int[size * 4];\r\n            build(1, 1, size, a);\r\n        }\r\n\r\n        private void build(int idx, int s, int e, int a[]) {\r\n            if (s == e) {\r\n                seg[idx] = a[s];\r\n                return;\r\n            }\r\n            build(idx << 1, s, (s + e) / 2, a);\r\n            build(idx << 1 | 1, (s + e) / 2 + 1, e, a);\r\n            seg[idx] = seg[idx << 1] + seg[idx << 1 | 1];\r\n        }\r\n\r\n        void updateIndex(int idx, int s, int e, int ind, int val) {\r\n            if (ind < s || ind > e) {\r\n                return;\r\n            }\r\n            if (s == ind && ind == e) {\r\n                seg[idx] += val;\r\n                return;\r\n            }\r\n            updateIndex(idx << 1, s, (s + e) / 2, ind, val);\r\n            updateIndex(idx << 1 | 1, (s + e) / 2 + 1, e, ind, val);\r\n            seg[idx] = seg[idx << 1] + seg[idx << 1 | 1];\r\n        }\r\n\r\n        int sumInRange(int idx, int s, int e, int l, int r) {\r\n            if ((l > e) || s > r) {\r\n                return 0;\r\n            }\r\n            if (s >= l && e <= r) {\r\n                return seg[idx];\r\n            }\r\n            return sumInRange(idx << 1, s, (s + e) / 2, l, r) + sumInRange(idx << 1 | 1, (s + e) / 2 + 1, e, l, r);\r\n        }\r\n    }\r\n\r\n    static class advancedSegmentTree {\r\n        private ArrayList<Integer> distinctElements;\r\n        private SegmentTree seg;\r\n        private SegmentTree segSum;\r\n        private int size;\r\n\r\n        public advancedSegmentTree(int a[]) {\r\n            distinctElements = new ArrayList<>();\r\n            Arrays.sort(a);\r\n            distinctElements.add(a[0]);\r\n            for (int i = 1; i < a.length; i++) {\r\n                if (a[i] != distinctElements.get(distinctElements.size() - 1)) {\r\n                    distinctElements.add(a[i]);\r\n                }\r\n            }\r\n            Collections.sort(distinctElements);\r\n            size = distinctElements.size() + 5;\r\n            seg = new SegmentTree(size);\r\n            segSum = new SegmentTree(size);\r\n        }\r\n\r\n        public void add(int val) {\r\n            int idx = getIndex(val);\r\n            seg.updateIndex(1, 1, size, idx, 1);\r\n            segSum.updateIndex(1, 1, size, idx, val);\r\n        }\r\n\r\n        public void remove(int val) {\r\n            int idx = getIndex(val);\r\n            seg.updateIndex(1, 1, size, idx, -1);\r\n            segSum.updateIndex(1, 1, size, idx, val * -1);\r\n        }\r\n\r\n        public long getAns(int val) {\r\n            int idx = getIndex(val);\r\n            long count = countNumbersGreaterThan(val);\r\n            long sum = segSum.sumInRange(1, 1, size, 1, size);\r\n            sum -= segSum.sumInRange(1, 1, size, idx + 1, size);\r\n            sum += count * val;\r\n            return sum;\r\n        }\r\n\r\n        public long getAns2(int val) {\r\n            int idx = getIndex(val);\r\n            long sum = segSum.sumInRange(1, 1, size, 1, size);\r\n            sum -= segSum.sumInRange(1, 1, size, 1, idx - 1);\r\n            return sum;\r\n        }\r\n\r\n        private int getIndex(int val) {\r\n            int max = distinctElements.size() - 1;\r\n            int min = 0;\r\n            int ans = -1;\r\n            while (max >= min) {\r\n                int mid = (max + min) / 2;\r\n                if (distinctElements.get(mid) == val) {\r\n                    return mid + 2;\r\n                } else if (distinctElements.get(mid) > val) {\r\n                    max = mid - 1;\r\n                } else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n            return ans;\r\n        }\r\n\r\n        public long countNumbersGreaterThan(int val) {\r\n            int idx = getIndex(val);\r\n            return seg.sumInRange(1, 1, size, idx + 1, size);\r\n        }\r\n\r\n        public long countNumbersLessThan(int val) {\r\n            int idx = getIndex(val);\r\n            return seg.sumInRange(1, 1, size, 1, idx - 1);\r\n        }\r\n\r\n        private static class SegmentTree {\r\n\r\n            int size;\r\n            long seg[];\r\n            long arr[];\r\n\r\n            public SegmentTree(int size) {\r\n                this.size = size;\r\n                seg = new long[size * 4];\r\n            }\r\n\r\n            void updateIndex(int idx, int s, int e, int ind, long val) {\r\n                if (ind < s || ind > e) {\r\n                    return;\r\n                }\r\n                if (s == ind && ind == e) {\r\n                    seg[idx] += val;\r\n                    return;\r\n                }\r\n                updateIndex(idx << 1, s, (s + e) / 2, ind, val);\r\n                updateIndex(idx << 1 | 1, (s + e) / 2 + 1, e, ind, val);\r\n                seg[idx] = seg[idx << 1] + seg[idx << 1 | 1];\r\n            }\r\n\r\n            long sumInRange(int idx, int s, int e, int l, int r) {\r\n                if ((l > e) || s > r) {\r\n                    return 0;\r\n                }\r\n                if (s >= l && e <= r) {\r\n                    return seg[idx];\r\n                }\r\n                return sumInRange(idx << 1, s, (s + e) / 2, l, r) + sumInRange(idx << 1 | 1, (s + e) / 2 + 1, e, l, r);\r\n            }\r\n        }\r\n    }\r\n\r\n    static class Tree {\r\n        private ArrayList<Integer> distinctElements;\r\n        private SegmentTree seg;\r\n        private int size;\r\n\r\n        public Tree(int a[]) {\r\n            distinctElements = new ArrayList<>();\r\n            Arrays.sort(a);\r\n            distinctElements.add(a[0]);\r\n            // 2 7 1 9 10 7 20\r\n            // 1 2 7 9 10 20\r\n            for (int i = 1; i < a.length; i++) {\r\n                if (a[i] != distinctElements.get(distinctElements.size() - 1)) {\r\n                    distinctElements.add(a[i]);\r\n                }\r\n            }\r\n            Collections.sort(distinctElements);\r\n            size = distinctElements.size() + 5;\r\n            seg = new SegmentTree(size);\r\n        }\r\n\r\n        public void add(int val) {\r\n            int idx = getIndex(val);\r\n            seg.updateIndex(1, 1, size, idx, 1);\r\n        }\r\n\r\n        public void remove(int val) {\r\n            int idx = getIndex(val);\r\n            seg.updateIndex(1, 1, size, idx, -1);\r\n        }\r\n\r\n        private int getIndex(int val) {\r\n            int max = distinctElements.size() - 1;\r\n            int min = 0;\r\n            int ans = -1;\r\n            while (max >= min) {\r\n                int mid = (max + min) / 2;\r\n                if (distinctElements.get(mid) == val) {\r\n                    return mid + 2;\r\n                } else if (distinctElements.get(mid) > val) {\r\n                    max = mid - 1;\r\n                } else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n            return ans;\r\n        }\r\n\r\n        public int countNumbersGreaterThan(int val) {\r\n            int idx = getIndex(val);\r\n            return seg.sumInRange(1, 1, size, idx + 1, size);\r\n        }\r\n\r\n        public int countNumbersLessThan(int val) {\r\n            int idx = getIndex(val);\r\n            return seg.sumInRange(1, 1, size, 1, idx - 1);\r\n        }\r\n\r\n        private static class SegmentTree {\r\n\r\n            int size;\r\n            int seg[];\r\n            int arr[];\r\n\r\n            public SegmentTree(int size) {\r\n                this.size = size;\r\n                seg = new int[size * 4];\r\n            }\r\n\r\n            void updateIndex(int idx, int s, int e, int ind, int val) {\r\n                if (ind < s || ind > e) {\r\n                    return;\r\n                }\r\n                if (s == ind && ind == e) {\r\n                    seg[idx] += val;\r\n                    return;\r\n                }\r\n                updateIndex(idx << 1, s, (s + e) / 2, ind, val);\r\n                updateIndex(idx << 1 | 1, (s + e) / 2 + 1, e, ind, val);\r\n                seg[idx] = seg[idx << 1] + seg[idx << 1 | 1];\r\n            }\r\n\r\n            int sumInRange(int idx, int s, int e, int l, int r) {\r\n                if ((l > e) || s > r) {\r\n                    return 0;\r\n                }\r\n                if (s >= l && e <= r) {\r\n                    return seg[idx];\r\n                }\r\n                return sumInRange(idx << 1, s, (s + e) / 2, l, r) + sumInRange(idx << 1 | 1, (s + e) / 2 + 1, e, l, r);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public static void prefixSum(ArrayList<Integer> a) {\r\n        for (int i = 1; i < a.size(); i++) {\r\n            a.set(i, a.get(i) + a.get(i - 1));\r\n        }\r\n    }\r\n\r\n    public static void suffixSum(ArrayList<Integer> a) {\r\n        for (int i = a.size() - 2; i > 0; i--) {\r\n            a.set(i, a.get(i) + a.get(i + 1));\r\n        }\r\n    }\r\n\r\n    public static void prefixSum(long[] a) {\r\n        for (int i = 1; i < a.length; i++) {\r\n            a[i] = a[i] + a[i - 1];\r\n        }\r\n    }\r\n\r\n    public static void suffixSum(long[] a) {\r\n        for (int i = a.length - 2; i > -1; i--) {\r\n            a[i] = a[i] + a[i + 1];\r\n        }\r\n    }\r\n\r\n    static class HashedString {\r\n        // Change M and B if you want\r\n        public static final long M = (long) 1e9 + 9;\r\n        public static final long B = 9973;\r\n\r\n        // pow[i] contains B^i % M\r\n        private static ArrayList<Long> pow = new ArrayList<>();\r\n\r\n        // pHash[i] is the hash of the first i characters of the given string\r\n        private long[] pHash;\r\n\r\n        public HashedString(String s) {\r\n            if (pow.isEmpty()) {\r\n                pow.add(1L);\r\n            }\r\n            while (pow.size() < s.length()) {\r\n                pow.add((pow.get(pow.size() - 1) * B) % M);\r\n            }\r\n            pHash = new long[s.length() + 1];\r\n            pHash[0] = 0;\r\n            for (int i = 0; i < s.length(); i++) {\r\n                pHash[i + 1] = ((pHash[i] * B) % M + s.charAt(i)) % M;\r\n            }\r\n        }\r\n\r\n        public long getHash(int start, int end) {\r\n            long rawVal = pHash[end + 1] - (pHash[start] * pow.get(end - start + 1));\r\n            return (rawVal % M + M) % M;\r\n        }\r\n    }\r\n\r\n    static class SegmentTreeMax {\r\n\r\n        int size;\r\n        long seg[];\r\n        long lazy[];\r\n        long arr[];\r\n\r\n        public SegmentTreeMax(int size, long a[]) {\r\n            this.size = size;\r\n            arr = a;\r\n            seg = new long[size * 4];\r\n            lazy = new long[size * 4];\r\n            build(1, 1, size, a);\r\n        }\r\n\r\n        private void build(int idx, int s, int e, long a[]) {\r\n            if (s == e) {\r\n                seg[idx] = a[s];\r\n                return;\r\n            }\r\n            build(idx * 2, s, (s + e) / 2, a);\r\n            build(idx * 2 + 1, (s + e) / 2 + 1, e, a);\r\n            seg[idx] = seg[idx * 2] + seg[idx * 2 + 1];\r\n        }\r\n\r\n        void process(int idx, int s, int e) {\r\n            seg[idx] += (e - s + 1) * lazy[idx];\r\n            if (s < e) {\r\n                lazy[idx * 2] += lazy[idx];\r\n                lazy[idx * 2 + 1] += lazy[idx];\r\n            }\r\n            lazy[idx] = 0;\r\n        }\r\n\r\n        void updateIndex(int idx, int s, int e, int ind, long val) {\r\n            if (ind < s || ind > e) {\r\n                return;\r\n            }\r\n            if (s == ind && ind == e) {\r\n                seg[idx] += val;\r\n                return;\r\n            }\r\n            updateIndex(idx * 2, s, (s + e) / 2, ind, val);\r\n            updateIndex(idx * 2 + 1, (s + e) / 2 + 1, e, ind, val);\r\n            seg[idx] = seg[idx * 2] + seg[idx * 2 + 1];\r\n        }\r\n\r\n        void updateRange(int idx, int s, int e, int l, int r, long val) {\r\n            process(idx, s, e);\r\n            if ((l > e) || s > r) {\r\n                return;\r\n            }\r\n            if (s >= l && e <= r) {\r\n                lazy[idx] += val;\r\n                process(idx, s, e);\r\n                return;\r\n            }\r\n            updateRange(idx * 2, s, (s + e) / 2, l, r, val);\r\n            updateRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r, val);\r\n            seg[idx] = seg[idx * 2] + seg[idx * 2 + 1];\r\n        }\r\n\r\n        long sumInRange(int idx, int s, int e, int l, int r) {\r\n            process(idx, s, e);\r\n            if ((l > e) || s > r) {\r\n                return 0;\r\n            }\r\n            if (s >= l && e <= r) {\r\n                return seg[idx];\r\n            }\r\n            return sumInRange(idx * 2, s, (s + e) / 2, l, r) + sumInRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r);\r\n        }\r\n    }\r\n\r\n    static class SegmentTreeMin {\r\n\r\n        int size;\r\n        int seg[];\r\n        int lazy[];\r\n\r\n        public SegmentTreeMin(int size, int a[]) {\r\n            this.size = size;\r\n            seg = new int[size * 4];\r\n            lazy = new int[size * 4];\r\n            build(1, 1, size, a);\r\n        }\r\n\r\n        private void build(int idx, int s, int e, int a[]) {\r\n            if (s == e) {\r\n                seg[idx] = a[s];\r\n                return;\r\n            }\r\n            build(idx * 2, s, (s + e) / 2, a);\r\n            build(idx * 2 + 1, (s + e) / 2 + 1, e, a);\r\n            seg[idx] = Math.min(seg[idx * 2], seg[idx * 2 + 1]);\r\n        }\r\n\r\n        void process(int idx, int s, int e) {\r\n            seg[idx] += lazy[idx];\r\n            if (s < e) {\r\n                lazy[idx * 2] += lazy[idx];\r\n                lazy[idx * 2 + 1] += lazy[idx];\r\n            }\r\n            lazy[idx] = 0;\r\n        }\r\n\r\n        void updateIndex(int idx, int s, int e, int ind, int val) {\r\n            if (ind < s || ind > e) {\r\n                return;\r\n            }\r\n            if (s == ind && ind == e) {\r\n                seg[idx] += val;\r\n                return;\r\n            }\r\n            updateIndex(idx * 2, s, (s + e) / 2, ind, val);\r\n            updateIndex(idx * 2 + 1, (s + e) / 2 + 1, e, ind, val);\r\n            seg[idx] = Math.min(seg[idx * 2], seg[idx * 2 + 1]);\r\n        }\r\n\r\n        void updateRange(int idx, int s, int e, int l, int r, long val) {\r\n            process(idx, s, e);\r\n            if ((l > e) || s > r) {\r\n                return;\r\n            }\r\n            if (s >= l && e <= r) {\r\n                lazy[idx] += val;\r\n                process(idx, s, e);\r\n                return;\r\n            }\r\n            updateRange(idx * 2, s, (s + e) / 2, l, r, val);\r\n            updateRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r, val);\r\n            seg[idx] = Math.min(seg[idx * 2], seg[idx * 2 + 1]);\r\n        }\r\n\r\n        int minInRange(int idx, int s, int e, int l, int r) {\r\n            process(idx, s, e);\r\n            if ((l > e) || s > r) {\r\n                return Integer.MAX_VALUE;\r\n            }\r\n            if (s >= l && e <= r) {\r\n                return seg[idx];\r\n            }\r\n            return Math.min(minInRange(idx * 2, s, (s + e) / 2, l, r), minInRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r));\r\n        }\r\n    }\r\n\r\n    static boolean isPalindrome(String w) {\r\n        for (int i = 0; i < w.length() / 2; i++) {\r\n            if (w.charAt(i) != w.charAt(w.length() - i - 1)) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isValid(int i, int j, int n, int m) {\r\n        return (i > -1 && i < n) && (j > -1 && j < m);\r\n\r\n    }\r\n\r\n    static void dfs(int x, int y, char w[][], boolean vi[][]) {\r\n        vi[x][y] = true;\r\n        for (int i = 0; i < 4; i++) {\r\n            int xx = x + grid[0][i];\r\n            int yy = y + grid[1][i];\r\n            if (isValid(xx, yy, w.length, w[0].length) && !vi[xx][yy] && w[xx][yy] != '#') {\r\n                dfs(xx, yy, w, vi);\r\n            }\r\n        }\r\n    }\r\n\r\n    static int cmpDouble(double a, double b) {\r\n        if (Math.abs(a - b) <= 1e-7) {\r\n            return 0;\r\n        }\r\n        return a < b ? -1 : 1;\r\n    }\r\n\r\n\r\n    public static long GCD(long x, long y) {\r\n        while (y != 0) {\r\n            long c = x % y;\r\n            x = y;\r\n            y = c;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    static boolean isPrime(long num) {\r\n        if (num <= 1) {\r\n            return false;\r\n        }\r\n        if (num == 2) {\r\n            return true;\r\n        }\r\n        if (num % 2 == 0) {\r\n            return false;\r\n        }\r\n        if (num == 3) {\r\n            return true;\r\n        }\r\n        for (long i = 3; i * i <= num; i += 2) {\r\n            if (num % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    public static int[] swap(int data[], int left, int right) {\r\n\r\n        // Swap the data\r\n        int temp = data[left];\r\n        data[left] = data[right];\r\n        data[right] = temp;\r\n\r\n        // Return the updated array\r\n        return data;\r\n    }\r\n\r\n    public static int[] reverse(int data[], int left, int right) {\r\n\r\n        // Reverse the sub-array\r\n        while (left < right) {\r\n            int temp = data[left];\r\n            data[left++] = data[right];\r\n            data[right--] = temp;\r\n        }\r\n\r\n        // Return the updated array\r\n        return data;\r\n    }\r\n\r\n\r\n    public static boolean findNextPermutation(int data[]) {\r\n\r\n        if (data.length <= 1) {\r\n            return false;\r\n        }\r\n\r\n        int last = data.length - 2;\r\n\r\n        // find the longest non-increasing suffix\r\n        // and find the pivot\r\n        while (last >= 0) {\r\n            if (data[last] < data[last + 1]) {\r\n                break;\r\n            }\r\n            last--;\r\n        }\r\n\r\n        // If there is no increasing pair\r\n        // there is no higher order permutation\r\n        if (last < 0) {\r\n            return false;\r\n        }\r\n\r\n        int nextGreater = data.length - 1;\r\n\r\n        // Find the rightmost successor to the pivot\r\n        for (int i = data.length - 1; i > last; i--) {\r\n            if (data[i] > data[last]) {\r\n                nextGreater = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Swap the successor and the pivot\r\n        data = swap(data, nextGreater, last);\r\n\r\n        // Reverse the suffix\r\n        data = reverse(data, last + 1, data.length - 1);\r\n\r\n        // Return true as the next_permutation is done\r\n        return true;\r\n    }\r\n\r\n    static double calcArea(pair a, pair b, pair c) {\r\n        double ret = Math.abs((a.x * (double) (b.y - c.y)) + (b.x * (double) (c.y - a.y)) + (c.x * (double) (a.y - b.y))) / 2.0;\r\n        return ret;\r\n    }\r\n\r\n\r\n    static class MultiSet<T> {\r\n\r\n        HashMap<T, Integer> fre;\r\n        TreeSet<T> set;\r\n        int size;\r\n\r\n        public MultiSet() {\r\n            set = new TreeSet<>();\r\n            fre = new HashMap<>();\r\n            size = 0;\r\n        }\r\n\r\n        public void add(T elem) {\r\n            if (fre.get(elem) == null || fre.get(elem) == 0) {\r\n                fre.put(elem, 0);\r\n                set.add(elem);\r\n            }\r\n            fre.put(elem, fre.get(elem) + 1);\r\n            size++;\r\n        }\r\n\r\n        public void remove(T elem) {\r\n            fre.put(elem, fre.get(elem) - 1);\r\n            if (fre.get(elem) == 0) {\r\n                set.remove(elem);\r\n            }\r\n            size--;\r\n        }\r\n\r\n\r\n        public boolean contains(T elem) {\r\n            return set.contains(elem);\r\n        }\r\n    }\r\n\r\n    static class Reader extends PrintWriter {\r\n\r\n        private BufferedReader r;\r\n        private StringTokenizer st;\r\n        // standard input\r\n\r\n        public Reader() {\r\n            this(System.in, System.out);\r\n        }\r\n\r\n        public Reader(InputStream i, OutputStream o) {\r\n            super(o);\r\n            r = new BufferedReader(new InputStreamReader(i));\r\n        }\r\n        // USACO-style file input\r\n\r\n        public Reader(String problemName) throws IOException {\r\n            super(problemName + \".out\");\r\n            r = new BufferedReader(new FileReader(problemName));\r\n        }\r\n\r\n        // returns null if no more input\r\n        String nextLine() {\r\n            String str = \"\";\r\n            try {\r\n                str = r.readLine();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n\r\n        public String next() {\r\n            try {\r\n                while (st == null || !st.hasMoreTokens()) {\r\n                    st = new StringTokenizer(r.readLine());\r\n                }\r\n                return st.nextToken();\r\n            } catch (Exception e) {\r\n            }\r\n            return null;\r\n        }\r\n\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        public long nextLong() {\r\n\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n    static class pair {\r\n        public int x, y, d, c;\r\n\r\n        public pair(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.d = d;\r\n        }\r\n\r\n        public String toString() {\r\n            return x + \" \" + y;\r\n        }\r\n    }\r\n\r\n    static class DSU {\r\n        int[] parent, groupSize;\r\n        int fre[];\r\n        int numberOfNodes, numberOfGroups, maxGroup;\r\n\r\n        public DSU(int numberOfNodes) {\r\n            fre = new int[numberOfNodes + 1];\r\n            this.numberOfNodes = numberOfNodes;\r\n            parent = new int[numberOfNodes + 1];\r\n            groupSize = new int[numberOfNodes + 1];\r\n            numberOfGroups = numberOfNodes;\r\n            maxGroup = 1;\r\n            for (int i = 1; i <= numberOfNodes; i++) {\r\n                parent[i] = i;\r\n                groupSize[i] = 1;\r\n                fre[groupSize[i]]++;\r\n            }\r\n        }\r\n\r\n        public int getLeader(int x) {\r\n            return parent[x] = (parent[x] == x ? x : getLeader(parent[x]));\r\n        }\r\n\r\n        public boolean sameGroup(int x, int y) {\r\n            return getLeader(x) == getLeader(y);\r\n        }\r\n\r\n        public void mergeGroups(int x, int y) {\r\n            int leader1 = getLeader(x);\r\n            int leader2 = getLeader(y);\r\n            if (leader1 != leader2) {\r\n                numberOfGroups--;\r\n                if (groupSize[leader1] < groupSize[leader2]) {\r\n                    int temp = leader1;\r\n                    leader1 = leader2;\r\n                    leader2 = temp;\r\n                }\r\n                fre[groupSize[leader1]]--;\r\n                fre[groupSize[leader2]]--;\r\n                parent[leader2] = leader1;\r\n                groupSize[leader1] += groupSize[leader2];\r\n                fre[groupSize[leader1]]++;\r\n                maxGroup = Math.max(maxGroup, groupSize[leader1]);\r\n            }\r\n        }\r\n\r\n        public int getSize(int x) {\r\n            return groupSize[getLeader(x)];\r\n        }\r\n    }\r\n\r\n\r\n}"
}