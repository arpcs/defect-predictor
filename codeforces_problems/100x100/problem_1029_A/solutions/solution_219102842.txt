{
    "id": 219102842,
    "contestId": 1029,
    "creationTimeSeconds": 1692185834,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1029,
        "index": "A",
        "name": "Many Equal Substrings",
        "type": "PROGRAMMING",
        "rating": 1300,
        "tags": [
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 1029,
        "members": [
            {
                "handle": "badql"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1535122200
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n// Magic Time :)    (Don't be a fool, read this - https://codeforces.com/blog/entry/96344)\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n\r\n/* Self Notes\r\nI copied a lot of it from Benq :)\r\nPriority queue is by default reverse sorted\r\nCustom comparator can be created using class and bool operator()(values)\r\n\r\n\r\n*/\r\n\r\n// =====================================================\r\n// Shorthands for Templates classes to easily create templates\r\n#define tcT template <class T\r\n#define tcTU tcT, class U\r\n// =====================================================\r\n\r\n// =====================================================\r\n// won't die anymore typing long things to get what i always need\r\ntcT > using V = vector<T>;\r\ntcT > using mp = map<T, long long>;\r\ntcT > using ump = unordered_map<T, long long>;\r\n// =====================================================\r\n\r\n// =====================================================\r\nusing str = string; // yay python!\r\nusing ull = unsigned long long;\r\nusing intl = int64_t;\r\nusing ll = long long;\r\nusing lld = long double;\r\n\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\n\r\nusing vpi = vector<pii>;\r\nusing vpll = vector<pll>;\r\nusing vi = vector<int>;\r\nusing vvi = vector<vi>;\r\nusing vll = vector<ll>;\r\nusing vvll = vector<vll>;\r\nusing vull = vector<ull>;\r\nusing vvull = vector<vull>;\r\nusing vs = vector<string>;\r\nusing vc = vector<char>;\r\nusing vb = vector<bool>;\r\n// =====================================================\r\n\r\n// =====================================================\r\n// am i dumb?\r\n#define rsz resize\r\n#define ins insert\r\n#define endl \"\\n\"\r\n#define sp \" \"\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ppf pop_front\r\n#define eb emplace_back\r\n#define ppb pop_back\r\n#define pf push_front\r\n#define F first\r\n#define S second\r\n#define fi first\r\n#define se second\r\n#define ft front()\r\n#define bk back()\r\n\r\n#define sz(x) (int)(x).size()\r\n#define sum(x) accumulate(all(x), 0LL)\r\n#define ssort(x) sort(all(x))\r\n#define rsort(x) sort(rall(x))\r\n#define vmax(x) *max_element(all(x))\r\n#define vmin(x) *min_element(all(x))\r\n\r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n// =====================================================\r\n\r\n// =====================================================\r\n// hihi i guess not so\r\n#define lb lower_bound\r\n#define ub upper_bound\r\ntcT > int lwb(V<T> &a, const T &b)\r\n{\r\n    return int(lb(all(a), b) - begin(a));\r\n}\r\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - begin(a)); }\r\n\r\n// =====================================================\r\n\r\n// =====================================================\r\n// bits lovely bits\r\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\r\n#define setBits(x) __builtin_popcountll((ll)x)\r\n#define leadingZero(x) __builtin_clzll((ll)x)\r\n#define fstbit(x) (64- leadingZero(x)) /*first set bit position*/\r\n#define lstbit(x) ffs(x) /*last set bit position*/\r\n\r\n// count total bits in no eg 9 is 1001 so 4 bits || can also be calculated using log2(x)+1\r\n#define bits(x) (64 - leadingZero(x))\r\nll cdiv(ll a, ll b)\r\n{\r\n    return a / b + ((a ^ b) > 0 && a % b);\r\n} // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down\r\ntcT > bool ckmin(T &a, const T &b)\r\n{\r\n    return b < a ? a = b, 1 : 0;\r\n} // set a = min(a,b)\r\ntcT > bool ckmax(T &a, const T &b)\r\n{\r\n    return a < b ? a = b, 1 : 0;\r\n} // set a = max(a,b)\r\n\r\nll binpow(ll a, ll b, ll mod = LLONG_MAX)\r\n{\r\n    a %= mod;\r\n    ll res = 1;\r\n    while (b > 0)\r\n    {\r\n        if (b & 1)\r\n            res = res * a % mod;\r\n        a = a * a % mod;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n// =====================================================\r\n\r\n// =====================================================\r\n// loops\r\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\r\n\r\n#define GET_MACRO(_1,_2,_3,NAME,...) NAME\r\n#define rep2(i, n) for (int i = 0; i < n; ++i)\r\n#define rep3(i, start, end) for (int i = start; i < end; ++i)\r\n\r\n#define repr(...) GET_MACRO(__VA_ARGS__, repr3, repr2)(__VA_ARGS__)\r\n\r\n#define GET_MACRO(_1,_2,_3,NAME,...) NAME\r\n#define repr2(i, n) for (int i = n-1; i >= 0; --i)\r\n#define repr3(i, start, end) for  (int i = start; i >= end; --i)\r\n\r\n#define each(a, x) for (auto &a : x)\r\n#define foreach(a, x) each(a,x)\r\n// =====================================================\r\n\r\n// =====================================================\r\n// Super useful things\r\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};           // for every grid problem!!\r\nstruct myGridDirections{\r\n    int x, y;\r\n};\r\nconst unordered_map<string, myGridDirections> dir = {\r\n    {\"l\", {0, -1}},\r\n    {\"r\", {0, 1}},\r\n    {\"u\", {-1, 0}},\r\n    {\"d\", {1, 0}},\r\n    {\"lu\", {-1, -1}},\r\n    {\"ld\", {1, -1}},\r\n    {\"ru\", {-1, 1}},\r\n    {\"rd\", {1, 1}}\r\n}; // solve those grid direction problems like butter baby\r\ntcT > using pqg = priority_queue<T, vector<T>, greater<T>>; // reverse priority queue\r\n\r\n#define fix(prec)                            \\\r\n    {                                        \\\r\n        cout << setprecision(prec) << fixed; \\\r\n    } // set decimal precision\r\n\r\ntcTU > T fstTrue(T lo, T hi, U f)\r\n{\r\n    ++hi;\r\n    assert(lo <= hi); // assuming f is increasing\r\n    while (lo < hi)\r\n    { // find first index such that f is true\r\n        T mid = lo + (hi - lo) / 2;\r\n        f(mid) ? hi = mid : lo = mid + 1;\r\n    }\r\n    return lo;\r\n    // Example: fstTrue<int, bool>(0, x.size() - 1, [&arr](int i) { return arr[i] == 10; });\r\n}\r\ntcTU > T lstTrue(T lo, T hi, U f)\r\n{\r\n    --lo;\r\n    assert(lo <= hi); // assuming f is decreasing\r\n    while (lo < hi)\r\n    { // find first index such that f is true\r\n        T mid = lo + (hi - lo + 1) / 2;\r\n        f(mid) ? lo = mid : hi = mid - 1;\r\n    }\r\n    return lo;\r\n    // Example: lstTrue<int, bool>(0, x.size() - 1, [&arr](int i) { return arr[i] == 10; });\r\n}\r\ntcT > void remDup(vector<T> &v)\r\n{ // sort and remove duplicates\r\n    sort(all(v));\r\n    v.erase(unique(all(v)), end(v));\r\n}\r\ntcTU > void erase(T &t, const U &u)\r\n{ // don't erase\r\n    auto it = t.find(u);\r\n    assert(it != end(t));\r\n    t.erase(it);\r\n} // element that doesn't exist from (multi)set\r\n\r\n// =====================================================\r\n\r\n// =====================================================\r\n#define read(x) for(auto &i:x)cin >> i\r\n#define write(x) { for(auto &i:x)cout << i << \" \"; cout << endl; }\r\n#define print(x) cout << x << endl\r\n\r\n#define tcTUU tcT, class... U\r\n\r\ninline namespace Helpers\r\n{\r\n    //////////// is_iterable\r\n    // https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\r\n    // this gets used only when we can call begin() and end() on that type\r\n    tcT, class = void > struct is_iterable : false_type\r\n    {\r\n    };\r\n    tcT > struct is_iterable<T, void_t<decltype(begin(declval<T>())),\r\n                                       decltype(end(declval<T>()))>> : true_type\r\n    {\r\n    };\r\n    tcT > constexpr bool is_iterable_v = is_iterable<T>::value;\r\n\r\n    //////////// is_readable\r\n    tcT, class = void > struct is_readable : false_type\r\n    {\r\n    };\r\n    tcT > struct is_readable<T,\r\n                             typename std::enable_if_t<\r\n                                 is_same_v<decltype(cin >> declval<T &>()), istream &>>> : true_type\r\n    {\r\n    };\r\n    tcT > constexpr bool is_readable_v = is_readable<T>::value;\r\n\r\n    //////////// is_printable\r\n    // // https://nafe.es/posts/2020-02-29-is-printable/\r\n    tcT, class = void > struct is_printable : false_type\r\n    {\r\n    };\r\n    tcT > struct is_printable<T,\r\n                              typename std::enable_if_t<\r\n                                  is_same_v<decltype(cout << declval<T>()), ostream &>>> : true_type\r\n    {\r\n    };\r\n    tcT > constexpr bool is_printable_v = is_printable<T>::value;\r\n}\r\n\r\ninline namespace Input\r\n{\r\n    tcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\r\n    tcTUU > void re(T &t, U &...u);\r\n    tcTU > void re(pair<T, U> &p); // pairs\r\n\r\n    // re: read\r\n    tcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) { cin >> x; } // default\r\n    tcT > void re(complex<T> &c)\r\n    {\r\n        T a, b;\r\n        re(a, b);\r\n        c = {a, b};\r\n    }                                                                // complex\r\n    tcT > typename enable_if<needs_input_v<T>, void>::type re(T &i); // ex. vectors, arrays\r\n    tcTU > void re(pair<T, U> &p) { re(p.F, p.S); }\r\n    tcT > typename enable_if<needs_input_v<T>, void>::type re(T &i)\r\n    {\r\n        each(x, i) re(x);\r\n    }\r\n    tcTUU > void re(T &t, U &...u)\r\n    {\r\n        re(t);\r\n        re(u...);\r\n    } // read multiple\r\n\r\n    // rv: resize and read vectors\r\n    void rv(size_t) {}\r\n    tcTUU > void rv(size_t N, V<T> &t, U &...u);\r\n    template <class... U>\r\n    void rv(size_t, size_t N2, U &...u);\r\n    tcTUU > void rv(size_t N, V<T> &t, U &...u)\r\n    {\r\n        t.rsz(N);\r\n        re(t);\r\n        rv(N, u...);\r\n    }\r\n    template <class... U>\r\n    void rv(size_t, size_t N2, U &...u)\r\n    {\r\n        rv(N2, u...);\r\n    }\r\n\r\n    // dumb shortcuts to read in ints\r\n    void decrement() {} // subtract one from each\r\n    tcTUU > void decrement(T &t, U &...u)\r\n    {\r\n        --t;\r\n        decrement(u...);\r\n    }\r\n#define ints(...)    \\\r\n    int __VA_ARGS__; \\\r\n    re(__VA_ARGS__);\r\n#define int1(...)      \\\r\n    ints(__VA_ARGS__); \\\r\n    decrement(__VA_ARGS__);\r\n}\r\n\r\ninline namespace ToString\r\n{\r\n    tcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\r\n\r\n    // ts: string representation to print\r\n    tcT > typename enable_if<is_printable_v<T>, str>::type ts(T v)\r\n    {\r\n        stringstream ss;\r\n        ss << fixed << setprecision(15) << v;\r\n        return ss.str();\r\n    } // default\r\n    tcT > str bit_vec(T t)\r\n    { // bit vector to string\r\n        str res = \"{\";\r\n        rep(i, sz(t)) res += ts(t[i]);\r\n        res += \"}\";\r\n        return res;\r\n    }\r\n    str ts(V<bool> v) { return bit_vec(v); }\r\n    template <size_t SZ>\r\n    str ts(bitset<SZ> b) { return bit_vec(b); }                     // bit vector\r\n    tcTU > str ts(pair<T, U> p);                                    // pairs\r\n    tcT > typename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\r\n    tcTU > str ts(pair<T, U> p) { return \"(\" + ts(p.F) + \", \" + ts(p.S) + \")\"; }\r\n    tcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep)\r\n    {\r\n        // convert container to string w/ separator sep\r\n        bool fst = 1;\r\n        str res = \"\";\r\n        for (const auto &x : v)\r\n        {\r\n            if (!fst)\r\n                res += sep;\r\n            fst = 0;\r\n            res += ts(x);\r\n        }\r\n        return res;\r\n    }\r\n    tcT > typename enable_if<needs_output_v<T>, str>::type ts(T v)\r\n    {\r\n        return \"{\" + ts_sep(v, \", \") + \"}\";\r\n    }\r\n\r\n    // for nested DS\r\n    template <int, class T>\r\n    typename enable_if<!needs_output_v<T>, vs>::type\r\n    ts_lev(const T &v) { return {ts(v)}; }\r\n    template <int lev, class T>\r\n    typename enable_if<needs_output_v<T>, vs>::type\r\n    ts_lev(const T &v)\r\n    {\r\n        if (lev == 0 || !sz(v))\r\n            return {ts(v)};\r\n        vs res;\r\n        for (const auto &t : v)\r\n        {\r\n            if (sz(res))\r\n                res.bk += \",\";\r\n            vs tmp = ts_lev<lev - 1>(t);\r\n            res.ins(end(res), all(tmp));\r\n        }\r\n        rep(i, sz(res))\r\n        {\r\n            str bef = \" \";\r\n            if (i == 0)\r\n                bef = \"{\";\r\n            res[i] = bef + res[i];\r\n        }\r\n        res.bk += \"}\";\r\n        return res;\r\n    }\r\n}\r\n\r\ninline namespace Output\r\n{\r\n    template <class T>\r\n    void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\r\n    template <class T, class... U>\r\n    void pr_sep(ostream &os, str sep, const T &t, const U &...u)\r\n    {\r\n        pr_sep(os, sep, t);\r\n        os << sep;\r\n        pr_sep(os, sep, u...);\r\n    }\r\n    // print w/ no spaces\r\n    template <class... T>\r\n    void pr(const T &...t) { pr_sep(cout, \"\", t...); }\r\n    // print w/ spaces, end with newline\r\n    void ps() { cout << \"\\n\"; }\r\n    template <class... T>\r\n    void ps(const T &...t)\r\n    {\r\n        pr_sep(cout, \" \", t...);\r\n        ps();\r\n    }\r\n    // print w/ spaces, end with newline, with custom separator\r\n    template <class... T>\r\n    void ps_sep(ostream &os, str sep, const T &...t)\r\n    {\r\n        pr_sep(os, sep, t...);\r\n        ps();\r\n    }\r\n    // debug to cerr\r\n    template <class... T>\r\n    void dbg_out(const T &...t)\r\n    {\r\n        pr_sep(cerr, \" | \", t...);\r\n        cerr << endl;\r\n    }\r\n    void loc_info(int line, str names)\r\n    {\r\n        cerr << \"Line(\" << line << \") -> [\" << names << \"]: \";\r\n    }\r\n    template <int lev, class T>\r\n    void dbgl_out(const T &t)\r\n    {\r\n        cerr << \"\\n\\n\"\r\n             << ts_sep(ts_lev<lev>(t), \"\\n\") << \"\\n\"\r\n             << endl;\r\n    }\r\n#ifndef ONLINE_JUDGE\r\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\r\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\r\n#else // don't actually submit with this\r\n#define dbg(...)\r\n#define dbgl(lev, x)\r\n#endif\r\n\r\n    // https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\r\n    const auto beg = std::chrono::high_resolution_clock::now();\r\n    void dbg_time()\r\n    {\r\n        auto duration = chrono::duration<double>(\r\n            std::chrono::high_resolution_clock::now() - beg);\r\n        dbg(duration.count());\r\n    }\r\n}\r\n\r\ninline namespace FileIO\r\n{\r\n    void setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\r\n    void setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\r\n    void setIO(str s = \"\")\r\n    {\r\n        cin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\r\n        // cin.exceptions(cin.failbit);\r\n        // throws exception when do smth illegal\r\n        // ex. try to read letter into int\r\n        if (sz(s))\r\n            setIn(s + \".in\"), setOut(s + \".out\"); // for old USACO\r\n    }\r\n}\r\n// =====================================================\r\n\r\nconst lld PI = 3.14159265358979323846;\r\n// const ll mod = 998244353;\r\n//const ll mod = LLONG_MAX;\r\n const ll mod = 1e9+7;\r\n// const mx = 2e5+2;\r\n// vll dp(mx,-1);\r\nll K;\r\nll M;\r\nll N;\r\nvoid solve(int tc = 0)\r\n{\r\n    ll n, m = 0, a = 0, b = 0, c = 0, d = 0, h = 0, k = 0, flag = 0, nxt = 0, prv = 0;\r\n    str s,s1,s2;\r\n    cin >> n >> m;\r\n    cin >> s;\r\n    auto fPos = [&](){\r\n        int ans = 0;\r\n        rep(i, 0, (n+1)/2){\r\n            flag = 0;\r\n            k = 0;\r\n            rep(j, n-i-1, n){\r\n                if(s[k++] != s[j]){\r\n                    flag = 1;\r\n                    break;\r\n                }\r\n            }\r\n            if(!flag) ans = i+1;\r\n        }\r\n        return ans;\r\n    };\r\n    b = fPos();\r\n    s1 = s.substr(b, n-b);\r\n    rep(i, 0, m-1)s += s1;\r\n    ps(s);\r\n    return;\r\n    // code here and comment out cin >> tc when there is only one test case\r\n}\r\nvoid precompute()\r\n{\r\n\r\n    return;\r\n}\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n\r\n    int tc = 1;\r\n    precompute();\r\n    // set first input point here\r\n    // cin>>tc;\r\n\r\n    for (int t = 0; t < tc; ++t)\r\n        solve(t);\r\n    return 0;\r\n\r\n    // you should actually read the stuff down here\r\n}\r\n\r\n/* stuff you should look for\r\n * int overflow, array bounds\r\n * special cases (n=1?)\r\n * do smth instead of nothing and stay organized\r\n * WRITE STUFF DOWN\r\n * DON'T GET STUCK ON ONE APPROACH\r\n */\r\n\r\n// ! Do something instead of nothing: write out small cases, code bruteforce\r\n// ! Check bounds even if I have a solution - are they letting through simpler versions?\r\n// ! If stuck on a \"should be easy\" problem for 10 mins, reread statement, check bounds\r\n\r\n/* possible reasons for runtime errors if everything else seems correct\r\n    pragma not supported on judge ( if weird judge like yandex)\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// =====================================================\r\n// Stuff not required but maybe i can use it later\r\n/*\r\nusing umpi = unordered_map<int,int>;\r\nusing umpc = unordered_map<char,int>;\r\nusing umps = unordered_map<string,int>;\r\nusing mpi = map<int,int>;\r\nusing mps = map<string,int>;\r\nusing mpc = map<char,int>;\r\nusing umpvi = unordered_map<vector<int>, int>;\r\nusing umpvc = unordered_map<vector<char>, int>;\r\nusing umpvs = unordered_map<vector<string>, int>;\r\nusing umpvll = unordered_map<vector<ll>, int>;\r\nusing umpll = unordered_map<ll, int>;\r\nusing mpll = map<ll ,int>;\r\nusing mpvs = map<vector<string>, int>;\r\n\r\n*/\r\n/*HISTORIC\r\n#define read(x) for(auto &i:x)cin >> i\r\n#define write(x) { for(auto &i:x)cout << i << \" \"; cout << endl; }\r\n#define print(x) cout << x << endl\r\n*/\r\n// =====================================================\r\n"
}