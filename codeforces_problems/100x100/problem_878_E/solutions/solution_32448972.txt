{
    "id": 32448972,
    "contestId": 878,
    "creationTimeSeconds": 1511073767,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 878,
        "index": "E",
        "name": "Numbers on the blackboard",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "combinatorics",
            "dp"
        ]
    },
    "author": {
        "contestId": 878,
        "members": [
            {
                "handle": "BSBandme"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1509029100
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 15,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 31334400,
    "source": "// #define DEBUG\r\n//#define USEPB_DS\r\n#define USETR1\r\n#define CPPELEVEN\r\n#define GPP\r\n\r\n/*\r\n * temp.cpp\r\n *\r\n *  Created on: 2012-7-18\r\n *      Author: BSBandme\r\n */\r\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string.h>\r\n#include <cstdio>\r\n#include <algorithm>\r\n#include <string>\r\n#include <vector>\r\n#include <queue>\r\n#include <cassert>\r\n#include <list>\r\n#include <iomanip>\r\n#include <math.h>\r\n#include <deque>\r\n#include <utility>\r\n#include <map>\r\n#include <set>\r\n#include <bitset>\r\n#include <numeric>\r\n#include <climits>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <functional>\r\n#include <sstream>\r\n#include <tuple>\r\n\r\nusing namespace std;\r\n\r\n#ifndef CPPELEVEN\r\n#ifdef USETR1\r\n#include <tr1/unordered_map>\r\n#include <tr1/unordered_set>\r\nusing namespace tr1;\r\n#endif\r\n#else\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\n\r\n#ifdef USEPB_DS\r\n#include <ext/pb_ds/priority_queue.hpp>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\r\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\r\n// splay_tree_tag, ov_tree_tag\r\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\r\n#endif\r\n\r\n#define mpr make_pair\r\ntypedef unsigned int ui;\r\ntypedef unsigned long long ull;\r\ntypedef long long ll;\r\ntypedef pair <int, int> pii;\r\ntypedef pair <ll, ll> pll;\r\ntypedef pair <double, double> pdd;\r\ntypedef vector <int> vi;\r\ntypedef vector <ll> vll;\r\ntypedef vector <double> vd;\r\ntypedef vector <string> vs;\r\ntypedef map <string, int> mpsi;\r\ntypedef map <double, int> mpdi;\r\ntypedef map <int, int> mpii;\r\n\r\nconst double pi = acos(0.0) * 2.0;\r\nconst long double eps = 1e-10;\r\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\r\n\r\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\r\n\r\n#ifndef CPPELEVEN\r\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\r\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\r\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\r\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\r\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\r\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\r\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\r\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\r\n#else\r\ntemplate <typename t, typename t1>\r\nt min1(t a, t1 b) { return a < b ? a : b; }\r\ntemplate <typename t, typename... arg>\r\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\r\ntemplate <typename t, typename t1>\r\nt max1(t a, t1 b) { return a > b ? a : b; }\r\ntemplate <typename t, typename... arg>\r\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\r\n#endif\r\n\r\ninline int jud(double a, double b){\r\n\tif(abs(a) < eps && abs(b) < eps) return 0;\r\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\r\n\tif(a < b) return -1;\r\n\treturn 1;\r\n}\r\ntemplate <typename t> inline int jud(t a, t b){\r\n\tif(a < b) return -1;\r\n\tif(a == b) return 0;\r\n\treturn 1;\r\n}\r\n\r\n// f_lb == 1\u4ee3\u8868\u8fd4\u56de\u76f8\u540c\u7684\u4e00\u4e32\u7684\u5de6\u8fb9\u754c\uff0cf_small == 1\u4ee3\u8868\u8fd4\u56de\u5982\u679c\u6ca1\u6709\u5bfb\u627e\u7684\u503c\u8fd4\u56de\u5c0f\u7684\u6570\r\ntemplate <typename it, typename t1>\r\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\r\n\tif(na == 0) return 0;\r\n\tint be = 0, en = na - 1;\r\n\tif(*a <= *(a + na - 1)){\r\n\t\tif(f_lb == 0) while(be < en){\r\n\t\t\tint mid = (be + en + 1) / 2;\r\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\r\n\t\t\telse en = mid - 1;\r\n\t\t}else while(be < en){\r\n\t\t\tint mid = (be + en) / 2;\r\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\r\n\t\t\telse be = mid + 1;\r\n\t\t}\r\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\r\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\r\n\t} else {\r\n\t\tif(f_lb) while(be < en){\r\n\t\t\tint mid = (be + en + 1) / 2;\r\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\r\n\t\t\telse en = mid - 1;\r\n\t\t}else while(be < en){\r\n\t\t\tint mid = (be + en) / 2;\r\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\r\n\t\t\telse be = mid + 1;\r\n\t\t}\r\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\r\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\r\n\t}\r\n\treturn be;\r\n}\r\n\r\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\r\n#ifdef GPP\r\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\r\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\r\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\r\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\r\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\r\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\r\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\r\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\r\n#else\r\n#endif\r\n\r\nlong long pow(long long n, long long m, long long mod = 0){\r\n\tif(m < 0) return 0;\r\n\tlong long ans = 1;\r\n\tlong long k = n;\r\n\twhile(m){\r\n\t\tif(m & 1) {\r\n\t\t\tans *= k;\r\n\t\t\tif(mod) ans %= mod;\r\n\t\t}\r\n\t\tk *= k;\r\n\t\tif(mod) k %= mod;\r\n\t\tm >>= 1;\r\n\t}\r\n\treturn ans;\r\n}\r\n\r\n#define  MOD 1000000007\r\ntemplate <class t1, class t2>\r\ninline void add(t1 &a, t2 b, int mod = -1) {\r\n\tif(mod == -1) mod = MOD;\r\n\ta += b;\r\n\twhile(a >= mod) a -= mod;\r\n\twhile(a < 0) a += mod;\r\n}\r\ntemplate <class t>\r\nvoid output1(t arr) {\r\n\tfor(int i = 0; i < (int)arr.size(); i++)\r\n\t\tcerr << arr[i] << ' ';\r\n\tcerr << endl;\r\n}\r\ntemplate <class t>\r\nvoid output2(t arr) {\r\n\tfor(int i = 0; i < (int)arr.size(); i++)\r\n\t\toutput1(arr[i]);\r\n}\r\n\r\n//....................\u5bc6..........\u5c01..........\u7ebf..........\u4e0b..........\u7981..........\u6b62..........hack...............................................\r\n\r\nconst int mod = MOD;\r\nconst int maxn = 100100;\r\nint st[maxn], lst;\r\nll pow2[maxn], inv2[maxn];\r\nll arr[maxn];\r\nll sum[maxn];\r\nint to[maxn][20];\r\nll tosum[maxn][20];\r\nll rto[maxn], rtosum[maxn];\r\nint n, nq;\r\n\r\nll getsum(int a, int b) {\r\n\tll ans = sum[b];\r\n\tif (a) {\r\n\t\tans -= sum[a - 1];\r\n\t\tans = (ans % mod + mod) % mod;\r\n\t}\r\n\treturn inv2[a] * ans % mod;\r\n}\r\n\r\nint main() {\r\n\r\n\r\n//............................\u4e0d\u8981\u518d\u5fd8\u4e86\u68c0\u67e5maxn\u5927\u5c0f\u4e86\uff01\uff01\uff01\uff01BSBandme\u4f60\u4e2aSB\uff01\uff01\uff01\uff01...................................................\r\n\r\n\tios_base::sync_with_stdio(0);\r\n\t#ifdef DEBUG //......................................................................................................\r\n\tfreopen(\"input.txt\", \"r\", stdin);\r\n\tint __size__ = 256 << 20; // 256MB\r\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\r\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\r\n\t#endif //...........................................................................................................\r\n\r\n\tpow2[0] = inv2[0] = 1;\r\n\tpow2[1] = 2;\r\n\tinv2[1] = pow(2, mod - 2, mod);\r\n\tfor (int i = 1; i < maxn; i++) {\r\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\r\n\t\tinv2[i] = inv2[i - 1] * inv2[1] % mod;\r\n\t}\r\n\r\n\tscanf(\"%d%d\", &n, &nq);\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tscanf(\"%I64d\", arr + i);\r\n\t\tsum[i] = arr[i] * pow2[i];\r\n\t\tif (i) sum[i] += sum[i - 1];\r\n\t\tsum[i] = (sum[i] % mod + mod) % mod;\r\n\t}\r\n\trto[0] = -1; rtosum[0] = arr[0];\r\n\tst[lst++] = 0;\r\n\tfor (int i = 1; i < n; i++) {\r\n\t\trto[i] = i - 1;\r\n\t\tll rsum = arr[i];\r\n\t\twhile (rto[i] != -1 && rsum >= 0) {\r\n\t\t\tint nextto = rto[rto[i]];\r\n\t\t\tif (rto[i] - nextto > 32) {\r\n\t\t\t\trto[i] = -1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trsum = rsum * pow(2, rto[i] - nextto, 0);\r\n\t\t\tif (arr[rto[i]] >= 0) {\r\n\t\t\t\trsum += rtosum[rto[i]];\r\n\t\t\t} else {\r\n\t\t\t\trsum += arr[rto[i]];\r\n\t\t\t}\r\n\t\t\tif (rsum > 2000000000) {\r\n\t\t\t\trto[i] = -1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trto[i] = nextto;\r\n\t\t}\r\n\t\trtosum[i] = getsum(rto[i] + 1, i);\r\n\t}\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tto[i][0] = rto[i];\r\n\t\ttosum[i][0] = rtosum[i];\r\n\t\tif (rto[i] != -1) {\r\n\t\t\ttosum[i][0] = tosum[i][0] * 2 % mod;\r\n\t\t}\r\n\t}\r\n\tfor (int j = 1; j < 20; j++) {\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tif (to[i][j - 1] == -1) {\r\n\t\t\t\tto[i][j] = -1;\r\n\t\t\t\ttosum[i][j] = tosum[i][j - 1];\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tto[i][j] = to[to[i][j - 1]][j - 1];\r\n\t\t\ttosum[i][j] = tosum[i][j - 1] + tosum[to[i][j - 1]][j - 1];\r\n\t\t\ttosum[i][j] %= mod;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < nq; i++\t) {\r\n\t\tint a, b;\r\n\t\tscanf(\"%d%d\",  &a, &b);\r\n\t\ta--; b--;\r\n\t\tll ans = 0, st = b;\r\n\t\tfor (int j = 19; j >= 0; j--) {\r\n\t\t\tif (to[st][j] >= a) {\r\n\t\t\t\tans += tosum[st][j];\r\n\t\t\t\tans %= mod;\r\n\t\t\t\tst = to[st][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (st >= a) {\r\n\t\t\tans += getsum(a, st);\r\n\t\t\tans %= mod;\r\n\t\t}\r\n\t\tprintf(\"%I64d\\n\", (ans % mod + mod) % mod);\r\n\t}\r\n\r\n    return 0;\r\n}\r\n\r\n"
}