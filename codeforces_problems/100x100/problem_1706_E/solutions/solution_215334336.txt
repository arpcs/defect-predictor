{
    "id": 215334336,
    "contestId": 1706,
    "creationTimeSeconds": 1690192352,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1706,
        "index": "E",
        "name": "Qpwoeirut and Vertices",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "dsu",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1706,
        "members": [
            {
                "handle": "shmax_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1658154900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 0,
    "source": "/*\r\n * powered by ANDRIY POPYK\r\n * in honor of DASHA LOBAS and SEGMENT DECOMPOSITION and N^(log(N))\r\n*/\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n\r\n//#pragma GCC optimize(\"O3\")\r\n//#pragma GCC target(\"avx,avx2,fma\")\r\n//#pragma GCC optimization (\"unroll-loops\")\r\n//#pragma GCC target(\"avx,avx2,sse,sse2,sse3,sse4,popcnt\")\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define int long long\r\n#define float long double\r\n#define elif else if\r\n#define endl \"\\n\"\r\n#define mod 1000000007\r\n#define pi acos(-1)\r\n#define eps 0.000000001\r\n#define inf 1000000000000\r\n#define FIXED(a) cout << fixed << setprecision(a)\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define time_init auto start = std::chrono::high_resolution_clock::now()\r\n#define time_report                                       \\\r\n    auto end = std::chrono::high_resolution_clock::now(); \\\r\n    std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << \" ms\" << endl\r\n#define debug(x) \\\r\n    { cerr << #x << \" = \" << x << endl; }\r\n#define len(x) (int) x.size()\r\n#define sqr(x) ((x) * (x))\r\n#define cube(x) ((x) * (x) * (x))\r\n#define bit(x, i) (((x) >> (i)) & 1)\r\n#define set_bit(x, i) ((x) | (1LL << (i)))\r\n#define clear_bit(x, i) ((x) & (~(1LL << (i))))\r\n#define toggle_bit(x, i) ((x) ^ (1LL << (i)))\r\n#define low_bit(x) ((x) & (-(x)))\r\n#define count_bit(x) __builtin_popcountll(x)\r\n#define srt(x) sort(all(x))\r\n#define rsrt(x) sort(rall(x))\r\n\r\ntemplate<typename T>\r\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate<typename T>\r\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\r\ntemplate<typename T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate<typename T>\r\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate<typename T>\r\nusing matrix = vector<vector<T>>;\r\ntemplate<typename T>\r\nusing graph = vector<vector<T>>;\r\n\r\ntemplate<typename T>\r\nvector<T> vect(int n, T val) {\r\n    return vector<T>(n, val);\r\n}\r\n\r\ntemplate<typename T>\r\nvector<vector<T>> vect(int n, int m, T val) {\r\n    return vector<vector<T>>(n, vector<T>(m, val));\r\n}\r\n\r\ntemplate<typename T>\r\nvector<vector<vector<T>>> vect(int n, int m, int k, T val) {\r\n    return vector<vector<vector<T>>>(n, vector<vector<T>>(m, vector<T>(k, val)));\r\n}\r\n\r\ntemplate<typename T>\r\nvector<vector<vector<vector<T>>>> vect(int n, int m, int k, int l, T val) {\r\n    return vector<vector<vector<vector<T>>>>(n, vector<vector<vector<T>>>(m, vector<vector<T>>(k, vector<T>(l, val))));\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nmatrix<T> new_matrix(int n, int m, T val) {\r\n    return matrix<T>(n, vector<T>(m, val));\r\n}\r\n\r\ntemplate<typename T>\r\ngraph<T> new_graph(int n) {\r\n    return graph<T>(n);\r\n}\r\n\r\nstruct edge {\r\n    int to, id, w;\r\n};\r\nstruct directed_edge {\r\n    int from, to, id;\r\n};\r\n\r\n\r\nclass dsu {\r\nprivate:\r\n    vector<int> parent;\r\n    vector<int> _size;\r\n    int _countOfSets;\r\n    int _n;\r\n\r\npublic:\r\n    dsu() : _n(100000), parent(100000, -2), _size(100000, 0), _countOfSets(0) {}\r\n\r\n    explicit dsu(int n) : _n(n), parent(n, -1), _size(n, -1), _countOfSets(0) {}\r\n\r\n\r\n    void add(int x) {\r\n        parent[x] = -1;\r\n        _size[x] = 1;\r\n        _countOfSets++;\r\n    }\r\n\r\n    int leader(int v) {\r\n        assert(0 <= v && v < _n);\r\n        if (parent[v] == -2)\r\n            return -1;\r\n        if (parent[v] == -1)\r\n            return v;\r\n        return parent[v] = leader(parent[v]);\r\n    }\r\n\r\n    int size(int v) {\r\n        assert(0 <= v && v < _n);\r\n        return _size[v = leader(v)];\r\n    }\r\n\r\n    int countOfSets() const {\r\n        return _countOfSets;\r\n    }\r\n\r\n    // return false if two vertex are in the same sets\r\n    bool merge(int a, int b) {\r\n        assert(0 <= a && a < _n);\r\n        assert(0 <= b && b < _n);\r\n        a = leader(a);\r\n        b = leader(b);\r\n        if (a != b) {\r\n            if (_size[a] < _size[b]) {\r\n                swap(a, b);\r\n            }\r\n            parent[b] = a;\r\n            _size[a] += _size[b];\r\n            _countOfSets--;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    bool same(int a, int b) {\r\n        assert(0 <= a && a < _n);\r\n        assert(0 <= b && b < _n);\r\n        return leader(a) == leader(b);\r\n    }\r\n};\r\n\r\ntemplate<typename it, typename bin_op>\r\nstruct SparseTable {\r\n\r\n    using T = typename remove_reference<decltype(*declval<it>())>::type;\r\n    vector<vector<T>> t;\r\n    bin_op f;\r\n\r\n    SparseTable(it first, it last, bin_op op) : t(1), f(op) {\r\n        int n = distance(first, last);\r\n        t.assign(32 - __builtin_clz(n), vector<T>(n));\r\n        t[0].assign(first, last);\r\n        for (int i = 1; i < t.size(); i++)\r\n            for (int j = 0; j < n - (1 << i) + 1; j++)\r\n                t[i][j] = f(t[i - 1][j], t[i - 1][j + (1 << (i - 1))]);\r\n    }\r\n\r\n    // returns f(a[l..r]) in O(1) time\r\n    T get(int l, int r) {\r\n        int h = floor(log2(r - l + 1));\r\n        return f(t[h][l], t[h][r - (1 << h) + 1]);\r\n    }\r\n};\r\n\r\nvoid solve() {\r\n    int n, m, q;\r\n    cin >> n >> m >> q;\r\n    graph<edge> g(n);\r\n    vector<directed_edge> edges(m);\r\n    for (int i = 0; i < m; ++i) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        --u;\r\n        --v;\r\n        g[u].push_back({v, i, i + 1});\r\n        g[v].push_back({u, i, i + 1});\r\n        edges[i] = {u, v, i};\r\n    }\r\n    vector<int> f(n, -1);\r\n    dsu d(n);\r\n    sort(all(edges), [&](directed_edge a, directed_edge b) {\r\n        return a.id < b.id;\r\n    });\r\n    graph<edge> tree(n);\r\n    for (auto e: edges) {\r\n        if (d.merge(e.from, e.to)) {\r\n            tree[e.from].push_back({e.to, e.id, e.id+1});\r\n            tree[e.to].push_back({e.from, e.id, e.id+1});\r\n        }\r\n    }\r\n    int root = 0;\r\n    vector<vector<int>> binary_lifting = vect(n, 20, root);\r\n    vector<vector<int>> vals = vect(n, 20, 0LL);\r\n\r\n    vector<int> depth(n, -1);\r\n    depth[root] = 0;\r\n    vector<int> tin(n, -1);\r\n    vector<int> tout(n, -1);\r\n    int timer = 0;\r\n    function<void(int, int, edge)> dfs = [&](int v, int p, edge ed) {\r\n        tin[v] = timer++;\r\n\r\n        binary_lifting[v][0] = p;\r\n        vals[v][0] = ed.w;\r\n        for (int i = 1; i < 20; ++i) {\r\n            binary_lifting[v][i] = binary_lifting[binary_lifting[v][i - 1]][i - 1];\r\n            vals[v][i] = max(vals[v][i - 1], vals[binary_lifting[v][i - 1]][i - 1]);\r\n        }\r\n        for (auto e: tree[v]) {\r\n            if (e.to != p) {\r\n                depth[e.to] = depth[v] + 1;\r\n                dfs(e.to, v, e);\r\n            }\r\n        }\r\n        tout[v] = timer++;\r\n    };\r\n    //    is v an ancestor of u\r\n    function<bool(int, int)> isAncestor = [&](int v, int u) {\r\n        return tin[v] <= tin[u] && tout[u] <= tout[v];\r\n    };\r\n    dfs(root, root, {-1, -1, -1});\r\n    function<int(int, int)> getMaxVal = [&](int v, int u) {\r\n        int ans = 0;\r\n        if (depth[v] < depth[u])\r\n            swap(v, u);\r\n        for (int i = 19; i >= 0; --i) {\r\n            if (!isAncestor(binary_lifting[v][i], u)) {\r\n                ans = max(ans, vals[v][i]);\r\n                v = binary_lifting[v][i];\r\n            }\r\n        }\r\n        if (v == u)\r\n            return ans;\r\n        for (int i = 19; i >= 0; --i) {\r\n            if (!isAncestor(binary_lifting[v][i], binary_lifting[u][i])) {\r\n                ans = max(ans, vals[v][i]);\r\n                ans = max(ans, vals[u][i]);\r\n                v = binary_lifting[v][i];\r\n                u = binary_lifting[u][i];\r\n            }\r\n        }\r\n        ans = max(ans, vals[v][0]);\r\n        return max(ans, vals[u][0]);\r\n    };\r\n    for (int i = 0; i < n - 1; i++) {\r\n        f[i] = getMaxVal(i, i + 1);\r\n    }\r\n    SparseTable st = SparseTable(all(f), [](int a, int b) { return max(a, b); });\r\n\r\n    while (q--) {\r\n        int l, r;\r\n        cin >> l >> r;\r\n        if (l == r) {\r\n            cout << 0 << \" \";\r\n            continue;\r\n        }\r\n        --l;\r\n        --r;\r\n        int ans = st.get(l, r - 1);\r\n        cout << ans << \" \";\r\n    }\r\n    cout << endl;\r\n    return;\r\n}\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n    int q;\r\n    cin >> q;\r\n    while (q--)\r\n        solve();\r\n}"
}