{
    "id": 176842092,
    "contestId": 1706,
    "creationTimeSeconds": 1666076612,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1706,
        "index": "E",
        "name": "Qpwoeirut and Vertices",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "dsu",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1706,
        "members": [
            {
                "handle": "cpp10"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1658154900
    },
    "programmingLanguage": "Java 11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 55,
    "timeConsumedMillis": 1013,
    "memoryConsumedBytes": 70963200,
    "source": "//package com.example.practice.codeforces.sc2300;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Solution5 {\n    public static void main (String [] args) throws IOException {\n        // Use BufferedReader rather than RandomAccessFile; it's much faster\n        final BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        // input file name goes above\n        int Q = Integer.parseInt(input.readLine());\n        while (Q>0){\n            StringTokenizer st = new StringTokenizer(input.readLine());\n            final int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken()), q = Integer.parseInt(st.nextToken());\n            int[][] es = readArray2DInt(m, m, input);\n            int[][] qs = readArray2DInt(q, q, input);\n            printArrayInt(calc(n, m, q, es, qs), out);\n            Q--;\n        }\n        out.close();       // close the output file\n    }\n\n    private static int[] calc(final int n, final int m, final int q, int[][] es, int[][] qs) {\n        int[] rd = new int[n+2], rdl = new int[n+2], rdr = new int[n+2];\n        ArrayList<Integer>[] als = new ArrayList[n+1];\n        ArrayList<int[]> rgs = new ArrayList<>();\n        for (int i=1;i<=n;++i){\n            als[i] = new ArrayList<>();\n            als[i].add(i);\n            rd[i] = rdl[i] = rdr[i] = i;\n            rgs.add(new int[]{i, i, 0});\n        }\n        int p =1;\n        for (int[] e : es){\n            int a = find(rd, e[0]), b = find(rd, e[1]);\n            if (a != b){\n                if (als[a].size() > als[b].size()){\n                    int temp = a;\n                    a = b;\n                    b = temp;\n                }\n                rd[a] = b;\n                for (int v : als[a]){\n                    int l = find(rdl, v), r = find(rdr, v), newl = l, newr = r;\n                    if (l==v && find(rd, v-1)==b){\n                        int t = find(rdl, v-1);\n                        rdl[v] = t;\n                        rdr[v-1] = newr;\n                        newl = t;\n                    }\n                    if (r==v && find(rd, v+1)==b){\n                        int t = find(rdr, v+1);\n                        rdr[v] = t;\n                        rdl[v+1] = newl;\n                        newr = t;\n                    }\n                    if (newl != l || newr != r){\n                        rgs.add(new int[]{newl, newr, p});\n                    }\n                    als[b].add(v);\n                }\n            }\n            p++;\n        }\n        SegTree segTree = new SegTree(1, n, m);\n        int[][] qs2 = new int[q][];\n        p = 0;\n        for (int[] q2 : qs){\n            qs2[p] = new int[]{q2[0], q2[1], p};\n            p++;\n        }\n        Arrays.sort(qs2, (a,b) -> (a[0]-b[0]));\n        Collections.sort(rgs, (a,b) -> (a[0] - b[0]));\n        int[] res = new int[q];\n        p = 0;\n        for (int[] q2 : qs2){\n            while (p<rgs.size() && rgs.get(p)[0] <= q2[0]){\n                int[] rg = rgs.get(p++);\n                segTree.update(rg[1], rg[2]);\n            }\n            int v = segTree.getMin(q2[1], n);\n            res[q2[2]] = v;\n        }\n        return res;\n    }\n\n    private static int find(int[] rd, int idx){\n        while (idx != rd[idx]){\n            rd[idx] = rd[rd[idx]];\n            idx = rd[idx];\n        }\n        return idx;\n    }\n\n    private static void printArray(long[] ns, final PrintWriter out){\n        for (int i=0;i<ns.length;++i){\n            out.print(ns[i]);\n            if (i+1<ns.length)out.print(\" \");\n            else out.println();\n        }\n    }\n\n    private static void printArrayInt(int[] ns, final PrintWriter out){\n        for (int i=0;i<ns.length;++i){\n            out.print(ns[i]);\n            if (i+1<ns.length)out.print(\" \");\n            else out.println();\n        }\n    }\n\n    private static void printArrayVertical(long[] ns, final PrintWriter out){\n        for (long a : ns){\n            out.println(a);\n        }\n    }\n\n    private static void printArrayVerticalInt(int[] ns, final PrintWriter out){\n        for (int a : ns){\n            out.println(a);\n        }\n    }\n\n    private static void printArray2D(long[][] ns, final int len, final PrintWriter out){\n        int cnt = 0;\n        for (long[] kk : ns){\n            cnt++;\n            if (cnt > len)break;\n            for (int i=0;i<kk.length;++i){\n                out.print(kk[i]);\n                if (i+1<kk.length)out.print(\" \");\n                else out.println();\n            }\n        }\n    }\n\n    private static void printArray2DInt(int[][] ns, final int len, final PrintWriter out){\n        int cnt = 0;\n        for (int[] kk : ns){\n            cnt++;\n            if (cnt > len)break;\n            for (int i=0;i<kk.length;++i){\n                out.print(kk[i]);\n                if (i+1<kk.length)out.print(\" \");\n                else out.println();\n            }\n        }\n    }\n\n    private static long[] readArray(final int n, final BufferedReader input) throws IOException{\n        long[] ns = new long[n];\n        StringTokenizer st = new StringTokenizer(input.readLine());\n        for (int i=0;i<n;++i){\n            ns[i] = Long.parseLong(st.nextToken());\n        }\n        return ns;\n    }\n\n    private static int[] readArrayInt(final int n, final BufferedReader input) throws IOException{\n        int[] ns = new int[n];\n        StringTokenizer st = new StringTokenizer(input.readLine());\n        for (int i=0;i<n;++i){\n            ns[i] = Integer.parseInt(st.nextToken());\n        }\n        return ns;\n    }\n\n    private static long[] readArrayVertical(final int n, final BufferedReader input) throws IOException{\n        long[] ns = new long[n];\n        for (int i=0;i<n;++i){\n            ns[i] = Long.parseLong(input.readLine());\n        }\n        return ns;\n    }\n\n    private static int[] readArrayVerticalInt(final int n, final BufferedReader input) throws IOException{\n        int[] ns = new int[n];\n        for (int i=0;i<n;++i){\n            ns[i] = Integer.parseInt(input.readLine());\n        }\n        return ns;\n    }\n\n    private static long[][] readArray2D(final int n, final int len, final BufferedReader input) throws IOException{\n        long[][] ns = new long[len][];\n        for (int i=0;i<n;++i){\n            StringTokenizer st = new StringTokenizer(input.readLine());\n            ArrayList<Long> al = new ArrayList<>();\n            while (st.hasMoreTokens()){\n                al.add(Long.parseLong(st.nextToken()));\n            }\n            long[] kk = new long[al.size()];\n            for (int j=0;j<kk.length;++j){\n                kk[j] = al.get(j);\n            }\n            ns[i] = kk;\n        }\n        return ns;\n    }\n\n    private static int[][] readArray2DInt(final int n, final int len, final BufferedReader input) throws IOException{\n        int[][] ns = new int[len][];\n        for (int i=0;i<n;++i){\n            StringTokenizer st = new StringTokenizer(input.readLine());\n            ArrayList<Integer> al = new ArrayList<>();\n            while (st.hasMoreTokens()){\n                al.add(Integer.parseInt(st.nextToken()));\n            }\n            int[] kk = new int[al.size()];\n            for (int j=0;j<kk.length;++j){\n                kk[j] = al.get(j);\n            }\n            ns[i] = kk;\n        }\n        return ns;\n    }\n\n    static class Tree{\n        int id;\n        int count;\n        ArrayList<Tree> cd;\n        long[] dp;\n        public Tree(int a){\n            id = a;\n            count = 1;\n            cd = new ArrayList<>();\n        }\n    }\n\n    static class SegTree{\n        int st;\n        int en;\n        int mid;\n        int val1;\n        int val2;\n        SegTree left;\n        SegTree right;\n        public SegTree(int l, int r, int d){\n            st = l;\n            en = r;\n            mid = (st + en) >> 1;\n            val1 = val2 = d;\n            if (st<en){\n                left = new SegTree(st, mid, d);\n                right = new SegTree(mid+1, en, d);\n            }else {\n                left = right = null;\n            }\n        }\n\n        public SegTree(int l, int r, int[] ns){\n            st = l;\n            en = r;\n            mid = (st + en) >> 1;\n            if (st==en){\n                val1 = val2 = ns[st];\n            }else {\n                left = new SegTree(l, mid, ns);\n                right = new SegTree(mid+1, r, ns);\n                val1 = Math.min(left.val1, right.val1);\n                val2 = Math.max(left.val2, right.val2);\n            }\n        }\n\n        void update(int idx, int v){\n            if (st==en){\n                val1 = val2 = v;\n            }else {\n                if (idx <= mid){\n                    left.update(idx, v);\n                }else {\n                    right.update(idx, v);\n                }\n                val1 = Math.min(left.val1, right.val1);\n                val2 = Math.max(left.val2, right.val2);\n            }\n        }\n\n        int getMin(int l, int r){\n            if (st==en || (l==st && r==en))return val1;\n            if (r<=mid){\n                return left.getMin(l, r);\n            }\n            if (l>mid){\n                return right.getMin(l, r);\n            }\n            return Math.min(left.getMin(l, mid), right.getMin(mid+1, r));\n        }\n\n        int getMax(int l, int r){\n            if (st==en || (l==st && r==en))return val2;\n            if (r<=mid){\n                return left.getMax(l, r);\n            }\n            if (l>mid){\n                return right.getMax(l, r);\n            }\n            return Math.max(left.getMax(l, mid), right.getMax(mid+1, r));\n        }\n    }\n}"
}