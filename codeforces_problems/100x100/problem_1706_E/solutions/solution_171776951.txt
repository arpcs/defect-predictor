{
    "id": 171776951,
    "contestId": 1706,
    "creationTimeSeconds": 1662961723,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1706,
        "index": "E",
        "name": "Qpwoeirut and Vertices",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "dsu",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1706,
        "members": [
            {
                "handle": "richard_bachman"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1658154900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 204800,
    "source": "//\r\n//  main.cpp\r\n//  CP\r\n//\r\n//  Created by richard_bachman\r\n//\r\n\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n\r\n#include <bits/stdc++.h>\r\n#include <iostream>\r\n\r\nconst int INF = 1061109567;\r\nconst long long LL_INF = 1000000000000000;\r\n\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(s) (int)((s).size())\r\n#define FOR(i,a,b) for(int i=(a); i<=(b); i++)\r\n#define ROF(i,b,a) for(int i=(b); i>=(a); i--)\r\n#define last(a) (a[sz(a)-1])\r\n\r\n#define ll long long\r\n#define vbool vector<bool>\r\n#define vint vector<int>\r\n#define vdouble vector<double>\r\n#define vll vector<long long>\r\n#define vpint vector<pint>\r\n#define vvint vector<vint>\r\n#define vvpint vector<vpint>\r\n#define vvll vector<vll>\r\n#define pb push_back\r\n\r\n#define pint pair<int, int>\r\n#define pll pair<long long, long long>\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n\r\n#define CHECK_BIT(var,pos) ((var) & (1LL<<(pos)))\r\n#define SET_BIT(var,pos) ((var |= (1LL<<(pos))))\r\n\r\nusing namespace std;\r\n\r\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& out, const pair<T1, T2>& x) {return out << x.f << ' ' << x.s;}\r\ntemplate<typename T1, typename T2> istream& operator>>(istream& in, pair<T1, T2>& x) {return in >> x.f >> x.s;}\r\n\r\ntemplate<typename T> istream& operator>>(istream& in, vector<T>& a) {for(auto &x : a) in >> x; return in;};\r\ntemplate<typename T> ostream& operator<<(ostream& out, vector<T>& a) {for(auto &x : a) out << x << ' '; return out;};\r\n\r\ntemplate<typename T> bool empty(vector<T> &a) {\r\n    return !sz(a);\r\n}\r\n\r\ntemplate<typename T> void make_unique(vector<T> &a) {\r\n    auto it = unique(all(a));\r\n    a.resize(distance(a.begin(), it));\r\n}\r\n\r\ntemplate<typename T> void sortPairByR(vector<pair<T, T>> &a) {\r\n    return sort(a.begin(), a.end(), [](auto &left, auto&right) {\r\n        return left.second < right.second;\r\n    });\r\n}\r\n\r\ntemplate<typename T> vector<T> merge(vector<T> &a, vector<T> &b) {\r\n    vector<T> res;\r\n    merge(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(res));\r\n    return res;\r\n}\r\n\r\ntemplate<typename T> int firstLargerOrEqual(vector<T> &a, T val) {\r\n    return (int) (lower_bound(a.begin(), a.end(), val) - a.begin());\r\n}\r\n\r\ntemplate<typename T> int firstLargerThan(vector<T> &a, T val) {\r\n    return (int) (upper_bound(a.begin(), a.end(), val) - a.begin());\r\n}\r\n\r\n//class ClassName {\r\n//public:\r\n//};\r\n\r\nclass DSU {\r\npublic:\r\n    vint rank;\r\n    vint parent;\r\n    int n;\r\n    \r\n    DSU(int n) {\r\n        this->n = n;\r\n        rank.resize(n);\r\n        parent.resize(n);\r\n        FOR(i,0,n-1) {\r\n            rank[i] = 0;\r\n            parent[i] = i;\r\n        }\r\n    }\r\n    \r\n    int find(int x) {\r\n        if (parent[x] != x) {\r\n            parent[x] = find(parent[x]);\r\n        }\r\n        return parent[x];\r\n    }\r\n    \r\n    void unite(int x, int y) {\r\n        int xp = find(x);\r\n        int yp = find(y);\r\n        \r\n        if (xp == yp) {\r\n            return;\r\n        }\r\n        \r\n        if (rank[xp] < rank[yp]) {\r\n            parent[xp] = yp;\r\n        } else {\r\n            parent[yp] = xp;\r\n            if (rank[xp] == rank[yp]) {\r\n                rank[xp]++;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nint getBlock(int x, int block_size) {\r\n    return x / block_size;\r\n}\r\n\r\nvoid solve() {\r\n    int n, m, q; cin >> n >> m >> q;\r\n    \r\n    DSU dsu(n);\r\n    vector<set<pint>> ranges(n);\r\n    FOR(i,0,n-1) {\r\n        ranges[i].insert(mp(i, i));\r\n    }\r\n    \r\n    vpint power_ranges;\r\n    vint power_times;\r\n    \r\n    bool dima = false;\r\n    \r\n    FOR(mm,1,m) {\r\n        int a, b; cin >> a >> b;\r\n        a--; b--;\r\n        \r\n        int ap = dsu.find(a);\r\n        int bp = dsu.find(b);\r\n        \r\n        if (ap == bp) {\r\n            continue;\r\n        }\r\n        \r\n        // for joining ranges\r\n        if (sz(ranges[ap]) < sz(ranges[bp])) {\r\n            swap(ap, bp);\r\n        }\r\n        \r\n        // combine ranges\r\n        for(auto itb = ranges[bp].begin(); itb != ranges[bp].end(); itb++) {\r\n            auto rb = ranges[ap].upper_bound(*itb);\r\n            auto lb = rb; lb--;\r\n            \r\n            pint to_add = *itb;\r\n            bool new_range = false;\r\n            bool erl = false;\r\n            bool err = false;\r\n            \r\n            if (lb != ranges[ap].end() && (*lb).s + 1 == to_add.f) {\r\n                erl = true;\r\n                to_add.f = (*lb).f;\r\n                new_range = true;\r\n            }\r\n            if (rb != ranges[ap].end() && (*rb).f - 1 == to_add.s) {\r\n                err = true;\r\n                to_add.s = (*rb).s;\r\n                new_range = true;\r\n            }\r\n            \r\n            if (erl) {\r\n                ranges[ap].erase(lb);\r\n            }\r\n            if (err) {\r\n                ranges[ap].erase(rb);\r\n            }\r\n            \r\n            ranges[ap].insert(to_add);\r\n            if (new_range) {\r\n                power_ranges.pb(to_add);\r\n                power_times.pb(mm);\r\n            }\r\n        }\r\n        \r\n        if (dsu.rank[ap] < dsu.rank[bp]) {\r\n            ranges[bp] = move(ranges[ap]);\r\n        }\r\n        \r\n        dsu.unite(a, b);\r\n    }\r\n    \r\n    vpint og_qs(q);\r\n    cin >> og_qs;\r\n    FOR(qq,0,q-1) {\r\n        og_qs[qq].f--;\r\n        og_qs[qq].s--;\r\n    }\r\n    \r\n    vpint qs;\r\n    set<pint> seen;\r\n    FOR(i,0,q-1) {\r\n        if (og_qs[i].f != og_qs[i].s && seen.count(og_qs[i]) == 0) {\r\n            seen.insert(og_qs[i]);\r\n            qs.pb(og_qs[i]);\r\n        }\r\n    }\r\n    \r\n    int block_size = 300;\r\n    int blocks = n / block_size + 1;\r\n    \r\n    vector<vector<pint>> se(blocks);\r\n    FOR(i,0,sz(qs)-1) {\r\n        se[getBlock(qs[i].f, block_size)].pb(mp(qs[i].f, qs[i].s));\r\n    }\r\n    FOR(i,0,blocks-1) {\r\n        sortPairByR(se[i]);\r\n    }\r\n    \r\n    map<pint, int> ans;\r\n    vint blocks_start(blocks, 0);\r\n    \r\n    FOR(i,0,sz(power_ranges)-1) {\r\n        if (sz(ans) == sz(qs)) {\r\n            break;\r\n        }\r\n        int bs = getBlock(power_ranges[i].f, block_size);\r\n        int be = getBlock(power_ranges[i].s, block_size);\r\n        \r\n        // for each block inside, get the ones that end early enough\r\n        FOR(bi, bs+1, be-1) {\r\n            vpint se_bi;\r\n            while (blocks_start[bi] < sz(se[bi]) && power_ranges[i].f <= se[bi][blocks_start[bi]].f && se[bi][blocks_start[bi]].s <= power_ranges[i].s) {\r\n                ans[se[bi][blocks_start[bi]]] = power_times[i];\r\n                blocks_start[bi]++;\r\n            }\r\n        }\r\n        \r\n        // get start ones\r\n        vpint se_bs;\r\n        FOR(bii, blocks_start[bs], sz(se[bs])-1) {\r\n            if (power_ranges[i].f <= se[bs][bii].f && se[bs][bii].s <= power_ranges[i].s) {\r\n                ans[se[bs][bii]] = power_times[i];\r\n            } else {\r\n                se_bs.pb(se[bs][bii]);\r\n            }\r\n        }\r\n        se[bs] = move(se_bs);\r\n        blocks_start[bs] = 0;\r\n        \r\n        // get last ones\r\n        vpint se_be;\r\n        FOR(bii, blocks_start[be], sz(se[be])-1) {\r\n            if (power_ranges[i].f <= se[be][bii].f && se[be][bii].s <= power_ranges[i].s) {\r\n                ans[se[be][bii]] = power_times[i];\r\n            } else {\r\n                se_be.pb(se[be][bii]);\r\n            }\r\n        }\r\n        se[be] = move(se_be);\r\n        blocks_start[be] = 0;\r\n    }\r\n    \r\n    FOR(qq,0,q-1) {\r\n        cout << ((og_qs[qq].f == og_qs[qq].s) ? 0 : ans[og_qs[qq]]) << \" \";\r\n    }\r\n    cout << \"\\n\";\r\n}\r\n\r\n/*\r\n \r\n 1\r\n 5 5 5\r\n 1 2\r\n 1 3\r\n 2 4\r\n 3 4\r\n 3 5\r\n 1 4\r\n 3 4\r\n 2 2\r\n 2 5\r\n 3 5\r\n \r\n 1\r\n 4 3 10\r\n 1 4\r\n 2 1\r\n 3 1\r\n 1 1\r\n 1 2\r\n 1 3\r\n 1 4\r\n 2 2\r\n 2 3\r\n 2 4\r\n 3 3\r\n 3 4\r\n 4 4\r\n \r\n */\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\r\n    // cout << \"good morning, world!\" << \"\\n\";\r\n\r\n    int t = 1;\r\n    cin >> t;\r\n    FOR(i,0,t-1) {\r\n        solve();\r\n    }\r\n\r\n//    ClassName c;\r\n//    // input = ...\r\n//    cout << c.method(input) << \"\\n\";\r\n\r\n    return 0;\r\n}\r\n\r\n// Try this:\r\n\r\n// unique / sort the array\r\n// binary search (not just the answer)\r\n// invariants (properties of array [sum, center of mass, diff-array, xor-array, etc], graph [cycles, path, mincost, etc])\r\n// maintain answers, or eliminate all non-answers\r\n// dp (deterministic states, no re-computing prev.)\r\n// SQRT decomposition\r\n// vertex condence\r\n// greedy algorithm\r\n// simulate and observe\r\n// try common / interesting patterns and see if they hold\r\n// stress-test generator / asserts\r\n\r\n"
}