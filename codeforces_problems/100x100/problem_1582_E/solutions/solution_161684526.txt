{
    "id": 161684526,
    "contestId": 1582,
    "creationTimeSeconds": 1656120025,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1582,
        "index": "E",
        "name": "Pchelyonok and Segments",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2000,
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1582,
        "members": [
            {
                "handle": "1DWalker"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1635069900
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 26,
    "timeConsumedMillis": 1715,
    "memoryConsumedBytes": 386355200,
    "source": "#pragma GCC optimize(\"O3\") \r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing ld = long double;\r\n\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(x) int((x).size())\r\n#define g0 get<0>\r\n#define g1 get<1>\r\n#define g2 get<2>\r\n#define g3 get<3>\r\n#define mill (int)(1e6)\r\n#define bill (int)(1e9)\r\n#define vi vector<int>\r\n#define vvi vector<vector<int>>\r\n#define vvvi vector<vector<vector<int>>>\r\n#define vl vector<ll>\r\n#define vvl vector<vector<ll>>\r\n#define vvvl vector<vector<vector<ll>>>\r\n#define vb vector<bool>\r\n#define vvb vector<vector<bool>>\r\n#define vd vector<double>\r\n#define vvd vector<vector<double>>\r\n#define vld vector<long double>\r\n#define vvld vector<vector<long double>>\r\n#define vc vector<char>\r\n#define vvc vector<vector<char>>\r\n#define vs vector<string>\r\n#define vvs vector<vector<string>>\r\n#define pii pair<int, int>\r\n#define pll pair<ll, ll>\r\n#define mt make_tuple\r\n#define tii tuple<int, int>\r\n#define vtii vector<tuple<int, int>>\r\n#define tiii tuple<int, int, int>\r\n#define vtiii vector<tuple<int, int, int>>\r\n#define tiiii tuple<int, int, int, int>\r\n#define vtiiii vector<tiiii>\r\n#define vtll vector<tuple<ll, ll>>\r\n#define vtli vector<tuple<ll, int>>\r\n#define vtil vector<tuple<int, ll>>\r\n#define vtill vector<tuple<int, ll, ll>>\r\n#define vtlll vector<tuple<ll, ll, ll>>\r\n#define vvtii vector<vtii>\r\n#define vvvtii vector<vvtii>\r\n#define vvtiii vector<vtiii>\r\n#define vvtll vector<vtll>\r\n#define vvtli vector<vtli>\r\n#define vvtil vector<vtil>\r\n#define vvtill vector<vtill>\r\n#define vvtlll vector<vtlll>\r\n#define tll tuple<ll, ll>\r\n#define tli tuple<ll, int>\r\n#define tlii tuple<ll, int, int>\r\n#define til tuple<int, ll>\r\n#define till tuple<int, ll, ll>\r\n#define tlll tuple<ll, ll, ll>\r\n#define qi queue<int>\r\n#define qll queue<ll>\r\n#define si set<int>\r\n#define sl set<ll>\r\n#define usi unordered_set<int>\r\n#define stii set<tii>\r\n#define ustii uset<tii>\r\n#define mii map<int, int>\r\n#define umii umap<int, int>\r\n#define mli map<ll, int>\r\n#define umli umap<ll, int>\r\n#define mil map<int, ll>\r\n#define umil umap<int, ll>\r\n#define mll map<ll, ll>\r\n#define umll umap<ll, ll>\r\n#define mivi map<int, vi>\r\n#define umivi umap<int, vi>\r\n#define mivl map<int, vl>\r\n#define umivl umap<int, vl>\r\n#define mlvl map<ll, vl>\r\n#define umlvl umap<ll, vl>\r\n#define vmii vector<mii>\r\n#define pq priority_queue\r\n#define iss istringstream\r\n#define pf push_front\r\n#define ef emplace_front\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define lb lower_bound\r\n#define up upper_bound\r\n#define MOD (int)(1e9 + 7)\r\n// #define MOD (int)(998244353)\r\n#define sor(a) sort(all(a))\r\n#define rev(a) reverse(all(a))\r\n#define mine(a) (*min_element((a).begin(), (a).end()))\r\n#define maxe(a) (*max_element((a).begin(), (a).end()))\r\n#define mini(a) (min_element((a).begin(), (a).end()) - (a).begin())\r\n#define maxi(a) (max_element((a).begin(), (a).end()) - (a).begin())\r\n#define lowb(a, x) (lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\r\n#define uppb(a, x) (upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\r\n#define repb(i, b) for (int i = 0; i < (b); ++i)\r\n#define repab(i, a, b) for (int i = (a); i < (b); ++i)\r\n#define repabd(i, a, b, d) for (int i = (a); i < (b); i += (d))\r\n#define GET_REP(_1, _2, _3, _4, NAME, ...) NAME\r\n#define re(...) GET_REP(__VA_ARGS__, repabd, repab, repb)(__VA_ARGS__)\r\n#define repra(i, a) for (int i = (a)-1; i >= 0; i--)\r\n#define reprab(i, a, b) for (int i = (a)-1; i >= (b); i--)\r\n#define reprabd(i, a, b, d) for (int i = (a)-1; i >= (b); i -= d);\r\n#define GET_REPR(_1, _2, _3, _4, NAME, ...) NAME\r\n#define rer(...) GET_REPR(__VA_ARGS__, reprabd, reprab, repra)(__VA_ARGS__)\r\n#define eachone(a, x) for (auto &a : x)\r\n#define eachtwo(k, v, x) for (auto &[k, v] : x)\r\n#define eachthree(a, b, c, x) for (auto &[a, b, c] : x)\r\n#define GET_EACH(_1, _2, _3, _4, NAME, ...) NAME\r\n#define ea(...) GET_EACH(__VA_ARGS__, eachthree, eachtwo, eachone)(__VA_ARGS__)\r\n#define rvi(v, n) vi v = vi((n)); re(i, n) cin >> v[i];\r\n#define rvl(v, n) vl v = vl((n)); re(i, n) cin >> v[i];\r\n#define rvs(v, n) vs v = vs((n)); re(i, n) cin >> v[i];\r\n#define fail() fflush(stdout); cout.flush(); assert(false);\r\n#define YES cout << \"YES\\n\"\r\n#define YESR { cout << \"YES\\n\"; return; }\r\n#define Yes cout << \"Yes\\n\"\r\n#define Yesr { cout << \"Yes\\n\"; return; }\r\n#define yes cout << \"yes\\n\"\r\n#define yesr { cout << \"yes\\n\"; return; }\r\n#define NO cout << \"NO\\n\"\r\n#define NOR { cout << \"NO\\n\"; return; }\r\n#define No cout << \"No\\n\"\r\n#define Nor { cout << \"No\\n\"; return; }\r\n#define no cout << \"no\\n\";\r\n#define nor { cout << \"no\\n\"; return; }\r\n#define n0 cout << \"0\\n\"\r\n#define n0r { cout << \"0\\n\"; return; }\r\n#define n1 cout << \"-1\\n\"\r\n#define n1r { cout << \"-1\\n\"; return; }\r\n#ifdef LOCAL\r\n#define dbg(...) logger(#__VA_ARGS__, __VA_ARGS__)\r\ntemplate <typename... Args> void logger(string vars, Args &&...values) {\r\n  cout << \"| \" << vars << \" = \";\r\n  string delim = \"\";\r\n  (..., (cout << delim << values, delim = \", \"));\r\n  cout << endl;\r\n}\r\n#else\r\n#define dbg(...) 0\r\n#endif\r\n\r\nstruct custom_hash { // source: https://codeforces.com/blog/entry/62393\r\n  static uint64_t splitmix64(uint64_t x) {\r\n    // http://xorshift.di.unimi.it/splitmix64.c\r\n    x += 0x9e3779b97f4a7c15;\r\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n    return x ^ (x >> 31);\r\n  }\r\n\r\n  size_t operator()(uint64_t x) const {\r\n    static const uint64_t FIXED_RANDOM =\r\n        chrono::steady_clock::now().time_since_epoch().count();\r\n    return (size_t)splitmix64(x + FIXED_RANDOM);\r\n  }\r\n};\r\n\r\ntemplate <typename A, typename B> using umap = unordered_map<A, B, custom_hash>;\r\ntemplate <typename A> using uset = unordered_set<A, custom_hash>;\r\n\r\ntemplate <class F> struct y_combinator {\r\n  F f;\r\n  template <class... Args> decltype(auto) operator()(Args &&...args) const {\r\n    return f(*this, forward<Args>(args)...);\r\n  }\r\n};\r\n\r\ntemplate <class F> y_combinator<decay_t<F>> lam(F &&f) {\r\n  return {forward<F>(f)};\r\n}\r\n\r\nconstexpr int pct(int x) { return __builtin_popcount(x); }\r\nconstexpr int pct(long long x) { return __builtin_popcountll(x); }\r\nconstexpr int bits(int x) { return x == 0 ? 0 : 31 - __builtin_clz(x); }\r\nconstexpr int bits(long long x) { return x == 0 ? 0 : 63 - __builtin_clzll(x); }\r\nconstexpr int p2(int x) { return 1 << x; }\r\nconstexpr int msk2(int x) { return p2(x + 1) - 1; } // 1s up to the xth bit (0-indexed), or (x+1) 1s in total\r\nconstexpr bool test(int x, int i) { return (x & (1 << i)) != 0; }\r\nconstexpr bool test(long long x, int i) { return (x & (1LL << i)) != 0; }\r\nint bitsrange(int l, int u) { assert(l <= u); return msk2(u) & (l == 0 ? 0 : msk2(l - 1)); }\r\n\r\ntemplate <class T, class U> T ipow(T a, U p) {\r\n  T ans = 1; assert(p >= 0);\r\n  for (; p; p /= 2, a *= a) if (p&1) ans *= a;\r\n  return ans;\r\n}\r\ntemplate <class T, class U> T ipow(T a, U p, T m) {\r\n  T ans = 1; assert(p >= 0);\r\n  for (; p; p /= 2, a = (a * a) % m) if (p&1) ans = (ans * a) % m;\r\n  return ans;\r\n}\r\n\r\ntemplate <class T, class U> T fstTrue(T lo, T hi, U f) {\r\n  hi++;\r\n  assert(lo <= hi); // assuming f is increasing\r\n  while (lo < hi) { // find first index such that f is true\r\n    T mid = lo + (hi - lo) / 2;\r\n    f(mid) ? hi = mid : lo = mid + 1;\r\n  }\r\n  return lo;\r\n}\r\n\r\ntemplate <class T, class U> T lstTrue(T lo, T hi, U f) {\r\n  lo--;\r\n  assert(lo <= hi); // assuming f is decreasing\r\n  while (lo < hi) { // find first index such that f is true\r\n    T mid = lo + (hi - lo + 1) / 2;\r\n    f(mid) ? lo = mid : hi = mid - 1;\r\n  }\r\n  return lo;\r\n}\r\n\r\ntemplate <class T> T sum(vector<T> &v) {\r\n  if (v.empty()) return 0LL;\r\n  T sum = v[0];\r\n  for (int i = 1; i < (int) v.size(); i++) {\r\n    sum += v[i];\r\n  }\r\n  return sum;\r\n}\r\n\r\ntemplate <class F> F posmod(F a, F b) { return ((a % b) + b) % b; }\r\n\r\n// 2d points and lines: https://codeforces.com/blog/entry/48122\r\ntemplate <class F>\r\nstruct Point {\r\n  F x, y;\r\n  Point(): x(0), y(0) {}\r\n  Point(const F& cx, const F& cy): x(cx), y(cy) {}\r\n};\r\n\r\ntemplate <class F> F floordiv(F a, F d) { F res = a / d; if (res * d != a) res -= 1 & ((a>0)^(d>0)); return res; }\r\ntemplate <class F> F ceildiv(F a, F d) { F res = a / d; if (res * d != a) res += 1 & ((a<0)^(d>0)); return res; }\r\ntemplate <class F> F sq(F a) { return a * a; }\r\n\r\nlong long inv(long long a, long long b) {\r\n  return 1 < a ? b - inv(b % a, a) * b / a : 1;\r\n}\r\n\r\ntemplate <class T> bool ckmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\r\ntemplate <class T> bool ckmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\r\n\r\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\r\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\r\nint rint(int a, int b) { // inclusive bounds\r\n  return uniform_int_distribution<int>(a, b)(rng);\r\n}\r\ndouble rdouble(double a, double b) {\r\n  return uniform_real_distribution<double>(a, b)(rng);\r\n}\r\ntemplate <class T> void shuffle(vector<T> &v) {\r\n  auto r0 = [](int x) { return rint(0, x-1); };\r\n  random_shuffle(all(v), r0);\r\n}\r\n\r\ntemplate <class T> void remdup(vector<T> &v, bool do_sort = true) { // sort and remove duplicates\r\n  if (do_sort) sort(all(v));\r\n  v.erase(unique(all(v)), end(v));\r\n}\r\n\r\ntemplate <class F> void print(const Point<F>& point) {\r\n  cout << \"x: \" << point.x << \"\\ty: \" << point.y << '\\n';\r\n}\r\n\r\ntemplate <class F> void print(const F a[], int n) {\r\n  for (int i = 0; i < n; i++) {\r\n    if (i > 0) cout << ' ';\r\n    cout << a[i];\r\n  }\r\n  cout << '\\n';\r\n}\r\n\r\ntemplate <class F> void print(const vector<F> &a) {\r\n  for (int i = 0; i < (int) a.size(); i++) {\r\n    if (i > 0) cout << ' ';\r\n    cout << a[i];\r\n  }\r\n  cout << '\\n';\r\n}\r\n\r\ntemplate <class F> void print2(const vector<vector<F>> &a) {\r\n  for (int i = 0; i < (int) a.size(); i++) {\r\n    for (int j = 0; j < (int) a[i].size(); j++) {\r\n      if (j > 0) cout << ' ';\r\n      cout << a[i][j];\r\n    }\r\n    cout << '\\n';\r\n  }\r\n}\r\n\r\ntemplate <class F> void fill2(vector<vector<F>> &a, F val) {\r\n  for (int i = 0; i < (int) a.size(); i++) {\r\n    for (int j = 0; j < (int) a[i].size(); j++) {\r\n      a[i][j] = val;\r\n    }\r\n  }\r\n}\r\n\r\ntemplate <class F> void fill3(vector<vector<vector<F>>> &a, F val) {\r\n  for (int i = 0; i < (int) a.size(); i++) {\r\n    for (int j = 0; j < (int) a[i].size(); j++) {\r\n      for (int k = 0; k < (int) a[i][j].size(); k++) {\r\n        a[i][j][k] = val;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ntemplate <class F> void r90(vector<vector<F>> &a) { // clockwise\r\n  int n = sz(a); assert(a.empty() || sz(a) == sz(a[0]));\r\n  vector<vector<F>> copy(n, vector<F>(n));\r\n  re(i, n) {\r\n    re(j, n) { copy[j][n - 1 - i] = a[i][j]; }\r\n  }\r\n  re(i, n) re(j, n) a[i][j] = copy[i][j];\r\n}\r\n\r\ntemplate <class F> void r180(vector<vector<F>> &a) {\r\n  int n = sz(a); assert(a.empty() || sz(a) == sz(a[0]));\r\n  vector<vector<F>> copy(n, vector<F>(n));\r\n  re(i, n) {\r\n    re(j, n) { copy[n - 1 - i][n - 1 - j] = a[i][j]; }\r\n  }\r\n  re(i, n) re(j, n) a[i][j] = copy[i][j];\r\n}\r\n\r\ntemplate <class F> void r270(vector<vector<F>> &a) {\r\n  int n = sz(a); assert(a.empty() || sz(a) == sz(a[0]));\r\n  vector<vector<F>> copy(n, vector<F>(n));\r\n  re(i, n) {\r\n    re(j, n) { copy[n - 1 - j][i] = a[i][j]; }\r\n  }\r\n  re(i, n) re(j, n) a[i][j] = copy[i][j];\r\n}\r\n\r\nstring reps(string s, int t) {\r\n  string res = \"\"; res.reserve(sz(s) * t);\r\n  re(i, t) res += s;\r\n  return res;\r\n}\r\n\r\nstring reps(char c, int t) { return reps(string(1, c), t); }\r\n\r\nint gen_base(const int before, const int after) {\r\n  int base = rint(before + 1, after);\r\n  return base % 2 == 0 ? base - 1 : base;\r\n}\r\n\r\nstruct phash {\r\n  static const int mod = (int) 1e9 + 123;\r\n  static vi pow1; // powers of base mod\r\n  static vector<ull> pow2; // powers of base 2^64\r\n  static int base;\r\n\r\n  vi pref1;\r\n  vector<ull> pref2;\r\n\r\n  phash(const string &s): pref1(sz(s) + 1u, 0), pref2(sz(s) + 1u, 0) {\r\n    assert(base < mod);\r\n    const int n = sz(s); // required power\r\n    while (sz(pow1) <= n) {\r\n      pow1.pb((int) ((ll) pow1.back() * base % mod));\r\n      pow2.pb(pow2.back() * base);\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      assert(base > s[i]);\r\n      pref1[i + 1] = (int) ((pref1[i] + (ll) s[i] * pow1[i]) % mod);\r\n      pref2[i + 1] = pref2[i] + s[i] * pow2[i];\r\n    }\r\n  }\r\n\r\n  inline std::pair<int, ull> operator()(const int pos, const int len, int mxPow = -1) const {\r\n    if (mxPow == -1) mxPow = (int) pref1.size() - 1;\r\n    int hash1 = pref1[pos + len] - pref1[pos];\r\n    ull hash2 = pref2[pos + len] - pref2[pos];\r\n    if (hash1 < 0) hash1 += mod;\r\n    if (mxPow != 0) {\r\n      hash1 = (int) ((ll) hash1 * pow1[mxPow - (pos + len - 1)] % mod);\r\n      hash2 *= pow2[mxPow - (pos + len - 1)];\r\n    }\r\n    return {hash1, hash2};\r\n  }\r\n};\r\n\r\nvi phash::pow1{1};\r\nvector<ull> phash::pow2{1};\r\nint phash::base = gen_base(256, phash::mod);\r\n\r\nstruct mi {\r\n  ll v;\r\n  explicit operator ll() const { return v; }\r\n  mi() { v = 0; }\r\n  mi(ll _v) {\r\n    v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\r\n    if (v < 0) v += MOD;\r\n  }\r\n  friend bool operator==(const mi& a, const mi& b) { return a.v == b.v; }\r\n  friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\r\n  friend bool operator<(const mi& a, const mi& b) { return a.v < b.v; }\r\n  mi& operator+=(const mi& m) { if ((v += m.v) >= MOD) v -= MOD; return *this; }\r\n  mi& operator-=(const mi& m) { if ((v -= m.v) < 0) v += MOD; return *this; }\r\n  mi& operator*=(const mi& m) { v = v * m.v % MOD; return *this; }\r\n  mi& operator/=(const mi& m) { return (*this) *= inv(m); }\r\n  friend mi pow(mi a, ll p) {\r\n    mi ans = 1; assert(p >= 0);\r\n    for (; p; p /= 2, a *= a) if (p&1) ans *= a;\r\n    return ans;}\r\n  friend mi inv(const mi& a) {\r\n    assert(a.v != 0);\r\n    return pow(a, MOD - 2);}\r\n  mi operator-() const { return mi(-v); }\r\n  mi &operator++() { return *this += 1; }\r\n  mi &operator--() { return *this -= 1; }\r\n  mi operator++(int) {\r\n    mi temp = *this += 1;\r\n    return temp;}\r\n  mi operator--(int) {\r\n    mi temp = *this -= 1;\r\n    return temp;}\r\n  friend mi operator+(mi a, const mi &b) { return a += b; }\r\n  friend mi operator-(mi a, const mi &b) { return a -= b; }\r\n  friend mi operator*(mi a, const mi &b) { return a *= b; }\r\n  friend mi operator/(mi a, const mi &b) { return a /= b; }\r\n  friend ostream &operator<<(ostream &os, const mi &m) {\r\n    os << m.v;\r\n    return os;\r\n  }\r\n  friend istream &operator>>(istream &is, mi &m) {\r\n    ll x;\r\n    is >> x;\r\n    m.v = x;\r\n    return is;\r\n  }\r\n};\r\n\r\nmi operator\"\" _mi(ull x) { return x; }\r\n\r\ntypedef vector<mi> vmi;\r\ntypedef vector<vector<mi>> vvmi;\r\ntypedef vector<vector<vector<mi>>> vvvmi;\r\ntypedef tuple<mi, mi> tmimi;\r\ntypedef tuple<mi, mi, mi> tmimimi;\r\ntypedef vector<tmimi> vmimi;\r\ntypedef vector<tmimimi> vmimimi;\r\ntypedef queue<mi> qmi;\r\n\r\nconst int MX = 1e6 + 30;\r\nbool facinit = false;\r\nmi facs[MX];\r\nmi facInvs[MX];\r\n\r\nmi ncr(ll a, ll b) {\r\n  assert(facinit && a < MX && b < MX);\r\n  assert(a >= 0 && b >= 0 && b <= a); // disable this assert whenever necessary\r\n  if (b > a || a < 0 || b < 0)\r\n    return 0;\r\n  mi cur = facs[a];\r\n  cur = cur * facInvs[b];\r\n  cur = cur * facInvs[a - b];\r\n  return cur;\r\n}\r\n\r\nvoid initFacs() {\r\n  facs[0] = 1;\r\n  re(i, 1, MX) facs[i] = i * facs[i - 1];\r\n  facInvs[MX - 1] = inv(facs[MX - 1]);\r\n  rer(i, MX - 1) facInvs[i] = facInvs[i + 1] * (i + 1);\r\n  facinit = true;\r\n}\r\n\r\n\r\nconst int MAXN = 1e5 + 1;\r\nll dp[MAXN][460];\r\nll pre[MAXN];\r\n\r\nvoid solve() {\r\n  int n; cin >> n;\r\n  rvl(a, n);\r\n\r\n  re(i, n) {\r\n    pre[i] = a[i];\r\n    if (i > 0) pre[i] += pre[i-1];\r\n  }\r\n\r\n  int KMAX = 1;\r\n  while (KMAX * (KMAX - 1) / 2 < n) KMAX++;\r\n  KMAX += 2;\r\n\r\n  re(i, n) {\r\n    re(j, KMAX+1) {\r\n      dp[i][j] = -1;\r\n    }\r\n  }\r\n\r\n  rer(i, n) {\r\n    dp[i][1] = a[i];\r\n    if (i < n - 1) {\r\n      ckmax(dp[i][1], dp[i+1][1]);\r\n    }\r\n  }\r\n\r\n  int possk = 1;\r\n  re(k, 2, KMAX) {\r\n    rer(i, n - k) {\r\n      ll s = pre[i + k - 1] - (i == 0 ? 0 : pre[i - 1]);\r\n      if (s < dp[i+k][k-1]) {\r\n        possk = k;\r\n        dp[i][k] = s;\r\n      }\r\n    }\r\n\r\n    rer(i, n-1) {\r\n      ckmax(dp[i][k], dp[i+1][k]);\r\n    }\r\n  }\r\n\r\n  cout << possk << '\\n';\r\n}\r\n\r\nint32_t main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0); cout << fixed;\r\n\r\n  int t = 1;\r\n  cin >> t;\r\n  while (t--) {\r\n    solve();\r\n  }\r\n  dbg(\"done\");\r\n  return 0;\r\n}"
}