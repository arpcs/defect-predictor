{
    "id": 155320983,
    "contestId": 682,
    "creationTimeSeconds": 1651260778,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 682,
        "index": "E",
        "name": "Alyona and Triangles",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2600,
        "tags": [
            "geometry",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 682,
        "members": [
            {
                "handle": "crowdforces"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1466181300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 66,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 1536000,
    "source": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <experimental/random>\n\nclass EmptyList { };\nclass EmptyDict { };\n\ntemplate <class T, class S>\nstruct CommonType { };\n\nstruct String;\n\ntemplate <class T>\nstruct List {\n    std::shared_ptr<std::vector<T>> inner;\n\n    List() : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>())) {}\n    List(std::vector<T> a) : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>(a))) {}\n    template <class S>\n    List(List<S> a) : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>(a.inner->begin(), a.inner->end()))) {}\n    List(EmptyList) : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>())) {}\n    T &operator[](size_t index) { return (*inner)[index]; }\n    const T &operator[](size_t index) const { return (*inner)[index]; }\n    void push(T value) { inner->push_back(value); }\n    void pop() { inner->pop_back(); }\n    int64_t length() const { return inner->size(); }\n\n    template <class SortFn>\n    void sort(SortFn sortFn) { std::sort(inner->begin(), inner->end(), sortFn); }\n\n    template <class S>\n    List<typename CommonType<T, S>::inner> concat(List<S> other) { List<typename CommonType<T, S>::inner> ret = EmptyList(); ret.inner->insert(ret.inner->end(), inner->begin(), inner->end()); ret.inner->insert(ret.inner->end(), other.inner->begin(), other.inner->end()); return ret; }\n    String join(String delim);\n};\n\nstruct String {\n    std::shared_ptr<std::string> inner;\n\n    String() : inner(std::shared_ptr<std::string>(new std::string())) {}\n    String(const char* a) : inner(std::shared_ptr<std::string>(new std::string(a))) {}\n    String(std::string a) : inner(std::shared_ptr<std::string>(new std::string(a))) {}\n    String operator +(String other) { return String(*inner + *other.inner); }\n    operator std::string() { return *inner; }\n    String operator[](size_t index) const { return String(std::string({(*inner)[index]})); }\n    int64_t charCodeAt(size_t index) const { return (*inner)[index]; }\n    String operator+(String &other) const { return String(*inner + *other.inner); }\n    String& operator+=(const String &other) { *inner += *other.inner; return *this; }\n    char operator <(const String &other) const { return *inner < *other.inner; }\n    char operator >(const String &other) const { return *inner > *other.inner; }\n    char operator <=(const String &other) const { return *inner <= *other.inner; }\n    char operator >=(const String &other) const { return *inner >= *other.inner; }\n    char operator ==(const String &other) const { return *inner == *other.inner; }\n    char operator !=(const String &other) const { return *inner != *other.inner; }\n    int64_t length() const { return inner->size(); }\n\n    String trim() {\n        std::string s = *inner;\n        const char* ws = \" \\t\\n\\r\\f\\v\";\n        s.erase(s.find_last_not_of(ws) + 1);\n        s.erase(0, s.find_first_not_of(ws));\n        return String(s);\n    }\n    List<String> split(String delim) { std::vector<String> ret; size_t last = 0; size_t next = 0; while ((next = inner->find(*delim.inner, last)) != std::string::npos) {   ret.push_back(String(inner->substr(last, next-last)));   last = next + delim.length(); } ret.push_back(String(inner->substr(last))); return ret; }\n};\n\ntemplate<> String List<String>::join(String delim) {\n    std::string ret; bool first = true; for (const auto& it: *inner) { if (!first) ret += *delim.inner; first = false; ret += *it.inner; } return ret;\n}\n\ntemplate <class K, class V> \nstruct Dict {\n    using Inner = __gnu_pbds::tree<K, V, std::less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n    std::shared_ptr<Inner> inner;\n\n    Dict() : inner(std::shared_ptr<Inner>(new Inner())) {}\n    Dict(std::vector<std::pair<K, V>> a) : inner(std::shared_ptr<Inner>(new Inner(a.begin(), a.end()))) {}\n    template <class K2, class V2>\n    Dict(Dict<K2, V2> a) : inner(std::shared_ptr<Inner>(new Inner(a.inner->begin(), a.inner->end()))) {}\n    Dict(EmptyDict) : inner(std::shared_ptr<Inner>(new Inner())) {}\n    V &operator[](K key) { return (*inner)[key]; }\n    const V &operator[](K key) const { return (*inner)[key]; }\n    int64_t length() const { return inner->size(); }\n    bool contains(const K& k) const { return inner->find(k) != inner->end(); }\n    void remove(const K& k) const { inner->erase(k); }\n    K keyAt(int64_t pos) const { return inner->find_by_order(pos)->first; }\n    int64_t bisect(const K& value) const { return inner->order_of_key(value); }\n\n    List<K> keys() const { std::vector<K> ret; for (auto const& it: *inner) { ret.push_back(it.first); }; return List<K>(ret); }\n};\n\ntemplate <class T> struct CommonType<List<T>, EmptyList> { using inner = List<T>; };\ntemplate <class T> struct CommonType<EmptyList, List<T>> { using inner = List<T>; };\ntemplate <class T, class S> struct CommonType<List<T>, List<S>> { using inner = List<typename CommonType<T, S>::inner>; };\n\ntemplate <class T> struct CommonType<std::nullptr_t, std::shared_ptr<T>> { using inner = std::shared_ptr<T>; };\ntemplate <class T> struct CommonType<std::shared_ptr<T>, std::nullptr_t> { using inner = std::shared_ptr<T>; };\n\ntemplate <class K, class V> struct CommonType<Dict<K, V>, EmptyDict> { using inner = Dict<K, V>; };\ntemplate <class K, class V> struct CommonType<EmptyDict, Dict<K, V>> { using inner = Dict<K, V>; };\ntemplate <class K, class V, class K2, class V2> struct CommonType<Dict<K, V>, Dict<K2, V2>> { using inner = Dict<typename CommonType<K, K2>::inner, typename CommonType<V, V2>::inner>; };\n\ntemplate <> struct CommonType<int64_t, int64_t> { using inner = int64_t; };\ntemplate <> struct CommonType<EmptyList, EmptyList> { using inner = EmptyList; };\ntemplate <> struct CommonType<EmptyDict, EmptyDict> { using inner = EmptyDict; };\ntemplate <> struct CommonType<std::nullptr_t, std::nullptr_t> { using inner = std::nullptr_t; };\ntemplate <> struct CommonType<char, char> { using inner = char; };\ntemplate <> struct CommonType<String, String> { using inner = String; };\n\nint64_t cast_int(long int x) { return x; }\nint64_t cast_int(long long int x) { return x; }\nint64_t cast_int(double x) { return x; }\nint64_t cast_int(String x) { return std::strtoll(x.inner->c_str(), NULL, 10); }\n\ndouble cast_float(long int x) { return x; }\ndouble cast_float(long long int x) { return x; }\ndouble cast_float(double x) { return x; }\ndouble cast_float(String x) { return std::strtod(x.inner->c_str(), NULL); }\n\nString cast_str(long int x) { return String(std::to_string(x)); }\nString cast_str(long long int x) { return String(std::to_string(x)); }\nString cast_str(double x) { return String(std::to_string(x)); }\nString cast_str(bool x) { return String(std::to_string(x)); }\nString cast_str(String x) { return x; }\n\nbool rand_bool() { return rand() % 100 < 50; }\nint64_t rand_int(int64_t upper) { return std::experimental::randint(int64_t(0), upper); }\nString chr(int64_t x) { return String(std::string({(char)x})); }\n\ntemplate <class T>\nstruct TypeHolder { };\n\ntemplate <class T, class S, class Filter, class Mapper>\nList<T> linq(const List<S> &input, Filter filter, Mapper mapper, TypeHolder<T> type_holder) {\n    List<T> ret;\n    for (const auto &it: *input.inner) {\n        if (filter(it)) {\n            ret.push(mapper(it));\n        }\n    }\n    return ret;\n}\n\nstruct Point;\nstd::shared_ptr<Point> Point$add(std::shared_ptr<Point> self, std::shared_ptr<Point> other);\nstd::shared_ptr<Point> Point$sub(std::shared_ptr<Point> self, std::shared_ptr<Point> other);\nString solve(String input);\nstruct Point{int64_t x;int64_t y;};\nstd::shared_ptr<Point> Point$add(std::shared_ptr<Point> self, std::shared_ptr<Point> other) {\nreturn std::shared_ptr<Point>(new Point{(self->x+other->x),(self->y+other->y)});\n}\nstd::shared_ptr<Point> Point$sub(std::shared_ptr<Point> self, std::shared_ptr<Point> other) {\nreturn std::shared_ptr<Point>(new Point{(self->x-other->x),(self->y-other->y)});\n}\nString solve(String input) {\nList<String> L = (input).split(String(\"\\n\"));\nint64_t n = cast_int((((L)[0ll]).split(String(\" \")))[0ll]);\nList<std::shared_ptr<Point>> pts = EmptyList();\nfor (int64_t i = 1ll; (i<=n); i+=1ll) {\nList<String> cl = ((L)[i]).split(String(\" \"));\n(pts).push(std::shared_ptr<Point>(new Point{cast_int((cl)[0ll]),cast_int((cl)[1ll])}));\n\n}\nstd::shared_ptr<Point> a = (pts)[0ll];\nint64_t i = 0ll;\nfor (int64_t _ = 0ll; (i<n); i+=1ll) {\nif ((((pts)[i]->x!=a->x)||((pts)[i]->y!=a->y))) {\nbreak;\n}\n\n}\nstd::shared_ptr<Point> b = (pts)[i];\nfor (int64_t _ = 0ll; (i<n); i+=1ll) {\nif ((((((b->x-a->x))*(((pts)[i]->y-a->y)))-((((pts)[i]->x-a->x))*((b->y-a->y))))!=0ll)) {\nbreak;\n}\n\n}\nstd::shared_ptr<Point> c = (pts)[i];\nif ((((((b->x-a->x))*((c->y-a->y)))-(((b->y-a->y))*((c->x-a->x))))<0ll)) {\nstd::shared_ptr<Point> _t = c;\nc = b;\nb = _t;\n}\nwhile (true) {\nint64_t cur = ((((b->x-a->x))*((c->y-a->y)))-(((b->y-a->y))*((c->x-a->x))));\ni = 0ll;\nfor (int64_t _ = 0ll; (i<n); i+=1ll) {\nif ((((((b->x-a->x))*(((pts)[i]->y-a->y)))-(((b->y-a->y))*(((pts)[i]->x-a->x))))>cur)) {\nc = (pts)[i];\nbreak;\n}\nif ((((((c->x-b->x))*(((pts)[i]->y-b->y)))-(((c->y-b->y))*(((pts)[i]->x-b->x))))>cur)) {\na = (pts)[i];\nbreak;\n}\nif ((((((a->x-c->x))*(((pts)[i]->y-c->y)))-(((a->y-c->y))*(((pts)[i]->x-c->x))))>cur)) {\nb = (pts)[i];\nbreak;\n}\n\n}\nif ((i>=n)) {\nbreak;\n}\n\n}\nstd::shared_ptr<Point> a1 = (Point$sub)((Point$add)(a, b), c);\nstd::shared_ptr<Point> b1 = (Point$sub)((Point$add)(a, c), b);\nstd::shared_ptr<Point> c1 = (Point$sub)((Point$add)(b, c), a);\nString ans = String(\"\");\nans+=(((cast_str(a1->x)+String(\" \"))+cast_str(a1->y))+String(\"\\n\"));\nans+=(((cast_str(b1->x)+String(\" \"))+cast_str(b1->y))+String(\"\\n\"));\nans+=(((cast_str(c1->x)+String(\" \"))+cast_str(c1->y))+String(\"\\n\"));\nreturn ans;\n}\nint main() { std::ios::sync_with_stdio(false) ; std::cin.tie(0) ; std::cout.tie(0) ; std::string line, input; while (std::getline(std::cin, line)) { input += line + \"\\n\"; } std::cout << *solve(String(input)).inner; return 0; }/*1651260777.087228*/"
}