{
    "id": 155318825,
    "contestId": 682,
    "creationTimeSeconds": 1651258525,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 682,
        "index": "E",
        "name": "Alyona and Triangles",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2600,
        "tags": [
            "geometry",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 682,
        "members": [
            {
                "handle": "Death_on_2_Legs"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1466181300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 66,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 1331200,
    "source": "\r\n#include <bits/stdc++.h>\r\nclass EmptyList {};\r\n\r\ntemplate <class T, class S> struct CommonType {};\r\n\r\nstruct String;\r\n\r\ntemplate <class T> struct List {\r\n    std::shared_ptr<std::vector<T>> inner;\r\n\r\n    List() : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>())) {}\r\n    List(std::vector<T> a)\r\n        : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>(a))) {}\r\n    template <class S>\r\n    List(List<S> a)\r\n        : inner(std::shared_ptr<std::vector<T>>(\r\n              new std::vector<T>(a.inner->begin(), a.inner->end()))) {}\r\n    List(EmptyList)\r\n        : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>())) {}\r\n    T& operator[](size_t index) { return (*inner)[index]; }\r\n    const T& operator[](size_t index) const { return (*inner)[index]; }\r\n    void push(T value) { inner->push_back(value); }\r\n    void pop() { inner->pop_back(); }\r\n    int64_t length() const { return inner->size(); }\r\n\r\n    template <class SortFn> void sort(SortFn sortFn) {\r\n        std::sort(inner->begin(), inner->end(), sortFn);\r\n    }\r\n\r\n    template <class S>\r\n    List<typename CommonType<T, S>::inner> concat(List<S> other) {\r\n        List<typename CommonType<T, S>::inner> ret = EmptyList();\r\n        ret.inner->insert(ret.inner->end(), inner->begin(), inner->end());\r\n        ret.inner->insert(ret.inner->end(), other.inner->begin(),\r\n                          other.inner->end());\r\n        return ret;\r\n    }\r\n    String join(String delim);\r\n};\r\n\r\nstruct String {\r\n    std::shared_ptr<std::string> inner;\r\n\r\n    String() : inner(std::shared_ptr<std::string>(new std::string())) {}\r\n    String(const char* a)\r\n        : inner(std::shared_ptr<std::string>(new std::string(a))) {}\r\n    String(std::string a)\r\n        : inner(std::shared_ptr<std::string>(new std::string(a))) {}\r\n    String operator+(String other) { return String(*inner + *other.inner); }\r\n    operator std::string() { return *inner; }\r\n    String operator[](size_t index) const {\r\n        return String(std::string({(*inner)[index]}));\r\n    }\r\n    int64_t charCodeAt(size_t index) const { return (*inner)[index]; }\r\n    String operator+(String& other) const {\r\n        return String(*inner + *other.inner);\r\n    }\r\n    String& operator+=(const String& other) {\r\n        *inner += *other.inner;\r\n        return *this;\r\n    }\r\n    char operator<(const String& other) const { return *inner < *other.inner; }\r\n    char operator>(const String& other) const { return *inner > *other.inner; }\r\n    char operator<=(const String& other) const {\r\n        return *inner <= *other.inner;\r\n    }\r\n    char operator>=(const String& other) const {\r\n        return *inner >= *other.inner;\r\n    }\r\n    char operator==(const String& other) const {\r\n        return *inner == *other.inner;\r\n    }\r\n    char operator!=(const String& other) const {\r\n        return *inner != *other.inner;\r\n    }\r\n    int64_t length() const { return inner->size(); }\r\n\r\n    String trim() {\r\n        std::string s = *inner;\r\n        const char* ws = \" \\t\\n\\r\\f\\v\";\r\n        s.erase(s.find_last_not_of(ws) + 1);\r\n        s.erase(0, s.find_first_not_of(ws));\r\n        return String(s);\r\n    }\r\n    List<String> split(String delim) {\r\n        std::vector<String> ret;\r\n        size_t last = 0;\r\n        size_t next = 0;\r\n        while ((next = inner->find(*delim.inner, last)) != std::string::npos) {\r\n            ret.push_back(String(inner->substr(last, next - last)));\r\n            last = next + delim.length();\r\n        }\r\n        ret.push_back(String(inner->substr(last)));\r\n        return ret;\r\n    }\r\n};\r\n\r\ntemplate <> String List<String>::join(String delim) {\r\n    std::string ret;\r\n    bool first = true;\r\n    for (const auto& it : *inner) {\r\n        if (!first)\r\n            ret += *delim.inner;\r\n        first = false;\r\n        ret += *it.inner;\r\n    }\r\n    return ret;\r\n}\r\n\r\ntemplate <class T> struct CommonType<List<T>, EmptyList> {\r\n    using inner = List<T>;\r\n};\r\ntemplate <class T> struct CommonType<EmptyList, List<T>> {\r\n    using inner = List<T>;\r\n};\r\ntemplate <class T, class S> struct CommonType<List<T>, List<S>> {\r\n    using inner = List<typename CommonType<T, S>::inner>;\r\n};\r\n\r\ntemplate <class T> struct CommonType<std::nullptr_t, std::shared_ptr<T>> {\r\n    using inner = std::shared_ptr<T>;\r\n};\r\ntemplate <class T> struct CommonType<std::shared_ptr<T>, std::nullptr_t> {\r\n    using inner = std::shared_ptr<T>;\r\n};\r\n\r\ntemplate <> struct CommonType<int64_t, int64_t> { using inner = int64_t; };\r\ntemplate <> struct CommonType<EmptyList, EmptyList> {\r\n    using inner = EmptyList;\r\n};\r\n\r\ntemplate <> struct CommonType<std::nullptr_t, std::nullptr_t> {\r\n    using inner = std::nullptr_t;\r\n};\r\ntemplate <> struct CommonType<char, char> { using inner = char; };\r\ntemplate <> struct CommonType<String, String> { using inner = String; };\r\n\r\nint64_t cast_int(long int x) { return x; }\r\nint64_t cast_int(long long int x) { return x; }\r\nint64_t cast_int(double x) { return x; }\r\nint64_t cast_int(String x) { return std::strtoll(x.inner->c_str(), NULL, 10); }\r\n\r\ndouble cast_float(long int x) { return x; }\r\ndouble cast_float(long long int x) { return x; }\r\ndouble cast_float(double x) { return x; }\r\ndouble cast_float(String x) { return std::strtod(x.inner->c_str(), NULL); }\r\n\r\nString cast_str(long int x) { return String(std::to_string(x)); }\r\nString cast_str(long long int x) { return String(std::to_string(x)); }\r\nString cast_str(double x) { return String(std::to_string(x)); }\r\nString cast_str(bool x) { return String(std::to_string(x)); }\r\nString cast_str(String x) { return x; }\r\n\r\nbool rand_bool() { return rand() % 100 < 50; }\r\nString chr(int64_t x) { return String(std::string({(char)x})); }\r\n\r\ntemplate <class T> struct TypeHolder {};\r\n\r\ntemplate <class T, class S, class Filter, class Mapper>\r\nList<T> linq(const List<S>& input, Filter filter, Mapper mapper,\r\n             TypeHolder<T> type_holder) {\r\n    List<T> ret;\r\n    for (const auto& it : *input.inner) {\r\n        if (filter(it)) {\r\n            ret.push(mapper(it));\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nstruct Point;\r\nPoint Point$add(Point self,\r\n                                 Point other);\r\nPoint Point$sub(Point self,\r\n                                 Point other);\r\nPoint Point$mul(Point self, int64_t k);\r\nchar Point$eq(Point self, Point other);\r\nchar Point$neq(Point self, Point other);\r\nint64_t Point$cross(Point self, Point other);\r\nint64_t area(Point a, Point b,\r\n             Point c);\r\nString solve(String input);\r\nstruct Point {\r\n    int64_t x;\r\n    int64_t y;\r\n};\r\nPoint Point$add(Point self,\r\n                                 Point other) {\r\n    return Point{(self.x + other.x), (self.y + other.y)};\r\n}\r\nPoint Point$sub(Point self,\r\n                                 Point other) {\r\n    return Point{self.x - other.x, self.y - other.y};\r\n}\r\nPoint Point$mul(Point self, int64_t k) {\r\n    return Point{(self.x * k), (self.y * k)};\r\n}\r\nchar Point$eq(Point self, Point other) {\r\n    return ((self.x == other.x) && (self.y == other.y));\r\n}\r\nchar Point$neq(Point self, Point other) {\r\n    return !((Point$eq)(self, other));\r\n}\r\nint64_t Point$cross(Point self, Point other) {\r\n    return ((self.x * other.y) - (other.x * self.y));\r\n}\r\nint64_t area(Point a, Point b,\r\n             Point c) {\r\n    return (Point$cross)(((Point$sub)(b, a)), (Point$sub)(c, a));\r\n}\r\n\r\nString solve(String input) {\r\n    List<String> L = (input).split(String(\"\\n\"));\r\n    int64_t n = cast_int((((L)[0ll]).split(String(\" \")))[0ll]);\r\n    List<Point> pts = EmptyList();\r\n    for (int64_t i = 1ll; (i <= n); i += 1ll) {\r\n        List<String> cl = L[i].split(String(\" \"));\r\n        (pts).push(Point{cast_int((cl)[0ll]), cast_int((cl)[1ll])});\r\n    }\r\n    Point a = (pts)[0ll];\r\n    int64_t i = 0ll;\r\n    for (int64_t _ = 0ll; (i < n); i += 1ll) {\r\n        if ((Point$neq)((pts)[i], a)) {\r\n            break;\r\n        }\r\n    }\r\n    Point b = (pts)[i];\r\n    for (int64_t _ = 0ll; (i < n); i += 1ll) {\r\n        if (((area)(a, b, (pts)[i]) != 0ll)) {\r\n            break;\r\n        }\r\n    }\r\n    Point c = (pts)[i];\r\n    if (((area)(a, b, c) < 0ll)) {\r\n        Point _t = c;\r\n        c = b;\r\n        b = _t;\r\n    }\r\n    int cnt = 0;\r\n    while (true) {\r\n        cnt += 1;\r\n        int64_t cur = (area)(a, b, c);\r\n        i = 0ll;\r\n        for (int64_t _ = 0ll; (i < n); i += 1ll) {\r\n            if (((area)(a, b, (pts)[i]) > cur)) {\r\n                c = (pts)[i];\r\n                break;\r\n            }\r\n            if (((area)(b, c, (pts)[i]) > cur)) {\r\n                a = (pts)[i];\r\n                break;\r\n            }\r\n            if (((area)(c, a, (pts)[i]) > cur)) {\r\n                b = (pts)[i];\r\n                break;\r\n            }\r\n        }\r\n        if ((i >= n)) {\r\n            break;\r\n        }\r\n    }\r\n    std::cerr << cnt << '\\n';\r\n    Point a1 = (Point$sub)((Point$add)(a, b), c);\r\n    Point b1 = (Point$sub)((Point$add)(a, c), b);\r\n    Point c1 = (Point$sub)((Point$add)(b, c), a);\r\n    String ans = String(\"\");\r\n    ans += (((cast_str(a1.x) + String(\" \")) + cast_str(a1.y)) + String(\"\\n\"));\r\n    ans += (((cast_str(b1.x) + String(\" \")) + cast_str(b1.y)) + String(\"\\n\"));\r\n    ans += (((cast_str(c1.x) + String(\" \")) + cast_str(c1.y)) + String(\"\\n\"));\r\n    return ans;\r\n}\r\nint main() {\r\n    std::ios::sync_with_stdio(false);\r\n    std::cin.tie(0);\r\n    std::cout.tie(0);\r\n    std::string line, input;\r\n    while (std::getline(std::cin, line)) {\r\n        input += line + \"\\n\";\r\n    }\r\n    std::cout << *solve(String(input)).inner;\r\n    return 0;\r\n} /*1651257224.1898732*/\r\n"
}