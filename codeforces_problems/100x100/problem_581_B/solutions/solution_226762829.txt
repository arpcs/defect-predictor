{
    "id": 226762829,
    "contestId": 581,
    "creationTimeSeconds": 1696520797,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 581,
        "index": "B",
        "name": "Luxurious Houses",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1100,
        "tags": [
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 581,
        "members": [
            {
                "handle": "marco.bonizzi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1443430800
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 53,
    "timeConsumedMillis": 61,
    "memoryConsumedBytes": 24985600,
    "source": "#include <algorithm>\r\n#include<bits/stdc++.h>\r\n#include <cctype>\r\n#include <climits>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <iterator>\r\n#include <locale>\r\n#include <math.h>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <sstream>\r\n#include <tuple>\r\n#include <type_traits>\r\n#include <cassert>\r\n \r\n \r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\n \r\n \r\nusing namespace std;\r\n// using namespace __gnu_pbds;\r\n \r\n \r\n#define md                  1000000007\r\n#define pb                  push_back\r\n#define eb                  emplace_back\r\n#define em                  emplace\r\n#define mp                  make_pair\r\n#define fr(i,n)             for(ll i=0;i<n;i++)\r\n#define fr1(i,k,n)          for(ll i=k;i<n;i++)\r\n#define endl                \"\\n\"\r\n#define F                   first\r\n#define S                   second\r\n#define inp(v)              for(auto &x: v) cin>>x  \r\n#define all(x)              (x).begin(), (x).end() \r\n#define fast_io             ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\n#define file_io             freopen(\"D:/cp/input.txt\", \"r+\", stdin);freopen(\"D:/cp/output.txt\", \"w+\", stdout);\r\n#define DEBUG\r\n#undef  DEBUG\r\n \r\ntypedef long long ll;\r\ntypedef pair<ll,ll> pll;\r\ntypedef pair<int,int>pii;\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n#define sc static_cast<ll>\r\n#define ONEPROBLEM\r\n#if defined(ONEPROBLEM)\r\n#undef ONEPROBLEM\r\n#endif\r\n#define ONEPROBLEM\r\n//#undef ONEPROBLEM\r\n\r\ntemplate<typename C> constexpr auto Size(const C& c) -> decltype(c.size()){\r\n  return c.size();\r\n}\r\ntemplate<typename T,std::size_t N> constexpr auto Size(const T(&)[N]) -> decltype(N){\r\n  return N;\r\n}\r\n\r\n// typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\r\nbool ispossible(const vector<ll>& a,int n,ll d,ll k,ll gain){\r\n  //cout << \"IN HERE\\n\";\r\n  int i=0;\r\n  ll elapsed{1};\r\n  ll nextime{elapsed+1LL+k};\r\n  while(d > 0){\r\n    gain-=a[i];\r\n    if(gain<=0)return true;\r\n    if(elapsed+1LL==nextime){\r\n      nextime+=1LL+k;\r\n      i=0;\r\n      --d;\r\n      ++elapsed;\r\n    }\r\n    else{\r\n      i=(i+1)%n;\r\n      if(i==0){\r\n        d-=(nextime-elapsed);\r\n        elapsed=nextime;\r\n        nextime+=1LL+k;\r\n      }\r\n      else{\r\n        ++elapsed;\r\n        --d;\r\n      }\r\n    }\r\n    //cout << \"Day \" << d << \" elapsed is \" << elapsed << \" next time is \" << nextime << \" gain is \" <<\r\n   // gain  << \" index is \" << i << \" and k is \" << k << \"\\n\"; \r\n  }\r\n  return gain<=0 and d<=0;\r\n}\r\nint dx[4]={1,-1,0,0};\r\nint dy[4]={0,0,-1,1};\r\nstruct HashStruct{\r\n  template<typename T,typename U> std::size_t operator()(const pair<T,U>& other) const{\r\n    auto first{std::hash<T>{}(other.first)};\r\n    auto second{std::hash<U>{}(other.second)};\r\n    return (first^(second<<1));\r\n  }\r\n}; \r\n#define GET(a) (a-'A')\r\n//#define PRINT\r\nstd::ofstream Result(\"output.txt\",ios::out);\r\ntypedef typename std::priority_queue<pii,\r\ntypename std::vector<pii>,\r\ntypename std::less<pii>> pq;\r\nstatic constexpr int MOD{ 998244353 };\r\n#define ms(a,b) (((a%MOD)+(b%MOD))%MOD)\r\n#define ps(a,b) (((a%MOD)*(b%MOD))%MOD)\r\nmap<int,int> h{};\r\nvoid dfs(const string& s,int i,int l,int num,int c){\r\n  if(i==l){\r\n    if(num%7==0){\r\n      h[c]=num;\r\n    }\r\n    return;\r\n  }\r\n  if(i==0){\r\n    for(int j{1};j<10;++j){\r\n      num=j;\r\n      if((s[i]-'0')!=j){\r\n        dfs(s,i+1,l,num,c+1);\r\n      }\r\n      else{\r\n        dfs(s,i+1,l,num,c);\r\n      }\r\n    }\r\n  }\r\n  else{\r\n    for(int j{0};j<10;++j){\r\n      auto x=num*10+j;\r\n      if((s[i]-'0')!=j){\r\n        dfs(s,i+1,l,x,c+1);\r\n      }\r\n      else{\r\n        dfs(s,i+1,l,x,c);\r\n      }\r\n    }\r\n  }\r\n}\r\nnamespace details{\r\n  vector<int> primes{};\r\n  void init();\r\n}\r\nvoid details::init(){\r\n  static constexpr int n{1000};\r\n  static constexpr int SIZE{10000};\r\n  bool isPrime[SIZE];\r\n  memset(isPrime,true,sizeof(isPrime));\r\n  static_assert(sizeof(isPrime)==(sizeof(bool)*std::size(isPrime)));\r\n  for(int i{2};;++i){\r\n    if(isPrime[i]){\r\n      details::primes.pb(i);\r\n      if(std::size(details::primes)==static_cast<std::size_t>(n))break;\r\n      for(int j{i*2};j<=SIZE;j+=i){\r\n        isPrime[j]=false;\r\n      }\r\n    }\r\n  }\r\n}\r\nbool isKalindrome(const vector<int>& a,int low,int high,int del){\r\n  if(low>=high)return true;\r\n  bool ans=false;\r\n  if(a[low]==a[high]){\r\n    ans=ans or isKalindrome(a, low+1, high-1, del);\r\n  }\r\n  else if(del==-1){\r\n    ans = ans or isKalindrome(a, low, high-1, a[high]) or\r\n    isKalindrome(a, low+1, high, a[low]);\r\n  }\r\n  else if(a[low]==del){\r\n    ans = ans or isKalindrome(a, low+1, high, del);\r\n  }\r\n  else if(a[high]==del){\r\n    ans = ans or isKalindrome(a, low, high-1, del);\r\n  }\r\n  return ans;\r\n}\r\nmap<string,int> dp{};\r\nint dfs(string& s){\r\n  if(s.empty())return 99999;\r\n  auto it=dp.find(s);\r\n  if(it!=end(dp))return it->second;\r\n  auto num=stoll(s);\r\n  if(num%25==0)return 0;\r\n  const auto& l{int(size(s))};\r\n  int ret=INT_MAX;\r\n  for(int i{};i<l;++i){\r\n    auto t=s;\r\n    t.erase(i,1);\r\n    ret=min(ret,1+dfs(t));\r\n  }\r\n  return dp[s]=ret;\r\n}\r\nvoid beatifulArray(){\r\n  ll n,k,b,s;\r\n  cin >> n >> k >> b >> s;\r\n  if(k*b==s){\r\n    for(int i{};i<n-1;++i){\r\n      cout << \"0 \";\r\n    }\r\n    cout << s << \"\\n\";\r\n    return;\r\n  }\r\n  if(k==1){\r\n    if(b!=s){\r\n      cout << \"-1\\n\";\r\n      return;\r\n    }\r\n    cout << s << \" \";\r\n    for(int i{1};i<n;++i){\r\n      cout << \"0 \";\r\n    }\r\n    cout << \"\\n\";\r\n    return;\r\n  }\r\n  if(k*b>s){\r\n    vector<ll> elements{k*b};\r\n    s-=k*b;\r\n    ll starter{k-1};\r\n    int i{1};\r\n    for(;i<n and s>0;++i){\r\n      ll taker=min(starter,s);\r\n      elements.push_back(taker);\r\n      s-=taker;\r\n    }\r\n    while(i++<n)elements.push_back(0);\r\n    if(s!=0){\r\n      cout << \"-1\\n\";\r\n      return;\r\n    }\r\n    for(auto&& x: elements){\r\n      cout << x << \" \";\r\n    }\r\n    cout << \"\\n\";\r\n    return;\r\n  }\r\n  int i{};\r\n  if(b==0LL){\r\n    ll start{k-1ll};\r\n    vector<ll> elements{};\r\n    for(;i<n and s>0;++i){\r\n      ll taker=min(s,start);\r\n      elements.push_back(taker);\r\n      s-=taker;\r\n    }\r\n    while(i++<n){\r\n      elements.push_back(0);\r\n    }\r\n    if(s){\r\n      cout << \"-1\\n\";\r\n      return;\r\n    }\r\n    for(auto&& x: elements){\r\n      cout << x << \" \";\r\n    }\r\n    cout << \"\\n\";\r\n    return;\r\n  }\r\n  vector<ll> elements{b*k};\r\n  s-=b*k;\r\n  ll start{k-1ll};\r\n  for(i=1;i<n and s>0;++i){\r\n    ll taker = min(s,start);\r\n    elements.push_back(taker);\r\n    s-=taker;\r\n  }\r\n  while(i++<n){\r\n    elements.emplace_back(0);\r\n  }\r\n  if(s){\r\n    cout << \"-1\\n\";\r\n    return;\r\n  }\r\n  for(auto&& x: elements){\r\n    static_assert(std::is_same_v<decltype(x),long long int&>,\"Types differ!\\n\");\r\n    cout << x << \" \";\r\n  }\r\n  cout << \"\\n\";\r\n  return;  \r\n}\r\nint dfs(const string& s,int i,int l,int* dp){\r\n  if(i==l)return 0;\r\n  if(dp[i]!=-1)return dp[i];\r\n  int ret=INT_MAX;\r\n  int j{i};\r\n  int MEX{-1};\r\n  int met[2]={0,0};\r\n  while(j<l){\r\n    ++met[s[j]-'0'];\r\n    if(met[0]==0)MEX=0;\r\n    else if(met[1]==0)MEX=1;\r\n    else MEX=2;\r\n    ret=min(ret,MEX+dfs(s,j+1,l,dp));\r\n    ++j;\r\n  }\r\n  return dp[i]=ret;\r\n}\r\nvector<int> getGoodNumbers(int maxCounter){\r\n  vector<int> a;\r\n  a.reserve(maxCounter);\r\n  int start{1};\r\n  auto isGood=[](const int x){\r\n    return (x%10!=3 and x%3!=0);\r\n  };\r\n  while(1){\r\n    if(isGood(start)){\r\n      a.push_back(start);\r\n      --maxCounter;\r\n      if(!maxCounter)break;\r\n    }\r\n    ++start;\r\n  }\r\n  return a;\r\n}\r\nvector<int> theNumbers{};\r\nint mx{INT_MIN};\r\n#define f first\r\n#define s second\r\nbool visited[51][51];\r\nbool canI(vector<string>& board,int i,int j,int n,int m){\r\n  static int dx[4]={1,-1,0,0};\r\n  static int dy[4]={0,0,1,-1};\r\n  auto isGood=[&](int i,int j){\r\n    return i>=0 and j>=0 and i<n and j<m;\r\n  };\r\n  bool ans=true;\r\n  auto col=board[i][j];\r\n  visited[i][j]=true;\r\n  for(int k{};k<4;++k){\r\n    auto ni{i+dx[k]},nj{j+dy[k]};\r\n    if(isGood(ni,nj) and !visited[ni][nj]){\r\n       if(board[ni][nj]=='.'){\r\n         board[ni][nj]=(col=='W')?('R'):('W');\r\n         ans=ans and canI(board,ni,nj,n,m);\r\n       }\r\n       else if(board[ni][nj]==col){\r\n        return false;\r\n       }\r\n       else if(board[ni][nj]!=col){\r\n        ans= ans and canI(board,ni,nj,n,m);\r\n       }\r\n    }\r\n  }\r\n  return ans;\r\n}\r\nset<vector<int>> bads{};\r\nint cache[101][101];\r\nbool can(int i,int j,int n,int m,int k){\r\n  if(k<0 or i>n or j>m)return false;\r\n  if(cache[i][j]!=-1)return cache[i][j];\r\n  if(i==n and j==m){\r\n    if(k==0)return true;\r\n  }\r\n  bool ans=false;\r\n  ans=ans or can(i+1,j,n,m,k-j);\r\n  ans=ans or can(i,j+1,n,m,k-i);\r\n  return cache[i][j]=ans;\r\n}\r\nint memo[2][101];\r\nbool dfs(int i,int j,int m,const vector<string>& a){\r\n  if(i<0 or j>=m or j<0 or i>=2)return false;\r\n  if(a[i][j]=='1')return false;\r\n  if(i==1 and j==m-1)return true;\r\n  if(memo[i][j]!=-1)return memo[i][j];\r\n  bool ans{false};\r\n  const int dx[]={1,1,0,-1,-1};\r\n  const int dy[]={0,1,1,0,1};\r\n  for(int k{};k<5;++k){\r\n    ans=ans or dfs(i+dx[k],j+dy[k],m,a);\r\n  }\r\n  return memo[i][j]=ans;\r\n}\r\nusing ip=typename std::pair<int,int>;\r\nclass Solution{\r\n  private:\r\n  int n{};\r\n  int m{};\r\n  bool isGood(int i,int j) const{\r\n    return (i>=0 and j>=0 and i<n and j<m);\r\n  }\r\n  public:\r\n  int MinimumEffort(vector<vector<int>>& heights){\r\n     n=int(heights.size());\r\n     m=int(heights.front().size());\r\n     auto getI=[&](int i,int j){\r\n      return i*m+j;\r\n     };\r\n     auto getij=[&](int I){\r\n      return mp(I/m,I%m);\r\n     };\r\n     int l{n*m};\r\n     const int INF{0x3f3f3f3f};\r\n     int dist[l];\r\n     fill(dist,dist+l,INF);\r\n     dist[0]=0;\r\n     set<ip> bst{};\r\n     bst.emplace(0,0);//{cost,I}\r\n     const int dx[4]={1,-1,0,0};\r\n     const int dy[4]={0,0,1,-1};\r\n     while(!bst.empty()){\r\n      auto cur{*bst.begin()};\r\n      static_assert(std::is_same<decltype(cur),\r\n      typename std::pair<int,int>>::value,\"Types differ...\\n\");\r\n      bst.erase(bst.begin());\r\n      auto theNode{cur.s};\r\n      auto theIJ{getij(theNode)};\r\n      auto oi{theIJ.first},oj{theIJ.second};\r\n      for(int k{};k<4;++k){\r\n        auto ni{oi+dx[k]},nj{oj+dy[k]};\r\n        if(isGood(ni, ni)){\r\n          auto NI{getI(ni,nj)};\r\n          auto dH{abs(heights[ni][nj]-heights[oi][oj])};\r\n          dH=max(dH,cur.f);\r\n          if(dist[NI]>dH){\r\n            if(dist[NI]!=INF){\r\n              bst.erase(bst.find(mp(dist[NI],NI)));\r\n            }\r\n            dist[NI]=dH;\r\n            bst.emplace(dist[NI],NI);\r\n          }\r\n        }\r\n      }\r\n     }\r\n     return *(dist+l-1);\r\n  }\r\n};\r\nint theCache[201][2][3];\r\n//dp[i][j][k] index/taken or not taken/\r\nbool can(const string& s,int i,int l,int prev,bool canremove){\r\n  if(i==l)return true;\r\n  bool ans=false;\r\n  //dp[i][canremove][prev+1]\r\n  if(theCache[i][canremove][prev+1]!=-1){\r\n    return theCache[i][canremove][prev+1];\r\n  }\r\n  if(prev==-1 and canremove){\r\n    //starting the process\r\n    ans=ans or can(s,i+1,l,s[i]-'0',true);\r\n    ans=ans or can(s,i+1,l,prev,false);\r\n  }\r\n  else if(!canremove and prev==-1){\r\n    ans=ans or can(s,i+1,l,s[i]-'0',true);\r\n  }\r\n  else if(canremove){\r\n    if(s[i]-'0'>=prev)ans=ans or can(s,i+1,l,s[i]-'0',true);\r\n    ans=ans or can(s,i+1,l,prev,false);\r\n  }\r\n  else if(!canremove){\r\n    if(s[i]-'0'>=prev)ans=ans or can(s,i+1,l,s[i]-'0',true);\r\n  }\r\n  return theCache[i][canremove][prev+1]=ans;\r\n}\r\nvector<int> thePrimes{};\r\nvoid init(int n){\r\n  bool isPrime[n+1];\r\n  memset(isPrime,1,sizeof isPrime);\r\n  for(int i{2};i<=n;++i){\r\n    if(isPrime[i]){\r\n      thePrimes.pb(i);\r\n      for(int j{i*2};j<=n;j+=i){\r\n        isPrime[j]=false;\r\n      }\r\n    }\r\n  }\r\n}\r\nnamespace std{\r\n  template<typename T,typename U> inline constexpr bool issamev=std::is_same<T,U>::value;\r\n}\r\n//https://mirror.codeforces.com/problemset/problem/385/B\r\nvoid bearANDstring(bool last=false){\r\n  string s{};\r\n  cin >> s;\r\n  const string theTarget{\"bear\"};\r\n  using ip = typename std::pair<int,int>;\r\n  #define mp make_pair\r\n  vector<ip> theIxs{};\r\n  theIxs.reserve(5000);\r\n  const auto& n{int(size(s))};\r\n  typename std::string::size_type pos=0;\r\n  while(1){\r\n    auto pos2=s.find(theTarget,pos);\r\n    if(pos2==string::npos)break;\r\n    theIxs.emplace_back(pos2,pos2+size(theTarget)-1);\r\n    pos=++pos2;\r\n  }\r\n  using ll = long long;\r\n  ll res=0;\r\n  const auto& l{int(size(theIxs))};\r\n  for(int i{};i<l;++i){\r\n    auto left{theIxs[i].f};\r\n    auto right{theIxs[i].s};\r\n    if(i==0 and i==l-1){\r\n      left=max(1,left);\r\n      right=n-right;\r\n    }\r\n    else if(i==0){\r\n      left=max(1,left);\r\n      right=n-right;\r\n    }\r\n    else if(i==l-1){\r\n      right=n-right;\r\n      left=left-theIxs[i-1].f;\r\n    }\r\n    else{\r\n      right=theIxs[i+1].s-right;\r\n      left=left-theIxs[i-1].f;\r\n    }\r\n    //cout << left << \" \" << right << \"\\n\";\r\n    res+=sc(right)*sc(left);\r\n  }\r\n  cout << res << \"\\n\";\r\n  return;\r\n}\r\nmap<string,int> theGoodOnes{{\"1\",1},{\"14\",2},{\"144\",3}};\r\nint goodNumber[20];\r\nbool ig(const string& s,int i,int n){\r\n  if(i==n)return true;\r\n  if(goodNumber[i]!=-1){\r\n    return goodNumber[i];\r\n  }\r\n  bool theResponse{false};\r\n  for(const auto& [aString,aLength] : theGoodOnes){\r\n    auto pos = s.find(aString,i);\r\n    if(pos == i){\r\n      theResponse |= ig(s,i+aLength,n);\r\n    }\r\n  }\r\n  return goodNumber[i]=theResponse;\r\n}\r\n#define PRINTGRID\r\n#undef PRINTGRID\r\nint cache2[101][101];\r\nstatic constexpr int INF{0x3f3f3f3f};\r\nint finder(int iR,int nR,const vector<int>& reds,\r\nint iB,int nB,const vector<int>& blue,int acc){\r\n  if(iR==nR and iB==nB){\r\n    return 0;\r\n  }\r\n  if(cache2[iR][iB]!=-INF){\r\n    return cache2[iR][iB];\r\n  }\r\n  int ans=0;\r\n  if(iR!=nR){\r\n    ans=max(ans,max(acc+reds[iR],finder(iR+1,nR,reds,\r\n    iB,nB,blue,acc+reds[iR])));\r\n  }\r\n  if(iB!=nB){\r\n    ans=max(ans,max(acc+blue[iB],finder(\r\n      iR,nR,reds,iB+1,nB,blue,acc+blue[iB])));\r\n  }\r\n  return cache2[iR][iB]=ans;\r\n}\r\nvector<int> aVectorCache{};\r\nvoid init2(long long int n){\r\n  if(n<2)return;\r\n  aVectorCache.clear();\r\n  aVectorCache.push_back(2ll);\r\n  long long int delta{5ll};\r\n  while(1){\r\n    auto next{aVectorCache.back()+delta};\r\n    if(next>n)break;\r\n    aVectorCache.push_back(next);\r\n    delta+=3ll;\r\n  }\r\n}\r\nint theCaching[101][101];\r\nint dfs(const vector<int>& a,int i,int k,int l){\r\n  if(i==l)return 0;\r\n  if(theCaching[i][k]!=-1){\r\n    return theCaching[i][k];\r\n  }\r\n  if(k==1){\r\n    int sub{};\r\n    for(int j{i+1};j<l;++j){\r\n      sub+=abs(a[j]-a[j-1]);\r\n    }\r\n    return sub;\r\n  }\r\n  int ans{INT_MAX};\r\n  int j{i};\r\n  int sub{};\r\n  while(j<=(l-k)){\r\n    if(j==i)ans=min(ans,dfs(a,j+1,k-1,l));\r\n    else{\r\n      sub+=abs(a[j]-a[j-1]);\r\n      ans=min(ans,sub+dfs(a,j+1,k-1,l));\r\n    }\r\n    ++j;\r\n  }\r\n  return theCaching[i][k]=ans;\r\n}\r\nvoid killIII(bool last=false){\r\n  int n,k;\r\n  cin>>n>>k;\r\n  int num;\r\n  cin>>num;\r\n  string s{to_string(num)};\r\n  cin>>s;\r\n  if(k==0){\r\n    cout<<s;\r\n    return;\r\n  }\r\n  if(n==1){\r\n    cout<<\"0\\n\";\r\n    return;\r\n  }\r\n  s.front()='1';\r\n  --k;\r\n  for(int i{1};i<n and k>0;++i){\r\n    if(s[i]=='0')continue;\r\n    --k;\r\n    s[i]='0';\r\n  }\r\n  cout<<s;\r\n  return;\r\n}\r\ntypedef void(*funcptr)(int,int);\r\ntypedef void(func)(int,int);\r\nnamespace detail{\r\n  template<typename T> struct type_identity{typedef T type;};\r\n  template<typename T> auto try_add_pointer(int) -> \r\n  type_identity<typename std::remove_reference<T>::type*>;\r\n  template<typename T> auto try_add_pointer(...) -> type_identity<T>;\r\n}\r\ntemplate<typename T> struct addpointer: decltype(detail::try_add_pointer<T>(0)){};\r\ntemplate<typename T> using addpointer_t = typename addpointer<T>::type;\r\nstatic_assert(std::is_same<funcptr,addpointer_t<func>>::value,\"Types differ!\\n\");\r\nusing ll=long long int;\r\nll theDp[1'000'001][3];\r\nvoid kill(){\r\n  int n;\r\n  cin>>n;\r\n  vector<int> a(n);\r\n  auto it{begin(a)};\r\n  while(it!=end(a)){\r\n    cin>>*it++;\r\n  }\r\n  int right[n];\r\n  right[n-1]=INT_MIN;\r\n  for(int i{n-2};i>=0;--i){\r\n    right[i]=max(right[i+1],a[i+1]);\r\n  }\r\n  for(int i{};i<n;++i){\r\n    auto theHighest{right[i]};\r\n    if(a[i]>theHighest){\r\n      cout<<\"0 \";\r\n    }\r\n    else{\r\n      cout<<(theHighest-a[i]+1)<<\" \";\r\n    }\r\n  }\r\n  cout<<\"\\n\";\r\n  return;\r\n}\r\n\r\nint main()\r\n{ \r\n    fast_io;\r\n    \r\n    //#ifndef ONLINE_JUDGE\r\n    //file_io;\r\n    //freopen(\"D:/cp/error.txt\", \"w+\", stderr);\r\n    //#endif\r\n#if !defined(ONEPROBLEM)\r\n    int n=1;\r\n    cin>>n;\r\n    //cin.ignore(std::numeric_limits<std::size_t>::max(),'\\n');\r\n    for(int i=0;i<n;i++){\r\n       kill();\r\n   }\r\n#elif defined(ONEPROBLEM)\r\n   kill();\r\n#endif\r\n  return 0;\r\n}"
}