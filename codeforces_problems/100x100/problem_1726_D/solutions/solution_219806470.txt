{
    "id": 219806470,
    "contestId": 1726,
    "creationTimeSeconds": 1692629246,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "D",
        "name": "Edge Split",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "probabilities",
            "trees"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "heisen__"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 5427200,
    "source": "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <bits/stdc++.h>\r\nusing namespace __gnu_pbds;\r\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\r\n#define ll long long\r\n// #define si(x)   scanf(\"%d\",&x)\r\n// #define sl(x)   scanf(\"%lld\",&x)\r\n// #define ss(s)   scanf(\"%s\",s)\r\n#define fs first\r\n#define sc second\r\n#define all(x) (x).begin(), (x).end()\r\n#define mp make_pair\r\n#define pb push_back\r\n#define sortall(x) sort(all(x))\r\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\r\n#define F(a,b,i) for(int i=a;i<b;i++)\r\n#define FN(a,b,i) for(int i=a;i>=b;i--)\r\n#define ll long long\r\n#define mp make_pair\r\n#define pb push_back\r\n#define sortall(x) sort(all(x))\r\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\r\n \r\n// typedef tree<int, null_type, less<int>, rb_tree_tag,\r\n//         tree_order_statistics_node_update > indexed_set;\r\ntypedef vector<int> vi;\r\ntypedef vector<long long>vll;\r\n// DEBUG FUNCTIONS\r\n// DEBUG FUNCTIONS\r\n#ifndef ONLINE_JUDGE\r\n \r\ntemplate<typename T>\r\nvoid __p(T a) {\r\n    cout << a;\r\n}\r\ntemplate<typename T, typename F>\r\nvoid __p(pair<T, F> a) {\r\n    cout << \"{\";\r\n    __p(a.first);\r\n    cout << \",\";\r\n    __p(a.second);\r\n    cout << \"}\";\r\n}\r\ntemplate<typename T>\r\nvoid __p(std::vector<T> a) {\r\n    cout << \"{\";\r\n    for (auto it = a.begin(); it < a.end(); it++)\r\n        __p(*it), cout << \",}\"[it + 1 == a.end()];\r\n}\r\ntemplate<typename T>\r\nvoid __p(std::set<T> a) {\r\n    cout << \"{\";\r\n    for (auto it = a.begin(); it != a.end();) {\r\n        __p(*it);\r\n        cout << \",}\"[++it == a.end()];\r\n    }\r\n \r\n}\r\ntemplate<typename T>\r\nvoid __p(std::multiset<T> a) {\r\n    cout << \"{\";\r\n    for (auto it = a.begin(); it != a.end();) {\r\n        __p(*it);\r\n        cout << \",}\"[++it == a.end()];\r\n    }\r\n}\r\ntemplate<typename T, typename F>\r\nvoid __p(std::map<T, F> a) {\r\n    cout << \"{\\n\";\r\n    for (auto it = a.begin(); it != a.end(); ++it)\r\n    {\r\n        __p(it->first);\r\n        cout << \": \";\r\n        __p(it->second);\r\n        cout << \"\\n\";\r\n    }\r\n    cout << \"}\\n\";\r\n}\r\n \r\ntemplate<typename T, typename ...Arg>\r\nvoid __p(T a1, Arg ...a) {\r\n    __p(a1);\r\n    __p(a...);\r\n}\r\ntemplate<typename Arg1>\r\nvoid __f(const char *name, Arg1 && arg1) {\r\n    cout << name << \" : \";\r\n    __p(arg1);\r\n    cout << endl;\r\n}\r\ntemplate<typename Arg1, typename ... Args>\r\nvoid __f(const char *names, Arg1 && arg1, Args && ... args) {\r\n    int bracket = 0, i = 0;\r\n    for (;; i++)\r\n        if (names[i] == ',' && bracket == 0)\r\n            break;\r\n        else if (names[i] == '(')\r\n            bracket++;\r\n        else if (names[i] == ')')\r\n            bracket--;\r\n    const char *comma = names + i;\r\n    cout.write(names, comma - names) << \" : \";\r\n    __p(arg1);\r\n    cout << \" | \";\r\n    __f(comma + 1, args...);\r\n}\r\n#define trace(...) cout<<\" \", __f(#__VA_ARGS__, __VA_ARGS__)\r\n#else\r\n#define trace(...)\r\n#define error(...)\r\n#endif\r\n \r\n \r\n//  \r\n// int gcdExtended(int a, int b, int* x, int* y)\r\n// {\r\n    // // Base Case\r\n    // if (a == 0)\r\n    // {\r\n        // *x = 0, *y = 1;\r\n        // return b;\r\n    // }\r\n//  \r\n    // // To store results of recursive call\r\n    // int x1, y1;\r\n    // int gcd = gcdExtended(b % a, a, &x1, &y1);\r\n    // // Update x and y using results of recursive\r\n    // // call\r\n    // *x = y1 - (b / a) * x1;\r\n    // *y = x1;\r\n    // return gcd;\r\n// }\r\n//  \r\n// int modInverse(int a, int m)\r\n// {\r\n    // int x, y;\r\n    // int g = gcdExtended(a, m, &x, &y);\r\n    // if (g != 1)\r\n        // // cout << \"Inverse doesn't exist\";\r\n        // return -1;\r\n    // else\r\n    // {\r\n        // // m is added to handle negative x\r\n        // int res = (x % m + m) % m;\r\n        // return res;\r\n    // }\r\n// }\r\n//  \r\n// long long  mpow(long long base, long long exp, long long  mod) {\r\n    // base %= mod;\r\n    // long long result = 1;\r\n    // while (exp > 0) {\r\n        // if (exp & 1) result = ((ll)result * base) % mod;\r\n        // base = ((ll)base * base) % mod;\r\n        // exp >>= 1;\r\n    // }\r\n    // return result % mod;\r\n// }\r\n//  \r\nll binpow(ll a, ll b) {\r\n    if (b == 0)\r\n        return 1;\r\n    long long res = binpow(a, b / 2);\r\n    if (b % 2)\r\n        return (res * res) * a ;\r\n    else\r\n        return (res * res);\r\n}\r\n//  \r\nconst int N = 1000001;\r\nll MOD=1000000007;\r\n// ll fact[N], inv[N], invfact[N];\r\n// void factInverse() {\r\n\t// fact[0] = inv[1] = fact[1] = invfact[0] = invfact[1] = 1;\r\n\t// for (long long i = 2; i < N; i++) {\r\n\t\t// fact[i] = (fact[i - 1] * i) % MOD;\r\n\t\t// inv[i] = MOD - (inv[MOD % i] * (MOD / i) % MOD);\r\n\t\t// invfact[i] = (inv[i] * invfact[i - 1]) % MOD;\r\n\t// }\r\n// }\r\n// \r\n// //  \r\n// int add(int a, int b) {\r\n\t// if ((a += b) >= MOD)\r\n\t\t// a -= MOD;\r\n\t// else if (a < 0)\r\n\t\t// a += MOD;\r\n\t// return a;\r\n// }\r\n//  \r\n// ll mul(ll x, ll y) {\r\n\t// return (1LL * x * y) % MOD;\r\n// }\r\n//  \r\n// ll nCr(ll n, ll r) {\r\n\t// if (r > n)\r\n\t\t// return 0;\r\n\t// return mul(mul(fact[n], invfact[r]), invfact[n - r]);\r\n// }\r\n\r\n// #define MAXN 3000001\r\n \r\n// int spf[MAXN];\r\n// \r\n// bool vis[200010];\r\n// ll dis[100010];\r\n// \r\n// void sieve()\r\n// {\r\n    // spf[1] = 1;\r\n    // for (int i=2; i<MAXN; i++)\r\n//  \r\n        // // marking smallest prime factor for every\r\n        // // number to be itself.\r\n        // spf[i] = i;\r\n//  \r\n    // // separately marking spf for every even\r\n    // // number as 2\r\n    // for (int i=4; i<MAXN; i+=2)\r\n        // spf[i] = 2;\r\n//  \r\n    // for (int i=3; i*i<MAXN; i++)\r\n    // {\r\n        // // checking if i is prime\r\n        // if (spf[i] == i)\r\n        // {\r\n            // // marking SPF for all numbers divisible by i\r\n            // for (int j=i*i; j<MAXN; j+=i)\r\n//  \r\n                // // marking spf[j] if it is not\r\n                // // previously marked\r\n                // if (spf[j]==j)\r\n                    // spf[j] = i;\r\n        // }\r\n    // }\r\n// }\r\n\r\n// int ran[10001];\r\n// int parent[200001];\r\n// int sz[200001];\r\n// void makesest(int n) {\r\n\t// for (int i = 1; i <= n; i++) {\r\n\t\t// parent[i] = i;\r\n\t\t// ran[i] = 0;\r\n\t\t// sz[i]=1;\r\n\t// }\r\n// }\r\n// int findpar(int v) {\r\n\t// //cout << v << \" \" << parent[v] << endl;\r\n\t// if (v == parent[v]) {\r\n\t\t// return v;\r\n\t// }\r\n\t// return parent[v]= findpar(parent[v]);\r\n// }\r\n// void un(int u, int v) {\r\n\t// u = findpar(u);\r\n\t// v = findpar(v);\r\n\t// if (ran[u] < ran[v]) {\r\n\t\t// parent[u] = v;\r\n\t// }\r\n\t// if (ran[v]< ran[u]) {\r\n\t\t// parent[v] = u;\r\n\t// }\r\n\t// if (ran[u]== ran[v]) {\r\n\t\t// parent[v]= u;\r\n\t\t// ran[u]++;\r\n\t\t// //cout << ran[u] << \" \" << parent[u] << endl;\r\n\t// }\r\n// }\r\nvector<pair<ll,ll>>adj[200010];\r\nbool vis[200010];\r\nbool mark[200010];\r\nll cn=0;\r\nvoid dfs(ll u){\r\n\t\r\n\tvis[u]=1;\r\n\t\r\n\tfor(auto v:adj[u]){\r\n\t\t\r\n\t\t\r\n\t\tif(!vis[v.fs]){\r\n\t\t\tmark[v.sc]=1;\r\n\t\t\tdfs(v.fs);\t\t\t\r\n\t\t}\t\r\n\t}\r\n}\r\n\r\n\r\nvoid dfs2(ll u){\r\n\t\r\n\tvis[u]=1;\r\n\tcn++;\r\n\t// trace(u,cn);\r\n\tfor(auto v:adj[u]){\r\n\t\t\r\n\t\t\r\n\t\tif(!vis[v.fs] && (mark[v.sc]==1)){\r\n\t\t\t// mark[v.sc]=1;\r\n\t\t\t// cn++;\r\n\t\t\tdfs2(v.fs);\t\t\t\r\n\t\t}\t\r\n\t}\r\n}\r\n\r\nint main() {\r\n\t\r\n \r\n// #ifndef ONLINE_JUDGE\r\n//  \r\n    // freopen(\"input.txt\", \"r\", stdin);\r\n    // freopen(\"output.txt\", \"w\", stdout);\r\n// #endif\r\n \r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n \t// cout.tie(0);\r\n    int t = 1 ;\r\n    cin >> t;\r\n    // sieve();\r\n    while  (t--) {\r\n    \t\r\n    \tll n,m;\r\n    \tcin>>n>>m;\r\n    \t\r\n    \tvector<pair<ll,ll>>edge(m+1);\r\n    \tF(1,m+1,i){\r\n    \t\t\r\n    \t\tvis[i]=0;\r\n    \t\tmark[i]=0;\r\n    \t\tadj[i].clear();\t\r\n    \t}\r\n    \tcn=0;\r\n    \tF(0,m,i){\r\n    \t\t\r\n    \t\tll p,q;\r\n    \t\tcin>>p>>q;\r\n    \t\t    \t\r\n    \t\tadj[p].pb(mp(q,i+1));\r\n    \t\t\r\n    \t\tadj[q].pb(mp(p,i+1));\r\n    \t\tedge[i+1]=mp(p,q);\r\n    \t}\r\n    \t\r\n    \t\r\n    \tif(m==n-1){\r\n    \t\tF(0,n-1,i){\r\n    \t\t\tcout<<1;\r\n    \t\t}\r\n    \t\tcout<<\"\\n\";continue;\r\n    \t}\r\n    \t\r\n    \tdfs(1);\r\n    \tif(m<n+2){\r\n    \t\t\r\n    \t\tF(0,m,i){\r\n    \t\t\tcout<<mark[i+1];\r\n    \t\t}\r\n    \t\tcout<<\"\\n\";    \t\t\r\n    \t\tcontinue;\r\n    \t}\r\n    \tset<ll>s;\r\n    \tvector<ll>req;\r\n    \tF(1,m+1,i){\r\n    \t\tif(mark[i]==0){\r\n    \t\t\ts.insert(edge[i].fs);\r\n    \t\t\treq.pb(i);\r\n    \t\t\ts.insert(edge[i].sc);\t\r\n    \t\t}    \t\t    \t\t\r\n    \t}\r\n    \tif(s.size()>3){\r\n    \t\tF(0,m,i){\r\n    \t\t\tcout<<mark[i+1];\r\n    \t\t}\r\n    \t\tcout<<\"\\n\";\r\n    \t\tcontinue;\r\n    \t}\r\n    \t\r\n    \tbool x=0;\r\n    \tfor(auto q:req){\r\n    \tauto u=edge[q];\r\n    \t\r\n    \tbool ok=false;\r\n    \t\r\n    \t\r\n    \tfor(auto v:adj[u.fs]){\r\n    \t\tmark[q]=1;\r\n    \t\tif(mark[v.sc]==0){\r\n    \t\t\tcontinue;\r\n    \t\t}\r\n    \t\tmark[v.sc]=0;\r\n    \t\tF(1,n+1,i){\r\n    \t\t\tvis[i]=0;\r\n    \t\t}\r\n    \t\tcn=0;\r\n    \t\tdfs2(v.fs);\r\n    \t\t\r\n    \t\tif(vis[u.sc] &&(cn==n)){\r\n    \t\t\tok=true;\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t\telse{\r\n    \t\t\tmark[q]=0;\r\n    \t\t\tmark[v.sc]=1;\r\n    \t\t}\r\n    \t\t\r\n    \t}\r\n//     \t\r\n\t    if(ok){\t   \r\n\t\t    x=1; \r\n\t    \tmark[q]=1;\r\n\t    \tbreak;\r\n    \t}\r\n//     \t\r\n    \tfor(auto v:adj[u.sc]){\r\n    \t\tmark[q]=1;\r\n    \t\tif(mark[v.sc]==0){\r\n    \t\t\tcontinue;\r\n    \t\t}\r\n    \t\tmark[v.sc]=0;\r\n    \t\tF(1,n+1,i){\r\n    \t\t\tvis[i]=0;\r\n    \t\t}\r\n    \t\tcn=0;\r\n    \t\tdfs2(v.fs);\r\n    \t\t\r\n    \t\tif(vis[u.fs] && (cn==n)){\r\n    \t\t\tok=true;\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t\telse{\r\n    \t\t\tmark[q]=0;\r\n    \t\t\tmark[v.sc]=1;\r\n    \t\t}    \t\t\r\n    \t}\r\n    \t\r\n\t    if(ok){\t   \r\n\t\t    x=1; \r\n\t    \tmark[q]=1;\r\n\t    \tbreak;\r\n    \t}\r\n    \t}\r\n    \tif(!x){\r\n    \t\tcout<<-1;\r\n    \t}\r\n    \t\r\n    \tF(0,m,i){\r\n    \t\t\tcout<<mark[i+1];\r\n    \t}\r\n    \t\r\n    \tcout<<\"\\n\";\r\n\t}\t\t\r\n}"
}