{
    "id": 198891547,
    "contestId": 1726,
    "creationTimeSeconds": 1679633424,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "D",
        "name": "Edge Split",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "probabilities",
            "trees"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "KingBarouSheroi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 77,
    "timeConsumedMillis": 1122,
    "memoryConsumedBytes": 50688000,
    "source": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define pb push_back\n#define eb eMPlace_back\n#define pyes cout << \"YES\" << '\\n'\n#define ff first\n#define ss second\n#define pno cout << \"NO\" << '\\n'\n#define int long long\n#define forn(i, n) for (int i = 0; i < int(n); i++)\nconst int MAXN = 2e5 + 20;\nconst int LMAXN = 9223372036854775807;  // the max value of long long int\nlong long MOD = 1e9 + 7;\n// ll a[MAXN], pre[MAXN];\n#define all(x) (x).begin(), (x).end()\n#define pii pair<int, int>\n#define m_p make_pair\n#define vi vector<int>\n\n#define lp(i, a, b) for (int i = a; i < b; i++)\n#define fastIO()                \\\n  ios_base::sync_with_stdio(0); \\\n  cin.tie(0);                   \\\n  cout.tie(0);\n\nusing namespace std;\n\nvoid print(int a) {\n  cout << a << '\\n';\n}\nvoid print(vector<int> &a) {\n  for(auto it : a) {\n    cout << it << ' ';\n  }\n  cout << '\\n';\n}\nvoid print(vector<vi> &a) {\n  for(auto it : a) {\n    for(auto e : it) {\n      cout << e << ' ';\n    }\n    cout << '\\n';\n  }\n}\n\ntemplate <typename T>\nvoid print1dvector(vector<T> V) {\n  for (auto it : V) {\n    cout << it << ' ';\n  }\n  cout << '\\n';\n}\n\ntemplate <typename T>\nvoid print2dvector(vector<vector<T>> V) {\n  for (auto it : V) {\n    for (auto itr : it) {\n      cout << itr << ' ';\n    }\n    cout << '\\n';\n  }\n}\n\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    // http://xorshift.di.unimi.it/splitmix64.c\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\n\ntemplate <std::size_t MAXN>  // change the value of bitest to any size (say nax)\n                             // that you need to assign\n                             bool operator<(const std::bitset<MAXN>& x,\n                                            const std::bitset<MAXN>& y) {\n  for (int i = MAXN - 1; i >= 0; i--) {\n    if (x[i] ^ y[i]) return y[i];\n  }\n  return false;\n}\n\nvoid makeUniq(vector<int>& vec) {\n  sort(all(vec));\n  vec.resize(unique(all(vec)) - vec.begin());\n}\n\nint binaryStrToDecimal(string b) { return stol(b, nullptr, 2); }\n\nint nxt() {\n  int x;\n  cin >> x;\n  return x;\n}\n\nint Sqrt(int n) {\n  int l = 1, r = n, ans = n;\n  while (r >= l) {\n    int mid = (l + r) / 2;\n    if (mid > n / mid)\n      r = mid - 1;\n    else {\n      ans = mid;\n      l = mid + 1;\n    }\n  }\n  return ans;\n}\n\nbool isPerfectSquare(int n) {\n  int x = Sqrt(n);\n  return x * x == n;\n}\n\nll accurateFloor(ll a, ll b) {  // gives the accurate floor for -ve/+ve\n  ll val = a / b;\n  while (val * b > a) val--;\n  return val;\n}\n\nll GCD(ll a, ll b) { return (a) ? GCD(b % a, a) : b; }\n\nll LCM(ll a, ll b) { return a * b / GCD(a, b); }\n\nbool isPowerOf2(ll n) { return (ceil(log2(n)) == floor(log2(n))); }\n/*\n unsigned int hibit(unsigned int x) { // return the position of highest set\n bit\n  if(x == 0) {\n    return 0;\n  } else {\n    return (32 - (__builtin_clz(x | 1)));\n  }\n}\n*/\nll fastpow(ll b, ll p) {\n  if (!p) return 1;\n  ll ret = fastpow(b, p >> 1);\n  ret *= ret;\n  if (p & 1) ret *= b;\n  return ret;\n}\nint powermodulo(int a, int p, int m) {\n  int ans = 1;\n  a = a % m;\n  while (p > 0) {\n    if (p & 1) ans *= a;\n    ans = ans % m;\n    a = (a * a) % m;\n    p = p >> 1;\n  }\n  return ans;\n}\nint inverse(int a, int p = MOD) { return (powermodulo(a, p - 2, p)) % p; }\nstruct DSU {\n  vector<int> e;\n  DSU(int N) { e = vector<int>(N, -1); }\n  // get representive component (uses path compression)\n  int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\n  bool same_set(int a, int b) { return get(a) == get(b); }\n  int size(int x) { return -e[get(x)]; }\n  bool unite(int x, int y) {  // union by size\n    x = get(x), y = get(y);\n    if (x == y) return false;\n    if (e[x] > e[y]) swap(x, y);\n    e[x] += e[y];\n    e[y] = x;\n    return true;\n  }\n};\nvector<int> fact;\nvoid pre_calc_fact() {\n  fact = vector<int>(1001);\n  fact[0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    fact[i] = ((fact[i - 1] % MOD) * i) % MOD;\n  }\n}\n\nint combination(int n, int r) {\n  return ((fact[n] % MOD * inverse(fact[r]) % MOD) % MOD *\n          inverse(fact[n - r]) % MOD);\n}\n\nint mod_add(int a, int b) {\n    return (a+b)%MOD;\n}\nint mod_sub(int a, int b) {\n    return (a-b+MOD)%MOD;\n}\nint mod_mult(int a, int b) {\n    return (a*b)%MOD;\n}\nint mod_div(int a, int b) {\n    return (mod_mult(a , inverse(b)));\n}\n\nstruct fTree {\n  vector<int> bit;  // binary indexed tree\n  int n;\n\n  fTree(int n) {\n    this->n = n + 1;\n    bit.assign(n + 1, 0);\n  }\n\n  fTree(vector<int> a) : fTree(a.size()) {\n    for (size_t i = 0; i < a.size(); i++) add(i, a[i]);\n  }\n\n  int sum(int idx) {\n    int ret = 0;\n    for (++idx; idx > 0; idx -= idx & -idx) ret += bit[idx];\n    return ret;\n  }\n\n  int sum(int l, int r) { return sum(r) - sum(l - 1); }\n\n  void add(int idx, int delta) {\n    for (++idx; idx < n; idx += idx & -idx) bit[idx] += delta;\n  }\n  void setX(int indx, int x) { add(indx, x - sum(indx, indx)); }\n};\n\nstring e = \"%%%%%%%%%%%%%%%%%\\n\";\nvoid solve() {\n    int n,m;\n    cin>>n>>m;\n    vector<int> adj[n];\n    vi h(n, 0);\n    vector<pii> edges;\n    vi p(n, -1);\n    set<pii> te;\n    vector<pii> pe;\n    vector<bool> seen(n, false);\n    for(int i=0;i<m;i++) {\n        int u,v;cin>>u>>v;--u;--v;adj[u].pb(v);adj[v].pb(u);\n        edges.pb(u>v?m_p(v,u):m_p(u,v));\n        //te.insert(u>v?m_p(v,u):m_p(u,v));\n    }\n    function<void(int)> dfs = [&](int i) {\n        seen[i] = true;\n        for(auto child : adj[i]) {\n            if(!seen[child]) {\n                p[child] = i;\n                pe.pb(child>i?m_p(i,child):m_p(child,i));\n                h[child] = h[i] + 1;\n                dfs(child);\n            }\n        }\n    };\n    dfs(0);\n    //for(int i=0;i<m;i++) {\n        //pii e=edges[i];\n        //if(pe.find(e) == pe.end()) {\n            //np.pb(e);\n        //}\n    //}\n    vector<pii> D1,D2;\n    D1=edges;\n    D2=pe;\n    vector<pii> np;\n    sort(all(D1));\n    sort(all(D2));\n    set_symmetric_difference(all(D1), all(D2), back_inserter(np));\n    vector<int> fans(m, 0);\n    for(int i=0;i<m;i++) {\n        pii e=edges[i];\n        for(auto it : np) {\n            if(e==it) {\n                fans[i] = 1;\n            }\n        }\n    }\n    if(np.size() == 3) {\n        set<int> S;\n        S.insert(np[0].first);S.insert(np[0].second);\n        S.insert(np[1].first);S.insert(np[1].second);\n        S.insert(np[2].first);S.insert(np[2].second);\n        if(S.size() == 3) {\n            vector<int> vv;for(auto it:S) vv.pb(it);\n            sort(all(vv), [&](int a,int b) {\n                return h[a] > h[b];\n                });\n            int d=vv[0];int h=vv[2];\n            int pp=p[d];\n            pii p1=(d>h?m_p(h,d):m_p(d,h));\n            pii p2=(pp>d?m_p(d,pp):m_p(pp,d));\n            for(int i=0;i<m;i++){\n                if(edges[i] == p1) {\n                    fans[i] = 0;\n                }\n                if(edges[i] == p2) {\n                    fans[i] = 1;\n                }\n            }\n        }\n    }\n\n    for(auto it:fans){\n        cout<<it;\n    }cout<<\"\\n\";\n}\n\nsigned main() {\n  fastIO();\n  int t = nxt();\n  // int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n\n/*\n    NO NEED TO CODE WITHOUT A COMPLETE ALGORITHM!!!\n    THINK OF WHAT THE PROBLEM DEMANDS!!!\n */\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n\n/*\n ll fastpow(ll b, ll p) {\n  if (!p) return 1;\n  ll ret = fastpow(b, p >> 1);\n  ret = ((ret%MOD) * (ret%MOD));\n  if (p & 1) ret = ((ret%MOD) * (b%MOD));\n  return ret%MOD;\n}\n*/\n/* \"double precision\" cout << fixed << std:setprecision(10) << '\\n' */\n/* min heap \"priority_queue<int, vector<int> , greater<int>>\" */\n/*\n  1. Understanding the problem.\n  2. Using past problems.\n  3. Using known ideas and algorithms\n  4. Observations Reductions RandomIdeas AnswerBounds SiMPlerProblems\n */\n//\n"
}