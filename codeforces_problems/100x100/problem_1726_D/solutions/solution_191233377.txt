{
    "id": 191233377,
    "contestId": 1726,
    "creationTimeSeconds": 1675073179,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "D",
        "name": "Edge Split",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "probabilities",
            "trees"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "namang01"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 77,
    "timeConsumedMillis": 592,
    "memoryConsumedBytes": 101171200,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define FAST ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define endl \"\\n\";\r\n#define PI 3.1415926535\r\n\r\n#define pb push_back\r\n#define f first\r\n#define s second\r\n#define rep(i,n) for(ll i=0;i<n;i++)\r\n#define SORT(v)  sort(v.begin(), v.end())\r\n#define SORTR(v) sort(v.rbegin(), v.rend())\r\n#define MAX(v) *max_element(v.begin(), v.end())\r\n#define MIN(v) *min_element(v.begin(), v.end())\r\n#define all(v) (v).begin(),(v).end()\r\n#define forn(i,n) for(int i=0;i<(n);i++)\r\ntypedef long long ll;\r\n// #define int long long int\r\nconst ll N = 400005;\r\nconst ll mod = 1e9 + 7;\r\nconst ll MAXX = 1e6 + 5;\r\nconst ll nn=1e5 + 1;\r\nconst ll inf = (1LL<<63 -1) + (1LL<<62 -1);\r\n\r\nvoid findDivisors(int n);   //!!Make div array public!! - 1 to n array\r\n// vector<ll> sieve(ll n);    //!!Make vi and array public!! - List of primes/Bool array to check prime\r\nll mpow(ll base, ll exp);    //modular exponentialtion, md = 1e9+7 default\r\nll gcd(ll a, ll b);\r\nint lcm(int a, int b);\r\nint ncr(int n, int r);\r\nint highestPowerOf2(int n);    //Highest power of 2 that divides n\r\nll cnt_digit(ll number);   //Number of digits present in a number\r\nint sum_digit(int n);             //Sum of digits\r\nint sum_digit(string str);        //in a number\r\nstring dec2bin(int n);\r\nll BinExpRecur(ll a,ll b);\r\nll BinExpIter(ll a,ll b);\r\n\r\nll XOR(ll x, ll y){\r\n   return (x | y) & (~x | ~y);\r\n}\r\n// bool comp(vector<int> &a, vector<int> &b){\r\n//     return a[1] < b[1];\r\n// }\r\nbool cmp(const pair<pair<ll,ll>,ll> &a,const pair<pair<ll,ll>,ll> &b) {\r\n\tif((a.first.first > b.first.first)){\r\n\t\treturn true;\r\n\t}\r\n\telse if((a.first.first == b.first.first)){\r\n\t\tif(a.first.second < b.first.second){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\telse{\r\n\t\treturn false;\r\n\t}\r\n\t// return ((a.first.first > b.first.first) and (a.first.second > b.first.second));\r\n}\r\nbool com(const pair<ll,ll> &a, const pair<ll,ll> &b){\r\n\tif(a.first!=b.first) return a.first < b.first;\r\n\telse return a.second > b.second;\r\n}\r\n\r\n/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\t\t\t\t\t\t\t\tDON'T MAKE CHANGES BEFORE THIS LINE!\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\r\nll binaryToDecimal(string n){\r\n\tstring num = n;\r\n\tll dec_value = 0;\r\n \r\n\t// Initializing base value to 1, i.e 2^0\r\n\tll base = 1;\r\n\tll len = num.length();\r\n\tfor (ll i = len - 1; i >= 0; i--) {\r\n\t\tif (num[i] == '1')\r\n\t\t\tdec_value += base;\r\n\t\tbase = base * 2;\r\n\t}\r\n \r\n\treturn dec_value;\r\n}\r\nstring decimalToBinary(ll n){\r\n\tstring s = bitset<64> (n).to_string();\r\n\tconst auto loc1 = s.find('1');\r\n\tif(loc1 != string::npos)\r\n\t\treturn s.substr(loc1);\r\n\treturn \"0\";\r\n}\r\n\r\n\r\nll fact(ll n){\r\n\t\r\n\tif(n == 0){\r\n\t\treturn 1;\r\n\t}\r\n\tll res = 1;\r\n\tfor (ll i = 2; i <= n; i++){\r\n\t\tres = res * i;\r\n\t\tres%=mod;\r\n\t}\r\n\tres%=mod;\r\n\treturn res;\r\n}\r\nll biexp(ll a, ll b){\r\n  ll res=1;\r\n  while(b>0)\r\n  {\r\n    if(b%2) res=(res)*(a);\r\n    b=b/2;\r\n    a=(a*a);\r\n  }\r\n  return res;\r\n}\r\n// ll nCr(ll n, ll r)\r\n// {    \r\n//  ll flag=0;\r\n//  if(r>=(n-r)){\r\n//      ll prod=1;\r\n//      for(ll i=r+1;i<=n;i++){\r\n//          prod*=i;\r\n//          if(prod%fact(n - r) ==0 and flag==0){\r\n//              prod/=(fact(n - r));\r\n//              flag=1;\r\n//          }\r\n//      }\r\n//      if(flag==1){\r\n//          return prod;\r\n//      }\r\n//      else{\r\n//          return prod / fact(n - r);\r\n//      }\r\n//  }\r\n\r\ninline ll store_primes(ll n,vector<ll> &a)\r\n{\r\n    ll t=0;\r\n    vector<bool> s(n+1,1);\r\n    for(int i=2;i<=n;i++)\r\n    {\r\n        if(s[i])\r\n        {\r\n            t++;\r\n            a.emplace_back(i);\r\n            for(int j=2;i*j<=n;j++)\r\n            {\r\n                s[i*j]=0;\r\n            }\r\n        }\r\n    }\r\n    return t;\r\n}\r\ninline ll no_of_primes(ll n)\r\n{\r\n    ll t=0;\r\n    vector<bool> s(n+1,1);\r\n    for(int i=2;i<=n;i++)\r\n    {\r\n        if(s[i])\r\n        {\r\n            t++;\r\n            for(int j=2;i*j<=n;j++)\r\n            {\r\n                s[i*j]=0;\r\n            }\r\n        }\r\n    }\r\n    return t;\r\n}\r\ninline void print_primes(ll n){\r\n    vector<bool> s(n+1,1);\r\n    for(int i=2;i<=n;i++)\r\n    {\r\n        if(s[i])\r\n        {\r\n            cout<<i<<\" \";\r\n            for(int j=2;i*j<=n;j++)\r\n            {\r\n                s[i*j]=0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// vector<ll> edges[500005];\r\n// bool vis[500005];\r\n// ll a[N+10];\r\n\r\n\r\n// ll dfs(ll v) {\r\n// \tll mn = c[v];\r\n// \tvis[v] = 1;\r\n\t\r\n// \tfor (ll x: edges[v]) {\r\n// \t\tif (!vis[x]) {\r\n// \t\t\tmn = min(mn, dfs(x));\r\n// \t\t}\r\n// \t}\r\n// \treturn mn;\r\n// }\r\n//  else{\r\n//      ll prod=1;\r\n//      for(ll i=n-r+1;i<=n;i++){\r\n//          prod*=i;\r\n//          if(prod%fact(r) ==0 and flag==0){\r\n//              prod/=(fact(r));\r\n//              flag=1;\r\n//          }\r\n//      }\r\n//      if(flag==1){\r\n//          return prod;\r\n//      }\r\n//      else{\r\n//          return prod / fact(r);\r\n//      }\r\n//  }\r\n   \r\n// }\r\n\r\n// ll findXOR(ll n){\r\n//     ll modd = n % 4;\r\n\r\n//     if (modd == 0)\r\n//         return n;\r\n\r\n//     else if (modd == 1)\r\n//         return 1;\r\n\r\n//     else if (modd == 2)\r\n//         return n + 1;\r\n\r\n//     else if (modd == 3)\r\n//         return 0;\r\n// }\r\n\r\nll binarySearch(ll arr[], ll l, ll r, ll x){\r\n\tif (r >= l) {\r\n\t\t// middle = (start + end) / 2. But this has a good \r\n\t\t// chance of producing an integer overflow so it\u2019s\r\n\t\t// recommended  that you represent the middle as:\r\n\t\t// middle = start + (end - start) / 2.\r\n\t\t\r\n\t\tll mid = l + (r - l) / 2;\r\n\t\tif (arr[mid] == x)\r\n\t\t\treturn mid;\r\n\t\tif (arr[mid] > x)\r\n\t\t\treturn binarySearch(arr, l, mid - 1, x);\r\n\t\treturn binarySearch(arr, mid + 1, r, x);\r\n\t}\r\n\treturn -1;\r\n}\r\n// void sieve()\r\n// {\r\n//     int k=sqrt(N-2);\r\n//     for(int i=1;i<=N-2;++i)\r\n//         prime[i]=true;\r\n//     for(int i=2;i<=k;++i)\r\n//     {\r\n//         if(prime[i])\r\n//         {\r\n//             for(int k=i*i;k<=N-2;k+=i)\r\n//             {\r\n//                 prime[k]=false;\r\n//                 pf[k]=i;\r\n//             }\r\n//         }\r\n//     }\r\n//     for(int i = 2; i < N; i++) if(prime[i]) pr.push_back(i);\r\n// }\r\n\r\nll bs(vector<ll> &arr, ll e)   // binary search\r\n{\r\n\tll start = 0, mid, end = arr.size() - 1;\r\n\twhile (start <= end) {\r\n\t\tmid = start + (end - start) / 2;\r\n\t\tif (arr[mid] == e)\r\n\t\t\treturn mid;\r\n\t\tif (e > arr[mid])\r\n\t\t\tstart = mid + 1;\r\n\t\telse\r\n\t\t\tend = mid - 1;\r\n\t}\r\n\treturn -1;\r\n}\r\n// ll a[N];\r\n\r\n// vector<ll> adj[100001];\r\n// ll depth[100001];\r\n// bool vis[100001];\r\n// set<ll>ts;\r\n\r\n// Do Not use power when calculating powers of 2 (its inefficient)\r\n// ASCII code: 0-9 >> 48-57;    A-Z>>65-90   and   a-z>>97-122 respectively;\r\n\r\n// vector<vector<ll>>v(100005);\r\n// ll dp[3][100005];\r\n// ll l[100005], r[100005];\r\n// void ans(ll x, ll par){\r\n//     dp[1][x] = 0;\r\n//     dp[2][x] = 0;\r\n//     for(auto y : v[x]){\r\n//         if(y==par) continue;\r\n//         ans(y,x);\r\n//         dp[1][x] += max(dp[1][y] + abs(l[x]-l[y]) , dp[2][y] + abs(l[x] - r[y]));\r\n//         dp[2][x] += max(dp[1][y] + abs(r[x] - l[y]), dp[2][y] + abs(r[x] - r[y]));\r\n//     }\r\n// }\r\nll t[3001][3000+1];\r\n// ll knapsack(ll wt[],ll val[],ll w,ll n){\r\n// \tif(n==0 or w==0){\r\n// \t\treturn 0;\r\n// \t}\r\n// \tif(t[n][w] != -1){\r\n// \t\treturn t[n][w];\r\n// \t}\r\n// \tif(wt[n-1] <= w){\r\n// \t\treturn t[n][w] = max(val[n-1] + knapsack(wt,val,w-wt[n-1],n-1), knapsack(wt,val,w,n-1));\t\r\n// \t}\r\n// \telse if(wt[n-1] > w){\r\n// \t\treturn t[n][w] = knapsack(wt,val,w,n-1);\r\n// \t}\r\n// \treturn 0;\r\n// }\r\n// ll LCS(string x,string y,ll m,ll n){\r\n// \tif(n==0 or m==0){\r\n// \t\treturn 0;\r\n// \t}\r\n// \tif(t[m][n] != -1){\r\n// \t\treturn t[m][n];\r\n// \t}\r\n// \tif(x[m-1] == y[n-1]){\r\n// \t\treturn t[m][n] = 1+ LCS(x,y,m-1,n-1);\r\n// \t}\r\n// \telse{\r\n// \t\treturn t[m][n] = max(LCS(x,y,m,n-1),LCS(x,y,m-1,n));\r\n// \t}\r\n// }\r\n\r\nint T, n, m;\r\nint x[N], y[N], dep[N], rp[N], col[N];\r\nvector<int> e[N], rs;\r\nvoid dfs(int u, int fa, int rfa)\r\n{\r\n\tdep[u]=dep[rfa]+1;\r\n\t// printf(\"in %d %d\\n\", u, dep[u]);\r\n\tfor(int i:e[u]) if(i!=fa)\r\n\t{\r\n\t\tint v=u^x[i]^y[i];\r\n\t\tif(dep[v])\r\n\t\t{\r\n\t\t\tif(dep[v]<dep[u])\r\n\t\t\t{\r\n\t\t\t\trp[i]=fa;\r\n\t\t\t\t// printf(\"now %d\\n\", i);\r\n\t\t\t\trs.pb(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse dfs(v, i, u);\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tscanf(\"%d\", &T);\r\n\twhile(T--)\r\n\t{\r\n\t\tscanf(\"%d%d\", &n, &m);\r\n\t\tfor(int i=1; i<=n; ++i) e[i].clear(), dep[i]=0;\r\n\t\tfor(int i=1; i<=m; ++i)\r\n\t\t{\r\n\t\t\tscanf(\"%d%d\", x+i, y+i), col[i]=0;\r\n\t\t\te[x[i]].pb(i), e[y[i]].pb(i);\r\n\t\t}\r\n\t\trs.clear();\r\n\t\tdfs(1, 0, 0);\r\n\t\tif(rs.size()==3)\r\n\t\t{\r\n\t\t\tfor(int a:rs)\r\n\t\t\t{\r\n\t\t\t\tint ok0=0, ok1=0;\r\n\t\t\t\tfor(int b:rs) if(a!=b)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(x[a]==x[b]||x[a]==y[b]) ok0=1;\r\n\t\t\t\t\tif(y[a]==x[b]||y[a]==y[b]) ok1=1;\r\n\t\t\t\t}\r\n\t\t\t\tif(!ok0||!ok1) goto out;\r\n\t\t\t}\r\n\t\t\trs[2]=rp[rs[2]];\r\n\t\t\tout:;\r\n\t\t}\r\n\t\tfor(int x:rs) col[x]=1;\r\n\t\tfor(int i=1; i<=m; ++i) putchar('0'+col[i]);\r\n\t\tputs(\"\");\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\t\t\t\t\t\t\t\tDON'T MAKE CHANGES AFTER THIS LINE!\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/   \r\n\r\n// ll BinExponentiationIter(ll a,ll b){\r\n//  ll ans=1;\r\n//  while(b){\r\n//      if(b&1){\r\n//          ans=ans*a;\r\n//      }\r\n//      a=a*a;\r\n//      b>>=1;\r\n//  }\r\n//  return ans;\r\n// }\r\n\r\n// ll BinExponentiationRecur(ll a,ll b){\r\n//  if(b==0) return 1;\r\n//  ll res = BinExpRecur(a,b/2);\r\n//  if(b&1){\r\n//      return a*res*res;\r\n//  }\r\n//  else{\r\n//      return res*res;\r\n//  }\r\n// }\r\n\r\n\r\nvoid findDivisors(int n)\r\n{\r\n\tint div[N];                   //HERE!!\r\n\tmemset(div, 0, sizeof div);\r\n\tfor(int i = 1; i <= n; i++)\r\n\t{\r\n\t\tfor(int j = 1; j * i <= n; j++)\r\n\t\t\tdiv[i * j]++;\r\n\t}\r\n}\r\n\t\r\n//  vector<ll>  sieve(ll n)   //O(nlog(logn))\r\n// {\r\n// \tvector<ll> primes;     //HERE!!\r\n// \tbool iscomp[N];          //HERE!!\r\n// \tfor(ll i = 2; i <= n; ++i)\r\n// \t{\r\n// \t\tif(!iscomp[i])\r\n// \t\t\tprimes.push_back(i);\r\n// \t\tfor(ll j = 0; j < primes.size() && i * primes[j] <= n; ++j)\r\n// \t\t{\r\n// \t\t\tiscomp[i * primes[j]] = true;\r\n// \t\t\tif(i % primes[j] == 0)\r\n// \t\t\t\tbreak;\r\n// \t\t}\r\n// \t}\r\n// \treturn primes;\r\n// }\r\n\t\r\nll mpow(ll base, ll exp)\r\n{\r\n\tll result = 1;\r\n\t// base %= md;\r\n\t\r\n\tif(base==0) return 0;\r\n\t\r\n\twhile(exp>0)\r\n\t{\r\n\t\tif(exp&1)\r\n\t\t\tresult = (result*base);\r\n\t\tbase = (base*base);\r\n\t\texp>>=1;\r\n\t}\r\n\treturn result;\r\n}\r\n\t\r\nll gcd(ll a, ll b) // Time Complexity: O(log(max(a,b))) or use (__gcd(a,b) function in C++ STL)\r\n{\r\n\tif(b==0)    return a;\r\n\treturn gcd(b, a%b);\r\n}\r\n\t\r\nint lcm(int a, int b)// Time Complexity: O(log(max(a,b)))\r\n{\r\n\treturn a*(b/gcd(a,b));\r\n}\r\n\t\r\nint ncr(int n,int r)\r\n{\r\n\tvector<int> fac(N),inv(N);\r\n\treturn fac[n] * (inv[r] * inv[n-r] % mod) % mod;\r\n\treturn fac[n] * (mpow(fac[r],mod-2) * mpow(fac[n-r],mod-2) % mod ) % mod;\r\n}\r\n\t\r\nint highestPowerOf2(int n)\r\n{\r\n\treturn (n & (~(n - 1)));\r\n}\r\n\t\r\nll cnt_digit(ll number)\r\n{\r\n\treturn int32_t(log10(number) + 1);\r\n}\r\n\t\r\nint sum_digit(int n)\r\n{\r\n\tint sum = 0;\r\n\twhile (n != 0)\r\n\t{\r\n\t\tsum = sum + n % 10;\r\n\t\tn = n / 10;\r\n\t}\r\n\treturn sum;\r\n}\r\n\t\r\nint sum_digit(string str)\r\n{\r\n\tint sum = 0;\r\n\tfor (int i = 0; i < str.length(); i++)\r\n\t{\r\n\t\tsum = sum + str[i] - 48;\r\n\t}\r\n\treturn sum;\r\n}\r\n\t\r\nstring dec2bin(int n)\r\n{\r\n\tconst int size=sizeof(n)*8;\r\n\tstring s = \"00000000000000000000000000000000\";\r\n\tfor (int a=0;a<32;a++)\r\n\t{\r\n\t\tif(n==0)\r\n\t\t\treturn s;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(n%2!=0)\r\n\t\t\t\ts[31-a]='1';\r\n\t\t\tn/=2;\r\n\t\t}\r\n\t}\r\n\treturn s;\r\n}"
}