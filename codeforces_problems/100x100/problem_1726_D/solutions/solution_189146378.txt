{
    "id": 189146378,
    "contestId": 1726,
    "creationTimeSeconds": 1673640477,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "D",
        "name": "Edge Split",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "probabilities",
            "trees"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "NotImplemented"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 77,
    "timeConsumedMillis": 1980,
    "memoryConsumedBytes": 51200000,
    "source": "#include <iterator>\n#include <numeric>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\n\n \nusing namespace std;\n \n \ntemplate<class T>\nvoid read(std::vector<T>& vt)\n{\n    for(int i = 0; i < vt.size(); ++i)\n    {\n        std::cin >> vt[i];\n    }\n}\n \n \ntemplate<class T, class U>\nvoid read(std::vector<pair<T, U>>& vt)\n{\n    for(int i = 0; i < vt.size(); ++i)\n    {\n        std::cin >> vt[i].first >> vt[i].second;\n    }\n}\n \n \ntemplate<class T>\nvoid dump(const std::vector<T>& vt)\n{\n    for(int i = 0; i < vt.size(); ++i)\n    {\n        if (i > 0)\n            std::cout << ' ';\n        \n        std::cout << vt[i];\n    }\n    \n    std::cout << std::endl;\n}\n \ntemplate<class T>\nvoid dump(const std::vector<std::vector<T>>& vt)\n{\n    for(int i = 0; i < vt.size(); ++i)\n    {\n        dump(vt[i]);\n    }\n}\n \n \ntemplate<class T, class U>\nvoid dump(const std::vector<std::pair<T, U>>& vt)\n{\n    for(int i = 0; i < vt.size(); ++i)\n    {\n        if (i > 0)\n            std::cout << ' ';\n        \n        std::cout << \"(\" << vt[i].first << \", \" << vt[i].second << \")\";\n    }\n    \n    std::cout << std::endl;\n}\n\ntemplate<class T, class U>\nvoid dump(const std::map<T, U>& mp)\n{\n    for(auto it: mp)\n    {\n        std::cout << it.first << \": \" << it.second << endl;\n    }\n    \n    std::cout << std::endl;\n}\n\n \ntemplate<class T, class U>\nvoid dump(const std::unordered_map<T, U>& mp)\n{\n    for(auto it: mp)\n    {\n        std::cout << it.first << \": \" << it.second << endl;\n    }\n    \n    std::cout << std::endl;\n}\n \n \nconst long long Mod = 998244353;\n \n \nint power(long long a, int n, const int modulo = Mod)\n{\n    long long res = 1;\n    \n    while(n)\n    {\n        if (n & 1)\n        {\n            --n;\n            res *= a;\n            res %= Mod;\n        }\n        else\n        {\n            a *= a;\n            a %= Mod;\n            \n            n >>= 1;\n        }\n    }\n    \n    return res;\n}\n\n\nint inverse(int n, const int modulo = Mod)\n{\n    return power(n, modulo-2, modulo);\n}\n\n\nvector<int> factorial_cache(1, 1);\nvector<int> factorial_inverse_cache(1, 1);\n\nint factorial(int n, const int modulo = Mod)\n{\n    if (factorial_cache.size() <= n)\n    {\n        for(int t = (int)factorial_cache.size(); t <= n; ++t)\n        {\n            factorial_cache.push_back((long long)t * factorial_cache.back() % modulo);\n        }\n    }\n    \n    return factorial_cache[n];\n}\n\n\nint inverse_factorial(int n, const int modulo = Mod)\n{\n    if (factorial_inverse_cache.size() <= n)\n    {\n        for(int t = (int)factorial_inverse_cache.size(); t <= n; ++t)\n        {\n            factorial_inverse_cache.push_back(power(factorial(t), modulo-2, modulo));\n        }\n    }\n\n    return factorial_inverse_cache[n];\n}\n\n\nint binomial(int k, int n, const int modulo = Mod)\n{\n    if (k < 0 || n < 0 || k > n)\n    {\n        return 0;\n    }\n    \n    long long res = factorial(n);\n    \n    res *= inverse_factorial(k);\n    res %= modulo;\n\n    res *= inverse_factorial(n-k);\n    res %= modulo;\n    \n    return (int)res;\n}\n\n\nint choose_with_repetitions(int k, int n, const int modulo = Mod)\n{\n    return binomial(k, n + k - 1);\n}\n\n\nstruct SegmentTree\n{\n    int n;\n    std::vector<int> data;\n    \n    SegmentTree(const std::vector<int>& values): data(4 * values.size()), n((int)values.size())\n    {\n        build(values, 1, 0, n-1);\n    }\n    \n    void build(const std::vector<int>& values, int v, int left, int right)\n    {\n        if (left == right)\n        {\n            data[v] = values[left];\n        }\n        else\n        {\n            int middle = (left + right) / 2;\n            \n            build(values, v*2, left, middle);\n            build(values, v*2+1, middle+1, right);\n            data[v] = data[v*2] + data[v*2+1];\n        }\n    }\n    \n    int op_sum(const int& a, const int& b)\n    {\n        return a + b;\n    }\n\n    int op(const int& a, const int& b)\n    {\n        return max(a, b);\n    }\n\n    int get_value(int v, int left, int right, int l, int r)\n    {\n        if (l > r)\n            return 0;\n        \n        if (l == left && r == right)\n        {\n            return data[v];\n        }\n        \n        int middle = (left + right) / 2;\n        \n        return op(get_value(v*2, left, middle, l, min(r, middle)), get_value(v*2+1, middle+1, right, max(l, middle+1), r));\n    }\n    \n    void update(int v, int left, int right, int pos, int new_value)\n    {\n        if (left == right)\n        {\n            data[v] = new_value;\n        }\n        else\n        {\n            int middle = (left + right) / 2;\n            if (pos <= middle)\n                update(v*2, left, middle, pos, new_value);\n            else\n                update(v*2+1, middle+1, right, pos, new_value);\n            \n            data[v] = op(data[v*2], data[v*2+1]);\n        }\n    }\n};\n \n \nvector<int> z_function(const vector<int>& s) {\n    \n    const int n = (int)s.size();\n    vector<int> z(n);\n    \n    for (int i = 1, l = 0, r = 0; i < n; ++i)\n    {\n        if (i <= r)\n        {\n            z[i] = min (r - i + 1, z[i - l]);\n        }\n        \n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n        {\n            ++z[i];\n        }\n        \n        if (i + z[i] - 1 > r)\n        {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\n\nlong long gcd(long long a, long long b)\n{\n    if (a > b)\n        return gcd(b, a);\n    \n    if (!a)\n        return b;\n    \n    return gcd(b % a, a);\n}\n\n\nlong long lcm(long long a, long long b)\n{\n    return a / gcd(a, b) * b;\n}\n\n\nbool same(vector<int> vt)\n{\n    sort(vt.begin(), vt.end());\n    \n    for(int i = 0; i + 1 < vt.size(); ++i)\n    {\n        if (vt[i] != vt[i+1])\n            return false;\n    }\n    \n    return true;\n}\n \n \ntemplate<class T>\nT mex(const vector<T>& vt)\n{\n    unordered_set<T> st(vt.begin(), vt.end());\n    \n    for(T t = T(); ; ++t)\n    {\n        if (st.count(t) == 0)\n            return t;\n    }\n    \n    return T();\n}\n\n\nint get_parent(int i, vector<int>& parent)\n{\n    if (parent[i] == -1 || parent[i] == i)\n        return parent[i] = i;\n    \n    int res = get_parent(parent[i], parent);\n    \n    return parent[i] = res;\n}\n\n\nvoid decrease(map<int, int>& mp, int key)\n{\n    mp[key]--;\n    if (mp[key] == 0)\n        mp.erase(key);\n}\n\nclass SqrtDecomposition\n{\n    int n;\n    int total_buckets;\n    int sz;\n    \n    std::vector<int> data;\n    std::vector<int> buckets;\n    std::vector<int> best;\n    \npublic:\n    SqrtDecomposition(int n)\n    {\n        this->n = n;\n        sz = max<int>(1, sqrt(n));\n        \n        total_buckets = (n + sz - 1) / sz;\n        \n        data.assign(n, 0);\n        buckets.assign(total_buckets, 0);\n        \n        for(int i = 0; i < total_buckets; ++i)\n        {\n            best.push_back(i * sz);\n        }\n    }\n    \npublic:\n    pair<int, int> get(int l, int r)\n    {\n        int res = INT_MIN, pos = -1;\n        \n        const int a = l / sz;\n        const int b = r / sz;\n        \n        for(int i = l; i < min(r+1, (a + 1) * sz); ++i)\n        {\n            if (data[i] > res)\n            {\n                res = data[i];\n                pos = i;\n            }\n        }\n\n        for(int i = r; i >= max(l, b * sz); --i)\n        {\n            if (data[i] > res)\n            {\n                res = data[i];\n                pos = i;\n            }\n        }\n        \n        for(int i = a + 1; i < b; ++i)\n        {\n            //cout << \"!!!\";\n            if (buckets[i] > res)\n            {\n                res = buckets[i];\n                pos = best[i];\n            }\n        }\n\n        return pair(res, pos);\n    }\n    \n    void update(int i, int x)\n    {\n        if (data[i] < x)\n            data[i] = x;\n        \n        const int b = i / sz;\n        if (x > buckets[b])\n        {\n            buckets[b] = x;\n            best[b] = i;\n        }\n    }\n};\n\n\nmap<int, int> factorize(int n)\n{\n    map<int, int> res;\n    \n    for(int i = 2; i*i <= n; ++i)\n    {\n        while(n % i == 0)\n        {\n            res[i]++;\n            n /= i;\n        }\n    }\n    \n    if (n > 1)\n        res[n]++;\n    \n    return res;\n}\n\n\nvoid solve_case(int case_)\n{\n    int n;\n    cin >> n;\n\n    int m;\n    cin >> m;\n    \n    //vector<pair<int, int>> edges(m);\n    \n    map<pair<int,int>, int> edge_to_id;\n    unordered_map<int, vector<int>> adj;\n\n    for(int i = 0; i < m; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        \n        if (a > b)\n            swap(a, b);\n        \n        //edges[i] = pair(a-1, b-1);\n        edge_to_id[pair(a-1, b-1)] = i;\n        edge_to_id[pair(b-1, a-1)] = i;\n\n        adj[a-1].push_back(b-1);\n        adj[b-1].push_back(a-1);\n    }\n    \n    \n    set<pair<int, int>> st;\n\n    vector<int> was(n), parent(n, -1);\n    \n    int remove = -1, add = -1;\n    \n    function<void(int, int)> go = [&] (int i, int p)\n    {\n        for(int t: adj[i])\n        {\n            if (t == p)\n                continue;\n            \n            if (was[t])\n            {\n                st.insert(pair(t, i));\n                if (remove == -1)\n                {\n                    remove = edge_to_id[pair(t, i)];\n                    add = edge_to_id[pair(i, parent[i])];\n                }\n            }\n            else\n            {\n                parent[t] = i;\n                was[t] = 1;\n                go(t, i);\n            }\n        }\n        \n    };\n    \n    was[0] = 1;\n    go(0, -1);\n    \n    //cout << m << endl;\n    string res(m, '0');\n\n    set<int> verts;\n    for(auto e: st)\n    {\n        int x = e.first, y = e.second;\n        \n        verts.insert(x);\n        verts.insert(y);\n        \n        res[edge_to_id[e]] = '1';\n    }\n    \n    //cout << remove << \" \" << add << endl;\n    if (verts.size() == 3)\n    {\n        res[remove] = '0';\n        res[add] = '1';\n    }\n    \n    cout << res << endl;\n}\n\n\n\nint main(int argc, const char * argv[])\n{\n    // freopen(\"/Users/mikhailkaspiarovich/Desktop/TopCoder/in.txt\", \"r\", stdin);\n    // freopen(\"/Users/mikhailkaspiarovich/Desktop/TopCoder/out.txt\", \"w\", stdout);\n    \n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    if (false)\n    {\n        solve_case(0);\n        return 0;\n    }\n    \n    int t = 0;\n    cin >> t;\n    \n    for(int i = 1; i <= t; ++i)\n    {\n        solve_case(i);\n    }\n    \n    return 0;\n}\n\n"
}