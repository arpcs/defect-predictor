{
    "id": 86080747,
    "contestId": 509,
    "creationTimeSeconds": 1593982608,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 509,
        "index": "C",
        "name": "Sums of Digits",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "dp",
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 509,
        "members": [
            {
                "handle": "yuppy1234"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1422705600
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 21,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 4096000,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\n#define mod 1000000007\r\n#define mod1 998244353\r\n#define lli long long int\r\n#define plli pair<lli, lli>\r\n#define REP(i, a, b) for (lli i = a; i < b; i++)\r\n#define REPI(i, a, b) for (lli i = b - 1; i >= a; i--)\r\n#define F first\r\n#define ldb long double\r\n#define deci(x) fixed << setprecision(x)\r\n#define S second\r\n#define PB push_back\r\n#define DB pop_back\r\n#define MP make_pair\r\n#define MT make_tuple\r\n#define G(a, b) get<a>(b)\r\ntypedef vector<plli> vii; // three data type shortcuts. They may look cryptic\r\ntypedef vector<lli> vi;\r\n\r\n#define o_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\r\n#define o_setlli tree<lli, null_type, less<lli>, rb_tree_tag, tree_order_statistics_node_update>\r\n#define o_multiset tree<int, null_type, std::less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>\r\n#define o_multisetlli tree<plli, null_type, std::less_equal<plli>, rb_tree_tag, tree_order_statistics_node_update>\r\n//member functions :\r\n//1. order_of_key(k) : number of elements strictly lesser than k\r\n//2. find_by_order(k) : k-th element in the set\r\n\r\nlli modI(lli a, lli m);\r\nlli gcd(lli a, lli b);\r\nlli powM(lli x, unsigned lli y, unsigned lli m);\r\nvoid pairsort(int a[], int b[], int n);\r\nvoid pairsortlli(lli a[], lli b[], lli n);\r\nlli logint(lli x, lli y);\r\nvoid Miden(lli **p1, lli n);\r\nvoid Mmult(lli **p1, lli **p2, lli **ans, lli x, lli y, lli z, lli m);\r\nvoid Mpow(lli **p1, lli **ans, lli n, lli y, lli m);\r\nplli Egcd(lli x, lli y);\r\n#define LSOne(S) (S & (-S))\r\n#define kira ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\r\n\r\nclass FenwickTree\r\n{\r\nprivate:\r\n    vector<lli> ft;\r\n\r\npublic:\r\n    FenwickTree() {}\r\n    // initialization: n + 1 zeroes, ignore index 0\r\n    FenwickTree(lli n) { ft.assign(n + 1, 0); }\r\n\r\n    lli rsq(lli b)\r\n    { // returns RSQ(1, b)\r\n        lli sum = 0;\r\n        for (; b; b -= LSOne(b))\r\n            sum += ft[b];\r\n        return sum;\r\n    }\r\n\r\n    lli rsq(lli a, lli b)\r\n    { // returns RSQ(a, b)\r\n        return rsq(b) - (a == 1 ? 0 : rsq(a - 1));\r\n    }\r\n\r\n    // adjusts value of the k-th element by v (v can be +ve/inc or -ve/dec)\r\n    void adjust(lli k, lli v)\r\n    { // note: n = ft.size() - 1\r\n        for (; k < (lli)ft.size(); k += LSOne(k))\r\n            ft[k] += v;\r\n    }\r\n};\r\n\r\nclass UnionFind\r\n{ // OOP style\r\npublic:\r\n    vector<lli> p, rank, setSize; // remember: vi is vector<int>\r\n    lli numSets;\r\n    UnionFind(lli N)\r\n    {\r\n        setSize.assign(N, 1);\r\n        numSets = N;\r\n        rank.assign(N, 0);\r\n        p.assign(N, 0);\r\n        for (lli i = 0; i < N; i++)\r\n            p[i] = i;\r\n    }\r\n    lli findSet(lli i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }\r\n    bool isSameSet(lli i, lli j) { return findSet(i) == findSet(j); }\r\n    void unionSet(lli i, lli j)\r\n    {\r\n        if (!isSameSet(i, j))\r\n        {\r\n            numSets--;\r\n            lli x = findSet(i), y = findSet(j);\r\n            // rank is used to keep the tree short\r\n            if (rank[x] > rank[y])\r\n            {\r\n                p[y] = x;\r\n                setSize[x] += setSize[y];\r\n            }\r\n            else\r\n            {\r\n                p[x] = y;\r\n                setSize[y] += setSize[x];\r\n                if (rank[x] == rank[y])\r\n                    rank[y]++;\r\n            }\r\n        }\r\n    }\r\n    lli numDisjointSets() { return numSets; }\r\n    lli sizeOfSet(lli i) { return setSize[findSet(i)]; }\r\n};\r\n\r\nlli gcd(lli x, lli y)\r\n{\r\n    if (x == 0)\r\n        return y;\r\n    return gcd(y % x, x);\r\n}\r\n\r\nplli Egcd(lli x, lli y)\r\n{\r\n    if (x == 0)\r\n        return MP(0, 1);\r\n    plli t = Egcd(y % x, x);\r\n    return MP(t.S - t.F * (y / x), t.F);\r\n}\r\n\r\nlli power(lli x, lli y,lli p)\r\n{\r\n    lli res = 1;\r\n    x = x %p;\r\n    while (y > 0)\r\n    {\r\n        if (y & 1)\r\n            res = (res * x)%p;\r\n        //y must be even now\r\n        y = y >> 1; //y=y/2\r\n        x = (x * x) %p;\r\n    }\r\n    return res;\r\n}\r\n\r\nlli modI(lli a, lli m)\r\n{\r\n    lli m0 = m, y = 0, x = 1;\r\n    if (m == 1)\r\n        return 0;\r\n    while (a > 1)\r\n    {\r\n        lli q = a / m;\r\n        lli t = m;\r\n        m = a % m;\r\n        a = t;\r\n        t = y;\r\n        y = x - q * y;\r\n        x = t;\r\n    }\r\n    if (x < 0)\r\n        x += m0;\r\n    return x;\r\n}\r\n\r\nvoid pairsort(int a[], int b[], int n)\r\n{\r\n    pair<int, int> v[n];\r\n    REP(i, 0, n)\r\n    {\r\n        v[i].F = a[i];\r\n        v[i].S = b[i];\r\n    }\r\n    sort(v, v + n);\r\n    REP(i, 0, n)\r\n    {\r\n        a[i] = v[i].F;\r\n        b[i] = v[i].S;\r\n    }\r\n}\r\n\r\nvoid pairsortlli(lli a[], lli b[], lli n)\r\n{\r\n    pair<lli, lli> v[n];\r\n    REP(i, 0, n)\r\n    {\r\n        v[i].F = a[i];\r\n        v[i].S = b[i];\r\n    }\r\n    sort(v, v + n);\r\n    REP(i, 0, n)\r\n    {\r\n        a[i] = v[i].F;\r\n        b[i] = v[i].S;\r\n    }\r\n}\r\n\r\nlli logint(lli x, lli y)\r\n{\r\n    lli ans = 0;\r\n    lli a = 1;\r\n    for (lli i = 0; i <= x; i++)\r\n    {\r\n        if (x < a)\r\n        {\r\n            return ans;\r\n        }\r\n        ans++;\r\n        a *= y;\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid Miden(lli **p1, lli n)\r\n{\r\n    lli(*x)[n] = (lli(*)[n])p1;\r\n    REP(i, 0, n)\r\n    {\r\n        REP(j, 0, n)\r\n        {\r\n            x[i][j] = 0;\r\n        }\r\n        x[i][i] = 1;\r\n    }\r\n    return;\r\n}\r\n\r\nvoid Mmult(lli **p1, lli **p2, lli **ans, lli x, lli y, lli z, lli m)\r\n{\r\n    lli(*a)[y] = (lli(*)[y])p1;\r\n    lli(*b)[z] = (lli(*)[z])p2;\r\n    lli(*c)[z] = (lli(*)[z])ans;\r\n    REP(i, 0, x)\r\n    {\r\n        REP(j, 0, z)\r\n        {\r\n            c[i][j] = 0;\r\n            REP(k, 0, y)\r\n            {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n                c[i][j] %= m;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\nvoid Mpow(lli **p1, lli **ans, lli n, lli y, lli m)\r\n{\r\n    if (y == 0)\r\n    {\r\n        Miden(ans, n);\r\n        return;\r\n    }\r\n    lli t[n][n];\r\n    Mpow(p1, (lli **)t, n, y / 2, m);\r\n    lli z[n][n];\r\n    Mmult((lli **)t, (lli **)t, (lli **)z, n, n, n, m);\r\n    if (y % 2)\r\n    {\r\n        Mmult((lli **)z, p1, ans, n, n, n, m);\r\n    }\r\n    else\r\n    {\r\n        Miden((lli **)t, n);\r\n        Mmult((lli **)z, (lli **)t, ans, n, n, n, m);\r\n    }\r\n    return;\r\n}\r\n\r\n/* comparator function in set */\r\n/*\r\nstruct cmp {\r\n\tbool operator() (const pair<int, int> &a, const pair<int, int> &b) const {\r\n\t\tint lena = a.second - a.first + 1;\r\n\t\tint lenb = b.second - b.first + 1;\r\n\t\tif (lena == lenb) return a.first < b.first;\r\n\t\treturn lena > lenb;\r\n\t}\r\n};\r\n*/\r\n/* set<pair<lli,lli>,cmp> s; */ \r\n\r\nint main()\r\n{\r\n    /*ifstream stdin;\r\n    stdin.open(\"sort.in\");\r\n    ofstream stdout;\r\n    stdout.open(\"sorted.out\");*/\r\n    kira;\r\n    lli t;\r\n    t = 1;\r\n    //cin>>t;\r\n    while(t--)\r\n    {\r\n      lli n;\r\n      cin>>n;\r\n      lli b[n];\r\n      string a[n];\r\n      REP(i,0,n)\r\n      {\r\n          cin>>b[i];\r\n          if(i==0)\r\n          {\r\n              lli p=b[0]/9;\r\n              REP(j,0,p)\r\n              a[0]+='9';\r\n              p=b[0]%9;\r\n              if(p)\r\n              a[0]=(char)(p+48)+a[0];\r\n              continue;\r\n          }\r\n          string p=a[i-1],ans=a[i-1];\r\n          lli q=b[i-1],d=0;\r\n          for(lli j=p.length()-1;j>=0;j--)\r\n          {\r\n              lli k=p.length()-j-1;\r\n              q-=p[j]-'0';\r\n              lli kk=p[j]-'0';\r\n              for(lli k1=kk+1;k1<=9;k1++)\r\n              {\r\n                  if(b[i]>=k1+q&&b[i]<=k1+q+9*k)\r\n                  {\r\n                      lli pp=b[i]-k1-q;\r\n                      ans[j]=(char)(k1+48);\r\n                      lli p2=pp/9;\r\n                      for(lli ii=p.length()-1;ii>=p.length()-p2;ii--)\r\n                      ans[ii]='9';\r\n                      lli p3=pp%9;\r\n                      if(p.length()-p2-1>j)\r\n                      ans[p.length()-p2-1]=(char)(p3+48);\r\n                      for(lli ii=p.length()-p2-2;ii>j;ii--)\r\n                      ans[ii]='0';\r\n                      d=1;\r\n                      break;\r\n                  }\r\n                  if(d==1)\r\n                  break;\r\n              }\r\n              if(d==1)\r\n              break;\r\n          }\r\n          if(d==0)\r\n          {\r\n              lli k=p.length()-1;\r\n              while(1)\r\n              {\r\n                  k++;\r\n                  ans+='0';\r\n                  for(lli j=1;j<=9;j++)\r\n                  {\r\n                      if(b[i]>=j&&b[i]<=j+9*k)\r\n                      {\r\n                          ans[0]=(char)(j+48);\r\n                          lli pp=(b[i]-j)/9;\r\n                          for(lli k1=ans.length()-1;k1>=ans.length()-pp;k1--)\r\n                          ans[k1]='9';\r\n                          if(ans.length()-pp-1>0)\r\n                          ans[ans.length()-pp-1]=(char)(((b[i]-j)%9+48));\r\n                          for(lli k1=ans.length()-pp-2;k1>0;k1--)\r\n                          ans[k1]='0';\r\n                          d=1;\r\n                          break;\r\n                      }\r\n                      if(d==1)\r\n                      break;\r\n                  }\r\n                  if(d==1)\r\n                  break;\r\n              }\r\n          }\r\n          a[i]=ans;\r\n      }\r\n      REP(i,0,n)\r\n      cout<<a[i]<<'\\n';\r\n    }\r\n}"
}