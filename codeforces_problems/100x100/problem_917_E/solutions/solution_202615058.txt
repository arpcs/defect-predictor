{
    "id": 202615058,
    "contestId": 917,
    "creationTimeSeconds": 1681827012,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "hgzxwzf"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1200,
    "memoryConsumedBytes": 101376000,
    "source": "#include<bits/stdc++.h>\r\n\r\n#define rep(x,y,z) for(int x=y;x<=z;x++)\r\n#define per(x,y,z) for(int x=z;x>=y;x--)\r\n\r\nusing namespace std;\r\n\r\nconst int N=1e5+10,mod=998244353,B=114514;\r\n\r\nint ksm(int x,int y)\r\n{\r\n\tint s=1;\r\n\twhile(y)\r\n\t{\r\n\t\tif(y&1) s=1ll*s*x%mod;\r\n\t\tx=1ll*x*x%mod;\r\n\t\ty>>=1;\r\n\t}\r\n\treturn s;\r\n}\r\n\r\nstruct mint\r\n{\r\n\tint x;\r\n\tmint(int a=0) {x=a;}\r\n\tint operator() ()const {return x;}\r\n\r\n\tbool operator < (const mint &b) const {return x<b.x;}\r\n\tbool operator == (const mint &b) const {return x==b.x;}\r\n\tbool operator > (const mint &b) const {return x>b.x;}\r\n\tbool operator != (const mint &b) const {return x!=b.x;}\r\n\tmint& operator += (const mint &b) {int a=(*this).x;*this=mint(a+b.x>=mod?a+b.x-mod:a+b.x);return *this;}\r\n\tmint& operator -= (const mint &b) {int a=(*this).x;*this=mint(a-b.x<0?a-b.x+mod:a-b.x);return *this;}\r\n\tmint& operator *= (const mint &b) {*this=b.x?1ll*(*this).x*b.x%mod:0;return *this;}\r\n\tmint& operator /= (const mint &b) {*this=1ll*(*this).x*ksm(b.x,mod-2)%mod;return *this;}\r\n\tmint& operator += (const int &c) {int b=c>=mod?c%mod:c;int a=(*this).x;*this=a+b>=mod?a+b-mod:a+b;return *this;}\r\n\tmint& operator -= (const int &c) {int b=c>=mod?c%mod:c;int a=(*this).x;*this=a-b<0?a-b+mod:a-b;return *this;}\r\n\tmint& operator *= (const int &c) {int b=c>=mod?c%mod:c;*this=b?1ll*((*this).x)*b%mod:0;return *this;}\r\n\tmint& operator /= (const int &c) {int b=c>=mod?c%mod:c;*this=1ll*((*this).x)*ksm(b,mod-2)%mod;return *this;}\r\n\tmint operator + (const mint &b) const {int a=(*this).x;return a+b.x>=mod?a+b.x-mod:a+b.x;}\r\n\tmint operator - (const mint &b) const {int a=(*this).x;return a-b.x<0?a-b.x+mod:a-b.x;}\r\n\tmint operator * (const mint &b) const {return b.x?1ll*((*this).x)*b.x%mod:0;}\r\n\tmint operator / (const mint &b) const {return 1ll*((*this).x)*ksm(b.x,mod-2)%mod;}\r\n\tmint operator + (const int &c) const {int b=c>=mod?c%mod:c;int a=(*this).x;return a+b>=mod?a+b-mod:a+b;}\r\n\tmint operator - (const int &c) const {int b=c>=mod?c%mod:c;int a=(*this).x;return a-b<0?a-b+mod:a-b;}\r\n\tmint operator * (const int &c) const {int b=c>=mod?c%mod:c;return b?1ll*((*this).x)*b%mod:0;}\r\n\tmint operator / (const int &c) const {int b=c>=mod?c%mod:c;return 1ll*((*this).x)*ksm(b,mod-2)%mod;}\r\n\r\n};\r\n\r\nstring s0[N];\r\nvector<pair<int,char> >e[N];\r\nint dep[N],fa[N][22],lg[N],Lg;\r\nmint ha[N][22],mi[N];\r\nint ans[N];\r\n\r\nvoid dfs(int cur)\r\n{\r\n\tdep[cur]=dep[fa[cur][0]]+1;\r\n\tfor(auto i: e[cur])\r\n\t{\r\n\t\tint nt=i.first;\r\n\t\tchar ch=i.second;\r\n\t\tif(nt==fa[cur][0]) continue;\r\n\t\tfa[nt][0]=cur;\r\n\t\tha[nt][0]=ch;\r\n\t\tdfs(nt);\r\n\t}\r\n}\r\n\r\nint LCA(int x,int y)\r\n{\r\n\tif(dep[x]<dep[y]) swap(x,y);\r\n\tper(i,0,Lg) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];\r\n\tif(x==y) return x;\r\n\tper(i,0,Lg)\r\n\t\tif(fa[x][i]!=fa[y][i])\r\n\t\t{\r\n\t\t\tx=fa[x][i];\r\n\t\t\ty=fa[y][i];\r\n\t\t}\r\n\treturn fa[x][0];\r\n}\r\n\r\nstruct query\r\n{\r\n\tint x,y,z;\r\n};\r\nvector<query>qry[2][N],qry2[N],qry3[N];\r\n\r\nstruct acam\r\n{\r\n\tint son[N][26],fail[N],idx;\r\n\tint dfn[N],siz[N],pos[N],ti;\r\n\tvector<int>g[N];\r\n\t\r\n\tvoid Insert(int id)\r\n\t{\r\n\t\tint len=s0[id].length(),cur=0;\r\n\t\trep(i,0,len-1)\r\n\t\t{\r\n\t\t\tint ch=s0[id][i]-'a';\r\n\t\t\tif(!son[cur][ch]) son[cur][ch]=++idx;\r\n\t\t\tcur=son[cur][ch];\r\n\t\t}\r\n\t\tpos[id]=cur;\r\n\t}\r\n\t\r\n\tvoid build()\r\n\t{\r\n\t\tqueue<int>q;\r\n\t\trep(i,0,25) if(son[0][i]) q.push(son[0][i]);\r\n\t\twhile(!q.empty())\r\n\t\t{\r\n\t\t\tint cur=q.front();\r\n\t\t\tq.pop();\r\n\t\t\trep(i,0,25)\r\n\t\t\t\tif(son[cur][i]) fail[son[cur][i]]=son[fail[cur]][i],q.push(son[cur][i]);\r\n\t\t\t\telse son[cur][i]=son[fail[cur]][i];\r\n\t\t}\r\n\t\trep(i,1,idx) g[fail[i]].push_back(i);\r\n\t}\r\n\t\r\n\tvoid dfs(int cur)\r\n\t{\r\n\t\tsiz[cur]=1;\r\n\t\tdfn[cur]=++ti;\r\n\t\tfor(int nt: g[cur])\r\n\t\t{\r\n\t\t\tdfs(nt);\r\n\t\t\tsiz[cur]+=siz[nt];\r\n\t\t}\r\n\t}\r\n\t\r\n}ac[2];\r\n\r\nstruct BIT\r\n{\r\n\tint bit[N];\r\n\tvoid update(int i,int d) {while(i<N) bit[i]+=d,i+=i&-i;}\r\n\tvoid update(int l,int r,int d) {update(l,d);update(r+1,-d);}\r\n\tint query(int i) {int res=0;while(i) res+=bit[i],i-=i&-i;return res;}\r\n\tint query(int l,int r) {return query(r)-query(l-1);}\r\n}tr1,tr2;\r\n\r\nvoid dfs(int cur,int p,int f)\r\n{\r\n\ttr1.update(ac[f].dfn[p],1);\r\n\tfor(auto i: qry[f][cur])\r\n\t{\r\n\t\tint u=ac[f].pos[i.y];\r\n\t\tans[i.z]+=i.x*tr1.query(ac[f].dfn[u],ac[f].dfn[u]+ac[f].siz[u]-1);\r\n\t}\r\n\tfor(auto i: e[cur])\r\n\t{\r\n\t\tint nt=i.first,c=i.second-'a';\r\n\t\tif(nt==fa[cur][0]) continue;\r\n\t\tdfs(nt,ac[f].son[p][c],f);\r\n\t}\r\n\ttr1.update(ac[f].dfn[p],-1);\r\n}\r\n\r\nstruct str\r\n{\r\n\tchar s[N];\r\n\tint n,nex[N],dfn[N],siz[N],ti;\r\n\tmint hsh[N];\r\n\tvector<int>g[N];\r\n\tint sa[N],x[N],y[N],cnt[N];\r\n\tint pa[N][22];\r\n\t\r\n\tvoid get_hash()\r\n\t{\r\n\t\thsh[n+1]=0;\r\n\t\tper(i,1,n) hsh[i]=hsh[i+1]*B+s[i];\r\n\t}\r\n\t\r\n\tvoid get_nex()\r\n\t{\r\n\t\tint j=0;\r\n\t\trep(i,2,n)\r\n\t\t{\r\n\t\t\twhile(j&&s[j+1]!=s[i]) j=nex[j];\r\n\t\t\tif(s[j+1]==s[i]) j++;\r\n\t\t\tnex[i]=j;\r\n\t\t}\r\n\t\trep(i,0,n) g[i].clear();\r\n\t\trep(i,1,n) g[nex[i]].push_back(i),pa[i][0]=nex[i];\r\n\t\trep(j,1,lg[n])\r\n\t\t\trep(i,1,n)\r\n\t\t\t\tpa[i][j]=pa[pa[i][j-1]][j-1];\r\n\t}\r\n\t\r\n\tvoid get_sa()\r\n\t{\r\n\t\tmemset(x,0,n+3<<2);\r\n\t\tint m=122;\r\n\t\trep(i,1,m) cnt[i]=0;\r\n\t\trep(i,1,n) cnt[x[i]=s[i]]++;\r\n\t\trep(i,1,m) cnt[i]+=cnt[i-1];\r\n\t\tper(i,1,n) sa[cnt[x[i]]--]=i;\r\n\t\tfor(int k=1;k<=n;k<<=1)\r\n\t\t{\r\n\t\t\tint tot=0;\r\n\t\t\trep(i,n-k+1,n) y[++tot]=i;\r\n\t\t\trep(i,1,n) if(sa[i]>k) y[++tot]=sa[i]-k;\r\n\t\t\trep(i,1,m) cnt[i]=0;\r\n\t\t\trep(i,1,n) cnt[x[y[i]]]++;\r\n\t\t\trep(i,1,m) cnt[i]+=cnt[i-1];\r\n\t\t\tper(i,1,n) sa[cnt[x[y[i]]]--]=y[i];\r\n\t\t\tmemcpy(y,x,n+3<<2);\r\n\t\t\tx[sa[1]]=tot=1;\r\n\t\t\trep(i,2,n)\r\n\t\t\t\tx[sa[i]]=y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]?tot:++tot;\r\n\t\t\tif(n==tot) break;\r\n\t\t\tm=tot;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid init()\r\n\t{\r\n\t\tti=0;\r\n\t\tget_hash();\r\n\t\tget_nex();\r\n\t\tget_sa();\r\n\t}\r\n\t\r\n\tvoid dfs(int cur)\r\n\t{\r\n\t\tdfn[cur]=++ti;\r\n\t\tsiz[cur]=1;\r\n\t\tfor(int nt: g[cur])\r\n\t\t{\r\n\t\t\tdfs(nt);\r\n\t\t\tsiz[cur]+=siz[nt];\r\n\t\t}\r\n\t}\r\n\t\r\n\tmint Hash(int l,int r)\r\n\t{\r\n\t\tif(l+r-1>n) return 0;\r\n\t\tr=l+r-1;\r\n\t\treturn hsh[l]-hsh[r+1]*mi[r-l+1];\r\n\t}\r\n\t\r\n\tint lcp(int u,int tp,int p)//tp->u\r\n\t{\r\n\t\tp=sa[p];\r\n\t\tint v=u;\r\n\t\tmint res=0;\r\n\t\tper(i,0,Lg)\r\n\t\t\tif(dep[fa[u][i]]>=dep[tp]) res=res*mi[1<<i]+ha[u][i],u=fa[u][i];\r\n\t\tu=v;\r\n\t\tif(res==Hash(p,dep[u]-dep[tp])) return dep[u]-dep[tp];\r\n\t\tper(i,0,Lg)\r\n\t\t\tif(dep[fa[u][i]]>=dep[tp]&&res-ha[u][i]*mi[dep[fa[u][i]]-dep[tp]]!=Hash(p,dep[fa[u][i]]-dep[tp]))\r\n\t\t\t\tres-=ha[u][i]*mi[dep[fa[u][i]]-dep[tp]],u=fa[u][i];\r\n\t\treturn dep[u]-dep[tp]-1;\r\n\t}\r\n\t\r\n}s[2];\r\n\r\nvoid dfs_sol(int cur)\r\n{\r\n\tint u=s[0].n-cur;\r\n\ttr2.update(s[1].dfn[u],s[1].dfn[u]+s[1].siz[u]-1,1);\r\n\tfor(auto i: qry3[cur])\r\n\t{\r\n\t\tint q=i.x,id=i.y,res=tr2.query(s[1].dfn[q]);\r\n\t\tans[id]+=res;\r\n\t}\r\n\tfor(int nt: s[0].g[cur])\r\n\t\tdfs_sol(nt);\r\n\ttr2.update(s[1].dfn[u],s[1].dfn[u]+s[1].siz[u]-1,-1);\r\n}\r\n\r\nint work(int u,int tp,int f)\r\n{\r\n\tint l=1,r=s[f].n,p=s[f].n;\r\n\twhile(l<=r)\r\n\t{\r\n\t\tint mid=l+r>>1,lcp=s[f].lcp(u,tp,mid);\r\n\t\tif(lcp==dep[u]-dep[tp]) {p=mid;break;}\r\n\t\tbool flag=0;\r\n\t\tchar ch=0;\r\n\t\tint x=u;\r\n\t\tper(i,0,Lg)\r\n\t\t\tif(dep[fa[x][i]]-dep[tp]>lcp) x=fa[x][i];\r\n\t\tch=ha[x][0].x;\r\n\t\tif(s[f].s[s[f].sa[mid]+lcp]>ch) flag=1;\r\n\t\tif(flag) p=mid,r=mid-1;\r\n\t\telse l=mid+1;\r\n\t}\r\n\tint L=s[f].lcp(u,tp,p),res=s[f].lcp(u,tp,p-1);\r\n\tif(res>L) p--,L=res;\r\n\tp=s[f].n-s[f].sa[p]+1;\r\n\tif(L==p) return L;\r\n\tper(i,0,lg[s[f^1].n])\r\n\t\tif(s[f^1].pa[p][i]>L) p=s[f^1].pa[p][i];\r\n\treturn s[f^1].pa[p][0];\r\n}\r\n\r\nint main()\r\n{\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0),cout.tie(0);\r\n\tmi[0]=1;\r\n\trep(i,1,N-1) mi[i]=mi[i-1]*B;\r\n\trep(i,2,N-1) lg[i]=lg[i>>1]+1;\r\n\tint n,m,q;\r\n\tcin>>n>>m>>q;\r\n\tLg=lg[n];\r\n\trep(i,1,n-1)\r\n\t{\r\n\t\tint u,v;\r\n\t\tchar c;\r\n\t\tcin>>u>>v>>c;\r\n\t\te[u].push_back({v,c});\r\n\t\te[v].push_back({u,c});\r\n\t}\r\n\tdfs(1);\r\n\trep(j,1,lg[n])\r\n\t\trep(i,1,n)\r\n\t\t{\r\n\t\t\tfa[i][j]=fa[fa[i][j-1]][j-1];\r\n\t\t\tha[i][j]=ha[i][j-1]*mi[1<<j-1]+ha[fa[i][j-1]][j-1];\r\n\t\t}\r\n\trep(i,1,m)\r\n\t{\r\n\t\tcin>>s0[i];\r\n\t\tac[0].Insert(i);\r\n\t\treverse(s0[i].begin(),s0[i].end());\r\n\t\tac[1].Insert(i);\r\n\t\treverse(s0[i].begin(),s0[i].end());\r\n\t}\r\n\trep(i,1,q)\r\n\t{\r\n\t\tint u,v,k;\r\n\t\tcin>>u>>v>>k;\r\n\t\tint lca=LCA(u,v),len=s0[k].length();\r\n\t\tif(dep[u]-dep[lca]>=len)\r\n\t\t{\r\n\t\t\tqry[1][u].push_back({1,k,i});\r\n\t\t\tper(i,0,lg[n])\r\n\t\t\t\tif(dep[fa[u][i]]-dep[lca]>=len-1) u=fa[u][i];\r\n\t\t\tqry[1][u].push_back({-1,k,i});\r\n\t\t}\r\n\t\tif(dep[v]-dep[lca]>=len)\r\n\t\t{\r\n\t\t\tqry[0][v].push_back({1,k,i});\r\n\t\t\tper(i,0,lg[n])\r\n\t\t\t\tif(dep[fa[v][i]]-dep[lca]>=len-1) v=fa[v][i];\r\n\t\t\tqry[0][v].push_back({-1,k,i});\r\n\t\t}\r\n\t\tif(dep[u]+dep[v]-2*dep[lca]>=len) qry2[k].push_back({u,v,i});\r\n\t}\r\n\trep(i,0,1)\r\n\t{\r\n\t\tac[i].build();\r\n\t\tac[i].dfs(0);\r\n\t\tdfs(1,0,i);\r\n\t}\r\n\trep(k,1,m)\r\n\t{\r\n\t\tif(qry2[k].empty()) continue;\r\n\t\tint L=s0[k].length();\r\n\t\trep(i,0,L-1) s[0].s[i+1]=s0[k][i];\r\n\t\ts[0].s[L+1]='\\0';\r\n\t\ts[0].n=L;\r\n\t\trep(i,1,L+1) s[1].s[i]=s[0].s[L-i+1];\r\n\t\ts[1].n=L;\r\n\t\ts[0].init(),s[1].init();\r\n\t\ts[1].dfs(0);\r\n\t\tfor(auto i: qry2[k])\r\n\t\t{\r\n\t\t\tint u=i.x,v=i.y,id=i.z;\r\n\t\t\tint lca=LCA(u,v);\r\n\t\t\tint p=work(u,lca,1),q=work(v,lca,0);\r\n\t\t\tqry3[p].push_back({q,id});\r\n\t\t}\r\n\t\tdfs_sol(0);\r\n\t\trep(i,0,L) qry3[i].clear();\r\n\t}\r\n\trep(i,1,q) cout<<ans[i]<<endl;\r\n\treturn 0;\r\n}"
}