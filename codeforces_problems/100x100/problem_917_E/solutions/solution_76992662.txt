{
    "id": 76992662,
    "contestId": 917,
    "creationTimeSeconds": 1587052780,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "hjk1030"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1980,
    "memoryConsumedBytes": 214732800,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef unsigned long long ull;\r\nconst ull mod=(1ull<<61)-1,bas=28;\r\ninline ull mult(ull a,ull b)\r\n{\r\n\tuint64_t l1 = (uint32_t)a, h1 = a>>32, l2 = (uint32_t)b, h2 = b>>32;\r\n\tuint64_t l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;\r\n\tuint64_t ret = (l&mod) + (l>>61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;\r\n\tret = (ret & mod) + (ret>>61);\r\n\tret = (ret & mod) + (ret>>61);\r\n\treturn ret-1;\r\n}\r\ninline ull add(ull a,ull b)\r\n{\r\n\tif((a+=b)>=mod)a-=mod;\r\n\treturn a;\r\n}\r\ninline ull dec(ull a,ull b)\r\n{\r\n\treturn add(a,mod-b);\r\n}\r\ninline int lowbit(int x)\r\n{\r\n\treturn x&(-x);\r\n}\r\nconst int N=100010;\r\nint n,m,q,s[N],e[N],c[N],ans[N];\r\nstring str[N];\r\nvector<pair<int,char> > v[N];\r\nnamespace SGT\r\n{\r\n\tclass node\r\n\t{\r\n\t\tpublic:\r\n\t\t\tint ch[2],mx;\r\n\t}t[10000000];\r\n\tint nodecnt;\r\n\tvoid init()\r\n\t{\r\n\t\tnodecnt=0;\r\n\t}\r\n\tvoid modify(int &p,int q,int l,int r,int ml,int mr,int v)\r\n\t{\r\n\t\tp=++nodecnt;\r\n\t\tt[p]=t[q];\r\n\t\tif(ml<=l&&r<=mr)\r\n\t\t{\r\n\t\t\tt[p].mx=max(t[p].mx,v);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint mid=(l+r)>>1;\r\n\t\tif(ml<=mid)modify(t[p].ch[0],t[q].ch[0],l,mid,ml,mr,v);\r\n\t\tif(mr>mid)modify(t[p].ch[1],t[q].ch[1],mid+1,r,ml,mr,v);\r\n\t}\r\n\tint query(int p,int l,int r,int pos)\r\n\t{\r\n\t\tif(!p)return 0;\r\n\t\tif(l==r)return t[p].mx;\r\n\t\tint mid=(l+r)>>1;\r\n\t\tif(pos<=mid)return max(t[p].mx,query(t[p].ch[0],l,mid,pos));\r\n\t\treturn max(t[p].mx,query(t[p].ch[1],mid+1,r,pos));\r\n\t}\r\n}\r\null pw[N];\r\nclass AC\r\n{\r\n\tpublic:\r\n\t\tint ch[N][26],fail[N],nodecnt=0,L[N],R[N],tim,L2[N],R2[N],at[N],dep[N];\r\n\t\tvector<int> t[N],st[N];\r\n\t\tmap<ull,int> mp;\r\n\t\tull hs[N];\r\n\t\tint insert(string s,int id)\r\n\t\t{\r\n\t\t\tint cur=0;\r\n\t\t\tfor(int i=0;i<s.size();i++)\r\n\t\t\t{\r\n\t\t\t\tif(!ch[cur][s[i]-'a'])ch[cur][s[i]-'a']=++nodecnt;\r\n\t\t\t\tcur=ch[cur][s[i]-'a'];\r\n\t\t\t}\r\n\t\t\tst[cur].push_back(id);\r\n\t\t\treturn cur;\r\n\t\t}\r\n\t\tvoid dfs(int np)\r\n\t\t{\r\n\t\t\tL[np]=++tim;\r\n\t\t\tfor(int &x:t[np])dfs(x);\r\n\t\t\tR[np]=tim;\r\n\t\t}\r\n\t\tint tim2;\r\n\t\tvoid dfs2(int np)\r\n\t\t{\r\n\t\t\tL2[np]=tim2+1;\r\n\t\t\tfor(int &x:st[np])at[x]=++tim2;\r\n\t\t\tfor(int i=0;i<26;i++)\r\n\t\t\t\tif(ch[np][i])dfs2(ch[np][i]);\r\n\t\t\tR2[np]=tim2;\r\n\t\t}\r\n\t\tvoid build()\r\n\t\t{\r\n\t\t\tdfs2(0);\r\n\t\t\tqueue<int> q;\r\n\t\t\tfor(int i=0;i<26;i++)\r\n\t\t\t{\r\n\t\t\t\tif(ch[0][i])\r\n\t\t\t\t{\r\n\t\t\t\t\ths[ch[0][i]]=i+1;\r\n\t\t\t\t\tq.push(ch[0][i]);\r\n\t\t\t\t\tdep[ch[0][i]]=1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile(!q.empty())\r\n\t\t\t{\r\n\t\t\t\tint fr=q.front();q.pop();\r\n\t\t\t\tt[fail[fr]].push_back(fr);\r\n\t\t\t\tfor(int i=0;i<26;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(ch[fr][i])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ths[ch[fr][i]]=add(hs[fr],mult(pw[dep[fr]],i+1));\r\n\t\t\t\t\t\tdep[ch[fr][i]]=dep[fr]+1;\r\n\t\t\t\t\t\tfail[ch[fr][i]]=ch[fail[fr]][i];\r\n\t\t\t\t\t\tq.push(ch[fr][i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tch[fr][i]=ch[fail[fr]][i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(int i=1;i<=nodecnt;i++)mp[hs[i]]=i;\r\n\t\t\tdfs(0);\r\n\t\t}\r\n\t\tint rt[N],que[N],top;\r\n\t\tint dat[N<<1],len;\r\n\t\tinline void modify(int p,int v)\r\n\t\t{\r\n\t\t\tfor(;p<=tim;p+=lowbit(p))dat[p]+=v;\r\n\t\t}\r\n\t\tinline int query(int p)\r\n\t\t{\r\n\t\t\tint ret=0;\r\n\t\t\tfor(;p;p-=lowbit(p))ret+=dat[p];\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\tinline int query(int l,int r)\r\n\t\t{\r\n\t\t\treturn query(r)-query(l-1);\r\n\t\t}\r\n\t\tvoid reset()\r\n\t\t{\r\n\t\t\ttop=0;\r\n\t\t\trt[0]=0;\r\n\t\t}\r\n\t\tvoid insert(int p,ull h)\r\n\t\t{\r\n\t\t\tque[++top]=p;\r\n\t\t\trt[top]=rt[top-1];\r\n\t\t\tif(mp.find(h)!=mp.end())\r\n\t\t\t{\r\n\t\t\t\tint id=mp[h];\r\n//\t\t\t\tprintf(\"%d---\\n\",id);\r\n\t\t\t\tSGT::modify(rt[top],rt[top],1,m,L2[id],R2[id],top-1);\r\n\t\t\t}\r\n\t\t\tmodify(L[p],1);\r\n\t\t}\r\n\t\tvoid pop()\r\n\t\t{\r\n\t\t\tmodify(L[que[top]],-1);\r\n\t\t\ttop--;\r\n\t\t}\r\n\t\tint ask(int x)\r\n\t\t{\r\n\t\t\treturn SGT::query(rt[top],1,m,at[x]);\r\n\t\t}\r\n}ac[2];\r\nclass AC_query\r\n{\r\n\tpublic:\r\n\t\tint qid;\r\n\t\tbool iv;\r\n};\r\nvector<AC_query> q1[N];\r\nvector<int> qpos[N];\r\nint strpos[N][2];\r\nnamespace TREE\r\n{\r\n\tvector<int> dtree[N];\r\n\tint rt,siz[N],mxsiz[N],R,st[N][18],dep[N];\r\n\tbool vis[N];\r\n\tvoid dfs(int np,int fath,int totsiz)\r\n\t{\r\n\t\tsiz[np]=1;\r\n\t\tmxsiz[np]=0;\r\n\t\tfor(auto &x:v[np])\r\n\t\t{\r\n\t\t\tif(x.first==fath||vis[x.first])continue;\r\n\t\t\tdfs(x.first,np,totsiz);\r\n\t\t\tsiz[np]+=siz[x.first];\r\n\t\t\tmxsiz[np]=max(mxsiz[np],siz[x.first]);\r\n\t\t}\r\n\t\tmxsiz[np]=max(mxsiz[np],totsiz-siz[np]);\r\n\t\tif(rt==-1||mxsiz[rt]>mxsiz[np])rt=np;\r\n\t}\r\n\tint divide(int np,int totsiz)\r\n\t{\r\n\t\trt=-1;\r\n\t\tdfs(np,0,totsiz);\r\n\t\tnp=rt;\r\n\t\tvis[np]=1;\r\n\t\tdfs(np,0,totsiz);\r\n\t\tfor(auto &x:v[np])\r\n\t\t\tif(!vis[x.first])dtree[np].push_back(divide(x.first,siz[x.first]));\r\n\t\treturn np;\r\n\t}\r\n\tvoid dfs2(int np,int fath)\r\n\t{\r\n\t\tdep[np]=dep[fath]+1;\r\n\t\tst[np][0]=fath;\r\n\t\tfor(int i=1;i<18;i++)st[np][i]=st[st[np][i-1]][i-1];\r\n\t\tfor(int &x:dtree[np])dfs2(x,np);\r\n\t}\r\n\tinline int lca(int a,int b)\r\n\t{\r\n\t\tif(dep[a]<dep[b])swap(a,b);\r\n\t\tfor(int i=17;i>=0;i--)\r\n\t\t\tif(dep[st[a][i]]>=dep[b])a=st[a][i];\r\n\t\tif(a==b)return a;\r\n\t\tfor(int i=17;i>=0;i--)\r\n\t\t\tif(st[a][i]!=st[b][i])a=st[a][i],b=st[b][i];\r\n\t\treturn st[a][0];\r\n\t}\r\n\tvoid build()\r\n\t{\r\n\t\tR=divide(1,n);\r\n\t\tdfs2(R,0);\r\n\t\tfor(int i=1;i<=q;i++)\r\n\t\t\tqpos[lca(s[i],e[i])].push_back(i);\r\n\t}\r\n}\r\nint L[2][N];\r\nnamespace Divided_tree\r\n{\r\n\tint rt,mxsiz[N],siz[N];\r\n\tbool vis[N];\r\n\tvoid dfs(int np,int fath,int totsiz)\r\n\t{\r\n\t\tsiz[np]=1;\r\n\t\tmxsiz[np]=0;\r\n\t\tfor(auto &x:v[np])\r\n\t\t{\r\n\t\t\tif(x.first==fath||vis[x.first])continue;\r\n\t\t\tdfs(x.first,np,totsiz);\r\n\t\t\tsiz[np]+=siz[x.first];\r\n\t\t\tmxsiz[np]=max(mxsiz[np],siz[x.first]);\r\n\t\t}\r\n\t\tmxsiz[np]=max(mxsiz[np],totsiz-siz[np]);\r\n\t\tif(rt==-1||mxsiz[rt]>mxsiz[np])rt=np;\r\n\t}\r\n\tvoid dfs2(int np,int fath,int pos1,int pos2,ull hs)\r\n\t{\r\n\t\tac[0].insert(pos1,hs);\r\n\t\tac[1].insert(pos2,hs);\r\n\t\tfor(auto &x:q1[np])\r\n\t\t{\r\n\t\t\tans[x.qid]+=ac[x.iv^1].query(ac[x.iv^1].L[strpos[c[x.qid]][x.iv^1]],ac[x.iv^1].R[strpos[c[x.qid]][x.iv^1]]);\r\n\t\t\tL[x.iv][x.qid]=ac[x.iv].ask(c[x.qid]);\r\n\t\t}\r\n\t\tsiz[np]=1;\r\n\t\tfor(auto &x:v[np])\r\n\t\t{\r\n\t\t\tif(x.first==fath||vis[x.first])continue;\r\n\t\t\tdfs2(x.first,np,ac[0].ch[pos1][x.second-'a'],ac[1].ch[pos2][x.second-'a'],add(mult(hs,bas),x.second-'a'+1));\r\n\t\t\tsiz[np]+=siz[x.first];\r\n\t\t}\r\n\t\tac[0].pop();\r\n\t\tac[1].pop();\r\n\t}\r\n\tvoid solve(int np,int totsiz)\r\n\t{\r\n\t\trt=-1;\r\n\t\tdfs(np,0,totsiz);\r\n\t\tnp=rt;\r\n\t\tvis[np]=1;\r\n//\t\tcerr<<np<<endl;\r\n\t\tfor(auto &x:qpos[np])\r\n\t\t{\r\n\t\t\tq1[s[x]].push_back((AC_query){x,0});\r\n\t\t\tq1[e[x]].push_back((AC_query){x,1});\r\n\t\t}\r\n\t\tdfs2(np,0,0,0,0ull);\r\n\t\tfor(auto &x:qpos[np])\r\n\t\t{\r\n\t\t\tq1[s[x]].clear();\r\n\t\t\tq1[e[x]].clear();\r\n\t\t}\r\n\t\tac[0].reset();\r\n\t\tac[1].reset();\r\n\t\tSGT::init();\r\n\t\tfor(auto &x:v[np])\r\n\t\t{\r\n\t\t\tif(!vis[x.first])solve(x.first,siz[x.first]);\r\n\t\t}\r\n\t}\r\n}\r\nclass KMPAM\r\n{\r\n\tpublic:\r\n\t\tint dat[N],L[N],R[N],tim,fail[N];\r\n\t\tvector<int> e[N];\r\n\t\tvoid dfs(int np)\r\n\t\t{\r\n\t\t\tL[np]=++tim;\r\n\t\t\tfor(int &x:e[np])dfs(x);\r\n\t\t\tR[np]=tim;\r\n\t\t}\r\n\t\tvoid tmodify(int p,int v)\r\n\t\t{\r\n\t\t\tfor(;p<=tim;p+=lowbit(p))dat[p]+=v;\r\n\t\t}\r\n\t\tint tquery(int p)\r\n\t\t{\r\n\t\t\tint ret=0;\r\n\t\t\tfor(;p;p-=lowbit(p))ret+=dat[p];\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\tvoid modify(int p,int v)\r\n\t\t{\r\n\t\t\ttmodify(L[p],v);\r\n\t\t\ttmodify(R[p]+1,-v);\r\n\t\t}\r\n\t\tint query(int p)\r\n\t\t{\r\n\t\t\treturn tquery(L[p]);\r\n\t\t}\r\n\t\tvoid build(int* a,int len)\r\n\t\t{\r\n\t\t\ttim=0;\r\n\t\t\tfor(int i=0;i<=len+1;i++)e[i].clear();\r\n\t\t\tint j=0;\r\n\t\t\tfail[1]=0;\r\n\t\t\tfor(int i=2;i<=len;i++)\r\n\t\t\t{\r\n\t\t\t\twhile(j&&a[j+1]!=a[i])j=fail[j];\r\n\t\t\t\tif(a[j+1]==a[i])j++;\r\n\t\t\t\tfail[i]=j;\r\n\t\t\t}\r\n\t\t\tfor(int i=1;i<=len;i++)e[fail[i]].push_back(i);\r\n\t\t\tdfs(0);\r\n\t\t}\r\n}kmp[2];\r\nnamespace single\r\n{\r\n\tvector<int> tq[N];\r\n\tvector<pair<int,int> > vq[N];\r\n\tint A[N];\r\n\tvoid dfs(int x,int l)\r\n\t{\r\n\t\tif(x&&l-x)kmp[1].modify(l-x,1);\r\n\t\tfor(auto &p:vq[x])ans[p.second]+=kmp[1].query(p.first);\r\n\t\tfor(int &p:kmp[0].e[x])dfs(p,l);\r\n\t\tif(x&&l-x)kmp[1].modify(l-x,-1);\r\n\t}\r\n\tvoid solve(int id)\r\n\t{\r\n\t\tint len=str[id].size();\r\n\t\tfor(int i=0;i<=len+1;i++)vq[i].clear();\r\n\t\tfor(int i=0;i<len;i++)A[i+1]=str[id][i]-'a'+1;\r\n\t\tkmp[0].build(A,len);\r\n\t\treverse(A+1,A+len+1);\r\n\t\tkmp[1].build(A,len);\r\n\t\tfor(int &x:tq[id])\r\n\t\t{\r\n\t\t\tif(L[0][x]==len)L[0][x]=kmp[0].fail[len];\r\n\t\t\tif(L[1][x]==len)L[1][x]=kmp[1].fail[len];\r\n\t\t\tvq[L[0][x]].push_back(make_pair(L[1][x],x));\r\n\t\t}\r\n\t\tdfs(0,len);\r\n\t}\r\n}\r\nint main()\r\n{\r\n//\tfreopen(\"data.in\",\"r\",stdin);\r\n//\tfreopen(\"test.out\",\"w\",stdout);\r\n\tscanf(\"%d%d%d\",&n,&m,&q);\r\n\tpw[0]=1;\r\n\tfor(int i=1;i<=100000;i++)pw[i]=mult(pw[i-1],bas);\r\n\tfor(int i=1;i<n;i++)\r\n\t{\r\n\t\tint a,b;\r\n\t\tchar opt[5];\r\n\t\tscanf(\"%d%d%s\",&a,&b,opt);\r\n\t\tv[a].push_back(make_pair(b,opt[0]));\r\n\t\tv[b].push_back(make_pair(a,opt[0]));\r\n\t}\r\n\tfor(int i=1;i<=m;i++)\r\n\t{\r\n\t\tcin>>str[i];\r\n\t\tstrpos[i][0]=ac[0].insert(str[i],i);\r\n\t\treverse(str[i].begin(),str[i].end());\r\n\t\tstrpos[i][1]=ac[1].insert(str[i],i);\r\n\t\treverse(str[i].begin(),str[i].end());\r\n\t}\r\n\tac[0].build();\r\n\tac[1].build();\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tscanf(\"%d%d%d\",&s[i],&e[i],&c[i]);\r\n\t\tsingle::tq[c[i]].push_back(i);\r\n\t}\r\n\tTREE::build();\r\n\tDivided_tree::solve(1,n);\r\n//\tfor(int i=1;i<=q;i++)printf(\"%d %d\\n\",L[0][i],L[1][i]);\r\n\tfor(int i=1;i<=m;i++)single::solve(i);\r\n\tfor(int i=1;i<=q;i++)\r\n\t\tprintf(\"%d\\n\",ans[i]);\r\n\treturn 0;\r\n}"
}