{
    "id": 80775847,
    "contestId": 917,
    "creationTimeSeconds": 1589980835,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "zxyoi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1419,
    "memoryConsumedBytes": 141414400,
    "source": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define re register\r\n#define cs const\r\n\r\nnamespace IO{\r\n\r\ninline char gc(){\r\n\tstatic cs int Rlen=1<<22|1;static char buf[Rlen],*p1,*p2;\r\n\treturn (p1==p2)&&(p2=(p1=buf)+fread(buf,1,Rlen,stdin),p1==p2)?EOF:*p1++;\r\n}template<typename T>T get_integer(){\r\n\tchar c;bool f=false;while(!isdigit(c=gc()))f=c=='-';T x=c^48;\r\n\twhile(isdigit(c=gc()))x=((x+(x<<2))<<1)+(c^48);return f?-x:x;\r\n}inline int gi(){return get_integer<int>();}\r\ninline char ga(){char c;while(!isalpha(c=gc()));return c;}\r\ninline int get_s(char *s){\r\n\tint len=0;char c;while(isspace(c=gc()));\r\n\twhile(s[len++]=c,!isspace(c=gc()));return len;\r\n}\r\n\r\nchar obuf[(int)(1e7+7)],*oh=obuf,ch[23];\r\ntemplate<typename T>void print(T a,char c){\r\n\tif(a<0)*oh++='-',a=-a;int tl=0;\r\n\tdo ch[++tl]=a%10; while(a/=10);\r\n\twhile(tl)*oh++=ch[tl--]^48;*oh++=c; \r\n}struct obuf_flusher{~obuf_flusher(){fwrite(obuf,1,oh-obuf,stdout);}}Flusher;\r\n\r\n}using IO::gi;\r\nusing IO::ga;\r\nusing IO::get_s;\r\nusing IO::print;\r\n\r\nusing std::cerr;\r\nusing std::cout;\r\n\r\ncs int N=2e5+7,M=2e5+7;\r\n\r\ncs int M1=1e9+7,M2=1e9+9;\r\ninline int add(int a,int b,int mod){return a+b>=mod?a+b-mod:a+b;}\r\ninline int dec(int a,int b,int mod){return a-b<0?a-b+mod:a-b;}\r\ninline int mul(int a,int b,int mod){ll r=(ll)a*b;return r>=mod?r%mod:r;}\r\ninline void Inc(int &a,int b,int mod){a+=b-mod,a+=a>>31&mod;}\r\ninline void Dec(int &a,int b,int mod){a-=b;a+=a>>31&mod;}\r\ninline void Mul(int &a,int b,int mod){a=mul(a,b,mod);}\r\ninline int power(int a,int b,int mod){\r\n\tint r=1;for(;b;b>>=1,Mul(a,a,mod))\r\n\tif(b&1)Mul(r,a,mod);return r;\r\n}inline int ex_gcd(int a,int b,int &x,int &y){\r\n\tif(!b){x=1,y=0;return a;}\r\n\tint g=ex_gcd(b,a%b,y,x);\r\n\ty-=a/b*x;return g;\r\n}inline int Inv(int a,int mod){\r\n\tint x,y;ex_gcd(mod,a,y,x);return x+(x>>31&mod);\r\n}\r\nint get_gr(cs int M){\r\n\tint phi=M-1;std::vector<int> p;\r\n\tfor(int i=2;i*i<=phi;++i)\r\n\t\tif(phi%i==0){\r\n\t\t\tp.push_back(i);\r\n\t\t\twhile(phi%i==0)phi/=i;\r\n\t\t}\r\n\tif(phi>1)p.push_back(phi),phi=M-1;\r\n\tfor(int re gr=2;;++gr){\r\n\t\tbool flag=true;\r\n\t\tfor(int t:p)\r\n\t\t\tif(power(gr,phi/t,M)==1)\r\n\t\t\t\t{flag=false;break;}\r\n\t\tif(flag)return gr;\r\n\t}\r\n}cs int g1=get_gr(M1),g2=get_gr(M2);\r\nclass Key{\r\n\tprivate:int x,y;\r\n\tpublic:\r\n\t\tKey(){}Key(int a):x(a),y(a){}Key(int _x,int _y):x(_x),y(_y){}\r\n\t\tfriend Key operator+(cs Key &a,cs Key &b){return Key(add(a.x,b.x,M1),add(a.y,b.y,M2));}\r\n\t\tfriend Key operator-(cs Key &a,cs Key &b){return Key(dec(a.x,b.x,M1),dec(a.y,b.y,M2));}\r\n\t\tfriend Key operator*(cs Key &a,cs Key &b){return Key(mul(a.x,b.x,M1),mul(a.y,b.y,M2));}\r\n\t\tKey &operator+=(cs Key &b){Inc(x,b.x,M1);Inc(y,b.y,M2);return *this;}\r\n\t\tKey &operator-=(cs Key &b){Dec(x,b.x,M1);Dec(y,b.y,M2);return *this;}\r\n\t\tKey &operator*=(cs Key &b){Mul(x,b.x,M1);Mul(y,b.y,M2);return *this;}\r\n\t\tfriend bool operator==(cs Key &a,cs Key &b){return a.x==b.x&&a.y==b.y;}\r\n\t\tfriend bool operator!=(cs Key &a,cs Key &b){return a.x!=b.x||a.y!=b.y;}\r\n};\r\n\r\ncs Key bse(g1,g2);\r\ncs Key ibs(Inv(g1,M1),Inv(g2,M2));\r\nKey pw[N],ip[N];\r\n\r\nstruct AC_auto{\r\n\tint son[N][26];int tot;\r\n\tint fa[N],el[N],ps[M],nxt[N];\r\n\tint in[N],ou[N],tr[N],dfc;\r\n\tvoid ins(char *s,int len,int id){\r\n\t\tint u=0;\r\n\t\tfor(int re i=1;i<=len;++i){\r\n\t\t\tint c=s[i]-'a';\r\n\t\t\tif(!son[u][c])son[u][c]=++tot;\r\n\t\t\tu=son[u][c];\r\n\t\t}ps[id]=u;\r\n\t}void build_ac(){\r\n\t\tstd::queue<int> q;\r\n\t\tfor(int re i=0;i<26;++i)\r\n\t\t\tif(son[0][i])q.push(son[0][i]);\r\n\t\twhile(!q.empty()){\r\n\t\t\tint u=q.front();q.pop();\r\n\t\t\tfor(int re c=0;c<26;++c)\r\n\t\t\t\tson[u][c]?\r\n\t\t\t\t\t(q.push(son[u][c]),fa[son[u][c]]=son[fa[u]][c]):\r\n\t\t\t\t\t(son[u][c]=son[fa[u]][c]);\r\n\t\t}for(int re i=1;i<=tot;++i)\r\n\t\t\tnxt[i]=el[fa[i]],el[fa[i]]=i;\r\n\t\tdfs(0);\r\n\t}void dfs(int u){in[u]=++dfc;for(int v=el[u];v;v=nxt[v])dfs(v);ou[u]=dfc;}\r\n\tint nx(int p,int c){return son[p][c];}\r\n\tvoid add(int p){for(p=in[p];p;p&=p-1)++tr[p];}\r\n\tvoid dec(int p){for(p=in[p];p;p&=p-1)--tr[p];}\r\n\tint qy(int p){p=ps[p];\r\n\t\tint l=in[p],r=ou[p]+1,res=0;\r\n\t\tfor(;l<=dfc;l+=l&-l)res+=tr[l];\r\n\t\tfor(;r<=dfc;r+=r&-r)res-=tr[r];\r\n\t\treturn res;\r\n\t}\r\n};\r\n\r\nstruct atom{int l,r,d;};\r\nstruct KMP{\r\n\tint *nx,*d,*up,len;\r\n\tvoid build(char *s,int n){\r\n\t\tnx=new int[n+1];d=new int[n+1];up=new int[n+1];\r\n\t\tnx[0]=d[0]=up[0]=0;nx[1]=0,up[1]=1,d[1]=1;len=n;\r\n\t\tfor(int re i=2,j=0;i<=len;++i){\r\n\t\t\twhile(j&&s[j+1]!=s[i])j=nx[j];\r\n\t\t\tif(s[j+1]==s[i])++j;nx[i]=j,d[i]=i-j;\r\n\t\t\tif(d[i]==d[nx[i]])up[i]=up[nx[i]];else up[i]=i;\r\n\t\t}\r\n\t}\r\n};\r\nstruct SA{\r\n\tint *sa,len;Key *vl;char *s;\r\n\tvoid build(char *s,int n){\r\n\t\tstatic int x[N],y[N];\r\n\t\tlen=n;sa=new int[len+1];vl=new Key[len+1];vl[0]=Key(0);sa[0]=0;\r\n\t\tfor(int re i=1;i<=n;++i)\r\n\t\t\tvl[i]=vl[i-1]+Key(s[i])*pw[i],x[i]=s[i],y[i]=i;\r\n\t\tfor(int re i=1;i<=n;++i)x[i+n]=y[i+n]=0;\r\n\t\tint m=128;radix_sort(x,y,m,n);\r\n\t\tfor(int re i=1,ct=0;ct<n;i<<=1){\r\n\t\t\tct=0;for(int re j=n-i+1;j<=n;++j)y[++ct]=j;\r\n\t\t\tfor(int re j=1;j<=n;++j)\r\n\t\t\t\tif(sa[j]>i)y[++ct]=sa[j]-i;\r\n\t\t\tradix_sort(x,y,m,n);y[sa[1]]=ct=1;\r\n\t\t\tfor(int re i=1;i<=n;++i)std::swap(x[i],y[i]);\r\n\t\t\tfor(int re j=2;j<=n;++j)\r\n\t\t\t\tx[sa[j]]=(y[sa[j]]==y[sa[j-1]]&&y[sa[j]+i]==y[sa[j-1]+i])?ct:++ct;\r\n\t\t\tm=ct;\r\n\t\t}this->s=new char[len+1];\r\n\t\tfor(int re i=1;i<=len;++i)\r\n\t\t\tthis->s[i]=s[i];\r\n\t}void radix_sort(int *x,int *y,int m,int n){\r\n\t\tstatic int bin[N];memset(bin+1,0,sizeof(int)*m);\r\n\t\tfor(int re i=1;i<=n;++i)++bin[x[i]];\r\n\t\tfor(int re i=1;i<=m;++i)bin[i]+=bin[i-1];\r\n\t\tfor(int re i=n;i;--i)sa[bin[x[y[i]]]--]=y[i];\r\n\t}Key get(int l,int r){return (vl[r]-vl[l-1])*ip[l];}\r\n\tint lcp(int,int,int);bool chk(int,int,int);\r\n\tstd::vector<atom> get(int,int,cs KMP &);\r\n};\r\n\r\nAC_auto S,T;\r\nKMP ori[M],rev[M]; \r\nSA sa_ori[M],sa_rev[M];\r\n\r\nint n,m,Q;\r\nchar s[N],t[N];int st[M],ed[M];\r\nint el[N],nx[N+N],to[N+N],w[N+N],ec;\r\nKey vl[N];int fa[N],d[N],top[N],pre[N];\r\nint sz[N],son[N],dfn[N],ps[N],dfc;\r\nvoid dfs1(int u,int p){\r\n\td[u]=d[p]+1,fa[u]=p;sz[u]=1;\r\n\tfor(int re e=el[u];e;e=nx[e])\r\n\t\tif(to[e]!=p){\r\n\t\t\tvl[to[e]]=Key(w[e])*pw[d[u]]+vl[u];\r\n\t\t\tdfs1(to[e],u),sz[u]+=sz[to[e]];pre[to[e]]=w[e];\r\n\t\t\tif(sz[to[e]]>sz[son[u]])son[u]=to[e];\r\n\t\t}\r\n}void dfs2(int u,int tp){\r\n\ttop[u]=tp,dfn[u]=++dfc,ps[dfn[u]]=u;\r\n\tif(son[u])dfs2(son[u],tp);\r\n\tfor(int re e=el[u];e;e=nx[e])\r\n\t\tif(to[e]!=fa[u]&&to[e]!=son[u])\r\n\t\t\tdfs2(to[e],to[e]);\r\n}Key tget(int u,int p){\r\n\treturn (vl[u]-vl[p])*ip[d[p]];\r\n}int jump(int u,int k){\r\n\tassert(k<d[u]);\r\n\twhile(k>d[u]-d[top[u]]){\r\n\t\tk-=d[u]-d[top[u]]+1;\r\n\t\tu=fa[top[u]];\r\n\t}return ps[dfn[u]-k];\r\n}int LCA(int u,int v){\r\n\twhile(top[u]!=top[v])\r\n\t\td[top[u]]<d[top[v]]?v=fa[top[v]]:u=fa[top[u]];\r\n\treturn d[u]<d[v]?u:v;\r\n}\r\n\r\nvoid str_build(char *s,AC_auto &S,KMP ori[],SA sa_ori[]){\r\n\tfor(int re i=1;i<=m;++i){\r\n\t\tS.ins(s+st[i],ed[i]-st[i],i);\r\n\t\tori[i].build(s+st[i],ed[i]-st[i]);\r\n\t\tsa_ori[i].build(s+st[i],ed[i]-st[i]);\r\n\t}S.build_ac();\r\n}\r\n\r\nint U[M],V[M],P[M],id[M],ans[M];\r\nstruct Qry{int t,id;};\r\nstd::vector<Qry> vec[N];\r\n\r\nint sign(int x){\r\n\treturn x<0?-1:(x>0?1:0);\r\n}\r\nvoid dfs_solve(int u,int p,int p1,int p2){\r\n\tS.add(p1),T.add(p2);\r\n\tfor(auto t:vec[u])switch(std::abs(t.t)){\r\n\t\tcase 1:ans[t.id]+=sign(t.t)*S.qy(id[t.id]);break;\r\n\t\tcase 2:ans[t.id]+=sign(t.t)*T.qy(id[t.id]);break;\r\n\t}for(int re e=el[u];e;e=nx[e])if(to[e]!=p)\r\n\t\tdfs_solve(to[e],u,S.nx(p1,w[e]-'a'),T.nx(p2,w[e]-'a'));\r\n\tS.dec(p1),T.dec(p2);\t\r\n}\r\n\r\n\r\nint solve(cs atom &v1,cs atom &v2,int len){\r\n\tif(v1.l+v2.l>len||v1.r+v2.r<len)return 0;\r\n\tint t1=(v1.r-v1.l)/(v1.d),t2=(v2.r-v2.l)/(v2.d);\r\n\tint x1,x2,y=len-v1.l-v2.l;\r\n\tint d1=v1.d,d2=v2.d,d=ex_gcd(d1,d2,x1,x2);\r\n\tif(y%d)return 0;\r\n\tint dt1=d2/d,dt2=d1/d;x1*=y/d,x2*=y/d;\r\n\tif(x1<0){\r\n\t\tint t=(-x1+dt1-1)/dt1;\r\n\t\tx1+=t*dt1;x2-=t*dt2;\r\n\t}else {\r\n\t\tint t=x1/dt1;\r\n\t\tx1-=t*dt1,x2+=t*dt2;\r\n\t}if(x1>t1||x2<0)return 0;\r\n\tint l1=0,r1=(t1-x1)/dt1,l2,r2=x2/dt2;\r\n\tif(x2-t2<0)l2=0;else l2=(x2-t2+dt2-1)/dt2;\r\n\tif(l1>r1||l2>r2||r1<l2||r2<l1)return 0;\r\n\treturn std::min(r1,r2)-std::max(l1,l2)+1;\r\n}\r\n\r\n\r\nint SA::lcp(int ps,int u,int p){\r\n\tif(u==p)return 0;int v=jump(u,d[u]-d[p]-1);\r\n\tif(d[u]-d[p]>len-sa[ps]+1)u=jump(u,d[u]-(d[p]+len-sa[ps]+1));\r\n\tint ct=0;\r\n\twhile(u!=p){\r\n\t\tint up=d[top[u]]>d[v]?top[u]:v;\r\n\t\tif(tget(up,p)!=get(sa[ps],sa[ps]+d[up]-d[p]-1))u=fa[up];\r\n\t\telse break;\r\n\t}if(u==p)return 0;\r\n\tint up=d[top[u]]>d[v]?top[u]:v;\r\n\tint l=0,r=d[u]-d[up];\r\n\twhile(l<r){\r\n\t\tint mid=(l+r)>>1;\r\n\t\tint q=::ps[dfn[u]-mid];\r\n\t\tif(tget(q,p)!=get(sa[ps],sa[ps]+d[q]-d[p]-1))l=mid+1;\r\n\t\telse r=mid;\r\n\t}return d[u]-d[p]-r;\r\n}bool SA::chk(int ps,int u,int p){\r\n\tint l=lcp(ps,u,p);if(l==len)return false;\r\n\tif(l==len-sa[ps]+1)return true;\r\n\tif(l==d[u]-d[p])return false;\r\n\treturn pre[jump(u,d[u]-d[p]-l-1)]>this->s[sa[ps]+l];\r\n}std::vector<atom> SA::get(int u,int p,cs KMP &t){\r\n\tint l=1,r=len,ps=0;\r\n\twhile(l<=r){\r\n\t\tint mid=(l+r)>>1;\r\n\t\tif(chk(mid,u,p))\r\n\t\t\tps=mid,l=mid+1;\r\n\t\telse r=mid-1;\r\n\t}if(!ps)return {};\r\n\tl=lcp(ps,u,p);if(l==len-sa[ps]+1)ps=l;\r\n\telse {\r\n\t\tps=sa[ps];ps=len-ps+1;\r\n\t\twhile(ps>l)\r\n\t\t\tif(t.up[ps]>l)ps=t.nx[t.up[ps]];\r\n\t\t\telse {\r\n\t\t\t\tps=t.up[ps]+(l-t.up[ps])/t.d[ps]*t.d[ps];\r\n\t\t\t}\r\n\t}\r\n\tstd::vector<atom> vec;\r\n\twhile(ps){\r\n\t\tvec.push_back({t.up[ps],ps,t.d[ps]});\r\n\t\tps=t.nx[t.up[ps]];\r\n\t}return vec;\r\n}\r\nvoid Main(){\r\n\tn=gi();m=gi(),Q=gi();\r\n\tassert(m<=1e5); \r\n\tfor(int re i=1;i<n;++i){\r\n\t\tint u=gi(),v=gi(),c=ga();\r\n\t\tnx[++ec]=el[u],el[u]=ec,to[ec]=v,w[ec]=c;\r\n\t\tnx[++ec]=el[v],el[v]=ec,to[ec]=u,w[ec]=c;\r\n\t}for(int re i=1;i<=m;++i){\r\n\t\tst[i]=ed[i-1]+1;ed[i]=st[i]+get_s(s+st[i]+1);\r\n\t\tstd::reverse_copy(s+st[i]+1,s+ed[i]+1,t+st[i]+1);\r\n\t}pw[0]={1,1},ip[0]={1,1};\r\n\tfor(int re i=1;i<=n;++i)\r\n\t\tpw[i]=pw[i-1]*bse,ip[i]=ip[i-1]*ibs;\r\n\tdfs1(1,0);dfs2(1,1);\r\n\tstr_build(s,S,ori,sa_ori);str_build(t,T,rev,sa_rev);\r\n\tfor(int re i=1;i<=Q;++i){\r\n\t\tint u=U[i]=gi(),v=V[i]=gi(),t=id[i]=gi();\r\n\t\tint p=P[i]=LCA(U[i],V[i]);\r\n\t\tif(d[u]-d[p]>=ed[t]-st[t]){\r\n\t\t\tvec[u].push_back({2,i});\r\n\t\t\tvec[jump(u,d[u]-d[p]-ed[t]+st[t]+1)].push_back({-2,i});\r\n\t\t}if(d[v]-d[p]>=ed[t]-st[t]){\r\n\t\t\tvec[v].push_back({1,i});\r\n\t\t\tvec[jump(v,d[v]-d[p]-ed[t]+st[t]+1)].push_back({-1,i});\r\n\t\t}\r\n\t}dfs_solve(1,0,0,0);\r\n\tfor(int re i=1;i<=Q;++i){\r\n\t\tauto v1=sa_rev[id[i]].get(U[i],P[i],ori[id[i]]);\r\n\t\tauto v2=sa_ori[id[i]].get(V[i],P[i],rev[id[i]]);\r\n\t\tfor(auto t1:v1)for(auto t2:v2)ans[i]+=solve(t1,t2,ed[id[i]]-st[id[i]]);\r\n\t\tprint(ans[i],'\\n');\r\n\t}\r\n}\r\n\r\ninline void file(){\r\n#ifdef zxyoi\r\n\tfreopen(\"tree.in\",\"r\",stdin);\r\n\tfreopen(\"tree.out\",\"w\",stdout);\r\n#endif\t\r\n}signed main(){file();Main();return 0;}"
}