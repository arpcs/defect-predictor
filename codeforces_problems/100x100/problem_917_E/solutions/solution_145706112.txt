{
    "id": 145706112,
    "contestId": 917,
    "creationTimeSeconds": 1644377781,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "CC2021zyz"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1341,
    "memoryConsumedBytes": 321945600,
    "source": "#include <map>\r\n#include <queue>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define int long long\r\n#define mp make_pair\r\nconst int mod = 1e9 + 7;\r\nint read () {\r\n\tint x = 0, f = 1;\r\n\tchar ch = getchar ();\r\n\twhile (ch < '0' || ch > '9') {\r\n\t\tif (ch == '-') f = -1;\r\n\t\tch = getchar ();\r\n\t}\r\n\twhile (ch >= '0' && ch <= '9') {\r\n\t\tx = x * 10 + ch - '0';\r\n\t\tch = getchar ();\r\n\t}\r\n\treturn x * f;\r\n}\r\nvoid write (int x) {\r\n\tif (x < 0) x = -x, putchar ('-');\r\n\tif (x >= 10) write (x / 10);\r\n\tputchar (x % 10 + '0');\r\n}\r\nint quickmod (int x, int y) {\r\n\tint Ans = 1;\r\n\twhile (y) {\r\n\t\tif (y & 1) Ans = (Ans * x) % mod;\r\n\t\tx = (x * x) % mod;\r\n\t\ty >>= 1;\r\n\t}\r\n\treturn Ans;\r\n}\r\nstruct st {\r\n\tint v;\r\n\tchar e;\r\n\tst () {}\r\n\tst (int A, char B) {\r\n\t\tv = A, e = B;\r\n\t}\r\n};\r\nvector <st> G[200005]; \r\nint n, m, Q;\r\nchar ch[200005];\r\nvector <char> str[200005];\r\n\r\nint dep[200005];\r\nint dp[200005][25];\r\n\r\nconst unsigned int bas = 131;\r\nunsigned int power[200005];\r\nunsigned int hash_tree[200005];\r\nchar val[200005];\r\nvoid dfs (int x, int fa) {\r\n\tdep[x] = dep[fa] + 1;\r\n\tfor (int i = 1; i <= 20; i++) dp[x][i] = dp[dp[x][i-1]][i-1];\r\n\tfor (int i = 0; i < (int)G[x].size(); i++) {\r\n\t\tint y = G[x][i].v, e = (int)G[x][i].e;\r\n\t\tif (y == fa) continue;\r\n\t\thash_tree[y] = hash_tree[x] * bas + e;\r\n\t\tdp[y][0] = x;\r\n\t\tval[y] = G[x][i].e;\r\n\t\tdfs (y, x);\r\n\t} \r\n}\r\nunsigned int get_hash_tree (int u, int lca) {\r\n\treturn hash_tree[u] - hash_tree[lca] * power[dep[u]-dep[lca]];\r\n}\r\nint LCA (int u, int v) {\r\n\tif (dep[u] < dep[v]) swap (u, v);\r\n\tfor (int i = 20; i >= 0; i--) {\r\n\t\tif (dep[dp[u][i]] >= dep[v]) u = dp[u][i];\r\n\t\tif (u == v) return u;\r\n\t}\r\n\tfor (int i = 20; i >= 0; i--) {\r\n\t\tif (dp[u][i] != dp[v][i]) {\r\n\t\t\tu = dp[u][i];\r\n\t\t\tv = dp[v][i];\r\n\t\t}\r\n\t}\r\n\treturn dp[u][0];\r\n}\r\nstruct AC {\r\n\tint trie[200005][27];\r\n\tint tot;\r\n\tint p[200005];\r\n\tvoid insert (vector <char> S, int id) {\r\n\t\tint rt = 0;\r\n\t\tfor (int i = 0; i < (int)S.size(); i++) {\r\n\t\t\tint now = S[i] - 'a';\r\n\t\t\tif (trie[rt][now] == 0) trie[rt][now] = ++tot;\r\n\t\t\trt = trie[rt][now];\r\n\t\t}\r\n\t\tp[id] = rt;\r\n//\t\tprintf (\"[%lld %lld]\\n\", id, rt);\r\n\t}\r\n\tint nxt[200005];\r\n\tint L[200005], R[200005], cnt;\r\n\tvector <int> V[200005];\r\n\tvoid build () {\r\n\t\tqueue <int> QQ;\r\n\t\tfor (int i = 0; i <= 25; i++) if (trie[0][i]) QQ.push(trie[0][i]), nxt[trie[0][i]] = 0;\r\n\t\twhile (!QQ.empty()) {\r\n\t\t\tint x = QQ.front();\r\n\t\t\tQQ.pop();\r\n\t\t\tint Fail = nxt[x];\r\n\t\t\tfor (int i = 0; i <= 25; i++) {\r\n\t\t\t\tint v = trie[x][i];\r\n\t\t\t\tif (! v) trie[x][i] = trie[Fail][i];\r\n\t\t\t\telse {\r\n\t\t\t\t\tnxt[v] = trie[Fail][i];\r\n\t\t\t\t\tQQ.push(v);\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t}\r\n\t\tfor (int i = 1; i <= tot; i++) V[nxt[i]].push_back(i);\r\n\t}\r\n\tvoid dfs (int x) {\r\n\t\tL[x] = ++cnt;\r\n\t\tfor (int i = 0; i < (int)V[x].size(); i++) dfs (V[x][i]);\r\n\t\tR[x] = cnt;\r\n\t}\r\n\t\r\n\tint bit[200005];\r\n\tint lowbit (int x) {\r\n\t\treturn x & (-x);\r\n\t}\r\n\tvoid add (int x, int y) {\r\n\t\tif (x == 0) return ;\r\n\t\tfor (int i = x; i <= 200000; i += lowbit (i)) bit[i] += y;\r\n\t}\r\n\tint Sum (int x) {\r\n\t\tif (x <= 0) return 0;\r\n\t\tint Ans = 0;\r\n\t\tfor (int i = x; i; i -= lowbit (i)) {\r\n\t\t\tAns += bit[i];\r\n\t\t}\r\n\t\treturn Ans;\r\n\t}\r\n\tint get_sum (int x) {\r\n\t\treturn Sum (R[x]) - Sum (L[x] - 1);\r\n\t}\r\n}T[2];\r\n\r\n\r\nstruct Query {\r\n\tint id, whi, k, val;\r\n\tQuery () {}\r\n\tQuery (int A, int B, int C, int D) {\r\n\t\tid = A, whi = B, k = C, val = D;\r\n\t}\r\n};\r\nvector <Query> P1[100005];\r\nint jump (int u, int k) {\r\n\tfor (int i = 20; i >= 0; i--) {\r\n\t\tif (k >= (1 << i)) {\r\n\t\t\tk -= (1 << i);\r\n\t\t\tu = dp[u][i];\r\n\t\t}\r\n\t}\r\n\treturn u;\r\n}\r\n\r\nint Ans[100005];\r\nvoid get_ans1 (int x, int fa, int n1, int n2) {\r\n\tT[0].add(T[0].L[n1], 1), T[1].add(T[1].L[n2], 1);\r\n//\tprintf (\"x2:%lld\\n\", x);\r\n\tfor (int i = 0; i < (int)P1[x].size(); i++) {\r\n\t\tQuery now = P1[x][i];\r\n\t\tAns[now.id] += now.val * T[now.whi].get_sum(T[now.whi].p[now.k]);\r\n\t}\r\n//\tprintf (\"x3:%lld\\n\", x);\r\n\tfor (int i = 0; i < (int)G[x].size(); i++) {\r\n\t\tint y = G[x][i].v, e = G[x][i].e - 'a';\r\n\t\tif (y == fa) continue;\r\n\t\tint m1 = T[0].trie[n1][e], m2 = T[1].trie[n2][e];\r\n\t\tget_ans1 (y, x, m1, m2); \r\n\t}\r\n//\tprintf (\"x4:%lld\\n\", x);\r\n\tT[0].add(T[0].L[n1], -1), T[1].add(T[1].L[n2], -1);\r\n}\r\n\r\nstruct Per {\r\n\tint l, r, d;\r\n\tint len;\r\n\tPer () {}\r\n\tPer (int A, int B, int C, int D) {\r\n\t\tl = A, r = B, d = C, len = D; \r\n\t}\r\n}P[2][100005];\r\nint per[2];\r\n\r\nstruct KMP {\r\n\tvector <char> s;\r\n\tvector <int> nxt;\r\n\tint len;\r\n\tvoid get_nxt (vector <char> S) {\r\n\t\tlen = S.size();\r\n//\t\tprintf (\"len:%lld\\n\", len);\r\n\t\ts.resize(len + 5), nxt.resize(len + 5);\r\n\t\tfor (int i = 1; i <= len; i++) s[i] = S[i-1];\r\n\t\tnxt[1] = 0;\r\n\t\tint j = 0;\r\n\t\tfor (int i = 2; i <= len; i++) {\r\n\t\t\twhile (j && s[i] != s[j+1]) j = nxt[j];\r\n\t\t\tif (s[i] == s[j+1]) j++;\r\n\t\t\tnxt[i] = j;\r\n\t\t}\r\n\t}\r\n\tvoid cut (int lcp, int k, int whi) {\r\n//\t\tprintf (\"len:%lld\\n\", len);\r\n\t\twhile (k > lcp) k = nxt[k];\r\n//\t\tprintf (\"lcp k:%lld %lld\\n\", lcp, k);\r\n\t\tif (k == 0) return ;\r\n//\t\tprintf (\"k:%lld %lld\\n\", k, len);\r\n\t\tint now = k;\r\n\t\twhile (now) {\r\n\t\t\tif (nxt[now] > now / 2) {\r\n\t\t\t\tint d = now - nxt[now];\r\n\t\t\t\tP[whi][++per[whi]] = Per (now % d + d, now, d, (now - (now % d + d)) / d + 1);\r\n\t\t\t\tnow = nxt[now % d + d];\r\n\t\t\t}\r\n\t\t\telse P[whi][++per[whi]] = Per (now, now, 1, 1), now = nxt[now];\r\n\t\t}\r\n//\t\tprintf (\"[%lld %lld]\\n\", per[0], per[1]);\r\n\t}\r\n}K[2][200005];\r\nint b[200005];\r\nstruct SA {\r\n\tvector <int> x, y, sa;\r\n\tvector <int> Hash;\r\n\tvector <char> s;\r\n\tint M = 30;\r\n\tint tot = 0, len;\r\n\tvoid get_sa (vector <char> S) {\r\n\t\tlen = (int)S.size();\r\n\t\tHash.resize(len + 5), s.resize(len + 5);\r\n\t\tHash[0] = 0;\r\n\t\tfor (int i = 1; i <= len; i++) Hash[i] = Hash[i-1] * bas + S[i-1];\r\n\t\t\r\n\t\tx.resize(len + 5), y.resize(len + 5), sa.resize(len + 5);\r\n\t\t\r\n\t\tfor (int i = 0; i <= M; i++) b[i] = 0;\r\n\t\tfor (int i = 0; i < len; i++) s[i+1] = S[i], b[x[i+1] = (S[i] - 'a' + 1)]++;\r\n\t\tfor (int i = 1; i <= M; i++) b[i] += b[i-1];\r\n\t\t\r\n\t\tfor (int i = len; i >= 1; i--) sa[b[x[i]]--] = i;\r\n//\t\tprintf (\"??\\n\");\r\n\t\tfor (int k = 1; k <= len; k *= 2) {\r\n\t\t\ttot = 0;\r\n\t\t\tfor (int i = len - k + 1; i <= len; i++) y[++tot] = i;\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i <= len; i++) if (sa[i] > k) y[++tot] = sa[i] - k;\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i <= M; i++) b[i] = 0;\r\n\t\t\tfor (int i = 1; i <= len; i++) b[x[y[i]]]++;\r\n\t\t\tfor (int i = 1; i <= M; i++) b[i] += b[i-1];\r\n\t\t\t\r\n\t\t\tfor (int i = len; i >= 1; i--) sa[b[x[y[i]]]--] = y[i];\r\n\t\t\t\r\n\t\t\tswap (x, y);\r\n\t\t\tx[sa[1]] = tot = 1;\r\n\t\t\t\r\n\t\t\tfor (int i = 2; i <= len; i++) {\r\n\t\t\t\tx[sa[i]] = (y[sa[i]] == y[sa[i-1]] && y[sa[i]+k] == y[sa[i-1]+k]) ? tot : ++tot;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (tot >= len) break;\r\n\t\t\tM = tot + 1; \r\n\t\t}\r\n\t}\r\n\tunsigned int get_hash (int l, int r) {\r\n\t\treturn Hash[r] - Hash[l-1] * power[r-l+1];\r\n\t}\r\n\tint get_lcp (int u, int lca, int k) {//rk \u4e3a k\uff0c\u6c42 lcp \u957f\u5ea6\r\n\t\tint nn = len - sa[k] + 1;\r\n//\t\tprintf (\"str:%c%c\\n\", s[1], s[2]);\r\n//\t\tprintf (\"{%lld %lld %lld}\\n\", nn, dep[u] - dep[lca], sa[k]);\r\n\t\tif (nn >= dep[u] - dep[lca] && get_hash (sa[k], sa[k] + (dep[u] - dep[lca]) - 1) == get_hash_tree (u, lca)) {\r\n\t\t\treturn dep[u] - dep[lca];\r\n\t\t}\r\n\t\tfor (int i = 20; i >= 0; i--) {\r\n\t\t\tif (dep[u] - dep[lca] > (1ll << i)) {\r\n\t\t\t\tif (dep[dp[u][i]] - dep[lca] > nn || get_hash_tree (dp[u][i], lca) != get_hash (sa[k], sa[k] + (dep[dp[u][i]] - dep[lca]) - 1)) {\r\n//\t\t\t\t\tprintf (\"[%lld %lld] [%lld %lld]\\n\", dp[u][i], lca, sa[k], sa[k] + (dep[dp[u][i]] - dep[lca]) - 1);\r\n\t\t\t\t\tu = dp[u][i];\r\n\t\t\t\t} \r\n\t\t\t}\r\n\t\t}\r\n\t\tu = dp[u][0];\r\n\t\treturn dep[u] - dep[lca];\r\n\t}\r\n\tint check (int u, int lca, int k) {//rk \u4e3a k\uff0c\u662f\u5426 (lca-->u) <= \u8be5\u4e32 \r\n\t\tint Len = get_lcp (u, lca, k);\r\n//\t\tprintf (\"str:%c%c\\n\", s[1], s[2]);\r\n//\t\tprintf (\"sa[k]:%lld\\n\", sa[k]);\r\n//\t\tprintf (\"1--\\n\");\r\n\t\tif (Len == len - sa[k] + 1) return 1;\r\n//\t\tprintf (\"2--\\n\");\r\n\t\tif (Len == dep[u] - dep[lca]) return 0;\r\n//\t\tprintf (\"3--\\n\");\r\n//\t\tprintf (\"Len:%lld\\n\", Len);\r\n//\t\tprintf (\"jump:%c\\n\", val[jump (u, dep[u] - dep[lca] - Len - 1)]); \r\n\t\treturn val[jump (u, dep[u] - dep[lca] - Len - 1)] > s[sa[k] + Len];\r\n\t} \r\n\tvoid get_len (int u, int lca, int id, int whi) {\r\n//\t\tif (whi == 0) {\r\n//\t\t\tprintf (\"?%lld\\n\", check (u, lca, 2));\r\n//\t\t}\r\n//\t\treturn ;\r\n\t\tint l = 1, r = len, ans = 0;\r\n\t\twhile (l <= r) {\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tif (check (u, lca, mid)) l = mid + 1, ans = mid;// <=  \r\n\t\t\telse r = mid - 1;\r\n\t\t}\r\n\t\tif (ans == 0) return ;\r\n//\t\tprintf (\"str:%c%c\\n\", s[1], s[2]);\r\n//\t\tprintf (\"[%lld:%lld] %lld %lld %lld\\n\", id, ans, u, lca, check (u, lca, ans));\r\n//\t\tprintf (\"??\\n\");\r\n\t\tint AAns = get_lcp (u, lca, ans);\r\n//\t\tprintf (\"%lld:[%lld %lld]\\n\", whi, AAns, len - sa[ans] + 1);\r\n\t\tK[whi][id].cut(AAns, len - sa[ans] + 1, whi);\r\n\t}\r\n}S[2][200005];\r\nvoid init () {\r\n\tpower[0] = 1;\r\n\tfor (int i = 1; i <= 200000; i++) power[i] = power[i-1] * bas;\r\n\tT[0].cnt = T[1].cnt = 0;\r\n\tT[0].tot = T[1].tot = 0;\r\n\tfor (int i = 1; i <= m; i++) {\r\n//\t\tprintf (\"i:%lld\\n\", i);\r\n\t\tT[0].insert(str[i], i), S[1][i].get_sa(str[i]), K[0][i].get_nxt(str[i]);\r\n\t\t\r\n\t\treverse (str[i].begin(), str[i].end());\r\n//\t\tprintf (\"??\\n\");\r\n//\t\tprintf (\"wha:i:%lld\\n\", i);\r\n\t\tT[1].insert(str[i], i), S[0][i].get_sa(str[i]), K[1][i].get_nxt(str[i]);\r\n\t\treverse (str[i].begin(), str[i].end());\r\n\t}\r\n\tT[0].build(), T[1].build();\r\n\tT[0].dfs(0), T[1].dfs(0);\r\n}\r\n\r\nint X, Y;\r\nvoid exgcd (int AA, int BB) {\r\n\tif (BB == 0) {\r\n\t\tX = 1, Y = 0;\r\n\t\treturn ;\r\n\t} \r\n\texgcd (BB, AA % BB);\r\n\tint tmp = X;\r\n\tX = Y;\r\n\tY = tmp - AA / BB * Y;\r\n}\r\nvoid match (Per A, Per B, int need, int id) {\r\n//\tprintf (\"-------\\n\");\r\n//\tprintf (\"[%lld:%lld]\\n\", id, need);\r\n//\tprintf (\"A:%lld %lld %lld %lld\\n\", A.l, A.r, A.d, A.len);\r\n//\tprintf (\"B:%lld %lld %lld %lld\\n\", B.l, B.r, B.d, B.len);\r\n//\t\r\n//\tprintf (\"(%lld %lld %lld)\\n\", A.d, B.d, need - A.l - B.l);\r\n//\tprintf (\"-------\\n\");\r\n\t\r\n\tint AA = A.d, BB = B.d, CC = need - A.l - B.l;\r\n\tif (CC % __gcd (AA, BB)) return ;\r\n\tint DD = __gcd (AA, BB);\r\n\tAA /= DD, BB /= DD, CC /= DD;\r\n\texgcd (AA, BB);\r\n\tX *= CC, Y *= CC;\r\n//\tprintf (\"XY:%lld %lld\\n\", X, Y);\r\n//\tX +- BB / ad, Y -+ AA / ad\r\n\t//A.d * X \u9760\u8fd1 A.l \u4e0e A.r, B.d * Y \u9760\u8fd1 B.l \u4e0e B.r \r\n\t//\u4e24\u8fb9\u540c\u65f6\u9650\u5236 Y \u7684\u8303\u56f4\r\n\tint ad = __gcd (A.d, B.d), adx = BB / ad, ady = AA / ad;\r\n\tint xl = (X % adx + adx) % adx, xr = (A.len - 1) / adx * adx + xl;\r\n\tif (xr > A.len - 1) xr -= adx;\r\n\t\r\n\tint yl = (Y % ady + ady) % ady, yr = (B.len - 1) / ady * ady + yl;\r\n\tif (yr > B.len - 1) yr -= ady;\r\n//\tprintf (\"x:{%lld %lld}\\n\", xl, xr); \r\n//\tprintf (\"y:{%lld %lld}\\n\", yl, yr);\r\n\tint yl2 = (need - B.l - (A.d * xr + A.l)) / B.d, yr2 = (need - B.l - (A.d * xl + A.l)) / B.d;\r\n//\tprintf (\"y2:{%lld %lld}\\n\", yl2, yr2);\r\n\tyl = max (yl, yl2), yr = min (yr, yr2);\r\n//\tprintf (\"y:%lld %lld %lld\\n\", yl, yr, B.d);\r\n\tif (yr >= yl) Ans[id] += yr - yl + 1;\r\n}\r\n/*\r\nA.d * x + B.d * y = need - A.l - B.l\r\n\r\n(A.d * x + A.l) + (B.d * y + B.l) = need\r\n*/\r\nvoid Part1 (int id, int u, int v, int k) {\r\n\tint lca = LCA (u, v);\r\n\tif (dep[u] - dep[lca] >= (int)str[k].size()) {\r\n\t\tP1[u].push_back(Query (id, 1, k, 1));\r\n\t\tP1[jump (u, dep[u] - dep[lca] + 1 - (int)str[k].size())].push_back(Query (id, 1, k, -1));\t\r\n\t}\r\n\tif (dep[v] - dep[lca] >= (int)str[k].size()) {\r\n\t\tP1[v].push_back(Query (id, 0, k, 1));\r\n\t\tP1[jump (v, dep[v] - dep[lca] + 1 - (int)str[k].size())].push_back(Query (id, 0, k, -1));\t\r\n\t}\r\n}\r\nvoid Part2 (int id, int u, int v, int k) {\r\n\tper[0] = per[1] = 0;\r\n\tint lca = LCA (u, v);\r\n//\tprintf (\"{}id0:%lld\\n\", id);\r\n\tS[0][k].get_len(u, lca, k, 0);\r\n//\tprintf (\"{}id1:%lld\\n\", id);\r\n\tS[1][k].get_len(v, lca, k, 1);\r\n\t\r\n//\tprintf (\"len:%lld\\n\", (int)str[k].size());\r\n//\tprintf (\"per:%lld %lld\\n\", per[0], per[1]);\r\n//\tfor (int i = 1; i <= per[0]; i++) {\r\n//\t\tprintf (\"[%lld %lld %lld %lld]\\n\", P[0][i].l, P[0][i].r, P[0][i].len, P[0][i].d);\r\n//\t}\r\n//\tprintf (\"-------\\n\");\r\n//\tfor (int i = 1; i <= per[1]; i++) {\r\n//\t\tprintf (\"[%lld %lld %lld %lld]\\n\", P[1][i].l, P[1][i].r, P[1][i].len, P[1][i].d);\r\n//\t}\r\n\tfor (int i = 1; i <= per[0]; i++) {\r\n\t\tfor (int j = 1; j <= per[1]; j++) {\r\n\t\t\tif (P[0][i].r + P[1][j].r >= (int)str[k].size() && P[0][i].l + P[1][j].l <= (int)str[k].size()) {\r\n\t\t\t\tmatch (P[0][i], P[1][j], (int)str[k].size(), id);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nsigned main () {\r\n//\tfreopen (\"1.in\", \"r\", stdin);\r\n//\tfreopen (\".out\", \"w\", stdout);\r\n\tn = read (), m = read (), Q = read ();\r\n\tfor (int i = 1; i < n; i++) {\r\n\t\tint u = read (), v = read ();\r\n\t\tscanf (\"%s\", ch);\r\n\t\tG[u].push_back(st (v, ch[0]));\r\n\t\tG[v].push_back(st (u, ch[0]));\r\n\t} \r\n\tdfs (1, 0);\r\n\tfor (int i = 1; i <= m; i++) {\r\n\t\tscanf (\"%s\", ch);\r\n\t\tint len = strlen (ch);\r\n\t\tstr[i].resize(len);\r\n\t\tfor (int j = 0; j < len; j++) str[i][j] = ch[j]; \r\n\t}\r\n\tinit ();\r\n//\treturn 0;\r\n\tfor (int i = 1; i <= Q; i++) {\r\n\t\tint u = read (), v = read (), k = read ();\r\n\t\tPart1 (i, u, v, k), Part2 (i, u, v, k);\r\n\t}\r\n\tget_ans1 (1, 0, 0, 0);\r\n\tfor (int i = 1; i <= Q; i++) write (Ans[i]), putchar ('\\n');\r\n\treturn 0;\r\n}\r\n/*\r\n10 1 1\r\n2 1 b\r\n3 2 b\r\n4 3 b\r\n5 2 a\r\n6 2 b\r\n7 1 b\r\n8 1 b\r\n9 2 a\r\n10 3 a\r\nab\r\n9 10 1\r\n*/"
}