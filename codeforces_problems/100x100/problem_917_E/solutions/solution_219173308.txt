{
    "id": 219173308,
    "contestId": 917,
    "creationTimeSeconds": 1692232298,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "BungeAuriculateRoot"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1278,
    "memoryConsumedBytes": 485171200,
    "source": "#include<bits/stdc++.h>\r\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\r\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\r\n#define op(x) ((x&1)?x+1:x-1)\r\n#define odd(x) (x&1)\r\n#define even(x) (!odd(x))\r\n#define lc(x) (x<<1)\r\n#define rc(x) (lc(x)|1)\r\n#define lowbit(x) (x&-x)\r\n#define mp(x,y) make_pair(x,y)\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef double db;\r\nusing namespace std;\r\nvoid input();\r\nvoid output();\r\ntemplate <typename T>void reset(vector<T>& v,int n){v.clear();v.resize(n+10);fill(v.begin(),v.end(),0);}\r\n\r\nconst int MAXN=1e5+10,base=13331,LIM=1e5,INF=1e9;\r\null pw[MAXN];\r\nvoid exgcd(ll a,ll b,ll& x,ll& y){\r\n    if(!b){x=1,y=0;return;}\r\n    exgcd(b,a%b,x,y);\r\n    ll x0=x,y0=y;\r\n    x=y0,y=x0-(a/b)*y0;\r\n}\r\n//\r\nint n,m,q,x[MAXN],y[MAXN],k[MAXN],ans[MAXN];\r\nvector<array<int,2> >e[MAXN];\r\nvector<array<int,3> >opt[MAXN]; //(k,flag,idx)\r\nstring s[MAXN],rs[MAXN];\r\nint p[MAXN],rp[MAXN];\r\nint len[MAXN];\r\nstruct BIT{\r\n    int t[MAXN*2],n;\r\n    void reset(int n){memset(t,0,sizeof t);this->n=n;}\r\n    void upd(int x,int v){for(;x<=n;x+=lowbit(x))t[x]+=v;}\r\n    int qry(int x){\r\n        int S=0;\r\n        for(;x;x-=lowbit(x))S+=t[x];\r\n        return S;\r\n    }\r\n    int qry(int L,int R){return qry(R)-qry(L-1);}\r\n}bit;\r\nnamespace Tree{\r\n    int sz[MAXN],son[MAXN],depth[MAXN],dfn[MAXN],fa[MAXN],top[MAXN],dfntot;\r\n    ull h[MAXN];char faw[MAXN];\r\n    vector<int>V[MAXN];\r\n    void dfs1(int u){\r\n        depth[u]=depth[fa[u]]+1;\r\n        sz[u]=1;\r\n        for(auto p:e[u]){\r\n            int v=p[0],w=p[1];\r\n            if(v==fa[u])continue;\r\n            h[v]=(h[u]*base+w+1);\r\n            fa[v]=u,faw[v]='a'+w;\r\n            dfs1(v);\r\n            sz[u]+=sz[v];if(sz[son[u]] < sz[v])son[u]=v; \r\n        }  \r\n    }\r\n    void dfs2(int u,int node){\r\n        V[node].push_back(u);\r\n        dfn[u]=++dfntot;top[u]=node;\r\n        if(son[u])dfs2(son[u],node);\r\n        for(auto p:e[u]){\r\n            int v=p[0];if(v==fa[u] || v==son[u])continue;\r\n            dfs2(v,v);\r\n        }\r\n    }\r\n    int lca(int x,int y){\r\n        while(top[x]!=top[y]){\r\n            if(depth[top[x]] < depth[top[y]])swap(x,y);\r\n            x=fa[top[x]];\r\n        }\r\n        return (depth[x]<depth[y])?(x):(y);\r\n    }\r\n    int upfind(int x,int k){\r\n        while(1){\r\n            int p=top[x],d=depth[x]-depth[p];\r\n            if(d<k){\r\n                k-=(d+1);x=fa[p];\r\n                continue;\r\n            }\r\n            return V[p][d-k]; \r\n        }   \r\n    }\r\n    ull hash(int x,int y){return h[y]-h[x]*pw[depth[y]-depth[x]];}\r\n}\r\nnamespace ACAM{\r\n    const int MAXN=2e5+10,MAXM=30;\r\n    int ch[MAXN][MAXM],fail[MAXN],tot;\r\n    queue<int>q;\r\n    vector<int>e[MAXN];\r\n    int dfn[MAXN],sz[MAXN],dfntot;\r\n    int insert(string s,int n){\r\n        int u=0;\r\n        rep(i,1,n){\r\n            int c=s[i]-'a';\r\n            if(!ch[u][c])ch[u][c]=++tot;\r\n            u=ch[u][c];\r\n        }\r\n        return u;\r\n    }   \r\n    void build(){\r\n        rep(i,0,25)if(ch[0][i]){\r\n            q.push(ch[0][i]);\r\n        }\r\n        while(q.size()){\r\n            int u=q.front();q.pop();\r\n            rep(i,0,25){\r\n                if(ch[u][i])fail[ch[u][i]]=ch[fail[u]][i],q.push(ch[u][i]);\r\n                else ch[u][i]=ch[fail[u]][i];\r\n            }\r\n        }\r\n        rep(i,1,tot)e[fail[i]].push_back(i);\r\n    }\r\n    void dfs(int u,int fa){\r\n        sz[u]=1;dfn[u]=++dfntot;\r\n        for(auto v:e[u])if(v!=fa){\r\n            dfs(v,u);sz[u]+=sz[v];\r\n        }\r\n    }\r\n}\r\nusing Tree::upfind;\r\nusing Tree::depth;\r\nusing ACAM::dfn;\r\nusing ACAM::sz;\r\nusing ACAM::ch;\r\nvoid acam_mdf(int u,int v){bit.upd(dfn[u],v);}\r\nint acam_qry(int u){return bit.qry(dfn[u],dfn[u]+sz[u]-1);}\r\n\r\nnamespace Task1{\r\n    void dfs(int u,int fa,int now){\r\n        acam_mdf(now,1);\r\n        for(auto qry:opt[u]){\r\n            int pos=(qry[0]>0)?(p[qry[0]]):(rp[-qry[0]]),flag=qry[1],idx=qry[2];\r\n            ans[idx]+=flag*acam_qry(pos);\r\n        }\r\n        for(auto p:e[u]){\r\n            int v=p[0],w=p[1];\r\n            if(v==fa)continue;\r\n            dfs(v,u,ch[now][w]);\r\n        }\r\n        acam_mdf(now,-1);\r\n    }\r\n    void solve(){\r\n        dfs(1,1,0);\r\n    }  \r\n}\r\nstruct KH{\r\n    vector<int>nxt,fa[20],depth;\r\n    vector<ull>h;\r\n    void calc(string s,int n){\r\n        reset(nxt,n);reset(h,n);reset(depth,n);\r\n        rep(j,0,19)reset(fa[j],n);\r\n        for(int i=2,j=0;i<=n;i++){\r\n            while(j && s[j+1]!=s[i])j=nxt[j];\r\n            if(s[j+1]==s[i])j++;\r\n            nxt[i]=j;\r\n        }\r\n        rep(i,1,n)h[i]=(h[i-1]*base+(s[i]-'a'+1)),fa[0][i]=nxt[i],depth[i]=depth[fa[0][i]]+1;\r\n        rep(j,1,19)rep(i,1,n)fa[j][i]=fa[j-1][fa[j-1][i]];\r\n    }\r\n    int border(int x)const{return nxt[x];}\r\n    ull hash(int L,int R)const{return h[R]-h[L-1]*pw[R-L+1];}\r\n    int upfind(int n,int lim)const{ //\u7b2c\u4e00\u4e2a<lim\u7684\u4f4d\u7f6e\r\n        if(n<lim)return n;\r\n        int u=n;\r\n        per(j,19,0)if(fa[j][u] >= lim)u=fa[j][u];\r\n        return fa[0][u];\r\n    }    \r\n}kmp[MAXN],rkmp[MAXN];\r\nstruct SA{\r\n    vector<int>sa,rk,oldrk,cnt,p;\r\n    int n,m,tmp;\r\n    string s;\r\n    void calc(string s,int n){\r\n        this->s=s,this->n=n;m=max(n,30);\r\n        reset(sa,n),reset(rk,2*n),reset(oldrk,2*n),reset(cnt,m),reset(p,n);\r\n        rep(i,1,n)rk[i]=s[i]-'a'+1,cnt[rk[i]]++;\r\n        rep(i,1,m)cnt[i]+=cnt[i-1];\r\n        per(i,n,1)sa[cnt[rk[i]]--]=i;\r\n        for(int w=1;w<n;w<<=1){\r\n            tmp=0;\r\n            per(i,n,n-w+1)p[++tmp]=i;\r\n            rep(i,1,n)if(sa[i]>w)p[++tmp]=sa[i]-w;\r\n            rep(i,1,m)cnt[i]=0;\r\n            rep(i,1,n)cnt[rk[p[i]]]++;\r\n            rep(i,1,m)cnt[i]+=cnt[i-1];\r\n            per(i,n,1)sa[cnt[rk[p[i]]]--]=p[i];\r\n            rep(i,1,n)oldrk[i]=rk[i];\r\n            rk[sa[1]]=1;\r\n            rep(i,2,n){\r\n                if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+w]==oldrk[sa[i-1]+w])rk[sa[i]]=rk[sa[i-1]];\r\n                else rk[sa[i]]=rk[sa[i-1]]+1;\r\n            }\r\n        }\r\n    }\r\n    int cmp(const KH& h,int x,int u,int v,int mode=0)const{\r\n        //[x,n] \u548c \u6811\u4e0a (u,v) \u6bd4\u8f83\u5b57\u5178\u5e8f\r\n        int l1=n-x+1,l2=depth[v]-depth[u];\r\n        int l=1,r=min(l1,l2),res=0;\r\n        while(l<=r){\r\n            int mid=(l+r)>>1;\r\n            if(h.hash(x,x+mid-1)==Tree::hash(u,upfind(v,l2-mid))){\r\n                res=mid;l=mid+1;\r\n            }else{\r\n                r=mid-1;\r\n            }\r\n        }\r\n        if(mode==1)return res;\r\n        if(res!=min(l1,l2)){\r\n            return s[x+res] < Tree::faw[upfind(v,l2-res-1)];\r\n        }else{\r\n            return (l1<l2)?(1):(0);\r\n        }\r\n    }\r\n    int qry_rk(const KH& h,int u,int v)const{\r\n        int l=1,r=n,res=0;\r\n        while(l<=r){\r\n            int mid=(l+r)>>1;\r\n            if(cmp(h,sa[mid],u,v)){\r\n                res=mid;l=mid+1;\r\n            }else{\r\n                r=mid-1;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}sa[MAXN],rsa[MAXN];\r\nnamespace Task2{\r\n    typedef array<int,3> Info; //(start,diff,cnt)\r\n    Info L[MAXN],R[MAXN];\r\n    int tot1,tot2;\r\n    void calc(int u,int v,const KH& kmp,const SA& sa,const KH& rkmp,const SA& rsa,int len,Info* info,int& tot){\r\n        //1.\u5148\u6c42\u5728sa\u4e2d\u7684rk\r\n        int rk=sa.qry_rk(kmp,u,v);\r\n        //2.\u6c42\u6700\u957fborder\r\n        int bd=0;\r\n        \r\n        if(rk){\r\n            int pos=sa.sa[rk];\r\n            int lcp=sa.cmp(kmp,pos,u,v,1);\r\n            int res=rkmp.upfind(len-pos+1,lcp+1);\r\n            bd=max(bd,res);\r\n        }\r\n        if(rk+1<=len){\r\n            int pos=sa.sa[rk+1];\r\n            int lcp=sa.cmp(kmp,pos,u,v,1);\r\n            int res=rkmp.upfind(len-pos+1,lcp+1);\r\n            bd=max(bd,res);\r\n        }\r\n        //3.\u5212\u5206\u7b49\u5dee\u6570\u5217\r\n        if(!bd)return;\r\n        if(bd!=len)info[++tot]={bd,1,1};\r\n\r\n        while(bd){\r\n            int nxt=rkmp.border(bd);\r\n            if(nxt==0)break;\r\n            if(nxt<=(bd+1)/2){\r\n                info[++tot]={nxt,1,1};\r\n                bd=nxt;continue;\r\n            }\r\n            int d=bd-nxt;\r\n            int ed=bd%d+d;\r\n            info[++tot]={ed,d,(bd-ed)/d};\r\n            bd=ed;\r\n        }\r\n    }\r\n    void solve(int x,int y,int lca,int k,int& ans){\r\n        if(x==lca || y==lca)return;\r\n        tot1=tot2=0;\r\n        //\u8ba1\u7b97\u4e24\u8fb9\u7684\u7b49\u5dee\u6570\u5217\r\n        calc(lca,x,rkmp[k],rsa[k],kmp[k],sa[k],len[k],L,tot1);\r\n        calc(lca,y,kmp[k],sa[k],rkmp[k],rsa[k],len[k],R,tot2);\r\n        rep(i,1,tot1)rep(j,1,tot2){\r\n            //\u5bf9\u4e8e\u4e24\u4e2a\u7b49\u5dee\u6570\u5217\u6c42\u7b54\u6848\r\n            int c=len[k]-L[i][0]-R[j][0];\r\n            int a=L[i][1],b=R[j][1]; //ax+by=c\r\n\r\n            if(c<0)continue;\r\n            int g=__gcd(a,b);if(c%g)continue;\r\n            int mn=INF,mx=-INF;\r\n            rep(x,0,L[i][2]-1){\r\n                ll rest=c-a*x;\r\n                if(rest<0 || rest%b)continue;\r\n                ll y=rest/b;if(y<R[j][2])mn=min(mn,x),mx=max(mx,x);\r\n            }\r\n            if(mn<=mx)ans+=mx-mn+1;\r\n            continue;\r\n            ll x0,y0;exgcd(a,b,x0,y0);\r\n            x0*=(c/g),y0*=(c/g);\r\n            //\u8c03\u6574\r\n            ll addx=b/g,addy=a/g;\r\n            ll miny=y0,maxy=y0,x=x0;\r\n            //\u6c42y\u6700\u5c0f\u7684\u89e3\r\n            if(miny<0){\r\n                ll step=(-miny+addy-1)/addy;\r\n                miny+=addy*step;x-=addx*step;\r\n            }\r\n            ll step=miny/addy;\r\n            miny-=addy*step;x+=addx*step;\r\n            if(x>=L[i][2]){\r\n                ll step=(x-L[i][2]+addx)/addx;\r\n                x-=step*addx,y+=step*addy;\r\n            }\r\n            if(miny<0 || miny>=R[j][2] || x<0 || x>=L[i][2])continue;\r\n            //\u6c42y\u6700\u5927\u7684\u89e3\r\n            x=x0;\r\n            if(maxy>=R[j][2]){\r\n                ll step=(maxy-R[j][2]+addy)/addy;\r\n                x+=step*addx,y-=step*addy;\r\n            }\r\n            step=(R[j][2]-maxy-1)/addy;\r\n            x-=step*addx,y+=step*addy;\r\n            if(x<0){\r\n                ll step=(-x+addx-1)/addx;\r\n                x+=step*addx,y-=step*addy;\r\n            }\r\n            if(maxy<0 || maxy>=R[j][2] || x<0 || x>=L[i][2])continue;\r\n            if(miny>maxy)continue;\r\n            ans+=maxy-miny+1;\r\n        }\r\n    }\r\n};\r\nint main(){\r\n    pw[0]=1;rep(i,1,LIM)pw[i]=pw[i-1]*base;\r\n    input();\r\n\r\n    ACAM::build();\r\n    ACAM::dfs(0,0);   \r\n    bit.reset(ACAM::dfntot);\r\n    \r\n    Tree::dfs1(1);\r\n    Tree::dfs2(1,1);\r\n\r\n    rep(i,1,q){\r\n        cin>>x[i]>>y[i]>>k[i];\r\n        int lca=Tree::lca(x[i],y[i]);\r\n        //x[i]->lca\r\n        int d=depth[x[i]]-depth[lca];\r\n        if(d >= len[k[i]]){\r\n            opt[x[i]].push_back({-k[i],1,i});\r\n            opt[upfind(x[i],d-len[k[i]]+1)].push_back({-k[i],-1,i});\r\n        }\r\n        //lca->y[i]\r\n        d=depth[y[i]]-depth[lca];\r\n        if(d >= len[k[i]]){\r\n            opt[y[i]].push_back({k[i],1,i});\r\n            opt[upfind(y[i],d-len[k[i]]+1)].push_back({k[i],-1,i});\r\n        }\r\n\r\n        Task2::solve(x[i],y[i],lca,k[i],ans[i]);\r\n    }\r\n    Task1::solve();\r\n\r\n    output();\r\n    return 0;\r\n}\r\nvoid input(){\r\n    ios::sync_with_stdio(false);\r\n    cin>>n>>m>>q;\r\n    rep(i,1,n-1){\r\n        int u,v;char ch;cin>>u>>v>>ch;\r\n        e[u].push_back({v,ch-'a'});\r\n        e[v].push_back({u,ch-'a'});\r\n    }\r\n    rep(i,1,m){\r\n        cin>>s[i];rs[i]=s[i];reverse(rs[i].begin(),rs[i].end());\r\n        len[i]=s[i].length();\r\n        s[i]=\" \"+s[i];rs[i]=\" \"+rs[i];\r\n        p[i]=ACAM::insert(s[i],len[i]);\r\n        rp[i]=ACAM::insert(rs[i],len[i]);\r\n        kmp[i].calc(s[i],len[i]);\r\n        rkmp[i].calc(rs[i],len[i]);\r\n        sa[i].calc(s[i],len[i]);\r\n        rsa[i].calc(rs[i],len[i]);\r\n    }\r\n}\r\nvoid output(){rep(i,1,q)cout<<ans[i]<<\"\\n\";}//10990811230118489680"
}