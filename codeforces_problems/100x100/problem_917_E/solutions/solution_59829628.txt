{
    "id": 59829628,
    "contestId": 917,
    "creationTimeSeconds": 1567287865,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "vjudge3"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1154,
    "memoryConsumedBytes": 366592000,
    "source": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mx 300005\n#define pb push_back\n#define dx mx*20\nint tree[dx],lefto[dx],righto[dx],nw;\nstruct ext{\n  int len,link;\n  map<char,int>next;\n};\next st[mx];\nint sz, last;\nvoid sa_init()\n{\n    sz = last = 0;\n    st[0].len = 0;\n    st[0].link = -1;\n    ++sz;\n}\nint update(int node,int st,int en,int g)\n{\n     int ps=++nw;\n     if(st==en)\n     {\n         tree[ps]=tree[node]+1;\n         return ps;\n     }\n     lefto[ps]=lefto[node];\n     righto[ps]=righto[node];\n     int mid=(st+en)>>1;\n     if(g<=mid)lefto[ps]=update(lefto[node],st,mid,g);\n     else righto[ps]=update(righto[node],mid+1,en,g);\n     tree[ps]=tree[lefto[ps]]+tree[righto[ps]];\n     return ps;\n}\nint query(int node,int node2,int st,int en,int l,int r)\n{\n    if(st>=l and en<=r)return tree[node]-tree[node2];\n    int mid=(st+en)>>1;\n    int ret=0;\n    if(l<=mid)ret+=query(lefto[node],lefto[node2],st,mid,l,r);\n    if(r>mid)ret+=query(righto[node],righto[node2],mid+1,en,l,r);\n    return ret;\n}\nint dp[mx][26];\nint extend (char c,int last)\n{\n    if(dp[last][c-97]!=-1)return dp[last][c-97];\n    int cur = sz++;\n    st[cur].len = st[last].len + 1;\n    int p;\n    for (p=last; p!=-1 && !st[p].next.count(c); p=st[p].link)\n        st[p].next[c] = cur;\n    if (p == -1)\n        st[cur].link = 0;\n    else\n    {\n        int q = st[p].next[c];\n        if (st[p].len + 1 == st[q].len)\n            st[cur].link = q;\n        else\n        {\n            int clone = sz++;\n            st[clone].len = st[p].len + 1;\n            st[clone].next = st[q].next;\n            st[clone].link = st[q].link;\n            for (; p!=-1 && st[p].next[c]==q; p=st[p].link)\n                st[p].next[c] = clone;\n            st[q].link = st[cur].link = clone;\n        }\n    }\n    return dp[last][c-97]= cur;\n}\nstruct st2{\n  int g,lev,id,bol;\n  st2(){}\n  st2(int _g,int _lev,int _id,int _bol)\n  {\n      g=_g;\n      lev=_lev;\n      id=_id;\n      bol=_bol;\n  }\n};\nint top[mx],P[mx];\nvector<st2>danda[mx];\nvoid upchain(int lev,int node,int c)\n{\n   //  int rrr=node;\n    // if(rrr==7)cout<<st[7].len<<endl;\n    while(node)\n    {\n        if(st[node].len==0)return ;\n\n        int g=lev-st[node].len;\n        assert(g>=1);\n      //  if(rrr==7&&lev==5)cout<<top[node]<<\" \"<<node<<\" \"<<st[node].len<<\" \"<<P[node]<<\" \"<<g<<endl;\n        if(c==-1)\n            g=1e8;\n        danda[top[node]].pb(st2(g,lev,-1,-1));\n        node=P[top[node]];\n    }\n}\nint mini(int v)\n{\n   if(v==0)return 0;\n   return st[st[v].link].len+1;\n}\nvoid query_chain(int node,int lev,int lc,int q,int bol,int len)\n{\n    while(node)\n    {\n\n        int k=min(st[node].len,len);\n        //if(lev==3)cout<<k<<endl;\n      //  cout<<st[node].len<<\" \"<<lev<<\" \"<<lc<<\" \"<<len<<\" \"<<top[node]<<\" \"<<node<<endl;\n        if(k==0)return ;\n        int g=min(lc+k,lev);\n       // if(g-lc>=mini(top[node]))\n            danda[top[node]].pb(st2(lc,g,q,bol));\n        node=P[top[node]];\n    }\n}\nint pos,start[mx],endo[mx];\nstruct st1{\n  int node,lev,id;\n  st1(){}\n  st1(int _node,int _lev,int _id)\n  {\n     node=_node;\n     lev=_lev;\n     id=_id;\n  }\n};\nvector<st1>ques[mx];\nstruct st3{\n  int id,bol,node,lc;\n  st3(){}\n  st3(int _node,int _lc,int _id,int _bol)\n  {\n     node=_node;\n     lc=_lc;\n     id=_id;\n     bol=_bol;\n  }\n};\nvector<st3>half[mx];\nvector<int>liqu[mx];\nint root[mx],ans[mx];\nvector<int>vc[mx];\nvector<char>cost[mx];\nvoid dfs(int v,int par,int prev,char c,int lev)\n{\n    root[lev]=root[lev-1];\n    if(v>1)\n    {\n        prev=st[prev].next[c];\n        assert(prev!=0);\n     //   if(v==4)cout<<prev<<\" \"<<start[prev]<<endl;\n        root[lev]=update(root[lev],1,pos,start[prev]);\n        upchain(lev,prev,1);\n    }\n  //  if(v==4)cout<<prev<<endl;\n    for(int i=0; i<ques[v].size(); i++)\n    {\n        int nd=ques[v][i].node;\n        int le=ques[v][i].lev;\n        int id=ques[v][i].id;\n      //  cout<<nd<<\" \"<<start[nd]<<\" \"<<id<<\" \"<<le<<endl;\n        int g=query(root[lev],root[le-1],1,pos,start[nd],endo[nd]);\n        ans[id]+=g;\n       // cout<<g<<endl;\n    }\n    for(int i=0; i<half[v].size(); i++)\n    {\n        int id=half[v][i].id;\n        int bol=half[v][i].bol;\n        int node=half[v][i].node;\n        int lc=half[v][i].lc;\n        query_chain(node,lev,lc,id,bol,liqu[v][i]);\n    }\n    for(int i=0; i<vc[v].size(); i++)\n    {\n        int w=vc[v][i];\n        if(w==par)continue;\n        dfs(w,v,prev,cost[v][i],lev+1);\n\n    }\n    if(v>1)\n    {\n        upchain(lev,prev,-1);\n    }\n}\nint bap[mx][20],L[mx],len;\nvoid dfs2(int v,int par, char c,int last,int lev)\n{\n     bap[v][0]=par;\n     L[v]=lev;\n     len=max(len,lev);\n     if(v>1)\n     {\n        last=extend(c,last);\n     }\n     for(int i=0;i<vc[v].size();i++)\n     {\n         int w=vc[v][i];\n         if(w==par)continue;\n         dfs2(w,v,cost[v][i],last,lev+1);\n     }\n}\nint maxi[mx],siz[mx];\nvector<int>ac[mx];\nvoid dfs3(int v)\n{\n    start[v]=++pos;\n    maxi[v]=-1;\n    for(int i=0;i<ac[v].size();i++)\n    {\n         int w=ac[v][i];\n         dfs3(w);\n         if(maxi[v]==-1)maxi[v]=w;\n         else if(siz[maxi[v]]<siz[w])\n         {\n            maxi[v]=w;\n         }\n         siz[v]+=siz[w];\n    }\n    endo[v]=pos;\n    siz[v]++;\n}\nvoid hld(int v,int par,int r)\n{\n\n    if(r==-1)top[v]=v;\n    else top[v]=r;\n    P[v]=par;\n    if(maxi[v]!=-1)hld(maxi[v],v,top[v]);\n    for(int i=0;i<ac[v].size();i++)\n    {\n        int w=ac[v][i];\n        if(w==maxi[v])continue;\n        hld(w,v,-1);\n    }\n}\nint tree2[dx];\nvoid update2(int node,int st,int en,int l,int g)\n{\n     if(st==en)\n     {\n         tree2[node]=g;\n         return ;\n     }\n     int mid=(st+en)>>1;\n     if(l<=mid)update2(node*2,st,mid,l,g);\n     else update2(node*2+1,mid+1,en,l,g);\n     tree2[node]=min(tree2[node*2],tree2[node*2+1]);\n}\nint query2(int node,int st,int en,int g,int l)\n{\n    if(tree2[node]>g)return -1;\n    if(st>l)return -1;\n    if(st==en)\n    {\n      return st;\n    }\n    int mid=(st+en)>>1;\n    int r=query2(node*2+1,mid+1,en,g,l);\n    if(r>-1)return r;\n    return query2(node*2,st,mid,g,l);\n}\nint create[mx][2];\nvoid sim(st2 ps)\n{\n    int lev=ps.lev;\n    int g=ps.g;\n  //  cout<<lev<<endl;\n   // if(ps.lev==3)cout<<ps.g<<\" \"<<lev<<endl;\n    int ans=query2(1,1,len,g,lev);\n    // cout<<lev<<\" \"<<ans<<\" \"<<ps.bol<<endl;\n    if(ans>lev||ans<=g)return ;\n    int id=ps.id;\n    int bol=ps.bol;\n    create[id][bol]=max(create[id][bol],ans-g);\n}\nvoid simulation(int n)\n{\n    for(int i=0;i<n;i++)\n    {\n       // if(i==0)continue;\n       if(danda[i].size()==0)continue;\n       //cout<<tree<<endl;\n     //   cout<<tree2[1]<<endl;\n        for(int j=0;j<danda[i].size();j++)\n        {\n           if(danda[i][j].bol>=0)\n           {\n              sim(danda[i][j]);\n              continue;\n           }\n           int lev=danda[i][j].lev;\n           int g=danda[i][j].g;\n           update2(1,1,len,lev,g);\n        }\n      //  cout<<tree2[i]<<endl;\n    }\n}\nint beg[mx][2],en[mx][2],obo[2];\nvector<int>trie[2][mx];\nvoid dfs5(int v,int bol)\n{\n    beg[v][bol]=++obo[bol];\n    for(int i=0;i<trie[bol][v].size();i++)\n    {\n        int w=trie[bol][v][i];\n        dfs5(w,bol);\n    }\n    en[v][bol]=obo[bol];\n}\nvector<int>sub[mx];\nint update3(int node,int st,int en,int l,int r)\n{\n    int ps=++nw;\n    assert(nw<dx);\n    tree[ps]=tree[node];\n    lefto[ps]=lefto[node];\n    righto[ps]=righto[node];\n    if(st>=l and en<=r)\n    {\n        tree[ps]+=1;\n     //   if(l==5&&r==5)cout<<tree[ps]<<\" \"<<ps<<endl;\n        return ps;\n    }\n    int mid=(st+en)>>1;\n    if(mid>=l)lefto[ps]=update3(lefto[node],st,mid,l,r);\n     if(mid<r)righto[ps]=update3(righto[node],mid+1,en,l,r);\n     return ps;\n}\nint vis2[mx],casio=1;\nvoid run_sim(int v,int par)\n{\n    root[v]=root[par];\n   // cout<<v<<endl;\n    for(int i=0;i<sub[v].size();i++)\n    {\n        int w=sub[v][i];\n      //  if(v==1)cout<<beg[w][1]<<\" s \"<<w<<\" \"<<en[w][1]<<endl;\n        root[v]=update3(root[v],1,obo[1],beg[w][1],en[w][1]);\n    }\n    for(int i=0;i<trie[0][v].size();i++)\n    {\n         int w=trie[0][v][i];\n         if(vis2[w]!=casio)continue;\n         run_sim(w,v);\n    }\n}\nint query3(int node,int st,int en,int l)\n{\n    int ret=tree[node];\n    //cout<<l<<\" \"<<tree[node]<<\" xvv\"<<node<<\"xvx \"<<lefto[node]<<endl;\n    if(st==en)return ret;\n    int mid=(st+en)>>1;\n    if(l<=mid)ret+=query3(lefto[node],st,mid,l);\n    else ret+=query3(righto[node],mid+1,en,l);\n    return ret;\n}\n#define tii pair<pii,int>\nmap<pii,int>name[2];\nint cnt[2];\nint prime[]={103,10007};\nint mod=784568360,mod2=820925358;\nint crt(int sum,int sum2,int bol)\n{\n   if(name[bol][mp(sum,sum2)]==0)\n   {\n      name[bol][mp(sum,sum2)]=++cnt[bol];\n   }\n   return name[bol][mp(sum,sum2)];\n\n}\nint lps[mx];\nvector<int>linear[2][mx];\nint vis[mx][2];\n#define ll long long\nvoid func(string pat,int bol,int id)\n{\n    int M=pat.size();\n    linear[bol][id].resize(M+2);\n    ll sum=0,sum2=0;\n    for(int i=0;i<M;i++)\n    {\n        sum=sum*prime[0]+pat[i]-96;\n        sum%=mod;\n        sum2=sum2*prime[1]+pat[i]-96;\n        sum2%=mod2;\n        int g=crt(sum,sum2,bol);\n        linear[bol][id][i+1]=g;\n    }\n     int len = 0;\n\n    lps[0] = 0;\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        else\n        {\n            if (len != 0) {\n                len = lps[len - 1];\n            }\n            else\n            {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    for(int i=0;i<M;i++)\n    {\n        int r=linear[bol][id][i+1];\n        if(vis[r][bol])continue;\n        vis[r][bol]=1;\n        int g=lps[i];\n\n        int x=linear[bol][id][g];\n       // if(bol==0)cout<<g<<\" \"<<i<<\" \"<<x<<\" \"<<r<<endl;\n        trie[bol][x].pb(r);\n    }\n}\nvoid init(int n)\n{\n   for (int j = 1; (1 << j) <=n; j++)\n         for (int i = 1; i <= n; i++)\n             if (bap[i][j - 1] != -1)\n                 bap[i][j] = bap[bap[i][j - 1]][j - 1];\n\n}\nint lca_query(int p,int q){\nint tmp, log, i;\n\n      if (L[p] < L[q])\n          tmp = p, p = q, q = tmp;\n        log=1;\n      while(1) {\n        int next=log+1;\n        if((1<<next)>L[p])break;\n        log++;\n      }\n        for (i = log; i >= 0; i--)\n          if (L[p] - (1 << i) >= L[q])\n              p = bap[p][i];\n      if (p == q)\n          return p;\n        for (i = log; i >= 0; i--)\n          if (bap[p][i] != -1 && bap[p][i] != bap[q][i])\n              p = bap[p][i], q = bap[q][i];\n       return bap[p][0];\n}\nstring my[mx];\nchar str2[mx];\nint hf[mx][2],dir[mx][2],lin[mx][2];\nint qui[mx];\nmap<string,int>coun;\nint ara[mx];\nvector<int>temp[mx];\nint main()\n{\n    int i,j,k,l,m,n,q,ff;\n    for(int i=1;i<dx;i++)tree2[i]=1e8;\n    memset(dp,-1,sizeof dp);\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d%s\",&l,&k,str2);\n        vc[l].pb(k);\n        vc[k].pb(l);\n        cost[l].pb(str2[0]);\n        cost[k].pb(str2[0]);\n    }\n     sa_init();\n    memset(bap,-1,sizeof bap);\n    dfs2(1,-1,0,0,1);\n    for(int kk=1;kk<=m;kk++)\n    {\n       scanf(\"%s\",str2);\n       my[kk]+=str2;\n       //coun[str2]++;\n    //   cout<<endl;\n       int l=strlen(str2);\n       int cur=0;\n       int ck=1,len=0;\n       for(int i=l-1;i>=0;i--)\n       {\n      //     cout<<cur<<endl;\n           char c=str2[i];\n           int prv=len;\n           if(st[cur].next.find(c)==st[cur].next.end())ck=0;\n           else{\n             len++;\n             cur=st[cur].next[c];\n             continue;\n           }\n            while(cur>-1&&st[cur].next.find(c)==st[cur].next.end())\n           {\n              cur=st[cur].link;\n           }\n           if(cur==-1)\n           {\n             len=0;\n             cur=0;\n             continue;\n           }\n           len=min(st[cur].len,prv);\n           len++;\n           cur=st[cur].next[c];\n       }\n     //  cout<<cur<<endl;\n     //  cout<<ck<<endl;\n       hf[kk][0]=cur;\n       lin[kk][0]=len;\n       if(ck==0)cur=0;\n       dir[kk][0]=cur;\n       cur=0,ck=1,len=0;\n        for(int i=0;str2[i];i++)\n       {\n             char c=str2[i];\n             int prv=len;\n           if(st[cur].next.find(c)==st[cur].next.end())ck=0;\n           else{\n             len++;\n             cur=st[cur].next[c];\n             continue;\n           }\n            while(cur>-1&&st[cur].next.find(c)==st[cur].next.end())\n           {\n              cur=st[cur].link;\n           }\n           if(cur==-1)\n           {\n             len=0;\n             cur=0;\n             continue;\n           }\n            len=min(st[cur].len,prv);\n           len++;\n           cur=st[cur].next[c];\n       }\n      // cout<<cur<<\" \"<<st[cur].len<<\" \"<<len<<endl;\n       hf[kk][1]=cur;\n       lin[kk][1]=len;\n       if(ck==0)cur=0;\n       dir[kk][1]=cur;\n    }\n    init(n);\n    for(int i=1;i<sz;i++)\n    {\n        ac[st[i].link].pb(i);\n    }\n    dfs3(0);\n    hld(0,0,-1);\n  //  cout<<endl;\n  //  cout<<top[2]<<endl;\n\n   // cout<<\"df\"<<endl;\n //  cout<<L[7]<<endl;\n    for(int i=1;i<=q;i++)\n    {\n       scanf(\"%d%d%d\",&l,&k,&j);\n       qui[i]=j;\n       int lc=lca_query(l,k);\n       if(l==lc)\n       {\n         int x=L[lc]+my[j].size();\n         //cout<<x<<\" \"<<dir[j][1]<<endl;\n         if(dir[j][1]&&x<=L[k])ques[k].pb(st1(dir[j][1],x,i));\n         continue;\n       }\n       if(k==lc)\n       {\n          int x=L[lc]+my[j].size();\n          //x--;\n          if(dir[j][0]&&x<=L[l])ques[l].pb(st1(dir[j][0],x,i));\n          continue;\n       }\n        int x=L[lc]+my[j].size();\n        if(dir[j][0]&&x<=L[l])ques[l].pb(st1(dir[j][0],x,i));\n        if(dir[j][1]&&x<=L[k]){\n     //   cout<<\"sdf\"<<endl;\n        ques[k].pb(st1(dir[j][1],x,i));\n        }\n        if(hf[j][0])half[l].pb(st3(hf[j][0],L[lc],i,0)),liqu[l].pb(lin[j][0]);\n        if(hf[j][1])half[k].pb(st3(hf[j][1],L[lc],i,1)),liqu[k].pb(lin[j][1]);\n    }\n    dfs(1,-1,0,0,1);\n    simulation(sz);\n  //  cout<<create[1][0]<<\" \"<<create[1][1]<<\" \"<<ans[1]<<endl;\n  //  cout<<ans[5]<<\"sfd\"<<endl;\n   // cout<<create[1][0]<<\" \"<<create[1][1]<<endl;\n    for(int i=1;i<=m;i++)\n    {\n       ll sum=0,sum2=0;\n       func(my[i],0,i);\n       reverse(my[i].begin(),my[i].end());\n       func(my[i],1,i);\n    }\n  //  cout<<nw<<endl;\n    for(int i=0;i<=nw;i++)\n    {\n        tree[i]=0;\n        lefto[i]=0;\n        righto[i]=0;\n    }\n    nw=0;\n    dfs5(0,0);\n    dfs5(0,1);\n    for(int i=1;i<=q;i++)\n    {\n       if(create[i][0]==0||create[i][1]==0)continue;\n       j=qui[i];\n       temp[j].pb(i);\n    }\n    //cout<<nw<<endl;\n    for(int i=1;i<=m;i++)\n    {\n      //  if(i!=3)continue;\n       l=my[i].size();\n       casio++;\n       vector<int>tp;\n     //  cout<<temp[i].size()<<endl;\n       for(int j=1;j<l;j++)\n       {\n           int g=linear[0][i][j];\n           tp.pb(g);\n           int h=linear[1][i][l-j];\n           vis2[g]=casio;\n         //  cout<<g<<\" \"<<h<<endl;\n           sub[g].pb(h);\n       }\n       int g=linear[0][i][l];\n       vis2[g]=casio;\n       tp.pb(g);\n       run_sim(0,0);\n      // cout<<nw<<endl;\n     //  cout<<tp.size()<<endl;\n       for(j=0;j<temp[i].size();j++)\n       {\n          int q=temp[i][j];\n          int g=linear[0][i][create[q][0]];\n      //  cout<<tree[root[g]]<<endl;\n          int h=linear[1][i][create[q][1]];\n        //  cout<<g<<\" \"<<h<<endl;\n       //   cout<<g<<\" \"<<h<<\" \"<<create[q][0]<<\" \"<<create[q][1]<<endl;\n       //   cout<<beg[h][1]<<endl;\n          ans[q]+=query3(root[g],1,obo[1],beg[h][1]);\n       }\n       for(int j=0;j<tp.size();j++)\n       {\n          int w=tp[j];\n          sub[w].clear();\n       }\n       for(int j=0;j<=nw;j++)\n       {\n           //sub[i].clear();\n           tree[j]=0;\n           lefto[j]=0;\n           righto[j]=0;\n       }\n       nw=0;\n    }\n\n    for(int i=1;i<=q;i++)\n    {\n     //  if(i!=2)continue;\n       printf(\"%d\\n\",ans[i]);\n    }\n    //fsdhdfjsf\n}\n//784568360, 820925358\n\n/*\n8 1 1\n1 2 a\n2 3 a\n3 4 a\n1 5 a\n5 6 a\n6 7 a\n7 8 a\naaaa\n4 8 1\n\n\n\n*/\n\n   \t\t\t\t\t      \t\t\t\t\t\t\t\t   \t\t\t"
}