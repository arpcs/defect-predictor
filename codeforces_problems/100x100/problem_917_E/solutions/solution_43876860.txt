{
    "id": 43876860,
    "contestId": 917,
    "creationTimeSeconds": 1538792913,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "_Happy_New_Year_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 982,
    "memoryConsumedBytes": 194355200,
    "source": "#ifdef __APPLE__\n#include \"head.h\"\n#else\n#include <bits/stdc++.h>\n#endif\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\n#define reset(a)memset(a,0,sizeof a)\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define eef(i,x)for(int i=head[x],y=e[i].to;y;i=e[i].next,y=e[i].to)\nint read(){char c=getchar();int d=0,f=1;for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;for(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());return d*f;}\nchar Read(){char c=getchar();while(c<'a'||c>'z')c=getchar();return c;}\ntypedef pair<int,int>PII;\ntypedef long long LL;\nconst double pi=acos(-1);\nconst int N=200100;\nint n,m,q;\nint cnt,head[N],L[N],R[N],mk[N];char s[N];\nstruct edge{int to,next,c;}e[N];\nvoid addedge(int x,int y,int c){\n\te[++cnt]=(edge){y,head[x],c};head[x]=cnt;\n}\nstruct node1{\n\tint ch[26],nxt[26],fail,fa,id;\n}a1[N]; int tot1, dep1[N], mk1[N];\nvoid inserta1(int l,int r,int id){\n\tint t=1;\n\tref(i,l,r){\n\t\tint &tt=a1[t].ch[s[i]-'a'];\n\t\tif(!tt)tt=++tot1,a1[tt].fa=t,dep1[tt]=dep1[t]+1; \n\t\tt=tt;\n\t}\n\tif(!a1[t].id)a1[t].id=id, mk1[id]=t;\n\tmk[id]=a1[t].id;\n}\nint q1[N], qc1[N];\nvector<int> e1[N]; int pos1,dfn1[N][2];\ntypedef vector<int>::iterator iti;\nvoid dfsfail(int x){\n\tdfn1[x][0]=++pos1;\n\tfor(iti it=e1[x].begin();it!=e1[x].end();it++)\n\t\tdfsfail(*it);\n\tdfn1[x][1]=pos1;\n}\nvoid inita1(){\n\tref(i,0,25)a1[0].ch[i]=1;\n\tint h=0,t=0; q1[++t]=1; qc1[t]=0;\n\twhile(h++<t){\n\t\tint u=q1[h],c=qc1[h];\n\t\tref(i,0,25)if(a1[u].ch[i])\n\t\t\tq1[++t]=a1[u].ch[i],qc1[t]=i;\n\t\tif(u==1)continue;\n\t\tint v=a1[a1[a1[u].fa].nxt[c]].ch[c];\n\t\tref(i,0,25)if(a1[v].ch[i])a1[u].nxt[i]=v;\n\t\t\telse a1[u].nxt[i]=a1[v].nxt[i];\n\t\ta1[u].fail=v;\n\t\te1[a1[u].fail].push_back(u);\n\t}\n\tdfsfail(1);\n}\nint Fa[N], Dep[N];\nint sz[N], p[N];\nvoid dfs(int f,int x){\n\tp[++p[0]]=x;sz[x]=1;\n\teef(i,x)if(y!=f&&!Dep[y])dfs(x,y),sz[x]+=sz[y];\n}\nvoid solve(int la,int x){\n\tp[0]=0; dfs(0,x); int Sz=sz[x]; x=0;\n\tref(i,1,p[0])if(sz[p[i]]>Sz/2&&(!x||sz[p[i]]<sz[x]))x=p[i];\n\tFa[x]=la; Dep[x]=Dep[la]+1;\n\teef(i,x)if(!Dep[y])solve(x,y);\n}\nint lca(int x,int y){\n\tif(Dep[x]<Dep[y])swap(x,y);\n\twhile(Dep[x]>Dep[y])x=Fa[x];\n\twhile(x!=y)x=Fa[x],y=Fa[y];\n\treturn x;\n}\nint ans[N];\nstruct qint{int x,y,L,z,id;PII xx,yy;}Q[N];\nbool cmp(qint a,qint b){return a.L<b.L;}\nbool cmpz(qint a,qint b){return a.z<b.z||(a.z==b.z&&a.x<b.x);}\nvector<PII> sq[N];\ntypedef vector<PII>::iterator itpii;\nint t1[N+1];\nvoid upd1(int x,int s){\n\tfor(;x<=N;x+=x&-x)t1[x]+=s;\n}\nint ask1(int x){int s=0;\n\tfor(;x>=1;x-=x&-x)s+=t1[x];return s;\n}\nvoid dfs1(int f,int x,int nd,int lim){\n\tupd1(dfn1[nd][0],1);\n\tif(!sq[x].empty()){\n\t\tfor(itpii it=sq[x].begin();it!=sq[x].end();it++){\n\t\t\tint id=(*it).fi,sd=(*it).se;\n\t\t\tans[id]+=ask1(dfn1[sd][1])-ask1(dfn1[sd][0]-1);\n\t\t}\n\t\tsq[x].clear();\n\t}\n\teef(i,x)if(y!=f&&Dep[y]>=lim){\n\t\tint c=e[i].c;\n\t\tint Nd=a1[nd].ch[c];if(!Nd)Nd=a1[a1[nd].nxt[c]].ch[c];\n\t\tdfs1(x,y,Nd,lim);\n\t}\n\tupd1(dfn1[nd][0],-1);\n}\nvoid work1(){\n\treset(a1); reset(dep1); reset(mk1); reset(dfn1);\n\tpos1=0;\n\tref(i,0,tot1)e1[i].clear();\n\ttot1=1; dep1[tot1]=1;\n\tref(i,1,m)inserta1(L[i],R[i],i);\n\tinita1();\n\tfor(int x=1;x<=q;){\n\t\tint L=Q[x].L;\n\t\tint y=x;while(y<q&&Q[y+1].L==L)y++;\n\t\tref(i,x,y)sq[Q[i].y].push_back(mp(Q[i].id,mk1[mk[Q[i].z]]));\n\t\tdfs1(0,L,1,Dep[L]);\n\t\tx=y+1;\n\t}\n}\nstruct node2{\n\tint ch[26],fa,len;\n}a2[N]; int tot2, cur2, p2[N];\nint ch2[N][26], dtot2; PII dfn2[N];\nPII pos2x[N], pos2y[N];\nvoid inserta2(int c,int l,int id){\n\tif (a2[cur2].ch[c]){\n\t\tint q=cur2,qc=a2[cur2].ch[c];\n\t\tif (a2[qc].len==a2[q].len+1) cur2=qc;\n        else{\n\t\t\t++tot2;\n\t\t\ta2[tot2].len=a2[q].len+1;\n\t\t\tmemcpy(a2[tot2].ch,a2[qc].ch,sizeof a2[qc].ch);\n\t\t\ta2[tot2].fa=a2[qc].fa; a2[qc].fa=tot2;\n\t\t\tfor(;q&&a2[q].ch[c]==qc;q=a2[q].fa) a2[q].ch[c]=tot2;\n\t\t\tcur2=tot2;\n        }\n        return;\n    }\n\n\tint p=cur2; cur2=++tot2;\n\ta2[cur2].len=l;\n\tint q=p;\n\tfor(;q&&!a2[q].ch[c];q=a2[q].fa)a2[q].ch[c]=cur2;\n\tif(!q)a2[cur2].fa=1;else{\n\t\tint qc=a2[q].ch[c];\n\t\tif(a2[qc].len==a2[q].len+1)a2[cur2].fa=qc;else{\n\t\t\t++tot2;\n\t\t\ta2[tot2].len=a2[q].len+1;\n\t\t\tmemcpy(a2[tot2].ch,a2[qc].ch,sizeof a2[qc].ch);\n\t\t\ta2[tot2].fa=a2[qc].fa; a2[qc].fa=tot2; a2[cur2].fa=tot2;\n\t\t\tfor(;q&&a2[q].ch[c]==qc;q=a2[q].fa) a2[q].ch[c]=tot2;\n\t\t}\n\t}\n\tp2[cur2]=id;\n}\nvoid Dfs2(int x){\n\tdfn2[x].fi=dfn2[x].se=++dtot2;\n\tref(i,0,25){ int u=ch2[x][i];if(u)Dfs2(u),dfn2[x].se=dfn2[u].se; }\n}\nvoid dfs2(int f,int x,int dep,int nd,int lim){\n\tif(!sq[x].empty()){\n\t\tfor(itpii it=sq[x].begin();it!=sq[x].end();it++)\n\t\t\tQ[(*it).fi].xx=mp(dfn2[nd].fi,abs(dep)-1);\n\t\tsq[x].clear();\n\t}\n\teef(i,x)if(y!=f&&Dep[y]>=lim){\n\t\tif(dep<0) { dfs2(x,y,dep,nd,lim);continue; }\n\t\tint c=e[i].c;\n\t\tint Nd=nd,Dep=dep+1;\n\t\tif((dep-1)==a2[nd].len){\n\t\t\tif(ch2[nd][c])Nd=ch2[nd][c];else Dep=-dep;\n\t\t}else if(c!=s[p2[nd]-(dep-1)]-'a')Dep=-dep;\n\t\tdfs2(x,y,Dep,Nd,lim);\n\t}\n}\nint tp2[N], ts2[N];\nvoid work2(){\n\tcur2=1; tot2=1; dtot2=0;\n\treset(a2); reset(pos2x); reset(tp2); reset(ts2); reset(p2); reset(ch2); reset(dfn2);\n\tref(i,1,m){\n\t\tcur2=1;\n\t\tref(j,L[i],R[i]){\n\t\t\tinserta2(s[j]-'a',j-L[i]+1,j);\n\t\t\tpos2x[j]=mp(cur2,0);\n\t\t}\n\t}\n\tref(i,2,tot2)tp2[a2[i].len]++;\n\tref(i,1,tot2)tp2[i]+=tp2[i-1];\n\tref(i,2,tot2)ts2[tp2[a2[i].len]--]=i;\n\tdef(i,tot2-1,1)p2[a2[ts2[i]].fa]=p2[ts2[i]];\n\tref(i,2,tot2)ch2[a2[i].fa][s[p2[i]-a2[a2[i].fa].len]-'a']=i;\n\tDfs2(1);\n\tref(i,1,m)ref(j,L[i],R[i]) pos2x[j]=dfn2[pos2x[j].fi];\n\tfor(int x=1;x<=q;){\n\t\tint L=Q[x].L;\n\t\tint y=x;while(y<q&&Q[y+1].L==L)y++;\n\t\tref(i,x,y)sq[Q[i].x].push_back(mp(i,0));\n\t\tdfs2(0,L,1,1,Dep[L]);\n\t\tx=y+1;\n\t}\n}\nconst int NN=N*10;\npair<PII,int> opr[NN]; int oprn;\nint t2[NN+1];\nvoid upd2(int x,int s){\n\tfor(;x<=NN;x+=x&-x)t2[x]+=s;\n}\nint ask2(int x){int s=0;\n\tfor(;x>=1;x-=x&-x)s+=t2[x];return s;\n}\npair<PII,PII> w[NN]; int wn;\nvoid solve2(){\n\tref(i,1,m)ref(j,L[i],R[i]){\n\t\tw[++wn]=mp(mp(pos2x[j].fi,j-L[i]+1),mp(j,1));\n\t\tw[++wn]=mp(mp(pos2x[j].se,1e9),mp(j,2));\n\t\tw[++wn]=mp(mp(pos2y[j].fi,j-L[i]+1),mp(j,3));\n\t\tw[++wn]=mp(mp(pos2y[j].se,1e9),mp(j,4));\n\t}\n\tref(i,1,q)w[++wn]=mp(Q[i].xx,mp(i,-1)),w[++wn]=mp(Q[i].yy,mp(i,-2));\n\tsort(w+1,w+wn+1);\n\tint tot=0; ref(i,1,wn){\n\t\ttot+=(i==1||w[i].fi!=w[i-1].fi); PII ct=w[i].se;\n\t\tif(ct.se==1)pos2x[ct.fi].fi=tot;\n\t\tif(ct.se==2)pos2x[ct.fi].se=tot;\n\t\tif(ct.se==3)pos2y[ct.fi].fi=tot;\n\t\tif(ct.se==4)pos2y[ct.fi].se=tot;\n\t\tif(ct.se==-1)Q[ct.fi].x=tot;if(ct.se==-2)Q[ct.fi].y=tot;\n\t}\n\tsort(Q+1,Q+q+1,cmpz);\n\tfor(int x=1;x<=q;){\n\t\tint z=Q[x].z;\n\t\tint y=x;while(y<q&&Q[y+1].z==z)y++;\n\t\toprn=0;\n\t\tref(i,L[z],R[z]-1){\n\t\t\tPII A=pos2x[i],B=pos2y[L[z]+R[z]-1-i];\n\t\t\topr[++oprn]=mp(mp(A.fi,B.fi),1);\n\t\t\topr[++oprn]=mp(mp(A.fi,B.se+1),-1);\n\t\t\topr[++oprn]=mp(mp(A.se+1,B.fi),-1);\n\t\t\topr[++oprn]=mp(mp(A.se+1,B.se+1),1);\n\t\t}\n\t\tsort(opr+1,opr+oprn+1);\n\t\tint cnt=1;\n\t\tref(i,x,y){\n\t\t\twhile(cnt<=oprn&&opr[cnt].fi.fi<=Q[i].x)\n\t\t\t\tupd2(opr[cnt].fi.se+1,opr[cnt].se),cnt++;\n\t\t\tans[Q[i].id]+=ask2(Q[i].y+1);\n\t\t}\n\t\tref(i,1,cnt-1)upd2(opr[i].fi.se+1,-opr[i].se);\n\t\tx=y+1;\n\t}\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"1.in\",\"r\",stdin);\n\tfreopen(\"1.out\",\"w\",stdout);\n#endif\n\tn=read(),m=read(),q=read();\n\tref(i,2,n){\n\t\tint x=read(),y=read();char c=Read();\n\t\taddedge(x,y,c-'a');addedge(y,x,c-'a');\n\t}\n\tref(i,1,m){\n\t\tL[i]=R[i-1]+1;\n\t\tscanf(\"%s\",s+L[i]);\n\t\tR[i]=L[i]+strlen(s+L[i])-1;\n\t}\n\tsolve(0,1);\n\tref(i,1,q){\n\t\tint x=read(),y=read(),z=read();\n\t\tQ[i].x=x;Q[i].y=y;Q[i].z=z;\n\t\tQ[i].L=lca(Q[i].x,Q[i].y);Q[i].id=i;\n\t}\n\tsort(Q+1,Q+q+1,cmp);\n\t//work1\n\twork1();\n\tref(i,1,m)ref(j,L[i],(L[i]+R[i])/2) swap(s[j],s[L[i]+R[i]-j]);\n\tref(i,1,q) swap(Q[i].x,Q[i].y);\n\twork1();\n\t//work2\n\twork2();\n\tref(i,1,m)ref(j,L[i],(L[i]+R[i])/2) swap(s[j],s[L[i]+R[i]-j]);\n\tref(i,1,q) swap(Q[i].x,Q[i].y), swap(Q[i].xx,Q[i].yy);\n\tmemcpy(pos2y,pos2x,sizeof pos2x);\n\twork2();\n\t//solve2\n\tsolve2();\n\tref(i,1,q)printf(\"%d\\n\",ans[i]);\n}\n\n"
}