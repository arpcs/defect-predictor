{
    "id": 72772162,
    "contestId": 917,
    "creationTimeSeconds": 1583742248,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "zx2003"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 732,
    "memoryConsumedBytes": 150528000,
    "source": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>V;\nconst int N=1e5+5,M=2e5+5,mo1=993244853,mo2=1e9+9;\nstruct P{int x,y;}mi[N];\ninline P operator*(const P&a,const P&b){return (P){int(1ll*a.x*b.x%mo1),int(1ll*a.y*b.y%mo2)};}\ninline P operator+(const P&a,const P&b){return (P){(a.x+b.x)%mo1,(a.y+b.y)%mo2};}\ninline P operator-(const P&a,const P&b){return (P){(a.x+mo1-b.x)%mo1,(a.y+mo2-b.y)%mo2};}\ninline bool operator==(const P&a,const P&b){return a.x==b.x && a.y==b.y;}\nint hib[N];\nint n,m,q,ans[N],x[N],y[N],z[N],l[N],i,p1[N],p2[N];\nstruct que{int x,i,k;};\nstruct BIT{\n\tint a[M],n;\n\tinline void ini(int nn){n=nn;memset(a+1,0,n<<2);}\n\tinline void add(int x,int v){for(;x<=n;x+=x&-x)a[x]+=v;}\n\tinline int ask(int x){int ans=0;for(;x;x-=x&-x)ans+=a[x];return ans;}\n}bi;\ntemplate<size_t N>struct tree{\n\tint n,be[N],en[N],dcnt,dfn[N],top[N],sz[N],ma[N],dad[N],dep[N];\n\tV e[N];\n\tvoid dfs1(int x,int fa){\n\t\tdfn[be[x]=++dcnt]=x;sz[x]=1;dad[x]=fa;dep[x]=dep[fa]+1;\n\t\tfor(int y:e[x])if(y!=fa){dfs1(y,x);sz[x]+=sz[y];if(sz[y]>sz[ma[x]])ma[x]=y;}\n\t\ten[x]=dcnt;\n\t}\n\tinline void gettop(int*top,int*ma){top[1]=1;for(int i=2,x;i<=n;++i)x=dfn[i],top[x]=ma[dad[x]]==x?top[dad[x]]:x;}\n\tinline void pre1(){dfs1(1,0);gettop(top,ma);}\n\tinline int lca(int x,int y){\n\t\tfor(;top[x]!=top[y];y=dad[top[y]])if(dep[top[x]]>dep[top[y]])swap(x,y);\n\t\treturn dep[x]<dep[y]?x:y;\n\t}\n};\nstruct GBT:tree<M>{\n\tint ch[M][2],qsz[M],son[M][26],rt,wd[M],bel[M];P su[M];\n\tinline void pre2(){\n\t\tint i;\n\t\tpre1();\n\t\tfor(i=1;i<=n;++i)qsz[i]=sz[i]-sz[ma[i]];\n\t\tfor(i=1;i<=n;++i)if(top[i]==i){\n\t\t\tstatic int st[N],suu[N];int w,x,j;\n\t\t\tfor(x=i,w=0;x;x=ma[x])st[++w]=x;\n\t\t\tfor(j=1;j<=w;++j)suu[j]=qsz[st[j-1]]+suu[j-1];\n\t\t\tfunction<int(int,int)>build=[&](int l,int r){\n\t\t\t\tif(l==r)return st[l];\n\t\t\t\tint m,mn=1<<30,i,z;\n\t\t\t\tfor(i=l;i<=r;++i){z=max(suu[i-1]-suu[l-1],suu[r]-suu[i]);if(z<mn)mn=z,m=i;}\n\t\t\t\tz=st[m];if(l<m)ch[z][0]=build(l,m-1);if(m<r)ch[z][1]=build(m+1,r);\n\t\t\t\treturn z;\n\t\t\t};\n\t\t\tx=build(1,w);for(j=1;j<=w;++j)bel[st[j]]=x;if(i==1)rt=x;\n\t\t}\n\t}\n\tinline void ini(int nn){\n\t\tint i;n=nn;\n\t\tfor(i=1;i<=n;++i)e[i].clear(),memset(ch[i],0,8),memset(son[i],0,104);dcnt=0;memset(ma+1,0,n<<2);\n\t}\n\tinline int find(int x,int l);\n}t2;\nstruct SAM{\n\tint ch[M][26],pre[M],step[M],xb;\n\tSAM():xb(1){}\n\tinline void ins(const string&s){\n\t\tint p,q,np,nq,x,i,lst=1;\n\t\tfor(i=0;i<s.size();++i){\n\t\t\tx=s[i]-'a';p=lst;\n\t\t\tstep[np=++xb]=step[p]+1;for(;p && !ch[p][x];p=pre[p])ch[p][x]=np;\n\t\t\tif(p){\n\t\t\t\tq=ch[p][x];\n\t\t\t\tif(step[p]+1!=step[q]){\n\t\t\t\t\tstep[nq=++xb]=step[p]+1;memcpy(ch[nq],ch[q],104);\n\t\t\t\t\tpre[nq]=pre[q];pre[q]=pre[np]=nq;\n\t\t\t\t\tfor(;p && ch[p][x]==q;p=pre[p])ch[p][x]=nq;\n\t\t\t\t}else pre[np]=q;\n\t\t\t}else pre[np]=1;\n\t\t\tlst=np;\n\t\t}\n\t}\n\tint le[M][26],be[M],en[M],dfn[M],dcnt;\n\tvector<int>e[M];\n\tvoid dfs(int x){dfn[be[x]=++dcnt]=x;for(int y:e[x])dfs(y);en[x]=dcnt;}\n\tinline void getdfn(){for(int i=2;i<=xb;++i)e[pre[i]].push_back(i);dfs(1);}\n\tinline void build1(){\n\t\tint i,j,x,y;\n\t\tgetdfn();\n\t\tfor(i=0;i<26;++i)if(!ch[1][i])ch[1][i]=1,le[1][i]=0;else le[1][i]=-1;\n\t\tfor(i=2;i<=xb;++i){\n\t\t\tx=dfn[i];\n\t\t\tfor(j=0;j<26;++j)if(!ch[x][j])ch[x][j]=ch[pre[x]][j],y=le[pre[x]][j],le[x][j]=y==-1?step[pre[x]]+1:y;\n\t\t\t\telse le[x][j]=-1;\n\t\t}\n\t}\n\tint lstt[M];\n\tinline void build2(const string&s){\n\t\tstatic P h[N];static int pos[M];int i,x=1,l=s.size();\n\t\th[l+1]=(P){0,0};for(i=l;i;--i)h[i]=h[i+1]*mi[1]+(P){s[i-1]-'a'+1,s[i-1]-'a'+1};\n\t\tmemset(pos+1,0,xb<<2);memset(lstt+1,0,xb<<2);\n\t\tgetdfn();\n\t\tfor(i=0;i<s.size();++i)x=ch[x][s[i]-'a'],lstt[x]=i+1,pos[x]=1;\n\t\tfor(i=2;i<=xb;++i)x=dfn[i],lstt[x]?0:lstt[x]=lstt[pre[x]];\n\t\tfor(i=xb;i;--i)x=dfn[i],!pos[x]?pos[x]=pos[e[x][0]]+step[e[x][0]]-step[x]:0;\n\t\tt2.ini(xb);\n\t\tfor(i=2;i<=xb;++i){\n\t\t\tx=pre[i];\n\t\t\tt2.e[x].push_back(i);\n\t\t\tauto geth=[&](int l,int r){return h[l]-h[r+1]*mi[r-l+1];};\n\t\t\tt2.son[x][s[pos[i]+step[i]-step[x]-2]-'a']=i;t2.su[i]=geth(pos[i],pos[i]+step[i]-1);\n\t\t}\n\t\tt2.pre2();memcpy(t2.wd+1,step+1,xb<<2);\n\t}\n\tinline void go(int&u,int&l,char c){c-='a';if(le[u][c]==-1)++l;else l=le[u][c];u=ch[u][c];}\n\tinline void clear(){for(int i=1;i<=xb;++i)memset(ch[i],0,104),e[i].clear();xb=1;dcnt=0;}\n}ss;\nstruct strr{\n\tint l,b;\n\tstring s,rs;\n\tinline void in(){cin>>s;l=s.size();rs=s;reverse(rs.begin(),rs.end());}\n\tinline void inss(int tp){ss.ins(tp==1?s:rs);b=1;}\n\tinline void getb(int tp){for(char c:tp==1?s:rs)b=ss.ch[b][c-'a'];}\n\tvector<int>qq;\n\tinline void solve();\n}s[N];\nstruct Tree:tree<N>{\n\tint top2[N],le[N],ma2[N],anc[20][N];\n\tV up[N],dow[N];\n\tinline void pre2(){\n\t\tint i,j,x;\n\t\tfor(i=n;i;--i){x=dfn[i];for(int y:e[x])if(y!=dad[x] && le[y]>le[ma2[x]])ma2[x]=y;le[x]=le[ma2[x]]+1;}\n\t\tgettop(top2,ma2);\n\t\tmemcpy(anc[0]+1,dad+1,n<<2);\n\t\tfor(i=1;i<20;++i)for(j=1;j<=n;++j)anc[i][j]=anc[i-1][anc[i-1][j]];\n\t\tfor(i=0;i<20;++i)for(j=1;j<=n;++j)anc[i][j]=top2[anc[i][j]];\n\t\tfor(i=1;i<=n;++i)if(top2[i]==i){\n\t\t\tauto fil=[&](V&v,int l,int*a){v.resize(l);for(j=0,x=i;j<l;++j)v[j]=x,x=a[x];};\n\t\t\tfil(dow[i],le[i],ma2);fil(up[i],min(le[i],dep[i]),dad);\n\t\t}\n\t}\n\tchar fc[N];\n\tP h[N];\n\tinline void in(){\n\t\tstatic unordered_map<int,char>mp[N];char c;int i,x,y;\n\t\tfor(i=1;i<n;++i)cin>>x>>y>>c,e[x].push_back(y),e[y].push_back(x),mp[x][y]=mp[y][x]=c;\n\t\tpre1();pre2();for(i=2;i<=n;++i)fc[i]=mp[dad[i]][i];\n\t\tfor(i=2;i<=n;++i)x=dfn[i],h[x]=h[dad[x]]*mi[1]+(P){fc[x]-'a'+1,fc[x]-'a'+1};\n\t}\n\tinline P geth(int x,int y){return h[x]-h[y]*mi[dep[x]-dep[y]];}\n\tinline int kthfa(int x,int k){\n\t\tint y=anc[hib[k]][x],dt=dep[x]-dep[y];\n\t\treturn k?k<=dt?dow[y][dt-k]:up[y][k-dt]:x;\n\t}\n\tvector<que>qu[N];\n\tvoid dfs(int x,int fa,int u,int l){\n\t\tint uu=l==ss.step[u]?u:ss.pre[u];\n\t\tbi.add(ss.be[uu],1);\n\t\tfor(que z:qu[x])ans[z.i]+=z.k*(bi.ask(ss.en[z.x])-bi.ask(ss.be[z.x]-1));\n\t\tfor(int y:e[x])if(y!=fa){int nu=u,nl=l;ss.go(nu,nl,fc[y]);dfs(y,x,nu,nl);}\n\t\tbi.add(ss.be[uu],-1);\n\t}\n\tinline void solve(int*x){\n\t\tint i,d,u,v;for(i=1;i<=n;++i)qu[i].clear();bi.ini(ss.xb);\n\t\tfor(i=1;i<=q;++i)if(d=dep[x[i]]-dep[l[i]],d>=s[z[i]].l)\n\t\t\tu=s[z[i]].b,qu[x[i]].push_back((que){u,i,1}),qu[kthfa(x[i],d-s[z[i]].l+1)].push_back((que){u,i,-1});\n\t\tdfs(1,0,1,0);\n\t}\n}t;\ninline int GBT::find(int x,int y){\n\tint u=rt,ret=1,v,l=t.dep[x]-t.dep[y],z;\n\tfor(;;){\n\t\tfor(v=0;u;)if(wd[u]<=l && t.geth(t.kthfa(x,l-wd[u]),y)==su[u])v=u,u=ch[u][1];else u=ch[u][0];\n\t\tif(!v)break;ret=v;if(wd[v]==l)break;\n\t\tu=son[v][t.fc[t.kthfa(x,l-wd[v]-1)]-'a'];if(!u || u==ma[v])break;u=bel[u];\n\t}\n\treturn ret;\n}\ninline void strr::solve(){\n\tstatic V e[N],re[N];static vector<que>qu[N];static int nxt[N],be[N],en[N];int i,j,dcnt=0;\n\tauto gettree=[&](V*e,const string&s){\n\t\tfor(i=0;i<=l;++i)e[i].clear();\n\t\tfor(i=2,j=0;i<=l;++i){\n\t\t\tfor(;j && s[j]!=s[i-1];j=nxt[j]);\n\t\t\tnxt[i]=j+=s[j]==s[i-1];\n\t\t}\n\t\tfor(i=1;i<=l;++i)e[nxt[i]].push_back(i);\n\t};\n\tgettree(e,s);gettree(re,rs);\n\tfunction<void(int)>dfs1=[&](int x){\n\t\tbe[x]=++dcnt;\n\t\tfor(int y:re[x])dfs1(y);\n\t\ten[x]=dcnt;\n\t};\n\tdfs1(0);bi.ini(l+1);for(i=0;i<=l;++i)qu[i].clear();\n\tss.ins(s);ss.build2(s);for(int i:qq)p1[i]=ss.lstt[t2.find(x[i],::l[i])];ss.clear();\n\tss.ins(rs);ss.build2(rs);for(int i:qq)p2[i]=ss.lstt[t2.find(y[i],::l[i])];ss.clear();\n\tfor(int i:qq)if(p1[i] && p2[i] && p1[i]+p2[i]>=l)qu[p1[i]].push_back((que){p2[i],i,0});\n\tfunction<void(int)>dfs2=[&](int x){\n\t\tif(0<x && x<l)bi.add(be[l-x],1),bi.add(en[l-x]+1,-1);\n\t\tfor(que u:qu[x])ans[u.i]+=bi.ask(be[u.x]);\n\t\tfor(int y:e[x])dfs2(y);\n\t\tif(0<x && x<l)bi.add(be[l-x],-1),bi.add(en[l-x]+1,1);\n\t};\n\tdfs2(0);\n}\nint main(){\n\tfor(i=2;i<N;++i)hib[i]=hib[i>>1]+1;mi[0]=(P){1,1};for(i=1;i<N;++i)mi[i]=mi[i-1]*(P){37,29};\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m>>q;\n\tt.n=n;t.in();\n\tfor(i=1;i<=m;++i)s[i].in();\n\tfor(i=1;i<=q;++i)cin>>x[i]>>y[i]>>z[i],l[i]=t.lca(x[i],y[i]);\n\tfor(i=1;i<=m;++i)s[i].inss(1);ss.build1();for(i=1;i<=m;++i)s[i].getb(1);t.solve(y);ss.clear();\n\tfor(i=1;i<=m;++i)s[i].inss(2);ss.build1();for(i=1;i<=m;++i)s[i].getb(2);t.solve(x);ss.clear();\n\tfor(i=1;i<=q;++i)s[z[i]].qq.push_back(i);\n\tfor(i=1;i<=m;++i)s[i].solve();\n\tfor(i=1;i<=q;++i)cout<<ans[i]<<'\\n';\n\treturn 0;\n}"
}