{
    "id": 38941576,
    "contestId": 917,
    "creationTimeSeconds": 1528108378,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "FizzyDavicl"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1326,
    "memoryConsumedBytes": 158515200,
    "source": "#include <bits/stdc++.h>\r\n\r\n#ifdef DEBUG\r\n#define debug(...) fprintf(stderr, __VA_ARGS__)\r\n#else\r\n#define debug(...)\r\n#endif\r\n\r\n#ifdef __WIN32\r\n#define LLFORMAT \"I64\"\r\n#define Rand() ((rand() << 15) + rand())\r\n#else\r\n#define LLFORMAT \"ll\"\r\n#define Rand() (rand())\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nconst int maxn = 1e5 + 10, maxm = 2e5 + 10;\r\n\r\nint n, m_n, q_n, u[maxn], v[maxn], i[maxn], ans[maxn], bel[maxn], mu[maxn], mv[maxn], par[maxn], fuck_id;\r\nchar par_c[maxn];\r\nstring m[maxm];\r\nvector<pair<int, char> > g[maxn];\r\nvector<int> has[maxn], border[maxm];\r\nbool vis[maxn];\r\n\r\nint extgcd(int a, int &x, int b, int &y) {\r\n\tif(!b) {\r\n\t\tx = 1;\r\n\t\ty = 0;\r\n\t\treturn a;\r\n\t}\r\n\tint t = a / b, ret = extgcd(b, y, a - t * b, x);\r\n\ty -= t * x;\r\n\treturn ret;\r\n}\r\n\r\nint F(int l1, int r1, int d1, int l2, int r2, int d2) {\r\n\tif(l1 > l2) {\r\n\t\treturn F(l2, r2, d2, l1, r1, d1);\r\n\t}\r\n\tint x, y, d = extgcd(d1, x, d2, y);\r\n\tif((l2 - l1) % d != 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tlong long Y = (long long) (l2 - l1) / d * -y;\r\n\td1 /= d;\r\n\tY = (Y % d1 + d1) % d1;\r\n\tlong long foo = (long long) Y * d2 + l2;\r\n\tif(foo > min(r1, r2)) {\r\n\t\treturn 0;\r\n\t}\r\n\tlong long k = (min(r1, r2) - foo) / (d1 * d2);\r\n\treturn (int) k + 1;\r\n}\r\n\r\nstruct Info {\r\n\tint l, r, d;\r\n\r\n\tInfo() {}\r\n\tInfo(int l, int r, int d): l(l), r(r), d(d) {}\r\n};\r\n\r\nint lowbit(int i) {\r\n\treturn i & (-i);\r\n}\r\n\r\nnamespace ac {\r\n\tint go[maxm][26], fail[maxm], SZ, pos[maxm], dfn[maxm], End[maxm], fen[maxm];\r\n\tvector<int> g[maxm];\r\n\r\n\tvoid M(int i, int x) {\r\n\t\tfor(; i <= SZ; i += lowbit(i)) {\r\n\t\t\tfen[i] += x;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tint Q(int i) {\r\n\t\tint x = 0;\r\n\t\tfor(; i; i ^= lowbit(i)) {\r\n\t\t\tx += fen[i];\r\n\t\t}\r\n\t\treturn x;\r\n\t}\r\n\r\n\tvoid m(int i, int x) {\r\n\t\tM(dfn[i], x);\r\n\t\treturn;\r\n\t}\r\n\r\n\tint q(int i) {\r\n\t\treturn Q(End[i]) - Q(dfn[i] - 1);\r\n\t}\r\n\r\n\tvoid dfs(int u) {\r\n\t\tdfn[u] = ++SZ;\r\n\t\tfor (int &v: g[u]) {\r\n\t\t\tdfs(v);\r\n\t\t}\r\n\t\tEnd[u] = SZ;\r\n\t\treturn;\r\n\t}\r\n\r\n\tvoid ins(int i) {\r\n\t\tint u = 0;\r\n\t\tfor (char &c: ::m[i]) {\r\n\t\t\tint j = c - 'a';\r\n\t\t\tif(!go[u][j]) {\r\n\t\t\t\tgo[u][j] = ++SZ;\r\n\t\t\t}\r\n\t\t\tu = go[u][j];\r\n\t\t}\r\n\t\tpos[i] = u;\r\n\t\treturn;\r\n\t}\r\n\r\n\tvoid build() {\r\n\t\tstatic int q[maxm], fnt, rar;\r\n\t\tfnt = rar = 0;\r\n\t\tfor (int i = 0; i < 26; ++i) {\r\n\t\t\tif(go[0][i]) {\r\n\t\t\t\tq[rar++] = go[0][i];\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(fnt != rar) {\r\n\t\t\tint u = q[fnt++];\r\n\t\t\tfor (int i = 0; i < 26; ++i) {\r\n\t\t\t\tif(go[u][i]) {\r\n\t\t\t\t\tint v = fail[u];\r\n\t\t\t\t\twhile(v && !go[v][i]) {\r\n\t\t\t\t\t\tv = fail[v];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfail[q[rar++] = go[u][i]] = go[v][i];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tgo[u][i] = go[fail[u]][i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 1; i <= SZ; ++i) {\r\n\t\t\tg[fail[i]].push_back(i);\r\n\t\t}\r\n\t\tSZ = 0;\r\n\t\tdfs(0);\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nnamespace sam {\r\n\tconst int lgn = 19;\r\n\tint go[maxm << 1][26], mx[maxm << 1], SZ, pos[maxm], dfn[maxm << 1], End[maxm << 1], fen[maxm << 2], par[maxm << 1][lgn];\r\n\tset<int> s[maxm << 1];\r\n\tvector<int> g[maxm << 1];\r\n\r\n\tvoid M(int i, int x) {\r\n\t\tfor(; i <= SZ; i += lowbit(i)) {\r\n\t\t\tfen[i] += x;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tint Q(int i) {\r\n\t\tint x = 0;\r\n\t\tfor(; i; i ^= lowbit(i)) {\r\n\t\t\tx += fen[i];\r\n\t\t}\r\n\t\treturn x;\r\n\t}\r\n\r\n\tvoid m(int i, int x, int l) {\r\n\t\tif(~i) {\r\n\t\t\tM(dfn[i], x);\r\n\t\t\tM(End[i], -x);\r\n\t\t\tif(x > 0) {\r\n\t\t\t\ts[i].insert(l);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ts[i].erase(l);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tint q(int u, int L) {\r\n\t\tif(s[u].size()) {\r\n\t\t\tauto it = s[u].lower_bound(L);\r\n\t\t\tif(it != s[u].begin()) {\r\n\t\t\t\t--it;\r\n\t\t\t\treturn *it;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint I = dfn[par[u][0]];\r\n\t\tfor (int i = lgn - 1; ~i; --i) {\r\n\t\t\tint p = par[u][i];\r\n\t\t\tif(Q(I) - Q(dfn[p] - 1) == 0) {\r\n\t\t\t\tu = p;\r\n\t\t\t}\r\n\t\t}\r\n\t\tu = par[u][0];\r\n\t\tif(!u) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tassert(s[u].size());\r\n\t\tauto it = s[u].end();\r\n\t\t--it;\r\n\t\treturn *it;\r\n\t}\r\n\r\n\tvoid dfs(int u) {\r\n\t\tdfn[u] = ++SZ;\r\n\t\tfor (int i = 1; i < lgn; ++i) {\r\n\t\t\tpar[u][i] = par[par[u][i - 1]][i - 1];\r\n\t\t}\r\n\t\tfor (int &v: g[u]) {\r\n\t\t\tdfs(v);\r\n\t\t}\r\n\t\tEnd[u] = ++SZ;\r\n\t\treturn;\r\n\t}\r\n\r\n\tvoid append(int &last, int i) {\r\n\t\tint p = last;\r\n\t\tif(~go[p][i]) {\r\n\t\t\tlast = go[p][i];\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint np = ++SZ;\r\n\t\tmx[np] = mx[p] + 1;\r\n\t\twhile(~p && !~go[p][i]) {\r\n\t\t\tgo[p][i] = np;\r\n\t\t\tp = par[p][0];\r\n\t\t}\r\n\t\tif(!~p) {\r\n\t\t\tpar[np][0] = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint q = go[p][i];\r\n\t\t\tif(mx[q] == mx[p] + 1) {\r\n\t\t\t\tpar[np][0] = q;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tint nq = ++SZ;\r\n\t\t\t\tmemcpy(go[nq], go[q], sizeof(go[nq]));\r\n\t\t\t\tmemcpy(par[nq], par[q], sizeof(par[nq]));\r\n\t\t\t\tmx[nq] = mx[p] + 1;\r\n\t\t\t\tpar[q][0] = par[np][0] = nq;\r\n\t\t\t\twhile(~p && go[p][i] == q) {\r\n\t\t\t\t\tgo[p][i] = nq;\r\n\t\t\t\t\tp = par[p][0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlast = np;\r\n\t\treturn;\r\n\t}\r\n\r\n\tvoid init() {\r\n\t\tmemset(go, -1, sizeof go);\r\n\t\tmemset(par, -1, sizeof par);\r\n\t\treturn;\r\n\t}\r\n\r\n\tvoid build() {\r\n\t\tstatic pair<pair<int, int>, int> q[maxm];\r\n\t\tint fnt = 0, rar = 0;\r\n\t\tfor (int i = 1; i <= m_n * 2; ++i) {\r\n\t\t\tq[rar++] = make_pair(make_pair(i, 0), 0);\r\n\t\t}\r\n\t\twhile(fnt != rar) {\r\n\t\t\tint i = q[fnt].first.first, j = q[fnt].first.second, u = q[fnt].second;\r\n\t\t\t++fnt;\r\n\t\t\tappend(u, ::m[i][j] - 'a');\r\n\t\t\tif(j == ::m[i].size() - 1) {\r\n\t\t\t\tpos[i] = u;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tq[rar++] = make_pair(make_pair(i, j + 1), u);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpar[0][0] = 0;\r\n\t\tfor (int i = 1; i <= SZ; ++i) {\r\n\t\t\tg[par[i][0]].push_back(i);\r\n\t\t}\r\n\t\tSZ = 0;\r\n\t\tdfs(0);\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nint find_rt(int u) {\r\n\tstatic int q[maxn], fnt, rar, par[maxn], hs[maxn], sz[maxn];\r\n\tfnt = rar = 0;\r\n\tpar[q[rar++] = u] = 0;\r\n\twhile(fnt != rar) {\r\n\t\tu = q[fnt++];\r\n\t\ths[u] = 0;\r\n\t\tsz[u] = 1;\r\n\t\tfor (auto &e: g[u]) {\r\n\t\t\tif(!vis[e.first] && e.first != par[u]) {\r\n\t\t\t\tpar[q[rar++] = e.first] = u;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (int i = rar - 1; ~i; --i) {\r\n\t\tu = q[i];\r\n\t\tif((max(hs[u], rar - sz[u]) << 1) <= rar) {\r\n\t\t\treturn u;\r\n\t\t}\r\n\t\tint p = par[u];\r\n\t\tsz[p] += sz[u];\r\n\t\ths[p] = max(hs[p], sz[u]);\r\n\t}\r\n}\r\n\r\nvoid dfs1(int u, int p, int rt) {\r\n\tbel[u] = rt;\r\n\tfor (auto &e: g[u]) {\r\n\t\tif(!vis[e.first] && e.first != p) {\r\n\t\t\tdfs1(e.first, u, rt);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\n\r\nvoid dfs2(int u, int p, int acp, int samp, int l) {\r\n\tpar[u] = p;\r\n\tac::m(acp, 1);\r\n\tsam::m(samp, 1, l);\r\n\tstatic vector<int> nhas;\r\n\tnhas.clear();\r\n\tfor (int i: has[u]) {\r\n\t\tif(bel[::u[i]] == bel[::v[i]]) {\r\n\t\t\tnhas.push_back(i);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif(u == ::u[i]) {\r\n\t\t\tans[i] += ac::q(ac::pos[::i[i] + m_n]);\r\n\t\t\tmu[i] = sam::q(sam::pos[::i[i] + m_n], m[::i[i]].size());\r\n\t\t}\r\n\t\telse {\r\n\t\t\tans[i] += ac::q(ac::pos[::i[i]]);\r\n\t\t\tmv[i] = sam::q(sam::pos[::i[i]], m[::i[i]].size());\r\n\t\t}\r\n\t}\r\n\thas[u] = nhas;\r\n\tfor (auto &e: g[u]) {\r\n\t\tif(!vis[e.first] && e.first != p) {\r\n\t\t\tpar_c[e.first] = e.second;\r\n\t\t\tdfs2(e.first, u, ac::go[acp][e.second - 'a'], ~samp ? sam::go[samp][e.second - 'a'] : -1, l + 1);\r\n\t\t}\r\n\t}\r\n\tac::m(acp, -1);\r\n\tsam::m(samp, -1, l);\r\n\treturn;\r\n}\r\n\r\nvoid solve(int rt) {\r\n\trt = find_rt(rt);\r\n\tbel[rt] = rt;\r\n\tfor (auto &e: g[rt]) {\r\n\t\tif(!vis[e.first]) {\r\n\t\t\tdfs1(e.first, rt, e.first);\r\n\t\t}\r\n\t}\r\n\tpar[rt] = 0;\r\n\tfor (auto &e: g[rt]) {\r\n\t\tif(!vis[e.first]) {\r\n\t\t\tpar_c[e.first] = e.second;\r\n\t\t\tdfs2(e.first, rt, ac::go[0][e.second - 'a'], sam::go[0][e.second - 'a'], 1);\r\n\t\t}\r\n\t}\r\n\tvis[rt] = 1;\r\n\tfor (auto &e: g[rt]) {\r\n\t\tif(!vis[e.first]) {\r\n\t\t\tsolve(e.first);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\n\r\nint main() {\r\n\tios::sync_with_stdio(false);\r\n\tcin >> n >> m_n >> q_n;\r\n\tfor (int i = 1; i < n; ++i) {\r\n\t\tint u, v;\r\n\t\tchar c;\r\n\t\tcin >> u >> v >> c;\r\n\t\tg[u].push_back(make_pair(v, c));\r\n\t\tg[v].push_back(make_pair(u, c));\r\n\t}\r\n\tfor (int i = 1; i <= m_n; ++i) {\r\n\t\tcin >> m[i];\r\n\t\tm[i + m_n] = m[i];\r\n\t\treverse(m[i + m_n].begin(), m[i + m_n].end());\r\n\t}\r\n\tsam::init();\r\n\tfor (int i = 1; i <= m_n * 2; ++i) {\r\n\t\tac::ins(i);\r\n\t\tint n = m[i].size();\r\n\t\tauto &b = border[i];\r\n\t\tb.resize(n + 1);\r\n\t\tb[0] = -1;\r\n\t\tfor (int k = 0; k < n; ++k) {\r\n\t\t\tint j = b[k];\r\n\t\t\twhile(~j && m[i][j] != m[i][k]) {\r\n\t\t\t\tj = b[j];\r\n\t\t\t}\r\n\t\t\tb[k + 1] = j + 1;\r\n\t\t}\r\n\t}\r\n\tac::build();\r\n\tsam::build();\r\n\tfor (int i = 1; i <= q_n; ++i) {\r\n\t\tcin >> u[i] >> v[i] >> ::i[i];\r\n\t\thas[u[i]].push_back(i);\r\n\t\thas[v[i]].push_back(i);\r\n\t}\r\n\tsolve(1);\r\n\tfor (int i = 1; i <= q_n; ++i) {\r\n\t\tif(mu[i] && mv[i]) {\r\n\t\t\tstatic vector<Info> vu, vv;\r\n\t\t\tauto &bu = border[::i[i]], &bv = border[::i[i] + m_n];\r\n\t\t\tint mu = ::mu[i], mv = ::mv[i];\r\n\t\t\tvu.clear();\r\n\t\t\tvv.clear();\r\n\t\t\twhile(mu) {\r\n\t\t\t\tint nu = bu[mu], d = mu - nu, t = mu - (mu >> 1), k = t / d;\r\n\t\t\t\tif(k * d == t) {\r\n\t\t\t\t\t--k;\r\n\t\t\t\t}\r\n\t\t\t\tnu = mu - k * d;\r\n\t\t\t\tvu.push_back(Info(nu, mu, d));\r\n\t\t\t\tmu = bu[nu];\r\n\t\t\t}\r\n\t\t\treverse(vu.begin(), vu.end());\r\n\t\t\twhile(mv) {\r\n\t\t\t\tint nv = bv[mv], d = mv - nv, t = mv - (mv >> 1), k = t / d;\r\n\t\t\t\tif(k * d == t) {\r\n\t\t\t\t\t--k;\r\n\t\t\t\t}\r\n\t\t\t\tnv = mv - k * d;\r\n\t\t\t\tvv.push_back(Info(nv, mv, d));\r\n\t\t\t\tmv = bv[nv];\r\n\t\t\t}\r\n\t\t\treverse(vv.begin(), vv.end());\r\n\t\t\tint len = m[::i[i]].size();\r\n\t\t\tfor (auto t: vu) {\r\n\t\t\t\tint l = t.l, r = t.r, d = t.d;\r\n\t\t\t\twhile(vv.size()) {\r\n\t\t\t\t\tauto s = vv.back();\r\n\t\t\t\t\tint ll = s.l, rr = s.r, dd = s.d;\r\n\t\t\t\t\tif(l + ll > len) {\r\n\t\t\t\t\t\tvv.pop_back();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tans[i] += F(len - r, len - l, d, ll, rr, dd);\r\n\t\t\t\t\tif(r + 1 + ll > len) {\r\n\t\t\t\t\t\tvv.pop_back();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"%d\\n\", ans[i]);\r\n\t}\r\n\treturn 0;\r\n}\r\n"
}