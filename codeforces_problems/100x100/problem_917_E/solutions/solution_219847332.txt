{
    "id": 219847332,
    "contestId": 917,
    "creationTimeSeconds": 1692656806,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "AsiaticToddaliaRoot"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1731,
    "memoryConsumedBytes": 247603200,
    "source": "#include <stdio.h>\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing vi = vector <int> ;\r\ntemplate <class T>\r\ninline void chmax(T &x, const T &y) { if(x < y) x = y; }\r\ntemplate <class T>\r\ninline void chmin(T &x, const T &y) { if(x > y) x = y; }\r\n#define mp make_pair\r\n#define fi first\r\n#define se second\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define pb push_back\r\n#define rsz resize\r\n#define all(a) a.begin(), a.end()\r\n#define clr(a, n) memset(a, 0, sizeof(a[0]) * (n + 1))\r\n#define rep(i, l, r) for(int i = l, i##end = r; i <= i##end; ++ i)\r\n#define per(i, r, l) for(int i = r, i##end = l; i >= i##end; -- i)\r\nconst int N = 2e5 + 15, C = 26, M = 17;\r\nconst int B = 59, P = 1004535809;\r\n\r\nstring s[N];\r\nvi suf[N], qu[N];\r\nll powb[N];\r\nint edn[N], len[N];\r\nint n, m, q;\r\n\r\nstruct Query {\r\n\tint x, y, k, lx, ly, r, ans;\r\n} Q[N];\r\n\r\nstruct BIT {\r\n\tint a[N];\r\n\tvoid add(int i, int x) {\r\n\t\tfor(; i < N; i += i & -i)\r\n\t\t\ta[i] += x;\r\n\t}\r\n\tint qry(int i) {\r\n\t\tint res = 0;\r\n\t\tfor(; i; i &= i - 1)\r\n\t\t\tres += a[i];\r\n\t\treturn res;\r\n\t}\r\n} T[2];\r\n\r\nstruct ACAM {\r\n\tint ch[N][C], fail[N], st[N], ed[N], cnt, tot;\r\n\tvi G[N];\r\n\r\n\tvoid dfs(int u) {\r\n\t\tst[u] = ++ cnt;\r\n\t\tfor(int v : G[u]) dfs(v);\r\n\t\ted[u] = cnt;\r\n\t}\r\n\tvoid insert(int id) {\r\n\t\tint p = 0, c;\r\n\t\trep(i, 1, len[id]) {\r\n\t\t\tc = s[id][i] - 'a';\r\n\t\t\tif(!ch[p][c]) ch[p][c] = ++ tot;\r\n\t\t\tp = ch[p][c];\r\n\t\t}\r\n\t\tedn[id] = p;\r\n\t}\r\n\tvoid build() {\r\n\t\tqueue <int> Q;\r\n\t\trep(i, 0, C - 1) if(ch[0][i]) Q.push(ch[0][i]);\r\n\t\twhile(!Q.empty()) {\r\n\t\t\tint u = Q.front(); Q.pop();\r\n\t\t\trep(i, 0, C - 1) {\r\n\t\t\t\tif(ch[u][i]) fail[ch[u][i]] = ch[fail[u]][i], Q.push(ch[u][i]);\r\n\t\t\t\telse ch[u][i] = ch[fail[u]][i];\r\n\t\t\t}\r\n\t\t}\r\n\t\trep(i, 1, tot) G[fail[i]].pb(i);\r\n\t}\r\n} AC[2];\r\n\r\nstruct Hash {\r\n\tvector <ll> h;\r\n\tvoid build(int id) {\r\n\t\th.rsz(len[id] + 3);\r\n\t\trep(i, 1, len[id]) h[i] = (h[i - 1] * B + s[id][i] - 'a' + 1) % P;\r\n\t}\r\n\tll gh(int l, int r) {\r\n\t\treturn (h[r] - h[l - 1] * powb[r - l + 1] % P + P) % P;\r\n\t}\r\n} H[N];\r\n\r\nstruct KMP {\r\n\tvi nxt[M], st, ed;\r\n\tvector <vi> qr, G;\r\n\tint cnt;\r\n\r\n\tvoid dfs(int u) {\r\n\t\tst[u] = ++ cnt;\r\n\t\tfor(int v : G[u]) dfs(v);\r\n\t\ted[u] = cnt;\r\n\t}\r\n\tvoid build(int id) {\r\n\t\tint n = len[id], j = 0;\r\n\t\trep(i, 0, M - 1) nxt[i].rsz(n + 1);\r\n\t\tG.rsz(n + 1); qr.rsz(n + 1);\r\n\t\trep(i, 2, n) {\r\n\t\t\twhile(j && s[id][j + 1] != s[id][i]) j = nxt[0][j];\r\n\t\t\tif(s[id][j + 1] == s[id][i]) ++ j;\r\n\t\t\tnxt[0][i] = j;\r\n\t\t}\r\n\t\trep(i, 1, n) G[nxt[0][i]].pb(i);\r\n\t\trep(j, 1, M - 1) rep(i, 1, n)\r\n\t\t\tnxt[j][i] = nxt[j - 1][nxt[j - 1][i]];\r\n\t\tif(id > m) st.rsz(n + 1), ed.rsz(n + 1), dfs(0);\r\n\t}\r\n\tint jump(int i, int lim) {\r\n\t\tif(i <= lim) return i;\r\n\t\tper(k, M - 1, 0)\r\n\t\t\tif(nxt[k][i] > lim) i = nxt[k][i];\r\n\t\treturn nxt[0][i];\r\n\t}\r\n} Kmp[N];\r\n\r\nvoid kmp_solve(int id, int u) {\r\n\tT[0].add(Kmp[id + m].st[len[id] - u], 1);\r\n\tT[0].add(Kmp[id + m].ed[len[id] - u] + 1, -1);\r\n\tfor(int qi : Kmp[id].qr[u])\r\n\t\tQ[qi].ans += T[0].qry(Kmp[id + m].st[Q[qi].ly]);\r\n\tfor(int v : Kmp[id].G[u])\r\n\t\tkmp_solve(id, v);\r\n\tT[0].add(Kmp[id + m].st[len[id] - u], -1);\r\n\tT[0].add(Kmp[id + m].ed[len[id] - u] + 1, 1);\r\n}\r\n\r\nnamespace Suffix_Sort {\r\n\r\nint sa[N], rnk[N], buc[N], tmp[N];\r\n\r\nvoid SA(int id) {\r\n\tint n = len[id], m = C;\r\n\tclr(buc, m);\r\n\trep(i, 1, n) ++ buc[rnk[i] = s[id][i] - 'a' + 1];\r\n\trep(i, 1, C) buc[i] += buc[i - 1];\r\n\tper(i, n, 1) sa[buc[rnk[i]] --] = i;\r\n\tfor(int ln = 1; ln < n; ln <<= 1) {\r\n\t\tint w = 0;\r\n\t\trep(i, n - ln + 1, n) tmp[++ w] = i;\r\n\t\trep(i, 1, n) if(sa[i] > ln) tmp[++ w] = sa[i] - ln;\r\n\t\tclr(buc, m);\r\n\t\trep(i, 1, n) ++ buc[rnk[tmp[i]]];\r\n\t\trep(i, 1, m) buc[i] += buc[i - 1];\r\n\t\tper(i, n, 1) sa[buc[rnk[tmp[i]]] --] = tmp[i];\r\n\t\ttmp[sa[1]] = m = 1;\r\n\t\tauto cmp = [&](int x, int y) -> bool {\r\n\t\t\tif(x + ln > n || y + ln > n) return 0;\r\n\t\t\treturn rnk[x] == rnk[y] && rnk[x + ln] == rnk[y + ln];\r\n\t\t};\r\n\t\trep(i, 2, n) tmp[sa[i]] = cmp(sa[i], sa[i - 1]) ? m : (++ m);\r\n\t\tmemcpy(rnk, tmp, 4 * (n + 1));\r\n\t\tif(m == n) break;\r\n\t}\r\n\tsuf[id].rsz(n + 1);\r\n\trep(i, 1, n) suf[id][i] = sa[i];\r\n}\r\n\r\n} // Suffix_Sort\r\n\r\nnamespace Tree {\r\n\r\nint to[N], nxt[N], ech[N], head[N], ecnt;\r\nint siz[N], vfa[N], nod[N], dep[N], fch[N];\r\nint fa[M][N], R, rt, mn, ns, cnt;\r\nbool buc[N], vis[N];\r\nll hs[N];\r\nvi G[N];\r\n\r\nvoid add(int x, int y, int z) {\r\n\tto[++ ecnt] = y;\r\n\tnxt[ecnt] = head[x];\r\n\thead[x] = ecnt;\r\n\tech[ecnt] = z;\r\n}\r\n\r\nint lca(int x, int y) {\r\n\tint res = 0;\r\n\tfor(int u = x; u; u = vfa[u])\r\n\t\tbuc[u] = 1;\r\n\tfor(; y; y = vfa[y])\r\n\t\tif(buc[y]) { res = y; break; }\r\n\tfor(int u = x; u; u = vfa[u])\r\n\t\tbuc[u] = 0;\r\n\treturn res;\r\n}\r\n\r\nvoid dfs_siz(int u, int f) {\r\n\tint mx = 0;\r\n\tsiz[u] = 1;\r\n\tfor(int i = head[u], v; i; i = nxt[i]) {\r\n\t\tv = to[i];\r\n\t\tif(v == f || vis[v]) continue;\r\n\t\tdfs_siz(v, u);\r\n\t\tsiz[u] += siz[v];\r\n\t\tchmax(mx, siz[v]);\r\n\t}\r\n\tchmax(mx, ns - siz[u]);\r\n\tif(mx < mn) mn = mx, rt = u;\r\n}\r\n\r\nint divide(int u) {\r\n\trt = 0; mn = 1e9;\r\n\tdfs_siz(u, 0);\r\n\tu = rt; vis[u] = 1;\r\n\tdfs_siz(u, 0);\r\n\tfor(int i = head[u], v; i; i = nxt[i]) {\r\n\t\tv = to[i];\r\n\t\tif(vis[v]) continue;\r\n\t\tns = siz[v];\r\n\t\tvfa[v = divide(v)] = u;\r\n\t\tG[u].pb(v);\r\n\t}\r\n\treturn u;\r\n}\r\n\r\nint kth(int u, int k) {\r\n\tper(i, M - 1, 0)\r\n\t\tif(k >> i & 1) u = fa[i][u];\r\n\treturn u;\r\n}\r\n\r\nint glcp(int id, int i, int u) {\r\n\tint n = len[id];\r\n\tif(n - i + 1 < dep[u]) u = kth(u, dep[u] - (n - i + 1));\r\n\tif(H[id].gh(i, i + dep[u] - 1) == hs[u]) return dep[u];\r\n\tper(k, M - 1, 0)\r\n\t\tif(fa[k][u] && !(hs[fa[k][u]] == H[id].gh(i, i + dep[fa[k][u]] - 1)))\r\n\t\t\tu = fa[k][u];\r\n\treturn dep[fa[0][u]];\r\n}\r\n\r\nint query_maxlen(int u, int id) {\r\n\tint n = len[id], l = 1, r = n, mid, p = 0;\r\n\tif(dep[u] >= n) u = kth(u, dep[u] - n + 1);\r\n\tif(u == rt) return 0;\r\n\twhile(l <= r) {\r\n\t\tmid = l + r >> 1;\r\n\t\tint i = suf[id][mid], o = glcp(id, i, u);\r\n\t\tif(o == n - i + 1 || o < dep[u] && s[id][i + o] < fch[kth(u, dep[u] - o - 1)])\r\n\t\t\tp = i, l = mid + 1;\r\n\t\telse r = mid - 1;\r\n\t}\r\n\tif(p) return Kmp[id <= m ? id + m : id - m].jump(len[id] - p + 1, glcp(id, p, u));\r\n\treturn 0;\r\n}\r\n\r\nvoid dfs_node(int u, int f, int p0, int p1) {\r\n\tfa[0][u] = f;\r\n\trep(i, 1, M - 1) fa[i][u] = fa[i - 1][fa[i - 1][u]];\r\n\tif(p0) T[0].add(AC[0].st[p0], 1);\r\n\tif(p1) T[1].add(AC[1].st[p1], 1);\r\n\tfor(int qi : qu[u]) if(Q[qi].r == rt) {\r\n\t\tint t = Q[qi].x == u, v = Q[qi].k + t * m;\r\n\t\tQ[qi].ans += T[t].qry(AC[t].ed[edn[v]]) - T[t].qry(AC[t].st[edn[v]] - 1);\r\n\t\t(t ? Q[qi].lx : Q[qi].ly) = query_maxlen(u, v);\r\n\t}\r\n\tfor(int i = head[u], v, c; i; i = nxt[i]) {\r\n\t\tv = to[i];\r\n\t\tif(v == f || vis[v]) continue;\r\n\t\tc = ech[i] - 'a';\r\n\t\ths[v] = (hs[u] * B + c + 1) % P;\r\n\t\tdep[v] = dep[u] + 1;\r\n\t\tfch[v] = ech[i];\r\n\t\tdfs_node(v, u, AC[0].ch[p0][c], AC[1].ch[p1][c]);\r\n\t}\r\n\tif(p0) T[0].add(AC[0].st[p0], -1);\r\n\tif(p1) T[1].add(AC[1].st[p1], -1);\r\n}\r\n\r\nvoid dfs(int r) {\r\n\trt = r; vis[r] = 1;\r\n\tdep[r] = 0; hs[r] = 0;\r\n\tdfs_node(r, 0, 0, 0);\r\n\tfor(int v : G[r]) dfs(v); \r\n}\r\n\r\nvoid solve() {\r\n\tns = n; R = divide(1);\r\n\trep(i, 1, q) Q[i].r = lca(Q[i].x, Q[i].y);\r\n\tclr(vis, n); dfs(R);\r\n}\r\n\r\n} // Tree\r\n\r\nsigned main() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint x, y; char c;\r\n\tcin >> n >> m >> q;\r\n\trep(i, 2, n) {\r\n\t\tcin >> x >> y >> c;\r\n\t\tTree::add(x, y, c);\r\n\t\tTree::add(y, x, c);\r\n\t}\r\n\tpowb[0] = 1;\r\n\trep(i, 1, 1e5) powb[i] = powb[i - 1] * B % P;\r\n\trep(i, 1, m) {\r\n\t\tcin >> s[i]; s[i + m] = s[i];\r\n\t\treverse(all(s[i + m]));\r\n\t}\r\n\trep(i, 1, m * 2) {\r\n\t\tlen[i] = s[i].size();\r\n\t\ts[i] = ' ' + s[i];\r\n\t\tAC[i > m].insert(i); H[i].build(i);\r\n\t\tKmp[i].build(i); Suffix_Sort :: SA(i);\r\n\t}\r\n\trep(i, 1, q) {\r\n\t\tcin >> Q[i].x >> Q[i].y >> Q[i].k;\r\n\t\tqu[Q[i].x].pb(i); qu[Q[i].y].pb(i);\r\n\t}\r\n\trep(i, 0, 1) AC[i].build(), AC[i].dfs(0);\r\n\tTree :: solve();\r\n\trep(i, 1, q) if(Q[i].lx && Q[i].ly) Kmp[Q[i].k].qr[Q[i].lx].pb(i);\r\n\trep(i, 1, m) kmp_solve(i, 0);\r\n\trep(i, 1, q) cout << Q[i].ans << '\\n';\r\n\treturn 0;\r\n}//7852683099741221296"
}