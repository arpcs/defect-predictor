{
    "id": 193946641,
    "contestId": 917,
    "creationTimeSeconds": 1676602133,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "yaoxi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 623,
    "memoryConsumedBytes": 100864000,
    "source": "// LUOGU_RID: 102286861\n#include <bits/stdc++.h>\nusing namespace std;\n#define myassert(X) (!(X) && (cout << \"failed \" << #X << \"\\n\", exit(0), 1))\n#define debug(fmt, ...) \\\n  fprintf(stderr, \"[%d] : \" fmt \"\\n\", __LINE__, ##__VA_ARGS__)\nusing ll = long long;\nconst int N = 1e5 + 10, S = 26, K = 17;\nconst int mod[2] = {(int)1e9 + 7, (int)1e9 + 9};\nint n, m, q, qu[N], qv[N], qk[N], qd[N];\nint ans[N], ulcp[N], vlcp[N], upos[N], vpos[N];\nstring str[N];\nstruct hash_t {\n  int h0, h1;\n  hash_t() = default;\n  hash_t(int h) : h0(h), h1(h) { }\n  hash_t(int h0, int h1) : h0(h0), h1(h1) { }\n  hash_t operator+(const hash_t& rhs) const {\n    return hash_t((h0 + rhs.h0) % mod[0], (h1 + rhs.h1) % mod[1]);\n  }\n  hash_t operator-(const hash_t& rhs) const {\n    return hash_t((h0 - rhs.h0 + mod[0]) % mod[0], (h1 - rhs.h1 + mod[1]) % mod[1]);\n  }\n  hash_t operator*(const hash_t& rhs) const {\n    return hash_t(1LL * h0 * rhs.h0 % mod[0], 1LL * h1 * rhs.h1 % mod[1]);\n  }\n  bool operator==(const hash_t& rhs) const {\n    return h0 == rhs.h0 && h1 == rhs.h1;\n  }\n} pws[N];\nconst hash_t seed(19260817, 20221130);\nnamespace tree {\nint dep[N], upv[N], fa[N][K];\nhash_t hsh[N];\nvector<pair<int, int>> g[N];\nhash_t get(int u, int d) {\n  return hsh[d] - hsh[u] * pws[dep[d] - dep[u]];\n}\nvoid build(int u = 1, int pre = 0) {\n  fa[u][0] = pre, dep[u] = dep[pre] + 1;\n  for (int i = 1; i < K; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];\n  for (auto e : g[u]) {\n    int v = e.first, ch = e.second;\n    if (v == pre) continue;\n    hsh[v] = hsh[u] * seed + ch;\n    upv[v] = ch, build(v, u);\n  }\n}\nint kthfa(int u, int k) {\n  for (int i = K - 1; ~i; --i) if (k >> i & 1) u = fa[u][i];\n  return u;\n}\nint lca(int u, int v) {\n  if (dep[u] < dep[v]) swap(u, v);\n  if ((u = kthfa(u, dep[u] - dep[v])) == v) return u;\n  for (int i = K - 1; ~i; --i) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];\n  return fa[u][0];\n}\n} // namespace tree\nstruct BIT {\n  int c[N];\n  void add(int x, int v) { for (; x < N; x += x & -x) c[x] += v; }\n  void add(int l, int r, int v) { add(l, v), add(r + 1, -v); }\n  int ask(int x) const { int s = 0; for (; x; x -= x & -x) s += c[x]; return s; }\n  int ask(int l, int r) const { return ask(r) - ask(l - 1); }\n};\nstruct ACAM {\n  int dfc, st[N], ed[N];\n  int cnt, fa[N], pos[N], son[N][S];\n  vector<int> qs[N], adj[N];\n  BIT bit;\n  void insert(const string& s, int id) {\n    int rt = 0;\n    for (auto c : s) {\n      if (!son[rt][c - 'a']) son[rt][c - 'a'] = ++cnt;\n      rt = son[rt][c - 'a'];\n    }\n    pos[id] = rt;\n  }\n  void dfs(int u) {\n    st[u] = ++dfc;\n    for (auto v : adj[u]) dfs(v);\n    ed[u] = dfc;\n  }\n  void build() {\n    static int que[N];\n    int hd = 1, tl = 0;\n    for (int i = 0; i < S; ++i)\n      if (son[0][i]) que[++tl] = son[0][i];\n    while (hd <= tl) {\n      int u = que[hd++];\n      for (int i = 0; i < S; ++i)\n        if (son[u][i]) {\n          fa[son[u][i]] = son[fa[u]][i], que[++tl] = son[u][i];\n        } else {\n          son[u][i] = son[fa[u]][i];\n        }\n    }\n    for (int i = 1; i <= cnt; ++i) adj[fa[i]].push_back(i);\n    dfs(0);\n  }\n  void solve(int u, int pre, int cur) {\n    bit.add(st[cur], 1);\n    for (auto p : qs[u]) {\n      int id = abs(p), k = (p > 0 ? 1 : -1);\n      ans[id] += k * bit.ask(st[pos[qk[id]]], ed[pos[qk[id]]]);\n    }\n    for (auto e : tree::g[u]) {\n      int v = e.first, ch = e.second;\n      if (v != pre) solve(v, u, son[cur][ch - 'a']);\n    }\n    bit.add(st[cur], -1);\n  }\n} AC, AM;\nstruct border {\n  int dfc, st[N], ed[N], kmp[N], fa[N][K];\n  vector<int> g[N];\n  void dfs(int u) {\n    st[u] = ++dfc;\n    for (auto v : g[u]) dfs(v);\n    ed[u] = dfc;\n  }\n  void build(int n, int s[]) {\n    for (int i = 0; i <= n; ++i) g[i].clear();\n    for (int i = 2, p = 0; i <= n; ++i) {\n      while (p && s[p + 1] != s[i]) p = kmp[p];\n      fa[i][0] = kmp[i] = s[p + 1] == s[i] ? ++p : p;\n    }\n    for (int i = 1; i <= n; ++i) g[kmp[i]].push_back(i);\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j < K; ++j)\n        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n    dfc = 0, dfs(0);\n  }\n  int jump(int p, int lim) {\n    if (p <= lim) return p;\n    for (int i = K - 1; ~i; --i) if (fa[p][i] > lim) p = fa[p][i];\n    return fa[p][0];\n  }\n} obdr, ibdr;\nnamespace combine {\nBIT bit;\nvector<int> qs[N];\nvoid dfs(int u, int n) {\n  if (u && u < n) bit.add(ibdr.st[n - u], ibdr.ed[n - u], 1);\n  for (auto v : obdr.g[u]) dfs(v, n);\n  for (auto p : qs[u]) ans[p] += bit.ask(ibdr.st[vpos[p]]);\n  if (u && u < n) bit.add(ibdr.st[n - u], ibdr.ed[n - u], -1);\n}\nvoid solve(int n, const vector<int>& iqs) {\n  for (int i = 0; i <= n; ++i) qs[i].clear();\n  for (auto p : iqs) {\n    upos[p] = obdr.jump(upos[p], ulcp[p]);\n    vpos[p] = ibdr.jump(vpos[p], vlcp[p]);\n    if (upos[p] + vpos[p] >= n) qs[upos[p]].push_back(p);\n  }\n  dfs(0, n);\n}\n} // namespace combine\nnamespace SA {\nint n, s[N], sa[N], rk[N], tp[N];\nhash_t hsh[N];\nvector<int> qs[N];\nhash_t get(int l, int r) {\n  return hsh[r] - hsh[l - 1] * pws[r - l + 1];\n}\nvoid radix_sort(int m) {\n  static int buc[N];\n  for (int i = 0; i <= m; ++i) buc[i] = 0;\n  for (int i = 1; i <= n; ++i) buc[rk[i]]++;\n  for (int i = 1; i <= m; ++i) buc[i] += buc[i - 1];\n  for (int i = n; i >= 1; --i) sa[buc[rk[tp[i]]]--] = tp[i];\n}\nvoid clear() {\n  fill(sa + 1, sa + n + 1, 0);\n  fill(rk + 1, rk + n + 1, 0);\n  fill(tp + 1, tp + n + 1, 0);\n}\nvoid build() {\n  int m = 128;\n  for (int i = 1; i <= n; ++i) rk[i] = s[i], tp[i] = i;\n  radix_sort(m);\n  for (int w = 1, p = 0; p < n; m = p, w <<= 1) {\n    p = 0;\n    for (int i = 1; i <= w; ++i) tp[++p] = n - w + i;\n    for (int i = 1; i <= n; ++i) if (sa[i] > w) tp[++p] = sa[i] - w;\n    radix_sort(m), copy(rk + 1, rk + n + 1, tp + 1), rk[sa[1]] = p = 1;\n    for (int i = 2; i <= n; ++i)\n      rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + w] == tp[sa[i] + w])\n                ? p : ++p;\n  }\n}\ntuple<int, int, int> lcp(int id, int d, int u) {\n  auto chk = [&](int p) {\n    int dis = tree::dep[p] - tree::dep[d];\n    if (id + dis - 1 > n) return false;\n    return tree::get(d, p) == get(id, id + dis - 1);\n  };\n  for (int i = K - 1; ~i; --i) {\n    int t = tree::fa[u][i];\n    if (tree::dep[t] <= tree::dep[d]) continue;\n    if (!chk(t)) u = t;\n  }\n  int val = 0;\n  if (!chk(u)) val = tree::upv[u], u = tree::fa[u][0];\n  int len = tree::dep[u] - tree::dep[d];\n  return {len, s[id + len], val};\n}\nvoid solve() {\n  for (int i = 1; i <= m; ++i) {\n    if (qs[i].empty()) continue;\n    n = str[i].size(), s[n + 1] = '\\0';\n    copy(str[i].begin(), str[i].end(), s + 1);\n    auto calc = [&](border& bdr, int qu[], int len[], int pos[]) {\n      for (int j = 1; j <= n; ++j) hsh[j] = hsh[j - 1] * seed + s[j];\n      build(), bdr.build(n, s);\n      for (auto p : qs[i]) {\n        int l = 1, r = n, res = 0;\n        while (l <= r) {\n          int mid = (l + r) >> 1;\n          auto tmp = lcp(sa[mid], qd[p], qu[p]);\n          if (std::get<1>(tmp) < std::get<2>(tmp)) {\n            l = mid + 1, res = mid;\n          } else {\n            r = mid - 1;\n          }\n        }\n        if (res > 0) {\n          int tmp = std::get<0>(lcp(sa[res], qd[p], qu[p]));\n          if (tmp > len[p]) len[p] = tmp, pos[p] = sa[res];\n        }\n        if (res < n) {\n          int tmp = std::get<0>(lcp(sa[res + 1], qd[p], qu[p]));\n          if (tmp > len[p]) len[p] = tmp, pos[p] = sa[res + 1];\n        }\n        if (len[p]) pos[p] = n - pos[p] + 1;\n      }\n      clear();\n    };\n    reverse(s + 1, s + n + 1), calc(ibdr, qu, ulcp, upos);\n    reverse(s + 1, s + n + 1), calc(obdr, qv, vlcp, vpos);\n    combine::solve(n, qs[i]);\n  }\n}\n} // namespace SA\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr), cout.tie(nullptr);\n  cin >> n >> m >> q;\n  pws[0] = 1;\n  for (int i = 1; i <= n; ++i) pws[i] = pws[i - 1] * seed;\n  for (int i = 1; i < n; ++i) {\n    int u, v; char ch;\n    cin >> u >> v >> ch;\n    tree::g[u].push_back({v, ch}), tree::g[v].push_back({u, ch});\n  }\n  tree::build();\n  for (int i = 1; i <= m; ++i) {\n    cin >> str[i];\n    AC.insert(str[i], i), reverse(str[i].begin(), str[i].end());\n    AM.insert(str[i], i), reverse(str[i].begin(), str[i].end());\n  }\n  AC.build(), AM.build();\n  for (int i = 1; i <= q; ++i) {\n    cin >> qu[i] >> qv[i] >> qk[i];\n    int sz = str[qk[i]].size();\n    qd[i] = tree::lca(qu[i], qv[i]);\n    int du = tree::dep[qu[i]] - tree::dep[qd[i]];\n    if (du >= sz) {\n      int p = tree::kthfa(qu[i], du - sz + 1);\n      AM.qs[p].push_back(-i), AM.qs[qu[i]].push_back(i);\n      qu[i] = p, du = sz - 1;\n    }\n    int dv = tree::dep[qv[i]] - tree::dep[qd[i]];\n    if (dv >= sz) {\n      int p = tree::kthfa(qv[i], dv - sz + 1);\n      AC.qs[p].push_back(-i), AC.qs[qv[i]].push_back(i);\n      qv[i] = p, dv = sz - 1;\n    }\n    if (qu[i] != qd[i] && qv[i] != qd[i] && du + dv >= sz)\n      SA::qs[qk[i]].push_back(i);\n  }\n  AC.solve(1, 0, 0), AM.solve(1, 0, 0), SA::solve();\n  for (int i = 1; i <= q; ++i) cout << ans[i] << \"\\n\";\n  return 0;\n}"
}