{
    "id": 193775833,
    "contestId": 917,
    "creationTimeSeconds": 1676505605,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "ducati"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1200,
    "memoryConsumedBytes": 153292800,
    "source": "// LUOGU_RID: 102227759\n#include <bits/stdc++.h>\r\n#define ll long long\r\n#define eb emplace_back\r\n#define PA pair<int,int>\r\n#define MP make_pair\r\nusing namespace std;\r\nconst int N=1e5+5,M=1e7+5,LG=19,bas=13331,mod=1e9+9;\r\n\r\nint read(){\r\n\tint s=0,w=1;char ch=getchar();\r\n\twhile (ch<'0'||ch>'9'){if (ch=='-')  w=-w;ch=getchar();}\r\n\twhile (ch>='0'&&ch<='9'){s=(s<<1)+(s<<3)+(ch^'0');ch=getchar();}\r\n\treturn s*w;\r\n}\r\nchar readchar(){\r\n\tchar ch=getchar();\r\n\twhile (ch<'a'||ch>'z')  ch=getchar();\r\n\treturn ch;\r\n}\r\nint n,m,q,len,pool[M],pw[N],lg[N],*cur=pool;\r\nint c[N],trs[N],trhv[N]; char ch,str[N];\r\nstruct Query{int u,v,k,l,r,ans;}que[N];\r\nvoid Assign(int *&a){a=cur,cur+=len+2;}\r\nnamespace FW{\r\n\tint n,t[N];\r\n\tvoid C(int x,int k){while(x<=n)t[x]+=k,x+=x&(-x);}\r\n\tint Q(int r){int S=0;while(r)S+=t[r],r-=r&(-r);return S;}\r\n}\r\nnamespace Math{\r\n\t#define int long long\r\n\tint n,x,y;\r\n\tstruct Segment{int r,d,l;};vector<Segment> A,B;\r\n\tint getgcd(int x,int y){return(!y)?x:getgcd(y,x%y);}\r\n\tvoid ins(int r,int d,int l,bool t){\r\n\t\tif (!t)  A.eb(Segment{n-l,d,n-r});\r\n\t\telse B.eb(Segment{r,d,l});\r\n\t}\r\n\tvoid exgcd(int a,int b,int c,int &x,int &y){\r\n\t\tif (!b) {x=c/a,y=0;return;}\r\n\t\texgcd(b,a%b,c,x,y),x=y,y=(c-x*a)/b;\r\n\t}\r\n\tint Downdiv(int L,int k){\r\n\t\tif (L>=0||L%k==0)  return L/k;\r\n\t\treturn L/k-1;\r\n\t}\r\n\tint Updiv(int L,int k){\r\n\t\tif (L>=0)  return (L+k-1)/k;\r\n\t\treturn L/k;\r\n\t}\r\n\tint Constraint_L(int b,int k,int L){return Updiv(L-b,k);}\r\n\tint Constraint_R(int b,int k,int R){return Downdiv(R-b,k);}\r\n\tint query(Segment A,Segment B){\r\n\t\tif (A.d==B.d){\r\n\t\t\tint L=max(A.l,B.l),R=min(A.r,B.r);\r\n\t\t\tif ((A.l-B.l)%A.d||L>R)  return 0;\r\n\t\t\treturn (R-L)/A.d+1;\r\n\t\t}\r\n\t\tint tg=getgcd(A.d,B.d),prd;\r\n\t\tif ((A.l-B.l)%tg)  return 0;\r\n\t\tA.l/=tg,B.l/=tg,A.d/=tg,B.d/=tg,A.r/=tg,B.r/=tg;\r\n\t\texgcd(A.d,-B.d,B.l-A.l,x,y),x*=A.d,x+=A.l,prd=A.d*B.d;\r\n\r\n\t\tint L=Constraint_L(x,prd,max(A.l,B.l));\r\n\t\tint R=Constraint_R(x,prd,min(A.r,B.r));\r\n\t\tif (L<=R)  return R-L+1;\r\n\t\treturn 0;\r\n\t}\r\n\tint solve(){\r\n\t\tint res=0;\r\n\t\tfor (auto x:A){\r\n\t\t\tfor (auto y:B){\r\n\t\t\t\tif (x.r>=y.l||y.r>=x.l)  res+=query(x,y);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn A.clear(),B.clear(),res;\r\n\t}\r\n\t#undef int\r\n}\r\nstruct AC_Automation{\r\n\tint Time,tot,endpos[N],ch[N][26],st[N],ed[N],fail[N]; vector<int> T[N];\r\n\tvoid upd(int x,int k){if(x)FW::C(st[x],k);}\r\n\tint get_cov(int x){\r\n\t\tx=endpos[x];\r\n\t\treturn FW::Q(ed[x])-FW::Q(st[x]-1);\r\n\t}\r\n\tvoid ins(int id){\r\n\t\tint x=0;\r\n\t\tfor (int i=1;i<=len;i++){\r\n\t\t\tint c=str[i]-'a';\r\n\t\t\tif (!ch[x][c])  ch[x][c]=(++tot);\r\n\t\t\tx=ch[x][c];\r\n\t\t}\r\n\t\tendpos[id]=x;\r\n\t}\r\n\tvoid Build(){\r\n\t\tqueue<int> q;\r\n\t\tfor (int i=0;i<26;i++){\r\n\t\t\tint &v=ch[0][i];\r\n\t\t\tif (v)  q.push(v);\r\n\t\t}\r\n\t\twhile (!q.empty()){\r\n\t\t\tint u=q.front(); q.pop();\r\n\t\t\tfor (int i=0;i<26;i++){\r\n\t\t\t\tint &v=ch[u][i],p=ch[fail[u]][i];\r\n\t\t\t\tif (v)  fail[v]=p,q.push(v);\r\n\t\t\t\telse v=p;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvoid dfs(int u){\r\n\t\tst[u]=ed[u]=(++Time);\r\n\t\tfor (int v:T[u])  dfs(v),ed[u]=ed[v];\r\n\t}\r\n\tvoid work(){\r\n\t\tBuild();\r\n\t\tfor (int i=1;i<=tot;i++)  T[fail[i]].eb(i);\r\n\t\tdfs(0);\r\n\t}\r\n}ACAM[2];\r\nstruct Knuth_Morris_Pratt{\r\n\tint n,*s,*kmp,*diff,*tp,*fa[LG];\r\n\tvoid Deal(int p,int t){\r\n\t\tMath::n=n;\r\n\t\tfor (int i=p;i;i=tp[i])  Math::ins(i,diff[i],tp[i]+diff[i],t);\r\n\t}\r\n\tvoid init(){\r\n\t\tn=len,Assign(s),Assign(kmp),Assign(diff),Assign(tp);\r\n\t\tfor (int i=0;i<=lg[len];i++)  Assign(fa[i]);\r\n\t}\r\n\tvoid get_s(){for(int i=1;i<=len;i++)s[i]=str[i];}\r\n\tvoid get_KMP(){\r\n\t\tfor (int i=2,j=0;i<=len;i++){\r\n\t\t\twhile (j&&(s[i]^s[j+1]))  j=kmp[j];\r\n\t\t\tif (s[i]==s[j+1])  j++;\r\n\t\t\tkmp[i]=j;\r\n\t\t}\r\n\t}\r\n\tvoid get_fa(){\r\n\t\tfor (int i=1;i<=len;i++)  fa[0][i]=kmp[i];\r\n\t\tfor (int t=1;t<=lg[len];t++){\r\n\t\t\tfor (int i=1;i<=len;i++)  fa[t][i]=fa[t-1][fa[t-1][i]];\r\n\t\t}\r\n\t}\r\n\tvoid get_tp(){\r\n\t\tfor (int i=1,x;i<=len;i++){\r\n\t\t\tx=kmp[i],diff[i]=i-x;\r\n\t\t\tif (diff[i]^diff[x])  tp[i]=x;\r\n\t\t\telse tp[i]=tp[x];\r\n\t\t}\r\n\t}\r\n\tvoid ins(){init(),get_s(),get_KMP(),get_fa(),get_tp();}\r\n\tint up_tree(int x,int lim){\r\n\t\tif (x==lim)  return x;\r\n\t\tfor (int i=lg[x];~i;--i){\r\n\t\t\tif (fa[i][x]>lim)  x=fa[i][x];\r\n\t\t}\r\n\t\treturn fa[0][x];\r\n\t}\r\n}KMP[N][2];\r\nstruct Suffix_Array{\r\n\tint n,string_id,string_typ,*s,*sa,*hv,*rnk,*x,*y;\r\n\tvoid init(){n=len,Assign(s),Assign(sa),Assign(hv),Assign(rnk),Assign(x),Assign(y);}\r\n\tvoid get_s(){for(int i=1;i<=len;i++)s[i]=str[i];}\r\n\tvoid get_SA(){\r\n\t\tint m=127;\r\n\t\tfor (int i=1;i<=n;i++)  c[x[i]=s[i]]++;\r\n\t\tfor (int i=1;i<=m;i++)  c[i]+=c[i-1];\r\n\t\tfor (int i=1;i<=n;i++)  sa[c[x[i]]--]=i;\r\n\t\tfor (int k=1;k<=n;k<<=1){\r\n\t\t\tint pos=0;\r\n\t\t\tfor (int i=n-k+1;i<=n;i++)  y[++pos]=i;\r\n\t\t\tfor (int i=1;i<=n;i++){\r\n\t\t\t\tif (sa[i]>k)  y[++pos]=sa[i]-k;\r\n\t\t\t}\r\n\t\t\tfor (int i=1;i<=m;i++)  c[i]=0;\r\n\t\t\tfor (int i=1;i<=n;i++)  c[x[i]]++;\r\n\t\t\tfor (int i=1;i<=m;i++)  c[i]+=c[i-1];\r\n\t\t\tfor (int i=n;i>=1;i--)  sa[c[x[y[i]]]--]=y[i];\r\n\t\t\tfor (int i=1;i<=n;i++)  swap(x[i],y[i]);\r\n\t\t\tm=1,x[sa[1]]=1;\r\n\t\t\tfor (int i=2;i<=n;i++){\r\n\t\t\t\tif (y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])  x[sa[i]]=m;\r\n\t\t\t\telse x[sa[i]]=(++m);\r\n\t\t\t}\r\n\t\t\tif (m==n)  break;\r\n\t\t}\r\n\t\tfill(c,c+max(n+2,130),0);\r\n\t}\r\n\tvoid get_hv(){for(int i=1;i<=n;i++)hv[i]=((ll)hv[i-1]*bas+s[i])%mod;}\r\n\tvoid ins(int id,int typ){\r\n\t\tn=len,string_id=id,string_typ=typ;\r\n\t\tinit(),get_s(),get_SA(),get_hv();\r\n\t}\r\n\tll query_hash(int l,int r){return hv[r]-(ll)hv[l-1]*pw[r-l+1];}\r\n\tint get_LCP(int p){\r\n\t\tint l=1,r=min(n-p+1,len),res=0;\r\n\t\twhile (l<=r){\r\n\t\t\tint mid=(l+r)>>1;\r\n\t\t\tif ((query_hash(p,p+mid-1)-trhv[mid])%mod)  r=mid-1;\r\n\t\t\telse res=mid,l=mid+1;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\tbool cmp_strings(int p){\r\n\t\tint t=get_LCP(p);\r\n\t\tif (t==len)  return 1;\r\n\t\tif (t==n-p+1)  return 0;\r\n\t\treturn s[p+t]>trs[t+1];\r\n\t}\r\n\tPA largest_LCP(){\r\n\t\tint l=1,r=n,res=n+1;\r\n\t\twhile (l<=r){\r\n\t\t\tint mid=(l+r)>>1;\r\n\t\t\tif (cmp_strings(sa[mid]))  res=mid,r=mid-1;\r\n\t\t\telse l=mid+1;\r\n\t\t}\r\n\t\tint x=((res<=n)?get_LCP(sa[res]):0);\r\n\t\tint y=((res>1)?get_LCP(sa[res-1]):0);\r\n\t\tif (x>y)  return MP(x,sa[res]);\r\n\t\treturn MP(y,sa[res-1]);\r\n\t}\r\n\tint solve(){\r\n\t\tPA t=largest_LCP();\r\n\t\tif (!t.first)  return 0;\r\n\t\treturn KMP[string_id][string_typ^1].up_tree(n-t.second+1,t.first);\r\n\t}\r\n}SA[N][2];\r\n\r\nnamespace Tree{\r\n\tint cnt,tot,rot,cntson; vector<int> qid,vec[N];\r\n\tint head[N],sz[N],son[N],bel[N]; bitset<N> vis;\r\n\tstruct edge{int nxt,to,w;}e[N<<1];\r\n\tvoid ins_char(int c){trs[++len]=c,trhv[len]=((ll)trhv[len-1]*bas+c)%mod;}\r\n\tvoid add_edge(int u,int v){e[++cnt]=edge{head[u],v,ch},head[u]=cnt;}\r\n\tvoid part_1(int u,int F,int cur){\r\n\t\tACAM[1].upd(cur,1);\r\n\t\tfor (int id:vec[u]){\r\n\t\t\tif (u==que[id].u)  que[id].ans+=ACAM[1].get_cov(que[id].k);\r\n\t\t}\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v]&&(v^F))  part_1(v,u,ACAM[1].ch[cur][e[i].w-'a']);\r\n\t\t}\r\n\t\tACAM[1].upd(cur,-1);\r\n\t}\r\n\tvoid part_2(int u,int F,int cur){\r\n\t\tACAM[0].upd(cur,1);\r\n\t\tfor (int id:vec[u]){\r\n\t\t\tif (u==que[id].v)  que[id].ans+=ACAM[0].get_cov(que[id].k);\r\n\t\t}\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v]&&(v^F))  part_2(v,u,ACAM[0].ch[cur][e[i].w-'a']);\r\n\t\t}\r\n\t\tACAM[0].upd(cur,-1);\r\n\t}\r\n\tvoid Find_l(int u,int F){\r\n\t\tfor (int id:vec[u]){\r\n\t\t\tif (u==que[id].u)  que[id].l=SA[que[id].k][1].solve();\r\n\t\t}\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v]&&(v^F))  ins_char(e[i].w),Find_l(v,u),len--;\r\n\t\t}\r\n\t}\r\n\tvoid Find_r(int u,int F){\r\n\t\tfor (int id:vec[u]){\r\n\t\t\tif (u==que[id].v)  que[id].r=SA[que[id].k][0].solve();\r\n\t\t}\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v]&&(v^F))  ins_char(e[i].w),Find_r(v,u),len--;\r\n\t\t}\r\n\t}\r\n\tvoid dfs_bel(int u,int F){\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif ((v^F)&&!vis[v])  bel[v]=bel[u],dfs_bel(v,u);\r\n\t\t}\r\n\t}\r\n\tvoid clr_all(int u,int F){\r\n\t\tvec[u].clear(),vec[u].shrink_to_fit();\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif ((v^F)&&!vis[v])  clr_all(v,u);\r\n\t\t}\r\n\t}\r\n\tvoid calc(int u){\r\n\t\tcntson=0,bel[u]=0;\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v])  son[++cntson]=v,bel[v]=cntson,dfs_bel(v,u);\r\n\t\t}\r\n\t\tfor (int id:qid){\r\n\t\t\tint x=que[id].u,y=que[id].v;\r\n\t\t\tif (bel[x]^bel[y])  vec[x].eb(id),vec[y].eb(id);\r\n\t\t}\r\n\t\tpart_1(u,0,0),part_2(u,0,0);\r\n\t\tlen=0,Find_l(u,0),Find_r(u,0);\r\n\t\tfor (int id:qid){\r\n\t\t\tKMP[que[id].k][0].Deal(que[id].l,0);\r\n\t\t\tKMP[que[id].k][1].Deal(que[id].r,1);\r\n\t\t\tque[id].ans+=Math::solve();\r\n\t\t}\r\n\t\tclr_all(u,0);\r\n\t}\r\n\tvoid get_tot(int u,int F){\r\n\t\ttot++;\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v]&&(v^F))  get_tot(v,u);\r\n\t\t}\r\n\t}\r\n\tvoid get_rot(int u,int F){\r\n\t\tint mx=0; sz[u]=1;\r\n\t\tfor (int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif (!vis[v]&&(v^F))  get_rot(v,u),sz[u]+=sz[v],mx=max(mx,sz[v]);\r\n\t\t}\r\n\t\tmx=max(mx,tot-sz[u]);\r\n\t\tif ((mx<<1)<=tot)  rot=u;\r\n\t}\r\n\tvoid dfs(int u){\r\n\t\tcalc(u),vis.set(u);\r\n\t\tvector<vector<int> >n_qid;\r\n\t\tvector<int> sl;  n_qid.resize(cntson);\r\n\t\tfor (auto id:qid){\r\n\t\t\tint u=que[id].u,v=que[id].v;\r\n\t\t\tif (bel[u]==bel[v])  n_qid[bel[u]-1].eb(id);\r\n\t\t}\r\n\t\tfor (int i=1;i<=cntson;i++)  sl.eb(son[i]);\r\n\t\tfor (int i=0,v;i<(int)sl.size();i++)if(!n_qid[i].empty()){\r\n\t\t\tv=sl[i],tot=0,get_tot(v,u),get_rot(v,u);\r\n\t\t\tswap(qid,n_qid[i]),dfs(rot),swap(qid,n_qid[i]);\r\n\t\t}\r\n\t}\r\n\tvoid solve(){\r\n\t\tfor (int i=1;i<=q;i++)  qid.eb(i);\r\n\t\tdfs(1);\r\n\t}\r\n}\r\nvoid Rev(){reverse(str+1,str+len+1);}\r\nvoid ACAM_ins(int id){ACAM[0].ins(id),Rev(),ACAM[1].ins(id),Rev();}\r\nvoid KMP_ins(int id){KMP[id][0].ins(),Rev(),KMP[id][1].ins(),Rev();}\r\nvoid SA_ins(int id){SA[id][0].ins(id,0),Rev(),SA[id][1].ins(id,1);}\r\nvoid init_pw(int n){\r\n\tpw[0]=1;\r\n\tfor (int i=1;i<=n;i++)  pw[i]=((ll)pw[i-1]*bas)%mod,lg[i]=__lg(i);\r\n}\r\nsigned main(){\r\n\tn=read(),m=read(),q=read(),init_pw(N-5),FW::n=1;\r\n\tfor (int i=1,u,v;i<n;i++){\r\n\t\tu=read(),v=read(),ch=readchar();\r\n\t\tTree::add_edge(u,v),Tree::add_edge(v,u);\r\n\t}\r\n\tfor (int i=1;i<=m;i++){\r\n\t\tscanf(\"%s\",str+1),len=strlen(str+1);\r\n\t\tFW::n+=len,ACAM_ins(i),KMP_ins(i),SA_ins(i);\r\n\t}\r\n\tfor (int i=1;i<=q;i++)  que[i].u=read(),que[i].v=read(),que[i].k=read();\r\n\tfor (int t=0;t<2;t++)  ACAM[t].work();\r\n\tTree::solve();\r\n\tfor (int i=1;i<=q;i++)  printf(\"%d\\n\",que[i].ans);\r\n\treturn 0;\r\n}"
}