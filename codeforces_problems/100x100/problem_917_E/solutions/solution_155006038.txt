{
    "id": 155006038,
    "contestId": 917,
    "creationTimeSeconds": 1650956818,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "legendgoddes"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1481,
    "memoryConsumedBytes": 164147200,
    "source": "#include <bits/stdc++.h>\n#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\nnamespace Legendgod {\n\tnamespace Read {\n//\t\t#define Fread\n\t\t#ifdef Fread\n\t\tconst int Siz = (1 << 21) + 5;\n\t\tchar *iS, *iT, buf[Siz];\n\t\t#define gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )\n\t\t#define getchar gc\n\t\t#endif\n\t\ttemplate <typename T>\n\t\tvoid r1(T &x) {\n\t\t    x = 0;\n\t\t\tchar c(getchar());\n\t\t\tint f(1);\n\t\t\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\n\t\t\tfor(; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n\t\t\tx *= f;\n\t\t}\n\t\ttemplate <typename T, typename...Args>\n\t\tvoid r1(T &x, Args&...arg) {\n\t\t\tr1(x), r1(arg...);\n\t\t}\n\t\t#undef getchar\n\t}\n\nusing namespace Read;\n\nconst int maxn = 2e5 + 5;\nint n, m, Q, head[maxn], cnt(1);\nstruct Edge {\n    int to, next, w;\n}edg[maxn << 1];\nvoid add(int u,int v,int w) {\n    edg[++ cnt] = (Edge) {v, head[u], w}, head[u] = cnt;\n}\nchar _s[maxn];\nconstexpr int mod1 = 1e9 + 7, mod2 = 1e9 + 9;\nstruct Hash {\n    int a, b;\n    Hash(int x = 0,int y = 0) : a(x), b(y) {}\n    Hash operator + (const Hash& z) { return (Hash){(a + z.a) % mod1, (b + z.b) % mod2}; }\n    Hash operator - (const Hash& z) { return (Hash){(a - z.a + mod1) % mod1, (b - z.b + mod2) % mod2}; }\n    Hash operator * (const Hash& z) { return (Hash){1ll * a * z.a % mod1, 1ll * b * z.b % mod2}; }\n    bool operator == (const Hash& z) { return (a == z.a) && (b == z.b); }\n}pw[maxn], th[maxn];\nconst Hash base = (Hash){13331, 131};\nint fa[maxn][21], cl[maxn], dep[maxn];\nHash Thas(int u,int lc) {\n    return th[u] - th[lc] * pw[dep[u] - dep[lc]];\n}\n\nvoid dfs(int p,int pre) {\n    fa[p][0] = pre, dep[p] = dep[pre] + 1;\n    for(int i = 1; i < 19; ++ i) fa[p][i] = fa[fa[p][i - 1]][i - 1];\n    for(int i = head[p];i;i = edg[i].next) {\n        int to = edg[i].to; if(to == pre) continue;\n        cl[to] = edg[i].w, th[to] = th[p] * base + (Hash){cl[to], cl[to]};\n        dfs(to, p);\n    }\n}\n\nint Lca(int u,int v) {\n    if(dep[u] < dep[v]) swap(u, v);\n    int d = dep[u] - dep[v];\n    for(int i = 18; i >= 0; -- i) if((d >> i) & 1) u = fa[u][i];\n    if(u == v) return u;\n    for(int i = 18; i >= 0; -- i) {\n        if(fa[u][i] != fa[v][i]) {\n            u = fa[u][i], v = fa[v][i];\n        }\n    }\n    return fa[u][0];\n}\n\nint Jump(int u,int k) {\n    for(int i = 18; i >= 0; -- i) if((k >> i) & 1) u = fa[u][i];\n    return u;\n}\n\nstruct ACAM {\n    int tr[maxn][27], fl[maxn], tot, pos[maxn];\n    vector<int> vc[maxn];\n    ACAM(void) : tot(1) {}\n    void Insert(char* str,int m,int id) {\n        int p = 1;\n        for(int i = 1; i <= m; ++ i) {\n            int x = str[i] - 'a' + 1;\n            if(!tr[p][x]) tr[p][x] = ++ tot;\n            p = tr[p][x];\n        }\n        pos[id] = p;\n    }\n    int dfn[maxn], edfn[maxn], dfntot;\n    void dfs(int p) {\n        dfn[p] = ++ dfntot;\n        for(const int& v : vc[p]) dfs(v);\n        edfn[p] = dfntot;\n    }\n    void build() {\n        static queue<int> q; while(!q.empty()) q.pop();\n        for(int i = 1; i <= 26; ++ i) if(tr[1][i]) q.push(tr[1][i]), fl[tr[1][i]] = 1;\n        else tr[1][i] = 1;\n        while(!q.empty()) {\n            int u = q.front(); q.pop();\n            for(int v, i = 1; i <= 26; ++ i) {\n                v = tr[u][i];\n                if(v) {\n                    q.push(v), fl[v] = tr[fl[u]][i];\n                }\n                else tr[u][i] = tr[fl[u]][i];\n            }\n        }\n        for(int i = 2; i <= tot; ++ i) vc[fl[i]].emplace_back(i);\n        dfntot = 0;\n        dfs(1);\n    }\n    int t[maxn];\n    int lowbit(int x) { return x & -x; }\n    void add(int p,int c) { assert(p != 0); p = dfn[p]; for(; p <= tot; p += lowbit(p)) t[p] += c;}\n    int ask(int p) { int res(0); for(; p > 0; p -= lowbit(p)) res += t[p]; return res; }\n    int query(int x) { x = pos[x]; return ask(edfn[x]) - ask(dfn[x] - 1); }\n}Ta[2];\n// Arithmetic sequence\nstruct Arith {\n    int s, t, d;\n};\n\nstruct KMP {\n    int *bel, *nxt, *del, n;\n    void Insert(char* str,int m) {\n        bel = new int[m + 2] ();\n        nxt = new int[m + 2] ();\n        del = new int[m + 2] ();\n        n = m;\n        del[1] = 1, bel[1] = 1;\n        for(int i = 2, j = 0; i <= n; ++ i) {\n            while(j && str[j + 1] != str[i]) j = nxt[j];\n//            printf(\"j = %d\\n\", j);\n            if(str[j + 1] == str[i]) ++ j;\n            del[i] = i - j, nxt[i] = j;\n            bel[i] = (del[i] == del[j] ? bel[j] : i);\n        }\n    }\n    void Get(int p,int len,Arith* ret, int& tot) const {\n        for(; p > len; p = nxt[p]) ;\n        while(p > 0) {\n            int s = bel[p], t = p, d = del[p];\n            ret[++ tot] = {s, t, d};\n            p = nxt[s];\n        }\n    }\n}p[2][maxn];\n\nint buc[maxn];\n\nstruct SA {\n    int *a, *sa, *sa2, *rk, n, m;\n    Hash *h;\n\n    void Sort() {\n        for(int i = 1; i <= m; ++ i) buc[i] = 0;\n        for(int i = 1; i <= n; ++ i) buc[rk[i]] ++;\n        for(int i = 1; i <= m; ++ i) buc[i] += buc[i - 1];\n        for(int i = n; i >= 1; -- i) sa[buc[rk[sa2[i]]] --] = sa2[i];\n    }\n\n    void Insert(char *str, int ln) {\n        n = ln, m = 26;\n        a = new int[n + 2] ();\n        sa = new int[n + 2] ();\n        sa2 = new int[n + 2] ();\n        rk = new int[n + 2] ();\n        h = new Hash[n + 2] ();\n        for(int i = 1; i <= n; ++ i) a[i] = str[i] - 'a' + 1, h[i] = h[i - 1] * base + (Hash){a[i], a[i]};\n        for(int i = 1; i <= n; ++ i) rk[i] = a[i], sa2[i] = i;\n        Sort();\n\n        for(int i = 1; i <= n; i <<= 1) {\n            int num(0);\n            for(int j = n - i + 1; j <= n; ++ j) sa2[++ num] = j;\n            for(int j = 1; j <= n; ++ j) if(sa[j] > i)\n                sa2[++ num] = sa[j] - i;\n            Sort();\n            swap(rk, sa2);\n            num = 1;\n            rk[sa[1]] = 1;\n            for(int j = 2; j <= n; ++ j)\n                rk[sa[j]] = (sa2[sa[j]] == sa2[sa[j - 1]] && sa2[sa[j] + i] == sa2[sa[j - 1] + i]) ? num : ++ num;\n            if(num >= n) break;\n            m = num;\n        }\n    }\n\n    Hash Has(int l,int r) {\n        return h[r] - h[l - 1] * pw[r - l + 1];\n    }\n\n    int lcp(int id, int u,int lc) {\n        int x = sa[id], ln = n - x + 1;\n        if(u == lc) return 0;\n        if(ln >= dep[u] - dep[lc] && Thas(u, lc) == Has(x, x + dep[u] - dep[lc] - 1)) return dep[u] - dep[lc];\n        for(int i = 18; i >= 0; -- i) if(dep[u] - dep[lc] > (1 << i))\n            if( (ln < dep[fa[u][i]] - dep[lc]) || ( !(Thas(fa[u][i], lc) == Has(x, x + dep[fa[u][i]] - dep[lc] - 1)) ) ) {\n                u = fa[u][i];\n            }\n        u = fa[u][0];\n        return dep[u] - dep[lc];\n    }\n\n    bool check(int mid, int u,int lc) {\n        int L = lcp(mid, u, lc);\n        if(L == n - sa[mid] + 1) return 1;\n        if(L == dep[u] - dep[lc]) return 0;\n        return a[sa[mid] + L] < cl[Jump(u, dep[u] - dep[lc] - L - 1)];\n    }\n\n    void Solve(int u,int lc,KMP& kp, Arith* ret, int& num) {\n        int l = 1, r = n, mid, ans(0);\n        while(l <= r) {\n            mid = (l + r) >> 1;\n            if(check(mid, u, lc)) ans = mid, l = mid + 1;\n            else r = mid - 1;\n        }\n        num = 0;\n        if(!ans) return ;\n        int p = n - sa[ans] + 1, ln = lcp(ans, u, lc);\n        kp.Get(p, ln, ret, num);\n    }\n\n}s[2][maxn];\n\nlong long ans[maxn];\n\nstruct Quer {\n    int id, opt, C, str;\n};\nvector<Quer> q[maxn];\nint sstr[maxn];\n\nvoid dfs2(int p,int pre,int num0, int num1) {\n//    assert(num0 != 0 && num1 != 0);\n    Ta[0].add(num0, 1), Ta[1].add(num1, 1);\n    for(const Quer& v : q[p]) {\n        ans[v.id] += v.C * Ta[v.opt].query(v.str);\n    }\n    for(int i = head[p];i;i = edg[i].next) {\n        int to = edg[i].to; if(to == pre) continue;\n        int c = edg[i].w;\n        dfs2(to, p, Ta[0].tr[num0][c], Ta[1].tr[num1][c]);\n    }\n    Ta[0].add(num0, - 1), Ta[1].add(num1, - 1);\n}\n\nvoid qadd(int u,int lc,int c,int id,int op) {\n    if(dep[u] - dep[lc] < sstr[c]) return ;\n    q[u].push_back({id, op, 1, c});\n    int x = Jump(u, dep[u] - dep[lc] - sstr[c] + 1);\n    q[x].push_back({id, op, - 1, c});\n}\n\nnamespace Chain {\n    Arith a1[65], a2[65];\n    int n1, n2;\n    int exgcd(int a,int b,int& x,int& y) {\n        if(b == 0) return x = 1, y = 0, a;\n        int gc = exgcd(b, a % b, x, y); long long z = x;\n        x = y, y = z - a / b * y;\n        return gc;\n    }\n\n    int Calc(int a,int b,int ua,int ub,int c) {\n        int x, y, x1, y1, dx, dy, mx;\n        int gd = exgcd(a, b, x, y);\n        if(c % gd != 0) return 0;\n        x1 = c / gd * x, y1 = c / gd * y;\n        dx = b / gd, dy = a / gd, mx = x1 % dx;\n        if(mx < 0) mx += dx;\n        y1 += ((x1 - mx) / dx) * dy, x1 = mx;\n        if(y1 < 0) return 0;\n        if(y1 > ub) {\n            int tmp = (y1 - ub - 1) / dy + 1;\n            y1 -= tmp * dy, x1 += tmp * dx;\n        }\n        if(x1 < 0 || y1 < 0 || x1 > ua || y1 > ub) return 0;\n        return min((ua - x1) / dx + 1, y1 / dy + 1);\n    }\n\n    int calc(Arith& x, Arith& y,int ln) {\n        return Calc(x.d, y.d, (x.t - x.s) / x.d, (y.t - y.s) / y.d, ln - x.s - y.s);\n    }\n\n    void Solve(int u, int v,int lc, int id,int qi) {\n        s[1][id].Solve(u, lc, p[0][id], a1, n1);\n        s[0][id].Solve(v, lc, p[1][id], a2, n2);\n//        assert(n1 < 60 && n2 < 60);\n        int ln = sstr[id];\n        for(int a = 1; a <= n1; ++ a) for(int b = 1; b <= n2; ++ b)\n        if(a1[a].s + a2[b].s <= ln && a1[a].t + a2[b].t >= ln)\n            ans[qi] += calc(a1[a], a2[b], ln);\n    }\n}\n\nsigned main() {\n\tint i, j;\n    r1(n, m, Q);\n    pw[0] = {1, 1};\n    for(i = 1; i < maxn; ++ i) pw[i] = pw[i - 1] * base;\n    for(i = 1; i < n; ++ i) {\n        int u, v; r1(u, v), scanf(\"%s\", _s + 1);\n        add(u, v, _s[1] - 'a' + 1), add(v, u, _s[1] - 'a' + 1);\n    }\n    dfs(1, 0);\n    for(i = 1; i <= m; ++ i) {\n        scanf(\"%s\", _s + 1);\n        int ln = strlen(_s + 1);\n        sstr[i] = ln;\n        Ta[0].Insert(_s, ln, i);\n        p[0][i].Insert(_s, ln);\n        s[0][i].Insert(_s, ln);\n        reverse(_s + 1, _s + ln + 1);\n        Ta[1].Insert(_s, ln, i);\n        p[1][i].Insert(_s, ln);\n        s[1][i].Insert(_s, ln);\n    }\n    Ta[0].build(), Ta[1].build();\n    /*\nstruct Quer {\n    int id, opt, C, str;\n};\n    */\n    for(i = 1; i <= Q; ++ i) {\n        int u, v, c;\n        r1(u, v, c);\n        int lc = Lca(u, v);\n        qadd(u, lc, c, i, 1), qadd(v, lc, c, i, 0);\n        Chain::Solve(u, v, lc, c, i);\n    }\n//    for(i = 1; i <= Q; ++ i) printf(\"%d : %lld\\n\", i, ans[i]);\n    dfs2(1, 0, 1, 1);\n    for(i = 1; i <= Q; ++ i) printf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}\n\n}\n\n\nsigned main() { return Legendgod::main(), 0; }//\n"
}