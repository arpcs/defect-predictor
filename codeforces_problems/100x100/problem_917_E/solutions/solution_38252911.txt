{
    "id": 38252911,
    "contestId": 917,
    "creationTimeSeconds": 1526346819,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "FizzyDavid"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 2386,
    "memoryConsumedBytes": 493465600,
    "source": "//by yjz\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define FF first\r\n#define SS second\r\n#define PB push_back\r\n#define MP make_pair\r\n#define bged(v) (v).begin(),(v).end()\r\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\r\ntypedef long long ll;\r\nconst int Imx=2147483647;\r\nconst ll Lbig=2e18;\r\nconst int mod=1e9+7;\r\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\r\nconst int maxn=200111;\r\nconst int maxTRIEn=1800111;\r\nnamespace KMP\r\n{\r\n\tint extgcd(int a,int b,int &x,int &y)\r\n\t{\r\n\t\tif(b==0)\r\n\t\t{\r\n\t\t\tx=1;y=0;\r\n\t\t\tif(a<0)a=-a,x=-x;\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint ret=extgcd(b,a%b,x,y);\r\n\t\t\tint nx=y,ny=x-(a/b)*y;\r\n\t\t\tx=nx;y=ny;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t}\r\n\tll rdown(ll p,ll q){return q<0?rdown(-p,-q):(p>0?p/q:-(-p+q-1)/q);}\r\n\tll rup(ll p,ll q){return -rdown(-p,q);}\r\n\tstruct sub\r\n\t{\r\n\t\tint s,d,cnt;//d>0\r\n\t\tsub(int S=0,int D=0,int CNT=0){s=S;d=D;cnt=CNT;}\r\n\t\tint calc(const sub &t)\r\n\t\t{\r\n\t\t\tint a=-d,b=t.d,x,y,c=s-t.s;\r\n\t\t\tint g=extgcd(a,b,x,y);\r\n\t\t\tif(c%g!=0)return 0;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tb/=g;a/=-g;\r\n\t\t\t\tll X=1ll*x*(c/g),Y=1ll*y*(c/g);\r\n\t\t\t\tll l=max(rup(-X,b),rup(-Y,a));\r\n\t\t\t\tll r=min(rdown(cnt-X-1,b),rdown(t.cnt-Y-1,a));\r\n\t\t\t\treturn max(0ll,r-l+1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsub flip(int x){return sub(x-(s+(cnt-1)*d),d,cnt);}\r\n\t\tint end(){return s+(cnt-1)*d;}\r\n\t};\r\n\tvector<int> Fail[maxn],Slink[maxn];\r\n\tvoid construct(char s[],int n,int id)\r\n\t{\r\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\r\n\t\tfail.resize(n+1);\r\n\t\tslink.resize(n+1);\r\n\t\tfail[0]=0;fail[1]=0;\r\n\t\tfor(int i=2;i<=n;i++)\r\n\t\t{\r\n\t\t\tint &p=fail[i];\r\n\t\t\tp=fail[i-1];\r\n\t\t\twhile(p&&s[p+1]!=s[i])p=fail[p];\r\n\t\t\tif(s[p+1]==s[i])p++;\r\n\t\t}\r\n\t\tfor(int i=1;i<=n;i++)slink[i]=fail[i]==0?0:(i-fail[i]==fail[i]-fail[fail[i]]?slink[fail[i]]:fail[i]);\r\n\t}\r\n\tvector<sub> extract(int id,int x)\r\n\t{\r\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\r\n\t\tassert(x<fail.size()&&x<slink.size());\r\n\t\tvector<sub> ret;\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tint d=x-fail[x];\r\n\t\t\tret.PB(sub(slink[x]+d,d,(x-slink[x])/d));\r\n\t\t\tx=slink[x];\r\n\t\t}\r\n\t\treverse(ret.begin(),ret.end());\r\n//\t\tfor(int i=0;i<ret.size();i++)cerr<<ret[i].s<<\",\"<<ret[i].d<<\",\"<<ret[i].cnt<<\" \";cerr<<endl;\r\n\t\treturn ret;\r\n\t}\r\n\tint query(int x,int xl,int y,int yl,int tot)\r\n\t{\r\n//\t\tcerr<<\"KMP::query:\"<<x<<\" \"<<xl<<\" \"<<y<<\" \"<<yl<<\" \"<<tot<<endl;\r\n\t\tvector<sub> vx=extract(x,xl);\r\n\t\tvector<sub> vy=extract(y,yl);\r\n\t\tfor(int i=0;i<vy.size();i++)vy[i]=vy[i].flip(tot);\r\n\t\treverse(vy.begin(),vy.end());\r\n//\t\tfor(int i=0;i<vx.size();i++)cerr<<vx[i].s<<\",\"<<vx[i].d<<\",\"<<vx[i].cnt<<\" \";cerr<<endl;\r\n//\t\tfor(int i=0;i<vy.size();i++)cerr<<vy[i].s<<\",\"<<vy[i].d<<\",\"<<vy[i].cnt<<\" \";cerr<<endl;\r\n\t\tint itx=0,ity=0,ret=0;\r\n\t\twhile(itx<vx.size()&&ity<vy.size())\r\n\t\t{\r\n\t\t\tret+=vx[itx].calc(vy[ity]);\r\n\t\t\tif(vx[itx].end()<=vy[ity].end())itx++;\r\n\t\t\telse ity++;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n};\r\nconst ll hs_B=233;\r\nconst ll hs_mod=100000000000031ll;\r\nint bit_tab[maxTRIEn];\r\nvoid bit_add(int x,int coef)\r\n{\r\n\tfor(int i=x;i<maxTRIEn;i+=i&(-i))bit_tab[i]+=coef;\r\n}\r\nint bit_query(int x)\r\n{\r\n\tint ret=0;\r\n\tfor(int i=x;i;i-=i&(-i))ret+=bit_tab[i];\r\n\treturn ret;\r\n}\r\nnamespace AC\r\n{\r\n\t//TRIE\r\n\tint tot=1,go[maxTRIEn][26];\r\n\tll hs[maxTRIEn];\r\n\tint fa[maxTRIEn],pc[maxTRIEn];\r\n\tpair<ll,int> hs_arr[maxTRIEn];\r\n\tint insert(int p,int c)\r\n\t{\r\n\t\t//cerr<<\"insert:\"<<p<<\" \"<<c<<endl;\r\n\t\tint &q=go[p][c];\r\n\t\tif(!q)\r\n\t\t{\r\n\t\t\tq=++tot,fa[q]=p,pc[q]=c,hs[q]=(hs[p]*hs_B+c+1)%hs_mod;\r\n\t\t\tassert(tot<maxTRIEn);\r\n\t\t}\r\n\t\treturn q;\r\n\t}\r\n\tint fail[maxTRIEn];\r\n\tvector<int> con[maxTRIEn];//store fail tree\r\n\tint fdfn[maxTRIEn],fdfnr[maxTRIEn],dfntot;\r\n\tvoid fdfs(int x)\r\n\t{\r\n\t\tfdfn[x]=++dfntot;\r\n\t\tfor(int i=0;i<con[x].size();i++)\r\n\t\t{\r\n\t\t\tint u=con[x][i];\r\n\t\t\tfdfs(u);\r\n\t\t}\r\n\t\tfdfnr[x]=dfntot;\r\n\t}\r\n\t\r\n\t//HLD\r\n\tint son[maxTRIEn],top[maxTRIEn],lv[maxTRIEn];\r\n\tset<int> st[maxTRIEn];\r\n\tint dfs(int x)\r\n\t{\r\n\t\tint sz=1,mx=0;\r\n\t\tson[x]=0;\r\n\t\tfor(int i=0;i<26;i++)\r\n\t\t{\r\n\t\t\tint u=go[x][i];\r\n\t\t\tif(!u)continue;\r\n\t\t\tlv[u]=lv[x]+1;\r\n\t\t\tint szu=dfs(u);\r\n\t\t\tsz+=szu;\r\n\t\t\tif(szu>mx)son[x]=u,mx=szu;\r\n\t\t}\r\n\t\treturn sz;\r\n\t}\r\n\tvoid dfs2(int x,int tp)\r\n\t{\r\n\t\ttop[x]=tp;\r\n\t\tif(son[x])dfs2(son[x],tp);\r\n\t\tfor(int i=0;i<26;i++)\r\n\t\t{\r\n\t\t\tint u=go[x][i];\r\n\t\t\tif(u==son[x]||!u)continue;\r\n\t\t\tdfs2(u,u);\r\n\t\t}\r\n\t}\r\n\tvoid construct_HLD()\r\n\t{\r\n\t\tlv[1]=0;\r\n\t\tdfs(1);\r\n\t\tdfs2(1,1);\r\n\t}\r\n\tvoid HLDflip(int x)\r\n\t{\r\n\t\tint g=top[x];\r\n\t\tif(st[g].find(lv[x])==st[g].end())st[g].insert(lv[x]);\r\n\t\telse st[g].erase(lv[x]);\r\n\t}\r\n\tint HLDquery(int x)\r\n\t{\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tif(st[top[x]].size()>0&&*st[top[x]].begin()<=lv[x])return *(--st[top[x]].lower_bound(lv[x]+1));\r\n\t\t\tx=fa[top[x]];\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tint q[maxTRIEn],qn;\r\n\tvoid construct()\r\n\t{\r\n//\t\tcerr<<\"construct:\"<<endl;\r\n//\t\tfor(int i=2;i<=tot;i++)cerr<<i<<\":\"<<fa[i]<<\",\"<<pc[i]<<\" \";cerr<<endl;\r\n//\t\tfor(int i=1;i<=tot;i++)cerr<<hs[i]<<\" \";cerr<<endl;\r\n\t\tconstruct_HLD();\r\n\t\tfor(int i=1;i<=tot;i++)hs_arr[i]=MP(hs[i],i);\r\n\t\tsort(hs_arr+1,hs_arr+tot+1);\r\n\t\tqn=0;q[qn++]=1;\r\n\t\tfor(int i=0;i<qn;i++)\r\n\t\t{\r\n\t\t\tint x=q[i];\r\n\t\t\tfor(int j=0;j<26;j++)\r\n\t\t\t{\r\n\t\t\t\tif(!go[x][j])continue;\r\n\t\t\t\tq[qn++]=go[x][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\tfail[1]=1;\r\n\t\tfor(int i=1;i<qn;i++)\r\n\t\t{\r\n\t\t\tint x=q[i];\r\n\t\t\tint &p=fail[x];\r\n\t\t\tif(fa[x]==1)p=1;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tp=fail[fa[x]];\r\n\t\t\t\twhile(p!=1&&!go[p][pc[x]])p=fail[p];\r\n\t\t\t\tif(go[p][pc[x]])p=go[p][pc[x]];\r\n\t\t\t}\r\n\t\t\tcon[fail[x]].PB(x);\r\n\t\t}\r\n\t\t//for(int i=1;i<=tot;i++)cerr<<fail[i]<<\" \";cerr<<endl;\r\n\t\tfdfs(1);\r\n\t}\r\n\tint qans[maxTRIEn],qans2[maxTRIEn];\r\n\tvector<pair<int,int> > qr[maxTRIEn],qr2[maxTRIEn];\r\n\tvoid dfs_solve_p1(int x)\r\n\t{\r\n\t\tbit_add(fdfn[x],1);\r\n\t\tfor(int i=0;i<qr[x].size();i++)\r\n\t\t{\r\n\t\t\tint pos=qr[x][i].FF;\r\n\t\t\tqans[qr[x][i].SS]+=bit_query(fdfnr[pos])-bit_query(fdfn[pos]-1);\r\n\t\t}\r\n\t\tfor(int i=0;i<26;i++)if(go[x][i])dfs_solve_p1(go[x][i]);\r\n\t\tbit_add(fdfn[x],-1);\r\n\t}\r\n\tvoid dfs_solve_p2(int x,ll hs=0,ll hs_bs=1)\r\n\t{\r\n\t\tint p=lower_bound(hs_arr+1,hs_arr+tot+1,MP(hs,0))-hs_arr;\r\n\t\tif(hs_arr[p].FF==hs)HLDflip(hs_arr[p].SS);\r\n\t\tfor(int i=0;i<qr2[x].size();i++)\r\n\t\t{\r\n\t\t\tqans2[qr2[x][i].SS]=HLDquery(qr2[x][i].FF);\r\n\t\t}\r\n\t\tfor(int i=0;i<26;i++)if(go[x][i])dfs_solve_p2(go[x][i],(hs+hs_bs*(i+1))%hs_mod,hs_bs*hs_B%hs_mod);\r\n\t\tif(hs_arr[p].FF==hs)HLDflip(hs_arr[p].SS);\r\n\t}\r\n\tvoid add_query(int ui,int vi,int si,int ti,int id)\r\n\t{\r\n//\t\tcerr<<\"add_query:\"<<ui<<\",\"<<vi<<\" \"<<si<<\",\"<<ti<<\" \"<<id<<endl;\r\n\t\tqr[ui].PB(MP(ti,id));\r\n\t\tqr[vi].PB(MP(si,id));\r\n\t\tqr2[si].PB(MP(ui,id*2));\r\n\t\tqr2[ti].PB(MP(vi,id*2+1));\r\n\t}\r\n\tpair<int,pair<int,int> > get_query(int id)\r\n\t{\r\n\t\treturn MP(qans[id],MP(qans2[id*2],qans2[id*2+1]));\r\n\t}\r\n\tvoid solve()\r\n\t{\r\n//\t\tcerr<<\"solve_part1:\"<<endl;\r\n\t\tmemset(qans,0,sizeof(qans));\r\n\t\tdfs_solve_p1(1);\r\n//\t\tcerr<<\"solve_part2:\"<<endl;\r\n\t\tdfs_solve_p2(1);\r\n//\t\tcerr<<\"solved\"<<endl;\r\n\t}\r\n};\r\nint n,m,q;\r\nvector<pair<int,char> > con[maxn];\r\nvector<pair<int,int> > qr[maxn];\r\nint qu[maxn],qv[maxn],qx[maxn],uid[maxn],vid[maxn];\r\nvector<int> sid[maxn];\r\nint cur_rt,cur_lv;\r\nint dlv[maxn],sz[maxn],arr[maxn],an,gr[maxn],id[maxn];\r\nvoid pdfs(int x,int pre=-1)\r\n{\r\n\tsz[x]=1;arr[an++]=x;dlv[x]=cur_lv+1;\r\n\tfor(int i=0;i<con[x].size();i++)\r\n\t{\r\n\t\tint u=con[x][i].FF;\r\n\t\tif(u==pre||dlv[u]<cur_lv)continue;\r\n\t\tpdfs(u,x);\r\n\t\tsz[x]+=sz[u];\r\n\t}\r\n}\r\nint findrt(int x)\r\n{\r\n\tan=0;\r\n\tpdfs(x);\r\n\tint ret=x;\r\n\tfor(int i=0;i<an;i++)if(sz[arr[i]]*2>=sz[x]&&sz[arr[i]]<sz[ret])ret=arr[i];\r\n\treturn ret;\r\n}\r\nvoid dfs(int x,int pre,int g)\r\n{\r\n\tgr[x]=g;\r\n\tfor(int i=0;i<con[x].size();i++)\r\n\t{\r\n\t\tint u=con[x][i].FF;\r\n\t\tif(u==pre||dlv[u]<cur_lv)continue;\r\n\t\tid[u]=AC::insert(id[x],con[x][i].SS-'a');\r\n\t\tdfs(u,x,pre==-1?u:g);\r\n\t}\r\n}\r\nvoid solve(int X,int lv)\r\n{\r\n\t//cerr<<\"solve:\"<<X<<\" \"<<lv<<endl;\r\n\tcur_lv=lv;\r\n\tint rt=findrt(X);\r\n\t//cerr<<\"rt=\"<<rt<<endl;\r\n\tcur_rt=rt;\r\n\tdlv[rt]=lv;\r\n\tid[rt]=1;\r\n\tdfs(rt,-1,rt);\r\n\tstatic bool vis[maxn];\r\n\tfor(int i=0;i<an;i++)vis[arr[i]]=1;\r\n\tfor(int i=0;i<an;i++)\r\n\t{\r\n\t\tint x=arr[i];\r\n\t\tfor(int j=0;j<qr[x].size();j++)\r\n\t\t{\r\n\t\t\tint y=qr[x][j].FF;\r\n\t\t\tif(vis[y]&&gr[y]!=gr[x])\r\n\t\t\t{\r\n\t\t\t\tuid[qr[x][j].SS]=id[x];\r\n\t\t\t\tvid[qr[x][j].SS]=id[y];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<an;i++)vis[arr[i]]=0;\r\n\tfor(int i=0;i<con[rt].size();i++)\r\n\t{\r\n\t\tint u=con[rt][i].FF;\r\n\t\tif(dlv[u]<lv)continue;\r\n\t\tsolve(u,lv+1);\r\n\t}\r\n}\r\nchar s[maxn];\r\nint main()\r\n{\r\n\tscanf(\"%d%d%d\",&n,&m,&q);\r\n\tfor(int i=1;i<n;i++)\r\n\t{\r\n\t\tint x,y;\r\n\t\tchar c;\r\n\t\tscanf(\"%d %d %c\",&x,&y,&c);\r\n\t\tcon[x].PB(MP(y,c));\r\n\t\tcon[y].PB(MP(x,c));\r\n\t}\r\n\tfor(int i=1;i<=m;i++)\r\n\t{\r\n\t\tscanf(\"%s\",s+1);\r\n\t\tint l=strlen(s+1);\r\n\t\tint p;\r\n\t\tp=1;sid[i].PB(1);\r\n\t\tfor(int j=1;j<=l;j++)p=AC::insert(p,s[j]-'a'),sid[i].PB(p);\r\n\t\tKMP::construct(s,l,i);\r\n\t\treverse(s+1,s+l+1);\r\n\t\tp=1;sid[i+m].PB(1);\r\n\t\tfor(int j=1;j<=l;j++)p=AC::insert(p,s[j]-'a'),sid[i+m].PB(p);\r\n\t\tKMP::construct(s,l,i+m);\r\n\t\treverse(s+1,s+l+1);\r\n\t}\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tint u,v,x;\r\n\t\tscanf(\"%d%d%d\",&u,&v,&x);\r\n\t\tqr[u].PB(MP(v,i));\r\n\t\tqu[i]=u;qv[i]=v;qx[i]=x;\r\n\t}\r\n\tsolve(1,0);\r\n\tAC::construct();\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tAC::add_query(uid[i],vid[i],sid[qx[i]].back(),sid[qx[i]+m].back(),i);\r\n\t}\r\n\tAC::solve();\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tpair<int,pair<int,int> > pp=AC::get_query(i);\r\n//\t\tcerr<<\"Query Answer: \"<<i<<\" - \"<<pp.FF<<\" \"<<pp.SS.FF<<\",\"<<pp.SS.SS<<endl;\r\n\t}\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tpair<int,pair<int,int> > pp=AC::get_query(i);\r\n\t\tint ans=pp.FF;\r\n\t\tans+=KMP::query(qx[i],pp.SS.FF,qx[i]+m,pp.SS.SS,sid[qx[i]].size()-1);\r\n\t\tprintf(\"%d\\n\",ans);\r\n\t}\r\n\treturn 0;\r\n}\r\n"
}