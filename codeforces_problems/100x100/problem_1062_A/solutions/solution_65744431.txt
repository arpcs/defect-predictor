{
    "id": 65744431,
    "contestId": 1062,
    "creationTimeSeconds": 1574768463,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1062,
        "index": "A",
        "name": "A Prank",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1300,
        "tags": [
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 1062,
        "members": [
            {
                "handle": "AnkushSharma"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1542209700
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 99,
    "timeConsumedMillis": 140,
    "memoryConsumedBytes": 0,
    "source": "import java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader; \r\nimport java.io.InputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\nimport java.util.InputMismatchException;\r\nimport java.io.DataInputStream; \r\nimport java.io.FileInputStream; \r\nimport java.io.IOException; \r\nimport java.util.ArrayList;\r\nimport java.util.Scanner; \r\nimport java.util.StringTokenizer; \r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\npublic final class AnkushJavaTemplate{ \r\n    static class FastReader { \r\n        final private int BUFFER_SIZE = 1 << 16; \r\n        private DataInputStream din; \r\n        private byte[] buffer; \r\n        private int bufferPointer, bytesRead; \r\n  \r\n        public FastReader() \r\n        { \r\n            din = new DataInputStream(System.in); \r\n            buffer = new byte[BUFFER_SIZE]; \r\n            bufferPointer = bytesRead = 0; \r\n        } \r\n  \r\n        public FastReader(String file_name) throws IOException \r\n        { \r\n            din = new DataInputStream(new FileInputStream(file_name)); \r\n            buffer = new byte[BUFFER_SIZE]; \r\n            bufferPointer = bytesRead = 0; \r\n        } \r\n\r\n        //Method to read String values\r\n        public String nextLine() throws IOException \r\n        { \r\n            byte[] buf = new byte[1000000]; // line length \r\n            int cnt = 0, c; \r\n            while ((c = read()) != -1) \r\n            { \r\n                if (c == '\\n') \r\n                    break; \r\n                buf[cnt++] = (byte) c; \r\n            } \r\n            return new String(buf, 0, cnt).trim(); \r\n        } \r\n\r\n        //Method to read Integer values\r\n        public int nextInt() throws IOException \r\n        { \r\n            int ret = 0; \r\n            byte c = read(); \r\n            while (c <= ' ') \r\n                c = read(); \r\n            boolean neg = (c == '-'); \r\n            if (neg) \r\n                c = read(); \r\n            do\r\n            { \r\n                ret = ret * 10 + c - '0'; \r\n            }  while ((c = read()) >= '0' && c <= '9'); \r\n  \r\n            if (neg) \r\n                return -ret; \r\n            return ret; \r\n        }\r\n\r\n        //Method to read Long values\r\n        public long nextLong() throws IOException \r\n        { \r\n            long ret = 0; \r\n            byte c = read(); \r\n            while (c <= ' ') \r\n                c = read(); \r\n            boolean neg = (c == '-'); \r\n            if (neg) \r\n                c = read(); \r\n            do { \r\n                ret = ret * 10 + c - '0'; \r\n            } \r\n            while ((c = read()) >= '0' && c <= '9'); \r\n            if (neg) \r\n                return -ret; \r\n            return ret; \r\n        } \r\n\r\n        //Method to read Double data type values\r\n        public double nextDouble() throws IOException \r\n        { \r\n            double ret = 0, div = 1; \r\n            byte c = read(); \r\n            while (c <= ' ') \r\n                c = read(); \r\n            boolean neg = (c == '-'); \r\n            if (neg) \r\n                c = read(); \r\n  \r\n            do { \r\n                ret = ret * 10 + c - '0'; \r\n            } \r\n            while ((c = read()) >= '0' && c <= '9'); \r\n  \r\n            if (c == '.') \r\n            { \r\n                while ((c = read()) >= '0' && c <= '9') \r\n                { \r\n                    ret += (c - '0') / (div *= 10); \r\n                } \r\n            } \r\n  \r\n            if (neg) \r\n                return -ret; \r\n            return ret; \r\n        } \r\n  \r\n        private void fillBuffer() throws IOException \r\n        { \r\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \r\n            if (bytesRead == -1) \r\n                buffer[0] = -1; \r\n        } \r\n  \r\n        private byte read() throws IOException \r\n        { \r\n            if (bufferPointer == bytesRead) \r\n                fillBuffer(); \r\n            return buffer[bufferPointer++]; \r\n        } \r\n  \r\n        public void close() throws IOException \r\n        { \r\n            if (din == null) \r\n                return; \r\n            din.close(); \r\n        } \r\n    }\r\n    int[] radixSort(int[] f){\r\n        int[] to = new int[f.length];\r\n        {\r\n            int[] b = new int[65537];\r\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\r\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\r\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\r\n            int[] d = f; f = to;to = d;\r\n        }\r\n        {\r\n            int[] b = new int[65537];\r\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\r\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\r\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\r\n            int[] d = f; f = to;to = d;\r\n        }\r\n        return f;\r\n    }\r\n    int phi(long n){ \r\n        long result = n;  \r\n      \r\n        // Consider all prime factors of n and subtract their multiples from result \r\n        for (long p = 2L; p * p <= n; ++p) { \r\n              \r\n            // Check if p is  a prime factor. \r\n            if (n % p == 0)  { \r\n                  \r\n                // If yes, then update n and result \r\n                while (n % p == 0) \r\n                    n /= p; \r\n                result -= result / p; \r\n            } \r\n        } \r\n    \r\n        // If n has a prime factor greater than sqrt(n)  (There can be at-most one such prime factor) \r\n        if (n > 1) \r\n            result -= result / n; \r\n        return (int)result; \r\n    }\r\n    void shuffleArray(long[] arr){\r\n        int n = arr.length;\r\n        Random rnd = new Random();\r\n        for(int i=0; i<n; ++i){\r\n            long tmp = arr[i];\r\n            int randomPos = i + rnd.nextInt(n-i);\r\n            arr[i] = arr[randomPos];\r\n            arr[randomPos] = tmp;\r\n        }   \r\n    }\r\n    long modInverse(long a, long m) { \r\n        long g = gcd(a, m); \r\n        if (g != 1) \r\n            return -1; \r\n        else \r\n        { \r\n            // If a and m are relatively prime, then modulo inverse is a^(m-2) mode m \r\n            return modpower(a, m - 2, m); \r\n        } \r\n        //return 0;\r\n    } \r\n    boolean isPowerOfTwo (long x) { \r\n        // First x in the below expression is for the case when x is 0 \r\n        return x!=0 && ((x&(x-1)) == 0);     \r\n    } \r\n    long nextPowerOf2(long n) { \r\n        n--; \r\n        n |= n >> 1; \r\n        n |= n >> 2; \r\n        n |= n >> 4; \r\n        n |= n >> 8; \r\n        n |= n >> 16; \r\n        n |= n >> 32;\r\n        //n |= n >> 64;\r\n        n++; \r\n        return n; \r\n    }\r\n    public long lcm_of_array_elements(long[] element_array) \r\n    { \r\n        long lcm_of_array_elements = 1; \r\n        long divisor = 2; \r\n          \r\n        while (true) { \r\n            long counter = 0; \r\n            boolean divisible = false; \r\n              \r\n            for (int i = 0; i < element_array.length; i++) { \r\n  \r\n                // lcm_of_array_elements (n1, n2, ... 0) = 0. For negative number we convert into positive and calculate lcm_of_array_elements. \r\n  \r\n                if (element_array[i] == 0) { \r\n                    return 0; \r\n                } \r\n                else if (element_array[i] < 0) { \r\n                    element_array[i] = element_array[i] * (-1); \r\n                } \r\n                if (element_array[i] == 1) { \r\n                    counter++; \r\n                } \r\n  \r\n                // Divide element_array by devisor if complete division i.e. without remainder then replace  number with quotient; used for find next factor \r\n                if (element_array[i] % divisor == 0) { \r\n                    divisible = true; \r\n                    element_array[i] = element_array[i] / divisor; \r\n                } \r\n            } \r\n  \r\n            // If divisor able to completely divide any number from array multiply with lcm_of_array_elements and store into lcm_of_array_elements and \r\n            // continue to same divisor for next factor finding. else increment divisor \r\n            if (divisible) { \r\n                lcm_of_array_elements = lcm_of_array_elements * divisor; \r\n            } \r\n            else { \r\n                divisor++; \r\n            } \r\n  \r\n            // Check if all element_array is 1 indicate  we found all factors and terminate while loop. \r\n            if (counter == element_array.length) { \r\n                return lcm_of_array_elements; \r\n            } \r\n        } \r\n    } \r\n\r\n    // return gcd of 2 numbers\r\n    long gcd(long a, long b) \r\n    { \r\n        if (a == 0) \r\n            return b; \r\n        return gcd(b % a, a); \r\n    } \r\n  \r\n    // Function to find gcd of array of numbers \r\n    long arrayGCD(long arr[], long n) \r\n    { \r\n        long result = arr[0]; \r\n        for (int i = 1; i < n; i++) \r\n            result = gcd(arr[i], result); \r\n  \r\n        return result; \r\n    }\r\n    long lcm(long a, long b) \r\n    { \r\n        return (a*b)/gcd(a, b); \r\n    } \r\n    long modpower(long x, long y, long p) { \r\n        // Initialize result \r\n        long res = 1;      \r\n         \r\n        // Update x if it is more than or equal to p \r\n        x = x % p;  \r\n      \r\n        while (y > 0) \r\n        { \r\n            // If y is odd, multiply x with result \r\n            if((y & 1)==1) \r\n                res = (res * x) % p; \r\n      \r\n            // y must be even now; y = y / 2 \r\n            y = y >> 1;  \r\n            x = (x * x) % p;  \r\n        } \r\n        return res; \r\n    } \r\n    int binarySearch(int arr[], int x) \r\n    { \r\n        int l = 0, r = arr.length - 1; \r\n        while (l <= r) { \r\n            int m = l + (r - l) / 2; \r\n            // Check if x is present at mid \r\n            if (arr[m] == x) \r\n                return m; \r\n            // If x greater, ignore left half \r\n            if (arr[m] < x) \r\n                l = m + 1; \r\n            // If x is smaller, ignore right half \r\n            else\r\n                r = m - 1;\r\n        } \r\n        // if we reach here, then element was not present \r\n        return -1; \r\n    } \r\n    int rightMostIndex(int arr[], int target){\r\n        int l = 0;\r\n        int r = arr.length;\r\n        while(l<r){\r\n            int mid = (l+r)/2;\r\n            if(target<arr[mid])\r\n                r = mid;\r\n            else \r\n                l = mid+1;\r\n        }\r\n        return l;\r\n    }\r\n    int leftMostIndex(int arr[], int target){\r\n        int l = 0;\r\n        int r = arr.length;\r\n        while(l<r){\r\n            int mid = (l+r)/2;\r\n            if(arr[mid]<target)\r\n                l = mid + 1;\r\n            else\r\n                r = mid;\r\n        }\r\n        return l;\r\n    }\r\n    HashMap<Character,Integer> Counter(char arr[]){\r\n        HashMap<Character,Integer> hash = new HashMap<>();\r\n        for(char i: arr){\r\n            hash.put(i,hash.getOrDefault(i,0)+1);\r\n        }\r\n        return hash;\r\n    }\r\n    int[] sieveOfEratosthenes(int n) \r\n    { \r\n        // Create a boolean array \"prime[0..n]\" and initialize all entries it as true. A value in prime[i] will \r\n        // finally be false if i is Not a prime, else true. \r\n        boolean prime[] = new boolean[n+1]; \r\n        for(int i=0;i<=n;i++) \r\n            prime[i] = true; \r\n        int cnt = 0;\r\n        for(int p = 2; p*p <=n; p++) \r\n        { \r\n            // If prime[p] is not changed, then it is a prime \r\n            if(prime[p] == true) \r\n            { \r\n                // Update all multiples of p \r\n                for(int i = p*p; i <= n; i += p) \r\n                    prime[i] = false; \r\n            } \r\n        } \r\n        // Print all prime numbers \r\n        for(int i = 2; i <= n; i++) \r\n        { \r\n            if(prime[i] == true) {\r\n                cnt++;\r\n                //System.out.print(i + \" \"); \r\n            }\r\n        }\r\n        int arr[] = new int[cnt];\r\n        int j = 0;\r\n        System.out.println(\"cnt is = \"+cnt);\r\n        for(int i = 2; i <= n; i++) \r\n        { \r\n            if(prime[i] == true) {\r\n                arr[j++]=i;\r\n                //System.out.print(i + \" \"); \r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    // **** Segment tree Code by Ankush Sharma written from scratch **** //\r\n    \r\n    int tree[]; // This is the Segment tree, initially it has size 0, and later we will allocate the memory according to our requirements \r\n    \r\n    // This update is used to update only a value at particular index\r\n    void update(int arr[], int node, int index, int val, int start, int end){\r\n        if(start == end){\r\n            arr[start] += val; // arr[index] += val;\r\n            tree[node] += val;\r\n        }\r\n        else{\r\n            int mid = (start + end) / 2;\r\n            if(start <= index && index <= mid)\r\n                update(arr, 2*node+1, index, val, start, mid);\r\n            else\r\n                update(arr, 2*node+2, index, val, mid+1, end);\r\n        }\r\n        tree[node] = tree[2*node+1] + tree[2*node+2];\r\n    }\r\n    //This is the method to build the Segment tree, first process in order to perform operations\r\n    void build(int arr[], int pos, int l, int r){\r\n        if(l==r)\r\n            tree[pos] = arr[l];\r\n        else{\r\n            int mid = (l+r)/2;\r\n            build(arr, 2*pos+1, l, mid);\r\n            build(arr, 2*pos+2, mid+1, r);\r\n            tree[pos] = tree[2*pos+1] + tree[2*pos+2];\r\n        }\r\n    }\r\n    // start and end are the starting and ending index of Segment tree \r\n    // l and r are the range of queries\r\n    // This is the method to return the result of range queries it can be changed according to the operations to be perform\r\n    int query(int node, int start, int end, int l, int r){\r\n        if(r < start || l > end)\r\n            return 0;\r\n        if(l <= start && r >= end)\r\n            return tree[node];\r\n        int mid = (start + end) / 2;\r\n        int ans1 = query(2*node+1, start, mid, l, r);\r\n        int ans2 = query(2*node+2, mid+1, end, l, r);\r\n        return ans1 + ans2;\r\n    } \r\n    boolean isprime(long n){\r\n        if(n==2 || n==3)\r\n            return true;\r\n        if(n%2==0 || n%3==0 || n<=1)\r\n            return false;\r\n        long x=5;\r\n        while(x*x<=n){\r\n            if(n%x==0 || n%(x+2)==0)\r\n                return false;\r\n            x+=6;\r\n        }\r\n        return true;\r\n    }\r\n    ArrayList<Long> fact(long n){\r\n        ArrayList<Long> arr = new ArrayList<Long>();\r\n        long x = 1;\r\n        while(x*x<=n){\r\n            if(n%x==0)\r\n                arr.add(x);\r\n            if(n/x!=x && n%(n/x)==0)\r\n                arr.add(n/x);\r\n            x+=1;\r\n        }\r\n        return arr;\r\n    }\r\n    /*\r\n    int x = (int) Math.ceil(Math.log(n)/Math.log(2));\r\n        int maxSize = 2*(int)Math.pow(2, x)-1;\r\n        size = maxSize;\r\n    */\r\n    void solve() throws Exception{\r\n        int n = read.nextInt();\r\n        int arr[] = new int[n];\r\n        for(int i = 0; i < n; i++)\r\n            arr[i] = read.nextInt();\r\n        if(n==2 && arr[0]!=1 && arr[1]!=1000){\r\n            System.out.println(\"0\");\r\n            System.exit(0);\r\n        }\r\n        int cnt = 0, ans = 0;\r\n        int ind = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(i<n-1 && arr[i+1]-arr[i]==1){\r\n                cnt++;\r\n            }\r\n            else{\r\n                if(ind == 0 && i==n-1 &&(arr[0]==1 || arr[n-1]==1000)){\r\n                    ans = Math.max(ans, cnt);   \r\n                }\r\n                else if(ind==0 && i!=n-1 && arr[0]==1){\r\n                    ans = Math.max(ans,cnt);\r\n                }\r\n                else if(ind==0 && i!=n-1){\r\n                    ans = Math.max(ans,cnt-1);\r\n                }\r\n                else if(i==n-1 && arr[i]==1000){\r\n                    ans = Math.max(ans,cnt);\r\n                }\r\n                else{\r\n                    ans = Math.max(ans,cnt-1);\r\n                }\r\n                ind = i+1;\r\n                cnt = 0;\r\n            }\r\n        }\r\n        System.out.println(ans);\r\n    }\r\n    FastReader read=new FastReader();\r\n    public static void main(String[] args) throws Exception { \r\n    \tnew AnkushJavaTemplate().solve();\r\n    } \r\n} "
}