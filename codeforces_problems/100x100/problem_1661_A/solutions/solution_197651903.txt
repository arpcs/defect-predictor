{
    "id": 197651903,
    "contestId": 1661,
    "creationTimeSeconds": 1678976690,
    "relativeTimeSeconds": 170,
    "problem": {
        "contestId": 1661,
        "index": "A",
        "name": "Array Balancing",
        "type": "PROGRAMMING",
        "rating": 800,
        "tags": [
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1661,
        "members": [
            {
                "handle": "ttttan"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1678976520
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 12,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 0,
    "source": "#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef unsigned int ui;\r\ntypedef pair<int,int> pii;\r\ntypedef pair<pii,int> ppii;\r\ntypedef pair<int,pii> pipi;\r\ntypedef pair<ll,ll> pll;\r\ntypedef pair<pll,ll> ppll;\r\ntypedef pair<ll,pll> plpl;\r\ntypedef pair<pii,pii> pippi;\r\ntypedef tuple<ll,ll,ll> tl;\r\ntypedef pair<long double,long double> pdd;\r\n//typedef vector<vector<ll>> mat;\r\nconst ll mod=1000000007;\r\nconst ll mod2=998244353;\r\nconst ll mod3=1000000009;\r\nll inf=numeric_limits<ll>::max()/2;\r\nint iinf=numeric_limits<int>::max()/2;\r\ndouble pi=3.14159265358979323846;\r\ndouble eps=1e-8;\r\n#define rep(i,m,n) for(ll i=m;i<n;i++)\r\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\r\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\r\n#define mrep(itr,mp) for(auto& itr:mp)\r\n#define Max(a,b) a=max(a,b)\r\n#define Min(a,b) a=min(a,b)\r\nint dh[4]={1,0,-1,0};\r\nint dw[4]={0,1,0,-1};\r\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\r\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        x+=0x9e3779b97f4a7c15;x=(x^(x>>30))*0xbf58476d1ce4e5b9;x=(x^(x>>27))*0x94d049bb133111eb;\r\n        return x^(x>>31);}\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);}\r\n};\r\n#define umh unordered_map<int,ll,custom_hash>\r\nll gcd(ll a,ll b){\r\n    if(a<0)a=-a;if(b<0)b=-b;if(a<b)swap(a,b);if(b==0)return a;if(a%b==0)return b;return gcd(b,a%b);}\r\nll lcm(ll a,ll b){if(a==0)return b;if(b==0)return a;ll c=gcd(a,b);a/=c;a*=b;return a;}\r\nll Pow(ll n,ll k){\r\n    if(k<0)return 0;ll ret=1;ll now=n;while(k>0){if(k&1)ret*=now;now*=now;k/=2;}return ret;\r\n}\r\nll beki(ll n,ll k,ll md){\r\n  ll ret=1;ll now=n;now%=md;\r\n  while(k>0){\r\n    if(k%2==1){ret*=now;ret%=md;}\r\n    now*=now;now%=md;k=k>>1;}return ret;\r\n}\r\nll gyaku(ll n,ll md){return beki(n,md-2,md);}\r\nll popcount(ll n){ll ret=0;ll u=n;while(u>0){ret+=u%2;u/=2;}return ret;}\r\n#ifndef ATCODER_INTERNAL_BITOP_HPP\r\n#define ATCODER_INTERNAL_BITOP_HPP 1\r\n#ifdef _MSC_VER\r\n#include <intrin.h>\r\n#endif\r\nnamespace atcoder {\r\nnamespace internal {\r\nint ceil_pow2(int n) {\r\n    int x = 0;while ((1U << x) < (unsigned int)(n)) x++;return x;}\r\nint bsf(unsigned int n) {\r\n#ifdef _MSC_VER\r\n    unsigned long index;\r\n    _BitScanForward(&index, n);\r\n    return index;\r\n#else\r\n    return __builtin_ctz(n);\r\n#endif\r\n}}}\r\n#endif\r\n#ifndef ATCODER_INTERNAL_MATH_HPP\r\n#define ATCODER_INTERNAL_MATH_HPP 1\r\n#include <utility>\r\nnamespace atcoder {\r\nnamespace internal {\r\nconstexpr long long safe_mod(long long x, long long m) {\r\n    x%=m;if(x<0)x+=m;return x;}\r\nstruct barrett {\r\n    unsigned int _m;\r\n    unsigned long long im;\r\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\r\n    unsigned int umod() const { return _m; }\r\n    unsigned int mul(unsigned int a, unsigned int b) const {\r\n        unsigned long long z = a;z *= b;\r\n#ifdef _MSC_VER\r\n        unsigned long long x;\r\n        _umul128(z, im, &x);\r\n#else\r\n        unsigned long long x =\r\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\r\n#endif\r\n        unsigned int v = (unsigned int)(z - x * _m);\r\n        if (_m <= v) v += _m;\r\n        return v;\r\n    }\r\n};\r\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\r\n    if (m == 1) return 0;\r\n    unsigned int _m = (unsigned int)(m);\r\n    unsigned long long r = 1;\r\n    unsigned long long y = safe_mod(x, m);\r\n    while (n) {\r\n        if (n & 1) r = (r * y) % _m;y = (y * y) % _m;n >>= 1;\r\n    }\r\n    return r;\r\n}\r\n\r\nconstexpr bool is_prime_constexpr(int n) {\r\n    if (n<=1) return false;\r\n    if (n==2||n==7||n==61) return true;\r\n    if (n%2==0) return false;\r\n    long long d = n - 1;\r\n    while (d%2==0)d/=2;\r\n    for (long long a : {2, 7, 61}) {\r\n        long long t = d;\r\n        long long y = pow_mod_constexpr(a, t, n);\r\n        while (t != n - 1 && y != 1 && y != n - 1) {\r\n            y = y * y % n;t <<= 1;}\r\n        if (y != n - 1 && t % 2 == 0) {return false;}\r\n    }\r\n    return true;\r\n}\r\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\r\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\r\n    a = safe_mod(a, b);\r\n    if (a == 0) return {b, 0};\r\n    long long s = b, t = a;\r\n    long long m0 = 0, m1 = 1;\r\n    while (t) {\r\n        long long u = s / t;\r\n        s -= t * u;\r\n        m0 -= m1 * u;\r\n        auto tmp = s;\r\n        s = t;\r\n        t = tmp;\r\n        tmp = m0;\r\n        m0 = m1;\r\n        m1 = tmp;\r\n    }\r\n    if (m0 < 0) m0 += b / s;\r\n    return {s, m0};\r\n}\r\nconstexpr int primitive_root_constexpr(int m) {\r\n    if (m == 2) return 1;\r\n    if (m == 167772161) return 3;\r\n    if (m == 469762049) return 3;\r\n    if (m == 754974721) return 11;\r\n    if (m == 998244353) return 3;\r\n    int divs[20] = {};\r\n    divs[0] = 2;\r\n    int cnt = 1;\r\n    int x = (m - 1) / 2;\r\n    while (x % 2 == 0) x /= 2;\r\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\r\n        if (x % i == 0) {\r\n            divs[cnt++] = i;\r\n            while (x % i == 0) {\r\n                x /= i;}\r\n        }\r\n    }\r\n    if (x > 1) {divs[cnt++] = x;}\r\n    for (int g = 2;; g++) {\r\n        bool ok = true;\r\n        for (int i = 0; i < cnt; i++) {\r\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\r\n                ok = false;break;\r\n            }\r\n        }\r\n        if (ok) return g;\r\n    }\r\n}\r\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\r\n}\r\n}\r\n#endif\r\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\r\n#define ATCODER_INTERNAL_QUEUE_HPP 1\r\n#include <vector>\r\nnamespace atcoder {\r\nnamespace internal {\r\ntemplate <class T> struct simple_queue {\r\n    std::vector<T> payload;\r\n    int pos = 0;\r\n    void reserve(int n) { payload.reserve(n); }\r\n    int size() const { return int(payload.size()) - pos; }\r\n    bool empty() const { return pos == int(payload.size()); }\r\n    void push(const T& t) { payload.push_back(t); }\r\n    T& front() { return payload[pos]; }\r\n    void clear() {\r\n        payload.clear();pos = 0;}\r\n    void pop() { pos++; }\r\n};\r\n}\r\n}\r\n#endif\r\n#ifndef ATCODER_INTERNAL_SCC_HPP\r\n#define ATCODER_INTERNAL_SCC_HPP 1\r\n#include <algorithm>\r\n#include <utility>\r\n#include <vector>\r\nnamespace atcoder {\r\nnamespace internal {\r\ntemplate <class E> struct csr {\r\n    std::vector<int> start;\r\n    std::vector<E> elist;\r\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\r\n        : start(n + 1), elist(edges.size()) {\r\n        for (auto e : edges) {start[e.first + 1]++;}\r\n        for (int i = 1; i <= n; i++) {start[i] += start[i - 1];}\r\n        auto counter = start;\r\n        for (auto e : edges) {elist[counter[e.first]++] = e.second;}\r\n    }\r\n};\r\nstruct scc_graph {\r\n  public:\r\n    scc_graph(int n) : _n(n) {}\r\n    int num_vertices() { return _n; }\r\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\r\n    std::pair<int, std::vector<int>> scc_ids() {\r\n        auto g = csr<edge>(_n, edges);\r\n        int now_ord = 0, group_num = 0;\r\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\r\n        visited.reserve(_n);\r\n        auto dfs = [&](auto self, int v) -> void {\r\n            low[v] = ord[v] = now_ord++;\r\n            visited.push_back(v);\r\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\r\n                auto to = g.elist[i].to;\r\n                if (ord[to] == -1) {\r\n                    self(self, to);low[v] = std::min(low[v], low[to]);\r\n                } else {low[v] = std::min(low[v], ord[to]);}\r\n            }\r\n            if (low[v] == ord[v]) {\r\n                while (true) {\r\n                    int u = visited.back();\r\n                    visited.pop_back();ord[u] = _n;ids[u] = group_num;if (u == v) break;\r\n                }\r\n                group_num++;\r\n            }\r\n        };\r\n        for (int i = 0; i < _n; i++) {if (ord[i] == -1) dfs(dfs, i);}\r\n        for (auto& x : ids) {x = group_num - 1 - x;}\r\n        return {group_num, ids};\r\n    }\r\n    std::vector<std::vector<int>> scc() {\r\n        auto ids = scc_ids();\r\n        int group_num = ids.first;\r\n        std::vector<int> counts(group_num);\r\n        for (auto x : ids.second) counts[x]++;\r\n        std::vector<std::vector<int>> groups(ids.first);\r\n        for (int i = 0; i < group_num; i++) {\r\n            groups[i].reserve(counts[i]);\r\n        }\r\n        for (int i = 0; i < _n; i++) {\r\n            groups[ids.second[i]].push_back(i);\r\n        }\r\n        return groups;\r\n    }\r\n  private:\r\n    int _n;\r\n    struct edge {\r\n        int to;\r\n    };\r\n    std::vector<std::pair<int, edge>> edges;\r\n};\r\n}\r\n}\r\n#endif\r\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\r\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\r\n#include <cassert>\r\n#include <numeric>\r\n#include <type_traits>\r\nnamespace atcoder {\r\nnamespace internal {\r\n#ifndef _MSC_VER\r\ntemplate <class T>\r\nusing is_signed_int128 =\r\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\r\n                                  std::is_same<T, __int128>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\ntemplate <class T>\r\nusing is_unsigned_int128 =\r\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\r\n                                  std::is_same<T, unsigned __int128>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\ntemplate <class T>\r\nusing make_unsigned_int128 =\r\n    typename std::conditional<std::is_same<T, __int128_t>::value,\r\n                              __uint128_t,\r\n                              unsigned __int128>;\r\ntemplate <class T>\r\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\r\n                                                  is_signed_int128<T>::value ||\r\n                                                  is_unsigned_int128<T>::value,\r\n                                              std::true_type,\r\n                                              std::false_type>::type;\r\ntemplate <class T>\r\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\r\n                                                 std::is_signed<T>::value) ||\r\n                                                    is_signed_int128<T>::value,\r\n                                                std::true_type,\r\n                                                std::false_type>::type;\r\ntemplate <class T>\r\nusing is_unsigned_int =\r\n    typename std::conditional<(is_integral<T>::value &&\r\n                               std::is_unsigned<T>::value) ||\r\n                                  is_unsigned_int128<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\ntemplate <class T>\r\nusing to_unsigned = typename std::conditional<\r\n    is_signed_int128<T>::value,\r\n    make_unsigned_int128<T>,\r\n    typename std::conditional<std::is_signed<T>::value,\r\n                              std::make_unsigned<T>,\r\n                              std::common_type<T>>::type>::type;\r\n#else\r\ntemplate <class T> using is_integral = typename std::is_integral<T>;\r\ntemplate <class T>\r\nusing is_signed_int =\r\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\ntemplate <class T>\r\nusing is_unsigned_int =\r\n    typename std::conditional<is_integral<T>::value &&\r\n                                  std::is_unsigned<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\ntemplate <class T>\r\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\r\n                                              std::make_unsigned<T>,\r\n                                              std::common_type<T>>::type;\r\n#endif\r\ntemplate <class T>\r\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\r\ntemplate <class T>\r\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\r\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\r\n}\r\n}\r\n#endif\r\n#ifndef ATCODER_MODINT_HPP\r\n#define ATCODER_MODINT_HPP 1\r\n#include <cassert>\r\n#include <numeric>\r\n#include <type_traits>\r\n#ifdef _MSC_VER\r\n#include <intrin.h>\r\n#endif\r\nnamespace atcoder {\r\nnamespace internal {\r\nstruct modint_base {};\r\nstruct static_modint_base : modint_base {};\r\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\r\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\r\n}\r\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\r\nstruct static_modint : internal::static_modint_base {\r\n    using mint = static_modint;\r\n  public:\r\n    static constexpr int mod() { return m; }\r\n    static mint raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\n    static_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\r\n    static_modint(T v) {\r\n        long long x = (long long)(v % (long long)(umod()));\r\n        if (x < 0) x += umod();\r\n        _v = (unsigned int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\r\n    static_modint(T v) {\r\n        _v = (unsigned int)(v % umod());\r\n    }\r\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\r\n    unsigned int val() const { return _v; }\r\n    mint& operator++() {_v++;if (_v == umod()) _v = 0;return *this;}\r\n    mint& operator--() {if (_v == 0) _v = umod();_v--;return *this;}\r\n    mint operator++(int) {mint result = *this;++*this;return result;}\r\n    mint operator--(int) {mint result = *this;--*this;return result;}\r\n    mint& operator+=(const mint& rhs) {_v += rhs._v;if (_v >= umod()) _v -= umod();return *this;}\r\n    mint& operator-=(const mint& rhs) {_v -= rhs._v;if (_v >= umod()) _v += umod();return *this;}\r\n    mint& operator*=(const mint& rhs) {\r\n        unsigned long long z = _v;\r\n        z *= rhs._v;\r\n        _v = (unsigned int)(z % umod());\r\n        return *this;\r\n    }\r\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\r\n    mint operator+() const { return *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n    mint inv() const {\r\n        if (prime) {\r\n            assert(_v);\r\n            return pow(umod() - 2);\r\n        } else {\r\n            auto eg = internal::inv_gcd(_v, m);\r\n            assert(eg.first == 1);\r\n            return eg.second;\r\n        }\r\n    }\r\n    friend mint operator+(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool operator==(const mint& lhs, const mint& rhs) {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\n  private:\r\n    unsigned int _v;\r\n    static constexpr unsigned int umod() { return m; }\r\n    static constexpr bool prime = internal::is_prime<m>;\r\n};\r\ntemplate <int id> struct dynamic_modint : internal::modint_base {\r\n    using mint = dynamic_modint;\r\n  public:\r\n    static int mod() { return (int)(bt.umod()); }\r\n    static void set_mod(int m) {\r\n        assert(1 <= m);\r\n        bt = internal::barrett(m);\r\n    }\r\n    static mint raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\n    dynamic_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\r\n    dynamic_modint(T v) {\r\n        long long x = (long long)(v % (long long)(mod()));\r\n        if (x < 0) x += mod();\r\n        _v = (unsigned int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\r\n    dynamic_modint(T v) {\r\n        _v = (unsigned int)(v % mod());\r\n    }\r\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\r\n    unsigned int val() const { return _v; }\r\n    mint& operator++() {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n        _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n        --*this;\r\n        return result;\r\n    }\r\n    mint& operator+=(const mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n        _v += mod() - rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n        _v = bt.mul(_v, rhs._v);\r\n        return *this;\r\n    }\r\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\r\n    mint operator+() const { return *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n    mint inv() const {\r\n        auto eg = internal::inv_gcd(_v, mod());\r\n        assert(eg.first == 1);\r\n        return eg.second;\r\n    }\r\n    friend mint operator+(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool operator==(const mint& lhs, const mint& rhs) {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\n  private:\r\n    unsigned int _v;\r\n    static internal::barrett bt;\r\n    static unsigned int umod() { return bt.umod(); }\r\n};\r\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\r\nusing modint998244353 = static_modint<998244353>;\r\nusing modint1000000007 = static_modint<1000000007>;\r\nusing modint = dynamic_modint<-1>;\r\nnamespace internal {\r\ntemplate <class T>\r\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\r\ntemplate <class T>\r\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\r\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\r\ntemplate <int id>\r\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\r\ntemplate <class T>\r\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\r\n}\r\n}\r\n#endif\r\n#ifndef ATCODER_CONVOLUTION_HPP\r\n#define ATCODER_CONVOLUTION_HPP 1\r\n#include <algorithm>\r\n#include <array>\r\n#include <cassert>\r\n#include <type_traits>\r\n#include <vector>\r\nnamespace atcoder {\r\nnamespace internal {\r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nvoid butterfly(std::vector<mint>& a) {\r\n    static constexpr int g = internal::primitive_root<mint::mod()>;\r\n    int n = int(a.size());\r\n    int h = internal::ceil_pow2(n);\r\n    static bool first = true;\r\n    static mint sum_e[30];\r\n    if (first) {\r\n        first = false;\r\n        mint es[30], ies[30];\r\n        int cnt2 = bsf(mint::mod() - 1);\r\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\r\n        for (int i = cnt2; i >= 2; i--) {\r\n            \r\n            es[i - 2] = e;\r\n            ies[i - 2] = ie;\r\n            e *= e;\r\n            ie *= ie;\r\n        }\r\n        mint now = 1;\r\n        for (int i = 0; i < cnt2 - 2; i++) {\r\n            sum_e[i] = es[i] * now;\r\n            now *= ies[i];\r\n        }\r\n    }\r\n    for (int ph = 1; ph <= h; ph++) {\r\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\r\n        mint now = 1;\r\n        for (int s = 0; s < w; s++) {\r\n            int offset = s << (h - ph + 1);\r\n            for (int i = 0; i < p; i++) {\r\n                auto l = a[i + offset];\r\n                auto r = a[i + offset + p] * now;\r\n                a[i + offset] = l + r;\r\n                a[i + offset + p] = l - r;\r\n            }\r\n            now *= sum_e[bsf(~(unsigned int)(s))];\r\n        }\r\n    }\r\n}\r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nvoid butterfly_inv(std::vector<mint>& a) {\r\n    static constexpr int g = internal::primitive_root<mint::mod()>;\r\n    int n = int(a.size());\r\n    int h = internal::ceil_pow2(n);\r\n    static bool first = true;\r\n    static mint sum_ie[30];\r\n    if (first) {\r\n        first = false;\r\n        mint es[30], ies[30];\r\n        int cnt2 = bsf(mint::mod() - 1);\r\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\r\n        for (int i = cnt2; i >= 2; i--) {\r\n            \r\n            es[i - 2] = e;\r\n            ies[i - 2] = ie;\r\n            e *= e;\r\n            ie *= ie;\r\n        }\r\n        mint now = 1;\r\n        for (int i = 0; i < cnt2 - 2; i++) {\r\n            sum_ie[i] = ies[i] * now;\r\n            now *= es[i];\r\n        }\r\n    }\r\n    for (int ph = h; ph >= 1; ph--) {\r\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\r\n        mint inow = 1;\r\n        for (int s = 0; s < w; s++) {\r\n            int offset = s << (h - ph + 1);\r\n            for (int i = 0; i < p; i++) {\r\n                auto l = a[i + offset];\r\n                auto r = a[i + offset + p];\r\n                a[i + offset] = l + r;\r\n                a[i + offset + p] =\r\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\r\n                    inow.val();\r\n            }\r\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\r\n        }\r\n    }\r\n}\r\n}\r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n    if (std::min(n, m) <= 60) {\r\n        if (n < m) {\r\n            std::swap(n, m);\r\n            std::swap(a, b);\r\n        }\r\n        std::vector<mint> ans(n + m - 1);\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                ans[i + j] += a[i] * b[j];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    int z = 1 << internal::ceil_pow2(n + m - 1);\r\n    a.resize(z);\r\n    internal::butterfly(a);\r\n    b.resize(z);\r\n    internal::butterfly(b);\r\n    for (int i = 0; i < z; i++) {\r\n        a[i] *= b[i];\r\n    }\r\n    internal::butterfly_inv(a);\r\n    a.resize(n + m - 1);\r\n    mint iz = mint(z).inv();\r\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\r\n    return a;\r\n}\r\ntemplate <unsigned int mod = 998244353,\r\n          class T,\r\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\r\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n    using mint = static_modint<mod>;\r\n    std::vector<mint> a2(n), b2(m);\r\n    for (int i = 0; i < n; i++) {\r\n        a2[i] = mint(a[i]);\r\n    }\r\n    for (int i = 0; i < m; i++) {\r\n        b2[i] = mint(b[i]);\r\n    }\r\n    auto c2 = convolution(move(a2), move(b2));\r\n    std::vector<T> c(n + m - 1);\r\n    for (int i = 0; i < n + m - 1; i++) {\r\n        c[i] = c2[i].val();\r\n    }\r\n    return c;\r\n}\r\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\r\n                                      const std::vector<long long>& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n    static constexpr unsigned long long MOD1 = 754974721;\r\n    static constexpr unsigned long long MOD2 = 167772161;\r\n    static constexpr unsigned long long MOD3 = 469762049;\r\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\r\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\r\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\r\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\r\n    static constexpr unsigned long long i1 =\r\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\r\n    static constexpr unsigned long long i2 =\r\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\r\n    static constexpr unsigned long long i3 =\r\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\r\n    auto c1 = convolution<MOD1>(a, b);\r\n    auto c2 = convolution<MOD2>(a, b);\r\n    auto c3 = convolution<MOD3>(a, b);\r\n    std::vector<long long> c(n + m - 1);\r\n    for (int i = 0; i < n + m - 1; i++) {\r\n        unsigned long long x = 0;\r\n        x += (c1[i] * i1) % MOD1 * M2M3;\r\n        x += (c2[i] * i2) % MOD2 * M1M3;\r\n        x += (c3[i] * i3) % MOD3 * M1M2;\r\n        \r\n        long long diff =\r\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\r\n        if (diff < 0) diff += MOD1;\r\n        static constexpr unsigned long long offset[5] = {\r\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\r\n        x -= offset[diff % 5];\r\n        c[i] = x;\r\n    }\r\n    return c;\r\n}\r\n}\r\n#endif\r\n#ifndef ATCODER_DSU_HPP\r\n#define ATCODER_DSU_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <vector>\r\nnamespace atcoder {\r\n\r\nstruct dsu {\r\n  public:\r\n    dsu() : _n(0) {}\r\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\r\n    int merge(int a, int b) {\r\n        assert(0 <= a && a < _n);\r\n        assert(0 <= b && b < _n);\r\n        int x = leader(a), y = leader(b);\r\n        if (x == y) return x;\r\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\r\n        parent_or_size[x] += parent_or_size[y];\r\n        parent_or_size[y] = x;\r\n        return x;\r\n    }\r\n    bool same(int a, int b) {\r\n        assert(0 <= a && a < _n);\r\n        assert(0 <= b && b < _n);\r\n        return leader(a) == leader(b);\r\n    }\r\n    int leader(int a) {\r\n        assert(0 <= a && a < _n);\r\n        if (parent_or_size[a] < 0) return a;\r\n        return parent_or_size[a] = leader(parent_or_size[a]);\r\n    }\r\n    int size(int a) {\r\n        assert(0 <= a && a < _n);\r\n        return -parent_or_size[leader(a)];\r\n    }\r\n    std::vector<std::vector<int>> groups() {\r\n        std::vector<int> leader_buf(_n), group_size(_n);\r\n        for (int i = 0; i < _n; i++) {\r\n            leader_buf[i] = leader(i);\r\n            group_size[leader_buf[i]]++;\r\n        }\r\n        std::vector<std::vector<int>> result(_n);\r\n        for (int i = 0; i < _n; i++) {\r\n            result[i].reserve(group_size[i]);\r\n        }\r\n        for (int i = 0; i < _n; i++) {\r\n            result[leader_buf[i]].push_back(i);\r\n        }\r\n        result.erase(\r\n            std::remove_if(result.begin(), result.end(),\r\n                           [&](const std::vector<int>& v) { return v.empty(); }),\r\n            result.end());\r\n        return result;\r\n    }\r\n  private:\r\n    int _n;\r\n    \r\n    std::vector<int> parent_or_size;\r\n};\r\n}\r\n#endif\r\n#ifndef ATCODER_FENWICKTREE_HPP\r\n#define ATCODER_FENWICKTREE_HPP 1\r\n#include <cassert>\r\n#include <vector>\r\nnamespace atcoder {\r\n\r\ntemplate <class T> struct fenwick_tree {\r\n    using U = internal::to_unsigned_t<T>;\r\n  public:\r\n    fenwick_tree() : _n(0) {}\r\n    fenwick_tree(int n) : _n(n), data(n) {}\r\n    void add(int p, T x) {\r\n        assert(0 <= p && p < _n);\r\n        p++;\r\n        while (p <= _n) {\r\n            data[p - 1] += U(x);\r\n            p += p & -p;\r\n        }\r\n    }\r\n    void change(int p,T x){\r\n        add(p,x-data[p]);\r\n    }\r\n    T sum(int l, int r) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        return sum(r) - sum(l);\r\n    }\r\n    int lb(T w){\r\n        if(w<=0)return 0;\r\n        int x=0;\r\n        int u=1;while(u<_n)u*=2;\r\n        for(int k=u;k>0;k/=2){\r\n            if(x+k<=_n&&data[x+k-1]<w){\r\n                w-=data[x+k-1];\r\n                x+=k;\r\n            }\r\n        }\r\n        return x;\r\n    }\r\n  private:\r\n    int _n;\r\n    std::vector<U> data;\r\n    U sum(int r) {\r\n        U s = 0;\r\n        while (r > 0) {\r\n            s += data[r - 1];\r\n            r -= r & -r;\r\n        }\r\n        return s;\r\n    }\r\n};\r\n}\r\n#endif\r\n#ifndef ATCODER_LAZYSEGTREE_HPP\r\n#define ATCODER_LAZYSEGTREE_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <iostream>\r\n#include <vector>\r\nnamespace atcoder {\r\ntemplate <class S,\r\n          S (*op)(S, S),\r\n          S (*e)(),\r\n          class F,\r\n          S (*mapping)(F, S),\r\n          F (*composition)(F, F),\r\n          F (*id)()>\r\nstruct lazy_segtree {\r\n  public:\r\n    lazy_segtree() : lazy_segtree(0) {}\r\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\r\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\r\n        log = internal::ceil_pow2(_n);\r\n        size = 1 << log;\r\n        d = std::vector<S>(2 * size, e());\r\n        lz = std::vector<F>(size, id());\r\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\r\n        for (int i = size - 1; i >= 1; i--) {\r\n            update(i);\r\n        }\r\n    }\r\n    void set(int p, S x) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        for (int i = log; i >= 1; i--) push(p >> i);\r\n        d[p] = x;\r\n        for (int i = 1; i <= log; i++) update(p >> i);\r\n    }\r\n    S get(int p) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        for (int i = log; i >= 1; i--) push(p >> i);\r\n        return d[p];\r\n    }\r\n    S prod(int l, int r) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        if (l == r) return e();\r\n        l += size;\r\n        r += size;\r\n        for (int i = log; i >= 1; i--) {\r\n            if (((l >> i) << i) != l) push(l >> i);\r\n            if (((r >> i) << i) != r) push(r >> i);\r\n        }\r\n        S sml = e(), smr = e();\r\n        while (l < r) {\r\n            if (l & 1) sml = op(sml, d[l++]);\r\n            if (r & 1) smr = op(d[--r], smr);\r\n            l >>= 1;\r\n            r >>= 1;\r\n        }\r\n        return op(sml, smr);\r\n    }\r\n    S all_prod() { return d[1]; }\r\n    void apply(int p, F f) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        for (int i = log; i >= 1; i--) push(p >> i);\r\n        d[p] = mapping(f, d[p]);\r\n        for (int i = 1; i <= log; i++) update(p >> i);\r\n    }\r\n    void apply(int l, int r, F f) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        if (l == r) return;\r\n        l += size;\r\n        r += size;\r\n        for (int i = log; i >= 1; i--) {\r\n            if (((l >> i) << i) != l) push(l >> i);\r\n            if (((r >> i) << i) != r) push((r - 1) >> i);\r\n        }\r\n        {\r\n            int l2 = l, r2 = r;\r\n            while (l < r) {\r\n                if (l & 1) all_apply(l++, f);\r\n                if (r & 1) all_apply(--r, f);\r\n                l >>= 1;\r\n                r >>= 1;\r\n            }\r\n            l = l2;\r\n            r = r2;\r\n        }\r\n        for (int i = 1; i <= log; i++) {\r\n            if (((l >> i) << i) != l) update(l >> i);\r\n            if (((r >> i) << i) != r) update((r - 1) >> i);\r\n        }\r\n    }\r\n    template <bool (*g)(S)> int max_right(int l) {\r\n        return max_right(l, [](S x) { return g(x); });\r\n    }\r\n    template <class G> int max_right(int l, G g) {\r\n        assert(0 <= l && l <= _n);\r\n        assert(g(e()));\r\n        if (l == _n) return _n;\r\n        l += size;\r\n        for (int i = log; i >= 1; i--) push(l >> i);\r\n        S sm = e();\r\n        do {\r\n            while (l % 2 == 0) l >>= 1;\r\n            if (!g(op(sm, d[l]))) {\r\n                while (l < size) {\r\n                    push(l);\r\n                    l = (2 * l);\r\n                    if (g(op(sm, d[l]))) {\r\n                        sm = op(sm, d[l]);\r\n                        l++;\r\n                    }\r\n                }\r\n                return l - size;\r\n            }\r\n            sm = op(sm, d[l]);\r\n            l++;\r\n        } while ((l & -l) != l);\r\n        return _n;\r\n    }\r\n    template <bool (*g)(S)> int min_left(int r) {\r\n        return min_left(r, [](S x) { return g(x); });\r\n    }\r\n    template <class G> int min_left(int r, G g) {\r\n        assert(0 <= r && r <= _n);\r\n        assert(g(e()));\r\n        if (r == 0) return 0;\r\n        r += size;\r\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\r\n        S sm = e();\r\n        do {\r\n            r--;\r\n            while (r > 1 && (r % 2)) r >>= 1;\r\n            if (!g(op(d[r], sm))) {\r\n                while (r < size) {\r\n                    push(r);\r\n                    r = (2 * r + 1);\r\n                    if (g(op(d[r], sm))) {\r\n                        sm = op(d[r], sm);\r\n                        r--;\r\n                    }\r\n                }\r\n                return r + 1 - size;\r\n            }\r\n            sm = op(d[r], sm);\r\n        } while ((r & -r) != r);\r\n        return 0;\r\n    }\r\n  private:\r\n    int _n, size, log;\r\n    std::vector<S> d;\r\n    std::vector<F> lz;\r\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\r\n    void all_apply(int k, F f) {\r\n        d[k] = mapping(f, d[k]);\r\n        if (k < size) lz[k] = composition(f, lz[k]);\r\n    }\r\n    void push(int k) {\r\n        all_apply(2 * k, lz[k]);\r\n        all_apply(2 * k + 1, lz[k]);\r\n        lz[k] = id();\r\n    }\r\n};\r\n}\r\n#endif\r\n#ifndef ATCODER_MAXFLOW_HPP\r\n#define ATCODER_MAXFLOW_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <limits>\r\n#include <queue>\r\n#include <vector>\r\nnamespace atcoder {\r\ntemplate <class Cap> struct mf_graph {\r\n  public:\r\n    mf_graph() : _n(0) {}\r\n    mf_graph(int n) : _n(n), g(n) {}\r\n    int add_edge(int from, int to, Cap cap) {\r\n        assert(0 <= from && from < _n);\r\n        assert(0 <= to && to < _n);\r\n        assert(0 <= cap);\r\n        int m = int(pos.size());\r\n        pos.push_back({from, int(g[from].size())});\r\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\r\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\r\n        return m;\r\n    }\r\n    struct edge {\r\n        int from, to;\r\n        Cap cap, flow;\r\n    };\r\n    edge get_edge(int i) {\r\n        int m = int(pos.size());\r\n        assert(0 <= i && i < m);\r\n        auto _e = g[pos[i].first][pos[i].second];\r\n        auto _re = g[_e.to][_e.rev];\r\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\r\n    }\r\n    std::vector<edge> edges() {\r\n        int m = int(pos.size());\r\n        std::vector<edge> result;\r\n        for (int i = 0; i < m; i++) {\r\n            result.push_back(get_edge(i));\r\n        }\r\n        return result;\r\n    }\r\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\r\n        int m = int(pos.size());\r\n        assert(0 <= i && i < m);\r\n        assert(0 <= new_flow && new_flow <= new_cap);\r\n        auto& _e = g[pos[i].first][pos[i].second];\r\n        auto& _re = g[_e.to][_e.rev];\r\n        _e.cap = new_cap - new_flow;\r\n        _re.cap = new_flow;\r\n    }\r\n    Cap flow(int s, int t) {\r\n        return flow(s, t, std::numeric_limits<Cap>::max());\r\n    }\r\n    Cap flow(int s, int t, Cap flow_limit) {\r\n        assert(0 <= s && s < _n);\r\n        assert(0 <= t && t < _n);\r\n        std::vector<int> level(_n), iter(_n);\r\n        internal::simple_queue<int> que;\r\n        auto bfs = [&]() {\r\n            std::fill(level.begin(), level.end(), -1);\r\n            level[s] = 0;\r\n            que.clear();\r\n            que.push(s);\r\n            while (!que.empty()) {\r\n                int v = que.front();\r\n                que.pop();\r\n                for (auto e : g[v]) {\r\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\r\n                    level[e.to] = level[v] + 1;\r\n                    if (e.to == t) return;\r\n                    que.push(e.to);\r\n                }\r\n            }\r\n        };\r\n        auto dfs = [&](auto self, int v, Cap up) {\r\n            if (v == s) return up;\r\n            Cap res = 0;\r\n            int level_v = level[v];\r\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\r\n                _edge& e = g[v][i];\r\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\r\n                Cap d =\r\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\r\n                if (d <= 0) continue;\r\n                g[v][i].cap += d;\r\n                g[e.to][e.rev].cap -= d;\r\n                res += d;\r\n                if (res == up) break;\r\n            }\r\n            return res;\r\n        };\r\n        Cap flow = 0;\r\n        while (flow < flow_limit) {\r\n            bfs();\r\n            if (level[t] == -1) break;\r\n            std::fill(iter.begin(), iter.end(), 0);\r\n            while (flow < flow_limit) {\r\n                Cap f = dfs(dfs, t, flow_limit - flow);\r\n                if (!f) break;\r\n                flow += f;\r\n            }\r\n        }\r\n        return flow;\r\n    }\r\n    std::vector<bool> min_cut(int s) {\r\n        std::vector<bool> visited(_n);\r\n        internal::simple_queue<int> que;\r\n        que.push(s);\r\n        while (!que.empty()) {\r\n            int p = que.front();\r\n            que.pop();\r\n            visited[p] = true;\r\n            for (auto e : g[p]) {\r\n                if (e.cap && !visited[e.to]) {\r\n                    visited[e.to] = true;\r\n                    que.push(e.to);\r\n                }\r\n            }\r\n        }\r\n        return visited;\r\n    }\r\n  private:\r\n    int _n;\r\n    struct _edge {\r\n        int to, rev;\r\n        Cap cap;\r\n    };\r\n    std::vector<std::pair<int, int>> pos;\r\n    std::vector<std::vector<_edge>> g;\r\n};\r\n}\r\n#endif\r\n#ifndef ATCODER_MINCOSTFLOW_HPP\r\n#define ATCODER_MINCOSTFLOW_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <limits>\r\n#include <queue>\r\n#include <vector>\r\nnamespace atcoder {\r\ntemplate <class Cap, class Cost> struct mcf_graph {\r\n  public:\r\n    mcf_graph() {}\r\n    mcf_graph(int n) : _n(n), g(n) {}\r\n    int add_edge(int from, int to, Cap cap, Cost cost) {\r\n        assert(0 <= from && from < _n);\r\n        assert(0 <= to && to < _n);\r\n        int m = int(pos.size());\r\n        pos.push_back({from, int(g[from].size())});\r\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\r\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\r\n        return m;\r\n    }\r\n    struct edge {\r\n        int from, to;\r\n        Cap cap, flow;\r\n        Cost cost;\r\n    };\r\n    edge get_edge(int i) {\r\n        int m = int(pos.size());\r\n        assert(0 <= i && i < m);\r\n        auto _e = g[pos[i].first][pos[i].second];\r\n        auto _re = g[_e.to][_e.rev];\r\n        return edge{\r\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\r\n        };\r\n    }\r\n    std::vector<edge> edges() {\r\n        int m = int(pos.size());\r\n        std::vector<edge> result(m);\r\n        for (int i = 0; i < m; i++) {\r\n            result[i] = get_edge(i);\r\n        }\r\n        return result;\r\n    }\r\n    std::pair<Cap, Cost> flow(int s, int t) {\r\n        return flow(s, t, std::numeric_limits<Cap>::max());\r\n    }\r\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\r\n        return slope(s, t, flow_limit).back();\r\n    }\r\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\r\n        return slope(s, t, std::numeric_limits<Cap>::max());\r\n    }\r\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\r\n        assert(0 <= s && s < _n);\r\n        assert(0 <= t && t < _n);\r\n        assert(s != t);\r\n       \r\n        std::vector<Cost> dual(_n, 0), dist(_n);\r\n        std::vector<int> pv(_n), pe(_n);\r\n        std::vector<bool> vis(_n);\r\n        auto dual_ref = [&]() {\r\n            std::fill(dist.begin(), dist.end(),\r\n                      std::numeric_limits<Cost>::max());\r\n            std::fill(pv.begin(), pv.end(), -1);\r\n            std::fill(pe.begin(), pe.end(), -1);\r\n            std::fill(vis.begin(), vis.end(), false);\r\n            struct Q {\r\n                Cost key;\r\n                int to;\r\n                bool operator<(Q r) const { return key > r.key; }\r\n            };\r\n            std::priority_queue<Q> que;\r\n            dist[s] = 0;\r\n            que.push(Q{0, s});\r\n            while (!que.empty()) {\r\n                int v = que.top().to;\r\n                que.pop();\r\n                if (vis[v]) continue;\r\n                vis[v] = true;\r\n                if (v == t) break;\r\n                \r\n                for (int i = 0; i < int(g[v].size()); i++) {\r\n                    auto e = g[v][i];\r\n                    if (vis[e.to] || !e.cap) continue;\r\n                    \r\n                    Cost cost = e.cost - dual[e.to] + dual[v];\r\n                    if (dist[e.to] - dist[v] > cost) {\r\n                        dist[e.to] = dist[v] + cost;\r\n                        pv[e.to] = v;\r\n                        pe[e.to] = i;\r\n                        que.push(Q{dist[e.to], e.to});\r\n                    }\r\n                }\r\n            }\r\n            if (!vis[t]) {\r\n                return false;\r\n            }\r\n            for (int v = 0; v < _n; v++) {\r\n                if (!vis[v]) continue;\r\n                \r\n                dual[v] -= dist[t] - dist[v];\r\n            }\r\n            return true;\r\n        };\r\n        Cap flow = 0;\r\n        Cost cost = 0, prev_cost = -1;\r\n        std::vector<std::pair<Cap, Cost>> result;\r\n        result.push_back({flow, cost});\r\n        while (flow < flow_limit) {\r\n            if (!dual_ref()) break;\r\n            Cap c = flow_limit - flow;\r\n            for (int v = t; v != s; v = pv[v]) {\r\n                c = std::min(c, g[pv[v]][pe[v]].cap);\r\n            }\r\n            for (int v = t; v != s; v = pv[v]) {\r\n                auto& e = g[pv[v]][pe[v]];\r\n                e.cap -= c;\r\n                g[v][e.rev].cap += c;\r\n            }\r\n            Cost d = -dual[s];\r\n            flow += c;\r\n            cost += c * d;\r\n            if (prev_cost == d) {\r\n                result.pop_back();\r\n            }\r\n            result.push_back({flow, cost});\r\n            prev_cost = cost;\r\n        }\r\n        return result;\r\n    }\r\n  private:\r\n    int _n;\r\n    struct _edge {\r\n        int to, rev;\r\n        Cap cap;\r\n        Cost cost;\r\n    };\r\n    std::vector<std::pair<int, int>> pos;\r\n    std::vector<std::vector<_edge>> g;\r\n};\r\n}\r\n#endif\r\n#ifndef ATCODER_SEGTREE_HPP\r\n#define ATCODER_SEGTREE_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <vector>\r\nnamespace atcoder {\r\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\r\n  public:\r\n    segtree() : segtree(0) {}\r\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\r\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\r\n        log = internal::ceil_pow2(_n);\r\n        size = 1 << log;\r\n        d = std::vector<S>(2 * size, e());\r\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\r\n        for (int i = size - 1; i >= 1; i--) {\r\n            update(i);\r\n        }\r\n    }\r\n    void set(int p, S x) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        d[p] = x;\r\n        for (int i = 1; i <= log; i++) update(p >> i);\r\n    }\r\n    S get(int p) {\r\n        assert(0 <= p && p < _n);\r\n        return d[p + size];\r\n    }\r\n    S prod(int l, int r) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        S sml = e(), smr = e();\r\n        l += size;\r\n        r += size;\r\n        while (l < r) {\r\n            if (l & 1) sml = op(sml, d[l++]);\r\n            if (r & 1) smr = op(d[--r], smr);\r\n            l >>= 1;\r\n            r >>= 1;\r\n        }\r\n        return op(sml, smr);\r\n    }\r\n    S all_prod() { return d[1]; }\r\n    template <bool (*f)(S)> int max_right(int l) {\r\n        return max_right(l, [](S x) { return f(x); });\r\n    }\r\n    template <class F> int max_right(int l, F f) {\r\n        assert(0 <= l && l <= _n);\r\n        assert(f(e()));\r\n        if (l == _n) return _n;\r\n        l += size;\r\n        S sm = e();\r\n        do {\r\n            while (l % 2 == 0) l >>= 1;\r\n            if (!f(op(sm, d[l]))) {\r\n                while (l < size) {\r\n                    l = (2 * l);\r\n                    if (f(op(sm, d[l]))) {\r\n                        sm = op(sm, d[l]);\r\n                        l++;\r\n                    }\r\n                }\r\n                return l - size;\r\n            }\r\n            sm = op(sm, d[l]);\r\n            l++;\r\n        } while ((l & -l) != l);\r\n        return _n;\r\n    }\r\n    template <bool (*f)(S)> int min_left(int r) {\r\n        return min_left(r, [](S x) { return f(x); });\r\n    }\r\n    template <class F> int min_left(int r, F f) {\r\n        assert(0 <= r && r <= _n);\r\n        assert(f(e()));\r\n        if (r == 0) return 0;\r\n        r += size;\r\n        S sm = e();\r\n        do {\r\n            r--;\r\n            while (r > 1 && (r % 2)) r >>= 1;\r\n            if (!f(op(d[r], sm))) {\r\n                while (r < size) {\r\n                    r = (2 * r + 1);\r\n                    if (f(op(d[r], sm))) {\r\n                        sm = op(d[r], sm);\r\n                        r--;\r\n                    }\r\n                }\r\n                return r + 1 - size;\r\n            }\r\n            sm = op(d[r], sm);\r\n        } while ((r & -r) != r);\r\n        return 0;\r\n    }\r\n  private:\r\n    int _n, size, log;\r\n    std::vector<S> d;\r\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\r\n};\r\n}\r\n#endif\r\n\r\n#ifndef ATCODER_STRING_HPP\r\n#define ATCODER_STRING_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <numeric>\r\n#include <string>\r\n#include <vector>\r\nnamespace atcoder {\r\nnamespace internal {\r\nstd::vector<int> sa_naive(const std::vector<int>& s) {\r\n    int n = int(s.size());\r\n    std::vector<int> sa(n);\r\n    std::iota(sa.begin(), sa.end(), 0);\r\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\r\n        if (l == r) return false;\r\n        while (l < n && r < n) {\r\n            if (s[l] != s[r]) return s[l] < s[r];\r\n            l++;\r\n            r++;\r\n        }\r\n        return l == n;\r\n    });\r\n    return sa;\r\n}\r\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\r\n    int n = int(s.size());\r\n    std::vector<int> sa(n), rnk = s, tmp(n);\r\n    std::iota(sa.begin(), sa.end(), 0);\r\n    for (int k = 1; k < n; k *= 2) {\r\n        auto cmp = [&](int x, int y) {\r\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\r\n            int rx = x + k < n ? rnk[x + k] : -1;\r\n            int ry = y + k < n ? rnk[y + k] : -1;\r\n            return rx < ry;\r\n        };\r\n        std::sort(sa.begin(), sa.end(), cmp);\r\n        tmp[sa[0]] = 0;\r\n        for (int i = 1; i < n; i++) {\r\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\r\n        }\r\n        std::swap(tmp, rnk);\r\n    }\r\n    return sa;\r\n}\r\n\r\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\r\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\r\n    int n = int(s.size());\r\n    if (n == 0) return {};\r\n    if (n == 1) return {0};\r\n    if (n == 2) {\r\n        if (s[0] < s[1]) {\r\n            return {0, 1};\r\n        } else {\r\n            return {1, 0};\r\n        }\r\n    }\r\n    if (n < THRESHOLD_NAIVE) {\r\n        return sa_naive(s);\r\n    }\r\n    if (n < THRESHOLD_DOUBLING) {\r\n        return sa_doubling(s);\r\n    }\r\n    std::vector<int> sa(n);\r\n    std::vector<bool> ls(n);\r\n    for (int i = n - 2; i >= 0; i--) {\r\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\r\n    }\r\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\r\n    for (int i = 0; i < n; i++) {\r\n        if (!ls[i]) {\r\n            sum_s[s[i]]++;\r\n        } else {\r\n            sum_l[s[i] + 1]++;\r\n        }\r\n    }\r\n    for (int i = 0; i <= upper; i++) {\r\n        sum_s[i] += sum_l[i];\r\n        if (i < upper) sum_l[i + 1] += sum_s[i];\r\n    }\r\n    auto induce = [&](const std::vector<int>& lms) {\r\n        std::fill(sa.begin(), sa.end(), -1);\r\n        std::vector<int> buf(upper + 1);\r\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\r\n        for (auto d : lms) {\r\n            if (d == n) continue;\r\n            sa[buf[s[d]]++] = d;\r\n        }\r\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\r\n        sa[buf[s[n - 1]]++] = n - 1;\r\n        for (int i = 0; i < n; i++) {\r\n            int v = sa[i];\r\n            if (v >= 1 && !ls[v - 1]) {\r\n                sa[buf[s[v - 1]]++] = v - 1;\r\n            }\r\n        }\r\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            int v = sa[i];\r\n            if (v >= 1 && ls[v - 1]) {\r\n                sa[--buf[s[v - 1] + 1]] = v - 1;\r\n            }\r\n        }\r\n    };\r\n    std::vector<int> lms_map(n + 1, -1);\r\n    int m = 0;\r\n    for (int i = 1; i < n; i++) {\r\n        if (!ls[i - 1] && ls[i]) {\r\n            lms_map[i] = m++;\r\n        }\r\n    }\r\n    std::vector<int> lms;\r\n    lms.reserve(m);\r\n    for (int i = 1; i < n; i++) {\r\n        if (!ls[i - 1] && ls[i]) {\r\n            lms.push_back(i);\r\n        }\r\n    }\r\n    induce(lms);\r\n    if (m) {\r\n        std::vector<int> sorted_lms;\r\n        sorted_lms.reserve(m);\r\n        for (int v : sa) {\r\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\r\n        }\r\n        std::vector<int> rec_s(m);\r\n        int rec_upper = 0;\r\n        rec_s[lms_map[sorted_lms[0]]] = 0;\r\n        for (int i = 1; i < m; i++) {\r\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\r\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\r\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\r\n            bool same = true;\r\n            if (end_l - l != end_r - r) {\r\n                same = false;\r\n            } else {\r\n                while (l < end_l) {\r\n                    if (s[l] != s[r]) {\r\n                        break;\r\n                    }\r\n                    l++;\r\n                    r++;\r\n                }\r\n                if (l == n || s[l] != s[r]) same = false;\r\n            }\r\n            if (!same) rec_upper++;\r\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\r\n        }\r\n        auto rec_sa =\r\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\r\n        for (int i = 0; i < m; i++) {\r\n            sorted_lms[i] = lms[rec_sa[i]];\r\n        }\r\n        induce(sorted_lms);\r\n    }\r\n    return sa;\r\n}\r\n}\r\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\r\n    assert(0 <= upper);\r\n    for (int d : s) {\r\n        assert(0 <= d && d <= upper);\r\n    }\r\n    auto sa = internal::sa_is(s, upper);\r\n    return sa;\r\n}\r\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\r\n    int n = int(s.size());\r\n    std::vector<int> idx(n);\r\n    iota(idx.begin(), idx.end(), 0);\r\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\r\n    std::vector<int> s2(n);\r\n    int now = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\r\n        s2[idx[i]] = now;\r\n    }\r\n    return internal::sa_is(s2, now);\r\n}\r\nstd::vector<int> suffix_array(const std::string& s) {\r\n    int n = int(s.size());\r\n    std::vector<int> s2(n);\r\n    for (int i = 0; i < n; i++) {\r\n        s2[i] = s[i];\r\n    }\r\n    return internal::sa_is(s2, 255);\r\n}\r\n\r\ntemplate <class T>\r\nstd::vector<int> lcp_array(const std::vector<T>& s,\r\n                           const std::vector<int>& sa) {\r\n    int n = int(s.size());\r\n    assert(n >= 1);\r\n    std::vector<int> rnk(n);\r\n    for (int i = 0; i < n; i++) {\r\n        rnk[sa[i]] = i;\r\n    }\r\n    std::vector<int> lcp(n - 1);\r\n    int h = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (h > 0) h--;\r\n        if (rnk[i] == 0) continue;\r\n        int j = sa[rnk[i] - 1];\r\n        for (; j + h < n && i + h < n; h++) {\r\n            if (s[j + h] != s[i + h]) break;\r\n        }\r\n        lcp[rnk[i] - 1] = h;\r\n    }\r\n    return lcp;\r\n}\r\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\r\n    int n = int(s.size());\r\n    std::vector<int> s2(n);\r\n    for (int i = 0; i < n; i++) {\r\n        s2[i] = s[i];\r\n    }\r\n    return lcp_array(s2, sa);\r\n}\r\n\r\ntemplate <class T> std::vector<int> z_algo(const std::vector<T>& s) {\r\n    int n = int(s.size());\r\n    if (n == 0) return {};\r\n    std::vector<int> z(n);\r\n    z[0] = 0;\r\n    for (int i = 1, j = 0; i < n; i++) {\r\n        int& k = z[i];\r\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\r\n        while (i + k < n && s[k] == s[i + k]) k++;\r\n        if (j + z[j] < i + z[i]) j = i;\r\n    }\r\n    z[0] = n;\r\n    return z;\r\n}\r\nstd::vector<int> z_algo(const std::string& s) {\r\n    int n = int(s.size());\r\n    std::vector<int> s2(n);\r\n    for (int i = 0; i < n; i++) {\r\n        s2[i] = s[i];\r\n    }\r\n    return z_algo(s2);\r\n}\r\n}\r\n#endif\r\n\r\n#ifndef ATCODER_MATH_HPP\r\n#define ATCODER_MATH_HPP 1\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <tuple>\r\n#include <vector>\r\nnamespace atcoder {\r\nlong long pow_mod(long long x, long long n, int m) {\r\n    assert(0 <= n && 1 <= m);\r\n    if (m == 1) return 0;\r\n    internal::barrett bt((unsigned int)(m));\r\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\r\n    while (n) {\r\n        if (n & 1) r = bt.mul(r, y);\r\n        y = bt.mul(y, y);\r\n        n >>= 1;\r\n    }\r\n    return r;\r\n}\r\nlong long inv_mod(long long x, long long m) {\r\n    assert(1 <= m);\r\n    auto z = internal::inv_gcd(x, m);\r\n    assert(z.first == 1);\r\n    return z.second;\r\n}\r\n\r\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\r\n                                    const std::vector<long long>& m) {\r\n    assert(r.size() == m.size());\r\n    int n = int(r.size());\r\n    \r\n    long long r0 = 0, m0 = 1;\r\n    for (int i = 0; i < n; i++) {\r\n        assert(1 <= m[i]);\r\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\r\n        if (m0 < m1) {\r\n            std::swap(r0, r1);\r\n            std::swap(m0, m1);\r\n        }\r\n        if (m0 % m1 == 0) {\r\n            if (r0 % m1 != r1) return {0, 0};\r\n            continue;\r\n        }\r\n        \r\n        long long g, im;\r\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\r\n        long long u1 = (m1 / g);\r\n        \r\n        if ((r1 - r0) % g) return {0, 0};\r\n        \r\n        long long x = (r1 - r0) / g % u1 * im % u1;\r\n        \r\n        r0 += x * m0;\r\n        m0 *= u1;\r\n        if (r0 < 0) r0 += m0;\r\n    }\r\n    return {r0, m0};\r\n}\r\nlong long floor_sum(long long n, long long m, long long a, long long b) {\r\n    long long ans = 0;\r\n    if (a >= m) {\r\n        ans += (n - 1) * n * (a / m) / 2;\r\n        a %= m;\r\n    }\r\n    if (b >= m) {\r\n        ans += n * (b / m);\r\n        b %= m;\r\n    }\r\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\r\n    if (y_max == 0) return ans;\r\n    ans += (n - (x_max + a - 1) / a) * y_max;\r\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\r\n    return ans;\r\n}\r\n}\r\n\r\n#endif\r\n\r\n\r\nusing namespace atcoder;\r\n#define endl \"\\n\"\r\nusing mint=static_modint<mod2>;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\n    int t;cin>>t;\r\n    rep(_,0,t){\r\n        int n;cin>>n;\r\n        int a[n],b[n];\r\n        rep(i,0,n)cin>>a[i];\r\n        rep(i,0,n)cin>>b[i];\r\n        ll dp[n][2];\r\n        rep(i,0,n)rep(j,0,2)dp[i][j]=inf;\r\n        dp[0][0]=0;\r\n        dp[0][1]=0;\r\n        rep(i,1,n){\r\n            rep(j,0,2){\r\n                if(j==0){\r\n                    Min(dp[i][0],dp[i-1][j]+abs(a[i]-a[i-1])+abs(b[i]-b[i-1]));\r\n                    Min(dp[i][1],dp[i-1][j]+abs(b[i]-a[i-1])+abs(a[i]-b[i-1]));\r\n                }\r\n                else{\r\n                    Min(dp[i][0],dp[i-1][j]+abs(a[i]-b[i-1])+abs(b[i]-a[i-1]));\r\n                    Min(dp[i][1],dp[i-1][j]+abs(b[i]-b[i-1])+abs(a[i]-a[i-1]));\r\n                }\r\n            }\r\n        }\r\n        cout<<min(dp[n-1][0],dp[n-1][1])<<endl;\r\n    }\r\n}\r\n"
}