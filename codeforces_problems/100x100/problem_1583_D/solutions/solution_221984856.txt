{
    "id": 221984856,
    "contestId": 1583,
    "creationTimeSeconds": 1693939958,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1583,
        "index": "D",
        "name": "Omkar and the Meaning of Life",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1800,
        "tags": [
            "constructive algorithms",
            "greedy",
            "interactive"
        ]
    },
    "author": {
        "contestId": 1583,
        "members": [
            {
                "handle": "Suplex"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1634468700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 26,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef vector<int> vi;\r\ntypedef vector<long long>vll;\r\ntypedef vector<vector<long long>>vvll;\r\ntypedef pair<long long,long long>pll;\r\ntypedef pair<int,int> pii; \r\ntemplate <typename T> using vc = vector<T>;\r\ntemplate <typename T> using vvc = vector<vc<T>>;\r\ntemplate <typename T> using vvvc = vector<vvc<T>>;\r\nusing vi = vc<int>;\r\nusing vl = vc<ll>;\r\nusing vpi = vc<pii>;\r\nusing vpl = vc<pll>;\r\ntemplate <class T> using pq = priority_queue<T>;\r\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate <typename T> int si(const T &x) { return x.size(); }\r\n#define overload5(a, b, c, d, e, name, ...) name\r\n#define overload4(a, b, c, d, name, ...) name\r\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\r\n#define overload2(_1, _2, name, ...) name\r\n#define endl \"\\n\"\r\n#define sq(x) (long long)sqrt(x)\r\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\r\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\r\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\r\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\r\n#define per0(n) for(int jidlsjf = 0; jidlsjf < (n); ++jidlsjf)\r\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\r\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\r\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= (b); i -= (c))\r\n#define fore1(i, a) for(auto &&i : a)\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define ppf pop_front\r\n#define eb emplace_back\r\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\r\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\r\n#define rng(v, l, r) v.begin() + (l), v.begin() + (r)\r\n#define all(c) begin(c), end(c)\r\n#define rall(c) rbegin(c), rend(c)\r\n#define SORT(v) sort(all(v))\r\n#define REV(v) reverse(all(v))\r\n#define MIN(v) *min_element(all(v))\r\n#define MAX(v) *max_element(all(v))\r\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\r\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\r\nvoid scan(int &a) { cin >> a; }\r\nvoid scan(long long &a) { cin >> a; }\r\nvoid scan(char &a) { cin >> a; }\r\nvoid scan(double &a) { cin >> a; }\r\nvoid scan(string &a) { cin >> a; }\r\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\r\ntemplate <class T> void scan(vector<T> &);\r\ntemplate <class T> void scan(vector<T> &a) {\r\n    for(auto &i : a) scan(i);\r\n}\r\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x) { return pair<T, S>(-x.first, -x.second); }\r\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\r\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\r\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\r\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\r\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\r\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\r\n\r\ntemplate <class T> vector<T> &operator++(vector<T> &v) {\r\n    fore(e, v) e++;\r\n    return v;\r\n}\r\ntemplate <class T> vector<T> operator++(vector<T> &v, int) {\r\n    auto res = v;\r\n    fore(e, v) e++;\r\n    return res;\r\n}\r\ntemplate <class T> vector<T> &operator--(vector<T> &v) {\r\n    fore(e, v) e--;\r\n    return v;\r\n}\r\ntemplate <class T> vector<T> operator--(vector<T> &v, int) {\r\n    auto res = v;\r\n    fore(e, v) e--;\r\n    return res;\r\n}\r\ntemplate <class T> vector<T> &operator+=(vector<T> &l, const vector<T> &r) {\r\n    fore(e, r) l.eb(e);\r\n    return l;\r\n}\r\ntemplate <class T> void scan(T &a) { cin >> a; }\r\ntemplate <typename T, typename S> T ceil(T x, S y) {\r\n    assert(y);\r\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\r\n}\r\n \r\ntemplate <typename T, typename S> T floor(T x, S y) {\r\n    assert(y);\r\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\r\n}\r\ntemplate <class T> T POW(T x, int n) {\r\n    T res = 1;\r\n    for(; n; n >>= 1, x *= x)\r\n        if(n & 1) res *= x;\r\n    return res;\r\n}\r\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\r\n    T res = 1;\r\n    x %= mod;\r\n    for(; n; n >>= 1, x = x * x % mod)\r\n        if(n & 1) res = res * x % mod;\r\n    return res;\r\n}\r\nvector<pll> factor(ll x) {\r\n    vector<pll> ans;\r\n    for(ll i = 2; i * i <= x; i++)\r\n        if(x % i == 0) {\r\n            ans.push_back({i, 1});\r\n            while((x /= i) % i == 0) ans.back().second++;\r\n        }\r\n    if(x != 1) ans.push_back({x, 1});\r\n    return ans;\r\n}\r\ntemplate <class T> vector<T> divisor(T x) {\r\n    vector<T> ans;\r\n    for(T i = 1; i * i <= x; i++)\r\n        if(x % i == 0) {\r\n            ans.pb(i);\r\n            if(i * i != x) ans.pb(x / i);\r\n        }\r\n    return ans;\r\n}\r\ntemplate <class T> bool is_prime(T x) {\r\n    if(x<2) return false;\r\n    for(T i = 2; i * i <= x; i++)\r\n        if(x % i == 0) {\r\n            return false;\r\n        }\r\n    return true;\r\n}\r\ntemplate <class T> vector<T> prime_factors(T x) {\r\n    vector<T> ans;\r\n    for(T i = 2; i * i <= x; i++){\r\n        while(x % i == 0) {\r\n            ans.pb(i);\r\n            x/=i;\r\n        }\r\n    }\r\n    if(x>1) ans.pb(x);\r\n    return ans;\r\n}\r\ntemplate <class T> vector<char> sieve_prime(T l,T r) {\r\n    vector<char> ans(r-l+1,true);\r\n    ll lim=sqrt(r);\r\n    for(T i = 2; i <= lim; i++){\r\n        for(T j=max(i*i,(l+i-1/(i*i)));j<=r;j+=i){\r\n            ans[j-l]=false;\r\n        }\r\n    }\r\n    if(l==1) ans[0]=false;\r\n    return ans;\r\n}\r\ntemplate <class T> vector<T> sieve_prime(T x) {\r\n    vector<bool> ans(x+1,true);\r\n    ans[0]=ans[1]=false;\r\n    for(T i = 2; i * i <= x; i++){\r\n        if(ans[i]){\r\n            for(T j=i*i;j<=x;j+=i){\r\n                ans[j]=false;\r\n            }\r\n        }\r\n    }\r\n    return ans;\r\n}\r\nll max(int x, ll y) { return max((ll)x, y); }\r\nll max(ll x, int y) { return max(x, (ll)y); }\r\nint min(int x, ll y) { return min((ll)x, y); }\r\nint min(ll x, int y) { return min(x, (ll)y); }\r\nll pow2(int i) { return 1LL << i; }\r\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\r\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\r\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\r\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\r\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\r\nstatic inline uint64_t popcount64(uint64_t x) {\r\n    uint64_t m1 = 0x5555555555555555ll;\r\n    uint64_t m2 = 0x3333333333333333ll;\r\n    uint64_t m4 = 0x0F0F0F0F0F0F0F0Fll;\r\n    uint64_t h01 = 0x0101010101010101ll;\r\n \r\n    x -= (x >> 1) & m1;\r\n    x = (x & m2) + ((x >> 2) & m2);\r\n    x = (x + (x >> 4)) & m4;\r\n \r\n    return (x * h01) >> 56;\r\n}\r\nbool ispow2(int i) { return i && (i & -i) == i; }\r\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> \r\nistream& operator >> (istream &is, T_container &v) { \r\n   for(T &x : v) is >> x; return is;\r\n}\r\n#ifdef __SIZEOF_INT128__\r\nostream& operator << (ostream &os, __int128 const& value){\r\n    static char buffer[64];\r\n    int index = 0;\r\n    __uint128_t T = (value < 0) ? (-(value + 1)) + __uint128_t(1) : value;\r\n    if (value < 0) \r\n        os << '-';\r\n    else if (T == 0)\r\n        return os << '0';\r\n    for(; T > 0; ++index){\r\n        buffer[index] = static_cast<char>('0' + (T % 10));\r\n        T /= 10;\r\n    }    \r\n    while(index > 0)\r\n        os << buffer[--index];\r\n    return os;\r\n}\r\nistream& operator >> (istream& is, __int128& T){\r\n    static char buffer[64];\r\n    is >> buffer;\r\n    size_t len = strlen(buffer), index = 0;\r\n    T = 0; int mul = 1;\r\n    if (buffer[index] == '-')\r\n        ++index, mul *= -1;\r\n    for(; index < len; ++index)\r\n        T = T * 10 + static_cast<int>(buffer[index] - '0');\r\n    T *= mul;    \r\n    return is;\r\n}\r\n#endif\r\n \r\ntemplate<typename A, typename B> \r\nostream& operator<<(ostream &os, const pair<A, B> &p) { \r\n   return os << '(' << p.first << \", \" << p.second << ')'; \r\n}\r\n \r\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> \r\nostream& operator << (ostream &os, const T_container &v) { \r\n   os << '{'; string sep; \r\n   for (const T &x : v) os << sep << x, sep = \", \"; \r\n   return os << '}'; \r\n}\r\ntemplate<class P, class Q = vector<P>, class R = less<P> > ostream& operator << (ostream& out, priority_queue<P, Q, R> const& M){\r\n    static priority_queue<P, Q, R> U;\r\n    U = M;\r\n    out << \"{ \";\r\n    while(!U.empty())\r\n        out << U.top() << \" \", U.pop();\r\n    return (out << \"}\");\r\n}\r\ntemplate<class P> ostream& operator << (ostream& out, queue<P> const& M){\r\n    static queue<P> U;\r\n    U = M;\r\n    out << \"{\"; string sep;\r\n    while(!U.empty()){\r\n        out << sep << U.front(); sep = \", \"; U.pop();\r\n    }\r\n    return (out << \"}\");\r\n}\r\nll gcdex(ll a,ll b,ll &x,ll &y){\r\n    // ax+by=gcd(a,b)\r\n    if(b==0){\r\n        y=0;\r\n        x=1;\r\n        return a;\r\n    }\r\n    ll x1,y1;\r\n    ll d=gcdex(b,a%b,x1,y1);\r\n    x=y1;\r\n    y=x1-y1*(a/b);\r\n    return d;\r\n}\r\nll gcd(ll a , ll b)\r\n{\r\n   if(b==0) return a;\r\n   a%=b;\r\n   return gcd(b,a);\r\n}\r\nconst ll inf=1e18;\r\nll n;\r\nll get_greater(ll idx){\r\n    vll a(n,1);\r\n    a[idx]=2;\r\n    cout<<\"? \";\r\n    for(auto x:a) cout<<x<<\" \";\r\n    cout<<endl;\r\n    cout.flush();\r\n    ll x;\r\n    cin>>x;\r\n    x--;\r\n    return x;\r\n}\r\nll get_smaller(ll idx){\r\n    vll a(n,2);\r\n    a[idx]=1;\r\n    cout<<\"? \";\r\n    for(auto x:a) cout<<x<<\" \";\r\n    cout<<endl;\r\n    cout.flush();\r\n    ll x;\r\n    cin>>x;\r\n    x--;\r\n    return x;\r\n}\r\nvoid solve()\r\n{\r\n    //your code\r\n    cin>>n;\r\n    vll ans(n);\r\n    vll nxt(n,-1);\r\n    ll idx1=-1,idxn=-1;\r\n    REP1(i,n){\r\n        ll x=get_greater(i);\r\n        ll y=get_smaller(i);\r\n        // cout<<\"x\"<<\" \"<<x<<\" \"<<\"y\"<<\" \"<<y<<endl;\r\n        if(x==-1){\r\n            ans[i]=n;\r\n            idxn=i;\r\n        }\r\n        else if(x!=i){\r\n            // g[i].pb(x);\r\n            nxt[i]=x;\r\n        }\r\n        if(y==-1){\r\n            ans[i]=1;\r\n            idx1=i;\r\n        }\r\n        else if(y!=i){\r\n            // g[x].pb(i);\r\n            nxt[y]=i;\r\n        }\r\n    }\r\n    // function<void(ll)> dfs=[&](ll u){\r\n    //     for(auto v:g[u]){\r\n    //         dfs();\r\n    //     }\r\n    // };\r\n    // cout<<ans<<endl;\r\n    // cout<<nxt<<endl;\r\n    ll c=1;\r\n    for(int i=idx1;i!=idxn;i=nxt[i]){\r\n        ans[i]=c++;\r\n    }\r\n    cout<<\"! \";\r\n    for(auto x:ans) cout<<x<<\" \";\r\n    cout<<endl;\r\n    cout.flush();\r\n\r\n    \r\n    \r\n    \r\n\r\n}\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    int t;\r\n    t=1;\r\n    while(t--)\r\n    {\r\n    solve();\r\n    }\r\n    return 0;\r\n}"
}