{
    "id": 185599504,
    "contestId": 279,
    "creationTimeSeconds": 1671265799,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 279,
        "index": "D",
        "name": "The Minimum Number of Variables",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "bitmasks",
            "dp"
        ]
    },
    "author": {
        "contestId": 279,
        "members": [
            {
                "handle": "TheUsurper"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362411000
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 70,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 1331200,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n\r\n#include <bits/stdc++.h> \r\nusing namespace std;\r\n \r\ntypedef long long ll;\r\n#define int ll\r\ntypedef long double ld;\r\ntypedef vector<int> vi;\r\ntypedef pair<int,int> pii;\r\ntypedef vector<pair<int, int>> vpi;\r\ntypedef vector<vector<int>> vvi;\r\n\r\nint mod = 1000000007;\r\n\r\n#define FOR(i,e) for(ll i = 0; i < e; i++)\r\n#define FORM(i,s,e) for(ll i = s; i < e; i++)\r\n#define nl \"\\n\"\r\n#define printArr(arr) FOR(abcd, arr.size()){cout<<arr[abcd]<<\" \";}cout<<nl;\r\n#define dbg(x) cout<<#x<<\" = \"<<x<<nl\r\n#define pb push_back\r\n#define pob pop_back\r\n#define fi first\r\n#define se second\r\n#define INF 2e18\r\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(x) ((ll)(x).size())\r\n#define FOREACH(a,b) for(auto &(a): (b))\r\n#define rev(v) reverse(all(v))\r\n#define cint(n) int n; cin>>n\r\n#define cint2(a,b) int a,b; cin>>a>>b\r\n#define cint3(a,b,c) int a,b,c; cin>>a>>b>>c\r\n\r\nint gcdExtended(int a, int b, int *x, int *y)\r\n{\r\n    // Base Case\r\n    if (a == 0)\r\n    {\r\n        *x = 0, *y = 1;\r\n        return b;\r\n    }\r\n\r\n    int x1, y1; // To store results of recursive call\r\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\r\n\r\n    // Update x and y using results of recursive\r\n    // call\r\n    *x = y1 - (b / a) * x1;\r\n    *y = x1;\r\n\r\n    return gcd;\r\n}\r\n\r\n// Function to find modulo inverse of a\r\nll modInverse(ll a, ll m)\r\n{\r\n    int x, y;\r\n    int g = gcdExtended(a, m, &x, &y);\r\n    if (g != 1)\r\n        return 0;\r\n    else\r\n    {\r\n        // m is added to handle negative x\r\n        ll res = (x % m + m) % m;\r\n        return res;\r\n    }\r\n}\r\n \r\nll nCr(int n, int r){\r\n    // remember to commend the ans/=i line in case of modulo\r\n    if(r>n){\r\n        return 0;\r\n    }\r\n    if(r>n-r){\r\n        r = n-r;\r\n    }\r\n    ll ans = 1;\r\n    for(int i = 1; i<=r ; i++){\r\n        ans *= (n-i+1);\r\n     // ans%= mod;\r\n     // ans *= modInverse(i, mod);\r\n     // ans %= mod;\r\n\r\n    //   *********** COMMENT ***********\r\n        ans /= i;\r\n    }\r\n \r\n    return ans;\r\n}\r\n \r\nll binpow(ll a, ll b) {\r\n    if (b == 0)\r\n        return 1;\r\n    long long res = binpow(a, b / 2);\r\n    if (b % 2)\r\n        return (res * res)%mod * a % mod;\r\n    else\r\n        return (res * res) %mod;\r\n}\r\n\r\nstruct segTree{\r\n    int size;\r\n    vector<int> seg;\r\n\r\n    void init(int n){\r\n        size = 1;\r\n        while(size<n) size *= 2;\r\n        seg.assign(2*size, 0LL);\r\n    }\r\n\r\n    void build(vector<int> &arr, int idx, int lx, int rx){\r\n        if(lx>rx) return;\r\n        if(lx == rx){\r\n            if(lx<sz(arr))\r\n                seg[idx] = arr[lx];\r\n            return;\r\n        }\r\n\r\n        int m = (lx + rx)/2;\r\n        build(arr, 2*idx+1, lx, m);\r\n        build(arr, 2*idx+2, m+1, rx);\r\n\r\n        seg[idx] = seg[2*idx+1] + seg[2*idx+2];\r\n        return;\r\n    }\r\n\r\n    void build(vector<int> &arr){\r\n        build(arr, 0, 0, size-1);\r\n    }\r\n\r\n    void set(int target_idx, int v, int idx, int lx, int rx){\r\n        if(lx==rx){\r\n            seg[idx] = v;\r\n            return;\r\n        }\r\n        int m = (lx + rx)/2;\r\n        if(target_idx<=m){\r\n            set(target_idx, v, 2*idx+1, lx, m);\r\n        }\r\n        else{\r\n            set(target_idx, v, 2*idx+2, m+1, rx);\r\n        }   \r\n\r\n        seg[idx] = seg[2*idx+1] + seg[2*idx+2];\r\n        return;\r\n    }\r\n\r\n    void set(int i, int v){\r\n        set(i, v, 0, 0, size-1);\r\n    }\r\n\r\n    int sum(int l, int r, int idx, int lx, int rx){\r\n        if(rx<l || lx>r) return 0;\r\n        if(lx>=l && rx<=r) return seg[idx];\r\n\r\n        int m = (lx+rx)/2;\r\n        int s1 = sum(l, r, 2*idx+1, lx, m);\r\n        int s2 = sum(l, r, 2*idx+2, m+1, rx);\r\n\r\n        return (s1 + s2);\r\n    }\r\n\r\n    int sum(int l, int r){\r\n        return sum(l, r, 0, 0, size-1);\r\n    }\r\n};\r\n\r\n// z-array is 0 indexed\r\nvector<int> z_function(string &s) {\r\n    int n = (int) s.length();\r\n    vector<int> z(n);\r\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\r\n        if (i <= r)\r\n            z[i] = min (r - i + 1, z[i - l]);\r\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\r\n            ++z[i];\r\n        if (i + z[i] - 1 > r)\r\n            l = i, r = i + z[i] - 1;\r\n    }\r\n    return z;\r\n}\r\n\r\n// PRIME FACTORISATION USING SEIVE  \r\n// #define MAXN 100001\r\n// int spf[MAXN];\r\n// void sieve()\r\n// {\r\n//     spf[1] = 1;\r\n//     for (int i=2; i<MAXN; i++)\r\n//         spf[i] = i;\r\n//     for (int i=4; i<MAXN; i+=2)\r\n//         spf[i] = 2;\r\n//     for (int i=3; i*i<MAXN; i++)\r\n//     {\r\n//         if (spf[i] == i)\r\n//         {\r\n//             for (int j=i*i; j<MAXN; j+=i)\r\n//                 if (spf[j]==j)\r\n//                     spf[j] = i;\r\n//         }\r\n//     }\r\n// }\r\n// void getFactorization(int x, vector<int> &factors)\r\n// {\r\n//     while (x != 1)\r\n//     {\r\n//         factors.push_back(spf[x]);\r\n//         x = x / spf[x];\r\n//     }\r\n// }\r\n\r\n// LINEAR SIEVE\r\n// const int N = 10000000;\r\n// vector<int> lp(N+1);\r\n// vector<int> pr;\r\n// void linSv(){\r\n//     for (int i=2; i <= N; ++i) {\r\n//         if (lp[i] == 0) {\r\n//             lp[i] = i;\r\n//             pr.push_back(i);\r\n//         }\r\n//         for (int j = 0; i * pr[j] <= N; ++j) {\r\n//             lp[i * pr[j]] = pr[j];\r\n//             if (pr[j] == lp[i]) {\r\n//                 break;\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n// LOWEST COMMON ANCESTOR\r\n// N = (n+1) in case of 1 indexed\r\n// resize adj -> preprocess(root) -> LCA\r\n// int N, l;\r\n// vector<vector<int>> adj;\r\n// int timer;\r\n// vector<int> tin, tout;\r\n// vector<vector<int>> up;\r\n// void dfs(int v, int p)\r\n// {\r\n//     tin[v] = ++timer;\r\n//     up[v][0] = p;\r\n//     for (int i = 1; i <= l; ++i)\r\n//         up[v][i] = up[up[v][i-1]][i-1];\r\n\r\n//     for (int u : adj[v]) {\r\n//         if (u != p)\r\n//             dfs(u, v);\r\n//     }\r\n\r\n//     tout[v] = ++timer;\r\n// }\r\n// bool is_ancestor(int u, int v)\r\n// {\r\n//     return tin[u] <= tin[v] && tout[u] >= tout[v];\r\n// }\r\n// int lca(int u, int v)\r\n// {\r\n//     if (is_ancestor(u, v))\r\n//         return u;\r\n//     if (is_ancestor(v, u))\r\n//         return v;\r\n//     for (int i = l; i >= 0; --i) {\r\n//         if (!is_ancestor(up[u][i], v))\r\n//             u = up[u][i];\r\n//     }\r\n//     return up[u][0];\r\n// }\r\n// void preprocess(int root) {\r\n//     tin.resize(N);\r\n//     tout.resize(N);\r\n//     timer = 0;\r\n//     l = ceil(log2(N));\r\n//     up.assign(N, vector<int>(l + 1));\r\n//     dfs(root, root);\r\n// }\r\n\r\n// DSU\r\n// resize leader,gsize -> make_set(i) for all i\r\n// vector<int> leader;\r\n// vector<int> gsize;\r\n// vector<vector<int>> adj;\r\n\r\n// int find_set(int v) {\r\n//     if (v == leader[v])\r\n//         return v;\r\n//     return leader[v] = find_set(leader[v]);\r\n// }\r\n\r\n// void make_set(int v) {\r\n//     leader[v] = v;\r\n//     gsize[v] = 1;\r\n// }\r\n\r\n// void union_sets(int a, int b) {\r\n//     a = find_set(a);\r\n//     b = find_set(b);\r\n//     if (a != b) {\r\n//         if (gsize[a] < gsize[b])\r\n//             swap(a, b);\r\n//         leader[b] = a;\r\n//         gsize[a] += gsize[b];\r\n//     }\r\n// }\r\n\r\n\r\nvector<int> a;\r\nint n;\r\nvector<vector<pair<int,int>>> poss;\r\nvector<map<int,int>> dp;\r\nvoid check(int i, map<int,int> &mp, int &maxi){\r\n    if(i<=0) return;\r\n    int hash1 = 0;\r\n    for(auto x: mp){\r\n        hash1 += (1<<x.first);\r\n    }\r\n    if(dp[i].find(hash1) != dp[i].end()){\r\n        maxi  = max(maxi, dp[i][hash1]);\r\n        return;\r\n    }\r\n    int store = mp[i];\r\n    mp.erase(i);\r\n    if(i>0){\r\n        mp[i-1]++;\r\n    }\r\n\r\n    int mini = INT_MAX;\r\n    for(auto x: poss[i]){\r\n        int one = x.first;\r\n        int two = x.second;\r\n        map<int,int> temp = mp;\r\n        temp[one]++;\r\n        temp[two]++;\r\n        int tempmax = temp.size();\r\n        check(i-1, temp, tempmax);\r\n        mini = min(mini, tempmax);\r\n    }\r\n    maxi = max(maxi, mini);\r\n    dp[i][hash1] = mini;\r\n}\r\n\r\nsigned main()\r\n{\r\n//#ifndef ONLINE_JUDGE\r\n//freopen(\"input.txt\", \"r\", stdin);\r\n//freopen(\"output.txt\", \"w\", stdout);\r\n//#endif\r\nfast_cin();\r\n\r\ncin>>n;\r\na.resize(n+1);\r\ndp.resize(n);\r\nFOR(i,n) cin>>a[i];\r\nposs.resize(n);\r\nfor(int i = 1; i<n;i ++){\r\n    for(int j=0; j<i; j++){\r\n        for(int k = j; k<i; k++){\r\n            if((a[j]+a[k]) == a[i]){\r\n                poss[i].push_back({j,k});\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint maxi = 1;\r\nmap<int,int> mp;\r\nmp[n-1]++;\r\ncheck(n-1, mp, maxi);\r\nif(maxi != INT_MAX)\r\ncout<<maxi<<nl;\r\nelse{\r\n    cout<<-1<<nl;\r\n}\r\n\r\nreturn 0;\r\n}"
}