{
    "id": 211962924,
    "contestId": 1096,
    "creationTimeSeconds": 1688396179,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1096,
        "index": "F",
        "name": "Inversion Expectation",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "dp",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1096,
        "members": [
            {
                "handle": "ecottea"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1546007700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#ifndef HIDDEN_IN_VS // \u6298\u308a\u305f\u305f\u307f\u7528\r\n\r\n// \u8b66\u544a\u306e\u6291\u5236\r\n#define _CRT_SECURE_NO_WARNINGS\r\n\r\n// \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8aad\u307f\u8fbc\u307f\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// \u578b\u540d\u306e\u77ed\u7e2e\r\nusing ll = long long; // -2^63 \uff5e 2^63 = 9 * 10^18\uff08int \u306f -2^31 \uff5e 2^31 = 2 * 10^9\uff09\r\nusing pii = pair<int, int>;\tusing pll = pair<ll, ll>;\tusing pil = pair<int, ll>;\tusing pli = pair<ll, int>;\r\nusing vi = vector<int>;\t\tusing vvi = vector<vi>;\t\tusing vvvi = vector<vvi>;\r\nusing vl = vector<ll>;\t\tusing vvl = vector<vl>;\t\tusing vvvl = vector<vvl>;\r\nusing vb = vector<bool>;\tusing vvb = vector<vb>;\t\tusing vvvb = vector<vvb>;\r\nusing vc = vector<char>;\tusing vvc = vector<vc>;\t\tusing vvvc = vector<vvc>;\r\nusing vd = vector<double>;\tusing vvd = vector<vd>;\t\tusing vvvd = vector<vvd>;\r\ntemplate <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\r\nusing Graph = vvi;\r\n\r\n// \u5b9a\u6570\u306e\u5b9a\u7fa9\r\nconst double PI = acos(-1);\r\nconst vi DX = { 1, 0, -1, 0 }; // 4 \u8fd1\u508d\uff08\u4e0b\uff0c\u53f3\uff0c\u4e0a\uff0c\u5de6\uff09\r\nconst vi DY = { 0, 1, 0, -1 };\r\nint INF = 1001001001; ll INFL = 4004004003104004004LL; // (int)INFL = 1010931620;\r\ndouble EPS = 1e-15;\r\n\r\n// \u5165\u51fa\u529b\u9ad8\u901f\u5316\r\nstruct fast_io { fast_io() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(18); } } fastIOtmp;\r\n\r\n// \u6c4e\u7528\u30de\u30af\u30ed\u306e\u5b9a\u7fa9\r\n#define all(a) (a).begin(), (a).end()\r\n#define sz(x) ((int)(x).size())\r\n#define lbpos(a, x) (int)distance((a).begin(), std::lower_bound(all(a), x))\r\n#define ubpos(a, x) (int)distance((a).begin(), std::upper_bound(all(a), x))\r\n#define Yes(b) {cout << ((b) ? \"Yes\\n\" : \"No\\n\");}\r\n#define YES(b) {cout << ((b) ? \"YES\\n\" : \"NO\\n\");}\r\n#define rep(i, n) for(int i = 0, i##_len = int(n); i < i##_len; ++i) // 0 \u304b\u3089 n-1 \u307e\u3067\u6607\u9806\r\n#define repi(i, s, t) for(int i = int(s), i##_end = int(t); i <= i##_end; ++i) // s \u304b\u3089 t \u307e\u3067\u6607\u9806\r\n#define repir(i, s, t) for(int i = int(s), i##_end = int(t); i >= i##_end; --i) // s \u304b\u3089 t \u307e\u3067\u964d\u9806\r\n#define repe(v, a) for(const auto& v : (a)) // a \u306e\u5168\u8981\u7d20\uff08\u5909\u66f4\u4e0d\u53ef\u80fd\uff09\r\n#define repea(v, a) for(auto& v : (a)) // a \u306e\u5168\u8981\u7d20\uff08\u5909\u66f4\u53ef\u80fd\uff09\r\n#define repb(set, d) for(int set = 0; set < (1 << int(d)); ++set) // d \u30d3\u30c3\u30c8\u5168\u63a2\u7d22\uff08\u6607\u9806\uff09\r\n#define repp(a) sort(all(a)); for(bool a##_perm = true; a##_perm; a##_perm = next_permutation(all(a))) // a \u306e\u9806\u5217\u5168\u3066\uff08\u6607\u9806\uff09\r\n#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // \u975e\u8ca0mod\r\n#define uniq(a) {sort(all(a)); (a).erase(unique(all(a)), (a).end());} // \u91cd\u8907\u9664\u53bb\r\n#define EXIT(a) {cout << (a) << endl; exit(0);} // \u5f37\u5236\u7d42\u4e86\r\n#define inQ(x, y, u, l, d, r) ((u) <= (x) && (l) <= (y) && (x) < (d) && (y) < (r)) // \u77e9\u5f62\u5185\u5224\u5b9a\r\n\r\n// \u6c4e\u7528\u95a2\u6570\u306e\u5b9a\u7fa9\r\ntemplate <class T> inline ll pow(T n, int k) { ll v = 1; rep(i, k) v *= n; return v; }\r\ntemplate <class T> inline bool chmax(T& M, const T& x) { if (M < x) { M = x; return true; } return false; } // \u6700\u5927\u5024\u3092\u66f4\u65b0\uff08\u66f4\u65b0\u3055\u308c\u305f\u3089 true \u3092\u8fd4\u3059\uff09\r\ntemplate <class T> inline bool chmin(T& m, const T& x) { if (m > x) { m = x; return true; } return false; } // \u6700\u5c0f\u5024\u3092\u66f4\u65b0\uff08\u66f4\u65b0\u3055\u308c\u305f\u3089 true \u3092\u8fd4\u3059\uff09\r\ntemplate <class T> inline T get(T set, int i) { return (set >> i) & T(1); }\r\n\r\n// \u6f14\u7b97\u5b50\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\r\ntemplate <class T, class U> inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\r\ntemplate <class T> inline istream& operator>>(istream& is, vector<T>& v) { repea(x, v) is >> x; return is; }\r\ntemplate <class T> inline vector<T>& operator--(vector<T>& v) { repea(x, v) --x; return v; }\r\ntemplate <class T> inline vector<T>& operator++(vector<T>& v) { repea(x, v) ++x; return v; }\r\n\r\n#endif // \u6298\u308a\u305f\u305f\u307f\u7528\r\n\r\n\r\n#if __has_include(<atcoder/all>)\r\n#include <atcoder/all>\r\nusing namespace atcoder;\r\n\r\n#ifdef _MSC_VER\r\n#include \"localACL.hpp\"\r\n#endif\r\n\r\n//using mint = modint1000000007;\r\nusing mint = modint998244353;\r\n//using mint = modint; // mint::set_mod(m);\r\n\r\nnamespace atcoder {\r\n\tinline istream& operator>>(istream& is, mint& x) { ll x_; is >> x_; x = x_; return is; }\r\n\tinline ostream& operator<<(ostream& os, const mint& x) { os << x.val(); return os; }\r\n}\r\nusing vm = vector<mint>; using vvm = vector<vm>; using vvvm = vector<vvm>;\r\n#endif\r\n\r\n\r\n#ifdef _MSC_VER // \u624b\u5143\u74b0\u5883\uff08Visual Studio\uff09\r\n#include \"local.hpp\"\r\n#else // \u63d0\u51fa\u7528\uff08gcc\uff09\r\ninline int popcount(int n) { return __builtin_popcount(n); }\r\ninline int popcount(ll n) { return __builtin_popcountll(n); }\r\ninline int lsb(int n) { return n != 0 ? __builtin_ctz(n) : -1; }\r\ninline int lsb(ll n) { return n != 0 ? __builtin_ctzll(n) : -1; }\r\ninline int msb(int n) { return n != 0 ? (31 - __builtin_clz(n)) : -1; }\r\ninline int msb(ll n) { return n != 0 ? (63 - __builtin_clzll(n)) : -1; }\r\n#define gcd __gcd\r\n#define dump(...)\r\n#define dumpel(v)\r\n#define dump_list(v)\r\n#define dump_mat(v)\r\n#define input_from_file(f)\r\n#define output_to_file(f)\r\n#define Assert(b) { if (!(b)) while (1) cout << \"OLE\"; }\r\n#endif\r\n\r\n\r\n//\u3010mint \u2192 \u6709\u7406\u6570\u3011\uff08\u5b9f\u9a13\u7528\uff09\r\n/*\r\n* x \u3092\u5206\u6bcd\u3068\u5206\u5b50\u306e\u7d76\u5bfe\u5024\u304c v_max \u4ee5\u4e0b\u306e\u6709\u7406\u6570\u8868\u793a\u306b\u5909\u63db\u3059\u308b\uff08\u4e0d\u53ef\u80fd\u306a\u3089\u305d\u306e\u307e\u307e\uff09\r\n*/\r\nstring mint_to_frac(mint x, int v_max = 31595) {\r\n\t// verify : https://www.codechef.com/problems/SUMOVERALL\r\n\r\n\trepi(dnm, 1, v_max) {\r\n\t\tint num = (x * dnm).val();\r\n\t\tif (num == 0) {\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\tif (num <= v_max) {\r\n\t\t\tif (dnm == 1) return to_string(num);\r\n\t\t\treturn to_string(num) + \"/\" + to_string(dnm);\r\n\t\t}\r\n\t\tif (mint::mod() - num <= v_max) {\r\n\t\t\tif (dnm == 1) return \"-\" + to_string(mint::mod() - num);\r\n\t\t\treturn \"-\" + to_string(mint::mod() - num) + \"/\" + to_string(dnm);\r\n\t\t}\r\n\t}\r\n\r\n\treturn to_string(x.val());\r\n}\r\n\r\n\r\n//\u3010\u6709\u9650\u4f53 F_p \u4e0a\u306e\u8a08\u7b97\uff0832 bit\uff09\u3011\r\n#ifndef _MSC_VER\r\ntemplate <ll MOD> struct static_modint {\r\n\tll v;\r\n\r\n\t// \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\r\n\tstatic_modint() noexcept : v(0) {};\r\n\tstatic_modint(const static_modint& a) = default;\r\n\tstatic_modint(int a) noexcept : v(a% MOD) { if (v < 0) v += MOD; };\r\n\tstatic_modint(ll a) noexcept : v(a% MOD) { if (v < 0) v += MOD; };\r\n\r\n\t// \u4ee3\u5165\r\n\tstatic_modint& operator=(const static_modint& a) = default;\r\n\tstatic_modint& operator=(int a) { v = a % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator=(ll a) { v = a % MOD; if (v < 0) v += MOD; return *this; }\r\n\r\n\t// \u5165\u51fa\u529b\r\n\tfriend istream& operator>> (istream& is, static_modint& x) {\r\n\t\tis >> x.v; x.v %= MOD; if (x.v < 0) x.v += MOD; return is;\r\n\t}\r\n\tfriend ostream& operator<< (ostream& os, const static_modint& x) { os << x.v; return os; }\r\n\r\n\t// \u6bd4\u8f03\r\n\tbool operator==(const static_modint& b) const { return v == b.v; }\r\n\tbool operator==(int b) const { return (b - v) % MOD == 0; }\r\n\tbool operator==(ll b) const { return (b - v) % MOD == 0; }\r\n\tfriend bool operator==(int a, const static_modint& b) { return b == a; }\r\n\tfriend bool operator==(ll a, const static_modint& b) { return b == a; }\r\n\tbool operator!=(const static_modint& b) const { return v != b.v; }\r\n\tbool operator!=(int b) const { return !(*this == b); }\r\n\tbool operator!=(ll b) const { return !(*this == b); }\r\n\tfriend bool operator!=(int a, const static_modint& b) { return b != a; }\r\n\tfriend bool operator!=(ll a, const static_modint& b) { return b != a; }\r\n\r\n\t// \u5358\u9805\u6f14\u7b97\r\n\tstatic_modint operator-() const { static_modint a; if (v > 0) a.v = MOD - v; return a; }\r\n\tstatic_modint& operator++() { v++; if (v == MOD) v = 0; return *this; }\r\n\tstatic_modint operator++(int) { static_modint tmp = *this; ++(*this); return tmp; }\r\n\tstatic_modint& operator--() { v--; if (v == -1) v = MOD - 1; return *this; }\r\n\tstatic_modint operator--(int) { static_modint tmp = *this; --(*this); return tmp; }\r\n\r\n\t// \u4e8c\u9805\u6f14\u7b97\r\n\tstatic_modint& operator+=(const static_modint& b) { v += b.v; if (v >= MOD) v -= MOD; return *this; }\r\n\tstatic_modint& operator-=(const static_modint& b) { v -= b.v; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator*=(const static_modint& b) { v = (v * b.v) % MOD; return *this; }\r\n\tstatic_modint& operator/=(const static_modint& b) { *this *= b.inv(); return *this; }\r\n\tstatic_modint operator+(const static_modint& b) const { static_modint a = *this; return a += b; }\r\n\tstatic_modint operator-(const static_modint& b) const { static_modint a = *this; return a -= b; }\r\n\tstatic_modint operator*(const static_modint& b) const { static_modint a = *this; return a *= b; }\r\n\tstatic_modint operator/(const static_modint& b) const { static_modint a = *this; return a /= b; }\r\n\r\n\t// int \u3068\u306e\u6f14\u7b97\r\n\tstatic_modint& operator+=(int b) { v = (v + b) % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator-=(int b) { v = (v - b) % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator*=(int b) { v = (v * b) % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator/=(int b) { *this *= static_modint(b).inv(); return *this; }\r\n\tstatic_modint operator+(int b) const { static_modint a = *this; return a += b; }\r\n\tstatic_modint operator-(int b) const { static_modint a = *this; return a -= b; }\r\n\tstatic_modint operator*(int b) const { static_modint a = *this; return a *= b; }\r\n\tstatic_modint operator/(int b) const { static_modint a = *this; return a /= b; }\r\n\tfriend static_modint operator+(int a, const static_modint& b) { return b + a; }\r\n\tfriend static_modint operator-(int a, const static_modint& b) { return -(b - a); }\r\n\tfriend static_modint operator*(int a, const static_modint& b) { return b * a; }\r\n\tfriend static_modint operator/(int a, const static_modint& b) { return b.inv() * a; }\r\n\r\n\t// ll \u3068\u306e\u6f14\u7b97\r\n\tstatic_modint& operator+=(ll b) { v = (v + b) % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator-=(ll b) { v = (v - b) % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator*=(ll b) { v = (v * (b % MOD)) % MOD; if (v < 0) v += MOD; return *this; }\r\n\tstatic_modint& operator/=(ll b) { *this *= static_modint(b).inv(); return *this; }\r\n\tstatic_modint operator+(ll b) const { static_modint a = *this; return a += b; }\r\n\tstatic_modint operator-(ll b) const { static_modint a = *this; return a -= b; }\r\n\tstatic_modint operator*(ll b) const { static_modint a = *this; return a *= b; }\r\n\tstatic_modint operator/(ll b) const { static_modint a = *this; return a /= b; }\r\n\tfriend static_modint operator+(ll a, const static_modint& b) { return b + a; }\r\n\tfriend static_modint operator-(ll a, const static_modint& b) { return -(b - a); }\r\n\tfriend static_modint operator*(ll a, const static_modint& b) { return b * a; }\r\n\tfriend static_modint operator/(ll a, const static_modint& b) { return b.inv() * a; }\r\n\r\n\t// \u7d2f\u4e57\uff080^0 := 1\uff09\r\n\tstatic_modint pow(ll d) const {\r\n\t\tstatic_modint res(1), pow2 = *this;\r\n\t\twhile (d > 0) {\r\n\t\t\tif (d & 1) res *= pow2;\r\n\t\t\tpow2 *= pow2;\r\n\t\t\td >>= 1;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t// \u9006\u5143\uff080^(-1) \u306f\u672a\u5b9a\u7fa9\uff09\r\n\tstatic_modint inv() const { Assert(v != 0); return pow(MOD - 2); }\r\n\r\n\t// \u6cd5\u306e\u78ba\u8a8d\r\n\tstatic int mod() { return int(MOD); }\r\n\r\n\t// \u5024\u306e\u78ba\u8a8d\r\n\tint val() const { return int(v); }\r\n};\r\nusing mint = static_modint<1000000007>;\r\n//using mint = static_modint<998244353>;\r\nusing vm = vector<mint>; using vvm = vector<vm>; using vvvm = vector<vvm>;\r\n#endif\r\n\r\n\r\n//\u3010\u30d5\u30a7\u30cb\u30c3\u30af\u6728\uff08ACL \u4ed5\u69d8\uff09\u3011\r\n/*\r\n* fenwick_tree(n) : O(n)\r\n*\t\u8981\u7d20\u6570 n \u304b\u3064\u521d\u671f\u5024 0 \u3067\u521d\u671f\u5316\u3059\u308b\uff0e\r\n*\r\n* add(p, val) : O(log n)\r\n*\tv[p] \u306b val \u3092\u52a0\u7b97\u3059\u308b\uff0e\r\n*\r\n* sum(l, r) : O(log n)\r\n*\t\u534a\u958b\u533a\u9593 [l, r) \u306e\u8981\u7d20\u306e\u7dcf\u548c\u3092\u8fd4\u3059\uff0e\r\n*/\r\n#ifndef _MSC_VER\r\ntemplate <class T>\r\nstruct fenwick_tree {\r\n\t// verify : https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_6_A\r\n\r\n\tint n;\r\n\tvector<T> v;\r\n\r\n\tfenwick_tree() {}\r\n\tfenwick_tree(int n_) : n(n_ + 1), v(n) {}\r\n\tvoid add(int p, T val) {\r\n\t\tp++;\r\n\t\twhile (p < n) {\r\n\t\t\tv[p] += val;\r\n\t\t\tp += p & -p;\r\n\t\t}\r\n\t}\r\n\tT sum_sub(int r) const {\r\n\t\tT res = 0;\r\n\t\twhile (r > 0) {\r\n\t\t\tres += v[r];\r\n\t\t\tr -= r & -r;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\tT sum(int l, int r) const {\r\n\t\treturn sum_sub(r) - sum_sub(l);\r\n\t}\r\n\r\n#ifdef _MSC_VER\r\n\tfriend ostream& operator<<(ostream& os, const fenwick_tree& ft) {\r\n\t\trep(i, ft.n - 1) {\r\n\t\t\tos << ft.sum(i, i + 1) << \" \";\r\n\t\t}\r\n\t\treturn os;\r\n\t}\r\n#endif\r\n};\r\n#endif\r\n\r\n\r\nint main() {\r\n//\tinput_from_file(\"input.txt\");\r\n//\toutput_to_file(\"output.txt\");\r\n\r\n\tint n;\r\n\tcin >> n;\r\n\r\n\tvi p(n);\r\n\tcin >> p;\r\n\t--p;\r\n\r\n\t// rem[j] : \u6570 i \u304c\u6b8b\u3063\u3066\u3044\u308b\u304b\r\n\tvi rem(n, 1);\r\n\trep(i, n) if (p[i] != -2) rem[p[i]] = 0;\r\n\tdump(rem);\r\n\r\n\t// acc_rem[j] : \u6570 [0..j) \u306e\u4e2d\u306e\u6b8b\u3063\u3066\u3044\u308b\u3082\u306e\u306e\u500b\u6570\r\n\tvm acc_rem(n + 1);\r\n\trep(i, n) acc_rem[i + 1] = acc_rem[i] + rem[i];\r\n\tdump(acc_rem);\r\n\r\n\t// acc_open[i] : \u4f4d\u7f6e [0..i) \u306e\u4e2d\u306e\u7a7a\u304d\u306e\u500b\u6570\r\n\tvm acc_open(n + 1);\r\n\trep(i, n) acc_open[i + 1] = acc_open[i] + (int)(p[i] == -2);\r\n\tdump(acc_open);\r\n\r\n\t// K : \u7a7a\u304d\u306e\u500b\u6570\r\n\tmint K = acc_open[n];\r\n\tdump(K);\r\n\r\n\t// (-1, -1) \u304b\u3089\u306e\u5bc4\u4e0e\r\n\tmint res = K * (K - 1) / 2 / 2;\r\n\tdump(mint_to_frac(res));\r\n\t\r\n\tfenwick_tree<mint> FT(n);\r\n\trep(i, n) {\r\n\t\tif (p[i] != -2) {\r\n\t\t\t// (p[i], -1) \u304b\u3089\u306e\u5bc4\u4e0e\r\n\t\t\tif (K != 0) res += (acc_open[n] - acc_open[i]) * acc_rem[p[i]] / K;\r\n\t\t\tdump(mint_to_frac(res));\r\n\r\n\t\t\t// (-1, p[i]) \u304b\u3089\u306e\u5bc4\u4e0e\r\n\t\t\tif (K != 0) res += acc_open[i] * (acc_rem[n] - acc_rem[p[i]]) / K;\r\n\t\t\tdump(mint_to_frac(res));\r\n\r\n\t\t\t// (p[i2], p[i]) \u304b\u3089\u306e\u5bc4\u4e0e\r\n\t\t\tres += FT.sum(p[i], n);\r\n\t\t\tFT.add(p[i], 1);\r\n\t\t\tdump(mint_to_frac(res));\r\n\t\t}\r\n\t}\r\n\r\n\tcout << res << endl;\r\n}\r\n"
}