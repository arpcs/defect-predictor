{
    "id": 1480467,
    "contestId": 173,
    "creationTimeSeconds": 1333725077,
    "relativeTimeSeconds": 677,
    "problem": {
        "contestId": 173,
        "index": "A",
        "name": "Rock-Paper-Scissors",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1300,
        "tags": [
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 173,
        "members": [
            {
                "handle": "vanchope"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 17,
        "startTimeSeconds": 1333724400
    },
    "programmingLanguage": "Java 6",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 54,
    "timeConsumedMillis": 170,
    "memoryConsumedBytes": 64614400,
    "source": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\n\n/**\n * @author Ivan Pryvalov ([email\u00a0protected])\n *\n */\npublic class KROK_R1_A implements Runnable{\n\n\tprivate void solve() throws IOException {\n\t\tint n = scanner.nextInt(); // 2*10^9\n\t\tString s1 = scanner.nextToken(); // 1000\n\t\tString s2 = scanner.nextToken(); // 1000\n\t\t\n\t\tint m1 = s1.length();\n\t\tint m2 = s2.length();\n\t\tint common = m1 * m2;\n\t\tint[] total = new int[2];\n\t\tfor(int i=0; i<Math.min(common, n); i++){\n\t\t\tint[] res = game(s1.charAt(i%m1), s2.charAt(i%m2));\n\t\t\tadd(total, res);\n\t\t}\n\t\t\n\t\tint count = n / common;\n\t\tif (count > 0){\n\t\t\tmult(total, count);\n\t\t\tint rest = n%common;\n\t\t\tfor(int i=0; i<rest; i++){\n\t\t\t\tint[] res = game(s1.charAt(i%m1), s2.charAt(i%m2));\n\t\t\t\tadd(total, res);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tout.println(total[1]+\" \"+total[0]);\t\t\n\t}\n\n\tprivate void mult(int[] total, int count) {\n\t\tfor (int i = 0; i < total.length; i++) {\n\t\t\ttotal[i] *= count;\n\t\t}\n\t}\n\n\tprivate void add(int[] total, int[] res) {\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\ttotal[i] += res[i];\n\t\t}\n\t}\n\n\tprivate int[] game(char c1, char c2) {\n\t\tif (c1==c2)\n\t\t\treturn new int[]{0,0};\n\t\tif (c1=='R' && c2=='S' || c1=='S' && c2=='P' || c1=='P'&& c2=='R')\n\t\t\treturn new int[]{1,0};\n\t\treturn new int[]{0,1};\n\t}\n\n\t/////////////////////////////////////////////////\n\tfinal int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n\tfinal int INPUT_BUFFER_SIZE = 1024 * 1024 * 8 ;\n\tfinal int BUF_SIZE_INPUT = 1024;\n\t\n\tfinal int BUF_SIZE_OUT = 1024;\n\t\n\tboolean inputFromFile = false;\n\tString filenamePrefix = \"A-small-attempt0\";\n\tString inSuffix = \".in\";\n\tString outSuffix = \".out\";\n\t\n\t//InputStream bis;\n\t//OutputStream bos;\n\tPrintStream out;\n\tByteScanner scanner;\n\tByteWriter writer;\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry{\n\t\t\tInputStream bis = null;\n\t\t\tOutputStream bos = null;\n\t\t\t//PrintStream out = null;\n\t\t\tif (inputFromFile){\n\t\t\t\tFile baseFile = new File(getClass().getResource(\"/\").getFile());\n\t\t\t\tbis = new BufferedInputStream(\n\t\t\t\t\t\tnew FileInputStream(new File(\n\t\t\t\t\t\t\t\tbaseFile, filenamePrefix+inSuffix)),\n\t\t\t\t\t\t\t\tINPUT_BUFFER_SIZE);\n\t\t\t\tbos = new BufferedOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\n\t\t\t\t\t\t\t\tnew File(baseFile, filenamePrefix+outSuffix)));\n\t\t\t\tout = new PrintStream(bos);\n\t\t\t}else{\n\t\t\t\tbis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n\t\t\t\tbos = new BufferedOutputStream(System.out);\n\t\t\t\tout = new PrintStream(bos);\n\t\t\t}\n\t\t\tscanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\t\t\twriter = new ByteWriter(bos, BUF_SIZE_OUT);\n\t\t\t\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tpublic interface Constants{\n\t\tfinal static byte ZERO = '0';//48 or 0x30\n\t\tfinal static byte NINE = '9';\n\t\tfinal static byte SPACEBAR = ' '; //32 or 0x20\n\t\tfinal static byte MINUS = '-'; //45 or 0x2d\t\n\t\t\n\t\tfinal static char FLOAT_POINT = '.';\n\t}\n\t\n\tpublic static class EofException extends IOException{\n\t}\n\t\n\tpublic static class ByteWriter implements Constants {\n\t\t\n\t\tint bufSize = 1024;\n\t\tbyte[] byteBuf = new byte[bufSize];\n\t\tOutputStream os;\n\t\t\n\t\tpublic ByteWriter(OutputStream os, int bufSize){\n\t\t\tthis.os = os;\n\t\t\tthis.bufSize = bufSize;\n\t\t}\n\t\t\n\t\tpublic void writeInt(int num) throws IOException{\n\t         int byteWriteOffset = byteBuf.length;\n\t         if (num==0){\n\t        \t byteBuf[--byteWriteOffset] = ZERO;\n\t         }else{\n\t        \t int numAbs = Math.abs(num);\n\t        \t while (numAbs>0){\n\t        \t\t byteBuf[--byteWriteOffset] = (byte)((numAbs % 10) + ZERO);\n\t        \t\t numAbs /= 10;\n\t        \t }\n\t        \t if (num<0)\n\t        \t\t byteBuf[--byteWriteOffset] = MINUS;\n\t         }\n\t         os.write(byteBuf, byteWriteOffset, byteBuf.length - byteWriteOffset);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Please ensure ar.length <= byteBuf.length!\n\t\t * \n\t\t * @param ar\n\t\t * @throws IOException\n\t\t */\n\t\tpublic void writeByteAr(byte[] ar) throws IOException{\n\t\t\tfor (int i = 0; i < ar.length; i++) {\n\t\t\t\tbyteBuf[i] = ar[i];\n\t\t\t}\n\t\t\tos.write(byteBuf,0,ar.length);\n\t\t}\n\t\t\n\t\tpublic void writeSpaceBar() throws IOException{\n\t\t\tbyteBuf[0] = SPACEBAR;\n\t\t\tos.write(byteBuf,0,1);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static class ByteScanner implements Constants{\n\t\t\n\t\tInputStream is;\n\t\t\n\t\tpublic ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n\t\t\tthis.is = is;\n\t\t\tthis.bufSizeInput = bufSizeInput;\n\t\t\tthis.bufSize = bufSize;\n\t\t\t\n\t\t\tbyteBufInput = new byte[this.bufSizeInput];\n\t\t\tbyteBuf = new byte[this.bufSize];\n\t\t}\n\t\t\n\t\tpublic ByteScanner(byte[] data){\n\t\t\tbyteBufInput = data;\n\t\t\tbufSizeInput = data.length;\n\t\t\tbufSize = data.length;\n\t\t\tbyteBuf = new byte[bufSize];\n\t\t\tbyteRead = data.length;\n\t\t\tbytePos = 0;\n\t\t}\n\t\t\n\t\tprivate int bufSizeInput;\n\t\tprivate int bufSize;\n\t\t\n\t\tbyte[] byteBufInput;\n\t\tbyte by=-1;\n\t\tint byteRead=-1;\n\t\tint bytePos=-1;\n\n\t\tbyte[] byteBuf;\n\t\tint totalBytes;\n\t\t\n\t\tboolean eofMet = false;\n\t\t\n\t\tprivate byte nextByte() throws IOException{\n\t\t\t\n\t\t\tif (bytePos<0 || bytePos>=byteRead){\n\t\t\t\tbyteRead = is==null? -1: is.read(byteBufInput);\n\t\t\t\tbytePos=0;\n\t\t\t\tif (byteRead<0){\n\t\t\t\t\tbyteBufInput[bytePos]=-1;//!!!\n\t\t\t\t\tif (eofMet)\n\t\t\t\t\t\tthrow new EofException();\n\t\t\t\t\teofMet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn byteBufInput[bytePos++];\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns next meaningful character as a byte.<br>\n\t\t * \n\t\t * @return\n\t\t * @throws IOException\n\t\t */\n\t\tpublic byte nextChar() throws IOException{\n\t\t\twhile ((by=nextByte())<=0x20);\n\t\t\treturn by;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns next meaningful character OR space as a byte.<br>\n\t\t * \n\t\t * @return\n\t\t * @throws IOException\n\t\t */\n\t\tpublic byte nextCharOrSpacebar() throws IOException{\n\t\t\twhile ((by=nextByte())<0x20);\n\t\t\treturn by;\n\t\t}\n\t\t\n\t    /**\n\t     * Reads line.\n\t     * \n\t     * @return\n\t     * @throws IOException\n\t     */\n\t    public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n\t    }\n\t    \n\t    public byte[] nextLineAsArray() throws IOException {\n            readToken((byte)0x20);\n            byte[] out = new byte[totalBytes];\n            System.arraycopy(byteBuf, 0, out, 0, totalBytes);\n            return out;\n\t    }\n\t    \n\t\t\n\t    /**\n\t     * Reads token. Spacebar is separator char.\n\t     * \n\t     * @return\n\t     * @throws IOException\n\t     */\n\t    public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n\t    }\n\t    \n\t    /**\n\t     * Spacebar is included as separator char\n\t     * \n\t     * @throws IOException\n\t     */\n\t    private void readToken() throws IOException {\t    \t\n            readToken((byte)0x21);\n\t    }\n\t    \n\t    private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n\t    }\n\t\t\n\t    public int nextInt() throws IOException{\n\t\t\treadToken();\n\t\t\tint num=0, i=0;\n\t\t\tboolean sign=false;\n\t\t\tif (byteBuf[i]==MINUS){\n\t\t\t\tsign = true;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i<totalBytes; i++){\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=byteBuf[i]-ZERO;\n\t\t\t}\n\t\t\treturn sign?-num:num;\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\treadToken();\n\t\t\tlong num=0;\n\t\t\tint i=0;\n\t\t\tboolean sign=false;\n\t\t\tif (byteBuf[i]==MINUS){\n\t\t\t\tsign = true;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i<totalBytes; i++){\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=byteBuf[i]-ZERO;\n\t\t\t}\n\t\t\treturn sign?-num:num;\n\t\t}\n\t\t\n\t\t/*\n\t\t//TODO test Unix/Windows formats\n\t\tpublic void toNextLine() throws IOException{\n\t\t\twhile ((ch=nextChar())!='\\n');\n\t\t}\n\t\t*/\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\treadToken();\n\t\t\tchar[] token = new char[totalBytes];\n\t\t\tfor (int i = 0; i < totalBytes; i++) {\n\t\t\t\ttoken[i] = (char)byteBuf[i];\n\t\t\t}\n\t\t\treturn Double.parseDouble(new String(token));\n\t\t}\n\t    \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew KROK_R1_A().run();\n\t}\n\t\n}\n"
}