{
    "id": 172128162,
    "contestId": 1605,
    "creationTimeSeconds": 1663151945,
    "relativeTimeSeconds": 185,
    "problem": {
        "contestId": 1605,
        "index": "A",
        "name": "A.M. Deviation",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1605,
        "members": [
            {
                "handle": "freehandle"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1663151760
    },
    "programmingLanguage": "Java 17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 171,
    "memoryConsumedBytes": 0,
    "source": "import java.util.*;\r\nimport java.util.function.*;\r\nimport java.io.*;\r\n\r\n// you can compare with output.txt and expected out\r\npublic class Round754A {\t\r\n\tMyPrintWriter out;\r\n\tMyScanner in;\r\n\t\r\n//\tfinal static long FIXED_RANDOM;\r\n//\tstatic {\r\n//\t\tFIXED_RANDOM = System.currentTimeMillis();\r\n//\t}\r\n\tfinal static String IMPOSSIBLE = \"IMPOSSIBLE\";\r\n\tfinal static String POSSIBLE = \"POSSIBLE\";\r\n\tfinal static String YES = \"YES\";\r\n\tfinal static String NO = \"NO\";\r\n\t\r\n    private void initIO(boolean isFileIO) {\r\n        if (System.getProperty(\"ONLINE_JUDGE\") == null && isFileIO) {\r\n        \ttry{\r\n\t            in = new MyScanner(new FileInputStream(\"input.txt\"));\r\n\t            out = new MyPrintWriter(new FileOutputStream(\"output.txt\"));\r\n        \t}\r\n        \tcatch(FileNotFoundException e){\r\n        \t\te.printStackTrace();\r\n        \t}\r\n        }\r\n        else{\r\n    \t\tin = new MyScanner(System.in);\r\n    \t    out = new MyPrintWriter(new BufferedOutputStream(System.out));\r\n        }\r\n    }\r\n\t\r\n\tpublic static void main(String[] args){\r\n//\t\tScanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\r\n\r\n\t\t// the code for the deep recursion (more than 100k or 3~400k or so)\r\n\t\t// Thread t = new Thread(null, new RoundEdu130F(), \"threadName\", 1<<28);\r\n\t\t// t.start();\r\n\t\t// t.join();\r\n\t\t\r\n\t\tRound754A sol = new Round754A();\r\n\t\tsol.run();\r\n    }\r\n\t\r\n\tprivate void run() {\r\n\t\tboolean isDebug = false;\r\n\t\tboolean isFileIO = true;\r\n\t\tboolean hasMultipleTests = true;\r\n\t\t\r\n\t\tinitIO(isFileIO);\r\n\t\r\n\t\tint t = hasMultipleTests? in.nextInt() : 1;\r\n\t    \r\n\t    for (int i = 1; i <= t; ++i) {\r\n\t    \tif(isDebug){\r\n\t\t    \tout.printf(\"Test %d\\n\", i);\r\n\t    \t}\r\n\r\n\t    \tgetInput();\r\n\r\n\t    \tsolve();\r\n\t    \t\r\n\t    \tprintOutput();\r\n\t    }\r\n\t    \r\n\t    in.close();\r\n\t    out.close();\r\n\t}\r\n\t\r\n\t// use suitable one between matrix(2, n), matrix(n, 2), transposedMatrix(2, n) for graph edges, pairs, ...\r\n\tint a1, a2, a3;\r\n\tvoid getInput() {\r\n\t\ta1 = in.nextInt();\r\n\t\ta2 = in.nextInt();\r\n\t\ta3 = in.nextInt();\r\n\t}\r\n\t\r\n\tvoid printOutput() {\r\n\t\tout.printlnAns(ans);\r\n\t}\r\n\r\n\tint ans;\r\n\tvoid solve(){\r\n\t\tans = Math.abs((a1 + a3 - a2*2)%3);\r\n\t\t// a1 + a3 - 2a2 > 0\r\n\t\t// a1--, a2++ -> -3\r\n\t\t\r\n\t\t// a1 = 1, a3 = 1, a2 = 0\r\n\t\t\r\n\t\t// a1 + a3 - 2a2 < 0\r\n\t}\r\n\t \r\n//\tOptional<T> solve()\r\n//\treturn Optional.empty();\r\n\t\r\n\tstatic class Pair implements Comparable<Pair>{\r\n\t\tfinal static long FIXED_RANDOM = System.currentTimeMillis();\r\n\t\tint first, second;\r\n\t\tpublic Pair(int first, int second) {\r\n\t\t\tthis.first = first;\r\n\t\t\tthis.second = second;\r\n\t\t}\r\n\t\t\r\n\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\t// http://xorshift.di.unimi.it/splitmix64.c\r\n\t\t\tlong x = first;\r\n\t\t\tx <<= 32;\r\n\t\t\tx += second;\r\n\t\t\tx += FIXED_RANDOM;\r\n\t\t\tx += 0x9e3779b97f4a7c15l;\r\n\t\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9l;\r\n\t\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111ebl;\r\n\t\t\treturn (int)(x ^ (x >> 31));\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n//\t\t\tif (this == obj)\r\n//\t\t\t\treturn true;\r\n//\t\t\tif (obj == null)\r\n//\t\t\t\treturn false;\r\n//\t\t\tif (getClass() != obj.getClass())\r\n//\t\t\t\treturn false;\r\n\t\t\tPair other = (Pair) obj;\r\n\t\t\treturn first == other.first && second == other.second;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn \"[\" + first + \",\" + second + \"]\";\r\n\t\t}\r\n\r\n\r\n\t\t@Override\r\n\t\tpublic int compareTo(Pair o) {\r\n\t\t\tint cmp = Integer.compare(first, o.first);\r\n\t\t\treturn cmp != 0? cmp: Integer.compare(second, o.second);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static class MyScanner {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\t// 32768?\r\n\t\tpublic MyScanner(InputStream is, int bufferSize) {\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(is), bufferSize);\r\n\t\t}\r\n\t\t\r\n\t\tpublic MyScanner(InputStream is) {\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\r\n\t\t\t// br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\t// br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\r\n\t\t}\r\n\r\n\t\tpublic void close() {\r\n\t\t\ttry {\r\n\t\t\t\tbr.close();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tString next() {\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n\r\n\t\tlong nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\r\n\t\tdouble nextDouble() {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tString nextLine(){\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t\t\r\n\t\tint[][] nextMatrix(int n, int m) {\r\n\t\t\treturn nextMatrix(n, m, 0);\r\n\t\t}\r\n\t\t\r\n\t\tint[][] nextMatrix(int n, int m, int offset) {\r\n\t\t\tint[][] mat = new int[n][m];\r\n\t\t\tfor(int i=0; i<n; i++) {\r\n\t\t\t\tfor(int j=0; j<m; j++) {\r\n\t\t\t\t\tmat[i][j] = nextInt()+offset;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn mat;\r\n\t\t}\r\n\t\t\r\n\t\tint[][] nextTransposedMatrix(int n, int m){\r\n\t\t\treturn nextTransposedMatrix(n, m, 0);\r\n\t\t}\r\n\t\t\r\n\t\tint[][] nextTransposedMatrix(int n, int m, int offset){\r\n\t\t\tint[][] mat = new int[m][n];\r\n\t\t\tfor(int i=0; i<n; i++) {\r\n\t\t\t\tfor(int j=0; j<m; j++) {\r\n\t\t\t\t\tmat[j][i] = nextInt()+offset;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn mat;\r\n\t\t}\r\n\t\t\r\n\t\tint[] nextIntArray(int len) {\r\n\t\t\treturn nextIntArray(len, 0);\r\n\t\t}\r\n\t\tint[] nextIntArray(int len, int offset){\r\n\t    \tint[] a = new int[len];\r\n\t\t\tfor(int j=0; j<len; j++)\r\n\t    \t\ta[j] = nextInt()+offset;\r\n\t    \treturn a;\r\n\t\t}\r\n\t\t\r\n\t\tlong[] nextLongArray(int len) {\r\n\t\t\treturn nextLongArray(len, 0);\r\n\t\t}\r\n\t\tlong[] nextLongArray(int len, int offset){\r\n\t    \tlong[] a = new long[len];\r\n\t\t\tfor(int j=0; j<len; j++)\r\n\t    \t\ta[j] = nextLong()+offset;\r\n\t    \treturn a;\r\n\t\t}\r\n\t\t\r\n\t\tString[] nextStringArray(int len) {\r\n\t\t\tString[] s = new String[len];\r\n\t\t\tfor(int i=0; i<len; i++)\r\n\t\t\t\ts[i] = next();\r\n\t\t\treturn s;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static class MyPrintWriter extends PrintWriter{\r\n\t\tpublic MyPrintWriter(OutputStream os) {\r\n\t\t\tsuper(os);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic <T> void printlnAns(Optional<T> ans) {\r\n//\t\t\tif(ans.isEmpty())\r\n//\t\t\t\tprintln(-1);\r\n//\t\t\telse\r\n//\t\t\t\tprintlnAns(ans.get());\r\n//\t\t}\r\n\t\t\r\n\t\tpublic void printlnAns(OptionalInt ans) {\r\n\t\t\tprintln(ans.orElse(-1));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printlnAns(long ans) {\r\n\t\t\tprintln(ans);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printlnAns(int ans) {\r\n\t\t\tprintln(ans);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printlnAns(boolean ans) {\r\n\t\t\tif(ans)\r\n\t\t\t\tprintln(YES);\r\n\t\t\telse\r\n\t\t\t\tprintln(NO);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printAns(long[] arr){\r\n\t\t\tif(arr != null && arr.length > 0){\r\n\t\t\t\tprint(arr[0]);\r\n\t\t\t\tfor(int i=1; i<arr.length; i++){\r\n\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\tprint(arr[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tpublic void printlnAns(long[] arr){\r\n\t\t\tprintAns(arr);\r\n\t\t\tprintln();\r\n\t\t}\r\n\r\n\t\tpublic void printAns(int[] arr){\r\n\t\t\tif(arr != null && arr.length > 0){\r\n\t\t\t\tprint(arr[0]);\r\n\t\t\t\tfor(int i=1; i<arr.length; i++){\r\n\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\tprint(arr[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tpublic void printlnAns(int[] arr){\r\n\t\t\tprintAns(arr);\r\n\t\t\tprintln();\r\n\t\t}\r\n\t\t\r\n\t\tpublic <T> void printAns(ArrayList<T> arr){\r\n\t\t\tif(arr != null && arr.size() > 0){\r\n\t\t\t\tprint(arr.get(0));\r\n\t\t\t\tfor(int i=1; i<arr.size(); i++){\r\n\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\tprint(arr.get(i));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tpublic <T> void printlnAns(ArrayList<T> arr){\r\n\t\t\tprintAns(arr);\r\n\t\t\tprintln();\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printAns(int[] arr, int add){\r\n\t\t\tif(arr != null && arr.length > 0){\r\n\t\t\t\tprint(arr[0]+add);\r\n\t\t\t\tfor(int i=1; i<arr.length; i++){\r\n\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\tprint(arr[i]+add);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tpublic void printlnAns(int[] arr, int add){\r\n\t\t\tprintAns(arr, add);\r\n\t\t\tprintln();\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printAns(ArrayList<Integer> arr, int add) {\r\n\t\t\tif(arr != null && arr.size() > 0){\r\n\t\t\t\tprint(arr.get(0)+add);\r\n\t\t\t\tfor(int i=1; i<arr.size(); i++){\r\n\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\tprint(arr.get(i)+add);\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printlnAns(ArrayList<Integer> arr, int add){\r\n\t\t\tprintAns(arr, add);\r\n\t\t\tprintln();\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printlnAnsSplit(long[] arr, int split){\r\n\t\t\tif(arr != null){\r\n\t\t\t\tfor(int i=0; i<arr.length; i+=split){\r\n\t\t\t\t\tprint(arr[i]);\r\n\t\t\t\t\tfor(int j=i+1; j<i+split; j++){\r\n\t\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\t\tprint(arr[j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintln();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic void printlnAnsSplit(int[] arr, int split){\r\n\t\t\tif(arr != null){\r\n\t\t\t\tfor(int i=0; i<arr.length; i+=split){\r\n\t\t\t\t\tprint(arr[i]);\r\n\t\t\t\t\tfor(int j=i+1; j<i+split; j++){\r\n\t\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\t\tprint(arr[j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintln();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic <T> void printlnAnsSplit(ArrayList<T> arr, int split){\r\n\t\t\tif(arr != null && !arr.isEmpty()){\r\n\t\t\t\tfor(int i=0; i<arr.size(); i+=split){\r\n\t\t\t\t\tprint(arr.get(i));\r\n\t\t\t\t\tfor(int j=i+1; j<i+split; j++){\r\n\t\t\t\t\t\tprint(\" \");\r\n\t\t\t\t\t\tprint(arr.get(j));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintln();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic private void permutateAndSort(long[] a) {\r\n\t\tint n = a.length;\r\n\t\tRandom R = new Random(System.currentTimeMillis());\r\n\t\tfor(int i=0; i<n; i++) {\r\n\t\t\tint t = R.nextInt(n-i);\r\n\t\t\tlong temp = a[n-1-i];\r\n\t\t\ta[n-1-i] = a[t];\r\n\t\t\ta[t] = temp;\r\n\t\t}\r\n\t\tArrays.sort(a);\t\t\r\n\t}\r\n\t\r\n\tstatic private void permutateAndSort(int[] a) {\r\n\t\tint n = a.length;\r\n\t\tRandom R = new Random(System.currentTimeMillis());\r\n\t\tfor(int i=0; i<n; i++) {\r\n\t\t\tint t = R.nextInt(n-i);\r\n\t\t\tint temp = a[n-1-i];\r\n\t\t\ta[n-1-i] = a[t];\r\n\t\t\ta[t] = temp;\r\n\t\t}\r\n\t\tArrays.sort(a);\r\n\t}\r\n\t\r\n\tstatic private int[][] constructChildren(int n, int[] parent, int parentRoot){\r\n\t\tint[][] childrens = new int[n][];\r\n\t\t\r\n\t\tint[] numChildren = new int[n];\r\n\t\tfor(int i=0; i<parent.length; i++) {\r\n\t\t\tif(parent[i] != parentRoot)\r\n\t\t\t\tnumChildren[parent[i]]++;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<n; i++) {\r\n\t\t\tchildrens[i] = new int[numChildren[i]];\r\n\t\t}\r\n\t\t\r\n\r\n\t\tint[] idx = new int[n];\r\n\t\tfor(int i=0; i<parent.length; i++) {\r\n\t\t\tif(parent[i] != parentRoot)\r\n\t\t\t\tchildrens[parent[i]][idx[parent[i]]++] = i;\r\n\t\t}\r\n\r\n\t\treturn childrens;\r\n\t}\r\n\t\r\n\tstatic private int[][][] constructDirectedNeighborhood(int n, int[][] e){\r\n\t\tint[] inDegree = new int[n];\r\n\t\tint[] outDegree = new int[n];\r\n\t\tfor(int i=0; i<e.length; i++) {\r\n\t\t\tint u = e[i][0];\r\n\t\t\tint v = e[i][1];\r\n\t\t\toutDegree[u]++;\r\n\t\t\tinDegree[v]++;\r\n\t\t}\r\n\t\t\r\n\t\tint[][] inNeighbors = new int[n][];\r\n\t\tint[][] outNeighbors = new int[n][];\r\n\t\tfor(int i=0; i<n; i++) {\r\n\t\t\tinNeighbors[i] = new int[inDegree[i]];\r\n\t\t\toutNeighbors[i] = new int[outDegree[i]];\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<e.length; i++) {\r\n\t\t\tint u = e[i][0];\r\n\t\t\tint v = e[i][1];\r\n\t\t\toutNeighbors[u][--outDegree[u]] = v;\r\n\t\t\tinNeighbors[v][--inDegree[v]] = u;\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[][][] {inNeighbors, outNeighbors};\r\n\t}\r\n\t\r\n\tstatic private int[][] constructNeighborhood(int n, int[][] e) {\r\n\t\tint[] degree = new int[n];\r\n\t\tfor(int i=0; i<e.length; i++) {\r\n\t\t\tint u = e[i][0];\r\n\t\t\tint v = e[i][1];\r\n\t\t\tdegree[u]++;\r\n\t\t\tdegree[v]++;\r\n\t\t}\r\n\t\t\r\n\t\tint[][] neighbors = new int[n][];\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t\tneighbors[i] = new int[degree[i]];\r\n\t\t\r\n\t\tfor(int i=0; i<e.length; i++) {\r\n\t\t\tint u = e[i][0];\r\n\t\t\tint v = e[i][1];\r\n\t\t\tneighbors[u][--degree[u]] = v;\r\n\t\t\tneighbors[v][--degree[v]] = u;\r\n\t\t}\r\n\t\t\r\n\t\treturn neighbors;\r\n\t}\r\n\t\r\n\tstatic private void drawGraph(int[][] e) {\r\n\t\tmakeDotUndirected(e);\r\n\t\ttry {\r\n\t\t\tfinal Process process = new ProcessBuilder(\"dot\", \"-Tpng\", \"graph.dot\")\r\n\t\t\t\t\t.redirectOutput(new File(\"graph.png\"))\r\n\t\t\t\t\t.start();\r\n\t\t} catch (IOException e1) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te1.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic private void makeDotUndirected(int[][] e) {\r\n\t\tMyPrintWriter out2 = null;\r\n\t\t try {\r\n\t\t\tout2 = new MyPrintWriter(new FileOutputStream(\"graph.dot\"));\r\n\t\t} catch (FileNotFoundException e1) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te1.printStackTrace();\r\n\t\t}\r\n\t\tout2.println(\"strict graph {\");\r\n\t\tfor(int i=0; i<e.length; i++){\r\n\t\t\tout2.println(e[i][0] + \"--\" + e[i][1] + \";\");\r\n\t\t}\r\n\t\tout2.println(\"}\");\r\n\t\tout2.close();\r\n\t}\r\n\t\r\n\tstatic private void makeDotDirected(int[][] e) {\r\n\t\tMyPrintWriter out2 = null;\r\n\t\t try {\r\n\t\t\tout2 = new MyPrintWriter(new FileOutputStream(\"graph.dot\"));\r\n\t\t} catch (FileNotFoundException e1) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te1.printStackTrace();\r\n\t\t}\r\n\t\tout2.println(\"strict digraph {\");\r\n\t\tfor(int i=0; i<e.length; i++){\r\n\t\t\tout2.println(e[i][0] + \"->\" + e[i][1] + \";\");\r\n\t\t}\r\n\t\tout2.println(\"}\");\r\n\t\tout2.close();\r\n\t}\r\n\t\r\n}\r\n"
}