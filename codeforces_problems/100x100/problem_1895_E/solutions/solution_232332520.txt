{
    "id": 232332520,
    "contestId": 1895,
    "creationTimeSeconds": 1699685835,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1895,
        "index": "E",
        "name": "Infinite Card Game",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "games",
            "graphs",
            "greedy",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1895,
        "members": [
            {
                "handle": "vaal"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1699022100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 296,
    "memoryConsumedBytes": 1228800,
    "source": "// templates.txt, glossary.txt\r\n// go to the end to view the (correct)soln\r\n#pragma GCC optimize(\"O2\")\r\n#include<bits/stdc++.h>\r\n// #include \"atcoder/lazysegtree.hpp\"\r\n// #include\"atcoder/modint.hpp\"\r\nusing namespace std;\r\n// using namespace atcoder;    \r\n#include \"ext/pb_ds/assoc_container.hpp\"\r\n#include \"ext/pb_ds/tree_policy.hpp\"\r\nusing namespace __gnu_pbds;  // refer pbds.cpp for details\r\n#define int long long // use unsigned long long if long long isnt enough (the domain is only whole nos though) (the shorthand is ull)\r\n#define ordered_set tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update>\r\n#define deb(x) cout << #x << \" \" << x << endl;\r\n// cout << #x << \" \" << x << endl;\r\n#define deb1(x) cout << #x << \" \";\r\n// cout << #x << \" \" << x << endl;\r\n#define pi pair<int, int>\r\n#define pd pair<double, double>\r\n#define TxtIO freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);  \r\n#define vpi vector<pi>\r\n#define vs vector<string>\r\n#define vvs vector<vs>\r\n#define vc vector<char>\r\n#define vvc vector<vc>\r\n#define vvvc vector<vvc>\r\n#define vb vector<bool>\r\n#define vvb vector<vb>\r\n#define vvvb vector<vvb>\r\n#define VI vector<int_fast32_t>\r\n#define VVI vector<VI>\r\n#define VVVI vector<VVI>\r\n#define vi vector<int>\r\n#define vvi vector<vi>\r\n#define vvvi vector<vvi>\r\n#define vd vector<double>\r\n#define vvd vector<vd>\r\n#define umap unordered_map\r\n#define uset unordered_set\r\n#define chash custom_hash \r\n#define pq priority_queue\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define ins insert\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define all(a)                          ::begin(a),::end(a)\r\n#define sz(X) (int)((X).size())\r\n#define EACH(x, a) for(auto &x:a)\r\n#define nl '\\n'\r\n#define Fo(i, n) for(int i=0; i<n; i++)\r\n#define fo(i, a, b) for(int i=a; i<b; i++)  \r\n#define REP(i,n) for(int _n=n, i=0;i<_n;++i)\r\n#define FOR(i,a,b) for(int i=(a),_b=(b);i<_b;++i)\r\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)\r\n// using mint=modint998244353;   // in atcoder template (modint.hpp)\r\n// using mvec=vector<mint>;\r\n// using mmat=vector<mvec>;\r\n\r\nconst int MOD=1000000007;\r\nint inf=1e18;\r\n// const int MOD=21945;\r\n// const int MOD=998244353;\r\nchar A=65, Z=90, lowerA=97, lowerZ=122;\r\nstring YES=\"Yes\", NO=\"No\";\r\nconst double PI=3.14159265358979323846;\r\nconst double epsilon=1e-9;\r\nstruct custom_hash {\r\n    // use it like this : umap<int, int, chash> mapp;\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        x+=0x9e3779b97f4a7c15;\r\n        x=(x^(x>>30))*0xbf58476d1ce4e5b9;\r\n        x=(x^(x>>27))*0x94d049bb133111eb;\r\n        return x^(x>>31); \\\r\n    }\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x+FIXED_RANDOM);\r\n    }\r\n};\r\n\r\ntemplate<class T> bool ckmin(T& a, const T& b) { return b<a ? a=b, 1 : 0; }\r\ntemplate<class T> bool ckmax(T& a, const T& b) { return a<b ? a=b, 1 : 0; }\r\n\r\ntemplate<class A> void read(vector<A>& v);\r\ntemplate<class A, size_t S> void read(array<A, S>& a);\r\ntemplate<class T> void read(T& x) { cin >> x; }\r\nvoid read(double& d) {\r\n    string t;  \r\n    read(t);\r\n    d=stod(t);\r\n}\r\nvoid read(long double& d) {\r\n    string t;\r\n    read(t);\r\n    d=stold(t);\r\n}\r\ntemplate<class H, class... T> void read(H& h, T&... t) {\r\n    read(h);\r\n    read(t...);\r\n}\r\ntemplate<class A> void read(vector<A>& x) { EACH(a, x) read(a); }\r\ntemplate<class A, size_t S> void read(array<A, S>& x) { EACH(a, x) read(a); }\r\n// template<typename... T>\r\n// void write(T&&... args) {\r\n//     ((cout << args << \" \"), ...);\r\n// }  // eg : write(x, y, z, \"im a good boi\", 4.5, 6);\r\n\r\ntemplate<typename T>\r\nbool f(T x, T y) { return x>y; }  // sort a vector in reverse manner : sort(all(vec), f<int>);\r\n\r\ntemplate<typename A, typename B>\r\nint count(A vec, B ele, bool isSorted) {\r\n    if(isSorted) {\r\n        auto it1=upper_bound(vec.begin(), vec.end(), ele);\r\n        auto it2=lower_bound(vec.begin(), vec.end(), ele); // kamala\r\n        return it1-it2;\r\n    }\r\n    return count(vec.begin(), vec.end(), ele);\r\n}\r\n\r\ntemplate <typename A> \r\nA myMax(A a,A b) {\r\n    if(a>b) return a;\r\n    return b;   \r\n}\r\ntemplate <typename A, typename ... Args>\r\nA myMax(A a, A b, Args ...args) { return myMax(myMax(a,b), args...); }\r\n\r\ntemplate <typename A> \r\nA myMin(A a, A b) {  \r\n    if(a<b) return a;\r\n    return b;\r\n}\r\ntemplate <typename A, typename ... Args>\r\nA myMin(A a, A b, Args ...args) { return myMin(myMin(a, b), args...); }\r\n\r\nstring to_string(char c) { return string(1, c); }\r\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\r\n\r\ntemplate <typename A>\r\nvoid printArray(A v) {\r\n    for(auto ele : v) cout << ele << ' ';\r\n    cout << nl;\r\n}\r\n\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nint rnd(int a, int b) {\r\n    if(a>b) return -1;\r\n    return a+(int)rng()%(b-a+1);\r\n}\r\n\r\nint query(int l) { \r\n    cout << \"? \" << l << endl;\r\n    return 0;\r\n}   \r\nvoid print_ans() {\r\n    cout << \"! \";\r\n}   \r\n\r\nvi solve() {\r\n    // 1136\r\n    int n, m; read(n);\r\n    vi a1(n), d1(n);\r\n    read(a1,d1);\r\n    read(m);\r\n    vi a2(m), d2(m);\r\n    read(a2,d2);\r\n\r\n    vvi a,b;\r\n    fo(i,0,n) a.pb({a1[i], d1[i]});\r\n    fo(i,0,m) b.pb({a2[i], d2[i]});\r\n    sort(all(a));\r\n    sort(all(b));\r\n    vvi sf1(n+1, vi{0, -1}), sf2(m+1, vi{0, -1});\r\n    for(int i=n-1; i>=0; --i) {\r\n        int curr=a[i][0];\r\n        if(curr>sf1[i+1][0]) {\r\n            sf1[i]=vi{curr, i};\r\n        } else sf1[i]=sf1[i+1];\r\n    }   \r\n    for(int i=m-1; i>=0; --i) {\r\n        int curr=b[i][0];\r\n        if(curr>sf2[i+1][0]) {\r\n            sf2[i]=vi{curr, i};\r\n        } else sf2[i]=sf2[i+1];\r\n    }   \r\n    sort(all(a1));\r\n    sort(all(d1));\r\n    sort(all(a2));\r\n    sort(all(d2));\r\n    int one, two, tree;\r\n    one=two=tree=0;\r\n    vi v(n+m,-1);  //m\r\n    vvi ad(n+m);\r\n    vi deg(n+m,0);\r\n    vi par(n+m,-1);\r\n\r\n    fo(i,0,n) {\r\n        int attack=a[i][0], defence=a[i][1];\r\n\r\n        // find largest defence d2[j] that attacks this (a2[j] > defence)\r\n        int mxat=b.back()[0]; // max attack possible\r\n        if(mxat>defence) {\r\n            deg[i]++;\r\n            int ind=ub(all(a2), defence)-begin(a2);\r\n            int mxdind=sf2[ind][1];\r\n            ad[i].pb(mxdind+n);\r\n            par[mxdind+n]=i;\r\n        }\r\n    }\r\n\r\n    fo(i,0,m) {\r\n        int attack=b[i][0], defence=b[i][1];\r\n\r\n        // find largest defence d2[j] that attacks this (a2[j] > defence)\r\n        int mxat=a.back()[0]; // max attack possible\r\n        if(mxat>defence) {\r\n            deg[n+i]++;\r\n            int ind=ub(all(a1), defence)-begin(a1);\r\n            int mxdind=sf1[ind][1];\r\n            ad[n+i].pb(mxdind);\r\n            par[mxdind]=n+i;\r\n        }\r\n    }\r\n    // cout << nl;\r\n    // fo(i,0,n+m) printArray(ad[i]);\r\n    // cout << nl;\r\n    \r\n\r\n    vb vis(n+m,false);\r\n    fo(i,-0,n+m) {\r\n        if(!vis[i]&&deg[i]==0) {\r\n            int j=i;\r\n            int parity=(i>=n);  //m\r\n            while(!vis[j]) {\r\n                if(parity) {\r\n                    tree++;\r\n                } else {\r\n                    one++;\r\n                }\r\n                vis[j]=true;\r\n                j=par[j];\r\n                if(j==-1) break;\r\n            }\r\n        }\r\n    }\r\n    two=n-(one+tree);\r\n    return vi{one, two, tree};\r\n}\r\n\r\nvoid main_() {\r\n    // TxtIO;\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout << setprecision(15) << fixed;\r\n    int TT=1; \r\n    read(TT);\r\n    while(TT--) {\r\n        // cf: 900, atc: 2200(2600), cc: 100\r\n        // sh run(as admin)\r\n        \r\n        printArray(solve());\r\n    } \r\n\r\n}\r\n\r\nstatic void run_with_stack_size(void (*func)(void), size_t stsize) {\r\n    // uncomment all the lines for MHC\r\n    // char *stack, *send;\r\n    // stack = (char *)malloc(stsize);\r\n    // send = stack + stsize - 16;\r\n    // send = (char *)((uintptr_t)send / 16 * 16);\r\n    // asm volatile(\r\n    //     \"mov %%rsp, (%0)\\n\"\r\n    //     \"mov %0, %%rsp\\n\"\r\n    //     :\r\n    //     : \"r\"(send));\r\n    func();\r\n    // asm volatile(\"mov (%0), %%rsp\\n\" : : \"r\"(send));\r\n    // free(stack);\r\n}\r\n\r\nint32_t main() {\r\n    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack\r\n    return 0;\r\n}\r\n// templates.txt\r\n// initialize everything\r\n// brk n continue n return, 1ll<<bt\r\n// gotchaaaaaaaaaa:\r\n// run the corect file in the terminal and type code in the correct file\r\n// print YES/NO correctly\r\n// check -ve indices\r\n// dont call solve() twice\r\n// exit(0) not exit(1)\r\n// dont put v[i]=ele instead of ele=v[i] bruh\r\n// dont forget to take MOD\r\n// check time complexity of problem A since pretests are weak\r\n// if using next_permutation(), store the resultant permutations in a separate data structure, and iterate through that structure\r\n\r\n// pypy gotchaa\r\n// if the code exceeds the maximum value for a number (eg while taking product), then it might result in TLE\r\n"
}