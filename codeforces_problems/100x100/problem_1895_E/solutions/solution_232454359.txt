{
    "id": 232454359,
    "contestId": 1895,
    "creationTimeSeconds": 1699762560,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1895,
        "index": "E",
        "name": "Infinite Card Game",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "games",
            "graphs",
            "greedy",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1895,
        "members": [
            {
                "handle": "prituladima"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1699022100
    },
    "programmingLanguage": "Java 17",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 265,
    "memoryConsumedBytes": 1126400,
    "source": "import org.w3c.dom.ls.LSOutput;\r\n\r\nimport java.io.*;\r\nimport java.text.MessageFormat;\r\nimport java.util.*;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Predicate;\r\n\r\npublic class E {\r\n\r\n    Map<String, Object> PARAM = new HashMap<String, Object>() {\r\n        {\r\n            put(\"nameIn\", \"input.txt\");\r\n            put(\"nameOut\", \"output.txt\");\r\n            put(\"io\", INPUT_OUTPUT.SYSTEM_IO);\r\n            put(\"stress_test\", false);\r\n            put(\"simulation\", false);\r\n            put(\"random\", new Random(42));\r\n        }\r\n\r\n    };\r\n    final String nameIn = E.class.getSimpleName() + \".in\";\r\n    final String nameOut = E.class.getSimpleName() + \".out\";\r\n\r\n    final boolean LOCAL_DEBUG = false;\r\n    final INPUT_OUTPUT io = INPUT_OUTPUT.SYSTEM_IO;\r\n    final boolean ANTI_TEST_FINDER_MODE = false;\r\n    final boolean SIMULATION = false;\r\n    final Random random = new Random(42);\r\n\r\n    final int MAXV = (int) 3e6 + 1;\r\n\r\n    private int solveOne(int testCase) {\r\n        int n = nextInt();\r\n        int[] ax = nextIntArr(n);\r\n        int[] ay = nextIntArr(n);\r\n        sort(ax, ay, n);\r\n        int[] aMaxPref = new int[n];\r\n        aMaxPref[0] = ax[0];\r\n        for (int i = 1; i < n; i++) {\r\n            aMaxPref[i] = Math.max(aMaxPref[i - 1], ax[i]);\r\n        }\r\n        int[] aMaxSuff = new int[n + 1];\r\n        aMaxSuff[n - 1] = ax[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            aMaxSuff[i] = Math.max(aMaxSuff[i + 1], ax[i]);\r\n        }\r\n\r\n        int m = nextInt();\r\n        int[] bx = nextIntArr(m);\r\n        int[] by = nextIntArr(m);\r\n        sort(bx, by, m);\r\n        int[] bMaxPref = new int[m];\r\n        int[] bMaxSuff = new int[m + 1];\r\n\r\n        bMaxPref[0] = bx[0];\r\n        for (int i = 1; i < m; i++) {\r\n            bMaxPref[i] = Math.max(bMaxPref[i - 1], bx[i]);\r\n        }\r\n\r\n        bMaxSuff[m - 1] = bx[m - 1];\r\n        for (int i = m - 2; i >= 0; i--) {\r\n            bMaxSuff[i] = Math.max(bMaxSuff[i + 1], bx[i]);\r\n        }\r\n\r\n        boolean[] used = new boolean[n];\r\n\r\n        int startsThatWin = 0;\r\n        {\r\n            int i = n;\r\n            int j = 0;\r\n            //int less = bMaxSuff[j];\r\n\r\n            while (true) {\r\n                int maxAttack = 0;\r\n\r\n                while (true) {\r\n                    if (i - 1 >= 0 && bMaxSuff[j] <= ay[i - 1]) {\r\n                        i--;\r\n                        startsThatWin++;\r\n                        assertThat(!used[i], \"must be false\");\r\n                        used[i] = true;\r\n                        if (maxAttack < ax[i]) {\r\n                            maxAttack = ax[i];\r\n                        }\r\n                    } else break;\r\n                }\r\n\r\n                if (maxAttack == 0) {\r\n                    break;\r\n                }\r\n\r\n                int maxAttackFinal = maxAttack;\r\n                j = lowerBound(-1, m, jj -> maxAttackFinal <= by[jj]);\r\n                if (j == 0)\r\n                    break;\r\n\r\n                if (bMaxPref[j - 1] <= bMaxSuff[j])\r\n                    break;\r\n\r\n                //less = bMaxSuff[j];\r\n            }\r\n\r\n        }\r\n\r\n\r\n        int startsThatLose = 0;\r\n//        if (false)\r\n        {\r\n            int max;\r\n            {\r\n                int i = m;\r\n                int maxAttack = 0;\r\n                while (true) {\r\n                    if (i - 1 >= 0 && aMaxSuff[0] <= by[i - 1]) {\r\n                        i--;\r\n                        if (maxAttack < bx[i]) {\r\n                            maxAttack = bx[i];\r\n                        }\r\n                    } else break;\r\n                }\r\n                max = maxAttack;\r\n            }\r\n\r\n            if (max != 0) {\r\n                int i = -1;\r\n                int j = 0;\r\n                //int max = Integer.MAX_VALUE;\r\n\r\n                step:\r\n                while (true) {\r\n                    int maxAttack = 0;\r\n\r\n                    while (true) {\r\n                        if (i + 1 < n && ay[i + 1] < max) {\r\n                            i++;\r\n                            startsThatLose++;\r\n                            if (used[i])\r\n                                assertThat(!used[i], \"must be false \"\r\n                                        + Arrays.toString(ax) + \" - \\n\" + Arrays.toString(ay) + \"  - \\n\"\r\n                                        + Arrays.toString(bx) + \" - \\n\" + Arrays.toString(by) + \"  - \\n\"\r\n                                );\r\n\r\n                            used[i] = true;\r\n                            if (maxAttack < ax[i]) {\r\n                                maxAttack = ax[i];\r\n                            }\r\n                        } else break;\r\n                    }\r\n\r\n\r\n                    if (maxAttack == 0) {\r\n                        break;\r\n                    }\r\n\r\n                    int maxAttack_ = maxAttack;\r\n                    j = lowerBound(-1, m, jj -> maxAttack_ <= by[jj]);\r\n\r\n                    if (j == 0)\r\n                        break;\r\n\r\n                    if (bMaxPref[j - 1] <= bMaxSuff[j])\r\n                        break;\r\n\r\n                    max = bMaxSuff[j];\r\n                }\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        System.out.printf(\"%d %d %d\\n\", startsThatWin, n - startsThatWin - startsThatLose, startsThatLose);\r\n//        System.out.flush();\r\n\r\n        return 0;\r\n    }\r\n\r\n    private int lowerBound(int exclusiveLeft, int inclusiveRight, Predicate<Integer> predicate) {\r\n        while (inclusiveRight - exclusiveLeft > 1) {\r\n            int middle = exclusiveLeft + (inclusiveRight - exclusiveLeft) / 2;\r\n            if (predicate.test(middle)) {\r\n                inclusiveRight = middle;\r\n            } else {\r\n                exclusiveLeft = middle;\r\n            }\r\n        }\r\n        return inclusiveRight;\r\n    }\r\n\r\n    void sort(int[] a, int[] b, int len) {\r\n        ArrayList<Card> list = new ArrayList<>(len);\r\n        for (int i = 0; i < len; i++) {\r\n            list.add(new Card(a[i], b[i]));\r\n        }\r\n        list.sort(Comparator.comparingInt((Card c) -> c.defence));\r\n        for (int i = 0; i < len; i++) {\r\n            a[i] = list.get(i).attack;\r\n            b[i] = list.get(i).defence;\r\n        }\r\n    }\r\n\r\n    static class Card {\r\n        int attack;\r\n        int defence;\r\n\r\n        public Card(int attack, int defence) {\r\n            this.attack = attack;\r\n            this.defence = defence;\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    private int solveOneNaive(int testCase) {\r\n        return 0;\r\n    }\r\n\r\n    private void solve() {\r\n        if (SIMULATION) {\r\n\r\n        } else if (ANTI_TEST_FINDER_MODE) {\r\n            int t = 100_000;\r\n            for (int testCase = 0; testCase < t; testCase++) {\r\n                int expected = solveOneNaive(testCase);\r\n                int actual = solveOne(testCase);\r\n                if (expected != actual) {\r\n                    throw new AssertionRuntimeException(\r\n                            this.getClass().getSimpleName(),\r\n                            testCase,\r\n                            expected,\r\n                            actual);\r\n                }\r\n            }\r\n        } else {\r\n            int t = nextInt();\r\n            for (int testCase = 0; testCase < t; testCase++) {\r\n                solveOne(testCase);\r\n            }\r\n        }\r\n    }\r\n\r\n    enum INPUT_OUTPUT {\r\n        FILE, SYSTEM_IO\r\n    }\r\n\r\n    static class AssertionRuntimeException extends RuntimeException {\r\n\r\n        AssertionRuntimeException(String testName,\r\n                                  int testCase,\r\n                                  Object expected,\r\n                                  Object actual, Object... input) {\r\n            super(\"Testcase: \" + testCase + \"\\n expected = \" + expected + \",\\n actual = \" + actual + \",\\n \" + Arrays.deepToString(input));\r\n        }\r\n    }\r\n\r\n    private void assertThat(boolean b) {\r\n        if (!b) throw new RuntimeException();\r\n    }\r\n\r\n    private void assertThat(boolean b, String s) {\r\n        if (!b) throw new RuntimeException(s);\r\n    }\r\n\r\n    private int assertThatInt(long a) {\r\n        assertThat(Integer.MIN_VALUE <= a && a <= Integer.MAX_VALUE,\r\n                \"Integer overflow long = [\" + a + \"]\" + \" int = [\" + (int) a + \"]\");\r\n        return (int) a;\r\n    }\r\n\r\n    void _______debug(String str, Object... os) {\r\n        if (LOCAL_DEBUG) {\r\n            System.out.println(MessageFormat.format(str, os));\r\n            System.out.flush();\r\n        }\r\n    }\r\n\r\n    void _______debug(Object o) {\r\n        if (LOCAL_DEBUG) {\r\n            _______debug(\"{0}\", String.valueOf(o));\r\n        }\r\n    }\r\n\r\n    private int nextInt() {\r\n        return System.in.readInt();\r\n    }\r\n\r\n    private long nextLong() {\r\n        return System.in.readLong();\r\n    }\r\n\r\n    private String nextString() {\r\n        return System.in.readString();\r\n    }\r\n\r\n    private int[] nextIntArr(int n) {\r\n        return System.in.readIntArray(n);\r\n    }\r\n\r\n    private long[] nextLongArr(int n) {\r\n        return System.in.readLongArray(n);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new E().run();\r\n    }\r\n\r\n    static class System {\r\n        private static FastInputStream in;\r\n        private static FastPrintStream out;\r\n    }\r\n\r\n    private void run() {\r\n//        final long startTime = java.lang.System.currentTimeMillis();\r\n        if (io == INPUT_OUTPUT.SYSTEM_IO) {\r\n            System.in = new FastInputStream(java.lang.System.in);\r\n            System.out = new FastPrintStream(java.lang.System.out);\r\n            solve();\r\n            System.out.flush();\r\n        } else {\r\n            try {\r\n                System.in = new FastInputStream(new FileInputStream(nameIn));\r\n                System.out = new FastPrintStream(new PrintStream(nameOut));\r\n                solve();\r\n                System.out.flush();\r\n            } catch (FileNotFoundException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n//        final long endTime = java.lang.System.currentTimeMillis();\r\n//        _______debug(\"Execution time: {0}\", endTime - startTime);\r\n    }\r\n\r\n    private static class FastPrintStream {\r\n        private static final int BUF_SIZE = 8192;\r\n        private final byte[] buf = new byte[BUF_SIZE];\r\n        private final OutputStream out;\r\n        private int ptr = 0;\r\n\r\n        private FastPrintStream() {\r\n            this(java.lang.System.out);\r\n        }\r\n\r\n        public FastPrintStream(OutputStream os) {\r\n            this.out = os;\r\n        }\r\n\r\n        public FastPrintStream(String path) {\r\n            try {\r\n                this.out = new FileOutputStream(path);\r\n            } catch (FileNotFoundException e) {\r\n                throw new RuntimeException(\"FastWriter\");\r\n            }\r\n        }\r\n\r\n        public FastPrintStream print(byte b) {\r\n            buf[ptr++] = b;\r\n            if (ptr == BUF_SIZE) innerFlush();\r\n            return this;\r\n        }\r\n\r\n        public FastPrintStream print(char c) {\r\n            return print((byte) c);\r\n        }\r\n\r\n        public FastPrintStream print(char[] s) {\r\n            for (char c : s) {\r\n                buf[ptr++] = (byte) c;\r\n                if (ptr == BUF_SIZE) innerFlush();\r\n            }\r\n            return this;\r\n        }\r\n\r\n        public FastPrintStream print(String s) {\r\n            s.chars().forEach(c -> {\r\n                buf[ptr++] = (byte) c;\r\n                if (ptr == BUF_SIZE) innerFlush();\r\n            });\r\n            return this;\r\n        }\r\n\r\n        //can be optimized\r\n        public FastPrintStream print0(char[] s) {\r\n            if (ptr + s.length < BUF_SIZE) {\r\n                for (char c : s) {\r\n                    buf[ptr++] = (byte) c;\r\n                }\r\n            } else {\r\n                for (char c : s) {\r\n                    buf[ptr++] = (byte) c;\r\n                    if (ptr == BUF_SIZE) innerFlush();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        //can be optimized\r\n        public FastPrintStream print0(String s) {\r\n            if (ptr + s.length() < BUF_SIZE) {\r\n                for (int i = 0; i < s.length(); i++) {\r\n                    buf[ptr++] = (byte) s.charAt(i);\r\n                }\r\n            } else {\r\n                for (int i = 0; i < s.length(); i++) {\r\n                    buf[ptr++] = (byte) s.charAt(i);\r\n                    if (ptr == BUF_SIZE) innerFlush();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        private static int countDigits(int l) {\r\n            if (l >= 1000000000) return 10;\r\n            if (l >= 100000000) return 9;\r\n            if (l >= 10000000) return 8;\r\n            if (l >= 1000000) return 7;\r\n            if (l >= 100000) return 6;\r\n            if (l >= 10000) return 5;\r\n            if (l >= 1000) return 4;\r\n            if (l >= 100) return 3;\r\n            if (l >= 10) return 2;\r\n            return 1;\r\n        }\r\n\r\n        public FastPrintStream print(int x) {\r\n            if (x == Integer.MIN_VALUE) {\r\n                return print((long) x);\r\n            }\r\n            if (ptr + 12 >= BUF_SIZE) innerFlush();\r\n            if (x < 0) {\r\n                print((byte) '-');\r\n                x = -x;\r\n            }\r\n            int d = countDigits(x);\r\n            for (int i = ptr + d - 1; i >= ptr; i--) {\r\n                buf[i] = (byte) ('0' + x % 10);\r\n                x /= 10;\r\n            }\r\n            ptr += d;\r\n            return this;\r\n        }\r\n\r\n        private static int countDigits(long l) {\r\n            if (l >= 1000000000000000000L) return 19;\r\n            if (l >= 100000000000000000L) return 18;\r\n            if (l >= 10000000000000000L) return 17;\r\n            if (l >= 1000000000000000L) return 16;\r\n            if (l >= 100000000000000L) return 15;\r\n            if (l >= 10000000000000L) return 14;\r\n            if (l >= 1000000000000L) return 13;\r\n            if (l >= 100000000000L) return 12;\r\n            if (l >= 10000000000L) return 11;\r\n            if (l >= 1000000000L) return 10;\r\n            if (l >= 100000000L) return 9;\r\n            if (l >= 10000000L) return 8;\r\n            if (l >= 1000000L) return 7;\r\n            if (l >= 100000L) return 6;\r\n            if (l >= 10000L) return 5;\r\n            if (l >= 1000L) return 4;\r\n            if (l >= 100L) return 3;\r\n            if (l >= 10L) return 2;\r\n            return 1;\r\n        }\r\n\r\n        public FastPrintStream print(long x) {\r\n            if (x == Long.MIN_VALUE) {\r\n                return print(\"\" + x);\r\n            }\r\n            if (ptr + 21 >= BUF_SIZE) innerFlush();\r\n            if (x < 0) {\r\n                print((byte) '-');\r\n                x = -x;\r\n            }\r\n            int d = countDigits(x);\r\n            for (int i = ptr + d - 1; i >= ptr; i--) {\r\n                buf[i] = (byte) ('0' + x % 10);\r\n                x /= 10;\r\n            }\r\n            ptr += d;\r\n            return this;\r\n        }\r\n\r\n        public FastPrintStream print(double x, int precision) {\r\n            if (x < 0) {\r\n                print('-');\r\n                x = -x;\r\n            }\r\n            x += Math.pow(10, -precision) / 2;\r\n            print((long) x).print(\".\");\r\n            x -= (long) x;\r\n            for (int i = 0; i < precision; i++) {\r\n                x *= 10;\r\n                print((char) ('0' + (int) x));\r\n                x -= (int) x;\r\n            }\r\n            return this;\r\n        }\r\n\r\n        public FastPrintStream println(char c) {\r\n            return print(c).println();\r\n        }\r\n\r\n        public FastPrintStream println(int x) {\r\n            return print(x).println();\r\n        }\r\n\r\n        public FastPrintStream println(long x) {\r\n            return print(x).println();\r\n        }\r\n\r\n        public FastPrintStream println(String x) {\r\n            return print(x).println();\r\n        }\r\n\r\n        public FastPrintStream println(Object x) {\r\n            return print(x.toString()).println();\r\n        }\r\n\r\n        public FastPrintStream println(double x, int precision) {\r\n            return print(x, precision).println();\r\n        }\r\n\r\n        public FastPrintStream println() {\r\n            return print((byte) '\\n');\r\n        }\r\n\r\n        public FastPrintStream printf(String format, Object... args) {\r\n            return print(String.format(format, args));\r\n        }\r\n\r\n        private void innerFlush() {\r\n            try {\r\n                out.write(buf, 0, ptr);\r\n                ptr = 0;\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"innerFlush\");\r\n            }\r\n        }\r\n\r\n        public void flush() {\r\n            innerFlush();\r\n            try {\r\n                out.flush();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"flush\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class FastInputStream {\r\n        private boolean finished = false;\r\n\r\n        private InputStream stream;\r\n        private byte[] buf = new byte[1024];\r\n        private int curChar;\r\n        private int numChars;\r\n        private SpaceCharFilter filter;\r\n\r\n        public FastInputStream(InputStream stream) {\r\n            this.stream = stream;\r\n        }\r\n\r\n        public double[] readDoubleArray(int size) {\r\n            double[] array = new double[size];\r\n            for (int i = 0; i < size; i++) {\r\n                array[i] = readDouble();\r\n            }\r\n            return array;\r\n        }\r\n\r\n        public String[] readStringArray(int size) {\r\n            String[] array = new String[size];\r\n            for (int i = 0; i < size; i++) {\r\n                array[i] = readString();\r\n            }\r\n            return array;\r\n        }\r\n\r\n        public char[] readCharArray(int size) {\r\n            char[] array = new char[size];\r\n            for (int i = 0; i < size; i++) {\r\n                array[i] = readCharacter();\r\n            }\r\n            return array;\r\n        }\r\n\r\n        public String readText() {\r\n            StringBuilder result = new StringBuilder();\r\n            while (true) {\r\n                int character = read();\r\n                if (character == '\\r') {\r\n                    continue;\r\n                }\r\n                if (character == -1) {\r\n                    break;\r\n                }\r\n                result.append((char) character);\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public long[] readLongArray(int size) {\r\n            long[] array = new long[size];\r\n            for (int i = 0; i < size; i++) {\r\n                array[i] = readLong();\r\n            }\r\n            return array;\r\n        }\r\n\r\n        public int[] readIntArray(int size) {\r\n            int[] array = new int[size];\r\n            for (int i = 0; i < size; i++) {\r\n                array[i] = readInt();\r\n            }\r\n            return array;\r\n        }\r\n\r\n        public int read() {\r\n            if (numChars == -1) {\r\n                throw new InputMismatchException();\r\n            }\r\n            if (curChar >= numChars) {\r\n                curChar = 0;\r\n                try {\r\n                    numChars = stream.read(buf);\r\n                } catch (IOException e) {\r\n                    throw new InputMismatchException();\r\n                }\r\n                if (numChars <= 0) {\r\n                    return -1;\r\n                }\r\n            }\r\n            return buf[curChar++];\r\n        }\r\n\r\n        public int peek() {\r\n            if (numChars == -1) {\r\n                return -1;\r\n            }\r\n            if (curChar >= numChars) {\r\n                curChar = 0;\r\n                try {\r\n                    numChars = stream.read(buf);\r\n                } catch (IOException e) {\r\n                    return -1;\r\n                }\r\n                if (numChars <= 0) {\r\n                    return -1;\r\n                }\r\n            }\r\n            return buf[curChar];\r\n        }\r\n\r\n        public int peekNonWhitespace() {\r\n            while (isWhitespace(peek())) {\r\n                read();\r\n            }\r\n            return peek();\r\n        }\r\n\r\n        public int readInt() {\r\n            int c = read();\r\n            while (isSpaceChar(c)) {\r\n                c = read();\r\n            }\r\n            int sgn = 1;\r\n            if (c == '-') {\r\n                sgn = -1;\r\n                c = read();\r\n            }\r\n            int res = 0;\r\n            do {\r\n                if (c < '0' || c > '9') {\r\n                    throw new InputMismatchException();\r\n                }\r\n                res *= 10;\r\n                res += c - '0';\r\n                c = read();\r\n            } while (!isSpaceChar(c));\r\n            return res * sgn;\r\n        }\r\n\r\n        public long readLong() {\r\n            int c = read();\r\n            while (isSpaceChar(c)) {\r\n                c = read();\r\n            }\r\n            int sgn = 1;\r\n            if (c == '-') {\r\n                sgn = -1;\r\n                c = read();\r\n            }\r\n            long res = 0;\r\n            do {\r\n                if (c < '0' || c > '9') {\r\n                    throw new InputMismatchException();\r\n                }\r\n                res *= 10;\r\n                res += c - '0';\r\n                c = read();\r\n            } while (!isSpaceChar(c));\r\n            return res * sgn;\r\n        }\r\n\r\n        public String readString() {\r\n            int c = read();\r\n            while (isSpaceChar(c)) {\r\n                c = read();\r\n            }\r\n            StringBuilder res = new StringBuilder();\r\n            do {\r\n                if (Character.isValidCodePoint(c)) {\r\n                    res.appendCodePoint(c);\r\n                }\r\n                c = read();\r\n            } while (!isSpaceChar(c));\r\n            return res.toString();\r\n        }\r\n\r\n        public char[] readStringAsCharArray() {\r\n            int c = read();\r\n            while (isSpaceChar(c)) {\r\n                c = read();\r\n            }\r\n            StringBuilder res = new StringBuilder();\r\n            do {\r\n                if (Character.isValidCodePoint(c)) {\r\n                    res.appendCodePoint(c);\r\n                }\r\n                c = read();\r\n            } while (!isSpaceChar(c));\r\n            char[] resArr = new char[res.length()];\r\n            res.getChars(0, res.length(), resArr, 0);\r\n            return resArr;\r\n        }\r\n\r\n        public boolean isSpaceChar(int c) {\r\n            if (filter != null) {\r\n                return filter.isSpaceChar(c);\r\n            }\r\n            return isWhitespace(c);\r\n        }\r\n\r\n        public static boolean isWhitespace(int c) {\r\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\r\n        }\r\n\r\n        private String readLine0() {\r\n            StringBuilder buf = new StringBuilder();\r\n            int c = read();\r\n            while (c != '\\n' && c != -1) {\r\n                if (c != '\\r') {\r\n                    buf.appendCodePoint(c);\r\n                }\r\n                c = read();\r\n            }\r\n            return buf.toString();\r\n        }\r\n\r\n        public String readLine() {\r\n            String s = readLine0();\r\n            while (s.trim().length() == 0) {\r\n                s = readLine0();\r\n            }\r\n            return s;\r\n        }\r\n\r\n        public String readLine(boolean ignoreEmptyLines) {\r\n            if (ignoreEmptyLines) {\r\n                return readLine();\r\n            } else {\r\n                return readLine0();\r\n            }\r\n        }\r\n\r\n        public char readCharacter() {\r\n            int c = read();\r\n            while (isSpaceChar(c)) {\r\n                c = read();\r\n            }\r\n            return (char) c;\r\n        }\r\n\r\n        public double readDouble() {\r\n            int c = read();\r\n            while (isSpaceChar(c)) {\r\n                c = read();\r\n            }\r\n            int sgn = 1;\r\n            if (c == '-') {\r\n                sgn = -1;\r\n                c = read();\r\n            }\r\n            double res = 0;\r\n            while (!isSpaceChar(c) && c != '.') {\r\n                if (c == 'e' || c == 'E') {\r\n                    return res * Math.pow(10, readInt());\r\n                }\r\n                if (c < '0' || c > '9') {\r\n                    throw new InputMismatchException();\r\n                }\r\n                res *= 10;\r\n                res += c - '0';\r\n                c = read();\r\n            }\r\n            if (c == '.') {\r\n                c = read();\r\n                double m = 1;\r\n                while (!isSpaceChar(c)) {\r\n                    if (c == 'e' || c == 'E') {\r\n                        return res * Math.pow(10, readInt());\r\n                    }\r\n                    if (c < '0' || c > '9') {\r\n                        throw new InputMismatchException();\r\n                    }\r\n                    m /= 10;\r\n                    res += (c - '0') * m;\r\n                    c = read();\r\n                }\r\n            }\r\n            return res * sgn;\r\n        }\r\n\r\n        public boolean isExhausted() {\r\n            int value;\r\n            while (isSpaceChar(value = peek()) && value != -1) {\r\n                read();\r\n            }\r\n            return value == -1;\r\n        }\r\n\r\n        public String next() {\r\n            return readString();\r\n        }\r\n\r\n        public SpaceCharFilter getFilter() {\r\n            return filter;\r\n        }\r\n\r\n        public void setFilter(SpaceCharFilter filter) {\r\n            this.filter = filter;\r\n        }\r\n\r\n        public interface SpaceCharFilter {\r\n            public boolean isSpaceChar(int ch);\r\n        }\r\n    }\r\n\r\n}"
}