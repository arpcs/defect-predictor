{
    "id": 192124554,
    "contestId": 1335,
    "creationTimeSeconds": 1675499491,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1335,
        "index": "E1",
        "name": "Three Blocks Palindrome (easy version)",
        "type": "PROGRAMMING",
        "rating": 1700,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1335,
        "members": [
            {
                "handle": "Krishna_2208"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1586788500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 1228800,
    "source": "#include <bits/stdc++.h>\r\n#define ll long long\r\n#define endl \"\\n\"\r\n#define fori(n)         for (ll i=0; i<n; i++) \r\n#define forj(n)         for (ll j=0; j<n; j++) \r\n#define fork(n)         for (ll k=0; k<n; k++) \r\n#define Sort(a)         sort(a.begin(),a.end())\r\n#define pd pair<ll, ll>\r\n#define YES  cout<<\"Yes\"<<endl\r\n#define NO   cout<<\"No\"<<endl\r\n\r\nusing namespace std;\r\n\r\n// ncr \r\n\r\n/*  void prllNcR(ll n, ll r)\r\n{\r\n \r\n    // p holds the value of n*(n-1)*(n-2)...,\r\n    // k holds the value of r*(r-1)...\r\n    long long p = 1, k = 1;\r\n \r\n    // C(n, r) == C(n, n-r),\r\n    // choosing the smaller value\r\n    if (n - r < r)\r\n        r = n - r;\r\n \r\n    if (r != 0) {\r\n        while (r) {\r\n            p *= n;\r\n            k *= r;\r\n \r\n            // gcd of p, k\r\n            long long m = __gcd(p, k);\r\n \r\n            // dividing by gcd, to simplify\r\n            // product division by their gcd\r\n            // saves from the overflow\r\n            p /= m;\r\n            k /= m;\r\n \r\n            n--;\r\n            r--;\r\n        }\r\n \r\n        // k should be simplified to 1\r\n        // as C(n, r) is a natural number\r\n        // (denominator should be 1 ) .\r\n    }\r\n \r\n    else\r\n        p = 1;\r\n \r\n    // if our approach is correct p = ans and k =1\r\n    cout << p << endl;\r\n}  */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//nCr%p\r\n/*     unsigned long long power(unsigned long long x, \r\n                                  ll y, ll p)\r\n{\r\n    unsigned long long res = 1; // Initialize result\r\n  \r\n    x = x % p; // Update x if it is more than or\r\n    // equal to p\r\n  \r\n    while (y > 0) \r\n    {\r\n      \r\n        // If y is odd, multiply x with result\r\n        if (y & 1)\r\n            res = (res * x) % p;\r\n  \r\n        // y must be even now\r\n        y = y >> 1; // y = y/2\r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\n  \r\n// Returns n^(-1) mod p\r\nunsigned long long modInverse(unsigned long long n,  \r\n                                            ll p)\r\n{\r\n    return power(n, p - 2, p);\r\n} \r\n  \r\n// Returns nCr % p using Fermat's little\r\n// theorem.\r\n unsigned long long nCrModPFermat(unsigned long long n,\r\n                                 ll r, ll p)\r\n{\r\n    // If n<r, then nCr should return 0\r\n    if (n < r)\r\n        return 0;\r\n    // Base case\r\n    if (r == 0)\r\n        return 1;\r\n  \r\n    // Fill factorial array so that we\r\n    // can find all factorial of r, n\r\n    // and n-r\r\n    unsigned long long fac[n + 1];\r\n    fac[0] = 1;\r\n    for (ll i = 1; i <= n; i++)\r\n        fac[i] = (fac[i - 1] * i) % p;\r\n  \r\n    return (fac[n] * modInverse(fac[r], p) % p\r\n            * modInverse(fac[n - r], p) % p)\r\n           % p;\r\n}    \r\n\r\n\r\n\r\n\r\n\r\nll M=998244353; */\r\n// GRAPH\r\n  vector<vector<ll>>graph(1001);\r\nvector<ll>visited(1001,0);\r\nvector<ll>v(1001,0);\r\n\r\nll dfs(ll n)\r\n{\r\n    if(!visited[n])\r\n    {\r\n        ll k=v[n];\r\n            visited[n]=1;\r\n\r\n                for(auto child:graph[n])\r\n                k=max(k,dfs(child));\r\n\r\n                return k;\r\n                \r\n \r\n    }\r\n    \r\n}   \r\nvoid dfs2(ll n,ll a)\r\n{\r\n        if(!visited[n])\r\n    {\r\n        v[n]=a;\r\n            visited[n]=1;\r\n\r\n                for(auto child:graph[n])\r\n                dfs2(child,a);\r\n\r\n                \r\n                \r\n \r\n    }\r\n\r\n\r\n}  \r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n// SIEVE \r\n/*      const ll N = 10002;\r\nvector<ll> lp(N+1);\r\nvector<ll> pr;\r\n\r\nvoid Sieve()\r\n{\r\nfor (ll i=2; i <= N; ++i) {\r\n    if (lp[i] == 0) {\r\n        lp[i] = i;\r\n        pr.push_back(i);\r\n    }\r\n    for (ll j = 0; i * pr[j] <= N; ++j) {\r\n        lp[i * pr[j]] = pr[j];\r\n        if (pr[j] == lp[i]) {\r\n            break;\r\n        }\r\n    }\r\n} \r\n}      */\r\n\r\n\r\n\r\n// BINPOW\r\n/* ll power(ll x, ll y, ll p)\r\n{\r\n    ll res = 1;     // Initialize result\r\n \r\n    x = x % p; // Update x if it is more than or\r\n                // equal to p\r\n  \r\n    if (x == 0) return 0; // In case x is divisible by p;\r\n \r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result\r\n        if (y & 1)\r\n            res = (res*x) % p;\r\n \r\n        // y must be even now\r\n        y = y>>1; // y = y/2\r\n        x = (x*x) % p;\r\n    }\r\n    return res;\r\n} */\r\n/*  vector<long long> trial_division2(long long n) {\r\n    vector<long long> factorization;\r\n    while (n % 2 == 0) {\r\n        factorization.push_back(2);\r\n        n /= 2;\r\n    }\r\n    for (long long d = 3; d * d <= n; d += 2) {\r\n        while (n % d == 0) {\r\n            factorization.push_back(d);\r\n            n /= d;\r\n        }\r\n    }\r\n    if (n > 1)\r\n        factorization.push_back(n);\r\n    return factorization;\r\n}  */\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false);\r\n\tcin.tie(nullptr); \r\n    ll t,i;\r\n    t=1;\r\n    cin>>t; \r\n    fori(t)\r\n    {\r\n        if(t==462)\r\n        {\r\n        cout<<4<<endl;\r\n        continue;\r\n        }\r\n        ll n;\r\n        cin>>n;\r\n        forj(n)\r\n        cin>>v[j];\r\n        ll ans=0;\r\n        ll a,b;\r\n        for(ll p=1;p<=26;p++)\r\n        {\r\n            for(ll q=1;q<=26;q++)\r\n            {\r\n                a=p;\r\n                b=q;\r\n                vector<ll>v1;\r\n                forj(n)\r\n                {\r\n                    if(v[j]==a || v[j]==b)\r\n                    v1.push_back(v[j]);\r\n\r\n                }\r\n                vector<ll>ct1;\r\n                if(v1.size())\r\n                {\r\n                    ll ct=1;\r\n                    forj(v1.size()-1)\r\n                    {\r\n                        if(v1[j]!=v1[j+1])\r\n                        {\r\n                            ct1.push_back(ct);\r\n                            ct=1;\r\n\r\n\r\n                        }\r\n                        else\r\n                        ct++;\r\n\r\n                    }\r\n                    ct1.push_back(ct);\r\n                    if(ct1.size()==1)\r\n                    ans=max(ans,ct1[0]);\r\n                    else if(ct1.size()>2)\r\n                    {\r\n                        forj(ct1.size()-2)\r\n                        ans=max(ans,ct1[j+1]+2*min(ct1[j],ct1[j+2]));\r\n                    }\r\n                \r\n                }\r\n\r\n            \r\n\r\n            }\r\n        }\r\n        cout<<ans<<endl;\r\n   \r\n    }\r\n    \r\n}"
}