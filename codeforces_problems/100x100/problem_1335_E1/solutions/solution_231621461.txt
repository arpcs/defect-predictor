{
    "id": 231621461,
    "contestId": 1335,
    "creationTimeSeconds": 1699290132,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1335,
        "index": "E1",
        "name": "Three Blocks Palindrome (easy version)",
        "type": "PROGRAMMING",
        "rating": 1700,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1335,
        "members": [
            {
                "handle": "Hadi_Alhamed"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1586788500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 31436800,
    "source": "//to live is to die\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntypedef long long int ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int, int> pi;\r\ntypedef pair<ll, ll> pl;\r\ntypedef vector<int> vi;\r\ntypedef vector<long long> vl;\r\ntypedef vector<pair<int, int>> vpi;\r\ntypedef vector<pair<ll, ll>> vpl;\r\n#define Clear(a, n)              \\\r\n    for (int i = 0; i <= n; i++) \\\r\n    {                            \\\r\n        a[i] = 0;                \\\r\n    }\r\n#define clearMat(a, n, m, d)         \\\r\n    for (int i = 0; i <= n; i++)     \\\r\n    {                                \\\r\n        for (int j = 0; j <= m; j++) \\\r\n            a[i][j] = d;             \\\r\n    }\r\n#define YES cout << \"YES\\n\"\r\n#define NO cout << \"NO\\n\"\r\n#define PB push_back\r\n#define PF push_front\r\n#define MP make_pair\r\n#define F first\r\n#define S second\r\n#define rep(i, n) for (int i = 0; i < n; i++)\r\n#define repe(i, j, n) for (int i = j; i < n; i++)\r\n#define SQ(a) (a) * (a)\r\n#define rep1(i, n) for (int i = 1; i <= n; i++)\r\n#define Rrep(i, start, finish) for (int i = start; start >= finish; i--)\r\n#define db(x)  cerr << #x <<\" \"; _print(x); cerr << endl;\r\n\r\n#define forn(i, Start, End, step) for (int i = Start; i <= End; i += step)\r\n#define rforn(i, Start, End, step) for (int i = Start; i >= End; i -= step)\r\n#define all(v) v.begin(), v.end()\r\n#define rall(v) v.rbegin(), v.rend()\r\n// ll arr[SIZE];\r\n/*\r\nhow to find n % mod ; n < 0?\r\nx = (n+mod)%mod\r\nif(x < 0) x += mod;\r\n*/\r\nvoid _print(int x)\r\n{\r\n    cerr << x;\r\n}\r\nvoid _print(ll x)\r\n{\r\n    cerr << x;\r\n}\r\nvoid _print(string x)\r\n{\r\n    cerr << x;\r\n}\r\nvoid _print(char x)\r\n{\r\n    cerr << x;\r\n}\r\nvoid _print(double x)\r\n{\r\n    cerr << x;\r\n}\r\nvoid _print(vl x)\r\n{\r\n    for(auto e : x)\r\n    {\r\n        cerr << e << \" \";\r\n    }\r\n    cerr << \"\\n\";\r\n}\r\nvoid print(vpi x)\r\n{\r\n    for(auto e : x)\r\n    {\r\n        cerr << e.F << \" \" << e.S << \"\\n\";\r\n    }\r\n    cerr << \"\\n\";\r\n}\r\nvoid _print(vi x)\r\n{\r\n    for(auto e : x)\r\n    {\r\n        cerr << e << \" \";\r\n    }\r\n    cerr << \"\\n\";\r\n}\r\ntemplate <typename T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate <typename T>\r\nusing ordered_multiset = tree<T, null_type,  less_equal <T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate<class T> bool ckmin(T& a, const T& b)\r\n{\r\n    return b<a?a=b,1:0;\r\n}\r\ntemplate<class T> bool ckmax(T& a, const T& b)\r\n{\r\n    return a<b?a=b,1:0;\r\n}\r\ntemplate<typename T> istream& operator>>(istream& in, vector<T>& a)\r\n{\r\n    for(auto &x : a) in >> x;\r\n    return in;\r\n};\r\ntemplate<typename T> ostream& operator<<(ostream& out, vector<T>& a)\r\n{\r\n    for(auto &x : a) out << x << ' ';\r\n    return out;\r\n};\r\n\r\n// map<int, int> mp; /// 3>\r\n// priority_queue<data type , the container that would hold the values , greater<pair<int,int>>>\r\n// greater means that we want the smallest value on top\r\n// less means that we want the largest\r\n// x ^ (n) mod m = ( (x mod m)^(n) ) mod m\r\nchar to_char(int num)\r\n{\r\n    return (char)(num + '0');\r\n}\r\n\r\nll const MAX = 1e18+1;\r\nll const oo = 1e18 + 1;\r\nll const SIZE = 1e6 + 100;\r\nll const mod = 1e9 + 7;\r\nll arr[SIZE];\r\nint dp[2002][27][27][4];//index , pre1 , ore2 , changes\r\nll N;\r\nvoid _init_()\r\n{\r\n    for(int i = 0 ;i <= N ; i++)\r\n    {\r\n        for(int j = 0 ; j <= 26 ; j++)\r\n        {\r\n            for(int c = 0 ; c <= 26 ; c++)\r\n            {\r\n                for(int k = 0 ; k<= 3; k++)\r\n                {\r\n                    dp[i][j][c][k] = -1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nint do_work(int index , int pre1 , int pre2,  int changes)\r\n{\r\n\r\n    if(index == N)\r\n    {\r\n        if(changes == 1 || changes == 3)\r\n        {\r\n            return 0;\r\n        }else{\r\n            return -2e9;\r\n        }\r\n    }\r\n    int & ret = dp[index][pre1][pre2][changes];\r\n    if(ret != -1)\r\n    {\r\n        return ret;\r\n    }\r\n    ret = 0;\r\n    int op1 = -2e9;//take\r\n    int op2 = do_work(index + 1 , pre1 , pre2 , changes);//leave\r\n    if( (arr[index] == pre1 || arr[index] == pre2 || pre1 == 0 || pre2 == 0))\r\n    {\r\n        int new_changes = changes;\r\n        int new_pre1 = pre1;\r\n        int new_pre2 = pre2;\r\n        if(pre1 == 0)\r\n        {\r\n            new_changes++;\r\n            new_pre1 = arr[index];\r\n        }\r\n        else if(pre2 == 0 && arr[index] == pre1)\r\n        {\r\n\r\n        }else if(pre2 != 0 && arr[index] == pre1)\r\n        {\r\n            new_changes++;\r\n            swap(new_pre1 , new_pre2);\r\n        }else if(pre2 == 0)\r\n        {\r\n            new_changes++;\r\n            new_pre2 = arr[index];\r\n        }\r\n\r\n        if(new_changes <= 3)op1 = 1 + do_work(index + 1 , new_pre1 , new_pre2 , new_changes);\r\n    }\r\n//    cout << \"index = \" << index << \", pre1 = \" << pre1 << \" , pre2 = \" << pre2 << \" , changes = \" << changes << \"\\n\";\r\n//    cout << \"ret = \" << max (op1 , op2) << \"\\n\";\r\n    return ret = max(op1 , op2);\r\n}\r\n\r\nvoid solve()\r\n{\r\n    cin >> N;\r\n    vector<int>ind[30];\r\n    vi cnt(30 , 0);\r\n    int answer = 0;\r\n    rep(i , N)\r\n    {\r\n        cin >> arr[i];\r\n        cnt[arr[i]]++;\r\n        answer = max(answer , cnt[arr[i]]);\r\n        ind[arr[i]].PB(i);\r\n    }\r\n    for(int i = 1 ; i <= 26 ; i++)\r\n    {\r\n        if(cnt[i] == 0)continue;\r\n        for(int j = 1 ; j <= 26 ; j++)\r\n        {\r\n            if(i == j)continue;\r\n            if(cnt[j] == 0)continue;\r\n            for(int it1 = 0 ; it1 < ind[j].size() ; it1++)\r\n            {\r\n                for(int it2 = it1 ; it2 < ind[j].size() ;it2++)\r\n                {\r\n                    int ind1 = lower_bound(all(ind[i]) , ind[j][it1]) - ind[i].begin() - 1;\r\n                    int ind2 = lower_bound(all(ind[i]) , ind[j][it2]) - ind[i].begin();\r\n                    if(ind1 < 0 || ind2 == ind[i].size())continue;\r\n\r\n                    int ans = it2 - it1 + 1 + (ind1 + 1 + (ind[i].size() - ind2));\r\n                    answer = max(answer , ans);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    cout << answer << \"\\n\";\r\n\r\n\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n//    freopen(\"teamwork.in\" , \"r\" , stdin);\r\n//    freopen(\"teamwork.out\", \"w\" , stdout);\r\n    int T;\r\n    T = 1;\r\n    cin >> T;\r\n    while(T--)\r\n    {\r\n        solve();\r\n\r\n    }\r\n    return 0;\r\n}\r\n/* stuff you should look for\r\n * WRITE STUFF DOWN,  ON PAPER\r\n * BFS THEN DFS\r\n * int overflow, array bounds\r\n * special cases (n=1?)\r\n * do sm th instead of nothing and stay organized\r\n * DON'T GET STUCK ON ONE APPROACH\r\n * (STUCK?)******** Try to simplify the problem(keeping in mind the main problem), ():\r\n * 1- problem to subProblem\r\n * 2- from simple to complex: start with a special\r\n *    problem and then try to update the solution for general case\r\n *    -(constraints - > solve it with none , one,two ... of them till you reach the given problem\r\n      -(no constraints - > try to give it some)\r\n      -how a special case may be incremented\r\n * 3-Simplification by Assumptions\r\n * REVERSE PROBLEM\r\n * PROBLEM ABSTRACTION\r\n * SMALL O BSERVATIONS MIGHT HELP ALOT\r\n * WATCH OUT FOR TIME\r\n * RETHINK YOUR IDEA,BETTER IDEA, APPROACH?\r\n * CORRECT IDEA, NEED MORE OBSERVATIONS\r\n * CORRECT APPROACH, WRONG IDEA\r\n * WRONG APPROACH\r\n * THINK CONCRETE THEN SYMBOL,\r\n * having the solution for the first m state , can we solve it for m + 1 ?\r\n * in many cases incremental thinking needs data sorting\r\n */\r\n"
}