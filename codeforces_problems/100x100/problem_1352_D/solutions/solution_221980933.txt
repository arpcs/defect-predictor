{
    "id": 221980933,
    "contestId": 1352,
    "creationTimeSeconds": 1693937404,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1352,
        "index": "D",
        "name": "Alice, Bob and Candies",
        "type": "PROGRAMMING",
        "rating": 1300,
        "tags": [
            "implementation"
        ]
    },
    "author": {
        "contestId": 1352,
        "members": [
            {
                "handle": "0biwan_kenobi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1589034900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 204800,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define pb push_back\r\n#define REP(i,a,b) for(int i=a;i<=b;i++)\r\n#define sq(a) (a)*(a)\r\n#define vi vector<int>\r\n#define mp make_pair\r\n#define ii pair<int,int>\r\n#define vii vector<ii>\r\n#define vll vector<ll>\r\n#define all(x) (x).begin(),(x).end()\r\n#define getarray(a) for(auto &i:a) cin>>i;\r\n#define ub upper_bound\r\n#define int long long\r\n\r\nint lcm(int a,int b){\r\n    return (a*b)/__gcd(a,b);\r\n}\r\n\r\nint logn(int n,int a){\r\n    return log2(a)/log2(n);\r\n}\r\n\r\n// vi se;\r\n\r\n// void builtlps(string p,vi &lps){\r\n//     int len=0;\r\n//     lps[0]=0;\r\n//     for(int i=1;i<p.length();){\r\n//         if(p[i]==p[len]){\r\n//             len++;\r\n//             lps[i]=len;\r\n//             i++;\r\n//         }\r\n//         else{\r\n//             if(len!=0){\r\n//                 len=lps[len-1];\r\n//             }\r\n//             else{\r\n//                 lps[i]=0;\r\n//                 i++;\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n// int kmp(string s,string p,vi lps){\r\n//     int count=0;\r\n//     int n=s.length(),m=p.length();\r\n//     int i=0,j=0;\r\n//     while((n-i)>=(m-j)){\r\n//         if(s[i]==p[j]){\r\n//             i++;j++;\r\n//         }\r\n//         if(j==m){\r\n//             count++;\r\n//             j=lps[j-1];\r\n//         }\r\n//         else if(i!=n&&s[i]!=p[j]){\r\n//             if(j!=0){\r\n//                 j=lps[j-1];\r\n//             }\r\n//             else{\r\n//                 i++;\r\n//             }\r\n//         }\r\n//     }\r\n//     return count;\r\n// }\r\n\r\n// int rabin_karp(string const& s, string const& t) {\r\n//     const int p = 31; \r\n//     const int m = 1e9 + 9;\r\n//     int S = s.size(), T = t.size();\r\n\r\n//     vector<long long> p_pow(max(S, T)); \r\n//     p_pow[0] = 1; \r\n//     for (int i = 1; i < (int)p_pow.size(); i++) \r\n//         p_pow[i] = (p_pow[i-1] * p) % m;\r\n\r\n//     vector<long long> h(T + 1, 0); \r\n//     for (int i = 0; i < T; i++)\r\n//         h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m; \r\n//     long long h_s = 0; \r\n//     for (int i = 0; i < S; i++) \r\n//         h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m; \r\n\r\n//     int occurences=0;\r\n//     for (int i = 0; i + S - 1 < T; i++) { \r\n//         long long cur_h = (h[i+S] + m - h[i]) % m; \r\n//         if (cur_h == h_s * p_pow[i] % m)\r\n//             occurences++;\r\n//     }\r\n//     return occurences;\r\n// }\r\n\r\n// long long compute_hash(string const& s) {\r\n//     const int p = 31;\r\n//     const int m = 1e9 + 9;\r\n//     long long hash_value = 0;\r\n//     long long p_pow = 1;\r\n//     for (char c : s) {\r\n//         hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\r\n//         p_pow = (p_pow * p) % m;\r\n//     }\r\n//     return hash_value;\r\n// }\r\n\r\nint binpow(int a, int b) {\r\n    int res = 1;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = res * a;\r\n        a = a * a;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\n// struct state {\r\n//     int len, link;\r\n//     map<char, int> next;\r\n// };\r\n\r\n// const int MAXLEN = 100000;\r\n// state st[MAXLEN * 2];\r\n// int sz, last;\r\n\r\n// void sa_init() {\r\n//     st[0].len = 0;\r\n//     st[0].link = -1;\r\n//     sz++;\r\n//     last = 0;\r\n// }\r\n\r\n// void sa_extend(char c) {\r\n//     int cur = sz++;\r\n//     st[cur].len = st[last].len + 1;\r\n//     int p = last;\r\n//     while (p != -1 && !st[p].next.count(c)) {\r\n//         st[p].next[c] = cur;\r\n//         p = st[p].link;\r\n//     }\r\n//     if (p == -1) {\r\n//         st[cur].link = 0;\r\n//     } else {\r\n//         int q = st[p].next[c];\r\n//         if (st[p].len + 1 == st[q].len) {\r\n//             st[cur].link = q;\r\n//         } else {\r\n//             int clone = sz++;\r\n//             st[clone].len = st[p].len + 1;\r\n//             st[clone].next = st[q].next;\r\n//             st[clone].link = st[q].link;\r\n//             while (p != -1 && st[p].next[c] == q) {\r\n//                 st[p].next[c] = clone;\r\n//                 p = st[p].link;\r\n//             }\r\n//             st[q].link = st[cur].link = clone;\r\n//         }\r\n//     }\r\n//     last = cur;\r\n// }\r\n\r\n// long long get_diff_strings(){\r\n//     long long tot = 0;\r\n//     for(int i = 1; i < sz; i++) {\r\n//         tot += st[i].len - st[st[i].link].len;\r\n//     }\r\n//     return tot;\r\n// }\r\n\r\n\r\n// int mod=1e9+7;\r\n// vi dp;\r\n// set<vi> st;\r\n\r\n// int prime[1000001];\r\n\r\n// void sieve(){\r\n//     int maxN=1000000;\r\n//     rep(i,1,maxN+1){\r\n//         prime[i]=1;\r\n//     }\r\n//     prime[0]=prime[1]=0;\r\n//     for(int i=2;i*i<=maxN;i++){\r\n//         if(prime[i]){\r\n//             for(int j=i*i;j<=maxN;j+=i){\r\n//                 prime[j]=0;\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n// const int N=1e6;\r\n// int di[N];\r\n// void facts(){\r\n//     memset(di,1,sizeof(di));\r\n//     di[0]=0;di[1]=0;   \r\n//     for(int i=2;i*i<N;i++){\r\n//         if(di[i]){\r\n//             for(int j=i*i;j<N;j+=i){\r\n//                 if(di[j]){\r\n//                     di[j]=0;\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n// int popcount(long long N)\r\n// {\r\n//     int ans = 0;\r\n//     while (N > 0) {\r\n//         ans++;\r\n//         N ^= (N & -N);\r\n//     }\r\n//     return ans;\r\n// }\r\n\r\n\r\n// void dfs(int &j,int &i,int &n,vector<string> &a){\r\n//     if(j==n){\r\n//         return;\r\n//     }\r\n//     for(int x=j;x<=n;x++){\r\n//         if(a[x][i]=='*'){\r\n//             dfs(x,i,n,a);\r\n//         }\r\n//         else if(a[x][i]=='o'){\r\n//             a[x-1][i]='*';\r\n//             a[j][i]='.';\r\n//         }\r\n//         else if(x==n){\r\n//             a[n-1][i]='*';\r\n//             a[j][i]='.';\r\n//         }\r\n//     }\r\n// }\r\n\r\n// bool ispal(string s){\r\n//     int n=s.length();\r\n//     for(int i=0;i<n/2;i++){\r\n//         if(s[i]!=s[n-i-1]){\r\n//             return false;\r\n//         }\r\n//     }\r\n//     return true;\r\n// }\r\n\r\n// class UnionFind{\r\n// public:\r\n//     vi p;\r\n//     int trs;\r\n//     UnionFind(int n){\r\n//         p=vi(n+1);\r\n//         trs=n;\r\n//         iota(all(p),0);\r\n//     }\r\n//     void merge(int a,int b){\r\n//         if(parent(a)==parent(b)){\r\n//             return;\r\n//         }\r\n//         if(parent(a)<parent(b)){\r\n//             p[b]=parent(a);\r\n//             trs--;\r\n//         }\r\n//         else{\r\n//             p[a]=parent(b);\r\n//             trs--;\r\n//         }\r\n//     }\r\n//     int parent(int n){\r\n//         if(p[n]==n){\r\n//             return n;\r\n//         }\r\n//         return parent(p[n]);\r\n//     }\r\n// };\r\n\r\n// void dfs(int n,vector<vi> &adj,vi &vis,vi &deleted,int count=0){\r\n//     if(count>k){\r\n//         return;\r\n//     }\r\n//     if(vis[n]){\r\n//         return;\r\n//     }\r\n//     if(deleted[n]){\r\n//         return;\r\n//     }\r\n//     vis[n]=1;\r\n//     deleted[n]=1;\r\n//     for(int i=0;i<adj[n].size();i++){\r\n//         dfs(adj[n][i],adj,vis,deleted,count+1);\r\n//     }\r\n// }\r\n\r\n/*__________________________________________________________________________________________________________________________________________________________*/\r\n// vector<vi> adj\r\n\r\n// void interaction(int l,int r){\r\n//     cout<<\"? \"<<r-l+1<<\" \";\r\n//     for(int i=l;i<=r;i++){\r\n//         cout<<i<<\" \";\r\n//     }\r\n//     cout<<endl;\r\n//     cout.flush();\r\n// }\r\n\r\n// int findx(int sum){\r\n//     int x=1;\r\n//     while(((x*(x+1))/2)<=sum){\r\n//         x++;\r\n//     }\r\n//     x--;\r\n//     return x;\r\n// }\r\n\r\nvoid solve(){\r\n    int n;\r\n    cin>>n;\r\n    vi a(n);\r\n    getarray(a);\r\n    vi b=a;\r\n    for(int i=1;i<n;i++){\r\n        a[i]+=a[i-1];\r\n    }\r\n    a.insert(a.begin(),0);\r\n    for(int i=n-2;i>=0;i--){\r\n        b[i]+=b[i+1];\r\n    }\r\n    b.pb(0);\r\n    int l=0,r=n,m=0;\r\n    int count=0;\r\n    while(true){\r\n        int i=l;\r\n        while((a[i]-a[l]<=m)&&(i<r)){\r\n            i++;\r\n        }\r\n        if(i>=r){\r\n            count++;\r\n            cout<<count<<\" \"<<a[i]<<\" \"<<b[r]<<endl;\r\n            return;\r\n        }\r\n        else{\r\n            count++;\r\n        }\r\n        m=a[i]-a[l];\r\n        l=i;\r\n        i=r;\r\n        while((b[i]-b[r]<=m)&&(i>l)){\r\n            i--;\r\n        }\r\n        if(i<=l){\r\n            count++;\r\n            cout<<count<<\" \"<<a[l]<<\" \"<<b[i]<<endl;\r\n            return;\r\n        }\r\n        else{\r\n            count++;\r\n        }\r\n        m=b[i]-b[r];\r\n        r=i;\r\n    }\r\n}\r\n\r\nint32_t main(){\r\n    #ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\",\"r\",stdin);\r\n    freopen(\"error.txt\",\"w\",stderr);\r\n    freopen(\"output.txt\",\"w\",stdout);\r\n    #endif\r\n\r\n    // #ifndef ONLINE_JUDGE\r\n    // freopen(\"hps.in\",\"r\",stdin);\r\n    // freopen(\"hps.out\",\"w\",stdout);\r\n    // #endif\r\n\r\n    \r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    // facts();\r\n    int t=1;\r\n    cin>>t;\r\n    while(t--){\r\n        solve();\r\n    }\r\n}"
}