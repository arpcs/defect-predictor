{
    "id": 109143885,
    "contestId": 1000,
    "creationTimeSeconds": 1614940808,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1000,
        "index": "G",
        "name": "Two-Paths",
        "type": "PROGRAMMING",
        "rating": 2700,
        "tags": [
            "data structures",
            "dp",
            "trees"
        ]
    },
    "author": {
        "contestId": 1000,
        "members": [
            {
                "handle": "haruki_K"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1530110100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 1060,
    "memoryConsumedBytes": 179916800,
    "source": "// >>> TEMPLATES\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing i32 = int32_t;\r\nusing i64 = int64_t;\r\nusing u32 = uint32_t;\r\nusing u64 = uint64_t;\r\n#define int ll\r\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\r\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\r\n#define repR(i, n) for (int i = (int)(n)-1; i >= 0; i--)\r\n#define rep1R(i, n) for (int i = (int)(n); i >= 1; i--)\r\n#define loop(i, a, B) for (int i = a; i B; i++)\r\n#define loopR(i, a, B) for (int i = a; i B; i--)\r\n#define all(x) begin(x), end(x)\r\n#define allR(x) rbegin(x), rend(x)\r\n#define rng(x, l, r) begin(x) + (l), begin(x) + (r)\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define fst first\r\n#define snd second\r\ntemplate <class A, class B> constexpr auto mp(A &&a, B &&b) { return make_pair(forward<A>(a), forward<B>(b)); }\r\ntemplate <class... T> constexpr auto mt(T&&... x) { return make_tuple(forward<T>(x)...); }\r\ntemplate <class Int> auto constexpr inf_ = numeric_limits<Int>::max()/2-1;\r\nauto constexpr INF32 = inf_<int32_t>;\r\nauto constexpr INF64 = inf_<int64_t>;\r\nauto constexpr INF   = inf_<int>;\r\n#ifdef LOCAL\r\n#include \"debug.hpp\"\r\n#else\r\n#define dump(...) (void)(0)\r\n#define say(x) (void)(0)\r\n#define debug if (0)\r\n#endif\r\ntemplate <class T, class Comp> struct pque : priority_queue<T, vector<T>, Comp> { vector<T> &data() { return this->c; } void clear() { this->c.clear(); } };\r\ntemplate <class T> using pque_max = pque<T, less<T>>;\r\ntemplate <class T> using pque_min = pque<T, greater<T>>;\r\ntemplate <class T, class = typename T::iterator, enable_if_t<!is_same<T, string>::value, int> = 0>\r\nostream& operator<<(ostream& os, T const& a) { bool f = true; for (auto const& x : a) os << (f ? \"\" : \" \") << x, f = false; return os; }\r\ntemplate <class T, size_t N, enable_if_t<!is_same<T, char>::value, int> = 0>\r\nostream& operator<<(ostream& os, const T (&a)[N]) { bool f = true; for (auto const& x : a) os << (f ? \"\" : \" \") << x, f = false; return os; }\r\ntemplate <class T, class = decltype(begin(declval<T&>())), class = typename enable_if<!is_same<T, string>::value>::type>\r\nistream& operator>>(istream& is, T &a) { for (auto& x : a) is >> x; return is; }\r\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T, S> const& p) { return os << p.first << \" \" << p.second; }\r\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T, S>& p) { return is >> p.first >> p.second; }\r\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\r\ntemplate <class F> struct FixPoint : private F {\r\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\r\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\r\n};\r\nstruct MakeFixPoint { template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); } };\r\n#define MFP MakeFixPoint()|\r\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\r\ntemplate <class T, size_t d> struct vec_impl {\r\n    using type = vector<typename vec_impl<T, d-1>::type>;\r\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T, d-1>::make_v(forward<U>(x)...)); }\r\n};\r\ntemplate <class T> struct vec_impl<T, 0> { using type = T; static type make_v(T const& x = {}) { return x; } };\r\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T, d>::type;\r\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T, d>::make_v(forward<Args>(args)...); }\r\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\r\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\r\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\r\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b, e, typename iterator_traits<It>::value_type{}); }\r\ntemplate <class T> int sz(T const& x) { return x.size(); }\r\ntemplate <class C, class T> int lbd(C const& v, T const& x) { return lower_bound(begin(v), end(v), x)-begin(v); }\r\ntemplate <class C, class T> int ubd(C const& v, T const& x) { return upper_bound(begin(v), end(v), x)-begin(v); }\r\nconstexpr int64_t mod(int64_t x, int64_t m) { assert(m > 0); return (x %= m) < 0 ? x+m : x; }\r\nconstexpr int64_t div_floor(int64_t x, int64_t y) { assert(y != 0); return x/y - ((x^y) < 0 and x%y); }\r\nconstexpr int64_t div_ceil(int64_t x, int64_t y) { assert(y != 0); return x/y + ((x^y) > 0 and x%y); }\r\nconstexpr int dx[] = { 1, 0, -1, 0, 1, -1, -1, 1 };\r\nconstexpr int dy[] = { 0, 1, 0, -1, 1, 1, -1, -1 };\r\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\r\nmt19937_64 seed_{random_device{}()};\r\ntemplate <class Int> Int rand(Int a, Int b) { return uniform_int_distribution<Int>(a, b)(seed_); }\r\ni64 irand(i64 a, i64 b) { return rand<i64>(a, b); } // [a, b]\r\nu64 urand(u64 a, u64 b) { return rand<u64>(a, b); } //\r\ntemplate <class It> void shuffle(It l, It r) { shuffle(l, r, seed_); }\r\nvector<int> &operator--(vector<int> &v) { for (int &x : v) --x; return v; }\r\nvector<int> &operator++(vector<int> &v) { for (int &x : v) ++x; return v; }\r\n// <<<\r\n// >>> LCA (RMQ)\r\n#ifndef EDGE_INFO\r\n#define EDGE_INFO\r\nconstexpr int dest(int v) { return v; }\r\ntemplate <class E, class = decltype(declval<E>().to)>\r\nconstexpr int dest(E const& e) { return e.to; }\r\nconstexpr int cost(int) { return 1; }\r\ntemplate <class E, class = decltype(declval<E>().cost)>\r\nconstexpr auto cost(E const& e) { return e.cost; }\r\ntemplate <class E> using cost_t = decltype(cost(declval<E>()));\r\n#endif\r\n\r\ntemplate <class E, class RMQ> struct LCA {\r\n    vector<vector<E>> const* g;\r\n    int32_t n, root;\r\n    vector<int32_t> id;\r\n    vector<cost_t<E>> d;\r\n    RMQ rmq;\r\n    LCA() {}\r\n    LCA(vector<vector<E>> const* g, int root)\r\n        : g(g), n(g->size()), root(root), id(n), d(n) {\r\n        vector<pair<int, int>> a;\r\n        a.reserve(n-1);\r\n        auto dfs = [&](auto dfs, int x, int p, int d0, cost_t<E> d1) -> void {\r\n            id[x] = a.size();\r\n            d[x] = d1;\r\n            for (auto const& e : (*g)[x]) {\r\n                if (dest(e) == p) continue;\r\n                a.emplace_back(d0, x);\r\n                dfs(dfs, dest(e), x, d0 + 1, d1 + cost(e));\r\n            }\r\n        };\r\n        dfs(dfs, root, -1, 0, 0);\r\n        rmq = RMQ(a);\r\n    }\r\n    cost_t<E> dep(int a) const { return d[a]; }\r\n    int operator()(int a, int b) const { return lca(a, b); }\r\n    int lca(int a, int b) const {\r\n        if (a == b) return a;\r\n        if (id[a] > id[b]) swap(a, b);\r\n        return rmq.get(id[a], id[b]).second;\r\n    }\r\n    cost_t<E> dist(int a, int b) const { return d[a] + d[b] - 2*d[lca(a, b)]; }\r\n};\r\n\r\nnamespace RMQ {\r\n// >>> DST\r\ntemplate <class Handler>\r\nstruct DST : Handler {\r\n    using Value = typename Handler::Value;\r\n    using Handler::unit; // () -> Value\r\n    using Handler::merge; // (Value, Value) -> Value\r\n    static constexpr int bsr(int32_t x) { return x ? 31-__builtin_clz(x) : -1; }\r\n\r\n    vector<vector<Value>> v;\r\n    DST() {}\r\n    template <class... T> DST(T&&... x) { build(forward<T>(x)...); }\r\n    void build(int n) { build(n, unit()); }\r\n    void build(int n, Value const& x) { build(n, [&](int) { return x; }); }\r\n    void build(vector<Value> const& v) { build(v.size(), [&](int i) { return v[i]; }); }\r\n    template <class F, class = decltype(declval<F>()(0))>\r\n    void build(int n, F gen)  {\r\n        assert(n >= 0);\r\n        v.resize(1);\r\n        v[0].resize(n, unit());\r\n        for (int i = 0; i < n; i++) v[0][i] = gen(i);\r\n        if (n <= 1) return;\r\n        const int lg = __lg(2*n-1);\r\n        v.resize(lg, vector<Value>(n, unit()));\r\n        for (int h = 1; h < lg; ++h) {\r\n            const int w = 1<<h;\r\n            for (int b = w; b < n; b += (w<<1)) {\r\n                Value x = unit();\r\n                for (int j = b-1; j >= b-w; --j) {\r\n                    v[h][j] = x = merge(v[0][j], x);\r\n                }\r\n                x = unit();\r\n                for (int j = b; j < min(n, b+w); ++j) {\r\n                    v[h][j] = x = merge(x, v[0][j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int size() const { return v.empty() ? 0 : v[0].size(); }\r\n    Value get(int l, int r) const {\r\n        assert(0 <= l); assert(l <= r); assert(r <= size());\r\n        if (l == r) return unit();\r\n        --r;\r\n        if (l == r) return v[0][l];\r\n        const int h = bsr(l^r);\r\n        return merge(v[h][l], v[h][r]);\r\n    }\r\n    Value operator[](int idx) const {\r\n        assert(0 <= idx); assert(idx < size());\r\n        return v[0][idx];\r\n    }\r\n};\r\n// <<<\r\nstruct Min {\r\n    using Value = pair<int, int>;\r\n    static constexpr auto inf = numeric_limits<int>::max();\r\n    constexpr static Value unit() { return { inf, inf }; }\r\n    constexpr static Value merge(Value const& x, Value const& y) { return min(x, y); }\r\n};\r\nusing RMQ = DST<Min>;\r\n}\r\n\r\ntemplate <class E>\r\nauto get_lca(vector<vector<E>> const& g, int root = 0) {\r\n    return LCA<E, RMQ::RMQ>(&g, root);\r\n}\r\n// <<<\r\n// >>> re-rooting\r\n// >>> edge info\r\n#ifndef EDGE_INFO\r\n#define EDGE_INFO\r\nconstexpr int dest(int v) { return v; }\r\ntemplate <class E, class = decltype(declval<E>().to)>\r\nconstexpr int dest(E const& e) { return e.to; }\r\nconstexpr int cost(int) { return 1; }\r\ntemplate <class E, class = decltype(declval<E>().cost)>\r\nconstexpr auto cost(E const& e) { return e.cost; }\r\ntemplate <class E> using cost_t = decltype(cost(declval<E>()));\r\n#endif\r\n// <<<\r\ntemplate <class Handler>\r\nstruct ReRooting : Handler {\r\n    using edge = typename Handler::edge;\r\n    using subs = typename Handler::subs; // subtrees\r\n    using sub = typename Handler::sub; // single subtree\r\n    using Handler::subs_unit; // (int vertex) -> subs\r\n    using Handler::sub_unit; // (int vertex) -> sub\r\n    using Handler::add; // (subs, sub, edge, int vertex) -> subs\r\n    using Handler::merge; // (subs, subs, int vertex) -> sub\r\n\r\n    vector<vector<edge>> const* g;\r\n    vector<sub> dp1, dp2, dp3;\r\n    ReRooting(vector<vector<edge>> const& g)\r\n        : g(&g), dp1(g.size()), dp2(g.size()), dp3(g.size()) {}\r\n    vector<sub> run() {\r\n        assert(g->size());\r\n        dfs1(0, -1);\r\n        dump(dp1);\r\n        dp2[0] = sub_unit(0);\r\n        dfs2(0, -1);\r\n        dump(dp2);\r\n        dump(dp3);\r\n        return dp3;\r\n    }\r\n    void dfs1(int x, int p) {\r\n        subs dat = subs_unit(x);\r\n        for (auto const& e : (*g)[x]) {\r\n            const int y = dest(e);\r\n            if (y == p) continue;\r\n            dfs1(y, x);\r\n            dat = add(dat, dp1[y], e, x);\r\n        }\r\n        dp1[x] = merge(dat, subs_unit(x), x);\r\n    }\r\n    void dfs2(int x, int p) {\r\n        auto const& es = (*g)[x];\r\n        auto d = [&](int i) { return dest(es[i]); };\r\n        const int m = es.size();\r\n        {\r\n            vector<subs> ldp(m+1, subs_unit(x)), rdp(m+1, subs_unit(x));\r\n            for (int i = 0; i < m; i++) {\r\n                sub val = (d(i) == p ? dp2[x] : dp1[d(i)]);\r\n                ldp[i+1] = add(ldp[i], val, es[i], x);\r\n            }\r\n            for (int i = m-1; i >= 0; i--) {\r\n                sub val = (d(i) == p ? dp2[x] : dp1[d(i)]);\r\n                rdp[i] = add(rdp[i+1], val, es[i], x);\r\n            }\r\n            dp3[x] = merge(subs_unit(x), rdp[0], x);\r\n            for (int i = 0; i < m; i++) {\r\n                if (d(i) != p) dp2[d(i)] = merge(ldp[i], rdp[i+1], x);\r\n            }\r\n        }\r\n        for (int i = 0; i < m; i++) if (d(i) != p) dfs2(d(i), x);\r\n    }\r\n};\r\n\r\n// <<<\r\n\r\nstruct edge { int to, cost, val; };\r\nint lift(edge const& e, int dp) {\r\n    return max<int>(0, -2*e.cost + e.val + dp);\r\n}\r\n\r\nstruct Handler {\r\n    using edge = ::edge;\r\n    using sub = int;\r\n    using subs = sub;\r\n    static sub sub_unit(int) { return 0; }\r\n    static subs subs_unit(int x) { return sub_unit(x); }\r\n    static subs add(subs const& x, sub const& y, edge const& e, int) {\r\n        return x + lift(e, y);\r\n    }\r\n    static sub merge(subs const& x, subs const& y, int) {\r\n        return x + y;\r\n    }\r\n};\r\n\r\nint32_t main() {\r\n    int n, q; cin >> n >> q;\r\n    vector<int> a(n); cin >> a;\r\n    vector<vector<edge>> g(n);\r\n    rep (i, n-1) {\r\n        int x, y; cin >> x >> y; --x, --y;\r\n        int c; cin >> c;\r\n        g[x].pb({y, c, a[y]});\r\n        g[y].pb({x, c, a[x]});\r\n    }\r\n    ReRooting<Handler> rr(g);\r\n    rr.run();\r\n\r\n    vector<int> sum_v(n), sum_e(n);\r\n    rep (x, n) sum_v[x] = a[x] + rr.dp3[x];\r\n\r\n    {\r\n        def (dfs, int x, int p) -> void {\r\n            for (auto e : g[x]) {\r\n                auto [y, cost, val] = e;\r\n                edge rev{ x, cost, a[x] };\r\n                if (y == p) continue;\r\n                sum_v[y] += sum_v[x];\r\n                int A = - lift(e, rr.dp1[y]) - lift(rev, rr.dp2[y]) - cost;\r\n                sum_e[y] = sum_e[x] + A;\r\n                dfs(y, x);\r\n            }\r\n        };\r\n        dfs(0, -1);\r\n    }\r\n\r\n    auto lca = get_lca(g);\r\n    rep (_, q) {\r\n        int x, y; cin >> x >> y; x--, y--;\r\n        int z = lca(x, y);\r\n\r\n        int ans = 0;\r\n        ans += sum_v[x] + sum_v[y] - 2*sum_v[z] + a[z] + rr.dp3[z];\r\n        ans += sum_e[x] + sum_e[y] - 2*sum_e[z];\r\n        cout << ans << '\\n';\r\n    }\r\n\r\n}\r\n"
}