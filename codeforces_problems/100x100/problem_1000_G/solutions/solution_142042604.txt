{
    "id": 142042604,
    "contestId": 1000,
    "creationTimeSeconds": 1641696951,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1000,
        "index": "G",
        "name": "Two-Paths",
        "type": "PROGRAMMING",
        "rating": 2700,
        "tags": [
            "data structures",
            "dp",
            "trees"
        ]
    },
    "author": {
        "contestId": 1000,
        "members": [
            {
                "handle": "heno239"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1530110100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 2121,
    "memoryConsumedBytes": 201932800,
    "source": "#pragma GCC optimize(\"O3\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#include<iostream>\r\n#include<string>\r\n#include<cstdio>\r\n#include<vector>\r\n#include<cmath>\r\n#include<algorithm>\r\n#include<functional>\r\n#include<iomanip>\r\n#include<queue>\r\n#include<ciso646>\r\n#include<random>\r\n#include<map>\r\n#include<set>\r\n#include<bitset>\r\n#include<stack>\r\n#include<unordered_map>\r\n#include<unordered_set>\r\n#include<utility>\r\n#include<cassert>\r\n#include<complex>\r\n#include<numeric>\r\n#include<array>\r\n#include<chrono>\r\nusing namespace std;\r\n\r\n//#define int long long\r\ntypedef long long ll;\r\n\r\ntypedef unsigned long long ul;\r\ntypedef unsigned int ui;\r\nconstexpr ll mod = 998244353;\r\nconst ll INF = mod * mod;\r\ntypedef pair<int, int>P;\r\n\r\n#define rep(i,n) for(int i=0;i<n;i++)\r\n#define per(i,n) for(int i=n-1;i>=0;i--)\r\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\r\n#define rep1(i,n) for(int i=1;i<=n;i++)\r\n#define per1(i,n) for(int i=n;i>=1;i--)\r\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\r\n#define all(v) (v).begin(),(v).end()\r\ntypedef pair<ll, ll> LP;\r\n\r\ntemplate<typename T>\r\nvoid chmin(T& a, T b) {\r\n\ta = min(a, b);\r\n}\r\ntemplate<typename T>\r\nvoid chmax(T& a, T b) {\r\n\ta = max(a, b);\r\n}\r\ntemplate<typename T>\r\nvoid cinarray(vector<T>& v) {\r\n\trep(i, v.size())cin >> v[i];\r\n}\r\ntemplate<typename T>\r\nvoid coutarray(vector<T>& v) {\r\n\trep(i, v.size()) {\r\n\t\tif (i > 0)cout << \" \"; cout << v[i];\r\n\t}\r\n\tcout << \"\\n\";\r\n}\r\nll mod_pow(ll x, ll n, ll m = mod) {\r\n\tif (n < 0) {\r\n\t\tll res = mod_pow(x, -n, m);\r\n\t\treturn mod_pow(res, m - 2, m);\r\n\t}\r\n\tif (abs(x) >= m)x %= m;\r\n\tif (x < 0)x += m;\r\n\tif (x == 0)return 0;\r\n\tll res = 1;\r\n\twhile (n) {\r\n\t\tif (n & 1)res = res * x % m;\r\n\t\tx = x * x % m; n >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\nstruct modint {\r\n\tint n;\r\n\tmodint() :n(0) { ; }\r\n\tmodint(ll m) {\r\n\t\tif (m < 0 || mod <= m) {\r\n\t\t\tm %= mod; if (m < 0)m += mod;\r\n\t\t}\r\n\t\tn = m;\r\n\t}\r\n\toperator int() { return n; }\r\n};\r\nbool operator==(modint a, modint b) { return a.n == b.n; }\r\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\r\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\r\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\r\nmodint operator+(modint a, modint b) { return a += b; }\r\nmodint operator-(modint a, modint b) { return a -= b; }\r\nmodint operator*(modint a, modint b) { return a *= b; }\r\nmodint operator^(modint a, ll n) {\r\n\tif (n == 0)return modint(1);\r\n\tmodint res = (a * a) ^ (n / 2);\r\n\tif (n % 2)res = res * a;\r\n\treturn res;\r\n}\r\n\r\nll inv(ll a, ll p) {\r\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\r\n}\r\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\r\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\r\nconst int max_n = 1 << 20;\r\nmodint fact[max_n], factinv[max_n];\r\nvoid init_f() {\r\n\tfact[0] = modint(1);\r\n\tfor (int i = 0; i < max_n - 1; i++) {\r\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\r\n\t}\r\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\r\n\tfor (int i = max_n - 2; i >= 0; i--) {\r\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\r\n\t}\r\n}\r\nmodint comb(int a, int b) {\r\n\tif (a < 0 || b < 0 || a < b)return 0;\r\n\treturn fact[a] * factinv[b] * factinv[a - b];\r\n}\r\nmodint combP(int a, int b) {\r\n\tif (a < 0 || b < 0 || a < b)return 0;\r\n\treturn fact[a] * factinv[a - b];\r\n}\r\n\r\nll gcd(ll a, ll b) {\r\n\ta = abs(a); b = abs(b);\r\n\tif (a < b)swap(a, b);\r\n\twhile (b) {\r\n\t\tll r = a % b; a = b; b = r;\r\n\t}\r\n\treturn a;\r\n}\r\ntypedef long double ld;\r\ntypedef pair<ld, ld> LDP;\r\nconst ld eps = 1e-8;\r\nconst ld pi = acosl(-1.0);\r\nint dx[4] = { 1,0,-1,0 };\r\nint dy[4] = { 0,1,0,-1 };\r\n\r\nusing mP = pair<modint, modint>;\r\n//-----------------------------------\r\n\r\nstruct lcagraph {\r\nprivate:\r\n\tint n;\r\n\tvector<vector<int>> G;\r\n\tvector<vector<int>> parent;\r\n\tvector<int> depth;\r\n\tint root;\r\n\tint tmp;\r\npublic:\r\n\tlcagraph(int n_) {\r\n\t\tn = n_;\r\n\t\tG.resize(n);\r\n\t\tparent.resize(n);\r\n\t\tdepth.resize(n);\r\n\t\ttmp = 0;\r\n\t\tint cop = n;\r\n\t\twhile (cop) {\r\n\t\t\ttmp++; cop /= 2;\r\n\t\t}\r\n\t\trep(i, n)parent[i].resize(tmp);\r\n\t\troot = 0;\r\n\t}\r\n\tlcagraph() {}\r\n\tvoid init(int n_) {\r\n\t\tn = n_;\r\n\t\tG.resize(n);\r\n\t\tparent.resize(n);\r\n\t\tdepth.resize(n);\r\n\t\ttmp = 0;\r\n\t\tint cop = n;\r\n\t\twhile (cop) {\r\n\t\t\ttmp++; cop /= 2;\r\n\t\t}\r\n\t\trep(i, n)parent[i].resize(tmp);\r\n\t\troot = 0;\r\n\t}\r\n\tvoid add_edge(int a, int b) {\r\n\t\tG[a].push_back(b);\r\n\t\tG[b].push_back(a);\r\n\t}\r\n\tvoid dfs(int id, int fr, int d) {\r\n\t\tparent[id][0] = fr;\r\n\t\tdepth[id] = d;\r\n\t\trep(j, G[id].size()) {\r\n\t\t\tint to = G[id][j];\r\n\t\t\tif (to == fr)continue;\r\n\t\t\tdfs(to, id, d + 1);\r\n\t\t}\r\n\t}\r\n\tvoid complete(int r = 0) {\r\n\t\troot = r;\r\n\t\tdfs(root, -1, 0);\r\n\t\trep(j, tmp - 1)rep(i, n) {\r\n\t\t\tif (parent[i][j] < 0)parent[i][j + 1] = -1;\r\n\t\t\telse parent[i][j + 1] = parent[parent[i][j]][j];\r\n\t\t}\r\n\t}\r\n\tint lca(int u, int v) {\r\n\t\tif (depth[u] > depth[v])swap(u, v);\r\n\t\tfor (int k = 0; k < tmp; k++) {\r\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\r\n\t\t\t\tv = parent[v][k];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (u == v)return u;\r\n\t\tfor (int k = tmp - 1; k >= 0; k--) {\r\n\t\t\tif (parent[u][k] != parent[v][k]) {\r\n\t\t\t\tu = parent[u][k];\r\n\t\t\t\tv = parent[v][k];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn parent[u][0];\r\n\t}\r\n\tint dep(int x) {\r\n\t\treturn depth[x];\r\n\t}\r\n\tint dist(int x, int y) {\r\n\t\tint l = lca(x, y);\r\n\t\treturn depth[x] + depth[y] - 2 * depth[l];\r\n\t}\r\n\tint proc_d(int a, int b, int d) {\r\n\t\tint l = lca(a, b);\r\n\t\tint res;\r\n\t\tif (dep(a) - dep(l) >= d) {\r\n\t\t\tres = a;\r\n\t\t\trep(i, tmp) {\r\n\t\t\t\tif (d & (1 << i))res = parent[res][i];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\td = dep(a) + dep(b) - 2 * dep(l) - d;\r\n\t\t\tres = b;\r\n\t\t\trep(i, tmp) {\r\n\t\t\t\tif (d & (1 << i))res = parent[res][i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n};\r\n\r\n\r\nconst int mn = 1 << 19;\r\nll a[mn];\r\nstruct edge {\r\n\tint to; ll cost;\r\n};\r\nusing Data = ll;\r\nvector<edge> G[mn];\r\nvector<int> ids[mn];\r\nvector<Data> memo[mn];\r\nvector<ll> costs[mn];\r\nint root;\r\n\r\nll score[mn];\r\nll d[mn];\r\nData merge(Data a, Data b) {\r\n\tData res;\r\n\t//\r\n\tres = a + b;\r\n\t//\r\n\treturn res;\r\n}\r\n\r\nData dfs(int id, int fr) {\r\n\tData res;\r\n\t//\r\n\t//initialize\r\n\tres = a[id];\r\n\t//\r\n\tfor (edge e : G[id]) {\r\n\t\tif (e.to == fr)continue;\r\n\t\tData nex = dfs(e.to, id);\r\n\t\t//\r\n\t\t//update with edge\r\n\t\tnex = max(nex - 2 * e.cost, 0ll);\r\n\t\t//\r\n\t\tres = merge(res, nex);\r\n\t\tids[id].push_back(e.to);\r\n\t\tmemo[id].push_back(nex);\r\n\t\tcosts[id].push_back(e.cost);\r\n\t\td[e.to] += nex;\r\n\t}\r\n\t//\r\n\t//update for return\r\n\t//\r\n\treturn res;\r\n}\r\n\r\nvoid invdfs(int id, int fr, Data pre) {\r\n\tif (fr >= 0) {\r\n\t\td[id] += pre;\r\n\t}\r\n\tvector<Data> v;\r\n\tfor (Data d : memo[id])v.push_back(d);\r\n\tif (fr >= 0)v.push_back(pre);\r\n\tint len = v.size();\r\n\t//\r\n\t//calcurate id's ans\r\n\tfor (auto d : v)score[id] += d;\r\n\t//\r\n\tvector<Data> le(len + 1);\r\n\tvector<Data> ri(len + 1);\r\n\t//\r\n\tData init_c = 0;\r\n\t//\r\n\tle[0] = init_c;\r\n\trep(i, len) {\r\n\t\tle[i + 1] = merge(le[i], v[i]);\r\n\t}\r\n\tri[len] = init_c;\r\n\tper(i, len) {\r\n\t\tri[i] = merge(ri[i + 1], v[i]);\r\n\t}\r\n\trep(i, ids[id].size()) {\r\n\t\tint to = ids[id][i];\r\n\t\tData d = merge(le[i], ri[i + 1]);\r\n\r\n\t\t//\r\n\t\t//update for return\r\n\t\td += a[id];\r\n\t\td = max(d - 2 * costs[id][i], 0ll);\r\n\t\t//\r\n\t\tinvdfs(to, id, d);\r\n\t}\r\n}\r\nvoid yaru() {\r\n\tdfs(root, -1);\r\n\tinvdfs(root, -1, 0);\r\n}\r\n\r\n\r\nvoid solve() {\r\n\tint n; cin >> n;\r\n\tint q; cin >> q;\r\n\trep(i, n)cin >> a[i];\r\n\tlcagraph lc(n);\r\n\trep(i, n - 1) {\r\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\r\n\t\tG[a].push_back({ b,c });\r\n\t\tG[b].push_back({ a,c });\r\n\t\tlc.add_edge(a, b);\r\n\t}\r\n\tlc.complete();\r\n\tyaru();\r\n\tvector<ll> rs(n);\r\n\tvector<ll> rd(n);\r\n\tvector<ll> rscore(n);\r\n\trscore[0] = score[0];\r\n\tfunction<void(int, int)> dfs = [&](int id, int fr) {\r\n\t\tfor (edge e : G[id])if (e.to != fr) {\r\n\t\t\trs[e.to] = rs[id] + a[e.to] - e.cost;\r\n\t\t\trscore[e.to] = rscore[id] + score[e.to];\r\n\t\t\trd[e.to] = rd[id] + d[e.to];\r\n\t\t\tdfs(e.to, id);\r\n\t\t}\r\n\t};\r\n\tdfs(0, -1);\r\n\tauto query = [&](int x, int y) {\r\n\t\tll res = 0;\r\n\t\tint l = lc.lca(x,y);\r\n\t\tres = rs[x]-rs[l] + rs[y]-rs[l] + a[l];\r\n\t\tres += rscore[x] - rscore[l] + rscore[y] - rscore[l] + score[l];\r\n\t\tres -= rd[x] - rd[l] + rd[y] - rd[l];\r\n\t\treturn res;\r\n\t};\r\n\trep(i, q) {\r\n\t\tint x, y; cin >> x >> y; x--; y--;\r\n\t\tcout << query(x, y) << \"\\n\";\r\n\t}\r\n}\r\n\r\n\r\nsigned main() {\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout << fixed << setprecision(10);\r\n\t//init_f();\r\n\t//init();\r\n\t//while(true)\r\n\t//expr();\r\n\t//int t; cin >> t; rep(i, t)\r\n\tsolve();\r\n\treturn 0;\r\n}\r\n\r\n\r\n"
}