{
    "id": 39884305,
    "contestId": 14,
    "creationTimeSeconds": 1530596461,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 14,
        "index": "C",
        "name": "Four Segments",
        "type": "PROGRAMMING",
        "rating": 1700,
        "tags": [
            "brute force",
            "constructive algorithms",
            "geometry",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 14,
        "members": [
            {
                "handle": "Tarun"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1274283000
    },
    "programmingLanguage": "Java 8",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 808,
    "memoryConsumedBytes": 56012800,
    "source": "import java.util.*;\n\nimport org.omg.CORBA.INTERNAL;\n\nimport java.awt.List;\nimport java.io.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\n\t\npublic class code1\n\t{\n \n\t\tpublic static int mx = 1228228;\n\t\tpublic static long[][] dp = new long[mx][21];\n\t\tpublic static long[] a = new long[mx];\n\t\tpublic static long[] b = new long[mx];\n\t\t\n\t\tpublic static void main(String[] args)\n\t\t{\n\t\t\tInputReader in = new InputReader(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\t\n\t\t\t//Code starts..\n\t\t\n\t\t\n\t\t\t\n\t\t\tArrayList<Long> list = new ArrayList<>();\n\t\t\tfor(int i=0; i<10; i++)\n\t\t\t\tlist.add((long)i+2);\n\t\t\tpw.println(lowerbound(list, (long)0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//Code ends....\n\t\t\t\n\t\t\tpw.flush();\n\t\t\tpw.close();\n\t\t}\n\t\t  \n\t\t\n\t\n\t\t\n\n\t\tstatic class InputReader \n\t\t{\n\t\t\t \n\t\t\tprivate final InputStream stream;\n\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\tprivate int curChar, snumChars;\n\t\t\tprivate SpaceCharFilter filter;\n\t \n\t\t\tpublic InputReader(InputStream stream) \n\t\t\t{\n\t\t\t\tthis.stream = stream;\n\t\t\t}\n\t \n\t\t\tpublic int snext() \n\t\t\t{\n\t\t\t\tif (snumChars == -1)\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tif (curChar >= snumChars) \n\t\t\t\t{\n\t\t\t\t\tcurChar = 0;\n\t\t\t\t\ttry \n\t\t\t\t\t{\n\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t} \n\t\t\t\t\tcatch (IOException e) \n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t}\n\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn buf[curChar++];\n\t\t\t}\n\t \n\t\t\tpublic int nextInt() \n\t\t    {\n\t\t\t\tint c = snext();\n\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tc = snext();\n\t\t\t\t}\n\t\t\t\tint sgn = 1;\n\t\t\t\tif (c == '-')\n\t\t\t    {\n\t\t\t\t\tsgn = -1;\n\t\t\t\t\tc = snext();\n\t\t\t\t}\n\t\t\t\tint res = 0;\n\t\t\t\tdo \n\t\t\t\t{\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = snext();\n\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t\t}\n\t \n\t\t\tpublic long nextLong()\n\t\t    {\n\t\t\t\tint c = snext();\n\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tc = snext();\n\t\t\t\t}\n\t\t\t\tint sgn = 1;\n\t\t\t\tif (c == '-') \n\t\t\t\t{\n\t\t\t\t\tsgn = -1;\n\t\t\t\t\tc = snext();\n\t\t\t\t}\n\t\t\t\tlong res = 0;\n\t\t\t\tdo \n\t\t\t\t{\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = snext();\n\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t\t}\n\t \n\t\t\tpublic int[] nextIntArray(int n) \n\t\t\t{\n\t\t\t\tint a[] = new int[n];\n\t\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\t{\n\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\t \n\t\t\tpublic String readString()\n\t\t    {\n\t\t\t\tint c = snext();\n\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tc = snext();\n\t\t\t\t}\n\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\tdo \n\t\t\t\t{\n\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\tc = snext();\n\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\treturn res.toString();\n\t\t\t}\n\t \n\t\t\tpublic String nextLine() \n\t\t\t{\n\t\t\t\tint c = snext();\n\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\tc = snext();\n\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\tdo \n\t\t\t\t{\n\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\tc = snext();\n\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\treturn res.toString();\n\t\t\t}\n\t \n\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t{\n\t\t\t\tif (filter != null)\n\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t}\n\t \n\t\t\tprivate boolean isEndOfLine(int c) \n\t\t\t{\n\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t}\n\t \n\t\t\tpublic interface SpaceCharFilter\n\t\t    {\n\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t}\n\t\t}\n\t\tpublic static long c = 0;\n\t\t\n\t\tpublic static long mod = 1000000007;\n\t\tpublic static int d;\n\t\tpublic static int p;\n\t\tpublic static int q;\n\t\tpublic static boolean flag;\n\t\tpublic static long INF= Long.MAX_VALUE;\n\t\t\n\t\tpublic static long fun(int[] a, int[] b, int m,int n) {\n\t\t\tlong result =0;\n\t\t\tfor(int i=0; i<m; i++)\n\t\t\t\tfor(int j=0; j<m; j++)\n\t\t\t\t{\n\t\t\t\t\tlong[] fib  = new long[Math.max(2, n+2)];\n\t\t\t\t\tfib[1] = a[i];\n\t\t\t\t\tfib[2] = b[j];\n\t\t\t\t\tfor(int k=3; k<=n; k++)\n\t\t\t\t\t\tfib[k] = (fib[k-1]%mod + fib[k-2]%mod)%mod;\n\t\t\t\t\tresult = (result%mod + fib[n]%mod)%mod;\n\t\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic static double slope(pair p1, pair p2)\n\t\t{\n\t\t\tdouble m = INF;\n\t\t\tif((p1.x - p2.x)!=0)\n\t\t\tm =  (p1.y - p2.y)/(p1.x - p2.x); \n\t\t\t\n\t\t\t\n\t\t\treturn Math.abs(m);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int count(String[] s, int f)\n\t\t{\n\t\t\tint count = 0;\n\t\t\tint n = s[0].length();\n\t\t\t\n\t\t\tif(f==1)\n\t\t\t{\n\t\t\tfor(int i = 0; i<n; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\t{\n\t\t\t\t\tif(i%2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j%2==0 && s[i].charAt(j)=='0')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(j%2==1 && s[i].charAt(j)=='1')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j%2==1 && s[i].charAt(j)=='0')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(j%2==0 && s[i].charAt(j)=='1')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\n\t\t\t count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i<n; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\t{\n\t\t\t\t\tif(i%2==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j%2==0 && s[i].charAt(j)=='0')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(j%2==1 && s[i].charAt(j)=='1')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j%2==1 && s[i].charAt(j)=='0')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(j%2==0 && s[i].charAt(j)=='1')\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n \n\t\t\t}\t\n\t\t\t\t\n\t\t\n\t\t\treturn count;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\t\t\n\t\tpublic static  int gcd(int p2, int p22)\n\t\t{\n\t\t    if (p2 == 0)\n\t\t        return (int) p22;\n\t\t    return gcd(p22%p2, p2);\n\t\t}\n\t\t\n\t\t\t\n\t\n\t\t\n\t\t\n\t\tpublic static int findGCD(int arr[], int n)\n\t\t{\n\t\t    int result = arr[0];\n\t\t    for (int i=1; i<n; i++)\n\t\t        result = gcd(arr[i], result);\n\t\t \n\t\t    return result;\n\t\t}\n\t\t\n\t\n \n\t\tpublic static void nextGreater(long[] a, int[] ans)\n\t\t{\n\t\t\t\n\t\t\tStack<Integer> stk = new Stack<>();\n\t\t\tstk.push(0);\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=1; i<a.length; i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(!stk.isEmpty())\n\t\t\t\t{\n\t\t\t\tint s = stk.pop();\n\t\t\t\twhile(a[s]<a[i])\n\t\t\t\t{\n\t\t\t\t\tans[s] = i;\n\t\t\t\t\tif(!stk.isEmpty())\n\t\t\t\t\t\ts = stk.pop();\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(a[s]>=a[i])\n\t\t\t\t\tstk.push(s);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstk.push(i);\n\t\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void nextGreaterRev(long[] a, int[] ans)\n\t\t{\n\t\t\t\n\t\t\tint n = a.length;\n\t\t\tint[] pans = new int[n];\n\t\t\tArrays.fill(pans, -1);\n\t\t\tlong[] arev = new long[n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tarev[i] = a[n-1-i];\n\t\t\t\n\t\t\tStack<Integer> stk = new Stack<>();\n\t\t\tstk.push(0);\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=1; i<n; i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(!stk.isEmpty())\n\t\t\t\t{\n\t\t\t\tint s = stk.pop();\n\t\t\t\twhile(arev[s]<arev[i])\n\t\t\t\t{\n\t\t\t\t\tpans[s] = n - i-1;\n\t\t\t\t\tif(!stk.isEmpty())\n\t\t\t\t\t\ts = stk.pop();\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(arev[s]>=arev[i])\n\t\t\t\t\tstk.push(s);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstk.push(i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//for(int i=0; i<n; i++)\n\t\t\t\t//System.out.print(pans[i]+\" \");\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tans[i] = pans[n-i-1];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void nextSmaller(long[] a, int[] ans)\n\t\t{\n\t\t\t\n\t\t\tStack<Integer> stk = new Stack<>();\n\t\t\tstk.push(0);\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=1; i<a.length; i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(!stk.isEmpty())\n\t\t\t\t{\n\t\t\t\tint s = stk.pop();\n\t\t\t\twhile(a[s]>a[i])\n\t\t\t\t{\n\t\t\t\t\tans[s] = i;\n\t\t\t\t\tif(!stk.isEmpty())\n\t\t\t\t\t\ts = stk.pop();\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(a[s]<=a[i])\n\t\t\t\t\tstk.push(s);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstk.push(i);\n\t\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t    public static long lcm(int[] numbers) {\n\t        long lcm = 1;\n\t        int divisor = 2;\n\t        while (true) {\n\t            int cnt = 0;\n\t            boolean divisible = false;\n\t            for (int i = 0; i < numbers.length; i++) {\n\t                if (numbers[i] == 0) {\n\t                    return 0;\n\t                } else if (numbers[i] < 0) {\n\t                    numbers[i] = numbers[i] * (-1);\n\t                }\n\t                if (numbers[i] == 1) {\n\t                    cnt++;\n\t                }\n\t                if (numbers[i] % divisor == 0) {\n\t                    divisible = true;\n\t                    numbers[i] = numbers[i] / divisor;\n\t                }\n\t            }\n\t            if (divisible) {\n\t                lcm = lcm * divisor;\n\t            } else {\n\t                divisor++;\n\t            }\n\t            if (cnt == numbers.length) {\n\t                return lcm;\n\t            }\n\t        }\n\t    }\n\t\tpublic static long fact(long n) {\n\t\t\t\n\t\t\tlong factorial = 1;\n\t\t\t for(int i = 1; i <= n; i++)\n\t\t        {\n\t\t            factorial *= i;\n\t\t        }\n\t\t\t return factorial;\n\t\t}\n\t\t\npublic static void factSieve(int[] a, int n) {\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=2; i<=n; i+=2)\n\t\t\t\ta[i] = 2;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=3; i<=n; i+=2)\n\t\t\t{\n\t\t\t\tif(a[i]==0)\n\t\t\t\t{\n\t\t\t\t\ta[i] = i;\n\t\t\t\t\t\n\t\t\t\t\tfor(int j=i; j*i<=n; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i*j] = i;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint k = 1000;\n\t\t\twhile(k!=1)\n\t\t\t{\n\t\t\t\tSystem.out.print(a[k]+\" \");\n\t\t\t\tk /= a[k];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\tpublic static int lowerLimit(int[] a, int n) {\n\t\t\tint ans = 0;\n\t\t\t\n\t\t\tint ll = 0;\n\t\t\tint rl = a.length-1;\n\t\t//\tSystem.out.println(a[rl]+\" \"+n);\n\t\t\tif(a[0]>n)\n\t\t\t\treturn 0;\n\t\t\tif(a[0]==n)\n\t\t\t\treturn 1;\n\t\t\telse if(a[rl]<=n)\n\t\t\t\treturn rl+1;\n\t\t\n\t\t\twhile(ll<=rl)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tint mid = (ll+rl)/2;\n\t\t\t\tif(a[mid]==n)\n\t\t\t\t{\n\t\t\t\t\tans = mid + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if(a[mid]>n)\n\t\t\t\t{\n\t\t\t\t\trl = mid-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans = mid+1;\n\t\t\t\t\tll = mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ans; \n\t\t}\n\t\t\n\t\t\n\t\tpublic static long choose(long total, long choose){\n\t\t    if(total < choose)\n\t\t        return 0;\n\t\t    if(choose == 0 || choose == total)\n\t\t        return 1;\n\t\t    return (choose(total-1,choose-1)+choose(total-1,choose))%mod;\n\t\t}\n\t\t\n\t\tpublic static int[] suffle(int[] a,Random gen)\n\t\t{\n\t\t\tint n = a.length;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\tint temp = a[ind];\n\t\t\t\ta[ind] = a[i];\n\t\t\t\ta[i] = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tpublic static long[] sort(long[] a)\n\t\t{\n\t\t\tRandom gen = new Random();\n\t\t\tint n = a.length;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\tlong temp = a[ind];\n\t\t\t\ta[ind] = a[i];\n\t\t\t\ta[i] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tpublic static pair[] sort(pair[] a)\n\t\t{\n\t\t\tRandom gen = new Random();\n\t\t\tint n = a.length;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\tpair temp = a[ind];\n\t\t\t\ta[ind] = a[i];\n\t\t\t\ta[i] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int[] sort(int[] a)\n\t\t{\n\t\t\tRandom gen = new Random();\n\t\t\tint n = a.length;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\t\tint temp = a[ind];\n\t\t\t\ta[ind] = a[i];\n\t\t\t\ta[i] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tpublic static int floorSearch(int arr[], int low, int high, int x)\n\t\t{\n\t\t    if (low > high)\n\t\t        return -1;\n\t\t \n\t\t    if (x > arr[high])\n\t\t        return high;\n\t\t    int mid = (low+high)/2;\n\t\t \n\t\t \n\t\t    if (mid > 0 && arr[mid-1] < x && x < arr[mid])\n\t\t        return mid-1;\n\t\t \n\t\t    if (x < arr[mid])\n\t\t        return floorSearch(arr, low, mid-1, x);\n\t\t \n\t\t    return floorSearch(arr, mid+1, high, x);\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void swap(int a, int b){\n\t\t\tint temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\tpublic static ArrayList<Integer> primeFactorization(int n)\n\t\t{\n\t\t\tArrayList<Integer> a =new ArrayList<Integer>();\n\t\t\tfor(int i=2;i*i<=n;i++)\n\t\t\t{\n\t\t\t\twhile(n%i==0)\n\t\t\t\t{\n\t\t\t\t\ta.add(i);\n\t\t\t\t\tn/=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n!=1)\n\t\t\t\ta.add(n);\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void sieve(boolean[] isPrime,int n)\n\t\t{\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\tisPrime[i] = true;\n\t\t\t\n\t\t\tisPrime[0] = false;\n\t\t\tisPrime[1] = false;\n\t\t\t\n\t\t\tfor(int i=2;i*i<n;i++)\n\t\t\t{\n\t\t\t\tif(isPrime[i] == true)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=(2*i);j<n;j+=i)\n\t\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static int lowerbound(ArrayList<Long> net, long c2) {\n\t\t\tint i=Collections.binarySearch(net, c2);\n\t\t\tif(i<0)\n\t\t\t\ti = -(i+2);\n\t\t\treturn i;\n\t\t\t\n\t\t\t\n\t\t}\n\t\n\t\tpublic static int lowerboundArray(long[] psum, long c2) {\n\t\t\tint i=Arrays.binarySearch(psum, c2);\n\t\t\tif(i<0)\n\t\t\t\ti = -(i+2);\n\t\t\treturn i;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static int lowerboundArray(int[] psum, int c2) {\n\t\t\tint i=Arrays.binarySearch(psum, c2);\n\t\t\tif(i<0)\n\t\t\t\ti = -(i+2);\n\t\t\treturn i;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int uperboundArray(long[] psum, long c2) {\n\t\t\tint i=Arrays.binarySearch(psum, c2);\n\t\t\tif(i<0)\n\t\t\t\ti = -(i+1);\n\t\t\treturn i;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int uperbound(ArrayList<Long> net, long c2) {\n\t\t\tint i=Collections.binarySearch(net, c2);\n\t\t\tif(i<0)\n\t\t\t\ti = -(i+1);\n\t\t\treturn i;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int GCD(int a,int b)\n\t\t{\n\t\t\tif(b==0)\n\t\t\t\treturn a;\n\t\t\telse\n\t\t\t\treturn GCD(b,a%b);\n\t\t}\n\t\t\n\t\tpublic static long GCD(long a,long b)\n\t\t{\n\t\t\tif(b==0)\n\t\t\t\treturn a;\n\t\t\telse\n\t\t\t\treturn GCD(b,a%b);\n\t\t}\n\t\t\n\t\tpublic static void extendedEuclid(int A,int B)\n\t\t{\n\t\t\tif(B==0)\n\t\t\t{\n\t\t\t\td = A;\n\t\t\t\tp = 1 ;\n\t\t\t\tq = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textendedEuclid(B, A%B);\n\t\t\t\tint temp = p;\n\t\t\t\tp = q;\n\t\t\t\tq = temp - (A/B)*q;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static long LCM(long a,long b)\n\t\t{\n\t\t\treturn (a*b)/GCD(a,b);\n\t\t}\n\t\t\n\t\tpublic static int LCM(int a,int b)\n\t\t{\n\t\t\treturn (a*b)/GCD(a,b);\n\t\t}\n\t\t\n\t\tpublic static int binaryExponentiation(int x,int n)\n\t\t{\n\t\t    int result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=result * x;\n\t\t        x=x*x;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int[] countDer(int n)\n\t    {\n\t        int der[] = new int[n + 1];\n\t     \n\t        der[0] = 1;\n\t        der[1] = 0;\n\t        der[2] = 1;\n\t     \n\t        for (int i = 3; i <= n; ++i)\n\t            der[i] = (i - 1) * (der[i - 1] + der[i - 2]);\n\t     \n\t        // Return result for n\n\t        return der;\n\t    }\n\t\t\n\t\t\n\t\t static long binomialCoeff(int n, int k)\n\t\t    {\n\t\t    long C[][] = new long[n+1][k+1];\n\t\t    int i, j;\n\t\t     \n\t\t        // Calculate  value of Binomial Coefficient in bottom up manner\n\t\t    for (i = 0; i <= n; i++)\n\t\t    {\n\t\t        for (j = 0; j <= Math.min(i, k); j++)\n\t\t        {\n\t\t            // Base Cases\n\t\t            if (j == 0 || j == i)\n\t\t                C[i][j] = 1;\n\t\t      \n\t\t            // Calculate value using previosly stored values\n\t\t            else\n\t\t                C[i][j] = C[i-1][j-1] + C[i-1][j];\n\t\t          }\n\t\t     }\n\t\t      \n\t\t    return C[n][k];\n\t\t    }\n\t\t\n\t\tpublic static long binaryExponentiation(long x,long n)\n\t\t{\n\t\t    long result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=result * x;\n\t\t        x=(x%mod * x%mod)%mod;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static int modularExponentiation(int x,int n,int M)\n\t\t{\n\t\t    int result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=(result * x)%M;\n\t\t        x=(x%M*x%M)%M;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static long modularExponentiation(long x,long n,long M)\n\t\t{\n\t\t    long result=1;\n\t\t    while(n>0)\n\t\t    {\n\t\t        if(n % 2 ==1)\n\t\t            result=(result %M* x%M)%M;\n\t\t        x=(x*x)%M;\n\t\t        n=n/2;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\t\n\t\tpublic static int modInverse(int A,int M)\n\t\t{\n\t\t    return modularExponentiation(A,M-2,M);\n\t\t}\n\t\t\n\t\tpublic static long modInverse(long A,long M)\n\t\t{\n\t\t    return modularExponentiation(A,M-2,M);\n\t\t}\n\t\t\n\t\t\n\t\tpublic static boolean checkYear(int year)\n\t    {\n\t\t\tif (year % 400 == 0)\n\t            return true;\n\t     \n\t        if (year % 100 == 0)\n\t            return false;\n\t     \n\t        if (year % 4 == 0)\n\t            return true;\n\t        return false;\n\t    }\n\t\t\n\t\tpublic static boolean isPrime(int n)\n\t\t{\n\t\t    \n\t\t    if (n <= 1)  return false;\n\t\t    if (n <= 3)  return true;\n\t\t    \n\t\t    if (n%2 == 0 || n%3 == 0) \n\t\t    \treturn false;\n\t\t \n\t\t    for (int i=5; i*i<=n; i=i+6)\n\t\t    {\n\t\t        if (n%i == 0 || n%(i+2) == 0)\n\t\t           return false;\n\t\t    }\n\t\t    \n\t\t    return true;\n\t\t}\n\t\t\n\t\tstatic class pair implements Comparable<pair>\n \n\t\t{\n\t\t\tLong x;\n\t\t\tLong y;\n\t\t\tpair(long a,long l)\n\t\t\t{\n\t\t\t\tthis.x=a;\n\t\t\t\tthis.y=l;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int compareTo(pair o) {\n\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\tif(result==0)\n\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}  \n\t\t\t\n\t\t\tpublic String toString()\n\t\t\t{\n\t\t\t\treturn x+\" \"+y;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean equals(Object o)\n\t\t\t{\n\t\t\t\tif (o instanceof pair)\n\t\t\t    {\n\t\t\t\t\tpair p = (pair)o;\n\t\t\t\t\treturn p.x == x && p.y == y ;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int hashCode()\n\t\t\t{\n\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\tstatic class triplet implements Comparable<triplet>\n\t\t{\n\t\t\tLong x,y;\n\t\t\tInteger z;\n\t\t\ttriplet(long l,long m,int z)\n\t\t\t{\n\t\t\t\tthis.x = l;\n\t\t\t\tthis.y = m;\n\t\t\t\tthis.z = z;\n\t\t\t}\n\t\t\t\n\t\t\tpublic  int compareTo(triplet o)\n\t\t\t{\n\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\tif(result==0)\n\t\t\t\t\tresult =  y.compareTo(o.y);\n\t\t\t\tif(result==0)\n\t\t\t\t\tresult = z.compareTo(o.z);\n \n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean equlas(Object o)\n\t\t\t{\n\t\t\t\tif(o instanceof triplet)\n\t\t\t\t{\n\t\t\t\t\ttriplet p = (triplet)o;\n\t\t\t\t\treturn x==p.x && y==p.y && z==p.z;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic String toString()\n\t\t\t{\n\t\t\t\treturn x+\" \"+y+\" \"+z;\n\t\t\t}\n\t\t\tpublic int hashCode()\n\t\t\t{\n\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode() + new Long(z).hashCode(); \n\t\t\t}\n\t\t}\n\t\t\n \n\t\t\n\t\t\n\t\t\n\t\n\t\t/*static class node implements Comparable<node>\n \n\t\t{\n\t\t\tInteger x, y, z;\n\t\t\tnode(int x,int y, int z)\n\t\t\t{\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int compareTo(pair o) {\n\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\tif(result==0)\n\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\tif(result==0)\n\t\t\t\t\tresult = z.compareTo(z); \n\t\t\t\treturn result;\n\t\t\t}\n \n\t\t\t@Override\n\t\t\tpublic int compareTo(node o) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\treturn 0;\n\t\t\t}  \n\t\t}\n\t\t*/\n\t}\n\t\n\t\t"
}