{
    "id": 160994582,
    "contestId": 1627,
    "creationTimeSeconds": 1655496197,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1627,
        "index": "E",
        "name": "Not Escaping",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "shortest paths",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1627,
        "members": [
            {
                "handle": "pc_invader"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1642257300
    },
    "programmingLanguage": "Java 11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 62,
    "timeConsumedMillis": 608,
    "memoryConsumedBytes": 37785600,
    "source": "//Utilities\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class a {\r\n\tstatic int t;\r\n\tstatic int n, m, k;\r\n\tstatic int a, b, c, d, h;\r\n\tstatic long[] x;\r\n\tstatic ArrayList<Ladder>[] start;\r\n\tstatic TreeMap<Integer, Long>[] dp;\r\n\tstatic long res;\r\n\t\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tt = in.iscan();\r\n\t\touter : while (t-- > 0) {\r\n\t\t\tn = in.iscan(); m = in.iscan(); k = in.iscan();\r\n\t\t\tx = new long[n+1];\r\n\t\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\t\tx[i] = in.lscan();\r\n\t\t\t}\r\n\t\t\tstart = new ArrayList[n+1];\r\n\t\t\tdp = new TreeMap[n+1];\r\n\t\t\tfor (int i = 0; i <= n; i++) {\r\n\t\t\t\tstart[i] = new ArrayList<Ladder>();\r\n\t\t\t\tdp[i] = new TreeMap<Integer, Long>();\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < k; i++) {\r\n\t\t\t\ta = in.iscan(); b = in.iscan(); c = in.iscan(); d = in.iscan(); h = in.iscan();\r\n\t\t\t\tstart[a].add(new Ladder(b, c, d, h));\r\n\t\t\t\tdp[c].put(d, Long.MAX_VALUE);\r\n\t\t\t}\r\n\t\t\tdp[1].put(1, 0L);\r\n\t\t\tres = Long.MAX_VALUE;\r\n\t\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\t\tCollections.sort(start[i]);\r\n\t\t\t\tif (dp[i].isEmpty()) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tInteger tmp = dp[i].firstKey();\r\n\t\t\t\twhile (tmp != null) {\r\n\t\t\t\t\tif (dp[i].get(tmp) == Long.MAX_VALUE) {\r\n\t\t\t\t\t\tdp[i].remove(tmp);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttmp = dp[i].higherKey(tmp);\r\n\t\t\t\t}\r\n\t\t\t\tif (dp[i].isEmpty()) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (i == n) {\r\n\t\t\t\t\tInteger nxt = dp[i].firstKey();\r\n\t\t\t\t\twhile (nxt != null) {\r\n\t\t\t\t\t\tif (dp[i].get(nxt) != Long.MAX_VALUE) {\r\n\t\t\t\t\t\t\tres = Math.min(res, dp[i].get(nxt) + x[i] * Math.abs(m - nxt));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnxt = dp[i].higherKey(nxt);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tint sz = dp[i].size();\r\n\t\t\t\t\tint prev = dp[i].firstKey();\r\n\t\t\t\t\tfor (int j = 1; j < sz; j++) {\r\n\t\t\t\t\t\tint cur = dp[i].higherKey(prev);\r\n\t\t\t\t\t\tif (dp[i].get(prev) + x[i] * Math.abs(cur - prev) < dp[i].get(cur)) {\r\n\t\t\t\t\t\t\tdp[i].put(cur, dp[i].get(prev) + x[i] * Math.abs(cur - prev));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tprev = cur;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tint nxt = dp[i].lastKey();\r\n\t\t\t\t\tfor (int j = sz-2; j >= 0; j--) {\r\n\t\t\t\t\t\tint cur = dp[i].lowerKey(nxt);\r\n\t\t\t\t\t\tif (dp[i].get(nxt) + x[i] * Math.abs(nxt - cur) < dp[i].get(cur)) {\r\n\t\t\t\t\t\t\tdp[i].put(cur, dp[i].get(nxt) + x[i] * Math.abs(nxt - cur));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnxt = cur;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (Ladder l : start[i]) {\r\n\t\t\t\t\t\tint col = l.col, nextRow = l.nextRow, nextCol = l.nextCol, h = l.h;\r\n\t\t\t\t\t\tInteger _prev = dp[i].floorKey(col);\r\n\t\t\t\t\t\tInteger _nxt = dp[i].ceilingKey(col);\r\n\t\t\t\t\t\tif (_prev != null) {\r\n\t\t\t\t\t\t\tdp[nextRow].put(nextCol, \r\n\t\t\t\t\t\t\t\t\tMath.min(dp[nextRow].get(nextCol), dp[i].get(_prev) + x[i] * Math.abs(col - _prev) - h));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (_nxt != null) {\r\n\t\t\t\t\t\t\tdp[nextRow].put(nextCol, \r\n\t\t\t\t\t\t\t\t\tMath.min(dp[nextRow].get(nextCol), dp[i].get(_nxt) + x[i] * Math.abs(col - _nxt) - h));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (res != Long.MAX_VALUE) out.println(res);\r\n\t\t\telse out.println(\"NO ESCAPE\");\r\n\t\t}\r\n\t\tout.close();\r\n\t}\r\n\t\r\n\tstatic class Pair {\r\n\t\tint r, c;\r\n\t\tPair(int r, int c){\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.c = c;\r\n\t\t}\r\n\t\tpublic int hashCode() { return Objects.hash(r, c); }\r\n\t\tpublic boolean equals(Object o) {\r\n\t\t\tPair p = (Pair)o;\r\n\t\t\treturn r == p.r && c == p.c;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic class Ladder implements Comparable<Ladder>{\r\n\t\tint col, nextRow, nextCol, h;\r\n\t\tLadder(int col, int nextRow, int nextCol, int h){\r\n\t\t\tthis.col = col;\r\n\t\t\tthis.nextRow = nextRow;\r\n\t\t\tthis.nextCol = nextCol;\r\n\t\t\tthis.h = h;\r\n\t\t}\r\n\t\tpublic int compareTo(Ladder l) {\r\n\t\t\treturn col - l.col;\r\n\t\t}\r\n\t}\r\n\t \r\n\tstatic INPUT in = new INPUT(System.in);\r\n\tstatic PrintWriter out = new PrintWriter(System.out);\r\n\tprivate static class INPUT {\r\n\r\n\t\tprivate InputStream stream;\r\n\t\tprivate byte[] buf = new byte[1024];\r\n\t\tprivate int curChar, numChars;\r\n\r\n\t\tpublic INPUT (InputStream stream) {\r\n\t\t\tthis.stream = stream;\r\n\t\t}\r\n\r\n\t\tpublic INPUT (String file) throws IOException {\r\n\t\t\tthis.stream = new FileInputStream (file);\r\n\t\t}\r\n\r\n\t\tpublic int cscan () throws IOException {\r\n\t\t\tif (curChar >= numChars) {\r\n\t\t\t\tcurChar = 0;\r\n\t\t\t\tnumChars = stream.read (buf);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (numChars == -1)\r\n\t\t\t\treturn numChars;\r\n\r\n\t\t\treturn buf[curChar++];\r\n\t\t}\r\n\r\n\t\tpublic int iscan () throws IOException {\r\n\t\t\tint c = cscan (), sgn = 1;\r\n\t\t\t\r\n\t\t\twhile (space (c))\r\n\t\t\t\tc = cscan ();\r\n\r\n\t\t\tif (c == '-') {\r\n\t\t\t\tsgn = -1;\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\r\n\t\t\tint res = 0;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tres = (res << 1) + (res << 3);\r\n\t\t\t\tres += c - '0';\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\t\t\twhile (!space (c));\r\n\r\n\t\t\treturn res * sgn;\r\n\t\t}\r\n\r\n\t\tpublic String sscan () throws IOException {\r\n\t\t\tint c = cscan ();\r\n\t\t\t\r\n\t\t\twhile (space (c))\r\n\t\t\t\tc = cscan ();\r\n\r\n\t\t\tStringBuilder res = new StringBuilder ();\r\n\r\n\t\t\tdo {\r\n\t\t\t\tres.appendCodePoint (c);\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\t\t\twhile (!space (c));\r\n\r\n\t\t\treturn res.toString ();\r\n\t\t}\r\n\r\n\t\tpublic double dscan () throws IOException {\r\n\t\t\tint c = cscan (), sgn = 1;\r\n\t\t\t\r\n\t\t\twhile (space (c))\r\n\t\t\t\tc = cscan ();\r\n\r\n\t\t\tif (c == '-') {\r\n\t\t\t\tsgn = -1;\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\r\n\t\t\tdouble res = 0;\r\n\r\n\t\t\twhile (!space (c) && c != '.') {\r\n\t\t\t\tif (c == 'e' || c == 'E')\r\n\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\r\n\t\t\t\t\r\n\t\t\t\tres *= 10;\r\n\t\t\t\tres += c - '0';\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\r\n\t\t\tif (c == '.') {\r\n\t\t\t\tc = cscan ();\r\n\t\t\t\tdouble m = 1;\r\n\r\n\t\t\t\twhile (!space (c)) {\r\n\t\t\t\t\tif (c == 'e' || c == 'E')\r\n\t\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\r\n\r\n\t\t\t\t\tm /= 10;\r\n\t\t\t\t\tres += (c - '0') * m;\r\n\t\t\t\t\tc = cscan ();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn res * sgn;\r\n\t\t}\r\n\r\n\t\tpublic long lscan () throws IOException {\r\n\t\t\tint c = cscan (), sgn = 1;\r\n\t\t\t\r\n\t\t\twhile (space (c))\r\n\t\t\t\tc = cscan ();\r\n\r\n\t\t\tif (c == '-') {\r\n\t\t\t\tsgn = -1;\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\r\n\t\t\tlong res = 0;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tres = (res << 1) + (res << 3);\r\n\t\t\t\tres += c - '0';\r\n\t\t\t\tc = cscan ();\r\n\t\t\t}\r\n\t\t\twhile (!space (c));\r\n\r\n\t\t\treturn res * sgn;\r\n\t\t}\r\n\r\n\t\tpublic boolean space (int c) {\r\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static class UTILITIES {\r\n\r\n\t\tstatic final double EPS = 10e-6;\r\n\t\t\r\n\t\tpublic static void sort(int[] a, boolean increasing) {\r\n\t\t\tArrayList<Integer> arr = new ArrayList<Integer>();\r\n\t\t\tint n = a.length;\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tarr.add(a[i]);\r\n\t\t\t}\r\n\t\t\tCollections.sort(arr);\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tif (increasing) {\r\n\t\t\t\t\ta[i] = arr.get(i);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta[i] = arr.get(n-1-i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic static void sort(long[] a, boolean increasing) {\r\n\t\t\tArrayList<Long> arr = new ArrayList<Long>();\r\n\t\t\tint n = a.length;\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tarr.add(a[i]);\r\n\t\t\t}\r\n\t\t\tCollections.sort(arr);\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tif (increasing) {\r\n\t\t\t\t\ta[i] = arr.get(i);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta[i] = arr.get(n-1-i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic static void sort(double[] a, boolean increasing) {\r\n\t\t\tArrayList<Double> arr = new ArrayList<Double>();\r\n\t\t\tint n = a.length;\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tarr.add(a[i]);\r\n\t\t\t}\r\n\t\t\tCollections.sort(arr);\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tif (increasing) {\r\n\t\t\t\t\ta[i] = arr.get(i);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta[i] = arr.get(n-1-i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic static int lower_bound (int[] arr, int x) {\r\n\t\t\tint low = 0, high = arr.length, mid = -1;\r\n\r\n\t\t\twhile (low < high) {\r\n\t\t\t\tmid = (low + high) / 2;\r\n\r\n\t\t\t\tif (arr[mid] >= x)\r\n\t\t\t\t\thigh = mid;\r\n\t\t\t\telse\r\n\t\t\t\t\tlow = mid + 1;\r\n\t\t\t}\r\n\r\n\t\t\treturn low;\r\n\t\t}\r\n\r\n\t\tpublic static int upper_bound (int[] arr, int x) {\r\n\t\t\tint low = 0, high = arr.length, mid = -1;\r\n\r\n\t\t\twhile (low < high) {\r\n\t\t\t\tmid = (low + high) / 2;\r\n\r\n\t\t\t\tif (arr[mid] > x)\r\n\t\t\t\t\thigh = mid;\r\n\t\t\t\telse\r\n\t\t\t\t\tlow = mid + 1;\r\n\t\t\t}\r\n\r\n\t\t\treturn low;\r\n\t\t}\r\n\t\t\r\n\t\tpublic static void updateMap(HashMap<Integer, Integer> map, int key, int v) {\r\n\t\t\tif (!map.containsKey(key)) {\r\n\t\t\t\tmap.put(key, v);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmap.put(key, map.get(key) + v);\r\n\t\t\t}\r\n\t\t\tif (map.get(key) == 0) {\r\n\t\t\t\tmap.remove(key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic static long gcd (long a, long b) {\r\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\r\n\t\t}\r\n\r\n\t\tpublic static long lcm (long a, long b) {\r\n\t\t\treturn a * b / gcd (a, b);\r\n\t\t}\r\n\r\n\t\tpublic static long fast_pow_mod (long b, long x, int mod) {\r\n\t\t\tif (x == 0) return 1;\r\n\t\t\tif (x == 1) return b;\r\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\r\n\r\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\r\n\t\t}\r\n\r\n\t\tpublic static long fast_pow (long b, long x) {\r\n\t\t\tif (x == 0) return 1;\r\n\t\t\tif (x == 1) return b;\r\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\r\n\r\n\t\t\treturn b * fast_pow (b * b, x / 2);\r\n\t\t}\r\n\r\n\t\tpublic static long choose (long n, long k) {\r\n\t\t\tk = Math.min (k, n - k);\r\n\t\t\tlong val = 1;\r\n\r\n\t\t\tfor (int i = 0; i < k; ++i)\r\n\t\t\t\tval = val * (n - i) / (i + 1);\r\n\r\n\t\t\treturn val;\r\n\t\t}\r\n\r\n\t\tpublic static long permute (int n, int k) {\r\n\t\t\tif (n < k) return 0;\r\n\t\t\tlong val = 1;\r\n\r\n\t\t\tfor (int i = 0; i < k; ++i)\r\n\t\t\t\tval = (val * (n - i));\r\n\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\t\r\n\t\t// start of permutation and lower/upper bound template\r\n\t\tpublic static void nextPermutation(int[] nums) {\r\n\t\t    //find first decreasing digit\r\n\t\t    int mark = -1;\r\n\t\t    for (int i = nums.length - 1; i > 0; i--) {\r\n\t\t        if (nums[i] > nums[i - 1]) {\r\n\t\t            mark = i - 1;\r\n\t\t            break;\r\n\t\t        }\r\n\t\t    }\r\n\t\t \r\n\t\t    if (mark == -1) {\r\n\t\t        reverse(nums, 0, nums.length - 1);\r\n\t\t        return;\r\n\t\t    }\r\n\t\t \r\n\t\t    int idx = nums.length-1;\r\n\t\t    for (int i = nums.length-1; i >= mark+1; i--) {\r\n\t\t        if (nums[i] > nums[mark]) {\r\n\t\t            idx = i;\r\n\t\t            break;\r\n\t\t        }\r\n\t\t    }\r\n\t\t \r\n\t\t    swap(nums, mark, idx);\r\n\t\t \r\n\t\t    reverse(nums, mark + 1, nums.length - 1);\r\n\t\t}\r\n\t\t \r\n\t\tpublic static void swap(int[] nums, int i, int j) {\r\n\t\t    int t = nums[i];\r\n\t\t    nums[i] = nums[j];\r\n\t\t    nums[j] = t;\r\n\t\t}\r\n\t\t \r\n\t\tpublic static void reverse(int[] nums, int i, int j) {\r\n\t\t    while (i < j) {\r\n\t\t        swap(nums, i, j);\r\n\t\t        i++;\r\n\t\t        j--;\r\n\t\t    }\r\n\t\t}\r\n\t\t\r\n\t\tstatic int lower_bound (int[] arr, int hi, int cmp) {\r\n\t\t\tint low = 0, high = hi, mid = -1;\r\n\t\t\twhile (low < high) {\r\n\t\t\t\tmid = (low + high) / 2;\r\n\t\t\t\tif (arr[mid] >= cmp) high = mid;\r\n\t\t\t\telse low = mid + 1;\r\n\t\t\t}\r\n\t\t\treturn low;\r\n\t\t}\r\n\t \r\n\t\tstatic int upper_bound (int[] arr, int hi, int cmp) {\r\n\t\t\tint low = 0, high = hi, mid = -1;\r\n\t\t\twhile (low < high) {\r\n\t\t\t\tmid = (low + high) / 2;\r\n\t\t\t\tif (arr[mid] > cmp) high = mid;\r\n\t\t\t\telse low = mid + 1;\r\n\t\t\t}\r\n\t\t\treturn low;\r\n\t\t}\r\n\t\t// end of permutation and lower/upper bound template\r\n\t}\r\n}\r\n"
}