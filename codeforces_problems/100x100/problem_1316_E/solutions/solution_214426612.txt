{
    "id": 214426612,
    "contestId": 1316,
    "creationTimeSeconds": 1689735692,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1316,
        "index": "E",
        "name": "Team Building",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2300,
        "tags": [
            "bitmasks",
            "dp",
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1316,
        "members": [
            {
                "handle": "Eslam_Ahmed"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1583332500
    },
    "programmingLanguage": "Java 8",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "\r\n\r\nimport java.io.*;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n *\r\n * @author eslam\r\n */\r\npublic class Solution {\r\n\r\n    // Beginning of the solution\r\n    static Reader input = new Reader();\r\n    static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\r\n    static ArrayList<ArrayList<Integer>> powerSet = new ArrayList<>();\r\n    static ArrayList<LinkedList<Integer>> allprem = new ArrayList<>();\r\n    static ArrayList<LinkedList<String>> allprems = new ArrayList<>();\r\n    static long mod = (long) (1e9 + 7);\r\n    static int grid[][] = {{0, 0, 1, -1, 1, 1, -1, -1}, {1, -1, 0, 0, 1, -1, 1, -1}};\r\n    static long dp[][][];\r\n    static final double cmp = 1e-9;\r\n    static final double pi = 3.14159265359;\r\n    static long MO = 998244353;\r\n    static long seg[], lazy[];\r\n    static int num[], lowesLink[];\r\n    static boolean inStack[];\r\n    static Stack<Integer> st;\r\n    static int nu;\r\n    static LinkedList<ArrayList<Integer>> stronConCom;\r\n    static ArrayList<TreeSet<Integer>> conCom;\r\n    static int powers[];\r\n\r\n    public static void main(String[] args) throws IOException {\r\n//        Reader input = new Reader(\"lis.in\");\r\n//        BufferedWriter log = new BufferedWriter(new FileWriter(f));\r\n        int test = 1;//input.nextInt();\r\n        loop:\r\n        for (int co = 1; co <= test; co++) {\r\n            int n = input.nextInt();\r\n            int p = input.nextInt();\r\n            int k = input.nextInt();\r\n            int a[] = new int[n];\r\n            int b[][] = new int[n][p];\r\n            powers = new int[7];\r\n            pair<Integer, Integer> c[] = new pair[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = input.nextInt();\r\n                c[i] = new pair<>(a[i], i);\r\n            }\r\n            powers[0] = 1;\r\n            for (int i = 1; i < 7; i++) {\r\n                powers[i] = powers[i - 1] * 2;\r\n            }\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < p; j++) {\r\n                    b[i][j] = input.nextInt();\r\n                }\r\n            }\r\n            Arrays.sort(c, new Comparator<pair<Long, Integer>>() {\r\n                @Override\r\n                public int compare(pair<Long, Integer> o1, pair<Long, Integer> o2) {\r\n                    if (o1.x > o2.x) {\r\n                        return -1;\r\n                    } else if (o1.x < o2.x) {\r\n                        return 1;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                }\r\n            });\r\n            boolean vi[] = new boolean[n];\r\n            long sum = 0;\r\n            for (int i = 0; i < k; i++) {\r\n                vi[c[i].y] = true;\r\n                sum += c[i].x;\r\n            }\r\n            dp = new long[n][1 << p][7];\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < dp[0].length; j++) {\r\n                    Arrays.fill(dp[i][j], -1);\r\n                }\r\n            }\r\n            log.write(sum + solve(0, 0, 0, vi, c, b, k, a) + \"\\n\");\r\n        }\r\n        log.flush();\r\n    }\r\n\r\n    static long solve(int idx, int pos, int re, boolean vi[], pair<Long, Integer> c[], long b[][], int k, long a[]) {\r\n        if (idx == vi.length) {\r\n            return 0;\r\n        }\r\n        if (dp[idx][pos][re] == -1) {\r\n            dp[idx][pos][re] = solve(idx + 1, pos, re, vi, c, b, k, a);\r\n            int e = 0;\r\n            long x = 0;\r\n            if (vi[idx]) {\r\n                e++;\r\n                x -= a[idx];\r\n                x += c[k + re].x;\r\n            }\r\n            int cnt = 0;\r\n            while (powers[cnt] < dp[0].length) {\r\n                if ((powers[cnt] & pos) == 0) {\r\n                    dp[idx][pos][re] = Math.max(dp[idx][pos][re], x + b[idx][cnt] + solve(idx + 1, pos | powers[cnt], re + e, vi, c, b, k, a));\r\n                }\r\n                cnt++;\r\n            }\r\n        }\r\n        return dp[idx][pos][re];\r\n    }\r\n\r\n    static int getPrimes(int v) {\r\n        int cnt = 0;\r\n        boolean ca = false;\r\n        while (v % 2 == 0) {\r\n            ca = true;\r\n            v /= 2;\r\n        }\r\n        if (ca) {\r\n            cnt++;\r\n        }\r\n        for (int i = 3; i * i <= v; i += 2) {\r\n            ca = false;\r\n            while (v % i == 0) {\r\n                ca = true;\r\n                v /= i;\r\n            }\r\n            if (ca) {\r\n                cnt++;\r\n            }\r\n        }\r\n        if (v > 1) {\r\n            cnt++;\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    static double sqrtD(double v) {\r\n        double max = (double) 4e9;\r\n        double min = 0;\r\n        double ans = 0;\r\n        while (max - min > cmp) {\r\n            double mid = (max + min) / 2.0;\r\n            if (cmpDouble(mid * mid, v) == 1) {\r\n                max = mid;\r\n            } else {\r\n                ans = mid;\r\n                min = mid;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static int cmpDouble(double a, double b) {\r\n        if (Math.abs(a - b) <= 1e-9) {\r\n            return 0;\r\n        }\r\n        return a < b ? -1 : 1;\r\n    }\r\n\r\n    static class MultiSet<T> {\r\n\r\n        HashMap<T, Integer> fre;\r\n        TreeSet<T> set;\r\n        int size;\r\n\r\n        public MultiSet() {\r\n            set = new TreeSet<>();\r\n            fre = new HashMap<>();\r\n            size = 0;\r\n        }\r\n\r\n        public void add(T elem) {\r\n            if (fre.get(elem) == null || fre.get(elem) == 0) {\r\n                fre.put(elem, 0);\r\n                set.add(elem);\r\n            }\r\n            fre.put(elem, fre.get(elem) + 1);\r\n        }\r\n\r\n        public void remove(T elem) {\r\n            fre.put(elem, fre.get(elem) - 1);\r\n            if (fre.get(elem) == 0) {\r\n                set.remove(elem);\r\n            }\r\n        }\r\n\r\n        public boolean contains(T elem) {\r\n            return set.contains(elem);\r\n        }\r\n    }\r\n\r\n    static long add(long a, long b) {\r\n        a += b;\r\n        if (a >= mod) {\r\n            a -= mod;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    static long mul(long a, long b) {\r\n        return (long) ((long) ((a % mod) * (b % mod)) % mod);\r\n    }\r\n\r\n    static long modinv(long x) {\r\n        return fast_pow(x, mod - 2, mod);\r\n    }\r\n\r\n    static long Div(long x, long y) {\r\n        return mul(x, modinv(y));\r\n\r\n    }\r\n\r\n    static class pair<T, L> {\r\n\r\n        T x;\r\n        L y;\r\n\r\n        public pair(T x, L y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return x + \" \" + y;\r\n        }\r\n    }\r\n\r\n    static long mod(long a, long b) {\r\n        long r = a % b;\r\n        return r < 0 ? r + b : r;\r\n    }\r\n\r\n    static long fast_pow(long a, long p, long mod) {\r\n        long res = 1;\r\n        while (p > 0) {\r\n            if (p % 2 == 0) {\r\n                a = ((a % mod) * (a % mod)) % mod;\r\n                p /= 2;\r\n            } else {\r\n                res = ((res % mod) * (a % mod)) % mod;\r\n                p--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static int flipBit(int num, int idx) {\r\n        return (num ^ (1 << idx));\r\n\r\n    }\r\n\r\n    static class temp {\r\n\r\n        int node;\r\n        long val;\r\n\r\n        public temp(int node, long val) {\r\n            this.node = node;\r\n            this.val = val;\r\n        }\r\n\r\n    }\r\n\r\n    static void tarjan(int node, ArrayList<Integer> g[]) {\r\n        num[node] = lowesLink[node] = nu++;\r\n        st.add(node);\r\n        inStack[node] = true;\r\n        for (Integer ch : g[node]) {\r\n            if (num[ch] == 0) {\r\n                tarjan(ch, g);\r\n                lowesLink[node] = Math.min(lowesLink[node], lowesLink[ch]);\r\n            } else if (inStack[ch]) {\r\n                lowesLink[node] = Math.min(lowesLink[node], num[ch]);\r\n            }\r\n        }\r\n        if (lowesLink[node] == num[node]) {\r\n            int x = -1;\r\n            stronConCom.add(new ArrayList<>());\r\n            while (x != node) {\r\n                x = st.pop();\r\n                inStack[x] = false;\r\n                stronConCom.getLast().add(x);\r\n            }\r\n        }\r\n    }\r\n\r\n    static void build(int idx, int s, int e, long a[]) {\r\n        if (s == e) {\r\n            seg[idx] = a[s];\r\n            return;\r\n        }\r\n        build(idx * 2, s, (s + e) / 2, a);\r\n        build(idx * 2 + 1, (s + e) / 2 + 1, e, a);\r\n        seg[idx] = Math.max(seg[idx * 2], seg[idx * 2 + 1]);\r\n\r\n    }\r\n\r\n    static void process(int idx, int s, int e) {\r\n        seg[idx] += (e - s + 1) * (lazy[idx]);\r\n\r\n        if (s < e) {\r\n            lazy[idx * 2] += lazy[idx];\r\n            lazy[idx * 2 + 1] += lazy[idx];\r\n        }\r\n        lazy[idx] = 0;\r\n    }\r\n\r\n    static void updateIndex(int idx, int s, int e, int ind, long val) {\r\n        if (ind < s || ind > e) {\r\n            return;\r\n        }\r\n        if (s == ind && ind == e) {\r\n            seg[idx] += val;\r\n            return;\r\n        }\r\n        updateIndex(idx * 2, s, (s + e) / 2, ind, val);\r\n        updateIndex(idx * 2 + 1, (s + e) / 2 + 1, e, ind, val);\r\n        seg[idx] = Math.max(seg[idx * 2], seg[idx * 2 + 1]);\r\n    }\r\n\r\n    static void updateRange(int idx, int s, int e, int l, int r, long val) {\r\n        process(idx, s, e);\r\n        if ((l > e) || s > r) {\r\n            return;\r\n        }\r\n        if (s >= l && e <= r) {\r\n            lazy[idx] += val;\r\n            process(idx, s, e);\r\n            return;\r\n        }\r\n        updateRange(idx * 2, s, (s + e) / 2, l, r, val);\r\n        updateRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r, val);\r\n        seg[idx] = Math.max((seg[idx * 2]), seg[idx * 2 + 1]);\r\n    }\r\n\r\n    static long maxInRange(int idx, int s, int e, int l, int r) {\r\n        //    process(idx, s, e);\r\n        if ((l > e) || s > r) {\r\n            return 0;\r\n        }\r\n        if (s >= l && e <= r) {\r\n            return seg[idx];\r\n        }\r\n        return Math.max(maxInRange(idx * 2, s, (s + e) / 2, l, r), maxInRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r));\r\n    }\r\n\r\n    public static boolean isPalindrome(String w) {\r\n        for (int i = 0; i < w.length() / 2; i++) {\r\n            if (w.charAt(i) != w.charAt(w.length() - i - 1)) {\r\n                return false;\r\n            }\r\n\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isValid(int i, int j, int n, int m) {\r\n        return (i > -1 && i < n) && (j > -1 && j < m);\r\n\r\n    }\r\n\r\n    static class tri {\r\n\r\n        int x, y;\r\n        int z;\r\n\r\n        public tri(int x, int y, int z) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return x + \" \" + y + \" \" + z;\r\n        }\r\n    }\r\n\r\n    public static int countPrimeInRange(int n, boolean isPrime[]) {\r\n        int cnt = 0;\r\n        Arrays.fill(isPrime, true);\r\n        isPrime[0] = false;\r\n        isPrime[1] = false;\r\n        for (int i = 2; i * i <= n; i++) {\r\n            if (isPrime[i]) {\r\n                for (int j = i * 2; j <= n; j += i) {\r\n                    isPrime[j] = false;\r\n                }\r\n            }\r\n        }\r\n        for (int i = 2; i <= n; i++) {\r\n            if (isPrime[i]) {\r\n                cnt++;\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    static pai absSub(pai a, pai b) {\r\n        doWork(a, b);\r\n        pai c = new pai(Math.abs(a.x - b.x), a.y);\r\n        simplifyFraction(b);\r\n        return c;\r\n    }\r\n\r\n    static int compare(pai a, pai b) {\r\n        doWork(a, b);\r\n        if (a.x <= b.x) {\r\n            return -1;\r\n        } else {\r\n            return (int) Math.min(1, a.x - b.x);\r\n        }\r\n    }\r\n\r\n    static void doWork(pai a, pai b) {\r\n        simplifyFraction(a);\r\n        simplifyFraction(b);\r\n        long c = a.y;\r\n        a.y *= b.y;\r\n        a.x *= b.y;\r\n        b.y *= c;\r\n        b.x *= c;\r\n    }\r\n\r\n    static void simplifyFraction(pai b) {\r\n        long g = GCD(b.x, b.y);\r\n        b.x /= g;\r\n        b.y /= g;\r\n\r\n    }\r\n\r\n    public static boolean isSortedInc(long[] a, int l, int r) {\r\n        for (int i = l; i <= r; i++) {\r\n            if (a[i] > a[i + 1]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isSortedDec(long[] a, int l, int r) {\r\n        for (int i = l; i <= r; i++) {\r\n            if (a[i] < a[i + 1]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static long f(long x) {\r\n        return (long) ((x * (x + 1) / 2) % mod);\r\n    }\r\n\r\n    static long Sub(long x, long y) {\r\n        long z = x - y;\r\n        if (z < 0) {\r\n            z += mod;\r\n        }\r\n        return z;\r\n    }\r\n\r\n    static boolean isdigit(char ch) {\r\n        return ch >= '0' && ch <= '9';\r\n    }\r\n\r\n    static boolean lochar(char ch) {\r\n        return ch >= 'a' && ch <= 'z';\r\n    }\r\n\r\n    static boolean cachar(char ch) {\r\n        return ch >= 'A' && ch <= 'Z';\r\n\r\n    }\r\n\r\n    static long sqrt(long v) {\r\n        long max = (long) 4e9;\r\n        long min = 0;\r\n        long ans = 0;\r\n        while (max >= min) {\r\n            long mid = (max + min) / 2;\r\n            if (mid * mid > v) {\r\n                max = mid - 1;\r\n            } else {\r\n                ans = mid;\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static long cbrt(long v) {\r\n        long max = (long) 3e6;\r\n        long min = 0;\r\n        long ans = 0;\r\n        while (max >= min) {\r\n            long mid = (max + min) / 2;\r\n            if (mid * mid > v) {\r\n                max = mid - 1;\r\n            } else {\r\n                ans = mid;\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static void prefixSum2D(long arr[][]) {\r\n        for (int i = 0; i < arr.length; i++) {\r\n            prefixSum(arr[i]);\r\n        }\r\n        for (int i = 0; i < arr[0].length; i++) {\r\n            for (int j = 1; j < arr.length; j++) {\r\n                arr[j][i] += arr[j - 1][i];\r\n            }\r\n        }\r\n    }\r\n\r\n    static Comparator<tri> cmpTri() {\r\n        Comparator<tri> c = new Comparator<tri>() {\r\n            @Override\r\n            public int compare(tri o1, tri o2) {\r\n                if (o1.x > o2.x) {\r\n                    return 1;\r\n                } else if (o1.x < o2.x) {\r\n                    return -1;\r\n                } else {\r\n                    if (o1.y > o2.y) {\r\n                        return 1;\r\n                    } else if (o1.y < o2.y) {\r\n                        return -1;\r\n                    } else {\r\n                        if (o1.z > o2.z) {\r\n                            return 1;\r\n                        } else if (o1.z < o2.z) {\r\n                            return -1;\r\n                        } else {\r\n                            return 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return c;\r\n    }\r\n\r\n    static long sumOfRange(int x1, int y1, int x2, int y2, long a[][]) {\r\n        return (a[x2][y2] - a[x1 - 1][y2] - a[x2][y1 - 1]) + a[x1 - 1][y1 - 1];\r\n    }\r\n\r\n    // present in the left and right indices\r\n    public static int[] swap(int data[], int left, int right) {\r\n\r\n        // Swap the data\r\n        int temp = data[left];\r\n        data[left] = data[right];\r\n        data[right] = temp;\r\n\r\n        // Return the updated array\r\n        return data;\r\n    }\r\n\r\n    // Function to reverse the sub-array\r\n    // starting from left to the right\r\n    // both inclusive\r\n    public static int[] reverse(int data[], int left, int right) {\r\n\r\n        // Reverse the sub-array\r\n        while (left < right) {\r\n            int temp = data[left];\r\n            data[left++] = data[right];\r\n            data[right--] = temp;\r\n        }\r\n\r\n        // Return the updated array\r\n        return data;\r\n    }\r\n\r\n    // Function to find the next permutation\r\n    // of the given integer array\r\n    public static boolean findNextPermutation(int data[]) {\r\n\r\n        // If the given dataset is empty\r\n        // or contains only one element\r\n        // next_permutation is not possible\r\n        if (data.length <= 1) {\r\n            return false;\r\n        }\r\n\r\n        int last = data.length - 2;\r\n\r\n        // find the longest non-increasing suffix\r\n        // and find the pivot\r\n        while (last >= 0) {\r\n            if (data[last] < data[last + 1]) {\r\n                break;\r\n            }\r\n            last--;\r\n        }\r\n\r\n        // If there is no increasing pair\r\n        // there is no higher order permutation\r\n        if (last < 0) {\r\n            return false;\r\n        }\r\n\r\n        int nextGreater = data.length - 1;\r\n\r\n        // Find the rightmost successor to the pivot\r\n        for (int i = data.length - 1; i > last; i--) {\r\n            if (data[i] > data[last]) {\r\n                nextGreater = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Swap the successor and the pivot\r\n        data = swap(data, nextGreater, last);\r\n\r\n        // Reverse the suffix\r\n        data = reverse(data, last + 1, data.length - 1);\r\n\r\n        // Return true as the next_permutation is done\r\n        return true;\r\n    }\r\n\r\n    public static String revs(String w) {\r\n        String ans = \"\";\r\n        for (int i = w.length() - 1; i > -1; i--) {\r\n            ans += w.charAt(i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static void getPowerSet(Queue<Integer> a) {\r\n        int n = a.poll();\r\n        if (!a.isEmpty()) {\r\n            getPowerSet(a);\r\n        }\r\n        int s = powerSet.size();\r\n        for (int i = 0; i < s; i++) {\r\n            ArrayList<Integer> ne = new ArrayList<>();\r\n            ne.add(n);\r\n            for (int j = 0; j < powerSet.get(i).size(); j++) {\r\n                ne.add(powerSet.get(i).get(j));\r\n            }\r\n\r\n            powerSet.add(ne);\r\n        }\r\n        ArrayList<Integer> p = new ArrayList<>();\r\n        p.add(n);\r\n        powerSet.add(p);\r\n    }\r\n\r\n    public static long ceil(long a, long b) {\r\n        return (a + b - 1) / b;\r\n    }\r\n\r\n    public static long round(long a, long b) {\r\n        if (a < 0) {\r\n            return (a - b / 2) / b;\r\n        }\r\n        return (a + b / 2) / b;\r\n    }\r\n\r\n    public static void allPremutationsst(LinkedList<String> l, boolean visited[], ArrayList<String> st) {\r\n        if (l.size() == st.size()) {\r\n            allprems.add(l);\r\n        }\r\n        for (int i = 0; i < st.size(); i++) {\r\n            if (!visited[i]) {\r\n                visited[i] = true;\r\n                LinkedList<String> nl = new LinkedList<>();\r\n                for (String x : l) {\r\n                    nl.add(x);\r\n                }\r\n                nl.add(st.get(i));\r\n                allPremutationsst(nl, visited, st);\r\n                visited[i] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void allPremutations(LinkedList<Integer> l, boolean visited[], int a[]) {\r\n        if (l.size() == a.length) {\r\n            allprem.add(l);\r\n        }\r\n        for (int i = 0; i < a.length; i++) {\r\n            if (!visited[i]) {\r\n                visited[i] = true;\r\n                LinkedList<Integer> nl = new LinkedList<>();\r\n                for (Integer x : l) {\r\n                    nl.add(x);\r\n                }\r\n                nl.add(a[i]);\r\n                allPremutations(nl, visited, a);\r\n                visited[i] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void reverse(int l, int r, char ch[]) {\r\n        for (int i = 0; i < r / 2; i++) {\r\n            char c = ch[i];\r\n            ch[i] = ch[r - i - 1];\r\n            ch[r - i - 1] = c;\r\n        }\r\n    }\r\n\r\n    public static long logK(long v, long k) {\r\n        long ans = 0;\r\n        while (v > 1) {\r\n            ans++;\r\n            v /= k;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static long power(long a, long p) {\r\n        long res = 1;\r\n        while (p > 0) {\r\n            if (p % 2 == 0) {\r\n                a = (a * a);\r\n                p /= 2;\r\n            } else {\r\n                res = (res * a);\r\n                p--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public static long rev(long n) {\r\n        long t = n;\r\n        long ans = 0;\r\n        while (t > 0) {\r\n            ans = ans * 10 + t % 10;\r\n            t /= 10;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static boolean isPalindrome(int n) {\r\n        int t = n;\r\n        int ans = 0;\r\n        while (t > 0) {\r\n            ans = ans * 10 + t % 10;\r\n            t /= 10;\r\n        }\r\n        return ans == n;\r\n\r\n    }\r\n\r\n    static boolean isPrime(long num) {\r\n        if (num == 1) {\r\n            return false;\r\n        }\r\n        if (num == 2) {\r\n            return true;\r\n        }\r\n        if (num % 2 == 0) {\r\n            return false;\r\n        }\r\n        if (num == 3) {\r\n            return true;\r\n        }\r\n        for (long i = 3; i * i <= num; i += 2) {\r\n            if (num % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static void prefixSum(long[] a) {\r\n        for (int i = 1; i < a.length; i++) {\r\n            a[i] = a[i] + a[i - 1];\r\n        }\r\n    }\r\n\r\n    public static void suffixSum(long[] a) {\r\n        for (int i = a.length - 2; i > -1; i--) {\r\n            a[i] = a[i] + a[i + 1];\r\n        }\r\n    }\r\n\r\n    public static long binaryToDecimal(String w) {\r\n        long r = 0;\r\n        long l = 0;\r\n        for (int i = w.length() - 1; i > -1; i--) {\r\n            long x = (w.charAt(i) - '0') * (long) Math.pow(2, l);\r\n            r = r + x;\r\n            l++;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    public static String decimalToBinary(long n) {\r\n        String w = \"\";\r\n        while (n > 0) {\r\n            w = n % 2 + w;\r\n            n /= 2;\r\n        }\r\n        return w;\r\n\r\n    }\r\n\r\n    static class pai {\r\n\r\n        long x;\r\n        long y;\r\n\r\n        public pai(long x, long y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return x + \" \" + y;\r\n        }\r\n    }\r\n\r\n    public static long LCM(long x, long y) {\r\n        return x / GCD(x, y) * y;\r\n    }\r\n\r\n    public static long GCD(long x, long y) {\r\n        if (y == 0) {\r\n            return x;\r\n        }\r\n        return GCD(y, x % y);\r\n\r\n    }\r\n\r\n    static class Reader extends PrintWriter {\r\n\r\n        private BufferedReader r;\r\n        private StringTokenizer st;\r\n        // standard input\r\n\r\n        public Reader() {\r\n            this(System.in, System.out);\r\n        }\r\n\r\n        public Reader(InputStream i, OutputStream o) {\r\n            super(o);\r\n            r = new BufferedReader(new InputStreamReader(i));\r\n        }\r\n        // USACO-style file input\r\n\r\n        public Reader(String problemName) throws IOException {\r\n            super(problemName + \".out\");\r\n            r = new BufferedReader(new FileReader(problemName));\r\n        }\r\n\r\n        // returns null if no more input\r\n        String nextLine() {\r\n            String str = \"\";\r\n            try {\r\n                str = r.readLine();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n\r\n        public String next() {\r\n            try {\r\n                while (st == null || !st.hasMoreTokens()) {\r\n                    st = new StringTokenizer(r.readLine());\r\n                }\r\n                return st.nextToken();\r\n            } catch (Exception e) {\r\n            }\r\n            return null;\r\n        }\r\n\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        public long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n}\r\n"
}