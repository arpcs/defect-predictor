{
    "id": 85138498,
    "contestId": 1316,
    "creationTimeSeconds": 1593184133,
    "relativeTimeSeconds": 5633,
    "problem": {
        "contestId": 1316,
        "index": "E",
        "name": "Team Building",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2300,
        "tags": [
            "bitmasks",
            "dp",
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1316,
        "members": [
            {
                "handle": "Temmie"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1593178500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 124,
    "timeConsumedMillis": 1232,
    "memoryConsumedBytes": 139366400,
    "source": "#include <bits/stdc++.h>\r\n\r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define cast(type, data) static_cast <type>(data)\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double ld;\r\n\r\ntemplate <class A> void transpose(std::vector <std::vector <A>>& v) { std::vector <std::vector <A>> result((int)v[0].size(), std::vector <A>((int)v.size())); for (int i = 0; i < (int)v.size(); i++) { for (int j = 0; j < (int)v[0].size(); j++) { result[j][i] = v[i][j]; } } v = result; }\r\n\r\nstd::string to_string(const std::string& s) { return '\"' + s + '\"'; }\r\nstd::string to_string(const char* s) { return to_string((std::string)s); }\r\nstd::string to_string(const bool& b) { return (b ? \"true\" : \"false\"); }\r\nstd::string to_string(const char& c) { return (std::string)\"'\" + c + \"'\"; }\r\nstd::string to_string(const std::vector <bool>& v) { std::string ret = \"{\" + to_string(v.front()); for (int i = 1; i < cast(int, v.size()); i++) { ret += \", \" + to_string(v[i]); } return ret + \"}\"; }\r\ntemplate <typename A> std::string to_string(A x) { return std::to_string(x); }\r\ntemplate <typename A, typename B> std::string to_string(std::pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\r\ntemplate <typename A> std::string to_string(const std::vector <A>& v) { std::string ret = \"{\" + to_string(v.front()); for (int i = 1; i < cast(int, v.size()); i++) { ret += \", \" + to_string(v[i]); } return ret + \"}\"; }\r\ntemplate <typename A> std::string to_string(const std::set <A>& st) { if (st.empty()) { return \"[empty]\"; } auto it = st.begin(); std::string ret = \"[\" + to_string(*it); it++; for (; it != st.end(); it++) { ret += \", \" + to_string(*it); } return ret + \"]\"; }\r\ntemplate <typename A> std::string to_string(const std::unordered_set <A>& st) { if (st.empty()) { return \"[empty]\"; } auto it = st.begin(); std::string ret = \"[\" + to_string(*it); it++; for (; it != st.end(); it++) { ret += \", \" + to_string(*it); } return ret + \"]\"; }\r\ntemplate <typename A, typename B> std::string to_string(const std::map <A, B>& mp) { if (mp.empty()) { return \"[empty]\"; } auto it = mp.begin(); std::string ret = \"[(\" + to_string((*it).first) + \": \" + to_string((*it).second) + \")\"; it++; for (; it != mp.end(); it++) { ret += \", (\" + to_string((*it).first) + \": \" + to_string((*it).second) + \")\"; } return ret + \"]\"; }\r\ntemplate <typename A, typename B> std::string to_string(const std::unordered_map <A, B>& mp) { if (mp.empty()) { return \"[empty]\"; } auto it = mp.begin(); std::string ret = \"[(\" + to_string((*it).first) + \": \" + to_string((*it).second) + \")\"; it++; for (; it != mp.end(); it++) { ret += \", (\" + to_string((*it).first) + \": \" + to_string((*it).second) + \")\"; } return ret + \"]\"; }\r\ntemplate <typename A> std::string to_string(const std::queue <A>& q) { if (q.empty()) { return \"[empty]\"; } std::queue <A> bckp = q; std::string ret = \"[\" + to_string(bckp.front()); bckp.pop(); while (!bckp.empty()) { A tp = bckp.front(); bckp.pop(); ret += \", \" + to_string(tp); } return ret + \"]\"; }\r\ntemplate <typename A> std::string to_string(const std::priority_queue <A>& pq) { if (pq.empty()) { return \"[empty]\"; } std::priority_queue <A> bckp = pq; std::string ret = \"[\" + to_string(bckp.top()); bckp.pop(); while (!bckp.empty()) { A tp = bckp.top(); bckp.pop(); ret += \", \" + to_string(tp); } return ret + \"]\"; }\r\ntemplate <typename A> std::string to_string(const std::stack <A>& stck) { if (stck.empty()) { return \"[empty]\"; } std::stack <A> bckp = stck; std::string ret = \"[\" + to_string(bckp.top()); bckp.pop(); while (!bckp.empty()) { A tp = bckp.top(); bckp.pop(); ret += \", \" + to_string(tp); } return ret + \"]\"; }\r\n\r\nvoid debug_out() { std::cerr << std::endl; }\r\ntemplate <typename H, typename... T> void debug_out(H h, T... t) { std::cout << \" \" << to_string(h); debug_out(t...); }\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\r\n#else\r\n#define debug(...) 0\r\n#endif\r\n\r\ntemplate <typename T = int>\r\nclass Graph_T {\r\npublic:\r\n\tstruct Edge { int from, to; T weight; };\r\n\tstd::vector <Edge> edges;\r\n\tstd::vector <std::vector <int>> adj;\r\n\tint size;\r\n\tGraph_T(int SIZE) : size(SIZE) { adj.resize(size); }\r\n\tvirtual int add(int from, int to, T weight) = 0;\r\n};\r\n\r\ntemplate <typename T = int>\r\nclass Tree : public Graph_T <T> {\r\npublic:\r\n\tusing Graph_T <T>::edges;\r\n\tusing Graph_T <T>::adj;\r\n\tusing Graph_T <T>::size;\r\n\t\r\n\tbool assert_tree;\r\n\t\r\n\tTree(int SIZE, bool ASSERT_TREE = true) : Graph_T <T>(SIZE), assert_tree(ASSERT_TREE) { }\r\n\t\r\n\tint add(int from, int to, T weight = 1) {\r\n\t\tassert(0 <= from && from < size && 0 <= to && to < size);\r\n\t\tint ID = (int)edges.size();\r\n\t\tif (assert_tree) { assert(ID < size - 1); }\r\n\t\tadj[from].push_back(ID);\r\n\t\tadj[to].push_back(ID);\r\n\t\tedges.push_back( {from, to, weight} );\r\n\t\treturn ID;\r\n\t}\r\n\t\r\n\tbool istree(int node = 0, int parent = -1) {\r\n\t\tassert(size);\r\n\t\tstatic std::vector <bool> vis;\r\n\t\tif (!node && parent == -1) { vis.clear(); vis.resize(size, false); }\r\n\t\tvis[node] = true;\r\n\t\tbool ok = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].from ^ edges[x].to ^ node;\r\n\t\t\tif (to == parent) { continue; }\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tok = ok & istree(to, node);\r\n\t\t}\r\n\t\tif (!node && parent == -1) { ok = ok & (std::count(all(vis), true) == size); }\r\n\t\treturn ok;\r\n\t}\r\n\t\r\n\tT pathUV(int u, int v) {\r\n\t\tstd::priority_queue <std::pair <T, int>> pq;\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tpq.push(std::make_pair(0, u));\r\n\t\tvis[u] = true;\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tauto now = pq.top(); pq.pop();\r\n\t\t\tif (now.second == v) return -now.first;\r\n\t\t\tfor (const int& x : adj[now.second]) {\r\n\t\t\t\tint to = edges[x].from ^ edges[x].to ^ now.second;\r\n\t\t\t\tif (!vis[to]) {\r\n\t\t\t\t\tpq.push(std::make_pair(now.first - edges[x].weight, to));\r\n\t\t\t\t\tvis[to] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (T)-1;\r\n\t}\r\n};\r\n\r\ntemplate <typename T = int>\r\nclass D_Tree : public Graph_T <T> {\r\npublic:\r\n\tusing Graph_T <T>::edges;\r\n\tusing Graph_T <T>::adj;\r\n\tusing Graph_T <T>::size;\r\n\t\r\n\tD_Tree(int SIZE) : Graph_T <T>(SIZE) { }\r\n\t\r\n\tint add(int from, int to, T weight = 1) {\r\n\t\tassert(0 <= from && from < size && 0 <= to && to < size);\r\n\t\tint ID = (int)edges.size();\r\n\t\tadj[from].push_back(ID);\r\n\t\tedges.push_back( {from, to, weight} );\r\n\t\treturn ID;\r\n\t}\r\n\t\r\n\tbool istree(int node = 0) {\r\n\t\tassert(size);\r\n\t\tstatic std::vector <bool> vis;\r\n\t\tif (!node) { vis.clear(); vis.resize(size, false); }\r\n\t\tvis[node] = true;\r\n\t\tbool ok = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].to;\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tok = ok & istree(to);\r\n\t\t}\r\n\t\tif (!node) { ok = ok & (std::count(all(vis), true) == size); }\r\n\t\treturn ok;\r\n\t}\r\n\t\r\n\tT pathUV(int u, int v) {\r\n\t\tstd::priority_queue <std::pair <T, int>> pq;\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tpq.push(std::make_pair(0, u));\r\n\t\tvis[u] = true;\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tauto now = pq.top(); pq.pop();\r\n\t\t\tif (now.second == v) return -now.first;\r\n\t\t\tfor (const int& x : adj[now.second]) {\r\n\t\t\t\tint to = edges[x].to;\r\n\t\t\t\tif (!vis[to]) {\r\n\t\t\t\t\tpq.push(std::make_pair(now.first - edges[x].weight, to));\r\n\t\t\t\t\tvis[to] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (T)-1;\r\n\t}\r\n};\r\n\r\ntemplate <typename T = int>\r\nclass Forest : public Graph_T <T> {\r\npublic:\r\n\tusing Graph_T <T>::edges;\r\n\tusing Graph_T <T>::adj;\r\n\tusing Graph_T <T>::size;\r\n\t\r\n\tbool assert_forest;\r\n\t\r\n\tForest(int SIZE, bool ASSERT_FOREST = true) : Graph_T <T>(SIZE), assert_forest(ASSERT_FOREST) { }\r\n\t\r\n\tint add(int from, int to, T weight = 1) {\r\n\t\tassert(0 <= from && from < size && 0 <= to && to < size);\r\n\t\tint ID = (int)edges.size();\r\n\t\tif (assert_forest) { assert(ID < size - 1); }\r\n\t\tadj[from].push_back(ID);\r\n\t\tadj[to].push_back(ID);\r\n\t\tedges.push_back( {from, to, weight} );\r\n\t\treturn ID;\r\n\t}\r\n\t\r\n\tbool istree(int node = 0, int parent = -1) {\r\n\t\tassert(size);\r\n\t\tstatic std::vector <bool> vis;\r\n\t\tif (!node && parent == -1) { vis.clear(); vis.resize(size, false); }\r\n\t\tvis[node] = true;\r\n\t\tbool ok = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].from ^ edges[x].to ^ node;\r\n\t\t\tif (to == parent) { continue; }\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tok = ok & istree(to, node);\r\n\t\t}\r\n\t\tif (!node && parent == -1) { ok = ok & (std::count(all(vis), true) == size); }\r\n\t\treturn ok;\r\n\t}\r\n\t\r\n\tbool isforest() {\r\n\t\tassert(size);\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tif (!vis[i]) {\r\n\t\t\t\tif (!m_isforest(vis, i)) { return false; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tT pathUV(int u, int v) {\r\n\t\tstd::priority_queue <std::pair <T, int>> pq;\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tpq.push(std::make_pair(0, u));\r\n\t\tvis[u] = true;\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tauto now = pq.top(); pq.pop();\r\n\t\t\tif (now.second == v) return -now.first;\r\n\t\t\tfor (const int& x : adj[now.second]) {\r\n\t\t\t\tint to = edges[x].from ^ edges[x].to ^ now.second;\r\n\t\t\t\tif (!vis[to]) {\r\n\t\t\t\t\tpq.push(std::make_pair(now.first - edges[x].weight, to));\r\n\t\t\t\t\tvis[to] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (T)-1;\r\n\t}\r\n\t\r\nprivate:\r\n\tbool m_isforest(std::vector <bool>& vis, int node, int parent = -1) {\r\n\t\tvis[node] = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].from ^ edges[x].to ^ node;\r\n\t\t\tif (to == parent) { continue; }\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tif (!m_isforest(vis, to, node)) { return false; }\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\ntemplate <typename T = int>\r\nclass D_Forest : public Graph_T <T> {\r\npublic:\r\n\tusing Graph_T <T>::edges;\r\n\tusing Graph_T <T>::adj;\r\n\tusing Graph_T <T>::size;\r\n\t\r\n\tD_Forest(int SIZE) : Graph_T <T>(SIZE) { }\r\n\t\r\n\tint add(int from, int to, T weight = 1) {\r\n\t\tassert(0 <= from && from < size && 0 <= to && to < size);\r\n\t\tint ID = (int)edges.size();\r\n\t\tadj[from].push_back(ID);\r\n\t\tedges.push_back( {from, to, weight} );\r\n\t\treturn ID;\r\n\t}\r\n\t\r\n\tbool istree(int node = 0) {\r\n\t\tassert(size);\r\n\t\tstatic std::vector <bool> vis;\r\n\t\tif (!node) { vis.clear(); vis.resize(size, false); }\r\n\t\tvis[node] = true;\r\n\t\tbool ok = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].to;\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tok = ok & istree(to);\r\n\t\t}\r\n\t\tif (!node) { ok = ok & (std::count(all(vis), true) == size); }\r\n\t\treturn ok;\r\n\t}\r\n\t\r\n\tbool isforest() {\r\n\t\tassert(size);\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tif (!vis[i]) {\r\n\t\t\t\tif (!m_isforest(vis, i)) { return false; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tT pathUV(int u, int v) {\r\n\t\tstd::priority_queue <std::pair <T, int>> pq;\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tpq.push(std::make_pair(0, u));\r\n\t\tvis[u] = true;\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tauto now = pq.top(); pq.pop();\r\n\t\t\tif (now.second == v) return -now.first;\r\n\t\t\tfor (const int& x : adj[now.second]) {\r\n\t\t\t\tint to = edges[x].to;\r\n\t\t\t\tif (!vis[to]) {\r\n\t\t\t\t\tpq.push(std::make_pair(now.first - edges[x].weight, to));\r\n\t\t\t\t\tvis[to] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (T)-1;\r\n\t}\r\n\t\r\nprivate:\r\n\tbool m_isforest(std::vector <bool>& vis, int node, int parent = -1) {\r\n\t\tvis[node] = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].to;\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tif (!m_isforest(vis, to, node)) { return false; }\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\ntemplate <typename T = int>\r\nclass Graph : public Graph_T <T> {\r\npublic:\r\n\tusing Graph_T <T>::edges;\r\n\tusing Graph_T <T>::adj;\r\n\tusing Graph_T <T>::size;\r\n\t\r\n\tGraph(int SIZE) : Graph_T <T>(SIZE) { }\r\n\t\r\n\tint add(int from, int to, T weight = 1) {\r\n\t\tassert(0 <= from && from < size && 0 <= to && to < size);\r\n\t\tint ID = (int)edges.size();\r\n\t\tadj[from].push_back(ID);\r\n\t\tadj[to].push_back(ID);\r\n\t\tedges.push_back( {from, to, weight} );\r\n\t\treturn ID;\r\n\t}\r\n\t\r\n\tbool istree(int node = 0, int parent = -1) {\r\n\t\tassert(size);\r\n\t\tstatic std::vector <bool> vis;\r\n\t\tif (!node && parent == -1) { vis.clear(); vis.resize(size, false); }\r\n\t\tvis[node] = true;\r\n\t\tbool ok = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].from ^ edges[x].to ^ node;\r\n\t\t\tif (to == parent) { continue; }\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tok = ok & istree(to, node);\r\n\t\t}\r\n\t\tif (!node && parent == -1) { ok = ok & (std::count(all(vis), true) == size); }\r\n\t\treturn ok;\r\n\t}\r\n\t\r\n\tbool isforest() {\r\n\t\tassert(size);\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tif (!vis[i]) {\r\n\t\t\t\tif (!m_isforest(vis, i)) { return false; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tT pathUV(int u, int v) {\r\n\t\tstd::priority_queue <std::pair <T, int>> pq;\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tpq.push(std::make_pair(0, u));\r\n\t\tvis[u] = true;\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tauto now = pq.top(); pq.pop();\r\n\t\t\tif (now.second == v) return -now.first;\r\n\t\t\tfor (const int& x : adj[now.second]) {\r\n\t\t\t\tint to = edges[x].from ^ edges[x].to ^ now.second;\r\n\t\t\t\tif (!vis[to]) {\r\n\t\t\t\t\tpq.push(std::make_pair(now.first - edges[x].weight, to));\r\n\t\t\t\t\tvis[to] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (T)-1;\r\n\t}\r\n\t\r\nprivate:\r\n\tbool m_isforest(std::vector <bool>& vis, int node, int parent = -1) {\r\n\t\tvis[node] = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].from ^ edges[x].to ^ node;\r\n\t\t\tif (to == parent) { continue; }\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tif (!m_isforest(vis, to, node)) { return false; }\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\ntemplate <typename T = int>\r\nclass D_Graph : public Graph_T <T> {\r\npublic:\r\n\tusing Graph_T <T>::edges;\r\n\tusing Graph_T <T>::adj;\r\n\tusing Graph_T <T>::size;\r\n\t\r\n\tD_Graph(int SIZE) : Graph_T <T>(SIZE) { }\r\n\t\r\n\tint add(int from, int to, T weight = 1) {\r\n\t\tassert(0 <= from && from < size && 0 <= to && to < size);\r\n\t\tint ID = (int)edges.size();\r\n\t\tadj[from].push_back(ID);\r\n\t\tedges.push_back( {from, to, weight} );\r\n\t\treturn ID;\r\n\t}\r\n\t\r\n\tbool istree(int node = 0) {\r\n\t\tassert(size);\r\n\t\tstatic std::vector <bool> vis;\r\n\t\tif (!node) { vis.clear(); vis.resize(size, false); }\r\n\t\tvis[node] = true;\r\n\t\tbool ok = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].to;\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tok = ok & istree(to);\r\n\t\t}\r\n\t\tif (!node) { ok = ok & (std::count(all(vis), true) == size); }\r\n\t\treturn ok;\r\n\t}\r\n\t\r\n\tbool isforest() {\r\n\t\tassert(size);\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tif (!vis[i]) {\r\n\t\t\t\tif (!m_isforest(vis, i)) { return false; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tT pathUV(int u, int v) {\r\n\t\tstd::priority_queue <std::pair <T, int>> pq;\r\n\t\tstd::vector <bool> vis(size, false);\r\n\t\tpq.push(std::make_pair(0, u));\r\n\t\tvis[u] = true;\r\n\t\twhile (!pq.empty()) {\r\n\t\t\tauto now = pq.top(); pq.pop();\r\n\t\t\tif (now.second == v) return -now.first;\r\n\t\t\tfor (const int& x : adj[now.second]) {\r\n\t\t\t\tint to = edges[x].to;\r\n\t\t\t\tif (!vis[to]) {\r\n\t\t\t\t\tpq.push(std::make_pair(now.first - edges[x].weight, to));\r\n\t\t\t\t\tvis[to] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (T)-1;\r\n\t}\r\n\t\r\nprivate:\r\n\tbool m_isforest(std::vector <bool>& vis, int node, int parent = -1) {\r\n\t\tvis[node] = true;\r\n\t\tfor (const int& x : adj[node]) {\r\n\t\t\tint to = edges[x].to;\r\n\t\t\tif (vis[to]) { return false; }\r\n\t\t\tif (!m_isforest(vis, to, node)) { return false; }\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\nvoid solv(const int curt);\r\n\r\nconst bool isT = false;\r\n\r\nint main() {\r\n\tstd::ios::sync_with_stdio(0); std::cin.tie(0);\r\n\t\r\n\tint t = 1; if (isT) { std::cin >> t; }\r\n\tfor (int i = 1; i <= t; i++) { solv(i); }\r\n\t\r\n\treturn 0;\r\n}\r\n\r\nstruct P {\r\n\tll a;\r\n\tstd::vector <ll> s;\r\n\tP() { s.resize(10); }\r\n\tbool operator<(const P& other) const { return a > other.a; }\r\n};\r\n\r\nstd::vector <P> pers;\r\nstd::vector <std::vector <ll>> dp;\r\nll n, p, k;\r\n\r\nll rec(ll x, ll fi, ll se) {\r\n\tif (x == n) return 0;\r\n\tif (dp[x][fi] != -1) return dp[x][fi];\r\n\tll r = 0;\r\n\tif (x - se < k) r = pers[x].a;\r\n\tll rs = rec(x + 1, fi, se) + r;\r\n\tfor (int i = 0; i < p; i++) {\r\n\t\tif (fi & (1 << i)) continue;\r\n\t\trs = std::max(rs, pers[x].s[i] + rec(x + 1, fi | (1 << i), se + 1));\r\n\t}\r\n\tdp[x][fi] = rs;\r\n\treturn rs;\r\n}\r\n\r\nvoid solv(const int curt) {\r\n\t\r\n\tstd::cin >> n >> p >> k;\r\n\tpers.resize(n);\r\n\tdp.resize(n + 1, std::vector <ll>((1 << 7) + 3, -1));\r\n\tfor (int i = 0; i < n; i++) std::cin >> pers[i].a;\r\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < p; j++) std::cin >> pers[i].s[j];\r\n\tstd::sort(all(pers));\r\n\tll ans = rec(0, 0, 0);\r\n\tstd::cout << ans << \"\\n\";\r\n\t\r\n}\r\n"
}