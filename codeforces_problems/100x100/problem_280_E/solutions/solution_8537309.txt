{
    "id": 8537309,
    "contestId": 280,
    "creationTimeSeconds": 1415027102,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 280,
        "index": "E",
        "name": "Sequence Transformation",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 280,
        "members": [
            {
                "handle": "ydc"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362929400
    },
    "programmingLanguage": "GNU C++",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 9,
    "timeConsumedMillis": 2028,
    "memoryConsumedBytes": 21913600,
    "source": "#include<iostream>\r\n#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cmath>\r\n#include<algorithm>\r\n#define maxn 700010\r\n#define eps 1e-10\r\nusing namespace std;\r\ntypedef long long LL;\r\nint dcmp(double p)\r\n{\r\n    if(abs(p)<eps)\r\n        return 0;\r\n    return p>eps?1:-1;\r\n}\r\nint n,Q,A,B,x[maxn];\r\nstruct Node\r\n{\r\n    Node *son[2],*fa;\r\n    double len,sumlen;\r\n    LL k,b,A,B,C;\r\n    /*\r\n        Matrix\r\n        1 a 0\r\n        0 1 0\r\n        b c 1\r\n    */\r\n}*Root,*stack[maxn];\r\nint top;\r\ndouble low[maxn],ans[maxn],sum;\r\nvoid read()\r\n{\r\n    scanf(\"%d %d %d %d\",&n,&Q,&A,&B);\r\n    for(int i=1;i<=n;++i)\r\n        scanf(\"%d\",x+i);\r\n    for(int i=1;i<=2*n;++i)\r\n        stack[++top]=new Node;\r\n}\r\nvoid move(Node *p,LL x)\r\n{\r\n    /*\r\n        Matrix\r\n        1 x 0\r\n        0 1 0\r\n        0 0 1\r\n    */\r\n    p->A+=x,p->C+=p->B*x;\r\n}\r\nvoid add(Node *p,LL x)\r\n{\r\n    /*\r\n        Matrix\r\n        1 0 0\r\n        0 1 0\r\n        0 x 1\r\n    */\r\n    p->C+=x;\r\n}\r\nvoid addK(Node *p,LL x)\r\n{\r\n    /*\r\n        Matrix\r\n        1 0 0\r\n        0 1 0\r\n        x 0 1\r\n    */\r\n    p->B+=x;\r\n}\r\nvoid multi(Node *p,LL A,LL B,LL C)\r\n{\r\n    /*\r\n        1 a 0\r\n        0 1 0\r\n        b c 1\r\n    */\r\n    p->C+=p->B*A+C,p->A+=A,p->B+=B;\r\n}\r\nvoid push_down(Node *p)\r\n{\r\n    if(p->A||p->B||p->C)\r\n    {\r\n        if(p->son[0])\r\n            multi(p->son[0],p->A,p->B,p->C);\r\n        if(p->son[1])\r\n            multi(p->son[1],p->A,p->B,p->C);\r\n        p->b+=p->A*p->k+p->C,p->k+=p->B;\r\n        p->A=p->B=p->C=0;\r\n    }\r\n}\r\nNode* NewNode(LL k,LL b,double len)\r\n{\r\n    Node *p=stack[top--];\r\n    p->k=k,p->b=b,p->len=p->sumlen=len,p->A=p->B=p->C=0;\r\n    p->fa=p->son[0]=p->son[1]=0;\r\n    return p;\r\n}\r\nvoid Erase(Node *p)\r\n{\r\n    if(p==0)\r\n        return ;\r\n    stack[++top]=p;\r\n    Erase(p->son[0]),Erase(p->son[1]);\r\n}\r\nvoid update(Node *p)\r\n{\r\n    p->sumlen=p->len;\r\n    if(p->son[0])\r\n        p->sumlen+=p->son[0]->sumlen;\r\n    if(p->son[1])\r\n        p->sumlen+=p->son[1]->sumlen;\r\n}\r\nvoid Rotate(Node *p,Node *x)\r\n{\r\n    bool mark=p==x->son[1];\r\n    Node *y=p->son[mark^1],*z=x->fa;\r\n    if(y!=0)\r\n        y->fa=x;\r\n    if(z!=0)\r\n        z->son[x==z->son[1]]=p;\r\n    p->son[mark^1]=x,p->fa=z,x->son[mark]=y,x->fa=p,update(x);\r\n}\r\nvoid Splay(Node *p,Node *go)\r\n{\r\n    static Node *ancestor[maxn];\r\n    int top=0;\r\n    ancestor[++top]=p;\r\n    for(Node *i=p;i->fa!=go;i=i->fa)\r\n        ancestor[++top]=i->fa;\r\n    while(top)\r\n        push_down(ancestor[top--]);\r\n    while(p->fa!=go)\r\n    {\r\n        Node *x=p->fa,*y=x->fa;\r\n        if(y==go)\r\n            Rotate(p,x);\r\n        else if((p==x->son[1])^(x==y->son[1]))\r\n            Rotate(p,x),Rotate(p,y);\r\n        else\r\n            Rotate(x,y),Rotate(p,x);\r\n    }\r\n    update(p);\r\n    if(go==0)\r\n        Root=p;\r\n}\r\nNode* Find(Node *p,int d)\r\n{\r\n    if(!p->son[d])\r\n        return 0;\r\n    for(p=p->son[d];p->son[d^1];p=p->son[d^1]);\r\n    return p;\r\n}\r\nNode* Query(Node *p,double &l,double &r,double &x,double fr)\r\n{\r\n    double sum=fr;\r\n    while(1)\r\n    {\r\n        push_down(p);\r\n        double newl,newr;\r\n        newl=sum+(p->son[0]?p->son[0]->sumlen:0);\r\n        newr=newl+p->len;\r\n        l=newl,r=newr;\r\n        double X=-1.0*p->b/p->k;\r\n        if(X<newl)\r\n        {\r\n            if(p->son[0])\r\n                p=p->son[0];\r\n            else\r\n            {\r\n                x=newl;\r\n                break;\r\n            }\r\n        }\r\n        else if(newr<X)\r\n        {\r\n            if(p->son[1])\r\n                sum=newr,p=p->son[1];\r\n            else\r\n            {\r\n                x=newr;\r\n                break;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            l=newl,r=newr,x=X;\r\n            break;\r\n        }\r\n    }\r\n    Splay(p,0);\r\n    return p;\r\n}\r\nNode* Query(Node *p,double x,double &l,double fr)\r\n{\r\n    double sum=fr;\r\n    while(1)\r\n    {\r\n        push_down(p);\r\n        double newl,newr;\r\n        newl=sum+(p->son[0]?p->son[0]->sumlen:0);\r\n        newr=newl+p->len;\r\n        if(x<newl)\r\n            p=p->son[0];\r\n        else if(newr<x)\r\n            p=p->son[1],sum=newr;\r\n        else\r\n        {\r\n            l=newl;\r\n            break;\r\n        }\r\n    }\r\n    Splay(p,0);\r\n    return p;\r\n}\r\nvoid Delete(Node *p)\r\n{\r\n    Splay(p,0);\r\n    if(p->son[0]==0&&p->son[1]!=0)\r\n        p->son[1]->fa=0,Root=p->son[1];\r\n    else if(p->son[1]==0&&p->son[0]!=0)\r\n        p->son[0]->fa=0,Root=p->son[0];\r\n    else\r\n    {\r\n        Node *i;\r\n        for(i=p->son[0];i->son[1];i=i->son[1]);\r\n        i->son[1]=p->son[1],p->son[1]->fa=i,p->son[0]->fa=0,Splay(i,0);\r\n    }\r\n    stack[++top]=p;\r\n}\r\nvoid Print(Node *p,double fr,int f)\r\n{\r\n    if(p==0)\r\n        return ;\r\n    double sum=p->son[0]?p->son[0]->sumlen+fr:fr;\r\n    push_down(p);\r\n    Print(p->son[0],fr,f);\r\n    if(f)\r\n        printf(\"%f %f %I64dx%I64d\\n\",sum,sum+p->len,p->k,p->b);\r\n    Print(p->son[1],sum+p->len,f);\r\n}\r\nvoid work()\r\n{\r\n    Root=NewNode(2,-2*x[1],Q-1);\r\n    for(int i=2;i<=n;++i)\r\n    {\r\n        double l,r;\r\n        Node *p=Query(Root,l,r,low[i-1],A*(i-2)+1);\r\n        Node *a=Find(p,0),*b=Find(p,1);\r\n        Node *q=NewNode(p->k,p->b,r-low[i-1]);\r\n        Node *nq;\r\n        p->len=low[i-1]-l,update(p);\r\n        if(a==0)\r\n        {\r\n            if(p->son[1])\r\n                p->son[1]->fa=q;\r\n            q->son[1]=p->son[1],p->son[1]=q,q->fa=p,Splay(q,0);\r\n        }\r\n        else if(b==0)\r\n            p->son[1]=q,q->fa=p,Splay(q,0);\r\n        else\r\n        {\r\n            Splay(a,0),Splay(b,a);\r\n            p->son[1]=q,q->fa=p,Splay(q,0);\r\n        }\r\n        if(A<B)\r\n        {\r\n            nq=NewNode(0,0,B-A);\r\n            Splay(p,0),Splay(q,Root),q->son[0]=nq,nq->fa=q,Splay(nq,0);\r\n        }\r\n        if(dcmp(low[i-1]-l)<=0)\r\n            Delete(p);\r\n        if(dcmp(r-low[i-1])<=0)\r\n            Delete(q);\r\n        if(dcmp(low[i-1]-l)>0)\r\n        {\r\n            if(A<B)\r\n                Splay(nq,0),Splay(p,nq);\r\n            else if(dcmp(r-low[i-1])>0)\r\n                Splay(q,0),Splay(p,q);\r\n            else\r\n                Splay(p,0);\r\n            move(p,-A);\r\n        }\r\n        if(dcmp(r-low[i-1])>0)\r\n        {\r\n            if(A<B)\r\n                Splay(nq,0),Splay(q,nq);\r\n            else if(dcmp(low[i-1]-l)>0)\r\n                Splay(p,0),Splay(q,p);\r\n            else\r\n                Splay(q,0);\r\n            move(q,-B);\r\n        }\r\n        //Print(Root,A*(i-1)+1,0);\r\n        //if(i==n-1)  printf(\"#################################################\\n\");\r\n        p=Query(Root,Q,l,A*(i-1)+1);\r\n        p->len=Q-l,Erase(p->son[1]),update(p);\r\n        //Print(Root,A*(i-1)+1,0);\r\n        p->son[1]=0,add(p,-2*x[i]),addK(p,2);\r\n        Print(Root,A*(i-1)+1,0);\r\n        //printf(\"##################################################\\n\");\r\n    }\r\n    double l,r;\r\n    Query(Root,l,r,ans[n],A*(n-1)+1);\r\n}\r\nvoid print(int p)\r\n{\r\n    sum+=(ans[p]-x[p])*(ans[p]-x[p]);\r\n    if(p>1)\r\n    {\r\n        double l=ans[p]-B,r=ans[p]-A;\r\n        if(dcmp(low[p-1]-l)<0)\r\n            ans[p-1]=l;\r\n        else if(dcmp(low[p-1]-r)>0)\r\n            ans[p-1]=r;\r\n        else\r\n            ans[p-1]=low[p-1];\r\n        print(p-1);\r\n    }\r\n    printf(\"%.10f%c\",ans[p],p<n?' ':'\\n');\r\n}\r\nint main()\r\n{\r\n    read();\r\n    work();\r\n    print(n);\r\n    printf(\"%.10f\\n\",sum);\r\n    return 0;\r\n}\r\n"
}