{
    "id": 8541897,
    "contestId": 280,
    "creationTimeSeconds": 1415061611,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 280,
        "index": "E",
        "name": "Sequence Transformation",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 280,
        "members": [
            {
                "handle": "ydc"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362929400
    },
    "programmingLanguage": "GNU C++",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 20889600,
    "source": "#include<iostream>\r\n#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cmath>\r\n#include<algorithm>\r\n#define maxn 700010\r\n#define eps 1e-10\r\nusing namespace std;\r\ntypedef long long LL;\r\nint dcmp(double p)\r\n{\r\n\tif(abs(p)<eps)\r\n\t\treturn 0;\r\n\treturn p>eps?1:-1;\r\n}\r\nint n,Q,A,B,x[maxn];\r\nstruct Node\r\n{\r\n\tNode *son[2],*fa;\r\n\tdouble len,sumlen;\r\n\tLL k,b,A,B,C;\r\n\t/*\r\n\t\tMatrix\r\n\t\t1 a 0\r\n\t\t0 1 0\r\n\t\tb c 1\r\n\t*/\r\n}*Root,*stack[maxn];\r\nint top;\r\ndouble low[maxn],ans[maxn],sum;\r\nvoid read()\r\n{\r\n\tscanf(\"%d %d %d %d\",&n,&Q,&A,&B);\r\n\tfor(int i=1;i<=n;++i)\r\n\t\tscanf(\"%d\",x+i);\r\n\tfor(int i=1;i<=2*n;++i)\r\n\t\tstack[++top]=new Node;\r\n}\r\nvoid move(Node *p,LL x)\r\n{\r\n\t/*\r\n\t\tMatrix\r\n\t\t1 x 0\r\n\t\t0 1 0\r\n\t\t0 0 1\r\n\t*/\r\n\tp->A+=x,p->C+=p->B*x;\r\n}\r\nvoid add(Node *p,LL x)\r\n{\r\n\t/*\r\n\t\tMatrix\r\n\t\t1 0 0\r\n\t\t0 1 0\r\n\t\t0 x 1\r\n\t*/\r\n\tp->C+=x;\r\n}\r\nvoid addK(Node *p,LL x)\r\n{\r\n\t/*\r\n\t\tMatrix\r\n\t\t1 0 0\r\n\t\t0 1 0\r\n\t\tx 0 1\r\n\t*/\r\n\tp->B+=x;\r\n}\r\nvoid multi(Node *p,LL A,LL B,LL C)\r\n{\r\n\t/*\r\n\t\t1 a 0\r\n\t\t0 1 0\r\n\t\tb c 1\r\n\t*/\r\n\tp->C+=p->B*A+C,p->A+=A,p->B+=B;\r\n}\r\nvoid push_down(Node *p)\r\n{\r\n\tif(p->A||p->B||p->C)\r\n\t{\r\n\t\tif(p->son[0])\r\n\t\t\tmulti(p->son[0],p->A,p->B,p->C);\r\n\t\tif(p->son[1])\r\n\t\t\tmulti(p->son[1],p->A,p->B,p->C);\r\n\t\tp->b+=p->A*p->k+p->C,p->k+=p->B;\r\n\t\tp->A=p->B=p->C=0;\r\n\t}\r\n}\r\nNode* NewNode(LL k,LL b,double len)\r\n{\r\n\tNode *p=stack[top--];\r\n\tp->k=k,p->b=b,p->len=p->sumlen=len,p->A=p->B=p->C=0;\r\n\tp->fa=p->son[0]=p->son[1]=0;\r\n\treturn p;\r\n}\r\nvoid Erase(Node *p)\r\n{\r\n\tif(p==0)\r\n\t\treturn ;\r\n\tstack[++top]=p;\r\n\tErase(p->son[0]),Erase(p->son[1]);\r\n}\r\nvoid update(Node *p)\r\n{\r\n\tp->sumlen=p->len;\r\n\tif(p->son[0])\r\n\t\tp->sumlen+=p->son[0]->sumlen;\r\n\tif(p->son[1])\r\n\t\tp->sumlen+=p->son[1]->sumlen;\r\n}\r\nvoid Rotate(Node *p,Node *x)\r\n{\r\n\tbool mark=p==x->son[1];\r\n\tNode *y=p->son[mark^1],*z=x->fa;\r\n\tif(y!=0)\r\n\t\ty->fa=x;\r\n\tif(z!=0)\r\n\t\tz->son[x==z->son[1]]=p;\r\n\tp->son[mark^1]=x,p->fa=z,x->son[mark]=y,x->fa=p,update(x);\r\n}\r\nvoid Splay(Node *p,Node *go)\r\n{\r\n\tstatic Node *ancestor[maxn];\r\n\tint top=0;\r\n\tancestor[++top]=p;\r\n\tfor(Node *i=p;i->fa!=go;i=i->fa)\r\n\t\tancestor[++top]=i->fa;\r\n\twhile(top)\r\n\t\tpush_down(ancestor[top--]);\r\n\twhile(p->fa!=go)\r\n\t{\r\n\t\tNode *x=p->fa,*y=x->fa;\r\n\t\tif(y==go)\r\n\t\t\tRotate(p,x);\r\n\t\telse if((p==x->son[1])^(x==y->son[1]))\r\n\t\t\tRotate(p,x),Rotate(p,y);\r\n\t\telse\r\n\t\t\tRotate(x,y),Rotate(p,x);\r\n\t}\r\n\tupdate(p);\r\n\tif(go==0)\r\n\t\tRoot=p;\r\n}\r\nNode* Find(Node *p,int d)\r\n{\r\n\tif(!p->son[d])\r\n\t\treturn 0;\r\n\tfor(p=p->son[d];p->son[d^1];p=p->son[d^1]);\r\n\treturn p;\r\n}\r\nNode* Query(Node *p,double &l,double &r,double &x,double fr)\r\n{\r\n\tdouble sum=fr;\r\n\twhile(1)\r\n\t{\r\n\t\tpush_down(p);\r\n\t\tdouble newl,newr;\r\n\t\tnewl=sum+(p->son[0]?p->son[0]->sumlen:0);\r\n\t\tnewr=newl+p->len;\r\n\t\tl=newl,r=newr;\r\n\t\tdouble X=-1.0*p->b/p->k;\r\n\t\tif(X<newl)\r\n\t\t{\r\n\t\t\tif(p->son[0])\r\n\t\t\t\tp=p->son[0];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx=newl;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(newr<X)\r\n\t\t{\r\n\t\t\tif(p->son[1])\r\n\t\t\t\tsum=newr,p=p->son[1];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx=newr;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tl=newl,r=newr,x=X;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tSplay(p,0);\r\n\treturn p;\r\n}\r\nNode* Query(Node *p,double x,double &l,double fr)\r\n{\r\n\tdouble sum=fr;\r\n\twhile(1)\r\n\t{\r\n\t\tpush_down(p);\r\n\t\tdouble newl,newr;\r\n\t\tnewl=sum+(p->son[0]?p->son[0]->sumlen:0);\r\n\t\tnewr=newl+p->len;\r\n\t\tif(x<newl)\r\n\t\t\tp=p->son[0];\r\n\t\telse if(newr<x)\r\n\t\t\tp=p->son[1],sum=newr;\r\n\t\telse\r\n\t\t{\r\n\t\t\tl=newl;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tSplay(p,0);\r\n\treturn p;\r\n}\r\nvoid Delete(Node *p)\r\n{\r\n\tSplay(p,0);\r\n\tif(p->son[0]==0&&p->son[1]!=0)\r\n\t\tp->son[1]->fa=0,Root=p->son[1];\r\n\telse if(p->son[1]==0&&p->son[0]!=0)\r\n\t\tp->son[0]->fa=0,Root=p->son[0];\r\n\telse\r\n\t{\r\n\t\tNode *i;\r\n\t\tfor(i=p->son[0];i->son[1];i=i->son[1]);\r\n\t\ti->son[1]=p->son[1],p->son[1]->fa=i,p->son[0]->fa=0,Splay(i,0);\r\n\t}\r\n\tstack[++top]=p;\r\n}\r\nvoid Print(Node *p,double fr,int f)\r\n{\r\n\tif(p==0)\r\n\t\treturn ;\r\n\tdouble sum=p->son[0]?p->son[0]->sumlen+fr:fr;\r\n\tpush_down(p);\r\n\tPrint(p->son[0],fr,f);\r\n\tif(f)\r\n\t\tprintf(\"%f %f %I64dx%I64d\\n\",sum,sum+p->len,p->k,p->b);\r\n\tPrint(p->son[1],sum+p->len,f);\r\n}\r\nvoid work()\r\n{\r\n\tRoot=NewNode(2,-2*x[1],Q-1);\r\n\tfor(int i=2;i<=n;++i)\r\n\t{\r\n\t\tdouble l,r;\r\n\t\tNode *p=Query(Root,l,r,low[i-1],A*(i-2)+1);\r\n\t\tNode *a=Find(p,0),*b=Find(p,1);\r\n\t\tNode *q=NewNode(p->k,p->b,r-low[i-1]);\r\n\t\tNode *nq;\r\n\t\tp->len=low[i-1]-l,update(p);\r\n\t\tif(a==0)\r\n\t\t{\r\n\t\t\tif(p->son[1])\r\n\t\t\t\tp->son[1]->fa=q;\r\n\t\t\tq->son[1]=p->son[1],p->son[1]=q,q->fa=p,Splay(q,0);\r\n\t\t}\r\n\t\telse if(b==0)\r\n\t\t\tp->son[1]=q,q->fa=p,Splay(q,0);\r\n\t\telse\r\n\t\t{\r\n\t\t\tSplay(a,0),Splay(b,a);\r\n\t\t\tp->son[1]=q,q->fa=p,Splay(q,0);\r\n\t\t}\r\n\t\tif(A<B)\r\n\t\t{\r\n\t\t\tnq=NewNode(0,0,B-A);\r\n\t\t\tSplay(p,0),Splay(q,Root),q->son[0]=nq,nq->fa=q,Splay(nq,0);\r\n\t\t}\r\n\t\tif(dcmp(low[i-1]-l)<=0)\r\n\t\t\tDelete(p);\r\n\t\tif(dcmp(r-low[i-1])<=0)\r\n\t\t\tDelete(q);\r\n\t\tif(dcmp(low[i-1]-l)>0)\r\n\t\t{\r\n\t\t\tif(A<B)\r\n\t\t\t\tSplay(nq,0),Splay(p,nq);\r\n\t\t\telse if(dcmp(r-low[i-1])>0)\r\n\t\t\t\tSplay(q,0),Splay(p,q);\r\n\t\t\telse\r\n\t\t\t\tSplay(p,0);\r\n\t\t\tmove(p,-A);\r\n\t\t}\r\n\t\tif(dcmp(r-low[i-1])>0)\r\n\t\t{\r\n\t\t\tif(A<B)\r\n\t\t\t\tSplay(nq,0),Splay(q,nq);\r\n\t\t\telse if(dcmp(low[i-1]-l)>0)\r\n\t\t\t\tSplay(p,0),Splay(q,p);\r\n\t\t\telse\r\n\t\t\t\tSplay(q,0);\r\n\t\t\tmove(q,-B);\r\n\t\t}\r\n\t\t//Print(Root,A*(i-1)+1,0);\r\n\t\t//if(i==n-1)  printf(\"#################################################\\n\");\r\n\t\tp=Query(Root,Q,l,A*(i-1)+1);\r\n\t\tp->len=Q-l,Erase(p->son[1]),update(p);\r\n\t\t//Print(Root,A*(i-1)+1,0);\r\n\t\tp->son[1]=0,add(p,-2*x[i]),addK(p,2);\r\n\t\t//Print(Root,A*(i-1)+1,1);\r\n\t\t//printf(\"##################################################\\n\");\r\n\t}\r\n\tdouble l,r;\r\n\tQuery(Root,l,r,ans[n],A*(n-1)+1);\r\n}\r\nvoid print(int p)\r\n{\r\n\tsum+=(ans[p]-x[p])*(ans[p]-x[p]);\r\n\tif(p>1)\r\n\t{\r\n\t\tdouble l=ans[p]-B,r=ans[p]-A;\r\n\t\tif(dcmp(low[p-1]-l)<0)\r\n\t\t\tans[p-1]=l;\r\n\t\telse if(dcmp(low[p-1]-r)>0)\r\n\t\t\tans[p-1]=r;\r\n\t\telse\r\n\t\t\tans[p-1]=low[p-1];\r\n\t\tprint(p-1);\r\n\t}\r\n\tprintf(\"%f%c\",ans[p],p<n?' ':'\\n');\r\n}\r\nint main()\r\n{\r\n\tread();\r\n\twork();\r\n\tprint(n);\r\n\tprintf(\"%.10f\\n\",sum);\r\n\treturn 0;\r\n}\r\n"
}