{
    "id": 57806500,
    "contestId": 1192,
    "creationTimeSeconds": 1564154575,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "ko_osaga"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 1060,
    "memoryConsumedBytes": 131993600,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\r\n#define sz(v) ((int)(v).size())\r\nusing namespace std;\r\nconst int MAXN = 150005;\r\nusing lint = long long;\r\nusing pi = pair<int, int>;\r\nconst int dx[8] = {1, 0, -1, 0, -1, -1, 1, 1};\r\nconst int dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};\r\n \r\nstruct AGISEOKHWAN{\r\n\tint pa[MAXN];\r\n\tvoid init(int n){\r\n\t\tiota(pa, pa + n + 1, 0);\r\n\t}\r\n\tint find(int x){\r\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\r\n\t}\r\n\tbool uni(int p, int q){\r\n\t\tp = find(p); q = find(q);\r\n\t\tif(p == q) return 0;\r\n\t\tpa[q] = p; return 1;\r\n\t}\r\n}AGISEOKHWAN;\r\n \r\nstruct point{\r\n\tint x, y, idx;\r\n\tbool operator<(const point &p)const{\r\n\t\treturn pi(x, y) < pi(p.x, p.y);\r\n\t}\r\n}a[MAXN];\r\n \r\nstruct node{\r\n\tint x, y, fs;\r\n};\r\n \r\nvector<node> disj[MAXN * 4];\r\n \r\nint n;\r\nbool vis[MAXN];\r\n \r\npi dual_edge[MAXN][4];\r\nint prec[MAXN][8];\r\nint faces;\r\nint outer_area;\r\nint V[MAXN], E[MAXN], F[MAXN];\r\n  \r\nint getV(int x){\r\n\tint msk = 0;\r\n\tfor(int j=0; j<8; j++){\r\n\t\tint pos = prec[x][j];\r\n\t\tif(pos != -1 && !vis[pos]){\r\n\t\t\tif(dx[j] <= 0 && dy[j] <= 0) msk |= 1;\r\n\t\t\tif(dx[j] <= 0 && dy[j] >= 0) msk |= 2;\r\n\t\t\tif(dx[j] >= 0 && dy[j] >= 0) msk |= 4;\r\n\t\t\tif(dx[j] >= 0 && dy[j] <= 0) msk |= 8;\r\n\t\t}\r\n\t}\r\n\tmsk ^= 15;\r\n\tint remVtx = 0;\r\n\tfor(int i=0; i<4; i++){\r\n\t\tif((msk >> i) & 1) remVtx++;\r\n\t}\r\n\treturn remVtx;\r\n}\r\n \r\nint getE(int x){\r\n\tint remEdg = 4;\r\n\tfor(int i=0; i<4; i++){\r\n\t\tint pos = prec[x][i];\r\n\t\tif(pos != -1 && !vis[pos]){\r\n\t\t\tremEdg--;\r\n\t\t}\r\n\t}\r\n\treturn remEdg;\r\n}\r\n\r\nint rev[MAXN];\r\nset<int> s[MAXN];\r\npriority_queue<pi> pq;\r\nbool chk[MAXN];\r\n\r\nvoid enq(int x){\r\n\tif(chk[x] && !vis[x]){\r\n\t\tpq.emplace(V[x] - E[x] + F[x], a[x].idx);\r\n\t}\r\n}\r\n\r\nint getF(int x){\r\n\ts[x].clear();\r\n\tfor(int i=0; i<4; i++){\r\n\t\tint pos = prec[x][i];\r\n\t\tif(pos != -1 && !vis[pos]){\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ts[x].insert(dual_edge[x][i].first);\r\n\t\t\ts[x].insert(dual_edge[x][i].second);\r\n\t\t}\r\n\t}\r\n\tif(s[x].find(outer_area) != s[x].end()) chk[x] = 1;\r\n\treturn max(sz(s[x]) - 1, 0);\r\n}\r\n \r\nvoid uni(int x, int y){\r\n\tif(x == y) return;\r\n\tif(disj[x].size() < disj[y].size()) swap(x, y);\r\n\tif(outer_area == y){\r\n\t\touter_area = x;\r\n\t\tfor(auto &i : disj[x]){\r\n\t\t\tF[i.x] = getF(i.x);\r\n\t\t\tenq(i.x);\r\n\t\t}\r\n\t}\r\n\tfor(auto &i : disj[y]){\r\n\t\tdisj[x].push_back(i);\r\n\t\tif(i.fs == 0){\r\n\t\t\tdual_edge[i.x][i.y].first = x;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tdual_edge[i.x][i.y].second = x;\r\n\t\t}\r\n\t}\r\n\tfor(auto &i : disj[y]){\r\n\t\tF[i.x] = getF(i.x);\r\n\t\tenq(i.x);\r\n\t}\r\n\tdisj[y].clear();\r\n}\r\n \r\nvoid relax(int x){\r\n\tfor(int i=0; i<4; i++){\r\n\t\tint pos = prec[x][i];\r\n\t\tif(pos != -1 && !vis[pos]){\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tuni(dual_edge[x][i].first, dual_edge[x][i].second);\r\n\t\t}\r\n\t}\r\n\tfor(int j=0; j<8; j++){\r\n\t\tint pos = prec[x][j];\r\n\t\tif(pos != -1 && !vis[pos]){\r\n\t\t\tV[pos] = getV(pos);\r\n\t\t\tE[pos] = getE(pos);\r\n\t\t\tF[pos] = getF(pos);\r\n\t\t\tenq(pos);\r\n\t\t}\r\n\t}\r\n}\r\n \r\nvoid solve(){\r\n\tvector<int> seq;\r\n\tfor(int i=0; i<n; i++){\r\n\t\tV[i] = getV(i);\r\n\t\tE[i] = getE(i);\r\n\t\tF[i] = getF(i);\r\n\t}\r\n\tfor(int i=0; i<n; i++) enq(i);\r\n\tfor(int i=0; i<n-1; i++){\r\n\t\tpi ret(-1e9, -1e9);\r\n\t\twhile(!pq.empty()){\r\n\t\t\tauto x = pq.top(); pq.pop();\r\n\t\t\tint y = rev[x.second];\r\n\t\t\tif(vis[y] || V[y] - E[y] + F[y] != 0 || V[y] - E[y] + F[y] != x.first) continue;\r\n\t\t\tret = pi(x.second, y);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tassert(ret.first > 0);\r\n\t\tvis[ret.second] = 1;\r\n\t\tseq.push_back(ret.first);\r\n\t\trelax(ret.second);\r\n\t}\r\n\tfor(int i=0; i<n; i++){\r\n\t\tif(!vis[i]) seq.push_back(a[i].idx);\r\n\t}\r\n\tputs(\"YES\");\r\n\treverse(seq.begin(), seq.end());\r\n\tfor(auto &i : seq) printf(\"%d\\n\", i);\r\n}\r\n \r\nvector<pi> dual_vtx;\r\nint gph[MAXN * 4][4];\r\nint fce[MAXN * 4][4];\r\n \r\nint main(){\r\n\tscanf(\"%d %*d\",&n);\r\n\tfor(int i=0; i<n; i++){\r\n\t\tscanf(\"%d %d\",&a[i].x,&a[i].y);\r\n\t\ta[i].idx = i + 1;\r\n\t\tfor(int j=0; j<2; j++){\r\n\t\t\tfor(int k=0; k<2; k++){\r\n\t\t\t\tdual_vtx.emplace_back(a[i].x + j, a[i].y + k);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tsort(dual_vtx.begin(), dual_vtx.end());\r\n\tdual_vtx.resize(unique(dual_vtx.begin(), dual_vtx.end()) - dual_vtx.begin());\r\n\tsort(a, a + n);\r\n\tint comp = n;\r\n\tAGISEOKHWAN.init(n);\r\n\tfor(int i=0; i<n; i++){\r\n\t\trev[a[i].idx] = i;\r\n\t\tfor(int j=0; j<8; j++){\r\n\t\t\tint pos = lower_bound(a, a + n, (point){a[i].x + dx[j], a[i].y + dy[j], -1}) - a;\r\n\t\t\tif(pos < n && pi(a[i].x + dx[j], a[i].y + dy[j]) == pi(a[pos].x, a[pos].y)){\r\n\t\t\t\tprec[i][j] = pos;\r\n\t\t\t\tcomp -= AGISEOKHWAN.uni(i, pos);\r\n\t\t\t}\r\n\t\t\telse prec[i][j] = -1;\r\n\t\t}\r\n\t}\r\n\tif(comp != 1){\r\n\t\tputs(\"NO\");\r\n\t\treturn 0;\r\n\t}\r\n\tmemset(gph, -1, sizeof(gph));\r\n\tmemset(fce, -1, sizeof(fce));\r\n\tauto add_edge = [&](int sx, int sy, int ex, int ey, int dir1, int dir2){\r\n\t\tauto l = lower_bound(dual_vtx.begin(), dual_vtx.end(), pi(sx, sy)) - dual_vtx.begin();\r\n\t\tauto r = lower_bound(dual_vtx.begin(), dual_vtx.end(), pi(ex, ey)) - dual_vtx.begin();\r\n\t\tgph[l][dir1] = r;\r\n\t\tgph[r][dir2] = l;\r\n\t};\r\n\tfor(int i=0; i<n; i++){\r\n\t\tadd_edge(a[i].x, a[i].y, a[i].x + 1, a[i].y, 0, 2);\r\n\t\tadd_edge(a[i].x, a[i].y, a[i].x, a[i].y + 1, 1, 3);\r\n\t\tadd_edge(a[i].x + 1, a[i].y + 1, a[i].x + 1, a[i].y, 3, 1);\r\n\t\tadd_edge(a[i].x + 1, a[i].y + 1, a[i].x, a[i].y + 1, 2, 0);\r\n\t}\r\n\tauto getPos = [&](pi p){\r\n\t\tint pos = lower_bound(dual_vtx.begin(), dual_vtx.end(), p) - dual_vtx.begin();\r\n\t\treturn pos;\r\n\t};\r\n\tauto getNext = [&](int pos, int d){\r\n\t\tauto p = dual_vtx[pos];\r\n\t\tp.first += dx[d];\r\n\t\tp.second += dy[d];\r\n\t\treturn getPos(p);\r\n\t};\r\n\tfor(int i=0; i<dual_vtx.size(); i++){\r\n\t\tfor(int j=0; j<4; j++){\r\n\t\t\tif(gph[i][j] != -1 && fce[i][j] == -1){\r\n\t\t\t\tfaces++;\r\n\t\t\t\tint px = i, py = j;\r\n\t\t\t\twhile(fce[px][py] == -1){\r\n\t\t\t\t\tfce[px][py] = faces;\r\n\t\t\t\t\tpx = getNext(px, py);\r\n\t\t\t\t\tpy ^= 2;\r\n\t\t\t\t\tpy = (py + 1) % 4;\r\n\t\t\t\t\twhile(gph[px][py] == -1) py = (py + 1) % 4;\r\n\t\t\t\t}\r\n\t\t\t\tassert(px == i && py == j);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=0; i<n; i++){\r\n\t\tint ll = getPos(pi(a[i].x, a[i].y));\r\n\t\tint lr = getPos(pi(a[i].x, a[i].y + 1));\r\n\t\tint rl = getPos(pi(a[i].x + 1, a[i].y));\r\n\t\tint rr = getPos(pi(a[i].x + 1, a[i].y + 1));\r\n\t\tdual_edge[i][0] = pi(fce[rl][1], fce[rr][3]);\r\n\t\tdual_edge[i][1] = pi(fce[rr][2], fce[lr][0]);\r\n\t\tdual_edge[i][2] = pi(fce[lr][3], fce[ll][1]);\r\n\t\tdual_edge[i][3] = pi(fce[ll][0], fce[rl][2]);\r\n\t\tfor(int j=0; j<4; j++){\r\n\t\t\tdisj[dual_edge[i][j].first].push_back({i, j, 0});\r\n\t\t\tdisj[dual_edge[i][j].second].push_back({i, j, 1});\r\n\t\t}\r\n\t}\r\n\touter_area = fce[0][0];\r\n\tsolve();\r\n}\r\n\r\n"
}