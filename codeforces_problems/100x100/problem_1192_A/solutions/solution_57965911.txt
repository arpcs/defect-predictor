{
    "id": 57965911,
    "contestId": 1192,
    "creationTimeSeconds": 1564454661,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Nishihara"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 1388,
    "memoryConsumedBytes": 48332800,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n \r\nusing namespace std;\r\n#define PB push_back\r\n#define MP make_pair\r\n#define st first\r\n#define nd second\r\n#define ALL(x) (x).begin(), (x).end()\r\n#define SZ(x) ((int)(x).size())\r\n \r\n#define unordered_map __fast_unordered_map\r\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\r\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\r\n \r\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\r\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\r\n \r\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\r\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\r\n  while(*sdbg!=',')cerr<<*sdbg++;\r\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\r\n}\r\n \r\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\r\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\r\n}\r\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\r\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\r\n}\r\n \r\n#ifdef LOCAL\r\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\r\n#else\r\n#define debug(...) (__VA_ARGS__)\r\n#define cerr if(0)cout\r\n#endif\r\n \r\nusing ll = long long;\r\nusing vi = vector<int>;\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing vll = vector<ll>;\r\nusing ld = long double;\r\n \r\nconst int kMaxN = 2e5;\r\nconst int kMaxVert = 5e5;\r\nconst int M = 1.02e9;\r\n \r\nconst int dr[] = {-1, -1, -1, 0, 1, 1,  1,  0};\r\nconst int dc[] = {-1,  0,  1, 1, 1, 0, -1, -1};\r\nmap<int, vector<tuple<int, int, int>>> intvs;\r\nconst int kNumDirs = 8;\r\n \r\nvector<pii> cells;\r\nmap<pii, int> cell_mapping;\r\nbool vis[kMaxN];\r\nvi adj[kMaxVert];\r\n \r\nint fu_parent[kMaxVert];\r\n//~ vi fu_elems[kMaxVert];\r\n \r\nint n;\r\nint outside_vert;\r\nset<int> avail_verts;\r\nset<int> quarantine_verts;\r\nvector<bool> is_free;\r\n \r\nint FuFind(int v) {\r\n  if (v == fu_parent[v]) { return v; }\r\n  return fu_parent[v] = FuFind(fu_parent[v]);\r\n}\r\n \r\nvoid FuUnion(int a, int b) {\r\n  a = FuFind(a); b = FuFind(b);\r\n  if (a == b) { return; }\r\n  fu_parent[a] = b;\r\n  //~ if (SZ(fu_elems[a]) > SZ(fu_elems[b])) { swap(a, b); }\r\n  \r\n  //~ for (int x : {a, b}) {\r\n    //~ if (x == FuFind(outside_vert)) {\r\n      //~ const int y = x ^ a ^ b;\r\n      //~ for (int s : fu_elems[y]) {\r\n        //~ avail_verts.insert(s);\r\n      //~ }\r\n    //~ }\r\n  //~ }\r\n  \r\n  //~ fu_parent[a] = b;\r\n  //~ for (int x : fu_elems[a]) {\r\n    //~ fu_elems[b].PB(x);\r\n  //~ }\r\n  //~ fu_elems[a].clear();\r\n}\r\n \r\nint GetByID(int r, int c) {\r\n  auto &I = intvs[c];\r\n  assert(!I.empty());\r\n  auto iter = prev(upper_bound(ALL(I),\r\n      tuple<int,int,int>(r, M + 100, -1)));\r\n  return get<2>(*iter);\r\n}\r\n \r\nbool MakesDisconnected(int v) {\r\n  assert(v < n);\r\n  bool is_adj[10];\r\n  memset(is_adj, 0, sizeof(is_adj));\r\n  \r\n  for (int i = 0; i < 8; ++i) {\r\n    const int nr = cells[v].st + dr[i];\r\n    const int nc = cells[v].nd + dc[i];\r\n    //~ debug(v, nr, nc);\r\n    const pii np{nr, nc};\r\n    auto iter = cell_mapping.find(np);\r\n    if (iter == cell_mapping.end()) { continue; }\r\n    const int s = iter->nd;\r\n    is_adj[i] = !is_free[s];\r\n  }\r\n  \r\n  set<int> comp_ids;\r\n  for (int i = 0; i < 8; ++i) {\r\n    const int j = (i + 1) % 8;\r\n    if (is_adj[i] && !is_adj[j]) {\r\n      if (j % 2 == 0 && is_adj[j + 1]) { continue; }\r\n      debug(v, i, j);\r\n      const int nr = cells[v].st + dr[j];\r\n      const int nc = cells[v].nd + dc[j];\r\n      const int cid = FuFind(GetByID(nr, nc));\r\n      if (comp_ids.count(cid)) { return true; }\r\n      comp_ids.insert(cid);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n \r\n \r\ninline void AddEdge(int u, int v) {\r\n  debug(u, v);\r\n  adj[u].PB(v); adj[v].PB(u);\r\n}\r\n \r\nvoid Dfs(int v) {\r\n  vis[v] = true;\r\n  for (int i = 0; i < kNumDirs; ++i) {\r\n    const int nr = cells[v].st + dr[i];\r\n    const int nc = cells[v].nd + dc[i];\r\n    const pii np{nr, nc};\r\n    auto iter = cell_mapping.find(np);\r\n    if (iter != cell_mapping.end()) {\r\n      const int s = iter->nd;\r\n      if (!vis[s]) { Dfs(s); }\r\n    }\r\n  }\r\n}\r\n \r\nint32_t main() {\r\n  ios_base::sync_with_stdio(0);\r\n  cin.tie(0);\r\n  cout << fixed << setprecision(11);\r\n  cerr << fixed << setprecision(6);\r\n  \r\n  int tidx;\r\n  cin >> n >> tidx;\r\n  cells.resize(n);\r\n  for (auto &[r, c] : cells) { cin >> r >> c; }\r\n  for (int i = 0; i < n; ++i) {\r\n    cell_mapping[cells[i]] = i;\r\n  }\r\n  \r\n  Dfs(0);\r\n  for (int i = 0; i < n; ++i) {\r\n    if (!vis[i]) {\r\n      cout << \"NO\\n\";\r\n      return 0;\r\n    }\r\n  }\r\n  \r\n  int min_c = M, max_c = -M;\r\n  map<int, vector<pii>> cell_cols;\r\n  for (int i = 0; i < n; ++i) {\r\n    mini(min_c, cells[i].nd);\r\n    maxi(max_c, cells[i].nd);\r\n    cell_cols[cells[i].nd].emplace_back(cells[i].st, i);\r\n  }\r\n  \r\n  assert(max_c - min_c <= n);\r\n  \r\n  int cur_id = n;\r\n  \r\n  for (int col = min_c; col <= max_c; ++col) {\r\n    vector<pii> rows = cell_cols[col];\r\n    assert(!rows.empty());\r\n    sort(ALL(rows));\r\n    \r\n    int last_r = -M;\r\n    \r\n    for (auto &&[r, idx] : rows) {\r\n      if (last_r < r - 1) {\r\n        intvs[col].emplace_back(last_r + 1, r, cur_id++);\r\n      }\r\n      intvs[col].emplace_back(r, r + 1, idx);\r\n      last_r = r;\r\n    }\r\n    intvs[col].emplace_back(last_r + 1, M, cur_id++);\r\n  }\r\n  \r\n  intvs[min_c - 1].emplace_back(-M, M, cur_id++);\r\n  intvs[max_c + 1].emplace_back(-M, M, cur_id++);\r\n  const int nverts = cur_id;\r\n  \r\n  for (int col = min_c; col <= max_c; ++col) {\r\n    const auto &I = intvs[col];\r\n    const int sz = SZ(I);\r\n    for (int i = 1; i < sz; ++i) {\r\n      AddEdge(get<2>(I[i - 1]), get<2>(I[i]));\r\n    }\r\n  }\r\n  \r\n  for (int col = min_c; col <= max_c + 1; ++col) {\r\n    int aptr = 0, bptr = 0;\r\n    const auto &A = intvs[col - 1];\r\n    const auto &B = intvs[col];\r\n    while (aptr < SZ(A) && bptr < SZ(B)) {\r\n      const auto [al, ar, aidx] = A[aptr];\r\n      const auto [bl, br, bidx] = B[bptr];\r\n      if (ar <= bl) { ++aptr; continue; }\r\n      if (br <= al) { ++bptr; continue; }\r\n      AddEdge(aidx, bidx);\r\n      if (ar < br) { ++aptr; } else { ++bptr; }\r\n    }\r\n  }\r\n  \r\n  debug(nverts);\r\n  outside_vert = nverts - 1;\r\n  iota(fu_parent, fu_parent + nverts, 0);\r\n  //~ for (int i = 0; i < nverts; ++i) {\r\n    //~ fu_elems[i].PB(i);\r\n  //~ }\r\n  for (int i = n; i < nverts; ++i) {\r\n    for (int j : adj[i]) {\r\n      if (j > i) {\r\n        FuUnion(i, j);\r\n      }\r\n    }\r\n  }\r\n  \r\n  vector<bool> is_deleted(nverts);\r\n  avail_verts.insert(outside_vert);\r\n  \r\n  is_free.resize(nverts);\r\n  for (int i = n; i < nverts; ++i) {\r\n    is_free[i] = true;\r\n  }\r\n  \r\n  vi answer;\r\n  while (SZ(answer) < n) {\r\n    if (avail_verts.empty()) {\r\n      debug(answer);\r\n      debug(vi(ALL(quarantine_verts)));\r\n    }\r\n    assert(!avail_verts.empty());\r\n    const int v = *avail_verts.rbegin();\r\n    avail_verts.erase(v);\r\n    debug(v);\r\n    \r\n    if (v < n && MakesDisconnected(v)) {\r\n      quarantine_verts.insert(v);\r\n      continue;\r\n    } else {\r\n      is_free[v] = is_deleted[v] = true;\r\n      if (v < n) { answer.PB(v); }\r\n      for (int s : adj[v]) {\r\n        if (!is_deleted[s]) { avail_verts.insert(s); }\r\n        quarantine_verts.erase(s);\r\n        if (is_free[s]) {\r\n          FuUnion(v, s);\r\n        }\r\n      }\r\n      \r\n      if (v < n) {\r\n        for (int ddr : {-1, 1}) {\r\n          for (int ddc : {-1, 1}) {\r\n            bool any_free = false;\r\n            const int nrow = GetByID(cells[v].st + ddr, cells[v].nd);\r\n            any_free |= is_free[nrow];\r\n            const int ncol = GetByID(cells[v].st, cells[v].nd + ddc);\r\n            any_free |= is_free[ncol];\r\n            if (!any_free) { continue; }\r\n            \r\n            pii np{cells[v].st + ddr, cells[v].nd + ddc};\r\n            auto iter = cell_mapping.find(np);\r\n            if (iter != cell_mapping.end()) {\r\n              const int s = iter->nd;\r\n              if (!is_deleted[s]) {\r\n                avail_verts.insert(s); quarantine_verts.erase(s);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  reverse(ALL(answer));\r\n  cout << \"YES\\n\";\r\n  for (int x : answer) { cout << x + 1 << \"\\n\"; }\r\n}\r\n"
}