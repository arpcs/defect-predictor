{
    "id": 180066258,
    "contestId": 1750,
    "creationTimeSeconds": 1667902200,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1750,
        "index": "E",
        "name": "Bracket Cost",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2400,
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "strings"
        ]
    },
    "author": {
        "contestId": 1750,
        "members": [
            {
                "handle": "mailo102"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1667745300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 2560000,
    "source": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdlib.h>\n#include <stack>\n#include <bitset>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\n//template<class key, class value, class cmp = std::less<key>>\n//using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n//template<class key, class cmp = std::less<key>>\n//using ordered_set = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ll long long\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define forn(i, n) for (int i = 0; i < n; i++)\n#define from(i,j,n) for (int i = j; i < n; i++)\n#define sz(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define eb emplace_back\n\nll INF = 1e18;\nll MOD = 998244353;\nvector<ll> fact(3e5 + 5, 1);\nvector<ll> fenwick;\n\ntemplate <typename T> vector<T> sort_unique(vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <typename T, size_t sz> ostream &operator<<(ostream &os, const array<T, sz> &arr) { os << '['; for (auto v : arr) os << v << ','; os << ']'; return os; }\n#if __cplusplus >= 201703L\ntemplate <typename... T> istream &operator>>(istream &is, tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }\ntemplate <typename... T> ostream &operator<<(ostream &os, const tuple<T...> &tpl) { os << '('; std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os << ')'; }\n#endif\ntemplate <typename T> ostream &operator<<(ostream &os, const deque<T> &vec) { os << \"deq[\"; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T, typename TH> ostream &operator<<(ostream &os, const unordered_set<T, TH> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa) { os << '(' << pa.first << ',' << pa.second << ')'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\ntemplate <typename TK, typename TV, typename TH> ostream &operator<<(ostream &os, const unordered_map<TK, TV, TH> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\n\nll gcd(ll a, ll b) {\n  if (b == 0)\n    return a;\n  return gcd(b, a % b);\n}\n\nstruct Fenwick {\n  Fenwick(int n) : vec(n, 0) {}\n\n  void update(int pos, ll add) {\n    while (pos < vec.size()) {\n      vec[pos] += add;\n      pos = (pos | (pos - 1)) + 1;\n    }\n  }\n\n  ll get(int pos) {\n    ll sum = 0;\n    while (pos > 0) {\n      sum += vec[pos];\n      pos = (pos & (pos - 1));\n    }\n    return sum;\n  }\n\n  // returns sum (l, r]\n  ll get(int l, int r) {\n    return get(r) - get(l);\n  }\n\n  vector<ll> vec;\n};\n\nstruct SNM {\n  struct Operation {\n    Operation() : empty(true) {}\n    Operation(int u, int v, int szv) : u(u), v(v), szv(szv), empty(false) {}\n\n    bool is_empty() {\n      return empty;\n    }\n\n    int u, v, szv;\n    bool empty = false;\n  };\n\n  SNM(int n) : n(n), comp_count(n) {\n    parent.resize(n, -1);\n    sz.resize(n, 1);\n  }\n\n  int get(int v) {\n    if (parent[v] == -1)\n      return v;\n    return get(parent[v]);\n  }\n\n  void uni(int u, int v) {\n    auto pu = get(u);\n    auto pv = get(v);\n    if (pu == pv) {\n      ops.push({});\n      return;\n    }\n    if (sz[pu] > sz[pv]) {\n      swap(pu, pv);\n    }\n    ops.push({pu, pv, sz[pv]});\n    parent[pu] = pv;\n    sz[pv] += sz[pu];\n    comp_count--;\n  }\n\n  void rollback() {\n    auto op = ops.top();\n    ops.pop();\n    if (!op.is_empty()) {\n      parent[op.u] = -1;\n      sz[op.v] = op.szv;\n      comp_count++;\n    }\n  }\n\n  int components() {\n    return comp_count;\n  }\n\n  void reset() {\n    while (!ops.empty())\n      rollback();\n  }\n\n  int n, comp_count;\n  vector<int> parent, sz;\n  stack<Operation> ops;\n};\n\nstruct Query {\n  Query(int type, int ts) : type(type), l(ts), r(ts + 1) {}\n  Query(int type, int l, int r, int u, int v) : type(type), l(l), r(r), u(u), v(v) {}\n\n  // 1 - [l, r], 0 - get\n  int type, l=-1, r=-1, u=-1, v=-1;\n};\n\nvector<pair<int, int>> dsu_answer;\n\nvoid dsu_offline(SNM& snm, const vector<Query>& queries, int l, int r) {\n  int ops = 0;\n  auto mid = (l + r) / 2;\n  vector<Query> left, right;\n\n  for (auto q : queries) {\n    if (q.type == 1 && q.l <= l && r <= q.r) {\n      snm.uni(q.u, q.v);\n      ops++;\n      continue;\n    }\n    if (!(q.l >= mid || q.r <= l)) {\n      left.pb(q);\n    }\n    if (!(q.l >= r || q.r <= mid)) {\n      right.pb(q);\n    }\n  }\n  if (l + 1 == r) {\n    for (auto q : queries) {\n      if (q.type == 0) {\n        dsu_answer.pb(mp(l, snm.components()));\n      }\n    }\n  } else {\n    dsu_offline(snm, left, l, mid);\n    dsu_offline(snm, right, mid, r);\n  }\n  while (ops > 0) {\n    snm.rollback();\n    ops--;\n  }\n}\n\nvector<int> z_function (string s) {\n  int n = (int) s.length();\n  vector<int> z (n);\n  for (int i=1, l=0, r=0; i<n; ++i) {\n    if (i <= r)\n      z[i] = min (r-i+1, z[i-l]);\n    while (i+z[i] < n && s[z[i]] == s[i+z[i]])\n      ++z[i];\n    if (i+z[i]-1 > r)\n      l = i,  r = i+z[i]-1;\n  }\n  return z;\n}\n\nvoid update(int pos, ll val) { // val- what we add\n  for (int i = pos; i < fenwick.size(); i = ((i - 1) | i) + 1) {\n    fenwick[i] += val;\n  }\n}\n\nll sum(int pos) {\n  ll result=0;\n  for (int i = pos; i > 0; i = i & (i - 1))\n    result += fenwick[i];\n  return result;\n}\n\nll range_sum(int l, int r) { // (l, r]\n  return sum(r) - sum(l);\n}\n\nvoid fill_fact() {\n  for (int i = 2; i < fact.size(); i++)\n    fact[i] = (fact[i - 1] * i) % MOD;\n}\n\nll pow(ll a, ll b) {\n  if (b == 0) {\n    return 1;\n  } else if (b % 2 == 0) {\n    ll x = pow(a, b / 2);\n    return x * x;\n  } else {\n    return a * pow(a, b - 1);\n  }\n}\n\nll pow_mod(ll a, ll b) {\n  if (b == 0) {\n    return 1;\n  } else if (b % 2 == 0) {\n    ll x = pow_mod(a, b / 2) % MOD;\n    return (x * x) % MOD;\n  } else {\n    return (a * pow_mod(a, b - 1)) % MOD;\n  }\n}\n\nll cnk(ll n, ll k) {\n  ll n_fact = fact[n];\n  ll k_fact = fact[k];\n  ll nk_fact = fact[n - k];\n  ll down = (k_fact * nk_fact) % MOD;\n  ll up = pow_mod(down, MOD - 2);\n  return (n_fact * up) % MOD;\n}\n\nnamespace ST {\n  constexpr struct MinAssignOp {\n    /*\n     *  \u041e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043c\u0438\u043d\u0438\u043c\u0443\u043c\u0430 \u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0441 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0435\u0439 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u044f \u043d\u0430\n     *  \u043e\u0442\u0440\u0435\u0437\u043a\u0435\n     */\n    ll init() const {\n      return 1e18;\n    }\n\n    ll operator()(ll a, ll b) const {\n      return min(a, b);\n    }\n\n    void assign(vector<pair<ll, ll>>& tree, int v, int tl, int tr, ll val) {\n      tree[v].f = min(tree[v].f, val);\n      tree[v].s = min(tree[v].s, val);\n    }\n\n    void push(vector<pair<ll, ll>>& tree, int v, int tl, int tr) {\n      const auto val = tree[v].s;\n      const auto vl = 2 * v + 1;\n      const auto vr = 2 * v + 2;\n      assign(tree, vl, tl, tr, val);\n      assign(tree, vr, tl, tr, val);\n      tree[v].s = init();\n    }\n  } Min;\n\n  constexpr struct MaxAssignOp {\n    /*\n     *  \u041e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043c\u0438\u043d\u0438\u043c\u0443\u043c\u0430 \u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0441 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0435\u0439 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u044f \u043d\u0430\n     *  \u043e\u0442\u0440\u0435\u0437\u043a\u0435\n     */\n    ll init() const {\n      return -1e18;\n    }\n\n    ll operator()(ll a, ll b) const {\n      return max(a, b);\n    }\n\n    void assign(vector<pair<ll, ll>>& tree, int v, int tl, int tr, ll val) {\n      tree[v].f = max(tree[v].f, val);\n      tree[v].s = max(tree[v].s, val);\n    }\n\n    void push(vector<pair<ll, ll>>& tree, int v, int tl, int tr) {\n      const auto val = tree[v].s;\n      const auto vl = 2 * v + 1;\n      const auto vr = 2 * v + 2;\n      assign(tree, vl, tl, tr, val);\n      assign(tree, vr, tl, tr, val);\n      tree[v].s = init();\n    }\n  } Max;\n\n  constexpr struct SumAddOp {\n    /*\n     *  \u041e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u0443\u043c\u043c\u044b \u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0435 \u0441 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0435\u0439 \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0435\n     */\n    ll init() const {\n      return 0;\n    }\n\n    ll operator()(ll a, ll b) const {\n      return a + b;\n    }\n\n    void assign(vector<pair<ll, ll>>& tree, int v, int tl, int tr, ll add) {\n      tree[v].f += (tr - tl) * add;\n      tree[v].s += add;\n    }\n\n    void push(vector<pair<ll, ll>>& tree, int v, int tl, int tr) {\n      const auto add = tree[v].s;\n      const auto vl = 2 * v + 1;\n      const auto vr = 2 * v + 2;\n      const auto mid = (tl + tr) / 2;\n\n      tree[vl].f += add * (mid - tl);\n      tree[vl].s += add;\n\n      tree[vr].f += add * (tr - mid);\n      tree[vr].s += add;\n      tree[v].s = 0;\n    }\n  } Sum;\n}\n\ntemplate<typename Operation>\nstruct SegmentTree {\n\n  SegmentTree(int n, Operation op) : n(n), tree(4 * n, mp(op.init(), op.init())), op(op) {}\n\n  void update(int l, int r, ll add) {\n    update_impl(0, 0, n, l, r, add);\n  }\n\n  void update(int l, ll add) {\n    update_impl(0, 0, n, l, l + 1, add);\n  }\n\n  ll get(int l, int r) {\n    return get_impl(0, 0, n, l, r);\n  }\n\n  ll get(int l) {\n    return get_impl(0, 0, n, l, l + 1);\n  }\n\nprivate:\n  void update_impl(int v, int tl, int tr, int l, int r, ll add) {\n    if (tl >= l && tr <= r) {\n      op.assign(tree, v, tl, tr, add);\n      return;\n    }\n    if (tl >= r || tr <= l) {\n      return;\n    }\n    const auto mid = (tl + tr) / 2;\n    op.push(tree, v, tl, tr);\n    update_impl(2 * v + 1, tl, mid, l, r, add);\n    update_impl(2 * v + 2, mid, tr, l, r, add);\n    tree[v].f = op(tree[2 * v + 1].f, tree[2 * v + 2].f);\n  }\n\n  ll get_impl(int v, int tl, int tr, int l, int r) {\n    if (tl >= l && tr <= r) {\n      return tree[v].f;\n    }\n    if (tl >= r || tr <= l) {\n      return op.init();\n    }\n    op.push(tree, v, tl, tr);\n    const auto mid = (tl + tr) / 2;\n    return op(get_impl(2 * v + 1, tl, mid, l, r), get_impl(2 * v + 2, mid, tr, l, r));\n  }\n\n  vector<pair<ll, ll>> tree;\n  int n;\n  Operation op;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> balance(n + 1, 0);\n    vector<int> dp(n + 1, 0), nxt(n + 1, -1);\n    map<int, vector<int>> balance2pos;\n    balance2pos[balance[0]].pb(0);\n    int N = 2 * n + 5;\n    Fenwick fen(N), fen_cnt(N);\n    fen.update(n + 1, n + 1);\n    fen_cnt.update(n + 1, 1);\n    forn(i, s.size()) {\n      if (s[i] == '(') {\n        balance[i + 1] = balance[i] + 1;\n      } else {\n        balance[i + 1] = balance[i] - 1;\n      }\n      balance2pos[balance[i + 1]].pb(i + 1);\n      auto x = balance[i + 1] + (n + 1);\n      fen.update(x, x);\n      fen_cnt.update(x, 1);\n    }\n    dp[n] = 1;\n    auto balance2pos_copy = balance2pos;\n    for (auto [k, _] : balance2pos_copy) {\n      reverse(all(balance2pos_copy[k]));\n    }\n    forn(i, n + 1) {\n      balance2pos_copy[balance[i]].pop_back();\n      if (balance2pos_copy.count(balance[i] - 1)) {\n        nxt[i] = balance2pos_copy[balance[i] - 1].back();\n      }\n    }\n    //cout << nxt << endl;\n    for (int i = n; i >= 0; i--) {\n      if (nxt[i] == -1) {\n        dp[i] = (n - i + 1) * balance[i];\n      } else {\n        dp[i] = dp[nxt[i]] + (nxt[i] - i) * balance[i];\n      }\n    }\n    ll answer = 0;\n    balance2pos_copy = balance2pos;\n    for (auto [k, _] : balance2pos_copy) {\n      reverse(all(balance2pos_copy[k]));\n    }\n    //cout << balance << endl;\n    //cout << nxt << endl;\n    //cout << dp << endl;\n    \n    for (int i = 0; i < n; i++) {\n      balance2pos_copy[balance[i]].pop_back();\n      if (balance2pos_copy[balance[i]].empty()) {\n        if (balance[i + 1] < balance[i]) {\n          auto val = dp[i + 1] - balance[i] * (n - i);\n          answer += abs(val);\n        } \n      } else {\n        auto x = balance2pos_copy[balance[i]].back();\n        if (nxt[i] != -1) {\n          x = std::min(x, nxt[i]);\n        }\n        auto val = dp[x] - balance[i] * (n - x + 1);\n        //cout << \"DEBUG: \" << i << \" \" << val << \" \" << x << endl;\n        answer += abs(val);\n      }\n      auto x = balance[i] + (n + 1);\n      fen.update(x, -x);\n      fen_cnt.update(x, -1);\n      auto val1 = fen.get(x, N - 1);\n      auto val2 = fen_cnt.get(x, N - 1);\n      auto val = val1 - val2 * x;\n      //cout << \"QQ: \" << i << \" \" << val << \" \" << val1 << \" \" << val2 << endl;\n      answer += val;\n    }\n    cout << answer << endl;\n    //cout << dp << endl;\n    //cout << balance2pos_copy << endl; \n    //cout << balance2pos << endl;\n  }\n  return 0;\n}\n"
}