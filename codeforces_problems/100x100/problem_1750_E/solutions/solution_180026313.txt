{
    "id": 180026313,
    "contestId": 1750,
    "creationTimeSeconds": 1667870275,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1750,
        "index": "E",
        "name": "Bracket Cost",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2400,
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "strings"
        ]
    },
    "author": {
        "contestId": 1750,
        "members": [
            {
                "handle": "u5n"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1667745300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 3379200,
    "source": "#ifndef M_H\n#define M_H\n#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;using uint=unsigned int;using uint32=unsigned int;using int32=int;using int64=long long;using uint64=unsigned long long;using uint128=unsigned __int128;using int128=__int128;\n#define elif else if\n#define fi first\n#define se second\n#define all(x) begin(x),end(x)\n#define rall(x) rbegin(x),rend(x) \n#define mini(l,r) {auto x = r; if(l>x) l=x;}\n#define maxi(l,r) {auto x = r; if(l<x) l=x;}\n#define oldv(x) (x) \n#define ___\n#define GET_MACRO(_0,_1,_2,_3,_N,...) _N\n#define rep(...) GET_MACRO(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rep4(i,a,b,c) for(int32 i=(a),_5=(b),_6=(c);i<_5;i+=_6)\n#define _rep3(i,a,b) for(int32 i=(a),_5=(b);i<_5;++i)\n#define _rep2(i,b) _rep3(i,0,b)\n#define _rep1(b) _rep2(_,b)\n#define rev_rep(...) GET_MACRO(__VA_ARGS__,1/0,_rev_rep3,_rev_rep2,_rev_rep1)(__VA_ARGS__)\n#define _rev_rep3(i,a,b) for(int32 i=(b)-1,_5=(a);i>=_5;--i)\n#define _rev_rep2(i,b) _rev_rep3(i,0,b)\n#define _rev_rep1(b) _rev_rep2(_,b)\n#define for_iter(i, s) for(auto i=begin(s);i<end(s);i++)\n#define pair_assign(a,b, c,d) {auto _pd=(d);a=c;b=_pd;}\n#define triple_assign(a,b,c, d,e,f) {auto _pe=(e);auto _pf=(f); a=(d);b=_pe;c=_pf;}\n#define floor_div(a,b) (a/b - (a%b&&(a^b)<0))\n#define memset0(arr, n) memset(arr,0,sizeof(decltype(arr[0]))*n)\n#ifndef ONLINE_JUDGE\n#define DEBUG_MODE\n#endif\n#if __cplusplus<201703L\ntemplate<typename T>inline T gcd(T l,T r){return __gcd(l,r);}template<typename T>inline T lcm(T l,T r){return l/__gcd(l,r)*r;}template<typename T>constexpr int len(const T&t)const{return t.size();}template<typename T,int N>constexpr int len(T(&t)[N])const{return N;}\n#else \ntemplate<typename T>constexpr int len(const T&t){return size(t);}\n#endif\ntemplate<typename T>inline T lowbit(T x){return x&-x;};inline constexpr int32 bit_count(int32 x){return __builtin_popcount(x);}inline constexpr int32 bit_count(uint32 x){return __builtin_popcount(x);}inline constexpr int32 bit_count(int64 x){return __builtin_popcountll(x);}inline constexpr int32 bit_count(uint64 x){return __builtin_popcountll(x);}template<class InputIter,class OutputIter>void partial_sum0(InputIter first,InputIter last,OutputIter output){typename iterator_traits<OutputIter>::value_type cs=0,tmp=0;while(first!=last){tmp=*first++;*output++=cs;cs+=tmp;}*output=cs;}template<class T,class F>T binary_search_first(T l,T r,F f){assert(l<=r);while(l<r){T m=l+((typename make_unsigned<T>::type)r-l)/2;if(f(m))r=m;else l=m+1;}return l;}template<class T,class F>T binary_search_last(T l,T r,F f){assert(l<=r);while(l<r){T m=l+((typename make_unsigned<T>::type)r-l-1)/2;if(f(m))l=m;else r=m-1;}return l;}void permutations(int n,int r,function<bool(int const*)>f){int ids[r];bool vis[n];memset0(vis,n);rep(i,r)ids[i]=i,vis[i]=1;while(1){if(!f(ids))return;int i_last=r-1;for(;i_last>=0;i_last--){int last=ids[i_last];vis[last++]=0;while(last<n and vis[last])last++;if(last<n){vis[last]=1;ids[i_last]=last;break;}}if(-1==i_last)break;i_last++;for(int i=0;i_last<r&&i<n;i++){if(!vis[i]){vis[i]=1;ids[i_last++]=i;}}}}void combinations(int n,int r,function<bool(int const*)>f){int ids[r];rep(i,r)ids[i]=i;while(1){if(!f(ids))return;int i_last;for(i_last=r-1;i_last>=0 and ids[i_last]==i_last+n-r;i_last--);if(-1==i_last)break;ids[i_last]++;rep(i,i_last+1,r)ids[i]=ids[i-1]+1;}}void product(const vector<int>&args,function<bool(int const*)>f){int n=args.size();int ids[n];memset0(ids,n);while(1){if(!f(ids))return;int i_last;for(i_last=n-1;i_last>=0 and ids[i_last]==args[i_last]-1;i_last--);if(-1==i_last)break;ids[i_last]++;rep(i,i_last+1,n)ids[i]=0;}}template<typename T,int L,int R>struct gnegarr{T A[R-L];void init(int l,int r){rep(i,l,r)(*this)[i]=0;}T&operator[](int index){return A[index-L];}};template<typename T>struct garr{T*A;typedef T*iterator;typedef T value_type;int N;int n=0;garr(int N):N(N){A=new T[N];}garr(int N,const T&v):N(N){A=new T[N];init(N,v);}void init(int cnt_v,const T&v){if(v==0){memset(A,0,sizeof(T)*cnt_v);n=cnt_v;}elif(sizeof(T)==1){memset(A,v,cnt_v);n=cnt_v;}else{n=0;int msb=1<<19;for(;msb;msb>>=1){memcpy(A+n,A,n*sizeof(T));n<<=1;if(cnt_v&msb)A[n++]=v;}}}template<typename RIter,enable_if_t<is_same<T,typename iterator_traits<RIter>::value_type>::value,bool> =0>void init(RIter beg,RIter end){uint32 sz2=end-beg;memcpy(A,beg,sz2*sizeof(T));n=sz2;}void init(initializer_list<T>L){n=0;for(auto&v:L)A[n++]=v;}void init(){n=0;}size_t size()const{return n;}T&operator[](int index){if(index>=0)return A[index];return A[index+n];}const T&operator[](int index)const{if(index>=0)return A[index];return A[index+n];}int lexical_cmp(const garr<T>&oth){rep(i,min(n,oth.n)){if(A[i]>oth.A[i])return 1;elif(A[i]<oth.A[i])return-1;}if(n==oth.n)return 0;return(n<oth.n)?-1:1;}bool operator==(const garr<T>&oth)const{return oth.n==n and memcmp(oth.A,A,n)==0;}bool operator!=(const garr<T>&oth)const{return!(oth==*this);}T*begin(){return&A[0];}T*end(){return&A[n];}void append(const T&v){A[n++]=v;}T pop(){return A[--n];}T pop(int index){int ret=A[index];if(index+1<n)memmove(A+index,A+index+1,sizeof(T)*(n-(index+1)));n--;return ret;}void slice_remove(int l,int r){if(r-l<=0 or r<=0)return;if(l<0)l=0;if(r<n){memmove(A+l,A+r,sizeof(T)*(n-r));n-=r-l;}else{n=l;}}void insert(int index,const T&v){memmove(A+index+1,A+index,sizeof(T)*(n-index));n++;A[index]=v;}int find(const T&v,int start=0){return find(v,start,n);}int find(const T&v,int start,int stop){if(stop-start<=0 or stop<=0)return-1;if(start<0)start=0;rep(i,start,stop){if(A[i]==v)return i;}return n;}friend istream&operator>>(istream&in,garr&obj){rep(i,obj.n)in>>obj.A[i];return in;}};template<typename T>struct garr2{typedef T value_type;int n,m;T*A;garr2(int N){A=new T[N];}garr2(int N,const T&v){A=new T[N];initsequence(N,v);}void init(int n,int m,const T&v){this->n=n;this->m=m;initsequence(n*m,v);}size_t size()const{return n;}void initsequence(int n,const T&v){if(v==0){memset0(A,n);}elif(sizeof(T)==1){memset(A,v,n);}else{int sz=0;int msb=1<<19;for(;msb;msb>>=1){memcpy(A+sz,A,sz*sizeof(T));sz<<=1;if(n&msb)A[sz++]=v;}}}T*operator[](int i){return A+i*m;}};template<class T>struct mqueue{T*A;typedef T*iterator;typedef T value_type;int N;int l=0;int r=0;mqueue(int N):N(N){A=new T[N];}mqueue(int start,int stop):N(stop-start){A=new T[N];rep(i,start,stop)A[r++]=i;}void init(initializer_list<T>L){l=r=0;for(auto&v:L)A[r++]=v;}template<typename RIter,enable_if_t<is_same<T,typename iterator_traits<RIter>::value_type>::value,bool> =0>void init(RIter beg,RIter end){l=0;uint sz2=end-beg;memcpy(A,beg,sz2*sizeof(T));r=sz2;}void init(){l=r=0;}size_t size()const{return r-l;}int*begin(){return&A[l];}int*end(){return&A[r];}T&operator[](int index){if(0<=index)return A[index+l];return A[index+r];}const T&operator[](int index)const{if(0<=index)return A[index+l];return A[index+r];}void append(const T&v){if(r==N){memmove(A,A+l,(r-l)*sizeof(T));r-=l;l=0;}A[r++]=v;}T popleft(){return A[l++];}void rotate(int step=1){int sz=r-l;step=step%sz;if(step<0)step+=sz;if((sz-step)<1000+0.035*sz){rep(sz-step)append(popleft());return;}if(step<=sz/2){T buf[step];memcpy(buf,A+sz-step,step*sizeof(T));memmove(A+step,A,(sz-step)*sizeof(T));memcpy(A,buf,step*sizeof(T));}else{T buf[sz-step];memcpy(buf,A,(sz-step)*sizeof(T));memmove(A,A+sz-step,step*sizeof(T));memcpy(A+step,buf,(sz-step)*sizeof(T));}}};template<bool weighted>struct Adjll_{int n;int m=0;int*head;int*wei;int*next;int*end;Adjll_(int N,int M){head=new int[N];end=new int[M];next=new int[M];if(weighted)wei=new int[M];}void init(int n){this->n=n;memset(head,-1,sizeof(int)*n);m=0;}void add(int u,int v){end[m]=v;next[m]=head[u];head[u]=m++;}void add(int u,int v,int w){end[m]=v;next[m]=head[u];wei[m]=w;head[u]=m++;}size_t size()const{return n;}void pprint(){cout<<\"Adjll\\n\";rep(u,n){cout<<\" [\";for(int eid=head[u];~eid;eid=next[eid]){int v=end[eid];if(weighted){cout<<'['<<v<<\",\"<<wei[eid]<<']';if(~next[eid])cout<<\",\";}else{cout<<v;if(~next[eid])cout<<\",\";}}cout<<\"]\\n\";}cout<<'\\n';}};using Adjll=Adjll_<0>;using AdjllW=Adjll_<1>;void __template_adjllW_foreach(AdjllW&adj,int u,function<void(int,int)>f){for(int eid=adj.head[u];~eid;eid=adj.next[eid]){int v=adj.end[eid],w=adj.wei[eid];f(v,w);}}void __template_adjll_foreach(Adjll&adj,int u,function<void(int)>f){for(int eid=adj.head[u];~eid;eid=adj.next[eid]){int v=adj.end[eid];f(v);}}bool __mystery=[](){cin.tie(0)->sync_with_stdio(0);cin.exceptions(cin.failbit);return 0;}();void print(){cout<<'\\n';}void print(int32*A,int t){rep(i,t)cout<<A[i]<<' ';cout<<'\\n';}void print(int64*A,int t){rep(i,t)cout<<A[i]<<' ';cout<<'\\n';}template<class T,class Al>void print(vector<T,Al>&A){for(auto v:A)cout<<v<<' ';cout<<'\\n';}template<class T,class... Args>void print(const T&v,Args... args){cout<<v<<' ';print(args...);}\n#ifdef ONLINE_JUDGE\n#define D(...)\n#define Dtype(...)\n#else \n#include \"d.h\"\n#endif\n#endif\n\n\nconst int maxn = 2e5 + 10;\n// #define int int64\nint __t, n;\nint t0,t1,t2;\ngarr<char> A(maxn);\n\nstruct CounterAddall{\n    // map<int, int> C;\n    gnegarr<int,-maxn-100,maxn+100> C;\n    int addall=0;\n    int ts = 0;\n    int ptf = 0;\n    void init(int n){\n        addall = ts = ptf = 0;\n        C.init(-n-100, n+100);\n    };\n    int& operator[] (int freq) {\n        return C[freq-addall];\n    }\n} bal,// ts: positive total sum; ptf: positive total freq\nmbal; // ts: total sum; ptf: don't need, which is `i+1`\n\nvoid solve(){\n    int64 ret=0;\n    rep(i, A.n){\n        bal[0]++;\n        mbal[0]++;\n        if(A[i]==')'){\n            bal.addall ++;\n            \n            bal.ptf+=bal[1];\n            bal.ts+=bal.ptf;\n            \n            mbal.addall ++;\n            mbal[0] += mbal[1];\n            mbal.ts += i+1 - (mbal[1]);\n            mbal[1] = 0;\n        } else {\n            bal.addall --;\n            \n            bal.ts+=-bal.ptf;\n            bal.ptf+=-bal[0];\n            \n            mbal.addall --;\n            mbal.ts -= i+1;\n        }\n        ret += bal.ts -mbal.ts;\n    }\n    print(ret);\n}\n\nint32 main(){\n    int __T=1;\n    cin>>__T;\n    for(__t=0; __t<__T;__t++){\n        cin >> A.n >> A;\n        bal.init(n);\n        mbal.init(n);\n        solve();\n    }\n} \n"
}