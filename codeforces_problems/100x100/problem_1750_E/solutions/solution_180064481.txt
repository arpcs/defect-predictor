{
    "id": 180064481,
    "contestId": 1750,
    "creationTimeSeconds": 1667901057,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1750,
        "index": "E",
        "name": "Bracket Cost",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2400,
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "strings"
        ]
    },
    "author": {
        "contestId": 1750,
        "members": [
            {
                "handle": "P500"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1667745300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 29,
    "timeConsumedMillis": 77,
    "memoryConsumedBytes": 3686400,
    "source": "#include <bits/stdc++.h>\r\n// #include <testlib.h>\r\n// #include <optional>\r\nusing namespace std;\r\n\r\nconstexpr int mod = (int)1e9 + 7; //998244353;\r\nconstexpr int N = (int)1e5 + 5;\r\nconstexpr int LOG = 15;\r\n// constexpr int M = (int)2e3 + 5;\r\n\r\nint T_T = 1;\r\n\r\nnamespace CF\r\n{\r\n    namespace NUM\r\n    {\r\n        int P = mod; // to do\r\n        template<class T> T power(T a, long long b) { T r = 1; for (; b > 0; b >>= 1, a *= a) if (b & 1) r *= a; return r; }\r\n        inline int norm(int x) { if (x < 0) x += P; else if (x >= P) x -= P; return x; }\r\n        struct Z\r\n        {\r\n            int x;\r\n            Z(int x = 0) : x(norm(x)) {}\r\n            int val() const { return x; }\r\n            Z operator-() const { return Z(norm(P - x)); }\r\n            Z inv() const { assert(x != 0); return power(*this, P - 2); }\r\n            Z& operator+=(const Z& rhs) { x = norm(x + rhs.x); return *this; }\r\n            Z& operator-=(const Z& rhs) { x = norm(x - rhs.x); return *this; }\r\n            Z& operator*=(const Z& rhs) { x = 1LL * x * rhs.x % P; return *this; }\r\n            Z& operator/=(const Z& rhs) { return *this *= rhs.inv(); }\r\n            friend Z operator+(const Z& lhs, const Z& rhs) { Z res = lhs; res += rhs; return res; }\r\n            friend Z operator-(const Z& lhs, const Z& rhs) { Z res = lhs; res -= rhs; return res; }\r\n            friend Z operator*(const Z& lhs, const Z& rhs) { Z res = lhs; res *= rhs; return res; }\r\n            friend Z operator/(const Z& lhs, const Z& rhs) { Z res = lhs; res /= rhs; return res; }\r\n            bool operator== (const Z& rhs) { return x == rhs.x; }\r\n            bool operator!= (const Z& rhs) { return x != rhs.x; }\r\n            // operator int() { return x; }\r\n            // operator bool() { return bool(x); }\r\n        };\r\n        istream& operator>>(istream& is, Z& z) { is >> z.x; z.x = norm(z.x); return is; }\r\n        ostream& operator<<(ostream& os, const Z& z) { os << z.x; return os; }\r\n    }\r\n    using NUM::Z;                           using vz = vector<Z>;\r\n    using ll = long long;                   using vcs = vector<string>;\r\n    using ull = unsigned long long;         using vb = vector<bool>;\r\n    using pzz = pair<Z, Z>;                 using vpzz = vector<pzz>;\r\n    using pii = pair<int, int>;             using vpii = vector<pii>;\r\n    using piii = pair<pii, int>;            using vpiii = vector<piii>;\r\n    using pll = pair<ll, ll>;               using vpll = vector<pll>;\r\n    using pdd = pair<double, double>;       using vpdd = vector<pdd>;\r\n    using vl = vector<ll>;                  using vi = vector<int>;\r\n    using vvl = vector<vl>;                 using vvi = vector<vi>;\r\n    using vvvl = vector<vvl>;               using vvvi = vector<vvi>;\r\n    using vvvvl = vector<vvvl>;             using vvvvi = vector<vvvi>;\r\n    // template <class T> using A = optional<T>;\r\n    template <class T> using vc = vector<T>;\r\n    template <class T> using vvc = vector<vc<T> >;\r\n    template <class T> using pq = priority_queue<T, vector<T>, less<T> >;\r\n    template <class T> using pqg = priority_queue<T, vector<T>, greater<T> >;\r\n    template<typename T1, typename T2> pair<T1, T2>& operator+=(pair<T1, T2>& p1, const pair<T1, T2>& p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\r\n    template<typename T1, typename T2> pair<T1, T2>& operator-=(pair<T1, T2>& p1, const pair<T1, T2>& p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\r\n    template<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> p1, const pair<T1, T2>& p2) { return p1 += p2; }\r\n    template<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> p1, const pair<T1, T2>& p2) { return p1 -= p2; }\r\n    template<typename T> T operator*(const pair<T, T>& p1, const pair<T, T>& p2) { return 1LL * p1.first * p2.first + 1LL * p1.second * p2.second; }\r\n    template<typename T> T operator^(const pair<T, T>& p1, const pair<T, T>& p2) { return 1LL * p1.first * p2.second - 1LL * p2.first * p1.second; }\r\n    template<typename T> pair<T, T>& operator*=(pair<T, T>& p1, const T& p2) { p1.first *= p2; p1.second *= p2; return p1; }\r\n    template<typename T> pair<T, T> operator*(pair<T, T> p1, const T& p2) { return p1 *= p2; }\r\n    template<typename T> T mo(const pair<T, T>& p) { return p * p; }\r\n    template<typename T> double sqmo(const pair<T, T>& p) { return sqrt(mo(p)); }\r\n\r\n    template<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << p.first << ' ' << p.second; }\r\n    template<typename T1, typename T2> istream& operator>>(istream& is, pair<T1, T2>& p) { is >> p.first >> p.second; return is; }\r\n    template<typename T> ostream& operator<<(ostream& os, const vc<T>& a) { for (int i = 0, n = a.size(); i < n; i++) { os << a[i]; if (i != n - 1) os << ' '; } return os; }\r\n    template<typename T> istream& operator>>(istream& is, vc<T>& a) { for (auto& v : a) is >> v; return is; }\r\n    template<typename T> ostream& operator<<(ostream& os, const vc<vc<T>>& a) { for (auto& v : a) os << v << '\\n'; return os; }\r\n\r\n    //set map\r\n    template<typename T> ostream& operator<<(ostream& os, const set<T>& a) { for (auto& v : a) os << v << ' '; return os; }\r\n    template<typename T> ostream& operator<<(ostream& os, const set<T, greater<T>>& a) { for (auto& v : a) os << v << ' '; return os; }\r\n    template<typename T> ostream& operator<<(ostream& os, const multiset<T>& a) { for (auto& v : a) os << v << ' '; return os; }\r\n    //template<typename T> istream& operator>>(istream& is, set<T>& a) { T x; is >> x; a.insert(x); return is; }\r\n    //template<typename T1, typename T2> istream& operator>>(istream& is, const map<T1, T2>& a) { T1 x; T2 y; is >> x >> y; a[x] = y; return is; }\r\n    template<typename T1, typename T2> ostream& operator<<(ostream& os, const map<T1, T2>& a) { for (auto& p : a) os << endl << setw(15) << p.first << \" : \" << p.second << ' '; return os; }\r\n\r\n    template<typename T> vc<T>& operator+=(vc<T>& a, const vc<T>& b) { a.insert(a.end(), b.begin(), b.end()); return a; }\r\n\r\n    const int IOS = []() { ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();\r\n\r\n#define endl ('\\n')\r\n#define MP(x,y) make_pair(x,y)\r\n#define all(a) begin(a), end(a)\r\n#define SUM(a) accumulate(all(a), 0LL)\r\n#define MIN(a) (*min_element(all(a)))\r\n#define MAX(a) (*max_element(all(a)))\r\n#define lb(a, x) distance(begin(a), lower_bound(all(a), (x)))\r\n#define ub(a, x) distance(begin(a), upper_bound(all(a), (x)))\r\n#define lbex(l, r, x) distance(l, lower_bound(l,r,(x)))\r\n#define ubex(l, r, x) distance(l, upper_bound(l,r,(x)))\r\n#define toset(a) (sort(all(a)), a.erase(unique(all(a)), a.end()), a.size())\r\n#ifdef CF_DEBUG\r\n    auto dbout = [](auto&& ... args) -> void { ((cerr << args << \", \"), ...); };\r\n#define debug(...) cerr << \"( \"<< #__VA_ARGS__ << \" ) = ( \", dbout(__VA_ARGS__), cerr << \")\\n\"  \r\n#define debugt(x) cerr << \"( \"<< #x<<\" ) = [ \"; apply(dbout, x); cerr << \"]\\n\";\r\n#define cin fin\r\n#define cout fout\r\n    ifstream fin(\"CF_data.in\");\r\n    ofstream fout(\"CF_data.out\");\r\n#define __int128 ll\r\n#else\r\n#define debug(...) (0)\r\n#define debugt(x) (0)\r\n#endif\r\n    ll operator%(const string& s, const ll p) { ll res = 0; for (auto& v : s) res = (res * 10 + v - 48) % p; return res; }\r\n    // double POW(double a, ll b) { double r = 1; for (; b > 0; a *= a, b >>= 1) if (b & 1) r *= a; return r; }\r\n    ll POW(ll a, ll b, const ll p) { a %= p; if (a == 0) return 0LL; ll r = 1; for (; b > 0; a = a * a % p, b >>= 1) if (b & 1) r = r * a % p; return r; }\r\n    ll gcd(ll a, ll b) { if (a < b) swap(a, b); if (b != 0) while (b ^= a ^= b ^= a %= b); return a; }\r\n    int gcd(int a, int b) { if (a < b) swap(a, b); if (b != 0) while (b ^= a ^= b ^= a %= b); return a; }\r\n    ll gcd(const vi& a) { int g = a[0]; for (auto& v : a) g = gcd(g, v); return g; }\r\n    // ll gcd(const vl& a) { ll g = a[0]; for (auto& v : a) g = gcd(g, v); return g; }\r\n    ll exgcd(ll a, ll b, ll& x, ll& y) { ll d = a; if (b != 0) d = exgcd(b, a % b, y, x), y -= (a / b) * x; else x = 1, y = 0; return d; }\r\n    ll NIY_exgcd(ll a, ll p) { ll x, y; exgcd(a, p, x, y); return (x % p + p) % p; }\r\n    ll LCM(ll a, ll b) { return a / gcd(a, b) * b; }\r\n    ll fast_mul(ll a, ll b, ll mod) { return ((a * b - (ll)((ll)((long double)a / mod * b + 1e-3) * mod)) % mod + mod) % mod; }\r\n    vi discrete(vi& a) { vi b(a); toset(b); for (auto& v : a) v = lb(b, v); return b; }\r\n    vl discrete(vl& a) { vl b(a); toset(b); for (auto& v : a) v = lb(b, v); return b; }\r\n    // vi discrete(vpii& a) { vi b; for (auto& [x, y] : a) b.emplace_back(x), b.emplace_back(y); toset(b); for (auto& [x, y] : a) x = lb(b, x), y = lb(b, y); return b; }\r\n\r\n    inline int LOG2(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x)) (x>0)\r\n    inline int sgn(ll x) { if (x) return x > 0 ? 1 : -1; return 0; }\r\n\r\n    const double PI = acos(-1);\r\n    constexpr int inf = 0x3f3f3f3f;\r\n    constexpr ll INF = 0x3f3f3f3f3f3f3f3f;\r\n    // constexpr ll INF = 1e15;\r\n}\r\nusing namespace CF;\r\n\r\nchar start_ch; int start_int; ll start_ll; Z start_Z;\r\n\r\n/*************************************************/\r\n// #undef endl\r\n\r\ntemplate<class T, class _Pr> vpii getLR(vc<T> a, _Pr cmp)\r\n{\r\n    int n = a.size();\r\n    vpii LR(n, { -1,n });\r\n    stack<int> s;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        while (!s.empty() && !cmp(a[s.top()], a[i]))\r\n        {\r\n            LR[s.top()].second = i;\r\n            s.pop();\r\n        }\r\n        if (!s.empty()) LR[i].first = s.top();\r\n        s.push(i);\r\n    }\r\n    return LR;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int n;\r\n    string s;\r\n    cin >> n >> s;\r\n    vi a(n + 1);\r\n    for (int i = 0; i < n; i++)\r\n        if (s[i] == '(') a[i + 1] = a[i] + 1;\r\n        else a[i + 1] = a[i] - 1;\r\n\r\n    ll ans = 0;\r\n    vpii f = getLR(a, less<int>());\r\n    for (int i = 0; i <= n; i++)\r\n        ans -= (1LL * (i - f[i].first) * (f[i].second - i) - 1) * a[i];\r\n\r\n    sort(all(a));\r\n    for (int i = 1; i <= n; i++) ans += ll(i) * a[i];\r\n    cout << ans;\r\n}\r\n\r\nvoid myinit()\r\n{\r\n    cin >> T_T;\r\n    return;\r\n}\r\n\r\n/**************************************************/\r\n// If you fail, don\u2019t forget to learn your lesson.\r\n\r\nchar end_ch; int end_int; ll end_ll; Z end_Z;\r\n\r\nint main()\r\n{\r\n#ifdef CF_DEBUG\r\n    clock_t time_start = clock();\r\n#endif  \r\n    myinit();\r\n    for (int t = 1; t <= T_T; t++)\r\n    {\r\n        // cout << \"Case #\" << t << \": \";\r\n        debug(\"Case \", t);\r\n        solve();\r\n        if (t != T_T) cout << endl;\r\n    }\r\n    // cout.flush();\r\n#ifdef CF_DEBUG\r\n    fin.close(); fout.close();\r\n    clock_t time_end = clock();\r\n    auto memory = ((&end_ch) - (&start_ch)) / 1024 + ((&end_int) - (&start_int) + ((&(end_Z.x)) - (&(start_Z.x)))) / 256 + ((&end_ll) - (&start_ll)) / 128;\r\n    debug(time_end - time_start);\r\n    debug(memory / 1024);\r\n#endif \r\n    return 0;\r\n}"
}