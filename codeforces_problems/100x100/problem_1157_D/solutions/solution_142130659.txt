{
    "id": 142130659,
    "contestId": 1157,
    "creationTimeSeconds": 1641781651,
    "relativeTimeSeconds": 5551,
    "problem": {
        "contestId": 1157,
        "index": "D",
        "name": "N Problems During K Days",
        "type": "PROGRAMMING",
        "rating": 1900,
        "tags": [
            "constructive algorithms",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1157,
        "members": [
            {
                "handle": "WillTheBill"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1641776100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 307200,
    "source": "#include<bits/stdc++.h>\nusing namespace std;\n\n// Username: WillTheBill\n#define _multitest_ 0\n#define _multitestexpr_ re(tests)\n#define _interactive_ 0\n#define int long long\n#define mod mod1\n\n// values\nconst int mod1 = 1000000007;\nconst int mod2 = 998244353;\n// defines\n#define vec vector\ntypedef string str;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n#define ll long long\n#define fun(ret,x,...) function<ret(__VA_ARGS__)> x;x=[&](__VA_ARGS__)->ret\n#define Void(x,...) fun(void,x,__VA_ARGS__)\n#define mp make_pair\n#define sz(x) int((x).size())\n#define fir(t) get<0>(t)\n#define sec(t) get<1>(t)\n#define thi(t) get<2>(t)\n#define fou(t) get<3>(t)\n#define fif(t) get<4>(t)\n// loops\n#define foabc(i,a,b,c) for (int i = (a); i < (b); i+=(c))\n#define cbaof(i,a,b,c) for (int i = int(b)-1; i >= (a); i-=(c))\n#define foab(i,a,b) for (int i = (a); i < (b); i++)\n#define baof(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define fon(i,n) for(int i = 0; i < n; i++)\n#define nof(i,n) for(int i = int(n) - 1; i >= 0; i--)\n#define foe(e,a) for(auto& e : a)\ntemplate<class T> class ReversedProxy {\npublic: using iterator = typename T::reverse_iterator; iterator begin() { return begin_; } iterator end() { return end_; } ReversedProxy(const iterator& begin, const iterator& end) : begin_(begin), end_(end) {}\nprivate: iterator begin_; iterator end_;};\ntemplate<class T> ReversedProxy<T> reversed(T& obj) {return ReversedProxy<T>(obj.rbegin(), obj.rend());}\n#define eof(e,a) for(auto e : reversed(a)) // this one is a bit slow, because of rbegin I think\n#define rep(n) for(int _ = 0; _ < n; _++)\n#define once for(int _ = 0; _ < 1; _++)\n// constructing multidimensional vectors\ntemplate<typename T> inline void init(vec<T>& v, deque<int> sizes) {\n    assert(sizes.size() == 1);\n    v = vec<T> (sizes[0]);}\ntemplate<typename T, typename C> inline void init(vec<T>& v, deque<int> sizes, C content) {\n    assert(sizes.size() == 1);\n    v = vec<T> (sizes[0], content);}\ntemplate<typename T> inline void init(vec<vec<T>>& v, deque<int> sizes) {\n    v = vec<vec<T>> (sizes[0]); sizes.pop_front();\n    if(sizes.size() == 0) return;\n    for(auto& subv : v) init(subv, sizes);}\ntemplate<typename T, typename C> inline void init(vec<vec<T>>& v, deque<int> sizes, C content) {\n    v = vec<vec<T>> (sizes[0]); sizes.pop_front();\n    if(sizes.size() == 0) return;\n    for(auto& subv : v) init(subv, sizes, content);}\n// reading\nvoid _read(str& t){cin>>t;} // has to be specified to that strings are not interpreted as basic_string<char>\ntemplate<typename T>void _read(T&t){cin>>t;}\ntemplate<typename T1,typename T2>void _read(pair<T1,T2>&p);\ntemplate<template<typename>class C,typename T>void _read(C<T>&v);\ntemplate<typename T1,typename T2>void _read(pair<T1,T2>&p){_read(p.first);_read(p.second);}\ntemplate<template<typename>class C,typename T>void _read(C<T>&v){for(auto&e:v)_read(e);}\nvoid _masterread(){}\ntemplate<typename T,typename... V>void _masterread(T& t, V&... v){_read(t);_masterread(v...);}\n#define re(...)_masterread(__VA_ARGS__)\n// writing\nstringstream _effout;\n#if defined(__local__) || (_interactive_ == 1)\n#define _stdout cout\n#else\n#define _stdout _effout\n#define endl '\\n'\n#endif\nvoid _print(str&t){_stdout<<t;}// has to be specified to that strings are not interpreted as basic_string<char>\ntemplate<typename T>void _print(T t){_stdout<<t;}\ntemplate<typename T1,typename T2>void _print(pair<T1,T2>&p);\ntemplate<template<typename>class C,typename T>void _print(C<T>&v);\ntemplate<template<typename,typename>class C,typename T1,typename T2>void _print(C<T1,T2>&v);\ntemplate<typename A>void _print(queue<A>&q);\ntemplate<typename A>void _print(priority_queue<A>&pq);\ntemplate<typename T1,typename T2>void _print(pair<T1,T2>&p){_print(p.first);_stdout<<\" \";_print(p.second);}\ntemplate<template<typename>class C,typename T>void _print(C<T>&v){bool f=1;for(auto&e:v)_stdout<<(f?\"\":\" \"),f=0,_print(e);}\ntemplate<template<typename,typename>class C,typename T1,typename T2>void _print(C<T1,T2>&v){bool f=1;for(auto&e:v)_stdout<<(f?\"\":\" \"),f=0,_print(e);}\ntemplate<typename A> void _print(queue<A>&q){queue<A>cp=q; vec<A>v;while(!cp.empty()) v.pb(cp.front()), cp.pop();_print(v);}\ntemplate<typename A> void _print(priority_queue<A>&pq){priority_queue<A>cp=pq; vec<A>v;while(!cp.empty()) v.pb(cp.top()), cp.pop();_print(v);}\nvoid _masterprint(){}\ntemplate<typename T,typename... V>void _masterprint(T t, V... v){_print(t);if(sizeof...(v))_stdout<<\" \";_masterprint(v...);}\n#define pr(...)_masterprint(__VA_ARGS__)\n#define prl(...) (_masterprint(__VA_ARGS__),_stdout<<endl)\n// debugging, https://stackoverflow.com/questions/35652212/how-partial-template-specialization-chosen\nvoid _debug(str&t){cerr<<t;} // has to be specified to that strings are not interpreted as basic_string<char>\ntemplate <typename T> void _debug(T t){cerr<<t;}\ntemplate<typename T1,typename T2> void _debug(pair<T1,T2>p);\ntemplate<template<typename>class C,typename T>void _debug(C<T>v);\ntemplate<template<typename,typename>class C,typename T1,typename T2>void _debug(C<T1,T2>v);\ntemplate<typename A>void _debug(queue<A>&q);\ntemplate<typename A>void _debug(priority_queue<A>&pq);\ntemplate<typename T1,typename T2> void _debug(pair<T1,T2> p){cerr<<\"{\";_debug(p.first);cerr<<\", \";_debug(p.second);cerr<<\"}\";}\ntemplate<template<typename>class C,typename T>void _debug(C<T>v){bool f=1;cerr<<\"(\";for(auto&e:v)cerr<<(f?\"\":\", \"),f=0,_debug(e);cerr << \")\";}\ntemplate<template<typename,typename>class C,typename T1,typename T2>void _debug(C<T1,T2>v){bool f=1;cerr<<\"(\";for(auto&e:v)cerr<<(f?\"\":\", \"),f=0,_debug(e);cerr << \")\";}\ntemplate<typename A> void _debug(queue<A>&q){queue<A>cp=q; vec<A>v;while(!cp.empty()) v.pb(cp.front()), cp.pop();_debug(v);}\ntemplate<typename A> void _debug(priority_queue<A>&pq){priority_queue<A>cp=pq; vec<A>v;while(!cp.empty()) v.pb(cp.top()), cp.pop();_debug(v);}\nvoid _masterdebug(){cerr<<\"]\"<<endl;}\ntemplate<typename T,typename... V> void _masterdebug(T t,V... v){_debug(t);if(sizeof...(v))cerr<<\", \";_masterdebug(v...);}\n#ifdef __local__\n#define debug(...)(cerr<<\"[\"<<#__VA_ARGS__<<\"] = [\",_masterdebug(__VA_ARGS__))\ntemplate<typename T> void _debugall(T c, string n){_debug(\"debugall: \");_debug(n);cerr<<endl;for(auto&_e:c){_debug(\"  \");_debug(_e);cerr<<endl;}} //2d vectors and similar\n#define debugall(c)(_debugall(c,#c))\n#else\n#define debug(...)\n#define debugall(c)\n#endif\n// main\nvoid prep();\nvoid testcase(signed tc);\nsigned main(){\n    if(!_interactive_) {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n    }\n    pr(setprecision(10));\n    pr(fixed);\n    prep();\n    if(_multitest_) {\n        signed tests; _multitestexpr_;\n        for(signed tc = 1; tc <= tests; tc++) {\n            testcase(tc);\n        }\n    } else {\n        testcase(1);\n    }\n#ifndef __local__\n    cout<<_effout.str();\n#endif\n}\nvoid prep(){\n}\nvoid testcase(__attribute__((unused)) signed tc){\n    int n,k; re(n,k);\n    int original_n = n;\n    int mn = (k + 1ll) * k / 2ll;\n    if(mn > n) {\n        prl(\"NO\");\n        return;\n    }\n    vec<int> a (k);\n    bool found = 0;\n    once {\n        int sum = (k + 2ll) * (k + 1ll) / 2ll - 1ll;\n        if(sum > n) break;\n        n -= sum;\n        int add = n / k;\n        fon(i, n) {\n            a[i] = 2ll + i + add;\n            n -= add;\n        }\n        int idx = k - 1;\n        while(n) a[idx--]++, n--;\n        found = 1;\n        debug(a);\n    }\n    if(!found) {\n        n = original_n;\n        for(int i = 0; i < min(k, 40ll); i++) {\n            int first = 1ll << i;\n            n -= first;\n            a[i] = first;\n            vec<int> ta = a;\n            int cnt = 0;\n            int sum = 0;\n            for(int j = i + 1; j < k; j++) {\n                cnt++;\n                ta[j] = first + cnt;\n                sum += ta[j];\n            }\n            if(cnt == 0) break;\n            // (n - sum) / cnt;\n            int add = (n - sum) / cnt;\n            if(sum <= n && add >= 0 && first + add + 1ll <= 2ll * first) {\n                debug(first, ta, add);\n                for(int j = i + 1; j < k; j++) {\n                    ta[j] += add;\n                    n -= ta[j];\n                }\n                debug(first, ta, add, n);\n                int idx = k - 1;\n                while(n) ta[idx--]++, n--;\n                assert(idx > i);\n                a = ta;\n                break;\n            }\n        }\n    }\n    debug(a);\n    bool ok = a[0] >= 1;\n    fon(i, n - 1) ok &= (a[i] < a[i+1]);\n    fon(i, n - 1) ok &= (a[i+1] <= 2ll * a[i]);\n    ok &= (accumulate(all(a),0ll) == original_n);\n    if(!ok) {\n        prl(\"NO\");\n        return;\n    }\n    prl(\"YES\");\n    prl(a);\n}\n"
}