{
    "id": 229698304,
    "contestId": 1157,
    "creationTimeSeconds": 1698240315,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1157,
        "index": "D",
        "name": "N Problems During K Days",
        "type": "PROGRAMMING",
        "rating": 1900,
        "tags": [
            "constructive algorithms",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1157,
        "members": [
            {
                "handle": "anandchourasia007"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1556289300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 51,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 819200,
    "source": "#include <bits/stdc++.h>\r\n#include <complex>\r\n#include <queue>\r\n#include <set>\r\n#include <unordered_set>\r\n#include <list>\r\n#include <chrono>\r\n#include <random>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <string>\r\n#include <vector>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <stack>\r\n#include <iomanip>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\nusing namespace chrono;\r\n\r\n#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\r\n#define MOD 1000000007\r\n#define MOD1 998244353\r\n#define INF 1e18\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define mp make_pair\r\n#define ff first\r\n#define ss second\r\n#define PI 3.141592653589793238462\r\n#define set_bits __builtin_popcountll\r\n#define sz(x) ((int)(x).size())\r\n#define all(x) (x).begin(), (x).end()\r\n#define ll long long\r\n#define imax INT_MAX\r\n#define llmax LLONG_MAX\r\n#define precise_cout(a,b) cout<<fixed<<setprecision(b)<<a<<\"\\n\";\r\n#define f(i,a,b) for(int i=a;i<=(int)b;i++)\r\n#define fn(i,b,a) for(int i=b;i>=(int)a;i--)\r\n#define debug(x) cerr << #x<<\" : \"; _print(x); cerr << endl;\r\n#define vi vector<int>\r\n#define vll vector<ll>\r\n// #ifndef ONLINE_JUDGE\r\n// #define debug(x) cerr << #x<<\" \"; _print(x); cerr << endl;\r\n// #endif\r\n\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\nvoid _print(ll t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\n/*---------------------------------------------------------------------------------------------------------------------------*/\r\n// ll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\r\n// void swap(int &x, int &y) {int temp = x; x = y; y = temp;}\r\n// int expo(int a, int b, int mod) {int res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\r\n// void extendgcd(int a, int b, int*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); int x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\r\n// int mminv(int a, int b) {int arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\r\n// int mminvprime(int a, int b) {return expo(a, b - 2, b);}\r\n// int mod_add(int a, int b, int m) {a = a % m; b = b % m; return (((0ll + a + b) % m) + m) % m;}\r\n// int mod_mul(int a, int b, int m) {a = a % m; b = b % m; return (((1ll * a * b) % m) + m) % m;}\r\n// int mod_sub(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\n// int mod_div(int a, int b, int m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\r\n\r\n// Fenwick tree\r\nconst int N=2e5+10; \r\n//struct BIT {\r\n// ll c[N];\r\n// void add(ll x, ll v, ll n) {\r\n//   while(x <= n) c[x] += v, x += x & -x;\r\n// }\r\n// ll query(ll x) {\r\n//   ll s = 0;\r\n//   while(x) s += c[x], x -= x & -x;\r\n//   return s;\r\n// }\r\n// ll search(ll prefSum, ll n){  // using Binary lifting, search lower_bound for prefSum in O(logn) \r\n//   ll num = 0;\r\n//   ll sum = 0;\r\n//   for(int i = 21; i>=0 ; --i){\r\n//       if((num + (1<<i) <= n) && (sum + c[num + (1<<i)] <= prefSum)){\r\n//           num += (1<<i);\r\n//           sum += c[num];\r\n//   }\r\n// }\r\n// return num + 1;\r\n// }\r\n//} tr;\r\n// binary exponentiation\r\n// ll bexp(ll a, ll b) { ll res = 1; while (b > 0) { if (b & 1) res = res * a; a = a * a; b >>= 1; } return res; }\r\n \r\n// binary exponentiation modulo mod\r\n// ll bexpM(ll a, ll b, ll mod) { ll res = 1; while (b > 0) { if (b & 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; } return res; }\r\n \r\n// sieve of eratosthenes for primes\r\n// const int P = 10000000;\r\n// int prime[P + 1];\r\n// void sieve() { prime[0] = 0; prime[1] = 0; for (int i = 2; i <= P; i++) { prime[i] = 1; } for (int i = 2; i * i <= P; i++) { if (prime[i] == 1) { for (int j = i * i; j <= P; j += i) { prime[j] = 0; } } } }\r\n \r\n// sieve of eratosthenes for 'prime' factorization, O(n(log(log(n)))) for precomputation of spf, O(log(n)) thereafter to factorize each n\r\n// ll spf[P + 1];\r\n// vector<ll> primefactorize(ll n) { vector<ll> f; while(n>1){ f.pb(spf[n]); n/=spf[n]; } return f; }\r\n// void sieve_spf() { spf[0] = 0; spf[1] = 0; for (int i = 2; i <= P; i++) { spf[i] = -1; } for (int i = 2; i <= P; i++) { if (spf[i] == -1) { for (int j = i; j <= P; j += i) { if (spf[j] == -1) { spf[j] = i; } } } } }\r\n \r\n// extended euclid algorithm\r\n// ll extendedgcd(ll a, ll b, ll &x, ll &y) { if (b == 0) { x = 1; y = 0; return a; } ll x1, y1; ll d = extendedgcd(b, a % b, x1, y1); x = y1; y = x1 - y1 * (a / b); return d; }\r\n \r\n// modulo multiplicative inverse\r\n// ll modInverse(ll a, ll m) { ll x, y; ll g = extendedgcd(a, m, x, y); ll res = (x % m + m) % m; return res; }\r\n \r\n// ncr using precomputed factorials and modInverse\r\n// vector<ll> fact(3e5+10,0);\r\n// void all_factorial_mod(int md) { fact[0]=1; for(int i=1; i<=300010; i++) fact[i]=(fact[i-1]*i)%md; }\r\n// ll ncrMOD(ll n,ll r, ll md) { return ((fact[n]*modInverse(fact[r],md)%md)*modInverse(fact[n-r],md))%md; }\r\n \r\n// phi function(1) O(sqrt(n)log(n))\r\n// ll phi1(ll n) { ll result = n; for (ll i = 2; i * i <= n; i++) { if (n % i == 0) { while (n % i == 0) n /= i; result -= result / i; } } if (n > 1) result -= result / n; return result; }\r\n \r\n// nCr (O(n))\r\n// ll ncr(ll n, ll k) { ll res = 1; if (k > n - k) k = n - k; for (int i = 0; i < k; ++i) { res *= (n - i); res /= (i + 1); } return res; }\r\n\r\n// nCr with modulo (O(rlogn))\r\n// ll ncrMOD(ll n, ll k, ll mod) { ll res = 1; if (k > n - k) k = n - k; for (int i = 0; i < k; ++i) { res = (res * (n - i)) % mod; res = (res * modInverse(i + 1, mod)) % mod; } return res % mod; }\r\n \r\n// factorial without modulo \r\n// ll factorial(ll n) { ll res = 1; for (int i = 2; i <= n; i++) res = res * i; return res; }\r\n \r\n// factorial with modulo \r\n// ll factorialMOD(ll n, ll m) { ll res = 1; for (int i = 2; i <= n; i++) res = ((res % m) * (i % m)) % m; return res % m; }\r\n \r\n// Check if a number is a Perfect square\r\n// bool checkperfectsquare(ll n) { if (ceil((double)sqrt(n)) == floor((double)sqrt(n))) { return true; } else { return false; } }\r\n \r\n// Divisors of a number in O(sqrt N) -> including 1 and n\r\n// vector<ll> factorize(ll n) { vector<ll> v; v.push_back(1); for(int i=2;i<sqrt(n);i++) { if (n % i == 0) { v.push_back(i); v.push_back(n / i); } } if (checkperfectsquare(n) == 1) { v.push_back(sqrt(n)); } if (n != 1) { v.pb(n); } return v; }\r\n \r\n// calculate mex of a set\r\n// ll calculateMex(vector<ll> A) { set<int> Set(A.begin(), A.end()); ll Mex = 0; while (Set.find(Mex) != Set.end()) Mex++; return (Mex); }\r\n \r\n// count number of set bits in a number\r\n// ll countSetBits(ll n) { if (n == 0) return 0; return (n & 1) + countSetBits(n >> 1); }\r\n\r\n// This section if not commented will take almost 117 mb, so wherever memory limit is low say 64 mb or tighter, make sure that not this entire section is uncommented.\r\n// use (a+b-1)/b instead of ceil(a*1.0/b), as it does not suffer from floating point imprecision\r\n\r\n// BEFORE SUBMISSION, \r\n// 1. check for uninitialised variables, \r\n// 2. check for possible int overflow, \r\n// 3. check for precision issues, \r\n// 4. check for invalid index access \r\n\r\n// Don't get stuck on one approach, incorrect approach causes more WA than incorrect implementation.\r\n/*--------------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvoid solve(){\r\n    ll n,k;\r\n    cin>>n>>k;\r\n    ll temp=k*(k+1)/2;\r\n    vll a(k);\r\n    f(i,0,k-1) a[i]=i+1;\r\n    if(n>=temp){\r\n        n-=temp;\r\n        ll q=n/k;\r\n        ll r=n%k;\r\n        f(i,0,k-1) a[i]=i+1+q;\r\n        fn(i,k-1,1){\r\n            ll d=2*a[i-1]-a[i];\r\n            a[i]+=min(r,d);\r\n            r-=min(r,d);\r\n            if(r==0) break;\r\n        }\r\n        if(r>0) cout<<\"NO\\n\";\r\n        else {\r\n            cout<<\"YES\\n\";\r\n            f(i,0,k-1) cout<<a[i]<<\" \";\r\n            cout<<\"\\n\";\r\n        }\r\n        \r\n    }else cout<<\"NO\\n\";\r\n}\r\n\r\nsigned main() {\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\",\"r\",stdin);\r\n    freopen(\"output.txt\",\"w\",stdout);\r\n    freopen(\"error.txt\",\"w\",stderr);\r\n#endif\r\n    fastio();\r\n    auto start1 = high_resolution_clock::now();\r\n    int t=1;\r\n    // cin>>t;\r\n    while(t--){\r\n        solve();\r\n    }\r\n    auto stop1 = high_resolution_clock::now();\r\n    auto duration = duration_cast<microseconds>(stop1 - start1);\r\n#ifndef ONLINE_JUDGE\r\n    cerr << \"Time: \" << duration . count() / 1000 << endl;\r\n#endif\r\n}"
}