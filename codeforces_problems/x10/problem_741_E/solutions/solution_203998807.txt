{
    "id": 203998807,
    "contestId": 741,
    "creationTimeSeconds": 1682828764,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 741,
        "index": "E",
        "name": "Arpa\u2019s abnormal DNA and Mehrdad\u2019s deep interest",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures"
        ]
    },
    "author": {
        "contestId": 741,
        "members": [
            {
                "handle": "bkifhr9"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1481034900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 91,
    "timeConsumedMillis": 1045,
    "memoryConsumedBytes": 222310400,
    "source": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\",                  \\\n                     \"omit-frame-pointer\", \"inline\")\n#pragma GCC target(                                                            \\\n    \"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,fma,tune=native\")\n#pragma GCC option(\"arch=native\", \"no-zero-upper\") // Enable AVX\n\n/// UH Top\n#include <bits/stdc++.h>\n#define db(x)   cerr << #x << ':' << (x) << '\\n';\n#define all(v)  (v).begin(), (v).end()\n#define allr(v) (v).rbegin(), (v).rend()\n// #define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n// typedef __int128_t int128;\ntypedef pair<int, int> pii;\ntypedef pair<ld, ll> pdi;\ntypedef pair<ld, ld> pdd;\ntypedef pair<ld, pdd> pdp;\ntypedef pair<string, ll> psi;\ntypedef pair<ll, string> pls;\ntypedef pair<string, string> pss;\ntypedef pair<ll, pii> pip;\ntypedef pair<pii, pii> ppp;\ntypedef complex<ld> point;\ntypedef vector<point> polygon;\ntypedef vector<ll> vi;\ntypedef pair<point, int> ppi;\n#define prec(n)                                                                \\\n\tcout.precision(n);                                                         \\\n\tcout << fixed\nconst ll mod = (1e9 + 7);\nconst ld eps = (1e-9);\nconst ll oo = (ll)(1e18 + 5);\n#define pi   acos(-1)\n#define MAXN (ll)(2e5 + 5)\n#define SIZE 100\n\ntemplate <typename T> struct rmq {\n\tvector<T> v;\n\tint n;\n\tstatic const int b = 30; // block size\n\tvector<int> mask, t;     // mask and sparse table\n\n\tint op(int x, int y) { return v[x] < v[y] ? x : y; }\n\t// least significant set bit\n\tint lsb(int x) { return x & -x; }\n\t// index of the most significant set bit\n\tint msb_index(int x) { return __builtin_clz(1) - __builtin_clz(x); }\n\t// answer query of v[r-size+1..r] using the masks, given size <= b\n\tint small(int r, int size = b) {\n\t\t// get only 'size' least significant bits of the mask\n\t\t// and then get the index of the msb of that\n\t\tint dist_from_r = msb_index(mask[r] & ((1 << size) - 1));\n\n\t\treturn r - dist_from_r;\n\t}\n\trmq(const vector<T> &v_) : v(v_), n(v.size()), mask(n), t(n) {\n\t\tint curr_mask = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t// shift mask by 1, keeping only the 'b' least significant bits\n\t\t\tcurr_mask = (curr_mask << 1) & ((1 << b) - 1);\n\n\t\t\twhile (curr_mask > 0 and\n\t\t\t       op(i, i - msb_index(lsb(curr_mask))) == i) {\n\t\t\t\t// current value is smaller than the value represented by the\n\t\t\t\t// last 1 in curr_mask, so we need to turn off that bit\n\t\t\t\tcurr_mask ^= lsb(curr_mask);\n\t\t\t}\n\t\t\t// append extra 1 to the mask\n\t\t\tcurr_mask |= 1;\n\n\t\t\tmask[i] = curr_mask;\n\t\t}\n\n\t\t// build sparse table over the n/b blocks\n\t\t// the sparse table is linearized, so what would be at\n\t\t// table[j][i] is stored in table[(n/b)*j + i]\n\t\tfor (int i = 0; i < n / b; i++)\n\t\t\tt[i] = small(b * i + b - 1);\n\t\tfor (int j = 1; (1 << j) <= n / b; j++)\n\t\t\tfor (int i = 0; i + (1 << j) <= n / b; i++)\n\t\t\t\tt[n / b * j + i] = op(t[n / b * (j - 1) + i],\n\t\t\t\t                      t[n / b * (j - 1) + i + (1 << (j - 1))]);\n\t}\n\t// query(l, r) returns the actual minimum of v[l..r]\n\t// to get the index, just change the first and last lines of the function\n\tT query(int l, int r) {\n\t\t// query too small\n\t\tif (r - l + 1 <= b)\n\t\t\treturn v[small(r, r - l + 1)];\n\n\t\t// get the minimum of the endpoints\n\t\t// (there is no problem if the ranges overlap with the sparse table\n\t\t// query)\n\t\tint ans = op(small(l + b - 1), small(r));\n\n\t\t// 'x' and 'y' are the blocks we need to query over\n\t\tint x = l / b + 1, y = r / b - 1;\n\n\t\tif (x <= y) {\n\t\t\tint j = msb_index(y - x + 1);\n\t\t\tans =\n\t\t\t    op(ans, op(t[n / b * j + x], t[n / b * j + y - (1 << j) + 1]));\n\t\t}\n\n\t\treturn v[ans];\n\t}\n};\n\ntemplate <typename T> struct RMQ2 {\n\tvector<vector<T>> rmq;\n\tvector<int> lg;\n\tint n;\n\tRMQ2(vector<T> &v) : n(v.size()) {\n\t\tlg.push_back(-1);\n\t\tfor (int i = 1; i <= n + 5; i++)\n\t\t\tlg.push_back(lg.back() + !(i & (i - 1)));\n\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\trmq.push_back(vector<T>(lg[n] + 1));\n\t\tfor (int i = 0; i < n; i++)\n\t\t\trmq[i][0] = v[i];\n\t\tfor (int j = 1; j <= lg[n]; j++)\n\t\t\tfor (int i = 0; i + (1 << j) <= n; i++)\n\t\t\t\trmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);\n\t}\n\n\tT query(int l, int r) {\n\t\tint po = lg[r - l + 1];\n\t\treturn min(rmq[l][po], rmq[r - (1 << po) + 1][po]);\n\t}\n};\n\ntemplate <typename charT> struct SuffixArray {\n\tint n;\n\tvector<int> sa, rank, lcp;\n\n\tSuffixArray(const basic_string<charT> &s)\n\t    : n(s.length() + 1), sa(n), rank(n), lcp(n) {\n\t\tvector<int> _sa(n), bucket(n);\n\n\t\tiota(sa.rbegin(), sa.rend(), 0);\n\t\tsort(next(sa.begin()), sa.end(), [&](int i, int j) {\n\t\t\treturn s[i] < s[j];\n\t\t});\n\n\t\tfor (int i = 1, j = 0; i < n; ++i) {\n\t\t\trank[sa[i]] = rank[sa[i - 1]] + (i == 1 || s[sa[i - 1]] < s[sa[i]]);\n\t\t\tif (rank[sa[i]] != rank[sa[i - 1]])\n\t\t\t\tbucket[++j] = i;\n\t\t}\n\n\t\tfor (int len = 1; len <= n; len += len) {\n\t\t\tfor (int i = 0, j; i < n; ++i) {\n\t\t\t\tif ((j = sa[i] - len) < 0)\n\t\t\t\t\tj += n;\n\t\t\t\t_sa[bucket[rank[j]]++] = j;\n\t\t\t}\n\n\t\t\tsa[_sa[bucket[0] = 0]] = 0;\n\n\t\t\tfor (int i = 1, j = 0; i < n; ++i) {\n\t\t\t\tif (rank[_sa[i]] != rank[_sa[i - 1]] ||\n\t\t\t\t    rank[_sa[i] + len] != rank[_sa[i - 1] + len])\n\t\t\t\t\tbucket[++j] = i;\n\n\t\t\t\tsa[_sa[i]] = j;\n\t\t\t}\n\n\t\t\tcopy(sa.begin(), sa.end(), rank.begin());\n\t\t\tsa.swap(_sa);\n\n\t\t\tif (rank[sa[n - 1]] == n - 1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0, j = rank[lcp[0] = 0], k = 0; i < n - 1; ++i, ++k)\n\t\t\twhile (k >= 0 && s[i] != s[sa[j - 1] + k])\n\t\t\t\tlcp[j] = k--, j = rank[sa[j] + 1];\n\t}\n};\n\nchar chh(int p, int off, string &s, string &t) {\n\tif (p < off)\n\t\treturn s[p];\n\tif (p < off + t.size())\n\t\treturn t[p - off];\n\treturn s[p - t.size()];\n}\n\nint32_t main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// freopen(\"input.txt\", \"w\", stdout);\n\n\t// string s = \"\";\n\t// string t = \"\";\n\t// int q = 1e5;\n\t// for (int i = 0; i < 1e5; i++) {\n\t// \ts.push_back('a' + (i % 26));\n\t// \tt.push_back('a' + (i % 26));\n\t// }\n\t// cout << s << ' ' << t << ' ' << q << '\\n';\n\n\t// for (int i = 0; i < q; i++) {\n\t// \tcout << 0 << ' ' << 100000 << ' ' << 100 << ' ' << 0 << ' ' << 99\n\t// \t     << '\\n';\n\t// }\n\n\tstring s, t;\n\tcin >> s >> t;\n\tint q;\n\tcin >> q;\n\tint n = s.size();\n\tvector<int> ts;\n\tfor (int i = 0; i <= n; i++)\n\t\tts.push_back(i);\n\n\tstring st = s + \"$\" + t;\n\n\tSuffixArray<char> sa(st);\n\tRMQ2 rmq_lcp(sa.lcp);\n\tvector<int> pos_s(n), pos_t(t.size());\n\tfor (int i = 1; i < sa.sa.size(); i++) {\n\t\tif (sa.sa[i] < n)\n\t\t\tpos_s[sa.sa[i]] = i;\n\t\telse if (sa.sa[i] > n)\n\t\t\tpos_t[sa.sa[i] - n - 1] = i;\n\t}\n\n\tauto help = [&](pii a, pii b) {\n\t\tint l, r;\n\t\tif (a.second == 0)\n\t\t\tl = pos_s[a.first];\n\t\telse\n\t\t\tl = pos_t[a.first];\n\t\tif (b.second == 0)\n\t\t\tr = pos_s[b.first];\n\t\telse\n\t\t\tr = pos_t[b.first];\n\t\tif (l > r)\n\t\t\tswap(l, r);\n\t\treturn rmq_lcp.query(l + 1, r);\n\t};\n\n\tauto solve_eqs = [&](int a, int b) {\n\t\tif (a > b)\n\t\t\tswap(a, b);\n\t\tif (a + t.size() < b) {\n\t\t\tint ans = a;\n\t\t\tint add = help(pii(a, 0), pii(0, 1));\n\t\t\tif (add >= t.size()) {\n\t\t\t\tans += t.size();\n\t\t\t\tadd = help(pii(a + t.size(), 0), pii(a, 0));\n\t\t\t\tif (add >= b - a - t.size()) {\n\t\t\t\t\tans += b - a - t.size();\n\t\t\t\t\tadd = help(pii(0, 1), pii(b - t.size(), 0));\n\t\t\t\t\tif (add >= t.size())\n\t\t\t\t\t\treturn n + (int)(t.size());\n\t\t\t\t\telse\n\t\t\t\t\t\treturn ans + add;\n\t\t\t\t} else\n\t\t\t\t\treturn ans + add;\n\t\t\t} else\n\t\t\t\treturn ans + add;\n\t\t} else if (a + t.size() == b) {\n\t\t\tint ans = a;\n\t\t\tint add = help(pii(a, 0), pii(0, 1));\n\t\t\tif (add >= t.size()) {\n\t\t\t\tans += t.size();\n\t\t\t\tadd = help(pii(0, 1), pii(a, 0));\n\t\t\t\tif (add >= t.size())\n\t\t\t\t\treturn n + (int)(t.size());\n\t\t\t\telse\n\t\t\t\t\treturn ans + add;\n\t\t\t} else\n\t\t\t\treturn ans + add;\n\t\t} else {\n\t\t\tint ans = a;\n\t\t\tint add = help(pii(a, 0), pii(0, 1));\n\t\t\tif (add >= b - a) {\n\t\t\t\tans += b - a;\n\t\t\t\tadd = help(pii(0, 1), pii(b - a, 1));\n\t\t\t\tif (add >= t.size() - (b - a)) {\n\t\t\t\t\tans += t.size() - (b - a);\n\t\t\t\t\tadd = help(pii(t.size() - (b - a), 1), pii(a, 0));\n\t\t\t\t\tif (add >= b - a)\n\t\t\t\t\t\treturn n + (int)(t.size());\n\t\t\t\t\telse\n\t\t\t\t\t\treturn ans + add;\n\t\t\t\t} else\n\t\t\t\t\treturn ans + add;\n\t\t\t} else\n\t\t\t\treturn ans + add;\n\t\t}\n\t};\n\tsort(all(ts), [&](int &a, int &b) {\n\t\tint eqs = solve_eqs(a, b);\n\t\tif (eqs < n + t.size())\n\t\t\treturn chh(eqs, a, s, t) < chh(eqs, b, s, t);\n\t\treturn a < b;\n\t});\n\n\tvector<int> invs(n + 1);\n\tfor (int i = 0; i <= n; i++)\n\t\tinvs[ts[i]] = i;\n\n\t// for (int i = 0; i <= n; i++) {\n\t// \tcout << s.substr(0, ts[i]) << t << s.substr(ts[i], s.size()) << '\\n';\n\t// }\n\n\t// for (int i = 0; i <= n; i++)\n\t// \tcout << ts[i] << ' ';\n\t// cout << '\\n';\n\t// for (int i = 0; i <= n; i++)\n\t// \tcout << invs[i] << ' ';\n\t// cout << '\\n';\n\n\ttypedef rmq<int> RMQ;\n\n\tRMQ2 rmq(invs);\n\n\tvector<vector<vector<int>>> to_build_rmqs(SIZE);\n\tvector<vector<RMQ>> rmqs_toh_tixxa(SIZE);\n\tfor (int i = 1; i < SIZE; i++) {\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tto_build_rmqs[i].push_back({});\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tto_build_rmqs[i][j % i].push_back(invs[j]);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\trmqs_toh_tixxa[i].push_back(RMQ(to_build_rmqs[i][j]));\n\t}\n\n\twhile (q--) {\n\t\tint l, r, k, x, y;\n\t\tcin >> l >> r >> k >> x >> y;\n\t\tif (k >= SIZE) {\n\t\t\tif (l / k == r / k) {\n\t\t\t\tx = max(x, l % k);\n\t\t\t\ty = min(y, r % k);\n\n\t\t\t\tif (x <= y) {\n\t\t\t\t\tint ans = rmq.query((l / k) * k + x, (l / k) * k + y);\n\t\t\t\t\tcout << ts[ans] << ' ';\n\t\t\t\t} else\n\t\t\t\t\tcout << -1 << ' ';\n\t\t\t} else {\n\t\t\t\tint ans = 1e7;\n\t\t\t\tint xi = max(x, l % k);\n\t\t\t\tint yi = min(y, k - 1);\n\n\t\t\t\tif (xi <= yi)\n\t\t\t\t\tans =\n\t\t\t\t\t    min(ans, rmq.query((l / k) * k + xi, (l / k) * k + yi));\n\n\t\t\t\txi = max(x, 0);\n\t\t\t\tyi = min(y, r % k);\n\n\t\t\t\tif (xi <= yi)\n\t\t\t\t\tans =\n\t\t\t\t\t    min(ans, rmq.query((r / k) * k + xi, (r / k) * k + yi));\n\t\t\t\tfor (int b = l / k + 1; b < r / k; b++)\n\t\t\t\t\tans = min(ans, rmq.query(b * k + x, b * k + y));\n\n\t\t\t\tif (ans == 1e7)\n\t\t\t\t\tcout << -1 << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << ts[ans] << ' ';\n\t\t\t}\n\t\t} else {\n\t\t\tint ans = 1e7;\n\t\t\tfor (int i = x; i <= y; i++) {\n\t\t\t\tint li = (l / k) + ((l % k) > i);\n\t\t\t\tint ri = (r / k) - ((r % k) < i);\n\t\t\t\tif (li <= ri)\n\t\t\t\t\tans = min(ans, rmqs_toh_tixxa[k][i].query(li, ri));\n\t\t\t}\n\n\t\t\tif (ans == 1e7)\n\t\t\t\tcout << -1 << ' ';\n\t\t\telse\n\t\t\t\tcout << ts[ans] << ' ';\n\t\t}\n\t}\n\n\treturn 0;\n}\n   \t\t\t\t\t  \t   \t \t \t\t \t    \t\t\t\t\t"
}