{
    "id": 204187498,
    "contestId": 741,
    "creationTimeSeconds": 1682993137,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 741,
        "index": "E",
        "name": "Arpa\u2019s abnormal DNA and Mehrdad\u2019s deep interest",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures"
        ]
    },
    "author": {
        "contestId": 741,
        "members": [
            {
                "handle": "Marckess"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1481034900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 91,
    "timeConsumedMillis": 1044,
    "memoryConsumedBytes": 52838400,
    "source": "#include <bits/stdc++.h>\r\n\r\n#define endl '\\n'\r\n#define fi first\r\n#define se second\r\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\r\n#define forn(i,n) for (int i = 0; i < int(n); i++)\r\n#define forr(i,a,b) for (int i = int(a); i <= int(b); i++)\r\n#define all(v) v.begin(), v.end()\r\n#define pb push_back\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef pair<int, int> ii;\r\ntypedef vector<int> vi;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<ii> vii;\r\n\r\nconst int MX = 200005, SQ = 320;\r\nint m, q, res[MX];\r\nstring s, t, st;\r\nvi ord, pos;\r\n\r\nint sa[MX], lcp[MX], f[MX], lis[MX];\r\n \r\nint t_sa[MX] = {0}, c[MX] = {0};\r\nvoid countingSort (string &s, int ra[], int k) {\r\n    int sum, n = s.size(), mx = max(300, n);\r\n    memset(t_sa, 0, sizeof(t_sa));\r\n    memset(c, 0, sizeof(c));\r\n \r\n    for (int i = 0; i < n; i++)\r\n        c[i+k<n?ra[i+k]:0]++;\r\n \r\n    for (int i = sum = 0; i < mx; i++) {\r\n        int t = c[i];\r\n        c[i] = sum;\r\n        sum += t;\r\n    }\r\n \r\n    for (int i = 0; i < n; i++)\r\n        t_sa[c[sa[i]+k<n?ra[sa[i]+k]:0]++] = sa[i];\r\n \r\n    for (int i = 0; i < n; i++) sa[i] = t_sa[i];\r\n}\r\n \r\nint t_ra[MX] = {0}, ra[MX] = {0};\r\nvoid obtSA (string &s) {\r\n    int r, n = s.size();\r\n \r\n    for (int i = 0; i < n; i++) ra[i] = s[i];\r\n    for (int i = 0; i < n; i++) sa[i] = i;\r\n \r\n    for (int k = 1; k < n; k <<= 1) {\r\n        countingSort(s, ra, k);\r\n        countingSort(s, ra, 0);\r\n \r\n        t_ra[s[0]] = r = 0;\r\n \r\n        for (int i = 1; i < n; i++)\r\n            if (ra[sa[i]] == ra[sa[i-1]] && ra[sa[i]+k] == ra[sa[i-1]+k])\r\n                t_ra[sa[i]] = r;\r\n            else\r\n                t_ra[sa[i]] = ++r;\r\n \r\n        for (int i = 0; i < n; i++) ra[i] = t_ra[i];\r\n        if (ra[sa[n-1]] == n-1) break;\r\n    }\r\n}\r\n \r\nint phi[MX], plcp[MX];\r\nvoid obtLCP (string &s) {\r\n    int n = s.size();\r\n \r\n    phi[sa[0]] = -1;\r\n    for (int i = 1; i < n; i++) phi[sa[i]] = sa[i-1];\r\n \r\n    for (int i = 0, l = 0; i < n; i++) {\r\n        if (phi[i] == -1) {\r\n            plcp[i] = 0;\r\n            continue;\r\n        }\r\n \r\n        while (s[i+l] == s[phi[i]+l]) l++;\r\n \r\n        plcp[i] = l;\r\n        l = max(l-1, 0);\r\n    }\r\n \r\n    for (int i = 0; i < n; i++) lcp[i] = plcp[sa[i]];\r\n}\r\n\r\ntemplate<typename T>\r\nstruct SparseTable{\r\n\tvector<vector<T>> ST;\r\n\tvector<int> logs;\r\n\tint K, N;\r\n\r\n\tSparseTable(vector<T> & arr){\r\n\t\tif (!arr.size())\r\n\t\t\treturn;\r\n\t\t\r\n\t\tN = arr.size();\r\n\t\tK = log2(N) + 1;\r\n\t\tST.assign(K + 1, vector<T>(N));\r\n\t\tlogs.assign(N + 1, 0);\r\n\t\tfor(int i = 2; i <= N; ++i)\r\n\t\t\tlogs[i] = logs[i >> 1] + 1;\r\n\t\tfor(int i = 0; i < N; ++i)\r\n\t\t\tST[0][i] = arr[i];\r\n\t\tfor(int j = 1; j <= K; ++j)\r\n\t\t\tfor(int i = 0; i + (1 << j) <= N; ++i)\r\n\t\t\t\tST[j][i] = min(ST[j - 1][i], ST[j - 1][i + (1 << (j - 1))]); \r\n\t}\r\n\r\n\tT query(int l, int r){\r\n\t\tif (l > r) return 1e9;\r\n\t\tint j = logs[r - l + 1];\r\n\t\treturn min(ST[j][l], ST[j][r - (1 << j) + 1]);\r\n\t}\r\n};\r\n\r\nSparseTable<int> *lon, *tot;\r\n\r\nint query (int i, int j) {\r\n\tif (i == j)\r\n\t\treturn 1e9;\r\n\tif (i > j)\r\n\t\tswap(i, j);\r\n\treturn lon->query(i + 1, j);\r\n}\r\n\r\nint comp (int i, int j, int lim) {\r\n\tint lcp = query(f[i], f[j]);\r\n\tif (lcp < lim && i + lcp < (int)st.size() && j + lcp < (int)st.size())\r\n\t\treturn st[i + lcp] < st[j + lcp];\r\n\treturn -1;\r\n}\r\n\r\nint get_l (int l, int k, int rem) {\r\n\tif (l % k <= rem)\r\n\t\treturn l / k;\r\n\treturn l / k + 1;\r\n}\r\n\r\nint get_r (int r, int k, int rem) {\r\n\tif (r % k >= rem)\r\n\t\treturn r / k;\r\n\treturn r / k - 1;\r\n}\r\n\r\nvvi queries[SQ];\r\n\r\nvoid main_() {\r\n\tfill(res, res + MX, 1e9);\r\n\t\r\n\tcin >> s >> t >> q;\r\n\t\r\n\tst = s + t + \"#\";\r\n\tobtSA(st);\r\n\tobtLCP(st);\r\n\t\r\n\tvi vaux(st.size());\r\n\tforn (i, st.size())\r\n\t\tvaux[i] = lcp[i];\r\n\tlon = new SparseTable<int>(vaux);\r\n\t\r\n\tforn(i, st.size())\r\n\t\tf[sa[i]] = i;\r\n\t\r\n\tord.resize(s.size() + 1);\r\n\tiota(all(ord), 0);\r\n\t\r\n\tsort(all(ord), [&] (int i, int j) {\r\n\t\tint f = 0;\r\n\t\tif (i > j) {\r\n\t\t\tswap(i, j);\r\n\t\t\tf = 1;\r\n\t\t}\r\n\t\t\r\n\t\tint d = comp((int)s.size(), i, min((int)t.size(), j - i));\r\n\t\tif (d != -1)\r\n\t\t\treturn f ^ d;\r\n\t\t\r\n\t\tif (j - i < (int)t.size()) {\r\n\t\t\td = comp((int)s.size() + (j - i), (int)s.size(), (int)t.size() - (j - i));\r\n\t\t\tif (d != -1)\r\n\t\t\t\treturn f ^ d;\r\n\t\t\t\r\n\t\t\td = comp(i, (int)s.size() + ((int)t.size() - (j - i)), j - i);\r\n\t\t\tif (d != -1)\r\n\t\t\t\treturn f ^ d;\r\n\t\t} else {\r\n\t\t\td = comp(i, i + (int)t.size(), j - ((int)t.size() + i));\r\n\t\t\tif (d != -1)\r\n\t\t\t\treturn f ^ d;\r\n\t\t\t\r\n\t\t\td = comp(i + (j - ((int)t.size() + i)), (int)s.size(), (int)t.size());\r\n\t\t\tif (d != -1)\r\n\t\t\t\treturn f ^ d;\r\n\t\t}\r\n\t\t\r\n\t\treturn f ^ (i < j);\r\n\t});\r\n\t\r\n\tpos.resize(ord.size());\r\n\tforn (i, ord.size())\r\n\t\tpos[ord[i]] = i;\r\n\ttot = new SparseTable<int>(pos);\r\n\t\r\n\tforn (i, q) {\r\n\t\tint l, r, k, x, y;\r\n\t\tcin >> l >> r >> k >> x >> y;\r\n\t\t\r\n\t\tif (k < SQ) {\r\n\t\t\tqueries[k].pb({l, r, x, y, i});\r\n\t\t} else {\r\n\t\t\tint f = x;\r\n\t\t\tint g = y;\r\n\t\t\t\r\n\t\t\twhile (f <= r) {\r\n\t\t\t\tint lo = max(l, f);\r\n\t\t\t\tint hi = min(r, g);\r\n\t\t\t\t\r\n\t\t\t\tif (lo <= hi)\r\n\t\t\t\t\tres[i] = min(res[i], tot->query(lo, hi));\r\n\t\t\t\t\r\n\t\t\t\tf += k;\r\n\t\t\t\tg += k;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tforn (k, SQ) {\r\n\t\tif (!queries[k].size())\r\n\t\t\tcontinue;\r\n\t\t\r\n\t\tvvi aux(k);\r\n\t\tforn (j, pos.size())\r\n\t\t\taux[j % k].pb(pos[j]);\r\n\t\t\r\n\t\tvector<unique_ptr<SparseTable<int>>> small;\r\n\t\tforn (j, k)\r\n\t\t\tsmall.emplace_back(new SparseTable<int>(aux[j]));\r\n\t\t\r\n\t\tfor (const vi &v : queries[k]) {\r\n\t\t\tint l = v[0];\r\n\t\t\tint r = v[1];\r\n\t\t\tint x = v[2];\r\n\t\t\tint y = v[3];\r\n\t\t\tint ind = v[4];\r\n\t\t\t\r\n\t\t\tforr (j, x, y) {\r\n\t\t\t\tint f = get_l(l, k, j);\r\n\t\t\t\tint g = get_r(r, k, j);\r\n\t\t\t\t\r\n\t\t\t\tif (f <= g)\r\n\t\t\t\t\tres[ind] = min(res[ind], small[j]->query(f, g));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tforn (i, q) {\r\n\t\tif (res[i] == 1e9)\r\n\t\t\tcout << -1 << \" \";\r\n\t\telse\r\n\t\t\tcout << ord[res[i]] << \" \";\r\n\t}\r\n\tcout << endl;\r\n}\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\t\r\n\tint t = 1;\r\n\t// cin >> t;\r\n\twhile (t--)\r\n\t\tmain_();\r\n\t\r\n\treturn 0;\r\n}\r\n"
}