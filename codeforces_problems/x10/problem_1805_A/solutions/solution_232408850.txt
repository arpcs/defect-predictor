{
    "id": 232408850,
    "contestId": 1805,
    "creationTimeSeconds": 1699720218,
    "relativeTimeSeconds": 318,
    "problem": {
        "contestId": 1805,
        "index": "A",
        "name": "We Need the Zero",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "bitmasks",
            "brute force"
        ]
    },
    "author": {
        "contestId": 1805,
        "members": [
            {
                "handle": "matheusdacach"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1699719900
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 12,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "// https://codeforces.com/contest/1805/problem/A\npub mod solution {\n\nuse crate::io::input::Input;\nuse crate::io::output::Output;\n\ntype PreCalc = ();\n\nfn solve(input: &mut Input, out: &mut Output, _test_case: usize, _data: &PreCalc) {\n    let n = input.read_size();\n    let values = input.read_size_vec(n);\n\n    let mut all_xor = 0;\n    for &x in &values {\n        all_xor ^= x;\n    }\n\n    if values.len() % 2 == 0 {\n        if all_xor == 0 {\n            out.print_line(0);\n        } else {\n            out.print_line(-1);\n        }\n    } else {\n        out.print_line(all_xor);\n    }\n}\n\npub(crate) fn run(mut input: Input, mut output: Output) -> bool {\n    let pre_calc = ();\n\n    #[allow(dead_code)]\n    enum TestType {\n        Single,\n        MultiNumber,\n        MultiEof,\n    }\n    let test_type = TestType::MultiNumber;\n    match test_type {\n        TestType::Single => solve(&mut input, &mut output, 1, &pre_calc),\n        TestType::MultiNumber => {\n            let t = input.read();\n            for i in 0usize..t {\n                solve(&mut input, &mut output, i + 1, &pre_calc);\n            }\n        }\n        TestType::MultiEof => {\n            let mut i = 1;\n            while input.peek().is_some() {\n                solve(&mut input, &mut output, i, &pre_calc);\n                i += 1;\n            }\n        }\n    }\n    output.flush();\n    input.skip_whitespace();\n    input.peek().is_none()\n}\n\n}\npub mod collections {\npub mod vec_ext {\npub mod default {\npub fn default_vec<T: Default>(len: usize) -> Vec<T> {\n    let mut v = Vec::with_capacity(len);\n    for _ in 0..len {\n        v.push(T::default());\n    }\n    v\n}\n}\n}\n}\npub mod io {\npub mod input {\nuse crate::collections::vec_ext::default::default_vec;\nuse std::io::Read;\n\npub struct Input<'s> {\n    input: &'s mut dyn Read,\n    buf: Vec<u8>,\n    at: usize,\n    buf_read: usize,\n}\n\nmacro_rules! read_impl {\n    ($t: ty, $read_name: ident, $read_vec_name: ident) => {\n        pub fn $read_name(&mut self) -> $t {\n            self.read()\n        }\n\n        pub fn $read_vec_name(&mut self, len: usize) -> Vec<$t> {\n            self.read_vec(len)\n        }\n    };\n\n    ($t: ty, $read_name: ident, $read_vec_name: ident, $read_pair_vec_name: ident) => {\n        read_impl!($t, $read_name, $read_vec_name);\n\n        pub fn $read_pair_vec_name(&mut self, len: usize) -> Vec<($t, $t)> {\n            self.read_vec(len)\n        }\n    };\n}\n\nimpl<'s> Input<'s> {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(input: &'s mut dyn Read) -> Self {\n        Self {\n            input,\n            buf: default_vec(Self::DEFAULT_BUF_SIZE),\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn new_with_size(input: &'s mut dyn Read, buf_size: usize) -> Self {\n        Self {\n            input,\n            buf: default_vec(buf_size),\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn get(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            self.at += 1;\n            if res == b'\\r' {\n                if self.refill_buffer() && self.buf[self.at] == b'\\n' {\n                    self.at += 1;\n                }\n                return Some(b'\\n');\n            }\n            Some(res)\n        } else {\n            None\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            Some(if res == b'\\r' { b'\\n' } else { res })\n        } else {\n            None\n        }\n    }\n\n    pub fn skip_whitespace(&mut self) {\n        while let Some(b) = self.peek() {\n            if !char::from(b).is_whitespace() {\n                return;\n            }\n            self.get();\n        }\n    }\n\n    pub fn next_token(&mut self) -> Option<Vec<u8>> {\n        self.skip_whitespace();\n        let mut res = Vec::new();\n        while let Some(c) = self.get() {\n            if char::from(c).is_whitespace() {\n                break;\n            }\n            res.push(c);\n        }\n        if res.is_empty() {\n            None\n        } else {\n            Some(res)\n        }\n    }\n\n    //noinspection RsSelfConvention\n    pub fn is_exhausted(&mut self) -> bool {\n        self.peek().is_none()\n    }\n\n    pub fn read<T: Readable>(&mut self) -> T {\n        T::read(self)\n    }\n\n    pub fn read_vec<T: Readable>(&mut self, size: usize) -> Vec<T> {\n        let mut res = Vec::with_capacity(size);\n        for _ in 0..size {\n            res.push(self.read());\n        }\n        res\n    }\n\n    pub fn read_char(&mut self) -> char {\n        self.skip_whitespace();\n        self.get().unwrap().into()\n    }\n\n    read_impl!(u32, read_unsigned, read_unsigned_vec);\n    read_impl!(u64, read_u64, read_u64_vec);\n    read_impl!(usize, read_size, read_size_vec, read_size_pair_vec);\n    read_impl!(i32, read_int, read_int_vec, read_int_pair_vec);\n    read_impl!(i64, read_long, read_long_vec, read_long_pair_vec);\n    read_impl!(i128, read_i128, read_i128_vec);\n\n    fn refill_buffer(&mut self) -> bool {\n        if self.at == self.buf_read {\n            self.at = 0;\n            self.buf_read = self.input.read(&mut self.buf).unwrap();\n            self.buf_read != 0\n        } else {\n            true\n        }\n    }\n}\n\npub trait Readable {\n    fn read(input: &mut Input) -> Self;\n}\n\nimpl Readable for char {\n    fn read(input: &mut Input) -> Self {\n        input.read_char()\n    }\n}\n\nimpl<T: Readable> Readable for Vec<T> {\n    fn read(input: &mut Input) -> Self {\n        let size = input.read();\n        input.read_vec(size)\n    }\n}\n\nmacro_rules! read_integer {\n    ($($t:ident)+) => {$(\n        impl Readable for $t {\n            fn read(input: &mut Input) -> Self {\n                input.skip_whitespace();\n                let mut c = input.get().unwrap();\n                let sgn = match c {\n                    b'-' => {\n                        c = input.get().unwrap();\n                        true\n                    }\n                    b'+' => {\n                        c = input.get().unwrap();\n                        false\n                    }\n                    _ => false,\n                };\n                let mut res = 0;\n                loop {\n                    assert!(c.is_ascii_digit());\n                    res *= 10;\n                    let d = (c - b'0') as $t;\n                    if sgn {\n                        res -= d;\n                    } else {\n                        res += d;\n                    }\n                    match input.get() {\n                        None => break,\n                        Some(ch) => {\n                            if ch.is_ascii_whitespace() {\n                                break;\n                            } else {\n                                c = ch;\n                            }\n                        }\n                    }\n                }\n                res\n            }\n        }\n    )+};\n}\n\nread_integer!(i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);\n\nmacro_rules! tuple_readable {\n    ($($name:ident)+) => {\n        impl<$($name: Readable), +> Readable for ($($name,)+) {\n            fn read(input: &mut Input) -> Self {\n                ($($name::read(input),)+)\n            }\n        }\n    }\n}\n\ntuple_readable! {T}\ntuple_readable! {T U}\ntuple_readable! {T U V}\ntuple_readable! {T U V X}\ntuple_readable! {T U V X Y}\ntuple_readable! {T U V X Y Z}\ntuple_readable! {T U V X Y Z A}\ntuple_readable! {T U V X Y Z A B}\ntuple_readable! {T U V X Y Z A B C}\ntuple_readable! {T U V X Y Z A B C D}\ntuple_readable! {T U V X Y Z A B C D E}\ntuple_readable! {T U V X Y Z A B C D E F}\n\nimpl Read for Input<'_> {\n    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {\n        if self.at == self.buf_read {\n            self.input.read(buf)\n        } else {\n            let mut i = 0;\n            while i < buf.len() && self.at < self.buf_read {\n                buf[i] = self.buf[self.at];\n                i += 1;\n                self.at += 1;\n            }\n            Ok(i)\n        }\n    }\n}\n}\npub mod output {\nuse crate::collections::vec_ext::default::default_vec;\nuse std::io::{stderr, Stderr, Write};\n\n#[derive(Copy, Clone)]\npub enum BoolOutput {\n    YesNo,\n    YesNoCaps,\n    PossibleImpossible,\n    Custom(&'static str, &'static str),\n}\n\nimpl BoolOutput {\n    pub fn output(&self, output: &mut Output, val: bool) {\n        (if val { self.yes() } else { self.no() }).write(output);\n    }\n\n    fn yes(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"Yes\",\n            BoolOutput::YesNoCaps => \"YES\",\n            BoolOutput::PossibleImpossible => \"Possible\",\n            BoolOutput::Custom(yes, _) => yes,\n        }\n    }\n\n    fn no(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"No\",\n            BoolOutput::YesNoCaps => \"NO\",\n            BoolOutput::PossibleImpossible => \"Impossible\",\n            BoolOutput::Custom(_, no) => no,\n        }\n    }\n}\n\npub struct Output<'s> {\n    output: &'s mut dyn Write,\n    buf: Vec<u8>,\n    at: usize,\n    auto_flush: bool,\n    bool_output: BoolOutput,\n}\n\nimpl<'s> Output<'s> {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(output: &'s mut dyn Write) -> Self {\n        Self {\n            output,\n            buf: default_vec(Self::DEFAULT_BUF_SIZE),\n            at: 0,\n            auto_flush: false,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn new_with_auto_flush(output: &'s mut dyn Write) -> Self {\n        Self {\n            output,\n            buf: default_vec(Self::DEFAULT_BUF_SIZE),\n            at: 0,\n            auto_flush: true,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn flush(&mut self) {\n        if self.at != 0 {\n            self.output.write_all(&self.buf[..self.at]).unwrap();\n            self.output.flush().unwrap();\n            self.at = 0;\n        }\n    }\n\n    pub fn print<T: Writable>(&mut self, s: T) {\n        s.write(self);\n        self.maybe_flush();\n    }\n\n    pub fn print_line<T: Writable>(&mut self, s: T) {\n        self.print(s);\n        self.put(b'\\n');\n        self.maybe_flush();\n    }\n\n    pub fn put(&mut self, b: u8) {\n        self.buf[self.at] = b;\n        self.at += 1;\n        if self.at == self.buf.len() {\n            self.flush();\n        }\n    }\n\n    pub fn maybe_flush(&mut self) {\n        if self.auto_flush {\n            self.flush();\n        }\n    }\n\n    pub fn print_per_line<T: Writable>(&mut self, arg: &[T]) {\n        for i in arg {\n            i.write(self);\n            self.put(b'\\n');\n        }\n    }\n\n    pub fn print_iter<T: Writable, I: Iterator<Item = T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n\n    pub fn print_iter_ref<'a, T: 'a + Writable, I: Iterator<Item = &'a T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n\n    pub fn set_bool_output(&mut self, bool_output: BoolOutput) {\n        self.bool_output = bool_output;\n    }\n}\n\nimpl Write for Output<'_> {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let mut start = 0usize;\n        let mut rem = buf.len();\n        while rem > 0 {\n            let len = (self.buf.len() - self.at).min(rem);\n            self.buf[self.at..self.at + len].copy_from_slice(&buf[start..start + len]);\n            self.at += len;\n            if self.at == self.buf.len() {\n                self.flush();\n            }\n            start += len;\n            rem -= len;\n        }\n        self.maybe_flush();\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.flush();\n        Ok(())\n    }\n}\n\npub trait Writable {\n    fn write(&self, output: &mut Output);\n}\n\nimpl Writable for &str {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for String {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for char {\n    fn write(&self, output: &mut Output) {\n        output.put(*self as u8);\n    }\n}\n\nimpl<T: Writable> Writable for [T] {\n    fn write(&self, output: &mut Output) {\n        output.print_iter_ref(self.iter());\n    }\n}\n\nimpl<T: Writable, const N: usize> Writable for [T; N] {\n    fn write(&self, output: &mut Output) {\n        output.print_iter_ref(self.iter());\n    }\n}\n\nimpl<T: Writable> Writable for &T {\n    fn write(&self, output: &mut Output) {\n        T::write(self, output)\n    }\n}\n\nimpl<T: Writable> Writable for Vec<T> {\n    fn write(&self, output: &mut Output) {\n        self.as_slice().write(output);\n    }\n}\n\nimpl Writable for () {\n    fn write(&self, _output: &mut Output) {}\n}\n\nmacro_rules! write_to_string {\n    ($($t:ident)+) => {$(\n        impl Writable for $t {\n            fn write(&self, output: &mut Output) {\n                self.to_string().write(output);\n            }\n        }\n    )+};\n}\n\nwrite_to_string!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n\nmacro_rules! tuple_writable {\n    ($name0:ident $($name:ident: $id:tt )*) => {\n        impl<$name0: Writable, $($name: Writable,)*> Writable for ($name0, $($name,)*) {\n            fn write(&self, out: &mut Output) {\n                self.0.write(out);\n                $(\n                out.put(b' ');\n                self.$id.write(out);\n                )*\n            }\n        }\n    }\n}\n\ntuple_writable! {T}\ntuple_writable! {T U:1}\ntuple_writable! {T U:1 V:2}\ntuple_writable! {T U:1 V:2 X:3}\ntuple_writable! {T U:1 V:2 X:3 Y:4}\ntuple_writable! {T U:1 V:2 X:3 Y:4 Z:5}\ntuple_writable! {T U:1 V:2 X:3 Y:4 Z:5 A:6}\ntuple_writable! {T U:1 V:2 X:3 Y:4 Z:5 A:6 B:7}\n\nimpl<T: Writable> Writable for Option<T> {\n    fn write(&self, output: &mut Output) {\n        match self {\n            None => (-1).write(output),\n            Some(t) => t.write(output),\n        }\n    }\n}\n\nimpl Writable for bool {\n    fn write(&self, output: &mut Output) {\n        let bool_output = output.bool_output;\n        bool_output.output(output, *self)\n    }\n}\n\nstatic mut ERR: Option<Stderr> = None;\npub fn err() -> Output<'static> {\n    unsafe {\n        if ERR.is_none() {\n            ERR = Some(stderr());\n        }\n        Output::new_with_auto_flush(ERR.as_mut().unwrap())\n    }\n}\n}\n}\nfn main() {\n    let mut sin = std::io::stdin();\n    let input = if false {\n        crate::io::input::Input::new_with_size(&mut sin, 1)\n    } else {\n        crate::io::input::Input::new(&mut sin)\n    };\n\n    let mut stdout = std::io::stdout();\n    let output = if false {\n        crate::io::output::Output::new_with_auto_flush(&mut stdout)\n    } else {\n        crate::io::output::Output::new(&mut stdout)\n    };\n\n    crate::solution::run(input, output);\n}\n\n"
}