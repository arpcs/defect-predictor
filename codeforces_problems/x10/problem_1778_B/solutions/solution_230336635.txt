{
    "id": 230336635,
    "contestId": 1778,
    "creationTimeSeconds": 1698568619,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1778,
        "index": "B",
        "name": "The Forbidden Permutation",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1300,
        "tags": [
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1778,
        "members": [
            {
                "handle": "At_Atharva"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1675262100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 15,
    "timeConsumedMillis": 327,
    "memoryConsumedBytes": 5836800,
    "source": "\r\n#include <bits/stdc++.h>\r\n\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\n\r\nusing namespace __gnu_pbds;\r\n\r\nusing ll = long long;\r\n\r\nusing ull = unsigned long long;\r\n\r\nconst ll mod = (998244353);\r\n\r\nconst int maxn = 2e5 + 3;\r\n\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\r\n\r\ntypedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\r\n\r\nll inv(ll i, ll modi)\r\n\r\n{\r\n\r\n    return i <= 1 ? i : modi - (long long)(modi / i) * inv(modi % i, modi) % modi;\r\n}\r\n\r\nlong long extendedGCD(long long a, long long b, long long &x, long long &y)\r\n{\r\n\r\n    if (b == 0)\r\n    {\r\n\r\n        x = 1;\r\n\r\n        y = 0;\r\n\r\n        return a;\r\n    }\r\n\r\n    long long x1, y1;\r\n\r\n    long long gcd = extendedGCD(b, a % b, x1, y1);\r\n\r\n    x = y1;\r\n\r\n    y = x1 - (a / b) * y1;\r\n\r\n    return gcd;\r\n}\r\n\r\nlong long findMultiplicativeInverse(long long a, long long m)\r\n{\r\n\r\n    long long x, y;\r\n\r\n    long long gcd = extendedGCD(a, m, x, y);\r\n\r\n    if (gcd != 1)\r\n    {\r\n\r\n        // std::cout << \"Multiplicative inverse does not exist.\" << endl;\r\n\r\n        return -1;\r\n    }\r\n\r\n    long long inverse = x % m;\r\n\r\n    if (inverse < 0)\r\n    {\r\n\r\n        inverse += m;\r\n    }\r\n\r\n    return inverse;\r\n}\r\n\r\nvector<ll> fastfactor(long long n)\r\n\r\n{\r\n\r\n    vector<long long> factorization;\r\n\r\n    for (long long d = 2; d * d <= n; d++)\r\n\r\n    {\r\n\r\n        while (n % d == 0)\r\n\r\n        {\r\n\r\n            factorization.push_back(d);\r\n\r\n            n /= d;\r\n        }\r\n    }\r\n\r\n    if (n > 1)\r\n\r\n    {\r\n\r\n        factorization.push_back(n);\r\n    }\r\n\r\n    return factorization;\r\n}\r\n\r\nvector<ll> minsieve(ll n)\r\n\r\n{\r\n\r\n    vector<ll> is_prime(n + 1, -1);\r\n\r\n    is_prime[0] = is_prime[1] = (-2);\r\n\r\n    for (ll i = 2; i <= n; i++)\r\n\r\n    {\r\n\r\n        if (is_prime[i] == (-1) && i * i <= n)\r\n\r\n        {\r\n\r\n            for (ll j = i * i; j <= n; j += i)\r\n\r\n                is_prime[j] = i;\r\n        }\r\n    }\r\n\r\n    return is_prime;\r\n}\r\n\r\nvector<bool> sieve(int n)\r\n\r\n{\r\n\r\n    vector<bool> is_prime(n + 1, true);\r\n\r\n    is_prime[0] = is_prime[1] = false;\r\n\r\n    for (int i = 2; i <= n; i++)\r\n\r\n    {\r\n\r\n        if (is_prime[i] && (long long)i * i <= n)\r\n\r\n        {\r\n\r\n            for (int j = i * i; j <= n; j += i)\r\n\r\n                is_prime[j] = false;\r\n        }\r\n    }\r\n\r\n    return is_prime;\r\n}\r\n\r\nlong long binpow(long long a, long long b, long long m)\r\n\r\n{\r\n\r\n    a %= m;\r\n\r\n    long long res = 1;\r\n\r\n    while (b > 0)\r\n\r\n    {\r\n\r\n        if (b & 1)\r\n\r\n            res = res * a % m;\r\n\r\n        a = a * a % m;\r\n\r\n        b >>= 1;\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\null sq(ull n)\r\n\r\n{\r\n\r\n    ull l = 0;\r\n\r\n    ull r = n;\r\n\r\n    ull ans = 0;\r\n\r\n    while (l <= r)\r\n\r\n    {\r\n\r\n        int mid = l + (r - l) / 2;\r\n\r\n        if ((1LL * mid * mid) == n)\r\n\r\n        {\r\n\r\n            return mid;\r\n        }\r\n\r\n        else if ((1LL * mid * mid) < n)\r\n\r\n        {\r\n\r\n            ans = mid;\r\n\r\n            l = mid + 1;\r\n        }\r\n\r\n        else\r\n\r\n        {\r\n\r\n            r = mid - 1;\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\nvector<ll> factmod(ll n, ll div)\r\n\r\n{\r\n\r\n    vector<ll> facts(n + 1, 0);\r\n\r\n    facts[0] = 1;\r\n\r\n    for (int i = 1; i <= n; i++)\r\n\r\n    {\r\n\r\n        facts[i] = ((facts[i - 1] % div) * (i % div)) % div;\r\n    }\r\n\r\n    return facts;\r\n}\r\n\r\nvector<bool> primes;\r\n\r\nvector<ll> primes1;\r\n\r\nvector<ll> factorials;\r\n\r\nvoid pre_process()\r\n\r\n{\r\n    // factorials=factmod(200009,998244353);\r\n    // // primes1 = minsieve(ll(1e7 + 10));\r\n    // vector<ll> p(1E5,0);\r\n    // for(ll i=2;i<=1E5;i++){\r\n    //     if(p[i]==0){\r\n    //         primes1.push_back(i);\r\n    //         p[i]=i;\r\n    //     }\r\n    //     for(auto it:primes1){\r\n    //         if(it*i>1E5) break;\r\n    //         p[it*i]=it;\r\n    //         if(p[i]==it) break;\r\n    //     }\r\n    // }\r\n}\r\n\r\nlong long binomial_coefficient(int n, int k)\r\n\r\n{\r\n\r\n    if (n < k || k < 0)\r\n\r\n    {\r\n\r\n        return 0;\r\n    }\r\n\r\n    return factorials[n] * inv(factorials[k] * factorials[n - k] % mod, mod) % mod;\r\n}\r\n\r\nll gcdModuloM(ll a, ll b, ll m)\r\n{\r\n    while (b != 0)\r\n    {\r\n        int temp = b;\r\n        b = a % b;\r\n        a = temp;\r\n    }\r\n    return a % m;\r\n}\r\nll realbin(ll k, ll n, ll m)\r\n{\r\n    if (n == 0)\r\n    {\r\n        return 1;\r\n    }\r\n    ll ans = 0;\r\n    if (n & 1)\r\n    {\r\n        ans = ((1 + k) * realbin((k * k) % m, (n - 1) / 2, m)) % m;\r\n    }\r\n    else\r\n    {\r\n        ans = (1 + ((k * realbin(k, n - 1, m)) % m)) % m;\r\n    }\r\n    return ans;\r\n}\r\nlong long bpow(long long a, long long b)\r\n{\r\n    if (b == 0)\r\n        return 1;\r\n    long long res = bpow(a, b / 2);\r\n    if (b % 2)\r\n        return res * res * a;\r\n    else\r\n        return res * res;\r\n}\r\nvoid build(vector<int> &arr, int v, int tl, int tr, vector<int> &tree)\r\n{\r\n    if (tl == tr)\r\n    {\r\n        tree[v] = arr[tl];\r\n    }\r\n    else\r\n    {\r\n        int tm = (tl + tr) / 2;\r\n        build(arr, v * 2, tl, tm, tree);\r\n        build(arr, v * 2 + 1, tm + 1, tr, tree);\r\n        tree[v] = (tree[v * 2] & tree[v * 2 + 1]);\r\n    }\r\n}\r\n\r\nint apply(int v, int tl, int tr, int l, int r, vector<int> &tree)\r\n{\r\n    if (l > r)\r\n    {\r\n        return 0;\r\n        std::cout << \"here\\n\";\r\n    }\r\n    if (l == tl && r == tr)\r\n    {\r\n        return tree[v];\r\n    }\r\n    int tm = (tl + tr) / 2;\r\n    return (apply(v * 2, tl, tm, l, min(r, tm), tree) & apply(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, tree));\r\n}\r\nvoid update(int v, int tl, int tr, int pos, int new_val, vector<int> &tree)\r\n{\r\n    if (tl == tr)\r\n    {\r\n        tree[v] = new_val;\r\n    }\r\n    else\r\n    {\r\n        int tm = (tl + tr) / 2;\r\n        if (pos <= tm)\r\n            update(v * 2, tl, tm, pos, new_val, tree);\r\n        else\r\n            update(v * 2 + 1, tm + 1, tr, pos, new_val, tree);\r\n        tree[v] = (tree[v * 2] & tree[v * 2 + 1]);\r\n    }\r\n}\r\n\r\nvoid solve(int &t)\r\n\r\n{\r\n          int n,m,d;\r\n          cin>>n>>m>>d;\r\n          vector<int> v(n), a(m);\r\n          map<int,int> mp;\r\n          for(int i=0;i<n;i++){\r\n            cin>>v[i];\r\n            mp[v[i]]=i;\r\n          }\r\n          for(int i=0;i<m;i++){\r\n            cin>>a[i];\r\n          }\r\n          int ans=INT_MAX;\r\n          for(int i=0;i<m-1;i++){\r\n            int first=mp[a[i]];\r\n            int second=mp[a[i+1]];\r\n            if(second<first || second-first>d){\r\n                ans=0;\r\n                break;\r\n            }\r\n            ans=min(ans,second-first);\r\n            int left=first-0;\r\n            int right=n-1-second;\r\n            if(d-(second-first)+1<=left+right){\r\n                ans=min(d-(second-first)+1,ans);\r\n            }\r\n            \r\n\r\n\r\n          }\r\n          cout<<ans<<\"\\n\";\r\n\r\n}\r\n\r\nint main()\r\n\r\n{\r\n\r\n    // freopen(\"input.txt\", \"r\", stdin);\r\n    // freopen(\"output.txt\", \"w\", stdout);\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n\r\n    pre_process();\r\n\r\n    int t;\r\n\r\n    cin >> t;\r\n\r\n    for (int i = 1; i <= t; i++)\r\n    {\r\n        solve(i);\r\n    }\r\n}"
}