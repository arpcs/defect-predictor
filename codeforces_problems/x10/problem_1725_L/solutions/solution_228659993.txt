{
    "id": 228659993,
    "contestId": 1725,
    "creationTimeSeconds": 1697624550,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1725,
        "index": "L",
        "name": "Lemper Cooking Competition",
        "type": "PROGRAMMING",
        "rating": 2400,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1725,
        "members": [
            {
                "handle": "ImmortaLimit"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662298500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 25,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 18841600,
    "source": "// LUOGU_RID: 130163685\n// #define ONLINE_JUDGE\r\n#include<bits/stdc++.h>\r\n#define REP(i,first,last) for(int i=(first);i<=(last);++i)\r\n#define DOW(i,first,last) for(int i=(first);(last)<=i;--i)\r\n#define LL long long\r\n#define UI unsigned int\r\n#define ULL unsigned long long\r\n#define PII pair<int,int>\r\n#define PIL pair<int,long long>\r\n#define PLI pair<long long,int>\r\n#define PLL pair<long long,long long>\r\n#define MPR(a,b) make_pair(a,b)\r\n#define CLEAN(a) memset(a,0,sizeof(a))\r\n#define COVER(a,v) memset(a,v,sizeof(a))\r\n#define SURVEILLANCE(type_name) IO::DeBugln(\"On line \",__LINE__,\" \"#type_name\"=\",type_name)\r\n#define GET_SIZE(type_name) IO::DeBugln(#type_name\"=\",sizeof(type_name)/1024.0/1024,\"MB\");\r\n#ifndef ONLINE_JUDGE\r\n#define GAP IO::DeBugln(\"Gap on line \",__LINE__);fwrite(pbuf,1,pp-pbuf,stdout);IO::pp=IO::pbuf;fclose(stdout);freopen(\"data.out\",\"w\",stdout);\r\n#define STOP IO::DeBugln(\"Stop on line \",__LINE__);fwrite(pbuf,1,pp-pbuf,stdout);fclose(stdout);exit(0);\r\n#else\r\n#define GAP\r\n#define STOP\r\n#endif\r\nconst int INF=1e9;\r\nconst LL INFL=1e18;\r\nnamespace IO\r\n{\r\n// #define GETCHAR_KEY\r\n// #define PUTCHAR_KEY\r\nconst int IN_BUF=1<<23,OUT_BUF=1<<23;\r\nint double_len(6);\r\nbool spacebar_can_see(1);\r\nconst char NUMBER_TO_CHAR[36]={48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90};\r\nconst int CHAR_TO_NUMBER[128]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0};\r\nchar buf[IN_BUF],*ps=buf,*pt=buf,pbuf[OUT_BUF],*pp=pbuf;\r\ntemplate<class T>class Number{public:unsigned int len;int hex;T number;inline Number(const T number=0,const int hex=10,const int len=0):number(number),hex(hex),len(len){}inline operator T()const{return number;}inline Number<T>& operator =(const T &a){number=a;return *this;}};\r\ninline bool CanSee(const char ch){return spacebar_can_see?(31<ch&&ch<127):(32<ch&&ch<127);}\r\ninline bool IsNumber(const char ch){return (47<ch&&ch<58);}\r\ninline bool IsNumber_(const int hex,const char ch){return (47<ch&&ch<48+hex)||(64<ch&&ch<55+hex)||(96<ch&&ch<87+hex);}\r\ninline char GetChar(){\r\n#ifdef GETCHAR_KEY\r\nreturn getchar();\r\n#endif\r\nif(ps==pt){ps=buf;pt=buf+fread(buf,1,IN_BUF,stdin);}return ps==pt?EOF:*ps++;}\r\ninline void PutChar(const char ch){\r\n#ifdef PUTCHAR_KEY\r\nputchar(ch);return;\r\n#endif\r\nif(pp==pbuf+OUT_BUF){fwrite(pbuf,1,OUT_BUF,stdout);pp=pbuf;}*pp++=ch;}\r\nchar read_ch(10);\r\ntemplate<class T>inline T ReadInt(){T x(0);bool f(1);while(!IsNumber(read_ch)&&(~read_ch)){if(read_ch==45){f=0;}read_ch=GetChar();}while(IsNumber(read_ch)&&(~read_ch)){x=(x<<1)+(x<<3)+(read_ch^48);read_ch=GetChar();}return f?x:-x;}\r\ntemplate<class T>inline T ReadUInt(){T x(0);while(!IsNumber(read_ch)&&(~read_ch)){read_ch=GetChar();}while(IsNumber(read_ch)&&(~read_ch)){x=(x<<1)+(x<<3)+(read_ch^48);read_ch=GetChar();}return x;}\r\ntemplate<class T>inline T ReadKInt(const int hex){T x(0);bool f(1);while(!IsNumber_(hex,read_ch)&&(~read_ch)){if(read_ch==45){f=0;}read_ch=GetChar();}while(IsNumber_(hex,read_ch)&&(~read_ch)){x=x*hex+CHAR_TO_NUMBER[read_ch];read_ch=GetChar();}return f?x:-x;}\r\ntemplate<class T>inline T ReadUKInt(const int hex){T x(0);while(!IsNumber_(hex,read_ch)&&(~read_ch)){read_ch=GetChar();}while(IsNumber_(hex,read_ch)&&(~read_ch)){x=x*hex+CHAR_TO_NUMBER[read_ch];read_ch=GetChar();}return x;}\r\ninline double ReadDouble(){long long int_num(ReadInt<long long>());if(read_ch==46){double pow10(1.0),result(0);read_ch=GetChar();while(IsNumber(read_ch)&&(~read_ch)){pow10/=10.0;result+=pow10*(read_ch^48);read_ch=GetChar();}return int_num+(int_num<0?-result:result);}else{return (double)int_num;}}\r\ninline void ReadT(int &x){x=ReadInt<int>();}\r\ninline void ReadT(long long &x){x=ReadInt<long long>();}\r\ninline void ReadT(bool &x){x=ReadUInt<bool>();}\r\ninline void ReadT(unsigned int &x){x=ReadUInt<unsigned int>();}\r\ninline void ReadT(unsigned long long &x){x=ReadUInt<unsigned long long>();}\r\ninline void ReadT(double &x){x=ReadDouble();}\r\ninline void ReadT(char &ch){for(;!CanSee(read_ch)&&(~read_ch);read_ch=GetChar()){};ch=read_ch;read_ch=10;}\r\ninline void ReadT(Number<int> &x){x.number=ReadKInt<int>(x.hex);}\r\ninline void ReadT(Number<long long> &x){x.number=ReadKInt<long long>(x.hex);}\r\ninline void ReadT(Number<unsigned int> &x){x.number=ReadUKInt<unsigned int>(x.hex);}\r\ninline void ReadT(Number<unsigned long long> &x){x.number=ReadUKInt<unsigned long long>(x.hex);}\r\ninline void ReadT(char *s){int len(0);for(;!CanSee(read_ch)&&(~read_ch);read_ch=GetChar()){};for(;CanSee(read_ch)&&(~read_ch);read_ch=GetChar()){s[len++]=read_ch;}s[len]=0;read_ch=10;}\r\ntemplate<class T>inline void Read(T &t){ReadT(t);}\r\ntemplate<class T,class ...Args>void Read(T &t,Args &...args){ReadT(t);Read(args...);}\r\ntemplate<class T>inline void WriteUInt(T x){static char out_number[65];static int cnt;out_number[cnt=1]=x%10^48;while(x/=10){out_number[++cnt]=x%10^48;}while(cnt){PutChar(out_number[cnt--]);}}\r\ntemplate<class T>inline void WriteInt(const T x){if(x<0){PutChar(45);WriteUInt(-x);return;}WriteUInt(x);}\r\ntemplate<class T>\r\ninline void WriteUKInt(T x,const int hex,int len){static char out_number[65];static int cnt;out_number[cnt=1]=NUMBER_TO_CHAR[x%hex];while(x/=hex){out_number[++cnt]=NUMBER_TO_CHAR[x%hex];}len-=cnt;while(0<len--){PutChar(48);}while(cnt){PutChar(out_number[cnt--]);}}\r\ntemplate<class T>inline void WriteKInt(const T x,const int hex,const int len){if(x<0){PutChar(45);WriteUKInt(-x,hex,len-1);return;}WriteUKInt(x,hex,len);}\r\ninline void WriteDouble(double x,int len){if(x<0){PutChar(45);x=-x;}WriteUInt<unsigned long long>((unsigned long long)x);if(len){x-=(int)x;PutChar(46);while(len--){x*=10;if(!(unsigned long long)x){PutChar(48);}}if((unsigned long long)x){WriteUInt<unsigned long long>((unsigned long long)x);}}}\r\ninline void WriteT(const int x){WriteInt<int>(x);}\r\ninline void WriteT(const long long x){WriteInt<long long>(x);}\r\ninline void WriteT(const bool x){PutChar(x|48);}\r\ninline void WriteT(const unsigned int x){WriteUInt<unsigned int>(x);}\r\ninline void WriteT(const unsigned long long x){WriteUInt<unsigned long long>(x);}\r\ninline void WriteT(const double x){WriteDouble(x,double_len);}\r\ninline void WriteT(const char *s){while(*s){PutChar(*s++);}}\r\ninline void WriteT(const char x){PutChar(x);}\r\ninline void WriteT(const Number<int> x){WriteKInt(x.number,x.hex,x.len);}\r\ninline void WriteT(const Number<long long> x){WriteKInt(x.number,x.hex,x.len);}\r\ninline void WriteT(const Number<unsigned int> x){WriteUKInt(x.number,x.hex,x.len);}\r\ninline void WriteT(const Number<unsigned long long> x){WriteUKInt(x.number,x.hex,x.len);}\r\ntemplate<class T>inline void Write(const T t){WriteT(t);}\r\ntemplate<class T,class ...Args>void Write(const T t,const Args ...args){WriteT(t);Write(args...);}\r\ninline void Writeln(){PutChar(10);}\r\ntemplate<class T>inline void Writeln(const T t){WriteT(t);PutChar(10);}\r\ntemplate<class ...Args>inline void Writeln(const Args ...args){Write(args...);PutChar(10);}\r\ntemplate<class ...Args>inline void WriteExit(const Args ...args){Write(args...);PutChar(10);exit(0);}\r\n#ifndef ONLINE_JUDGE\r\ntemplate<class ...Args>inline void DeBug(const Args ...args){Write(args...);}\r\ntemplate<class ...Args>inline void DeBugln(const Args ...args){Writeln(args...);}\r\ninline void DeBugln(){Writeln();}\r\n#else\r\ntemplate<class ...Args>inline void DeBug(const Args ...args){}\r\ntemplate<class ...Args>inline void DeBugln(const Args ...args){}\r\ninline void DeBugln(){}\r\n#endif\r\nclass CodeToDo{public:inline CodeToDo(){\r\n#ifndef ONLINE_JUDGE\r\nfreopen(\"data.in\",\"r\",stdin);freopen(\"data.out\",\"w\",stdout);\r\n#endif\r\nsrand(time(0));}\r\ninline ~CodeToDo(){\r\ndouble_len=3;DeBugln(\"\\nTime=\",(double)clock()/CLOCKS_PER_SEC,\"s\");\r\nfwrite(pbuf,1,pp-pbuf,stdout);\r\n#ifndef ONLINE_JUDGE\r\nfclose(stdin);fclose(stdout);\r\n#endif\r\n}}code_to_do;\r\n}\r\ntemplate<typename T>inline T Max(const T a,const T b){return a<b?b:a;}\r\ntemplate<typename T,typename ...Args>T Max(const T a,const Args ...args){return Max(a,Max(args...));}\r\ntemplate<typename T>inline T Min(const T a,const T b){return a<b?a:b;}\r\ntemplate<typename T,typename ...Args>T Min(const T a,const Args ...args){return Min(a,Min(args...));}\r\ntemplate<typename T>inline void Swap(T &a,T &b){T temp=a;a=b;b=temp;}\r\ntemplate<typename T>inline T Abs(const T a){return a<0?-a:a;}\r\nusing namespace IO;\r\nusing namespace std;\r\ntemplate<int SIZE,class T=int> class Discretization\r\n{\r\nprivate:\r\n\tT sor[SIZE];\r\n\tint cnt;\r\n\tint len;\r\npublic:\r\n\tinline Discretization()\r\n\t{\r\n\t\tlen=cnt=0;\r\n\t}\r\n\tinline void Push(const T num)\r\n\t{\r\n\t\tsor[cnt++]=num;\r\n\t}\r\n\tinline void operator +=(const T num)\r\n\t{\r\n\t\tsor[cnt++]=num;\r\n\t}\r\n\tinline void Calc()\r\n\t{\r\n\t\tstd::sort(sor,sor+cnt);\r\n\t\tlen=std::unique(sor,sor+cnt)-sor;\r\n\t}\r\n\tinline void operator ()()\r\n\t{\r\n\t\tstd::sort(sor,sor+cnt);\r\n\t\tlen=std::unique(sor,sor+cnt)-sor;\r\n\t}\r\n\tinline int operator [](const T num)const\r\n\t{\r\n\t\treturn std::lower_bound(sor,sor+len,num)-sor+1;\r\n\t}\r\n\tinline T operator ()(const int num)const\r\n\t{\r\n\t\treturn sor[num-1];\r\n\t}\r\n\tinline int Size()const\r\n\t{\r\n\t\treturn len;\r\n\t}\r\n\tinline void Clean()\r\n\t{\r\n\t\tcnt=0;\r\n\t}\r\n};\r\ntemplate<int SIZE> class BIT\r\n{\r\nprivate:\r\n\tint tree[SIZE];\r\n\tint n;\r\npublic:\r\n\tinline int Query(const int left,const int right)const\r\n\t{\r\n\t\tint result(0);\r\n\t\tfor(int now(right);now;now-=Lowbit(now))\r\n\t\t{\r\n\t\t\tresult+=tree[now];\r\n\t\t}\r\n\t\tfor(int now(left-1);now;now-=Lowbit(now))\r\n\t\t{\r\n\t\t\tresult-=tree[now];\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\tinline void Add(const int place,const int val)\r\n\t{\r\n\t\tfor(int now(place);now<n;now+=Lowbit(now))\r\n\t\t{\r\n\t\t\ttree[now]+=val;\r\n\t\t}\r\n\t}\r\nprivate:\r\n\tinline int Lowbit(const int now)const\r\n\t{\r\n\t\treturn now&-now;\r\n\t}\r\n\tclass Ref\r\n\t{\r\n\tprivate:\r\n\t\tint place;\r\n\t\tBIT *id;\r\n\tpublic:\r\n\t\tinline Ref(BIT *id,const int place):id(id),place(place)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\tinline int operator [](const int r)const\r\n\t\t{\r\n\t\t\treturn id->Query(place,r);\r\n\t\t}\r\n\t\tinline void operator +=(const int val)\r\n\t\t{\r\n\t\t\tid->Add(place,val);\r\n\t\t}\r\n\t};\r\npublic:\r\n\tinline BIT(const int n=0):n(n+1)\r\n\t{\r\n\r\n\t}\r\n\tinline void Init(const int m)\r\n\t{\r\n\t\tn=m+1;\r\n\t}\r\n\tinline Ref operator [](const int place)\r\n\t{\r\n\t\treturn Ref(this,place);\r\n\t}\r\n\tinline int operator ()(const int left,const int right)const\r\n\t{\r\n\t\treturn Query(left,right);\r\n\t}\r\n};\r\nconst int MAXN=1e5+5;\r\nBIT<MAXN>bit;\r\nDiscretization<MAXN,LL>d;\r\nint n;\r\nLL s[MAXN];\r\nint main()\r\n{\r\n\tRead(n);\r\n\tint a;\r\n\tLL min(INFL),max(0);\r\n\tREP(i,1,n)\r\n\t{\r\n\t\tRead(a);\r\n\t\tmin=Min(min,s[i]=s[i-1]+a);\r\n\t\tmax=Max(max,s[i]);\r\n\t\td+=s[i];\r\n\t}\r\n\tif(min<0||s[n]!=max)\r\n\t{\r\n\t\tWriteln(-1);\r\n\t\treturn 0;\r\n\t}\r\n\td.Calc();\r\n\tbit.Init(d.Size());\r\n\tLL answer=0;\r\n\tREP(i,1,n)\r\n\t{\r\n\t\ts[i]=d[s[i]];\r\n\t\tanswer+=bit(s[i]+1,d.Size());\r\n\t\tbit[s[i]]+=1;\r\n\t}\r\n\tWriteln(answer);\r\n\treturn 0;\r\n}"
}