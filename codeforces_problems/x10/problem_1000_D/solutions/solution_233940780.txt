{
    "id": 233940780,
    "contestId": 1000,
    "creationTimeSeconds": 1700755063,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1000,
        "index": "D",
        "name": "Yet Another Problem On a Subsequence",
        "type": "PROGRAMMING",
        "rating": 1900,
        "tags": [
            "combinatorics",
            "dp"
        ]
    },
    "author": {
        "contestId": 1000,
        "members": [
            {
                "handle": "joker_x"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1530110100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 22,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 4096000,
    "source": "#pragma GCC optimize(\"O3\")\r\n#pragma GCC optimize(2)\r\n#pragma GCC optimize(3)\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"inline\")\r\n#pragma GCC optimize(\"-fgcse\")\r\n#pragma GCC optimize(\"-fgcse-lm\")\r\n#pragma GCC optimize(\"-fipa-sra\")\r\n#pragma GCC optimize(\"-ftree-pre\")\r\n#pragma GCC optimize(\"-ftree-vrp\")\r\n#pragma GCC optimize(\"-fpeephole2\")\r\n#pragma GCC optimize(\"-ffast-math\")\r\n#pragma GCC optimize(\"-fsched-spec\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#pragma GCC optimize(\"-falign-jumps\")\r\n#pragma GCC optimize(\"-falign-loops\")\t\r\n#pragma GCC optimize(\"-falign-labels\")\r\n#pragma GCC optimize(\"-fdevirtualize\")\r\n#pragma GCC optimize(\"-fcaller-saves\")\r\n#pragma GCC optimize(\"-fcrossjumping\") \r\n#pragma GCC optimize(\"-fthread-jumps\")\r\n#pragma GCC optimize(\"-funroll-loops\")\r\n#pragma GCC optimize(\"-freorder-blocks\")\r\n#pragma GCC optimize(\"-fschedule-insns\")\r\n#pragma GCC optimize(\"inline-functions\")\r\n#pragma GCC optimize(\"-ftree-tail-merge\")\r\n#pragma GCC optimize(\"-fschedule-insns2\")\r\n#pragma GCC optimize(\"-fstrict-aliasing\")\r\n#pragma GCC optimize(\"-falign-functions\")\r\n#pragma GCC optimize(\"-fcse-follow-jumps\")\r\n#pragma GCC optimize(\"-fsched-interblock\")\r\n#pragma GCC optimize(\"-fpartial-inlining\")\r\n#pragma GCC optimize(\"no-stack-protector\")\r\n#pragma GCC optimize(\"-freorder-functions\")\r\n#pragma GCC optimize(\"-findirect-inlining\")\r\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\r\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\r\n#pragma GCC optimize(\"inline-small-functions\")\r\n#pragma GCC optimize(\"-finline-small-functions\")\r\n#pragma GCC optimize(\"-ftree-switch-conversion\")\r\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\r\n#pragma GCC optimize(\"-fexpensive-optimizations\")\r\n#pragma GCC optimize(\"inline-functions-called-once\")\r\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\r\n#pragma GCC optimize(\"Ofast\")\r\n \r\n#include <bits/stdc++.h>\r\n \r\nusing namespace std;\r\n \r\nnamespace atcoder {\r\n\r\nnamespace internal {\r\n\r\ntemplate <class T> struct simple_queue {\r\n    std::vector<T> payload;\r\n    int pos = 0;\r\n    void reserve(int n) { payload.reserve(n); }\r\n    int size() const { return int(payload.size()) - pos; }\r\n    bool empty() const { return pos == int(payload.size()); }\r\n    void push(const T& t) { payload.push_back(t); }\r\n    T& front() { return payload[pos]; }\r\n    void clear() {\r\n        payload.clear();\r\n        pos = 0;\r\n    }\r\n    void pop() { pos++; }\r\n};\r\n\r\n}  // namespace internal\r\n\r\n}  // namespace atcoder\r\n\r\n\r\nnamespace atcoder {\r\nnamespace internal {\r\n\r\ntemplate <class E> struct csr {\r\n    std::vector<int> start;\r\n    std::vector<E> elist;\r\n    explicit csr(int n, const std::vector<std::pair<int, E>>& edges)\r\n        : start(n + 1), elist(edges.size()) {\r\n        for (auto e : edges) {\r\n            start[e.first + 1]++;\r\n        }\r\n        for (int i = 1; i <= n; i++) {\r\n            start[i] += start[i - 1];\r\n        }\r\n        auto counter = start;\r\n        for (auto e : edges) {\r\n            elist[counter[e.first]++] = e.second;\r\n        }\r\n    }\r\n};\r\n\r\n}  // namespace internal\r\n\r\n}  // namespace atcoder\r\n\r\nnamespace atcoder {\r\n \r\nnamespace internal {\r\n \r\n// @param m `1 <= m`\r\n// @return x mod m\r\nconstexpr long long safe_mod(long long x, long long m) {\r\n    x %= m;\r\n    if (x < 0) x += m;\r\n    return x;\r\n}\r\n \r\n// Fast modular multiplication by barrett reduction\r\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\r\n// NOTE: reconsider after Ice Lake\r\nstruct barrett {\r\n    unsigned int _m;\r\n    unsigned long long im;\r\n \r\n    // @param m `1 <= m`\r\n    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\r\n \r\n    // @return m\r\n    unsigned int umod() const { return _m; }\r\n \r\n    // @param a `0 <= a < m`\r\n    // @param b `0 <= b < m`\r\n    // @return `a * b % m`\r\n    unsigned int mul(unsigned int a, unsigned int b) const {\r\n        // [1] m = 1\r\n        // a = b = im = 0, so okay\r\n \r\n        // [2] m >= 2\r\n        // im = ceil(2^64 / m)\r\n        // -> im * m = 2^64 + r (0 <= r < m)\r\n        // let z = a*b = c*m + d (0 <= c, d < m)\r\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\r\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\r\n        // ((ab * im) >> 64) == c or c + 1\r\n        unsigned long long z = a;\r\n        z *= b;\r\n#ifdef _MSC_VER\r\n        unsigned long long x;\r\n        _umul128(z, im, &x);\r\n#else\r\n        unsigned long long x =\r\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\r\n#endif\r\n        unsigned long long y = x * _m;\r\n        return (unsigned int)(z - y + (z < y ? _m : 0));\r\n    }\r\n};\r\n \r\n// @param n `0 <= n`\r\n// @param m `1 <= m`\r\n// @return `(x ** n) % m`\r\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\r\n    if (m == 1) return 0;\r\n    unsigned int _m = (unsigned int)(m);\r\n    unsigned long long r = 1;\r\n    unsigned long long y = safe_mod(x, m);\r\n    while (n) {\r\n        if (n & 1) r = (r * y) % _m;\r\n        y = (y * y) % _m;\r\n        n >>= 1;\r\n    }\r\n    return r;\r\n}\r\n \r\n// Reference:\r\n// M. Forisek and J. Jancina,\r\n// Fast Primality Testing for Integers That Fit into a Machine Word\r\n// @param n `0 <= n`\r\nconstexpr bool is_prime_constexpr(int n) {\r\n    if (n <= 1) return false;\r\n    if (n == 2 || n == 7 || n == 61) return true;\r\n    if (n % 2 == 0) return false;\r\n    long long d = n - 1;\r\n    while (d % 2 == 0) d /= 2;\r\n    constexpr long long bases[3] = {2, 7, 61};\r\n    for (long long a : bases) {\r\n        long long t = d;\r\n        long long y = pow_mod_constexpr(a, t, n);\r\n        while (t != n - 1 && y != 1 && y != n - 1) {\r\n            y = y * y % n;\r\n            t <<= 1;\r\n        }\r\n        if (y != n - 1 && t % 2 == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\r\n \r\n// @param b `1 <= b`\r\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\r\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\r\n    a = safe_mod(a, b);\r\n    if (a == 0) return {b, 0};\r\n \r\n    // Contracts:\r\n    // [1] s - m0 * a = 0 (mod b)\r\n    // [2] t - m1 * a = 0 (mod b)\r\n    // [3] s * |m1| + t * |m0| <= b\r\n    long long s = b, t = a;\r\n    long long m0 = 0, m1 = 1;\r\n \r\n    while (t) {\r\n        long long u = s / t;\r\n        s -= t * u;\r\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\r\n \r\n        // [3]:\r\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\r\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\r\n        // = s * |m1| + t * |m0| <= b\r\n \r\n        auto tmp = s;\r\n        s = t;\r\n        t = tmp;\r\n        tmp = m0;\r\n        m0 = m1;\r\n        m1 = tmp;\r\n    }\r\n    // by [3]: |m0| <= b/g\r\n    // by g != b: |m0| < b/g\r\n    if (m0 < 0) m0 += b / s;\r\n    return {s, m0};\r\n}\r\n \r\n// Compile time primitive root\r\n// @param m must be prime\r\n// @return primitive root (and minimum in now)\r\nconstexpr int primitive_root_constexpr(int m) {\r\n    if (m == 2) return 1;\r\n    if (m == 167772161) return 3;\r\n    if (m == 469762049) return 3;\r\n    if (m == 754974721) return 11;\r\n    if (m == 998244353) return 3;\r\n    int divs[20] = {};\r\n    divs[0] = 2;\r\n    int cnt = 1;\r\n    int x = (m - 1) / 2;\r\n    while (x % 2 == 0) x /= 2;\r\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\r\n        if (x % i == 0) {\r\n            divs[cnt++] = i;\r\n            while (x % i == 0) {\r\n                x /= i;\r\n            }\r\n        }\r\n    }\r\n    if (x > 1) {\r\n        divs[cnt++] = x;\r\n    }\r\n    for (int g = 2;; g++) {\r\n        bool ok = true;\r\n        for (int i = 0; i < cnt; i++) {\r\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\r\n                ok = false;\r\n                break;\r\n            }\r\n        }\r\n        if (ok) return g;\r\n    }\r\n}\r\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\r\n \r\n// @param n `n < 2^32`\r\n// @param m `1 <= m < 2^32`\r\n// @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)\r\nunsigned long long floor_sum_unsigned(unsigned long long n,\r\n                                      unsigned long long m,\r\n                                      unsigned long long a,\r\n                                      unsigned long long b) {\r\n    unsigned long long ans = 0;\r\n    while (true) {\r\n        if (a >= m) {\r\n            ans += n * (n - 1) / 2 * (a / m);\r\n            a %= m;\r\n        }\r\n        if (b >= m) {\r\n            ans += n * (b / m);\r\n            b %= m;\r\n        }\r\n \r\n        unsigned long long y_max = a * n + b;\r\n        if (y_max < m) break;\r\n        // y_max < m * (n + 1)\r\n        // floor(y_max / m) <= n\r\n        n = (unsigned long long)(y_max / m);\r\n        b = (unsigned long long)(y_max % m);\r\n        std::swap(m, a);\r\n    }\r\n    return ans;\r\n}\r\n \r\n}  // namespace internal\r\n \r\n}  // namespace atcoder\r\n \r\n \r\nnamespace atcoder {\r\n \r\nnamespace internal {\r\n \r\n#ifndef _MSC_VER\r\ntemplate <class T>\r\nusing is_signed_int128 =\r\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\r\n                                  std::is_same<T, __int128>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int128 =\r\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\r\n                                  std::is_same<T, unsigned __int128>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing make_unsigned_int128 =\r\n    typename std::conditional<std::is_same<T, __int128_t>::value,\r\n                              __uint128_t,\r\n                              unsigned __int128>;\r\n \r\ntemplate <class T>\r\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\r\n                                                  is_signed_int128<T>::value ||\r\n                                                  is_unsigned_int128<T>::value,\r\n                                              std::true_type,\r\n                                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\r\n                                                 std::is_signed<T>::value) ||\r\n                                                    is_signed_int128<T>::value,\r\n                                                std::true_type,\r\n                                                std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int =\r\n    typename std::conditional<(is_integral<T>::value &&\r\n                               std::is_unsigned<T>::value) ||\r\n                                  is_unsigned_int128<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing to_unsigned = typename std::conditional<\r\n    is_signed_int128<T>::value,\r\n    make_unsigned_int128<T>,\r\n    typename std::conditional<std::is_signed<T>::value,\r\n                              std::make_unsigned<T>,\r\n                              std::common_type<T>>::type>::type;\r\n \r\n#else\r\n \r\ntemplate <class T> using is_integral = typename std::is_integral<T>;\r\n \r\ntemplate <class T>\r\nusing is_signed_int =\r\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int =\r\n    typename std::conditional<is_integral<T>::value &&\r\n                                  std::is_unsigned<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\r\n                                              std::make_unsigned<T>,\r\n                                              std::common_type<T>>::type;\r\n \r\n#endif\r\n \r\ntemplate <class T>\r\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\r\n \r\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\r\n \r\n}  // namespace internal\r\n \r\n}  // namespace atcoder\r\n \r\nnamespace atcoder {\r\n \r\nnamespace internal {\r\n \r\nstruct modint_base {};\r\nstruct static_modint_base : modint_base {};\r\n \r\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\r\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\r\n \r\n}  // namespace internal\r\n \r\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\r\nstruct static_modint : internal::static_modint_base {\r\n    using mint = static_modint;\r\n \r\n  public:\r\n    static constexpr int mod() { return m; }\r\n    static mint raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\n \r\n    static_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\r\n    static_modint(T v) {\r\n        long long x = (long long)(v % (long long)(umod()));\r\n        if (x < 0) x += umod();\r\n        _v = (unsigned int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\r\n    static_modint(T v) {\r\n        _v = (unsigned int)(v % umod());\r\n    }\r\n \r\n    unsigned int val() const { return _v; }\r\n \r\n    mint& operator++() {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n        _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n        --*this;\r\n        return result;\r\n    }\r\n \r\n    mint& operator+=(const mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n        _v -= rhs._v;\r\n        if (_v >= umod()) _v += umod();\r\n        return *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n        unsigned long long z = _v;\r\n        z *= rhs._v;\r\n        _v = (unsigned int)(z % umod());\r\n        return *this;\r\n    }\r\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\r\n \r\n    mint operator+() const { return *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n \r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n    mint inv() const {\r\n        if (prime) {\r\n            assert(_v);\r\n            return pow(umod() - 2);\r\n        } else {\r\n            auto eg = internal::inv_gcd(_v, m);\r\n            assert(eg.first == 1);\r\n            return eg.second;\r\n        }\r\n    }\r\n \r\n    friend mint operator+(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool operator==(const mint& lhs, const mint& rhs) {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\n \r\n  private:\r\n    unsigned int _v;\r\n    static constexpr unsigned int umod() { return m; }\r\n    static constexpr bool prime = internal::is_prime<m>;\r\n};\r\n \r\ntemplate <int id> struct dynamic_modint : internal::modint_base {\r\n    using mint = dynamic_modint;\r\n \r\n  public:\r\n    static int mod() { return (int)(bt.umod()); }\r\n    static void set_mod(int m) {\r\n        assert(1 <= m);\r\n        bt = internal::barrett(m);\r\n    }\r\n    static mint raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\n \r\n    dynamic_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\r\n    dynamic_modint(T v) {\r\n        long long x = (long long)(v % (long long)(mod()));\r\n        if (x < 0) x += mod();\r\n        _v = (unsigned int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\r\n    dynamic_modint(T v) {\r\n        _v = (unsigned int)(v % mod());\r\n    }\r\n \r\n    unsigned int val() const { return _v; }\r\n \r\n    mint& operator++() {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n        _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n        --*this;\r\n        return result;\r\n    }\r\n \r\n    mint& operator+=(const mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n        _v += mod() - rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n        _v = bt.mul(_v, rhs._v);\r\n        return *this;\r\n    }\r\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\r\n \r\n    mint operator+() const { return *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n \r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n    mint inv() const {\r\n        auto eg = internal::inv_gcd(_v, mod());\r\n        assert(eg.first == 1);\r\n        return eg.second;\r\n    }\r\n \r\n    friend mint operator+(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool operator==(const mint& lhs, const mint& rhs) {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\n \r\n  private:\r\n    unsigned int _v;\r\n    static internal::barrett bt;\r\n    static unsigned int umod() { return bt.umod(); }\r\n};\r\ntemplate <int id> internal::barrett dynamic_modint<id>::bt(998244353);\r\n \r\nusing modint998244353 = static_modint<998244353>;\r\nusing modint1000000007 = static_modint<1000000007>;\r\nusing modint = dynamic_modint<-1>;\r\n \r\nnamespace internal {\r\n \r\ntemplate <class T>\r\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\r\n \r\ntemplate <class T>\r\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\r\n \r\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\r\ntemplate <int id>\r\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\r\n \r\ntemplate <class T>\r\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\r\n \r\n}  // namespace internal\r\n \r\n}  // namespace atcoder\r\n \r\nnamespace atcoder {\r\n \r\nnamespace internal {\r\n \r\n// @return same with std::bit::bit_ceil\r\nunsigned int bit_ceil(unsigned int n) {\r\n    unsigned int x = 1;\r\n    while (x < (unsigned int)(n)) x *= 2;\r\n    return x;\r\n}\r\n \r\n// @param n `1 <= n`\r\n// @return same with std::bit::countr_zero\r\nint countr_zero(unsigned int n) {\r\n#ifdef _MSC_VER\r\n    unsigned long index;\r\n    _BitScanForward(&index, n);\r\n    return index;\r\n#else\r\n    return __builtin_ctz(n);\r\n#endif\r\n}\r\n \r\n// @param n `1 <= n`\r\n// @return same with std::bit::countr_zero\r\nconstexpr int countr_zero_constexpr(unsigned int n) {\r\n    int x = 0;\r\n    while (!(n & (1 << x))) x++;\r\n    return x;\r\n}\r\n \r\n}  // namespace internal\r\n \r\n}  // namespace atcoder\r\n \r\n \r\nnamespace atcoder {\r\n \r\nnamespace internal {\r\n \r\n#ifndef _MSC_VER\r\ntemplate <class T>\r\nusing is_signed_int128 =\r\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\r\n                                  std::is_same<T, __int128>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int128 =\r\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\r\n                                  std::is_same<T, unsigned __int128>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing make_unsigned_int128 =\r\n    typename std::conditional<std::is_same<T, __int128_t>::value,\r\n                              __uint128_t,\r\n                              unsigned __int128>;\r\n \r\ntemplate <class T>\r\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\r\n                                                  is_signed_int128<T>::value ||\r\n                                                  is_unsigned_int128<T>::value,\r\n                                              std::true_type,\r\n                                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\r\n                                                 std::is_signed<T>::value) ||\r\n                                                    is_signed_int128<T>::value,\r\n                                                std::true_type,\r\n                                                std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int =\r\n    typename std::conditional<(is_integral<T>::value &&\r\n                               std::is_unsigned<T>::value) ||\r\n                                  is_unsigned_int128<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing to_unsigned = typename std::conditional<\r\n    is_signed_int128<T>::value,\r\n    make_unsigned_int128<T>,\r\n    typename std::conditional<std::is_signed<T>::value,\r\n                              std::make_unsigned<T>,\r\n                              std::common_type<T>>::type>::type;\r\n \r\n#else\r\n \r\ntemplate <class T> using is_integral = typename std::is_integral<T>;\r\n \r\ntemplate <class T>\r\nusing is_signed_int =\r\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int =\r\n    typename std::conditional<is_integral<T>::value &&\r\n                                  std::is_unsigned<T>::value,\r\n                              std::true_type,\r\n                              std::false_type>::type;\r\n \r\ntemplate <class T>\r\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\r\n                                              std::make_unsigned<T>,\r\n                                              std::common_type<T>>::type;\r\n \r\n#endif\r\n \r\ntemplate <class T>\r\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\r\n \r\ntemplate <class T>\r\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\r\n \r\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\r\n \r\n}  // namespace internal\r\n \r\n}  // namespace atcoder\r\n \r\n \r\nnamespace atcoder {\r\n \r\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\r\ntemplate <class T> struct fenwick_tree {\r\n    using U = internal::to_unsigned_t<T>;\r\n \r\n  public:\r\n    fenwick_tree() : _n(0) {}\r\n    explicit fenwick_tree(int n) : _n(n), data(n) {}\r\n \r\n    void add(int p, T x) {\r\n        assert(0 <= p && p < _n);\r\n        p++;\r\n        while (p <= _n) {\r\n            data[p - 1] += U(x);\r\n            p += p & -p;\r\n        }\r\n    }\r\n \r\n    T sum(int l, int r) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        return sum(r) - sum(l);\r\n    }\r\n \r\n  private:\r\n    int _n;\r\n    std::vector<U> data;\r\n \r\n    U sum(int r) {\r\n        U s = 0;\r\n        while (r > 0) {\r\n            s += data[r - 1];\r\n            r -= r & -r;\r\n        }\r\n        return s;\r\n    }\r\n};\r\n \r\n}  // namespace atcoder\r\n \r\n \r\nnamespace atcoder {\r\n \r\n#if __cplusplus >= 201703L\r\n \r\ntemplate <class S, auto op, auto e> struct segtree {\r\n    static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\r\n                  \"op must work as S(S, S)\");\r\n    static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\r\n                  \"e must work as S()\");\r\n \r\n#else\r\n \r\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\r\n \r\n#endif\r\n \r\n  public:\r\n    segtree() : segtree(0) {}\r\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\r\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\r\n        size = (int)internal::bit_ceil((unsigned int)(_n));\r\n        log = internal::countr_zero((unsigned int)size);\r\n        d = std::vector<S>(2 * size, e());\r\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\r\n        for (int i = size - 1; i >= 1; i--) {\r\n            update(i);\r\n        }\r\n    }\r\n    \r\n    void clear_and_update(const std::vector<S>& v)\r\n    {\r\n        _n = (int)v.size();\r\n         size = (int)internal::bit_ceil((unsigned int)(_n));\r\n        log = internal::countr_zero((unsigned int)size);\r\n        d = std::vector<S>(2 * size, e());\r\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\r\n        for (int i = size - 1; i >= 1; i--) {\r\n            update(i);\r\n        }       \r\n    }\r\n \r\n    void set(int p, S x) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        d[p] = x;\r\n        for (int i = 1; i <= log; i++) update(p >> i);\r\n    }\r\n \r\n    S get(int p) const {\r\n        assert(0 <= p && p < _n);\r\n        return d[p + size];\r\n    }\r\n \r\n    S prod(int l, int r) const {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        S sml = e(), smr = e();\r\n        l += size;\r\n        r += size;\r\n \r\n        while (l < r) {\r\n            if (l & 1) sml = op(sml, d[l++]);\r\n            if (r & 1) smr = op(d[--r], smr);\r\n            l >>= 1;\r\n            r >>= 1;\r\n        }\r\n        return op(sml, smr);\r\n    }\r\n \r\n    S all_prod() const { return d[1]; }\r\n \r\n    template <bool (*f)(S)> int max_right(int l) const {\r\n        return max_right(l, [](S x) { return f(x); });\r\n    }\r\n    template <class F> int max_right(int l, F f) const {\r\n        assert(0 <= l && l <= _n);\r\n        assert(f(e()));\r\n        if (l == _n) return _n;\r\n        l += size;\r\n        S sm = e();\r\n        do {\r\n            while (l % 2 == 0) l >>= 1;\r\n            if (!f(op(sm, d[l]))) {\r\n                while (l < size) {\r\n                    l = (2 * l);\r\n                    if (f(op(sm, d[l]))) {\r\n                        sm = op(sm, d[l]);\r\n                        l++;\r\n                    }\r\n                }\r\n                return l - size;\r\n            }\r\n            sm = op(sm, d[l]);\r\n            l++;\r\n        } while ((l & -l) != l);\r\n        return _n;\r\n    }\r\n \r\n    template <bool (*f)(S)> int min_left(int r) const {\r\n        return min_left(r, [](S x) { return f(x); });\r\n    }\r\n    template <class F> int min_left(int r, F f) const {\r\n        assert(0 <= r && r <= _n);\r\n        assert(f(e()));\r\n        if (r == 0) return 0;\r\n        r += size;\r\n        S sm = e();\r\n        do {\r\n            r--;\r\n            while (r > 1 && (r % 2)) r >>= 1;\r\n            if (!f(op(d[r], sm))) {\r\n                while (r < size) {\r\n                    r = (2 * r + 1);\r\n                    if (f(op(d[r], sm))) {\r\n                        sm = op(d[r], sm);\r\n                        r--;\r\n                    }\r\n                }\r\n                return r + 1 - size;\r\n            }\r\n            sm = op(d[r], sm);\r\n        } while ((r & -r) != r);\r\n        return 0;\r\n    }\r\n \r\n  private:\r\n    int _n, size, log;\r\n    std::vector<S> d;\r\n \r\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\r\n};\r\n \r\n}  // namespace atcoder\r\n \r\n \r\nnamespace atcoder {\r\n \r\n#if __cplusplus >= 201703L\r\n \r\ntemplate <class S,\r\n          auto op,\r\n          auto e,\r\n          class F,\r\n          auto mapping,\r\n          auto composition,\r\n          auto id>\r\nstruct lazy_segtree {\r\n    static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\r\n                  \"op must work as S(S, S)\");\r\n    static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\r\n                  \"e must work as S()\");\r\n    static_assert(\r\n        std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,\r\n        \"mapping must work as F(F, S)\");\r\n    static_assert(\r\n        std::is_convertible_v<decltype(composition), std::function<F(F, F)>>,\r\n        \"compostiion must work as F(F, F)\");\r\n    static_assert(std::is_convertible_v<decltype(id), std::function<F()>>,\r\n                  \"id must work as F()\");\r\n \r\n#else\r\n \r\ntemplate <class S,\r\n          S (*op)(S, S),\r\n          S (*e)(),\r\n          class F,\r\n          S (*mapping)(F, S),\r\n          F (*composition)(F, F),\r\n          F (*id)()>\r\nstruct lazy_segtree {\r\n \r\n#endif\r\n \r\n  public:\r\n    lazy_segtree() : lazy_segtree(0) {}\r\n    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\r\n    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\r\n        size = (int)internal::bit_ceil((unsigned int)(_n));\r\n        log = internal::countr_zero((unsigned int)size);\r\n        d = std::vector<S>(2 * size, e());\r\n        lz = std::vector<F>(size, id());\r\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\r\n        for (int i = size - 1; i >= 1; i--) {\r\n            update(i);\r\n        }\r\n    }\r\n \r\n    void set(int p, S x) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        for (int i = log; i >= 1; i--) push(p >> i);\r\n        d[p] = x;\r\n        for (int i = 1; i <= log; i++) update(p >> i);\r\n    }\r\n \r\n    S get(int p) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        for (int i = log; i >= 1; i--) push(p >> i);\r\n        return d[p];\r\n    }\r\n \r\n    S prod(int l, int r) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        if (l == r) return e();\r\n \r\n        l += size;\r\n        r += size;\r\n \r\n        for (int i = log; i >= 1; i--) {\r\n            if (((l >> i) << i) != l) push(l >> i);\r\n            if (((r >> i) << i) != r) push((r - 1) >> i);\r\n        }\r\n \r\n        S sml = e(), smr = e();\r\n        while (l < r) {\r\n            if (l & 1) sml = op(sml, d[l++]);\r\n            if (r & 1) smr = op(d[--r], smr);\r\n            l >>= 1;\r\n            r >>= 1;\r\n        }\r\n \r\n        return op(sml, smr);\r\n    }\r\n \r\n    S all_prod() { return d[1]; }\r\n \r\n    void apply(int p, F f) {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        for (int i = log; i >= 1; i--) push(p >> i);\r\n        d[p] = mapping(f, d[p]);\r\n        for (int i = 1; i <= log; i++) update(p >> i);\r\n    }\r\n    void apply(int l, int r, F f) {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        if (l == r) return;\r\n \r\n        l += size;\r\n        r += size;\r\n \r\n        for (int i = log; i >= 1; i--) {\r\n            if (((l >> i) << i) != l) push(l >> i);\r\n            if (((r >> i) << i) != r) push((r - 1) >> i);\r\n        }\r\n \r\n        {\r\n            int l2 = l, r2 = r;\r\n            while (l < r) {\r\n                if (l & 1) all_apply(l++, f);\r\n                if (r & 1) all_apply(--r, f);\r\n                l >>= 1;\r\n                r >>= 1;\r\n            }\r\n            l = l2;\r\n            r = r2;\r\n        }\r\n \r\n        for (int i = 1; i <= log; i++) {\r\n            if (((l >> i) << i) != l) update(l >> i);\r\n            if (((r >> i) << i) != r) update((r - 1) >> i);\r\n        }\r\n    }\r\n \r\n    template <bool (*g)(S)> int max_right(int l) {\r\n        return max_right(l, [](S x) { return g(x); });\r\n    }\r\n    template <class G> int max_right(int l, G g) {\r\n        assert(0 <= l && l <= _n);\r\n        assert(g(e()));\r\n        if (l == _n) return _n;\r\n        l += size;\r\n        for (int i = log; i >= 1; i--) push(l >> i);\r\n        S sm = e();\r\n        do {\r\n            while (l % 2 == 0) l >>= 1;\r\n            if (!g(op(sm, d[l]))) {\r\n                while (l < size) {\r\n                    push(l);\r\n                    l = (2 * l);\r\n                    if (g(op(sm, d[l]))) {\r\n                        sm = op(sm, d[l]);\r\n                        l++;\r\n                    }\r\n                }\r\n                return l - size;\r\n            }\r\n            sm = op(sm, d[l]);\r\n            l++;\r\n        } while ((l & -l) != l);\r\n        return _n;\r\n    }\r\n \r\n    template <bool (*g)(S)> int min_left(int r) {\r\n        return min_left(r, [](S x) { return g(x); });\r\n    }\r\n    template <class G> int min_left(int r, G g) {\r\n        assert(0 <= r && r <= _n);\r\n        assert(g(e()));\r\n        if (r == 0) return 0;\r\n        r += size;\r\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\r\n        S sm = e();\r\n        do {\r\n            r--;\r\n            while (r > 1 && (r % 2)) r >>= 1;\r\n            if (!g(op(d[r], sm))) {\r\n                while (r < size) {\r\n                    push(r);\r\n                    r = (2 * r + 1);\r\n                    if (g(op(d[r], sm))) {\r\n                        sm = op(d[r], sm);\r\n                        r--;\r\n                    }\r\n                }\r\n                return r + 1 - size;\r\n            }\r\n            sm = op(d[r], sm);\r\n        } while ((r & -r) != r);\r\n        return 0;\r\n    }\r\n \r\n  private:\r\n    int _n, size, log;\r\n    std::vector<S> d;\r\n    std::vector<F> lz;\r\n \r\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\r\n    void all_apply(int k, F f) {\r\n        d[k] = mapping(f, d[k]);\r\n        if (k < size) lz[k] = composition(f, lz[k]);\r\n    }\r\n    void push(int k) {\r\n        all_apply(2 * k, lz[k]);\r\n        all_apply(2 * k + 1, lz[k]);\r\n        lz[k] = id();\r\n    }\r\n};\r\n \r\n}  // namespace atcoder\r\n \r\n \r\nnamespace atcoder {\r\n \r\nnamespace internal {\r\n \r\ntemplate <class mint,\r\n          int g = internal::primitive_root<mint::mod()>,\r\n          internal::is_static_modint_t<mint>* = nullptr>\r\nstruct fft_info {\r\n    static constexpr int rank2 = countr_zero_constexpr(mint::mod() - 1);\r\n    std::array<mint, rank2 + 1> root;   // root[i]^(2^i) == 1\r\n    std::array<mint, rank2 + 1> iroot;  // root[i] * iroot[i] == 1\r\n \r\n    std::array<mint, std::max(0, rank2 - 2 + 1)> rate2;\r\n    std::array<mint, std::max(0, rank2 - 2 + 1)> irate2;\r\n \r\n    std::array<mint, std::max(0, rank2 - 3 + 1)> rate3;\r\n    std::array<mint, std::max(0, rank2 - 3 + 1)> irate3;\r\n \r\n    fft_info() {\r\n        root[rank2] = mint(g).pow((mint::mod() - 1) >> rank2);\r\n        iroot[rank2] = root[rank2].inv();\r\n        for (int i = rank2 - 1; i >= 0; i--) {\r\n            root[i] = root[i + 1] * root[i + 1];\r\n            iroot[i] = iroot[i + 1] * iroot[i + 1];\r\n        }\r\n \r\n        {\r\n            mint prod = 1, iprod = 1;\r\n            for (int i = 0; i <= rank2 - 2; i++) {\r\n                rate2[i] = root[i + 2] * prod;\r\n                irate2[i] = iroot[i + 2] * iprod;\r\n                prod *= iroot[i + 2];\r\n                iprod *= root[i + 2];\r\n            }\r\n        }\r\n        {\r\n            mint prod = 1, iprod = 1;\r\n            for (int i = 0; i <= rank2 - 3; i++) {\r\n                rate3[i] = root[i + 3] * prod;\r\n                irate3[i] = iroot[i + 3] * iprod;\r\n                prod *= iroot[i + 3];\r\n                iprod *= root[i + 3];\r\n            }\r\n        }\r\n    }\r\n};\r\n \r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nvoid butterfly(std::vector<mint>& a) {\r\n    int n = int(a.size());\r\n    int h = internal::countr_zero((unsigned int)n);\r\n \r\n    static const fft_info<mint> info;\r\n \r\n    int len = 0;  // a[i, i+(n>>len), i+2*(n>>len), ..] is transformed\r\n    while (len < h) {\r\n        if (h - len == 1) {\r\n            int p = 1 << (h - len - 1);\r\n            mint rot = 1;\r\n            for (int s = 0; s < (1 << len); s++) {\r\n                int offset = s << (h - len);\r\n                for (int i = 0; i < p; i++) {\r\n                    auto l = a[i + offset];\r\n                    auto r = a[i + offset + p] * rot;\r\n                    a[i + offset] = l + r;\r\n                    a[i + offset + p] = l - r;\r\n                }\r\n                if (s + 1 != (1 << len))\r\n                    rot *= info.rate2[countr_zero(~(unsigned int)(s))];\r\n            }\r\n            len++;\r\n        } else {\r\n            // 4-base\r\n            int p = 1 << (h - len - 2);\r\n            mint rot = 1, imag = info.root[2];\r\n            for (int s = 0; s < (1 << len); s++) {\r\n                mint rot2 = rot * rot;\r\n                mint rot3 = rot2 * rot;\r\n                int offset = s << (h - len);\r\n                for (int i = 0; i < p; i++) {\r\n                    auto mod2 = 1ULL * mint::mod() * mint::mod();\r\n                    auto a0 = 1ULL * a[i + offset].val();\r\n                    auto a1 = 1ULL * a[i + offset + p].val() * rot.val();\r\n                    auto a2 = 1ULL * a[i + offset + 2 * p].val() * rot2.val();\r\n                    auto a3 = 1ULL * a[i + offset + 3 * p].val() * rot3.val();\r\n                    auto a1na3imag =\r\n                        1ULL * mint(a1 + mod2 - a3).val() * imag.val();\r\n                    auto na2 = mod2 - a2;\r\n                    a[i + offset] = a0 + a2 + a1 + a3;\r\n                    a[i + offset + 1 * p] = a0 + a2 + (2 * mod2 - (a1 + a3));\r\n                    a[i + offset + 2 * p] = a0 + na2 + a1na3imag;\r\n                    a[i + offset + 3 * p] = a0 + na2 + (mod2 - a1na3imag);\r\n                }\r\n                if (s + 1 != (1 << len))\r\n                    rot *= info.rate3[countr_zero(~(unsigned int)(s))];\r\n            }\r\n            len += 2;\r\n        }\r\n    }\r\n}\r\n \r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nvoid butterfly_inv(std::vector<mint>& a) {\r\n    int n = int(a.size());\r\n    int h = internal::countr_zero((unsigned int)n);\r\n \r\n    static const fft_info<mint> info;\r\n \r\n    int len = h;  // a[i, i+(n>>len), i+2*(n>>len), ..] is transformed\r\n    while (len) {\r\n        if (len == 1) {\r\n            int p = 1 << (h - len);\r\n            mint irot = 1;\r\n            for (int s = 0; s < (1 << (len - 1)); s++) {\r\n                int offset = s << (h - len + 1);\r\n                for (int i = 0; i < p; i++) {\r\n                    auto l = a[i + offset];\r\n                    auto r = a[i + offset + p];\r\n                    a[i + offset] = l + r;\r\n                    a[i + offset + p] =\r\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\r\n                        irot.val();\r\n                    ;\r\n                }\r\n                if (s + 1 != (1 << (len - 1)))\r\n                    irot *= info.irate2[countr_zero(~(unsigned int)(s))];\r\n            }\r\n            len--;\r\n        } else {\r\n            // 4-base\r\n            int p = 1 << (h - len);\r\n            mint irot = 1, iimag = info.iroot[2];\r\n            for (int s = 0; s < (1 << (len - 2)); s++) {\r\n                mint irot2 = irot * irot;\r\n                mint irot3 = irot2 * irot;\r\n                int offset = s << (h - len + 2);\r\n                for (int i = 0; i < p; i++) {\r\n                    auto a0 = 1ULL * a[i + offset + 0 * p].val();\r\n                    auto a1 = 1ULL * a[i + offset + 1 * p].val();\r\n                    auto a2 = 1ULL * a[i + offset + 2 * p].val();\r\n                    auto a3 = 1ULL * a[i + offset + 3 * p].val();\r\n \r\n                    auto a2na3iimag =\r\n                        1ULL *\r\n                        mint((mint::mod() + a2 - a3) * iimag.val()).val();\r\n \r\n                    a[i + offset] = a0 + a1 + a2 + a3;\r\n                    a[i + offset + 1 * p] =\r\n                        (a0 + (mint::mod() - a1) + a2na3iimag) * irot.val();\r\n                    a[i + offset + 2 * p] =\r\n                        (a0 + a1 + (mint::mod() - a2) + (mint::mod() - a3)) *\r\n                        irot2.val();\r\n                    a[i + offset + 3 * p] =\r\n                        (a0 + (mint::mod() - a1) + (mint::mod() - a2na3iimag)) *\r\n                        irot3.val();\r\n                }\r\n                if (s + 1 != (1 << (len - 2)))\r\n                    irot *= info.irate3[countr_zero(~(unsigned int)(s))];\r\n            }\r\n            len -= 2;\r\n        }\r\n    }\r\n}\r\n \r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nstd::vector<mint> convolution_naive(const std::vector<mint>& a,\r\n                                    const std::vector<mint>& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    std::vector<mint> ans(n + m - 1);\r\n    if (n < m) {\r\n        for (int j = 0; j < m; j++) {\r\n            for (int i = 0; i < n; i++) {\r\n                ans[i + j] += a[i] * b[j];\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                ans[i + j] += a[i] * b[j];\r\n            }\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n \r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nstd::vector<mint> convolution_fft(std::vector<mint> a, std::vector<mint> b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\r\n    a.resize(z);\r\n    internal::butterfly(a);\r\n    b.resize(z);\r\n    internal::butterfly(b);\r\n    for (int i = 0; i < z; i++) {\r\n        a[i] *= b[i];\r\n    }\r\n    internal::butterfly_inv(a);\r\n    a.resize(n + m - 1);\r\n    mint iz = mint(z).inv();\r\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\r\n    return a;\r\n}\r\n \r\n}  // namespace internal\r\n \r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nstd::vector<mint> convolution(std::vector<mint>&& a, std::vector<mint>&& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n \r\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\r\n    assert((mint::mod() - 1) % z == 0);\r\n \r\n    if (std::min(n, m) <= 60) return convolution_naive(a, b);\r\n    return internal::convolution_fft(a, b);\r\n}\r\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\r\nstd::vector<mint> convolution(const std::vector<mint>& a,\r\n                              const std::vector<mint>& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n \r\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\r\n    assert((mint::mod() - 1) % z == 0);\r\n \r\n    if (std::min(n, m) <= 60) return convolution_naive(a, b);\r\n    return internal::convolution_fft(a, b);\r\n}\r\n \r\ntemplate <unsigned int mod = 998244353,\r\n          class T,\r\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\r\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n \r\n    using mint = static_modint<mod>;\r\n \r\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\r\n    assert((mint::mod() - 1) % z == 0);\r\n \r\n    std::vector<mint> a2(n), b2(m);\r\n    for (int i = 0; i < n; i++) {\r\n        a2[i] = mint(a[i]);\r\n    }\r\n    for (int i = 0; i < m; i++) {\r\n        b2[i] = mint(b[i]);\r\n    }\r\n    auto c2 = convolution(std::move(a2), std::move(b2));\r\n    std::vector<T> c(n + m - 1);\r\n    for (int i = 0; i < n + m - 1; i++) {\r\n        c[i] = c2[i].val();\r\n    }\r\n    return c;\r\n}\r\n \r\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\r\n                                      const std::vector<long long>& b) {\r\n    int n = int(a.size()), m = int(b.size());\r\n    if (!n || !m) return {};\r\n \r\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\r\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\r\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\r\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\r\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\r\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\r\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\r\n \r\n    static constexpr unsigned long long i1 =\r\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\r\n    static constexpr unsigned long long i2 =\r\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\r\n    static constexpr unsigned long long i3 =\r\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\r\n        \r\n    static constexpr int MAX_AB_BIT = 24;\r\n    static_assert(MOD1 % (1ull << MAX_AB_BIT) == 1, \"MOD1 isn't enough to support an array length of 2^24.\");\r\n    static_assert(MOD2 % (1ull << MAX_AB_BIT) == 1, \"MOD2 isn't enough to support an array length of 2^24.\");\r\n    static_assert(MOD3 % (1ull << MAX_AB_BIT) == 1, \"MOD3 isn't enough to support an array length of 2^24.\");\r\n    assert(n + m - 1 <= (1 << MAX_AB_BIT));\r\n \r\n    auto c1 = convolution<MOD1>(a, b);\r\n    auto c2 = convolution<MOD2>(a, b);\r\n    auto c3 = convolution<MOD3>(a, b);\r\n \r\n    std::vector<long long> c(n + m - 1);\r\n    for (int i = 0; i < n + m - 1; i++) {\r\n        unsigned long long x = 0;\r\n        x += (c1[i] * i1) % MOD1 * M2M3;\r\n        x += (c2[i] * i2) % MOD2 * M1M3;\r\n        x += (c3[i] * i3) % MOD3 * M1M2;\r\n        // B = 2^63, -B <= x, r(real value) < B\r\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\r\n        // r = c1[i] (mod MOD1)\r\n        // focus on MOD1\r\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\r\n        // r = x,\r\n        //     x - M' + (0 or 2B),\r\n        //     x - 2M' + (0, 2B or 4B),\r\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\r\n        // (r - x) = 0, (0)\r\n        //           - M' + (0 or 2B), (1)\r\n        //           -2M' + (0 or 2B or 4B), (2)\r\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\r\n        // we checked that\r\n        //   ((1) mod MOD1) mod 5 = 2\r\n        //   ((2) mod MOD1) mod 5 = 3\r\n        //   ((3) mod MOD1) mod 5 = 4\r\n        long long diff =\r\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\r\n        if (diff < 0) diff += MOD1;\r\n        static constexpr unsigned long long offset[5] = {\r\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\r\n        x -= offset[diff % 5];\r\n        c[i] = x;\r\n    }\r\n \r\n    return c;\r\n}\r\n \r\n}  // namespace atcoder\r\n \r\n\r\nnamespace atcoder {\r\n\r\ntemplate <class Cap> struct mf_graph {\r\n  public:\r\n    mf_graph() : _n(0) {}\r\n    explicit mf_graph(int n) : _n(n), g(n) {}\r\n\r\n    int add_edge(int from, int to, Cap cap) {\r\n        assert(0 <= from && from < _n);\r\n        assert(0 <= to && to < _n);\r\n        assert(0 <= cap);\r\n        int m = int(pos.size());\r\n        pos.push_back({from, int(g[from].size())});\r\n        int from_id = int(g[from].size());\r\n        int to_id = int(g[to].size());\r\n        if (from == to) to_id++;\r\n        g[from].push_back(_edge{to, to_id, cap});\r\n        g[to].push_back(_edge{from, from_id, 0});\r\n        return m;\r\n    }\r\n\r\n    struct edge {\r\n        int from, to;\r\n        Cap cap, flow;\r\n    };\r\n\r\n    edge get_edge(int i) {\r\n        int m = int(pos.size());\r\n        assert(0 <= i && i < m);\r\n        auto _e = g[pos[i].first][pos[i].second];\r\n        auto _re = g[_e.to][_e.rev];\r\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\r\n    }\r\n    std::vector<edge> edges() {\r\n        int m = int(pos.size());\r\n        std::vector<edge> result;\r\n        for (int i = 0; i < m; i++) {\r\n            result.push_back(get_edge(i));\r\n        }\r\n        return result;\r\n    }\r\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\r\n        int m = int(pos.size());\r\n        assert(0 <= i && i < m);\r\n        assert(0 <= new_flow && new_flow <= new_cap);\r\n        auto& _e = g[pos[i].first][pos[i].second];\r\n        auto& _re = g[_e.to][_e.rev];\r\n        _e.cap = new_cap - new_flow;\r\n        _re.cap = new_flow;\r\n    }\r\n\r\n    Cap flow(int s, int t) {\r\n        return flow(s, t, std::numeric_limits<Cap>::max());\r\n    }\r\n    Cap flow(int s, int t, Cap flow_limit) {\r\n        assert(0 <= s && s < _n);\r\n        assert(0 <= t && t < _n);\r\n        assert(s != t);\r\n\r\n        std::vector<int> level(_n), iter(_n);\r\n        internal::simple_queue<int> que;\r\n\r\n        auto bfs = [&]() {\r\n            std::fill(level.begin(), level.end(), -1);\r\n            level[s] = 0;\r\n            que.clear();\r\n            que.push(s);\r\n            while (!que.empty()) {\r\n                int v = que.front();\r\n                que.pop();\r\n                for (auto e : g[v]) {\r\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\r\n                    level[e.to] = level[v] + 1;\r\n                    if (e.to == t) return;\r\n                    que.push(e.to);\r\n                }\r\n            }\r\n        };\r\n        auto dfs = [&](auto self, int v, Cap up) {\r\n            if (v == s) return up;\r\n            Cap res = 0;\r\n            int level_v = level[v];\r\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\r\n                _edge& e = g[v][i];\r\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\r\n                Cap d =\r\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\r\n                if (d <= 0) continue;\r\n                g[v][i].cap += d;\r\n                g[e.to][e.rev].cap -= d;\r\n                res += d;\r\n                if (res == up) return res;\r\n            }\r\n            level[v] = _n;\r\n            return res;\r\n        };\r\n\r\n        Cap flow = 0;\r\n        while (flow < flow_limit) {\r\n            bfs();\r\n            if (level[t] == -1) break;\r\n            std::fill(iter.begin(), iter.end(), 0);\r\n            Cap f = dfs(dfs, t, flow_limit - flow);\r\n            if (!f) break;\r\n            flow += f;\r\n        }\r\n        return flow;\r\n    }\r\n\r\n    std::vector<bool> min_cut(int s) {\r\n        std::vector<bool> visited(_n);\r\n        internal::simple_queue<int> que;\r\n        que.push(s);\r\n        while (!que.empty()) {\r\n            int p = que.front();\r\n            que.pop();\r\n            visited[p] = true;\r\n            for (auto e : g[p]) {\r\n                if (e.cap && !visited[e.to]) {\r\n                    visited[e.to] = true;\r\n                    que.push(e.to);\r\n                }\r\n            }\r\n        }\r\n        return visited;\r\n    }\r\n\r\n  private:\r\n    int _n;\r\n    struct _edge {\r\n        int to, rev;\r\n        Cap cap;\r\n    };\r\n    std::vector<std::pair<int, int>> pos;\r\n    std::vector<std::vector<_edge>> g;\r\n};\r\n\r\n}  // namespace atcoder\r\n\r\n\r\nnamespace atcoder {\r\n\r\ntemplate <class Cap, class Cost> struct mcf_graph {\r\n  public:\r\n    mcf_graph() {}\r\n    explicit mcf_graph(int n) : _n(n) {}\r\n\r\n    int add_edge(int from, int to, Cap cap, Cost cost) {\r\n        assert(0 <= from && from < _n);\r\n        assert(0 <= to && to < _n);\r\n        assert(0 <= cap);\r\n        assert(0 <= cost);\r\n        int m = int(_edges.size());\r\n        _edges.push_back({from, to, cap, 0, cost});\r\n        return m;\r\n    }\r\n\r\n    struct edge {\r\n        int from, to;\r\n        Cap cap, flow;\r\n        Cost cost;\r\n    };\r\n\r\n    edge get_edge(int i) {\r\n        int m = int(_edges.size());\r\n        assert(0 <= i && i < m);\r\n        return _edges[i];\r\n    }\r\n    std::vector<edge> edges() { return _edges; }\r\n\r\n    std::pair<Cap, Cost> flow(int s, int t) {\r\n        return flow(s, t, std::numeric_limits<Cap>::max());\r\n    }\r\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\r\n        return slope(s, t, flow_limit).back();\r\n    }\r\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\r\n        return slope(s, t, std::numeric_limits<Cap>::max());\r\n    }\r\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\r\n        assert(0 <= s && s < _n);\r\n        assert(0 <= t && t < _n);\r\n        assert(s != t);\r\n\r\n        int m = int(_edges.size());\r\n        std::vector<int> edge_idx(m);\r\n\r\n        auto g = [&]() {\r\n            std::vector<int> degree(_n), redge_idx(m);\r\n            std::vector<std::pair<int, _edge>> elist;\r\n            elist.reserve(2 * m);\r\n            for (int i = 0; i < m; i++) {\r\n                auto e = _edges[i];\r\n                edge_idx[i] = degree[e.from]++;\r\n                redge_idx[i] = degree[e.to]++;\r\n                elist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});\r\n                elist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});\r\n            }\r\n            auto _g = internal::csr<_edge>(_n, elist);\r\n            for (int i = 0; i < m; i++) {\r\n                auto e = _edges[i];\r\n                edge_idx[i] += _g.start[e.from];\r\n                redge_idx[i] += _g.start[e.to];\r\n                _g.elist[edge_idx[i]].rev = redge_idx[i];\r\n                _g.elist[redge_idx[i]].rev = edge_idx[i];\r\n            }\r\n            return _g;\r\n        }();\r\n\r\n        auto result = slope(g, s, t, flow_limit);\r\n\r\n        for (int i = 0; i < m; i++) {\r\n            auto e = g.elist[edge_idx[i]];\r\n            _edges[i].flow = _edges[i].cap - e.cap;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n  private:\r\n    int _n;\r\n    std::vector<edge> _edges;\r\n\r\n    // inside edge\r\n    struct _edge {\r\n        int to, rev;\r\n        Cap cap;\r\n        Cost cost;\r\n    };\r\n\r\n    std::vector<std::pair<Cap, Cost>> slope(internal::csr<_edge>& g,\r\n                                            int s,\r\n                                            int t,\r\n                                            Cap flow_limit) {\r\n        // variants (C = maxcost):\r\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\r\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\r\n\r\n        // dual_dist[i] = (dual[i], dist[i])\r\n        std::vector<std::pair<Cost, Cost>> dual_dist(_n);\r\n        std::vector<int> prev_e(_n);\r\n        std::vector<bool> vis(_n);\r\n        struct Q {\r\n            Cost key;\r\n            int to;\r\n            bool operator<(Q r) const { return key > r.key; }\r\n        };\r\n        std::vector<int> que_min;\r\n        std::vector<Q> que;\r\n        auto dual_ref = [&]() {\r\n            for (int i = 0; i < _n; i++) {\r\n                dual_dist[i].second = std::numeric_limits<Cost>::max();\r\n            }\r\n            std::fill(vis.begin(), vis.end(), false);\r\n            que_min.clear();\r\n            que.clear();\r\n\r\n            // que[0..heap_r) was heapified\r\n            size_t heap_r = 0;\r\n\r\n            dual_dist[s].second = 0;\r\n            que_min.push_back(s);\r\n            while (!que_min.empty() || !que.empty()) {\r\n                int v;\r\n                if (!que_min.empty()) {\r\n                    v = que_min.back();\r\n                    que_min.pop_back();\r\n                } else {\r\n                    while (heap_r < que.size()) {\r\n                        heap_r++;\r\n                        std::push_heap(que.begin(), que.begin() + heap_r);\r\n                    }\r\n                    v = que.front().to;\r\n                    std::pop_heap(que.begin(), que.end());\r\n                    que.pop_back();\r\n                    heap_r--;\r\n                }\r\n                if (vis[v]) continue;\r\n                vis[v] = true;\r\n                if (v == t) break;\r\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\r\n                // dist[v] >= 0 (all reduced cost are positive)\r\n                // dist[v] <= (n-1)C\r\n                Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;\r\n                for (int i = g.start[v]; i < g.start[v + 1]; i++) {\r\n                    auto e = g.elist[i];\r\n                    if (!e.cap) continue;\r\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\r\n                    // cost <= C - -(n-1)C + 0 = nC\r\n                    Cost cost = e.cost - dual_dist[e.to].first + dual_v;\r\n                    if (dual_dist[e.to].second - dist_v > cost) {\r\n                        Cost dist_to = dist_v + cost;\r\n                        dual_dist[e.to].second = dist_to;\r\n                        prev_e[e.to] = e.rev;\r\n                        if (dist_to == dist_v) {\r\n                            que_min.push_back(e.to);\r\n                        } else {\r\n                            que.push_back(Q{dist_to, e.to});\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!vis[t]) {\r\n                return false;\r\n            }\r\n\r\n            for (int v = 0; v < _n; v++) {\r\n                if (!vis[v]) continue;\r\n                // dual[v] = dual[v] - dist[t] + dist[v]\r\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) +\r\n                //         (shortest(s, v) + dual[s] - dual[v]) = - shortest(s,\r\n                //         t) + dual[t] + shortest(s, v) = shortest(s, v) -\r\n                //         shortest(s, t) >= 0 - (n-1)C\r\n                dual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;\r\n            }\r\n            return true;\r\n        };\r\n        Cap flow = 0;\r\n        Cost cost = 0, prev_cost_per_flow = -1;\r\n        std::vector<std::pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};\r\n        while (flow < flow_limit) {\r\n            if (!dual_ref()) break;\r\n            Cap c = flow_limit - flow;\r\n            for (int v = t; v != s; v = g.elist[prev_e[v]].to) {\r\n                c = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);\r\n            }\r\n            for (int v = t; v != s; v = g.elist[prev_e[v]].to) {\r\n                auto& e = g.elist[prev_e[v]];\r\n                e.cap += c;\r\n                g.elist[e.rev].cap -= c;\r\n            }\r\n            Cost d = -dual_dist[s].first;\r\n            flow += c;\r\n            cost += c * d;\r\n            if (prev_cost_per_flow == d) {\r\n                result.pop_back();\r\n            }\r\n            result.push_back({flow, cost});\r\n            prev_cost_per_flow = d;\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\n}  // namespace atcoder\r\n\r\n\r\nnamespace atcoder {\r\n\r\n// Implement (union by size) + (path compression)\r\n// Reference:\r\n// Zvi Galil and Giuseppe F. Italiano,\r\n// Data structures and algorithms for disjoint set union problems\r\nstruct dsu {\r\n  public:\r\n    dsu() : _n(0) {}\r\n    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}\r\n\r\n    int merge(int a, int b) {\r\n        assert(0 <= a && a < _n);\r\n        assert(0 <= b && b < _n);\r\n        int x = leader(a), y = leader(b);\r\n        if (x == y) return x;\r\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\r\n        parent_or_size[x] += parent_or_size[y];\r\n        parent_or_size[y] = x;\r\n        return x;\r\n    }\r\n\r\n    bool same(int a, int b) {\r\n        assert(0 <= a && a < _n);\r\n        assert(0 <= b && b < _n);\r\n        return leader(a) == leader(b);\r\n    }\r\n\r\n    int leader(int a) {\r\n        assert(0 <= a && a < _n);\r\n        if (parent_or_size[a] < 0) return a;\r\n        return parent_or_size[a] = leader(parent_or_size[a]);\r\n    }\r\n\r\n    int size(int a) {\r\n        assert(0 <= a && a < _n);\r\n        return -parent_or_size[leader(a)];\r\n    }\r\n\r\n    std::vector<std::vector<int>> groups() {\r\n        std::vector<int> leader_buf(_n), group_size(_n);\r\n        for (int i = 0; i < _n; i++) {\r\n            leader_buf[i] = leader(i);\r\n            group_size[leader_buf[i]]++;\r\n        }\r\n        std::vector<std::vector<int>> result(_n);\r\n        for (int i = 0; i < _n; i++) {\r\n            result[i].reserve(group_size[i]);\r\n        }\r\n        for (int i = 0; i < _n; i++) {\r\n            result[leader_buf[i]].push_back(i);\r\n        }\r\n        result.erase(\r\n            std::remove_if(result.begin(), result.end(),\r\n                           [&](const std::vector<int>& v) { return v.empty(); }),\r\n            result.end());\r\n        return result;\r\n    }\r\n\r\n  private:\r\n    int _n;\r\n    // root node: -1 * component size\r\n    // otherwise: parent\r\n    std::vector<int> parent_or_size;\r\n};\r\n\r\n}  // namespace atcoder\r\n\r\nusing namespace atcoder;\r\n \r\nusing modint998244353 = static_modint<998244353>;\r\nusing modint1000000007 = static_modint<1000000007>;\r\nusing mint = modint998244353;\r\n\r\n/*\r\nusing S = long long;\r\nusing F = long long;\r\n\r\nconst S INF = 8e18;\r\n\r\nS op(S a, S b){ return std::max(a, b); }\r\nS e(){ return 0; }\r\nS mapping(F f, S x){ return f+x; }\r\nF composition(F f, F g){ return f+g; }\r\nF id(){ return 0; }\r\n*/\r\n\r\nmint dp[1005];\r\nmint C[1005][1005];\r\nint n,t;\r\nvector <int> v;\r\nint main(void)\r\n{\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(false);\r\n\r\n    cin >> n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin >> t;\r\n        v.push_back(t);\r\n    }\r\n\r\n    C[0][0] = 1;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        C[i][0] = 1;\r\n        C[i][i] = 1;\r\n        for(int j=1;j<i;j++)\r\n        {\r\n            C[i][j] = C[i-1][j-1] + C[i-1][j];\r\n        }\r\n    }\r\n\r\n    dp[0] = 1;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        dp[i+1] += dp[i];\r\n        for(int j=i;j<n;j++)\r\n        {\r\n            int len = j-i-1;\r\n            if(len >= v[i]-1 && v[i] > 0)\r\n            {\r\n                dp[j+1] += (C[len][v[i]-1]*dp[i]);\r\n            }\r\n        }\r\n    }\r\n    dp[n]-=1;\r\n    cout << dp[n].val() << '\\n';\r\n\r\n\treturn 0;       \r\n}"
}