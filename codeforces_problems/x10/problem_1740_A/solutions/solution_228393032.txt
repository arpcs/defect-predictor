{
    "id": 228393032,
    "contestId": 1740,
    "creationTimeSeconds": 1697448661,
    "relativeTimeSeconds": 61,
    "problem": {
        "contestId": 1740,
        "index": "A",
        "name": "Factorise N+M",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "constructive algorithms",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1740,
        "members": [
            {
                "handle": "tatata96"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1697448600
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// #define ATCODER_MODINT\r\n// #include \"atcoder/convolution\"\r\n// #include \"atcoder/dsu\"\r\n// #include \"atcoder/fenwicktree\"\r\n// #include \"atcoder/lazysegtree\"\r\n// #include \"atcoder/math\"\r\n// #include \"atcoder/maxflow\"\r\n// #include \"atcoder/mincostflow\"\r\n// #include \"atcoder/scc\"\r\n// #include \"atcoder/segtree\"\r\n// #include \"atcoder/string\"\r\n// #include \"atcoder/twosat\"\r\n\r\n#ifdef ATCODER_MODINT\r\n#include <atcoder/modint>\r\n#endif\r\n\r\nnamespace atcoder {}\r\nusing namespace atcoder;\r\n\r\n#define int long long\r\n// #define endl \"\\n\"\r\n\r\n#pragma GCC optimize(\"-O3\")\r\n\r\nvoid solve();\r\n\r\ntypedef long long ll;\r\ntypedef __int128_t LL;\r\ntypedef unsigned long long ull;\r\ntypedef double db;\r\ntypedef long double ld;\r\ntypedef pair<int, int> pi;\r\ntypedef pair<int, pair<int, int>> pip;\r\ntypedef vector<int> vi;\r\ntypedef vector<double> vd;\r\ntypedef vector<bool> vb;\r\ntypedef vector<string> vs;\r\ntypedef vector<char> vc;\r\ntypedef vector<pair<int, int>> vp;\r\ntypedef vector<vector<int>> vvi;\r\ntypedef vector<vector<double>> vvd;\r\ntypedef vector<vector<bool>> vvb;\r\ntypedef vector<vector<string>> vvs;\r\ntypedef vector<vector<char>> vvc;\r\ntypedef vector<vector<pair<int, int>>> vvp;\r\ntypedef vector<vector<vector<int>>> vvvi;\r\ntypedef vector<vector<vector<vector<int>>>> vvvvi;\r\ntemplate <typename T>\r\nusing vec = vector<T>;\r\ntemplate <typename T>\r\nusing vv = vector<vector<T>>;\r\ntemplate <typename T>\r\nusing vvv = vector<vector<vector<T>>>;\r\ntemplate <typename T>\r\nusing vvvv = vector<vector<vector<vector<T>>>>;\r\ntemplate <typename T>\r\nusing pq = priority_queue<T>;\r\ntemplate <typename T>\r\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate <typename T>\r\nusing mset = multiset<T>;\r\ntemplate <typename T>\r\nusing uset = unordered_set<T>;\r\ntemplate <typename T, typename U>\r\nusing umap = unordered_map<T, U>;\r\n\r\n#define _PI 3.14159265358979323846\r\n#define _E 2.7182818284590452354\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define bg begin()\r\n#define ed end()\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define td typedef\r\n#define elif else if\r\n#define ifnot(x) if (!(x))\r\n#define si(x) (int)((x).size())\r\n#define all(obj) (obj).begin(), (obj).end()\r\n#define rall(obj) (obj).rbegin(), (obj).rend()\r\n#define sumv(a) accumulate(all(a), 0LL)\r\n#define lb(v, a) (lower_bound(begin(v), end(v), a) - begin(v))\r\n#define ub(v, a) (upper_bound(begin(v), end(v), a) - begin(v))\r\n#define inr(l, x, r) (l <= x && x < r)\r\n#define cbit(x) __builtin_popcountll(x)\r\n#define tbit(t) (t == 0 ? -1 : 63 - __builtin_clzll(t))\r\n#define bbit(t) (t == 0 ? 64 : __builtin_ctzll(t))\r\n#define gb(msk, i) ((msk) >> (i)&1)\r\n#define mask(x) ((1LL << (x)) - 1)\r\n#define setbits(i, n) \\\r\n    for (int j = (n), i = botbit(j); j; j ^= 1LL << i, i = botbit(j))\r\n\r\n#define rep1(a)                                                   \\\r\n    for (int NEVER_USE_VARIABLE = 0; NEVER_USE_VARIABLE < (int)a; \\\r\n         NEVER_USE_VARIABLE++)\r\n#define rep2(i, a) for (int i = 0; i < (int)a; i++)\r\n#define rep3(i, a, b) for (int i = a; i < (int)b; i++)\r\n#define rep4(i, a, b, c) for (int i = a; i < (int)b; i += c)\r\n#define overload4(a, b, c, d, e, ...) e\r\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\r\n#define rrep1(n) for (ll NEVER_USE_VARIABLE = n; NEVER_USE_VARIABLE--;)\r\n#define rrep2(i, n) for (ll i = n; i--;)\r\n#define rrep3(i, a, b) for (ll i = b; i-- > (a);)\r\n#define rrep4(i, a, b, c) \\\r\n    for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i >= (a); i -= c)\r\n#define rrep(...) \\\r\n    overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\r\n#define fore1(i, a) for (auto &&i : a)\r\n#define fore2(x, y, a) for (auto &&[x, y] : a)\r\n#define fore3(x, y, z, a) for (auto &&[x, y, z] : a)\r\n#define fore(...) overload4(__VA_ARGS__, fore3, fore2, fore1)(__VA_ARGS__)\r\n#define ryes return yes();\r\n#define rno return no();\r\n#define rerr return err();\r\n\r\n#ifdef ATCODER_MODINT\r\nistream &operator>>(istream &is, modint998244353 &a) {\r\n    long long v;\r\n    is >> v;\r\n    a = v;\r\n    return is;\r\n}\r\nostream &operator<<(ostream &os, const modint998244353 &a) {\r\n    return os << a.val();\r\n}\r\nistream &operator>>(istream &is, modint1000000007 &a) {\r\n    long long v;\r\n    is >> v;\r\n    a = v;\r\n    return is;\r\n}\r\nostream &operator<<(ostream &os, const modint1000000007 &a) {\r\n    return os << a.val();\r\n}\r\n#endif\r\ntemplate <class T, class U>\r\nistream &operator>>(istream &is, pair<T, U> &p) {\r\n    is >> p.first >> p.second;\r\n    return is;\r\n}\r\ntemplate <class T, class U>\r\nostream &operator<<(ostream &os, const pair<T, U> &p) {\r\n    os << p.first << \",\" << p.second;\r\n    return os;\r\n}\r\ntemplate <class T>\r\nostream &operator<<(ostream &s, set<T> P) {\r\n    fore(it, P) {\r\n        s << it << \" \";\r\n    }\r\n    return s;\r\n}\r\ntemplate <class T1, class T2>\r\nostream &operator<<(ostream &s, map<T1, T2> P) {\r\n    fore(x, y, P) {\r\n        s << \"<\" << x << \"->\" << y << \"> \";\r\n    }\r\n    return s;\r\n}\r\ntemplate <class T>\r\nostream &operator<<(ostream &s, multiset<T> P) {\r\n    fore(it, P) {\r\n        s << it << \" \";\r\n    }\r\n    return s;\r\n}\r\ntemplate <class T>\r\nostream &operator<<(ostream &s, unordered_set<T> P) {\r\n    fore(it, P) {\r\n        s << it << \" \";\r\n    }\r\n    return s;\r\n}\r\ntemplate <class T1, class T2>\r\nostream &operator<<(ostream &s, unordered_map<T1, T2> P) {\r\n    fore(x, y, P) {\r\n        s << \"<\" << x << \"->\" << y << \"> \";\r\n    }\r\n    return s;\r\n}\r\ntemplate <class T>\r\nistream &operator>>(istream &is, vector<T> &v) {\r\n    for (auto &e : v) is >> e;\r\n    return is;\r\n}\r\ntemplate <class T>\r\nostream &operator<<(ostream &os, const vector<T> &v) {\r\n    for (auto &e : v) os << e << ' ';\r\n    return os;\r\n}\r\ntemplate <class T>\r\nostream &operator<<(ostream &os, const vector<vector<T>> &v) {\r\n    for (auto &e : v) {\r\n        for (auto &c : e) os << c << ' ';\r\n        os << endl;\r\n    }\r\n    return os;\r\n}\r\ntemplate <class t, size_t n>\r\nostream &operator<<(ostream &os, const array<t, n> &a) {\r\n    return os << vector<t>(all(a));\r\n}\r\n\r\ntemplate <int i, class T>\r\nvoid print_tuple(ostream &, const T &) {\r\n}\r\ntemplate <int i, class T, class H, class... Args>\r\nvoid print_tuple(ostream &os, const T &t) {\r\n    if (i) os << \",\";\r\n    os << get<i>(t);\r\n    print_tuple<i + 1, T, Args...>(os, t);\r\n}\r\ntemplate <class... Args>\r\nostream &operator<<(ostream &os, const tuple<Args...> &t) {\r\n    print_tuple<0, tuple<Args...>, Args...>(os, t);\r\n    return os;\r\n}\r\ntemplate <class T>\r\nvector<T> &operator++(vector<T> &v) {\r\n    for (auto &e : v) e++;\r\n    return v;\r\n}\r\ntemplate <class T>\r\nvector<T> operator++(vector<T> &v, signed) {\r\n    auto res = v;\r\n    for (auto &e : v) e++;\r\n    return res;\r\n}\r\ntemplate <class T>\r\nvector<T> &operator--(vector<T> &v) {\r\n    for (auto &e : v) e--;\r\n    return v;\r\n}\r\ntemplate <class T>\r\nvector<T> operator--(vector<T> &v, signed) {\r\n    auto res = v;\r\n    for (auto &e : v) e--;\r\n    return res;\r\n}\r\n\r\n// \u5341\u9032\u6570\u304b\u3089b\u9032\u6570\u3078\r\ntemplate <class T>\r\nstring to_baseB(T x, int b = 10) {\r\n    string ans;\r\n    do {\r\n        int num = x % b;\r\n        ans = (char)((num <= 9) ? ('0' + num) : ('A' + num - 10)) + ans;\r\n        x /= b;\r\n    } while (x != 0);\r\n    return ans;\r\n}\r\n// b\u9032\u6570\u304b\u3089\u5341\u9032\u6570\u3078\r\nlong long to_base10(const string &x, int b = 10) {\r\n    long long ans = 0, base = 1;\r\n    for (int i = x.length() - 1; i >= 0; --i) {\r\n        int num =\r\n            ('0' <= x[i] && x[i] <= '9') ? (x[i] - '0') : (x[i] - 'A' + 10);\r\n        ans += base * num;\r\n        base *= b;\r\n    }\r\n    return ans;\r\n}\r\n\r\nostream &operator<<(ostream &s, const LL &p) {\r\n    s << to_baseB(p);\r\n    return s;\r\n}\r\n\r\n#ifndef ATCODER_MODINT\r\ntemplate <int mod>\r\nstruct ModInt {\r\n    int x;\r\n\r\n    ModInt() : x(0) {\r\n    }\r\n\r\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {\r\n    }\r\n\r\n    ModInt &operator+=(const ModInt &p) {\r\n        if ((x += p.x) >= mod) x -= mod;\r\n        return *this;\r\n    }\r\n\r\n    ModInt &operator-=(const ModInt &p) {\r\n        if ((x += mod - p.x) >= mod) x -= mod;\r\n        return *this;\r\n    }\r\n\r\n    ModInt &operator*=(const ModInt &p) {\r\n        x = (int)(1LL * x * p.x % mod);\r\n        return *this;\r\n    }\r\n\r\n    ModInt &operator/=(const ModInt &p) {\r\n        *this *= p.inverse();\r\n        return *this;\r\n    }\r\n\r\n    ModInt operator-() const {\r\n        return ModInt(-x);\r\n    }\r\n\r\n    ModInt operator+(const ModInt &p) const {\r\n        return ModInt(*this) += p;\r\n    }\r\n\r\n    ModInt operator-(const ModInt &p) const {\r\n        return ModInt(*this) -= p;\r\n    }\r\n\r\n    ModInt operator*(const ModInt &p) const {\r\n        return ModInt(*this) *= p;\r\n    }\r\n\r\n    ModInt operator/(const ModInt &p) const {\r\n        return ModInt(*this) /= p;\r\n    }\r\n\r\n    bool operator==(const ModInt &p) const {\r\n        return x == p.x;\r\n    }\r\n\r\n    bool operator!=(const ModInt &p) const {\r\n        return x != p.x;\r\n    }\r\n\r\n    ModInt inverse() const {\r\n        int a = x, b = mod, u = 1, v = 0, t;\r\n        while (b > 0) {\r\n            t = a / b;\r\n            swap(a -= t * b, b);\r\n            swap(u -= t * v, v);\r\n        }\r\n        return ModInt(u);\r\n    }\r\n\r\n    ModInt pow(int64_t n) const {\r\n        ModInt ret(1), mul(x);\r\n        while (n > 0) {\r\n            if (n & 1) ret *= mul;\r\n            mul *= mul;\r\n            n >>= 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\r\n        return os << p.x;\r\n    }\r\n\r\n    friend istream &operator>>(istream &is, ModInt &a) {\r\n        int64_t t;\r\n        is >> t;\r\n        a = ModInt<mod>(t);\r\n        return (is);\r\n    }\r\n\r\n    static int get_mod() {\r\n        return mod;\r\n    }\r\n};\r\ntypedef ModInt<1000000007> modint1000000007;\r\ntypedef ModInt<998244353> modint998244353;\r\n#endif\r\n\r\n// debug methods\r\n// usage: debug(x,y);\r\n#define CHOOSE(a) CHOOSE2 a\r\n#define CHOOSE2(a0, a1, a2, a3, a4, x, ...) x\r\n#define debug_1(x1) cout << #x1 << \": \" << x1 << endl\r\n#define debug_2(x1, x2) \\\r\n    cout << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << endl\r\n#define debug_3(x1, x2, x3)                                                 \\\r\n    cout << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << \", \" #x3 << \": \" \\\r\n         << x3 << endl\r\n#define debug_4(x1, x2, x3, x4)                                             \\\r\n    cout << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << \", \" #x3 << \": \" \\\r\n         << x3 << \", \" #x4 << \": \" << x4 << endl\r\n#define debug_5(x1, x2, x3, x4, x5)                                         \\\r\n    cout << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << \", \" #x3 << \": \" \\\r\n         << x3 << \", \" #x4 << \": \" << x4 << \", \" #x5 << \": \" << x5 << endl\r\n#ifdef _DEBUG\r\n#define debug(...)                                                        \\\r\n    CHOOSE((__VA_ARGS__, debug_5, debug_4, debug_3, debug_2, debug_1, ~)) \\\r\n    (__VA_ARGS__)\r\n#else\r\n#define debug(...)\r\n#endif\r\n\r\nvoid out() {\r\n    cout << endl;\r\n}\r\ntemplate <class T>\r\nvoid out(const T &a) {\r\n    cout << a;\r\n    cout << endl;\r\n}\r\ntemplate <class T, class... Ts>\r\nvoid out(const T &a, const Ts &...b) {\r\n    cout << a;\r\n    (cout << ... << (cout << ' ', b));\r\n    cout << endl;\r\n}\r\nvoid ofs_in(ostream &ofs) {\r\n    ofs << endl;\r\n}\r\ntemplate <class T>\r\nvoid ofs_in(ostream &ofs, const T &a) {\r\n    ofs << a;\r\n    ofs << endl;\r\n}\r\ntemplate <class T, class... Ts>\r\nvoid ofs_in(ostream &ofs, const T &a, const Ts &...b) {\r\n    ofs << a;\r\n    (ofs << ... << (ofs << ' ', b));\r\n    ofs << endl;\r\n}\r\n#define rout_1(x1) return out(x1)\r\n#define rout_2(x1, x2) return out(x1, x2)\r\n#define rout_3(x1, x2, x3) return out(x1, x2, x3)\r\n#define rout_4(x1, x2, x3, x4) return out(x1, x2, x3, x4)\r\n#define rout_5(x1, x2, x3, x4, x5) return out(x1, x2, x3, x4, x5)\r\n#define rout(...)                                                    \\\r\n    CHOOSE((__VA_ARGS__, rout_5, rout_4, rout_3, rout_2, rout_1, ~)) \\\r\n    (__VA_ARGS__)\r\n\r\nstruct fast_ios {\r\n    fast_ios() {\r\n        cin.tie(nullptr);\r\n        ios::sync_with_stdio(false);\r\n        cout << fixed << setprecision(12);\r\n    };\r\n} fast_ios_;\r\n\r\nstruct Binomial {\r\n    int p;\r\n    int MAX;\r\n    vector<long long> fac, finv, inv;\r\n\r\n    // \u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u308b\u524d\u51e6\u7406\r\n    Binomial(int p_, int n = 1) : p(p_), MAX(1), fac(2), finv(2), inv(2) {\r\n        fac[0] = fac[1] = 1;\r\n        finv[0] = finv[1] = 1;\r\n        inv[1] = 1;\r\n        if (n != 1) build(n);\r\n    }\r\n\r\n    void build(int new_max) {\r\n        MAX++;\r\n        fac.resize(new_max + 1);\r\n        inv.resize(new_max + 1);\r\n        finv.resize(new_max + 1);\r\n        for (; MAX <= new_max; MAX++) {\r\n            fac[MAX] = fac[MAX - 1] * MAX % p;\r\n            inv[MAX] = p - inv[p % MAX] * (p / MAX) % p;\r\n            finv[MAX] = finv[MAX - 1] * inv[MAX] % p;\r\n        }\r\n        MAX--;\r\n    }\r\n\r\n    // nCk\r\n    long long mod_comb(int n, int k) {\r\n        if (n < k) return 0;\r\n        if (n < 0 || k < 0) return 0;\r\n        if (n > MAX) build(n);\r\n        return fac[n] * (finv[k] * finv[n - k] % p) % p;\r\n    }\r\n    long long operator()(int n, int k) {\r\n        return mod_comb(n, k);\r\n    }\r\n\r\n    // nPk\r\n    long long mod_perm(int n, int k) {\r\n        if (n < k) return 0;\r\n        if (n < 0 || k < 0) return 0;\r\n        if (n > MAX) build(n);\r\n        return fac[n] * finv[n - k] % p;\r\n    }\r\n    // n!\r\n    long long operator[](int n) {\r\n        if (n > MAX) build(n);\r\n        return fac[n];\r\n    }\r\n    // 1/n!\r\n    long long operator()(int n) {\r\n        if (n > MAX) build(n);\r\n        return finv[n];\r\n    }\r\n};\r\n\r\ntemplate <typename T = long long>\r\nstruct modpow {\r\n    long long x, m;\r\n    int n;\r\n    vector<T> d;\r\n    modpow(long long x) : x(x), n(1), d(1, 1) {\r\n    }\r\n    T operator[](int i) {\r\n        while (n <= i) d.push_back(d.back() * x), ++n;\r\n        return d[i];\r\n    }\r\n};\r\nmodpow two(2), ten(10);\r\nlong long mod_pow(long long x, int n, long long m) {\r\n    long long res = 1;\r\n    while (n > 0) {\r\n        if (n & 1) res = res * x % m;\r\n        x = x * x % m;\r\n        n >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\nstruct RandomNumberGenerator {\r\n    mt19937 mt;\r\n\r\n    RandomNumberGenerator()\r\n        : mt(chrono::steady_clock::now().time_since_epoch().count()) {\r\n    }\r\n\r\n    long long operator()(long long a, long long b) {  // [a, b)\r\n        uniform_int_distribution<long long> dist(a, b - 1);\r\n        return dist(mt);\r\n    }\r\n\r\n    long long operator()(long long b) {  // [0, b)\r\n        return (*this)(0, b);\r\n    }\r\n\r\n    long long operator()() {\r\n        return (*this)(0, 1LL << 60);\r\n    }\r\n\r\n    double operator[](double a) {\r\n        return (double)(*this)(0, 1LL << 60) / (1LL << 60) * a;\r\n    }\r\n} rnd;\r\n\r\nclock_t start_time = clock();\r\ndouble now_time() {\r\n    clock_t end_time = clock();\r\n    return (double)(end_time - start_time) / CLOCKS_PER_SEC;\r\n}\r\n\r\nvoid input_graph(vector<vector<int>> &g, int m = -1, int bidirected = true) {\r\n    if (m == -1) m = g.size() - 1;\r\n    for (int i = 0; i < m; i++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        u--;\r\n        v--;\r\n        g[u].push_back(v);\r\n        if (bidirected) g[v].push_back(u);\r\n    }\r\n}\r\nvector<int> iota(int n, int s = 0) {\r\n    vi a(n);\r\n    iota(a.begin(), a.end(), s);\r\n    return a;\r\n}\r\ntemplate <class T>\r\nvoid sort(vector<T> &v) {\r\n    sort(all(v));\r\n}\r\ntemplate <class T>\r\nvoid rsort(vector<T> &v) {\r\n    sort(rall(v));\r\n}\r\ntemplate <class T>\r\nvoid reverse(T &v) {\r\n    reverse(all(v));\r\n}\r\ntemplate <class T>\r\nauto max(const T &a) {\r\n    return *max_element(a.begin(), a.end());\r\n}\r\ntemplate <class T>\r\nauto min(const T &a) {\r\n    return *min_element(a.begin(), a.end());\r\n}\r\ntemplate <class T>\r\nint max_id(const T &a) {\r\n    return max_element(a.begin(), a.end()) - a.begin();\r\n}\r\ntemplate <class T>\r\nint min_id(const T &a) {\r\n    return min_element(a.begin(), a.end()) - a.begin();\r\n}\r\nlong long max(signed x, long long y) {\r\n    return max((long long)x, y);\r\n}\r\nlong long max(long long x, signed y) {\r\n    return max(x, (long long)y);\r\n}\r\nlong long min(signed x, long long y) {\r\n    return min((long long)x, y);\r\n}\r\nlong long min(long long x, signed y) {\r\n    return min(x, (long long)y);\r\n}\r\ntemplate <class T, class S>\r\nbool chmax(T &a, const S &b) {\r\n    if (a < (T)b) {\r\n        a = (T)b;\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\ntemplate <class T, class S>\r\nbool chmin(T &a, const S &b) {\r\n    if ((T)b < a) {\r\n        a = (T)b;\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\ntemplate <class T>\r\nvector<T> uniq(vector<T> v) {\r\n    sort(v.begin(), v.end());\r\n    v.erase(unique(v.begin(), v.end()), v.end());\r\n    return v;\r\n}\r\ntemplate <class T>\r\nvector<T> compress(vector<T> v) {\r\n    vector<T> v2(v.size());\r\n    v2 = v;\r\n    sort(v.begin(), v.end());\r\n    v.erase(unique(v.begin(), v.end()), v.end());\r\n\r\n    for (int i = 0; i < (int)v2.size(); i++) {\r\n        v2[i] = lower_bound(v.begin(), v.end(), v2[i]) - v.begin();\r\n    }\r\n    return v2;\r\n}\r\nvector<int> inverse(vector<int> &p) {\r\n    int n = p.size();\r\n    vector<int> inv(n);\r\n    for (int i = 0; i < n; i++) inv[p[i]] = i;\r\n    return inv;\r\n}\r\ntemplate <typename T>\r\nvector<pair<T, int>> idx_pair(vector<T> &a) {\r\n    int n = a.size();\r\n    vector<pair<T, int>> res(n);\r\n    for (int i = 0; i < n; i++) res[i] = {a[i], i};\r\n    return res;\r\n}\r\ntemplate <typename T>\r\nvector<T> acc0(vector<T> &v) {\r\n    vector<T> res(v.size());\r\n    if ((int)v.size() == 0) return res;\r\n    res[0] = v[0];\r\n    for (int i = 1; i < (int)v.size(); i++) {\r\n        res[i] = res[i - 1] + v[i];\r\n    }\r\n    return res;\r\n}\r\ntemplate <typename T>\r\nvector<T> acc1(vector<T> &v) {\r\n    vector<T> res(v.size() + 1);\r\n    for (int i = 0; i < (int)v.size(); i++) {\r\n        res[i + 1] = res[i] + v[i];\r\n    }\r\n    return res;\r\n}\r\ntemplate <typename T>\r\nvector<vector<T>> acc0(vector<vector<T>> v) {\r\n    int h = v.size(), w = v[0].size();\r\n    for (int i = 0; i < h; i++) {\r\n        for (int j = 1; j < w; j++) {\r\n            v[i][j] += v[i][j - 1];\r\n        }\r\n    }\r\n    for (int i = 1; i < h; i++) {\r\n        for (int j = 0; j < w; j++) {\r\n            v[i][j] += v[i - 1][j];\r\n        }\r\n    }\r\n    return v;\r\n}\r\ntemplate <typename T>\r\nvector<vector<T>> acc1(vector<vector<T>> &v) {\r\n    int h = v.size(), w = v[0].size();\r\n    vector<vector<T>> res(h + 1, vector<T>(w + 1));\r\n    for (int i = 0; i < h; i++) {\r\n        for (int j = 0; j < w; j++) {\r\n            res[i + 1][j + 1] = v[i][j] + res[i + 1][j];\r\n        }\r\n    }\r\n    for (int i = 0; i < h; i++) {\r\n        for (int j = 0; j < w; j++) {\r\n            res[i + 1][j + 1] += res[i][j + 1];\r\n        }\r\n    }\r\n    return res;\r\n}\r\ntemplate <class T>\r\nvoid erase1(multiset<T> &st, int x) {\r\n    auto it = st.find(x);\r\n    assert(it != st.end());\r\n    st.erase(it);\r\n}\r\n\r\nlong long exp(long long x, int n) {\r\n    long long res = 1;\r\n    while (n > 0) {\r\n        if (n & 1) res = res * x;\r\n        x = x * x;\r\n        n >>= 1;\r\n    }\r\n    return res;\r\n}\r\nbool ispow2(int i) {\r\n    return i && (i & -i) == i;\r\n}\r\nint countDigits(long long n) {\r\n    string tmp = to_string(n);\r\n    return (int)tmp.size();\r\n}\r\nlong long sq(long long n) {\r\n    return n * n;\r\n}\r\nlong long ceil(long long x, long long y) {\r\n    return (x + y - 1) / y;\r\n}\r\nlong long floor(long long x, long long y) {\r\n    return (y < 0 ? floor(-x, -y)\r\n                  : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\r\n}\r\nconstexpr long long tri(long long n) {\r\n    return n * (n + 1) / 2;\r\n}\r\n// l + ... + r\r\nconstexpr long long tri(long long l, long long r) {\r\n    return (l + r) * (r - l + 1) / 2;\r\n}\r\nint ctoi(const char &c, const char start = '0') {\r\n    return c - start;\r\n}\r\nint atoi(const char &c, const char start = 'a') {\r\n    return c - start;\r\n}\r\nvector<int> ctoi(string &s, const char start = '0') {\r\n    vector<int> res;\r\n    for (auto &c : s) {\r\n        int x = c - start;\r\n        if (x < 0 || x >= 10) x = -1;\r\n        res.push_back(x);\r\n    }\r\n    return res;\r\n}\r\nvector<int> atoi(string &s, const char start = 'a') {\r\n    vector<int> res;\r\n    for (auto &c : s) {\r\n        int x = c - start;\r\n        if (x < 0 || x >= 26) x = -1;\r\n        res.push_back(x);\r\n    }\r\n    return res;\r\n}\r\nint mex(vector<int> &a) {\r\n    int n = a.size();\r\n    vector<int> cnt(n + 1);\r\n    for (int i = 0; i < n; i++) {\r\n        if (a[i] > n) continue;\r\n        cnt[a[i]]++;\r\n    }\r\n    int res = 0;\r\n    while (cnt[res]) res++;\r\n    return res;\r\n}\r\nvoid yes() {\r\n    cout << \"YES\" << endl;\r\n}\r\nvoid no() {\r\n    cout << \"NO\" << endl;\r\n}\r\nvoid yesno(bool x) {\r\n    if (x)\r\n        yes();\r\n    else\r\n        no();\r\n}\r\nvoid err() {\r\n    cout << -1 << endl;\r\n}\r\n\r\nint dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\r\nint dy[] = {0, 1, 0, -1, -1, 1, 1, -1};\r\n\r\nlong long inf = (1 << 30) + (1LL << 60) - 2;\r\ndouble eps = 1e-9;\r\n\r\n// long long mod = 67280421310721;\r\n// using mint = static_modint<1000000009>;\r\n// using mint = dynamic_modint<1000000009>;\r\n// long long mod = 1000000007;\r\n// using mint = modint1000000007;\r\n// long long mod = 998244353;\r\n// using mint = modint998244353;\r\n// typedef vector<mint> vm;\r\n// typedef vector<vector<mint>> vvm;\r\n// typedef vector<vector<vector<mint>>> vvvm;\r\n// Binomial C(mod);\r\n// modpow<mint> mtwo(2), mten(10);\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nsigned main() {\r\n    int testcase = 1;\r\n    cin >> testcase;\r\n    for (int i = 0; i < testcase; i++) {\r\n        solve();\r\n    }\r\n}\r\n\r\nvoid solve() {\r\n    int n;\r\n    cin >> n;\r\n    if (n == 2) rout(2);\r\n    out(1);\r\n}"
}