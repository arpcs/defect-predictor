{
    "id": 98988311,
    "contestId": 921,
    "creationTimeSeconds": 1605823969,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 921,
        "index": "04",
        "name": "Labyrinth-4",
        "type": "PROGRAMMING",
        "rating": 3200,
        "tags": []
    },
    "author": {
        "contestId": 921,
        "members": [
            {
                "handle": "antonis.white"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517500800
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 2480,
    "memoryConsumedBytes": 124825600,
    "points": 0.0,
    "source": "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <ctime>\r\n#include <cassert>\r\n\r\nusing std::cerr;\r\nusing std::cin;\r\nusing std::cout;\r\n \r\nclass big_integer {\r\nprivate:\r\n\tstatic int const BASE = 10;\r\n\tstatic int const HALF_BASE = 5;\r\n\tstatic int const mod = 998244353;\r\n\tstatic const int root = 15311432;\r\n\tstatic const int root_inv = 469870224;\r\n\tstatic const int root_pw = 1 << 23;       \r\n\tstd::vector<int> num = std::vector<int>(1, 0);\r\n\tbool neg = 0;\r\n\tvoid leading_zeros();\r\n\tvoid shift();\r\n\tvoid format();\r\n\tstatic size_t min(size_t a, size_t b) { return a < b ? a : b; }\r\n\tstatic size_t max(size_t a, size_t b) { return a > b ? a : b; }\r\n\tstatic int mod_mlt(int a, int b) { return (a * 1ll * b) % mod; }\r\n\tstatic int mod_inv(int x) { return mod_bin_pow(x, mod - 2); }\r\n\tstatic void mod_sum(int& a, int b);\r\n\tstatic int mod_sub(int a, int b);\r\n\tstatic int mod_bin_pow(int a, int n); \r\n\tstatic void ntt(std::vector<int>& a, bool invert);\r\n\tstatic void multiply(std::vector<int>& a, std::vector<int> b);\r\n\tvoid addition(const big_integer& x);\r\n\tvoid substraction(const big_integer& x);\r\n\tvoid summation(const big_integer& x, bool sub);\r\n\tvoid division(const big_integer& x, bool mod);\r\n\tvoid ban_negative_zero();\r\n\tvoid divide_by_two();\r\npublic:\r\n\tbig_integer() = default;\r\n\tbig_integer(std::string str) { \r\n\t\tif (!str.size())\r\n\t\t\treturn;\r\n\t\tneg = (str[0] == '-');\r\n\t\tnum.resize(str.size() - neg);\r\n\t\tauto num_it = num.end() - 1; \r\n\t\tfor (auto str_it = str.begin() + neg; str_it != str.end(); ++str_it, --num_it) \r\n\t\t\tif (*str_it == '-') {\r\n\t\t\t\t++num_it;\r\n\t\t\t\tneg = 1;\r\n\t\t\t} else {\r\n\t\t\t\t*num_it = (*str_it - '0');\r\n\t\t       \t}\r\n\t\tban_negative_zero();\r\n\t}\r\n\tbig_integer(int x) {\r\n\t\tif (x == 0) \r\n\t\t\treturn;\r\n\t\tif (x < 0) {\r\n\t\t\tneg = 1;\r\n\t\t\tx = -x;\r\n\t\t}\r\n\t\tnum.clear();\r\n\t\twhile (x) {\r\n\t\t\tnum.push_back(x % BASE);\r\n\t\t\tx /= BASE;\r\n\t\t}\r\n\t}\r\n\tbig_integer(const char* s) : big_integer(std::string(s)) {}\r\n\tbig_integer(const big_integer& x) : num(std::vector<int>(x.num.begin(), x.num.end())), neg(x.neg) {}\r\n\t~big_integer() = default;\r\n\tbig_integer& operator+=(const big_integer& x) &;\r\n\tbig_integer& operator-=(const big_integer& x) &;\r\n\tbig_integer& operator*=(const big_integer& x) &;\r\n\tbig_integer& operator/=(const big_integer& x) &;\r\n\tbig_integer& operator%=(const big_integer& x) &;\r\n\tbig_integer& operator=(big_integer x) &;\r\n\tbig_integer& operator++() &;\r\n\tbig_integer operator++(int) &;\r\n\tbig_integer& operator--() &;\r\n\tbig_integer operator--(int) &;\r\n\tbig_integer operator-() const;\r\n\tbool negative() const;\r\n\tbool is_zero() const;\r\n\tbool is_one() const;\r\n\tvoid change_sign();\r\n\tstatic void ntt_precalc();\r\n\tvoid cut(size_t left);\r\n\tbool less_abs(const big_integer& x) const;\r\n\tint digit(size_t index) const;\r\n\tint& digit(size_t index);\r\n\tsize_t length() const;\r\n\tstd::string to_string() const;\r\n\tvoid swap(big_integer& b) &;\r\n\texplicit operator bool() const { return !is_zero(); }\t  \r\n\tvoid multiply_by_power_of_ten(size_t ppw) &;\r\n\texplicit operator int() const {\r\n\t\tint ans = 0;\r\n\t\tfor (size_t pos = length(); pos;) {\r\n\t\t\tans = ans * BASE + num[--pos];\r\n\t\t}\r\n\t\treturn ans * (neg ? -1 : 1);\r\n\t}\r\n\tfriend class big_float;\r\n\tfriend void test();\r\n};\r\n\r\nvoid big_integer::mod_sum(int& a, int b) {\r\n\ta += b;\r\n\tif (a >= mod)\r\n\t\ta -= mod;\r\n\t//return a < mod ? a : a - mod;\r\n}\r\n\r\nint big_integer::mod_sub(int a, int b) {\r\n        a -= b;\r\n\treturn a < 0 ? a + mod : a;\r\n}\r\n\r\nint big_integer::mod_bin_pow(int a, int n) {\r\n\tint res = 1;\r\n\twhile (n) {\r\n\t\tif(n & 1) {\r\n\t\t\tres = mod_mlt(a, res), n ^= 1;\r\n\t\t} else {\r\n\t\t\ta = mod_mlt(a, a), n >>= 1;\r\n\t\t}\r\n\t}\r\n\treturn res;\t\r\n}\r\n\r\n\r\nint const C = (1<<22);\r\nint* w[23];\r\nint* iw[23];\r\n\r\nvoid big_integer::ntt_precalc() {\r\n\tint rt = root;\r\n\tint irt = root_inv;\r\n\tfor (int j = 22; j >= 0; --j){\r\n\t\t//precalc w\r\n\t\trt = mod_mlt(rt, rt);\r\n\t\tirt = mod_mlt(irt, irt);\r\n\t\tsize_t len = (1 << j);\r\n\t\tw[j] = new int[len + 1];\r\n\t\tiw[j] = new int[len + 1];\r\n\t\tw[j][0] = 1;\r\n\t\tiw[j][0] = 1;\r\n\t\tint* w_it = &w[j][1];\r\n\t\tint* iw_it = &iw[j][1];\r\n\t\tint* wend = &w[j][len];\r\n\t\tint cw = 1;\r\n\t\tint ciw = 1; \r\n\t\tfor (; w_it != wend; ++w_it, ++iw_it) {\r\n\t\t\t*w_it = cw = mod_mlt(cw, rt);\r\n\t\t\t*iw_it = ciw = mod_mlt(ciw, irt);\r\n\t\t}\r\n\t}\t\r\n}\r\n  \r\nvoid big_integer::ntt(std::vector<int>& a, bool invert) {\r\n\t//Number theoretic transform (I thought that's well-known name)\r\n\t//time complexity O(N * log(N))\r\n\tsize_t n = a.size();\r\n\tfor (size_t i = 1, j = 0; i < n; ++i) {\r\n\t\tsize_t bit = n >> 1;\r\n\t\tfor (; j >= bit; bit >>= 1) {\r\n\t\t\tj -= bit;\r\n\t\t}\r\n\t\tj += bit;\r\n\t\tif (i < j)\r\n\t\t\tstd::swap(a[i], a[j]);\r\n\t}   \r\n\tfor (size_t p = 1, hlen = 1, len = 2; len <= n; hlen = len, len <<= 1, ++p) {\r\n\t\tint* start = (invert ? &iw[p][0] : &w[p][0]);\r\n\t\tauto j = a.begin() + hlen;\r\n\t\tfor (auto i = a.begin(); i != a.end(); i += hlen, j += hlen) {\r\n\t\t\tauto ni = i + len;\r\n\t\t\tint* w_it = start;\r\n\t\t\tfor (; j != ni; ++i, ++j) {\r\n\t\t\t\tint j_val = mod_mlt(*j, *w_it);\r\n\t\t\t\t*j = mod_sub(*i, j_val);\r\n\t\t\t\tmod_sum(*i, j_val);\r\n\t\t\t\t++w_it;\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (invert) {\r\n\t\tint n_inv = mod_inv(n);\r\n\t\tfor (size_t i = 0; i < n; ++i) {\r\n\t\t\ta[i] = mod_mlt(a[i], n_inv);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid big_integer::multiply(std::vector<int>& a, std::vector<int> b){\r\n\tsize_t n = 1;\r\n\twhile (n < a.size() + b.size() + 1) {\r\n\t\tn <<= 1;\r\n       \t}\r\n\ta.resize(n, 0);\r\n\tb.resize(n, 0);\r\n\tntt(a, 0);\r\n\tntt(b, 0);\r\n\tfor (size_t i = 0; i < n; ++i) {\r\n\t\ta[i] = mod_mlt(a[i], b[i]);\r\n\t}\r\n\tntt(a, 1);\t\r\n}\r\n\r\nbig_integer big_integer::operator-() const {\r\n\tbig_integer cp(*this);\r\n\tcp.change_sign();\r\n\treturn cp;\r\n}\r\n\r\nbool big_integer::is_zero() const{\r\n\treturn num.back() == 0 && num.size() == 1;\r\n}\r\n\r\nbool big_integer::is_one() const {\r\n\treturn length() == 1 && num[0] == 1;\t\r\n}\r\n\r\nvoid big_integer::change_sign(){\t\r\n\tif (!is_zero())\r\n\t\tneg = !neg;\t\r\n}\r\n\r\nbig_integer abs(big_integer q) {\r\n\tif (q.negative())\r\n\t\tq.change_sign();\r\n\treturn q;\r\n}\r\n\r\nbig_integer operator\"\"_bi(const char* s) {\r\n\treturn big_integer(s);\r\n}\r\n\r\nbool big_integer::less_abs(const big_integer& x) const {\r\n\tif (length() != x.length())\r\n\t\treturn length() < x.length();\r\n\tfor (size_t pos = length(); pos;) {\r\n\t\t--pos;\r\n\t\tif (num[pos] != x.num[pos])\r\n\t\t\treturn num[pos] < x.num[pos];\r\n\t}\r\n\treturn 0;\t\t\r\n}\r\n\r\nbig_integer& big_integer::operator+=(const big_integer& x) & {\r\n\tsummation(x, negative() != x.negative());\r\n\treturn *this;\r\n}\r\n\r\nbig_integer& big_integer::operator-=(const big_integer& x) & {\r\n\tsummation(x, negative() == x.negative());\r\n\treturn *this;\t\r\n}\r\n\r\nbig_integer& big_integer::operator*=(const big_integer& x) & {\r\n\tneg ^= x.neg;\r\n\tmultiply(num, x.num);\r\n\tformat();\r\n\treturn *this;\r\n}\r\n\r\nbig_integer& big_integer::operator=(big_integer x) & {\r\n\tswap(x);\r\n\treturn *this;\r\n}\r\n\t\r\nvoid big_integer::swap(big_integer& x) & {\r\n\tstd::swap(neg, x.neg);\r\n\tstd::swap(num, x.num);\r\n}\r\n\r\nbig_integer& big_integer::operator++() & {\r\n\t*this += 1_bi;\r\n\treturn *this;\r\n}\r\n\r\nbig_integer& big_integer::operator--() & {\r\n\t*this -= 1_bi;\r\n\treturn *this;\r\n}\r\n\r\nbig_integer big_integer::operator++(int) & {\r\n\tbig_integer res(*this);\r\n\t*this += 1_bi;\r\n\treturn res;\r\n}\r\n\r\nbig_integer big_integer::operator--(int) & {\r\n\tbig_integer res(*this);\r\n\t*this -= 1_bi;\r\n\treturn res;\r\n}\r\n\r\nbig_integer operator+(const big_integer& lhs, const big_integer& rhs) {\r\n\tbig_integer res(lhs);\r\n\tres += rhs;\r\n\treturn res;\t                                                                \r\n}\r\n\r\nbig_integer operator-(const big_integer& lhs, const big_integer& rhs) {\r\n\tbig_integer res(lhs);\r\n\tres -= rhs;\r\n\treturn res;\t\r\n}\r\n\r\nbig_integer operator*(const big_integer& lhs, const big_integer& rhs) {\r\n\tbig_integer res(lhs);\r\n\tres *= rhs;\r\n\treturn res;\r\n}        \r\n\r\nbool operator<(const big_integer& lhs, const big_integer& rhs) {\r\n\tif (lhs.negative() != rhs.negative())\r\n\t\treturn lhs.negative();\r\n\tif (lhs.less_abs(rhs))\r\n\t\treturn !lhs.negative();\r\n\tif (rhs.less_abs(lhs))\r\n\t\treturn lhs.negative();\r\n\treturn 0; \t\r\n}\r\n\r\nbool operator>(const big_integer& lhs, const big_integer& rhs) {\r\n\treturn rhs < lhs;\r\n}\r\n\r\nbool operator<=(const big_integer& lhs, const big_integer& rhs) {\r\n\treturn !(rhs < lhs);\r\n}\r\n\r\nbool operator>=(const big_integer& lhs, const big_integer& rhs) {\r\n\treturn !(lhs < rhs);\r\n}\r\n\r\nbool operator==(const big_integer& lhs, const big_integer& rhs) {\r\n\treturn !(lhs < rhs || rhs < lhs);\r\n}\r\n\r\nbool operator!=(const big_integer& lhs, const big_integer& rhs) {\r\n\treturn lhs < rhs || rhs < lhs;\r\n}    \r\n\r\nstd::istream& operator>>(std::istream& in, big_integer& x) {\r\n\tstd::string input;\r\n\tin >> input;\r\n\tx = big_integer(input);\r\n\treturn in;\r\n}\r\n\r\nstd::ostream& operator<<(std::ostream& out, const big_integer& x) {\r\n\tout << x.to_string();\r\n\treturn out;\r\n}\r\n\r\nvoid big_integer::leading_zeros() {\r\n\twhile (num.size() > 1 && !num.back()) {\r\n\t\tnum.pop_back();\t\r\n\t}\r\n}\r\n\r\nvoid big_integer::shift() {\r\n\tint bonus = 0;\r\n\tfor (size_t pos = 0; pos < num.size(); ++pos) {\r\n\t\tnum[pos] += bonus;\r\n\t\tbonus = num[pos] / BASE;\r\n\t\tnum[pos] %= BASE;\r\n\t}\r\n}\r\n\r\nvoid big_integer::format() {\r\n\tshift();\r\n\tleading_zeros();\r\n\tban_negative_zero(); \r\n}\r\n\r\nvoid big_integer::ban_negative_zero() {\r\n\tif (num.size() == 0 && !num.back())\r\n\t\tneg = 0;\t\r\n}\r\n\r\nvoid big_integer::addition(const big_integer& x) {\r\n\tint bonus = 0;\r\n\tsize_t nsz = max(length(), x.length());\r\n\tnum.resize(nsz, 0);\r\n\tfor (size_t pos = 0; pos < nsz; ++pos) {\r\n\t\tnum[pos] = num[pos] + (pos < x.length() ? x.num[pos] : 0) + bonus;\r\n\t\tbonus = 0;\r\n\t\twhile (num[pos] >= BASE) {\r\n\t\t\tnum[pos] -= BASE;\r\n\t\t\t++bonus;\r\n\t\t}\t\t\r\n\t}\t\r\n\tif (bonus) \r\n\t\tnum.push_back(bonus);\r\n}\r\n\r\nvoid big_integer::substraction(const big_integer& x) {\r\n\tif (less_abs(x)) {  //works linear only if numbers have same length - so it's O(changed digits)\r\n\t\tbool new_neg = !neg;\r\n\t\tbig_integer cp(*this);\r\n\t\t*this = big_integer(x);\r\n\t\tsubstraction(cp);\r\n\t\tneg = new_neg;\r\n\t\treturn;\t\t\t\t\r\n\t}\r\n\tint bonus = 0;\r\n\tfor (size_t pos = 0; bonus || pos < x.length(); ++pos) {\r\n\t\tnum[pos] = num[pos] - bonus - (pos < x.length() ? x.num[pos] : 0);\r\n\t\tbonus = 0;\r\n\t\twhile (num[pos] < 0) {\r\n\t\t\tnum[pos] += BASE;\r\n\t\t\t++bonus;\r\n\t\t}\r\n\t}\r\n\tleading_zeros();\r\n\tban_negative_zero();\t\t\r\n}\r\n\r\nvoid big_integer::summation(const big_integer& x, bool sub) {\r\n\tif (sub)\r\n\t\tsubstraction(x);\r\n\telse\r\n\t\taddition(x);\r\n}\r\n\r\nvoid big_integer::divide_by_two() {\r\n\tbool bonus = 0;\r\n\tfor (size_t pos = length(); pos;) {\r\n\t\t--pos;\r\n\t\tbool nbonus = (num[pos] & 1);\r\n\t\tnum[pos] >>= 1;\r\n\t\tif (bonus)\r\n\t\t\tnum[pos] += HALF_BASE;\r\n\t\tbonus = nbonus;\t\t\t\r\n\t}\r\n\tleading_zeros();\r\n}\r\n\r\nbool big_integer::negative() const {\r\n\treturn neg;\r\n}\r\n\r\nint big_integer::digit(size_t index) const {\r\n\treturn num[index];\r\n}\r\n\r\nint& big_integer::digit(size_t index) {\r\n\treturn num[index];\r\n}\t\r\n\r\nsize_t big_integer::length() const {\r\n\treturn num.size();\r\n}\r\n\r\nstd::string big_integer::to_string() const {\r\n\tstd::string res;\r\n\tres.resize(length() + neg);\r\n\tif (neg)\r\n\t\tres[0] = '-';\t\r\n\tfor (size_t i = 0, j = length() - 1; i < length(); ++i, --j) {\r\n\t\tres[j + neg] = '0' + num[i];\r\n\t}\r\n\treturn res;\t\r\n}\r\n\r\nvoid big_integer::multiply_by_power_of_ten(size_t ppw) & {          \t\t\t\t\r\n\tif (is_zero() || !ppw)\r\n\t\treturn;\r\n\tnum.resize(length() + ppw, 0);\r\n\tfor (size_t i = length() - 1; i >= ppw; --i) {\r\n\t\tnum[i] = num[i - ppw];\r\n\t}    \r\n}\r\n\r\nvoid big_integer::cut(size_t left) {\r\n\tsize_t n = length();\r\n \tif (n <= left)\r\n \t\treturn;\r\n \tbig_integer res(*this);\r\n \tres.num.resize(left);\r\n \tfor(size_t i = 0; i < left; ++i) {\r\n \t\tres.num[i] = num[n - left + i];\r\n \t}\r\n \tswap(res); \t\r\n}\r\n\r\n\r\nclass big_float{\r\nprivate:\r\n\tbig_integer num = 0_bi;\r\n\tint ex = 0;\r\npublic:\r\n\tbig_float(){}\r\n\tbig_float(const big_integer& x, int ex = 0) : num(x) , ex(ex) { leading_zeros(); }\r\n\tbig_float(const big_float& x) : num(x.num), ex(x.ex) {}\r\n\tbig_float(int x) : big_float(static_cast<big_integer>(x)) {}\r\n\tbig_float& operator=(const big_float& x) &;\r\n\tbig_float& operator+=(const big_float& x) &;\r\n\tbig_float& operator-=(const big_float& x) &; \r\n\tbig_float& operator*=(const big_float& x) &;\r\n\tbig_float& operator/=(const big_float& x) &;\r\n\tbig_float operator-() const;\r\n\tbool negative() const { return num.negative(); }\r\n\tint exponent() const { return ex; }\r\n\tsize_t length() const { return num.length(); };\r\n\tbig_float inverse(int precision) const;\r\n\tint digit(int index) const { return num.digit(index + ex); }\r\n\tvoid setprecision(int prec) &;\r\n\tvoid swap(big_float& x) &;\r\n\tvoid multiply_by_power_of_ten(int pw) &;\r\n\tint intpart() const { return length() - ex; }\r\n\toperator big_integer() {\r\n\t\tsetprecision(0);\r\n\t\treturn num;\r\n\t}\r\n\tvoid times_three() &;\r\n\tbig_float sq_aproximation() const;\r\n\tvoid divide_by_two();\r\n\tvoid leading_zeros() {\r\n\t\tif (ex > (int)length()) \r\n\t\t\tnum.num.resize(ex, 0);\r\n\t\twhile (intpart() > 0 && num.num.back() == 0)\t\r\n\t\t\tnum.num.pop_back();\r\n\t}\r\n\tbig_float sq_root_newton(int precision) const;\r\n\tfriend std::ostream& operator<<(std::ostream& out, const big_float& x);\r\n};\r\n\r\nstd::ostream& operator<<(std::ostream& out, const big_float& x) {\r\n\tif (x.num.negative()) {\r\n\t        out << '-';\r\n\t}\r\n\tint ipart = x.length() - x.ex;\r\n\tif (ipart == 0)\r\n\t\tout << '0';\r\n\tfor (int p = ipart - 1; p >= -x.ex; --p) {\r\n\t\tif (p == -1)\r\n\t\t\tout << '.';\t\r\n\t\tout << x.digit(p);\r\n\t}\r\n\treturn out;\r\n}\r\n\r\nbig_float big_float::operator-() const {\r\n\tbig_float cp(*this);\r\n\tcp.num.neg ^= 1;\r\n\treturn cp;\r\n}\r\n\r\nbig_float& big_float::operator=(const big_float& x) & {\r\n\tnum = x.num;\r\n\tex = x.ex;\r\n\treturn *this;\r\n}\r\n\r\nvoid big_float::multiply_by_power_of_ten(int pw) & {\r\n\tif (pw < 0) {\r\n\t\tex -= pw;\r\n\t\tleading_zeros();\r\n\t\treturn;\r\n\t}\r\n\tint dex = std::min(ex, pw);\r\n\tex -= dex;\r\n\tpw -= dex;\r\n\tif (pw) \r\n\t\tnum.multiply_by_power_of_ten(pw);\r\n}\r\n\r\nvoid big_float::swap(big_float& x) & {\r\n\tnum.swap(x.num);\r\n\tstd::swap(ex, x.ex);\r\n}\r\n\r\nvoid big_float::setprecision(int prec) & {\r\n\tif (ex <= prec) \r\n\t\treturn;\r\n\tnum.cut(length() - ex + prec);\r\n\tex = prec;\r\n}\r\n\r\nbig_float& big_float::operator+=(const big_float& x) & {\r\n\tif (ex == x.ex) {\r\n\t\tnum += x.num;\r\n\t\tleading_zeros();\r\n\t\treturn *this;\r\n\t}\t\r\n\tif (ex < x.ex) {\r\n\t\tnum.multiply_by_power_of_ten(x.ex - ex);\r\n\t\tex = x.ex;\r\n\t\tnum += x.num;\r\n\t\tleading_zeros();\r\n\t\treturn *this;\r\n\t}\r\n\tbig_integer cp = x.num;\r\n\tcp.multiply_by_power_of_ten(ex - x.ex);\r\n\tnum += cp;\r\n\tleading_zeros();\r\n\treturn *this;\r\n}\r\n\r\nbig_float& big_float::operator-=(const big_float& x) & {\r\n\t*this += -x;\r\n\tleading_zeros();\r\n\treturn *this;\r\n} \r\n\r\nbig_float& big_float::operator*=(const big_float& x) & {\r\n\tnum *= x.num;\r\n\tex += x.ex;\r\n\tleading_zeros();\r\n\treturn *this;\t\r\n}\r\n\r\nbig_float operator+(const big_float& a, const big_float& b) {\r\n\tbig_float res(a);\r\n\tres += b;\r\n\treturn res;\r\n}\r\n\r\nbig_float operator-(const big_float& a, const big_float& b) {\r\n\tbig_float res(a);\r\n\tres -= b;\r\n\treturn res;\r\n}\r\n\r\nbig_float operator*(const big_float& a, const big_float& b) {\r\n\tbig_float res(a);\r\n\tres *= b;\r\n\treturn res;\r\n}\r\n\r\nbool operator<(const big_float& a, const big_float& b) {\r\n\treturn (a - b).negative();\t\r\n}\r\n\r\nbool operator==(const big_float& a, const big_float& b) {\r\n\treturn !(a < b || b < a);\t\r\n}\r\n\r\nbool operator!=(const big_float& a, const big_float& b) {\r\n\treturn a < b || b < a;\t\r\n}\r\n\r\nbool operator>(const big_float& a, const big_float& b) {\r\n\treturn b < a;\r\n}\r\n\r\nbool operator<=(const big_float& a, const big_float& b) {\r\n\treturn !(a > b); \r\n}\r\n\r\nbool operator>=(const big_float& a, const big_float& b) {\r\n\treturn !(a < b);\r\n}\r\n\r\nvoid big_float::times_three() & {\r\n\tint bonus = 0;\r\n\tfor (int& x : num.num) {\r\n\t\tx = 3 * x + bonus;\r\n\t\tbonus = 0;\r\n\t\twhile (x > 9) {\r\n\t\t\t++bonus;\r\n\t\t\tx -= 10;\r\n\t\t}\t\t\t\r\n\t}\t\r\n\tif (bonus) \r\n\t\tnum.num.push_back(bonus);\r\n\tleading_zeros();\r\n}\r\nbig_float aproximate(const big_float& a) {\r\n\tint l = 1;\r\n\tfor (int p = (1 << 29); p > 0; p >>= 1) {\r\n\t\tl += p;\r\n\t\tbig_float cur(l, 9);\r\n\t\tcur *= a;\r\n\t\tif (cur.intpart())\r\n\t\t\tl -= p;\r\n\t}\r\n\treturn big_float(l, 9);\r\n}\r\n\r\nbig_float big_float::inverse(int precision) const {\r\n\tbig_float a(*this);\r\n\tint delta = a.intpart();\r\n\tif (delta == 0) {\r\n\t\tint j = 1;\r\n\t\twhile(a.digit(-j) == 0)\r\n\t\t\t++j;\r\n\t\tdelta = - j + 1;\r\n\t}\r\n\ta.multiply_by_power_of_ten(-delta);\r\n\tbig_float b(a);\r\n\tb.setprecision(1);\r\n\tbig_float x = aproximate(b);\r\n\tint k = 1;\r\n\tbig_float two(2_bi, 0);\r\n\twhile((1 << k) < (precision - delta)) {\r\n\t\t++k;\r\n\t\t//cerr << \"div \" << k << '\\n';\r\n\t\tbig_float a_(a);\r\n\t\ta_.num.change_sign();\r\n\t\ta_.setprecision(x.intpart() + (1 << k) + 2);\r\n\t\t//cerr << std::max(a_.length(), x.length() * 2) << '\\n';\r\n\t\tbig_float cx(x);\r\n\t\tcx *= a_;\r\n\t\tcx += two;\r\n\t\tx *= cx;\r\n\t\t//x *= (x * a_ + two);\r\n\t\tx.setprecision((1<<k) + 2);\r\n\t\tx.leading_zeros();\r\n\t}\r\n\tx.setprecision(precision);\r\n\tx.multiply_by_power_of_ten(-delta);\r\n\treturn x;\t\t\t\t\r\n}\r\n\r\nbig_integer operator/(const big_integer& a, const big_integer& b) {\r\n\tbig_float fa(a), fb(b);\r\n\tbig_integer q = fa * fb.inverse(a.length() + 100);\r\n\tbig_integer qb = q * b;\r\n\tint iter = 0;\r\n\tint delta = 0;\r\n\twhile (qb < a) {\r\n\t\tqb += b;\r\n\t\t++delta;\r\n\t\t++iter;\r\n\t}\r\n\twhile (qb > a) {\r\n\t\tqb -= b;\r\n\t\t--delta;\r\n\t\t++iter;\r\n\t}\r\n\t//cerr << \"precision error in division: \" << std::max(0, iter - 2) << '\\n';\r\n\treturn q + delta;\r\n}\r\n\r\nbig_float big_float::sq_aproximation() const {\r\n\tint l = 1;\r\n\tfor (int p = (1 << 29); p; p >>= 1) {\r\n\t\tl += p;\r\n\t\tbig_float x(l, 3);\r\n\t\tx *= x;\r\n\t\tif (x > *this) \r\n\t\t\tl -= p;\t\r\n\t}\r\n\treturn big_float(l, 3);\r\n}\r\n\r\nvoid big_float::divide_by_two() {\r\n\tint bonus = 0;\r\n\tfor (int& x : num.num) {\r\n\t\tx = 5 * x + bonus;\r\n\t\tbonus = 0;\r\n\t\twhile (x > 9) {\r\n\t\t\t++bonus;\r\n\t\t\tx -= 10;\r\n\t\t}\t\t\t\r\n\t}\t\r\n\tif (bonus) \r\n\t\tnum.num.push_back(bonus);\r\n\t++ex;\r\n\tleading_zeros();\r\n}\r\n\r\nbig_float big_float::sq_root_newton(int precision) const { \r\n\tint delta = (1 + (int)length() - ex) / 2;     \r\n\tbig_float a(*this);\r\n\ta.multiply_by_power_of_ten(-2 * delta);\r\n\tbig_float a_inv = a.inverse(delta * 3 / 2 + precision + 1);\r\n\tbig_float x = a.sq_aproximation();\r\n\tint k = 0;\r\n\twhile ((1 << k) < (precision + delta)) {\r\n\t\t++k;\r\n\t\t//cerr << \"sqrt \" << k << '\\n';\r\n\t\tbig_float a_(a_inv);\r\n\t\ta_.setprecision((1 << k) + 2);\r\n\t\t//cerr <<  a_.length() + 2 * x.length() << '\\n';\r\n\t\t//x *= (x * x * a_- three);\r\n\t\tbig_float cx(x);\r\n\t\tcx.times_three();\r\n\t\tbig_float ncx(x);\r\n\t\tncx *= x;\r\n\t\tncx *= x;\r\n\t\tncx *= a_;\r\n\t\tcx -= ncx;//(x * x) * (x * a_);\r\n\t\tx.swap(cx);\r\n\t\tx.divide_by_two();\r\n\t\tx.setprecision((1 << k) + 2);\r\n\t\tx.leading_zeros();\r\n\t}\r\n\tx.multiply_by_power_of_ten(delta);\r\n\tx.setprecision(precision);\r\n\treturn x;\r\n}\r\n\r\nbig_integer sq_root(const big_integer& x) {\r\n\tbig_float fx(x);\r\n\tbig_integer s = fx.sq_root_newton(0); \r\n\tbig_integer sq(s);\r\n\tsq *= s;\r\n\tint iter = 0;\r\n\tint delta = 0;\r\n\tbig_integer bonus = 2 * s + 1;\r\n\twhile (sq < x) {\r\n\t\tsq += bonus;\r\n\t\tbonus += 2;\r\n\t\t++delta;\r\n\t\t++iter;\r\n\t\tif(iter == 100) {\r\n\t\t\tcerr << \"too small\\n\";\r\n\t\t\tassert(0);\r\n\t\t}\r\n\t}\r\n\tbonus -= 2;\r\n\twhile (sq > x) {\r\n\t\tsq -= bonus;\r\n\t\tbonus -= 2;\r\n\t\t--delta;\r\n\t\t++iter;\r\n\t\tif(iter == 100) {\r\n\t\t\tcerr << \"too big\\n\";\r\n\t\t\tassert(0);\r\n\t\t}\r\n\t}\r\n\t//cerr << \"precision error in sqrt: \" << std::max(0, iter - 2) << '\\n';\t\r\n\treturn s + delta;\t\t\r\n}\r\n\r\nvoid test() {\r\n\tbig_integer x;\r\n\tint const N = 1000000;\r\n\tx.num.resize(N);\r\n\tx.num[N - 1] = 9;\r\n\tfor (int i = 0; i < N - 1; ++i)\r\n\t\tx.num[i] = rand() % 10;\r\n\tbig_integer s = sq_root(x);\r\n\tcout << (s * s == x ? \"Yes\\n\" : \"No\\n\"); \r\n}        \r\n\r\nvoid solve() {\r\n\tbig_integer x;\r\n\tcin >> x;\r\n\tbig_integer s = sq_root(x);\r\n\tcout << (s * s == x ? \"Yes\" : \"No\");\r\n}\r\n\r\nint main(){\r\n\tstd::ios_base::sync_with_stdio(false);\r\n\tstd::cin.tie(NULL);\r\n\tsrand(time(0));\r\n\t#ifdef LOCAL\r\n\tfreopen(\"in\", \"r\", stdin);\r\n\tfreopen(\"out\", \"w\", stdout);\r\n\tunsigned int start_time = clock();\r\n\t#endif\r\n\tbig_integer::ntt_precalc();\r\n\ttest();\r\n\t//solve();\r\n\t#ifdef LOCAL\r\n\tcerr << \"Time: \" << clock() - start_time << \"ms\\n\";\r\n\t#endif\r\n\treturn 0;\r\n}"
}