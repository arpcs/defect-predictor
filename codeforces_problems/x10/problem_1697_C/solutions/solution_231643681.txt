{
    "id": 231643681,
    "contestId": 1697,
    "creationTimeSeconds": 1699304263,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1697,
        "index": "C",
        "name": "awoo's Favorite Problem",
        "type": "PROGRAMMING",
        "rating": 1400,
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "strings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1697,
        "members": [
            {
                "handle": "Derato"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1655044500
    },
    "programmingLanguage": "C# 10",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 28,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 3379200,
    "source": "using static IOBase;\r\nusing static IOExt;\r\nusing static Math1;\r\nusing static ProblemData;\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Numerics;\r\nusing System.Reflection.PortableExecutable;\r\nusing System.Runtime;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.Intrinsics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Xml;\r\n\r\ninternal partial class Program {\n    static void Solve() {\n        long answ = 0;\n        var n = geti();\n        var ss= gets_c();\n        var tt= gets_c();\n        char a = 'a';\n        char c = 'c';\n        void f() {\n            int j = 0;\n            for (var i = 0; i < n; i++) {\n                if (tt[i] == 'b' && ss[i] == a) {\n                    j.max(i);\n                    for (; j < n; j++) {\n                        if (ss[j] == c) break;\n                        if (ss[j] == 'b') { ss.swap(i, j); break; }\n                    }\n                }\n            }\n        }\n        f();\n        ss.Reverse();\n        tt.Reverse();\n        Swap(ref a, ref c);\n        f();\n        yes(ss.SequenceEqual(tt));\n    }\n}\r\n\r\n// --------------------\r\ninternal partial class Program {\n    static void Main(string[] args) {\n        HasTestCase = true;\n        AutoFlash = false;\n        TestInput = new string [] {@\"\n5\n3\ncab\ncab\n1\na\nb\n6\nabbabc\nbbaacb\n10\nbcaabababc\ncbbababaac\n2\nba\nab\n\"};\n        CorOutput = new string [] {@\"\nYES\nNO\nYES\nYES\nNO\n\"};\n        Starter.Start(args, Solve);\n    }\n}\r\npublic static class Extens_long {\n    public static bool isodd(this long v) { return (v & 1) != 0; }\n    public static bool isodd(this int v) { return (v & 1) != 0; }\n    public static bool iseven(this long v) { return (v & 1) == 0; }\n    public static bool iseven(this int v) { return (v & 1) == 0; }\n    public static bool issameparity(this long a, long b) { return (a + b & 1) == 0; }\n    public static bool issameparity(this int a, long b) { return (a + b & 1) == 0; }\n    public static long divup(this long a, long b) { return (a + b - 1) / b; }\n    public static int divup(this int a, int b) { return (a + b - 1) / b; }\n    public static bool b(this int v) { return v != 0; }\n    public static bool b(this long v) { return v != 0; }\n    public static void min(this ref long a, long b) { a = Math.Min(a, b); }\n    public static void min(this ref int a, int b) { a = Math.Min(a, b); }\n    public static void max(this ref long a, long b) { a = Math.Max(a, b); }\n    public static void max(this ref int a, int b) { a = Math.Max(a, b); }\n}\r\nstatic public partial class IOBase {\n    public static FastStreamScanner Scanner { get; private set; }\n    public static void Reinit(Stream stream) {\n        Scanner = new(stream);\n    }\n    static public bool HasInput => !Scanner.IsEndOfStream;\n    [MethodImpl(256)] static public long geti() { return Scanner.Integer(); }\n    [MethodImpl(256)] static public int geti32() { return (int)Scanner.Integer(); }\n    static public string gets() { return Scanner.NextToken(); }\n    [MethodImpl(256)] static public char getc() { return Scanner.ReadChar(); }\n}\r\npublic class FastStreamScanner {\n    public FastStreamScanner(Stream stream) { str = stream; }\n    private readonly Stream str;\n    private readonly byte[] _buffer = new byte[1024];\n    private int _length, _cursor;\n    bool isEof = false;\n    [MethodImpl(256)] private static bool IsValidChar(char c) => '!' <= c && c <= '~';\n    public bool IsEndOfStream {\n        get {\n            if (_cursor != _length) return false;\n            if (isEof) return true;\n            _length = str.Read(_buffer);\n            if (_length == 0) {\n                isEof = true;\n                return true;\n            }\n            return false;\n        }\n    }\n    StringBuilder sb = new StringBuilder();\n    [MethodImpl(256)] private char read_raw() {\n        if (_cursor == _length) {\n            _cursor = 0;\n            _length = str.Read(_buffer);\n            if (_length == 0) {\n                if (!isEof) {\n                    isEof = true;\n                    return '\\0';\n                } else {\n                    throw new EndOfStreamException(\"Input was FULL readed\");\n                }\n            }\n        }\n        return (char)_buffer[_cursor++];\n    }\n    [MethodImpl(256)]\n    public char ReadChar() {\n        char c;\n        while (!IsValidChar(c = read_raw())) { }\n        return c;\n    }\n    public string Line() {\n        sb.Clear();\n        for (var b = ReadChar(); b != '\\n' && !isEof; b = read_raw()) sb.Append(b);\n        return sb.ToString();\n    }\n    public string NextToken() {\n        sb.Clear();\n        for (var b = ReadChar(); IsValidChar(b); b = read_raw()) sb.Append(b);\n        return sb.ToString();\n    }\n    public long Integer() {\n        long ret;\n        char b;\n        var ng = false;\n        b = ReadChar();\n        if (b == '-') {\n            ng = true;\n            b = read_raw();\n        }\n        if (b >= '0' && b <= '9') {\n            ret = b - '0';\n        } else {\n            throw new Exception($\"bad symbol while parse integer: '{b}'\");\n        }\n        for (b = read_raw(); b >= '0' && b <= '9'; b = read_raw()) {\n            ret = ret * 10 + b - '0';\n        }\n        return ng ? -ret : ret;\n    }\n    [MethodImpl(256)] public double Double() => double.Parse(NextToken());\n    [MethodImpl(256)] public decimal Decimal() => decimal.Parse(NextToken());\n}\r\npublic static class Extension_Array {\n    public static void Fill<T>(this T[] array, T value) => Array.Fill(array, value);\n    public static void Fill<T>(this T[,] array, T value) => fill(array, value);\n    public static void Fill<T>(this T[,,] array, T value) => fill(array, value);\n    public static void Fill<T>(this T[,,,] array, T value) => fill(array, value);\n    public static void Fill<T>(this T[,,,,] array, T value) => fill(array, value);\n    [MethodImpl(256)]\n    static void fill<T>(Array array, T value) {\n        var data = MemoryMarshal.CreateSpan(\n            ref Unsafe.As<byte, T>(ref MemoryMarshal.GetArrayDataReference(array)),\n            array.Length);\n        data.Fill(value);\n    }\n    [MethodImpl(256)]\n    public static Span<T> Row<T>(this T[,] array, int i) {\n        var width = array.GetLength(1);\n        return MemoryMarshal.CreateSpan(ref array[i, 0], width);\n    }\n    public static IEnumerable<T> Column<T>(this T[,] array, int j) {\n        var hh = array.GetLength(0);\n        for (int h = 0; h < hh; h++) {\n            yield return array[h, j];\n        }\n    }\n    public static ref T get<T>(this T[,] arr, (int, int) i) { return ref arr[i.Item1, i.Item2]; }\n    public static ref T get<T>(this T[,] arr, (long, long) i) { return ref arr[i.Item1, i.Item2]; }\n}\r\npublic static class Extensions_Common\n{\n    public static string set(this string s, int i, char c) {\n        var a = s.ToCharArray();\n        a[i] = c;\n        return a.ToString();\n    }\n    public static char get(this string s, long i) {\n        return s[(int)i];\n    }\n    public static string JoinToStr(this char[] arr) {\n        return new string(arr);\n    }\n    public static void rev(this ref bool v) {  v = !v; }\n}\r\npublic static class Extension_IEnum {\n    public static IEnumerable<long> iota(this long v) { for (int i = 0; i < v; i++) { yield return i; } }\n    public static IEnumerable<long> iota(this int v) { for (int i = 0; i < v; i++) { yield return i; } }\n    public static long Count<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate) => source.LongCount(predicate);\n    public static IEnumerable<(T val, int i)> Track<T>(this IEnumerable<T> enumeration)\n        => enumeration.Select((x, i) => (x, i));\n    public static IEnumerable<(T val, int i)> Sort_track<T>(this IEnumerable<T> lst) {\n        return lst.Select((x, index) => (x, index)).OrderBy(x => x.x); }\n    public static string JoinToStr<T>(this IEnumerable<T> lst, string delim = \"\") {\n        return string.Join(delim, lst);\n    }\n    public static SortedSet<T> ToSortedSet<T>(this IEnumerable<T> lst) {\n        return new SortedSet<T>(lst);\n    }\n    public static IEnumerable<T> Reversed<T>(this IEnumerable<T> lst) {\n        return lst.Reverse();\n    }\n}\r\nstatic public partial class IOBase {\n    public static StringBuilder Output { get; private set; } = new StringBuilder();\n    static void _track_output<T>(T v) {\n#if INTERNAL_VER\n        Output.Append(v.ToString());\n#endif\n    }\n    static public void put_raw<T>(T v) {\n        _track_output(v);\n        Console.Write(v.ToString());\n    }\n    public static void put(char v) { _track_output(v); Console.Write(v); }\n    public static void print(char v) { put(v); put('\\n'); }\n    public static void put_sp(char v) { put(v); put(' '); }\n    public static void put(long v) { _track_output(v); Console.Write((long)v); }\n    public static void print(long v) { put(v); put('\\n'); }\n    public static void put_sp(long v) { put(v); put(' '); }\n    static public void put<T>(T v) {\n        if (v is IEnumerable vv && v is not string) {\n            foreach (var item in vv) {\n                put_raw(item);\n                put_raw(' ');\n            }\n        } else {\n            put_raw(v);\n        }\n    }\n    static public void print() { put('\\n'); }\n    static public void print<T>(T v) { put(v); put('\\n'); }\n    static public void print<Q, W>(Q q, W w) { put(q); put(' '); put(w); put('\\n'); }\n    static public void print<Q, W, G>(Q q, W w, G g) { put(q); put(' '); put(w); put(' '); put(g); put('\\n'); }\n    static public void put_sp<T>(T v) { put(v); put(' '); }\n    static public void yes(bool cond) { print(cond ? \"Yes\": \"No\"); }\n    static public void done() { throw new _DoneException(); }\n    static public void done<T>(T v) { print(v); done(); }\n    static public void done<Q, W>(Q q, W w) { print(q, w); done(); }\n}\r\nclass _DoneException : Exception { }\npublic class Starter {\n    public static void Start(string[] args, Action solve) {\n        if (!ProgramUtils.IsInternal) {\n            if(AutoFlash == false)\n                Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n            IOBase.Reinit(Console.OpenStandardInput());\n            _Start(solve);\n            Console.Out.Flush();\n        } else {\n            var tm = Stopwatch.StartNew();\n            string res = \"OK\";\n            for (int i = 0; i < TestInput.Length; i++) {\n                IOBase.Reinit(new MemoryStream(Encoding.UTF8.GetBytes(TestInput[i].Trim())));\n                IOBase.Output.Clear();\n                _Start(solve);\n                if (res is \"OK\") {\n                    res = CheckOutput(CorOutput[i]);\n                    if (res != \"OK\")\n                        res = $\"FAILED{(TestInput.Length == 1 ? \"\" : $\" {i + 1}\")}: {res}\";\n                }\n            }\n            Console.Write(\"\\n\");\n            Console.WriteLine(res is \"OK\" ? \"Checked: OK\" : res);\n            Console.WriteLine($\"\\n------\\nElapsed: {tm.ElapsedMilliseconds}. Build: {(ProgramUtils.IsDebug ? \"DEBUG\" : \"RELEASE\")}\");\n        }\n    }\n    static void _Start(Action solve) {\n        void test_wrap() { try { solve(); } catch (_DoneException) { } }\n        if (HasTestCase) {\n            var test = IOBase.geti();\n            while (test-- > 0) test_wrap();\n        } else {\n            test_wrap();\n        }\n        if (ProgramUtils.IsInternal) {\n            while (IOBase.HasInput) test_wrap();\n        }\n    }\n    static string CheckOutput(string output) {\n        var delims = new char[] { '\\r', '\\n', '\\t', ' ' };\n        var cor = output.Split(delims, StringSplitOptions.RemoveEmptyEntries);\n        var wrong = IOBase.Output.ToString().Split(delims, StringSplitOptions.RemoveEmptyEntries);\n        if (cor.Length != wrong.Length) {\n            return $\"bad length: cor={cor.Length} our={wrong.Length}\";\n        } else {\n            for (int i = 0; i < wrong.Length; i++) {\n                var cur_cor = cor[i];\n                if (cur_cor != wrong[i]) {\n                    var cur_cor_low = cur_cor.ToLower();\n                    if (cur_cor_low == wrong[i].ToLower() && (cur_cor_low is \"yes\" or \"no\")) {\n                    } else {\n                        return $\"bad {i + 1}th answ: cor={cur_cor} our={wrong[i]}\";\n                    }\n                }\n            }\n            return \"OK\";\n        }\n    }\n}\r\npublic class ProblemData {\n    static public string[] TestInput = { };\n    static public string[] CorOutput = { };\n    static public EasyBool HasTestCase = true;\n    static public EasyBool AutoFlash = false;\n}\r\npublic struct EasyBool{\n    bool val;\n    public EasyBool() { val = false; }\n    public static implicit operator bool(EasyBool v) { return v.val; }\n    public static implicit operator EasyBool(bool v) { return new EasyBool { val = v }; }\n    public static implicit operator EasyBool(int v) { return new EasyBool { val = v!=0 }; }\n}\r\npublic class ProgramUtils {\n    static public bool IsDebug {\n        [MethodImpl(256)]\n        get {\n#if DEBUG\n            return true;\n#else\n                return false;\n#endif\n        }\n    }\n    static public bool IsInternal {\n        [MethodImpl(256)]\n        get {\n#if INTERNAL_VER\n            return true;\n#else\n            return false;\n#endif\n        }\n    }\n}\r\npublic class IOExt {\n    static public Vec<long> getv(long n) {\n        var res = new Vec<long>();\n        res.Capacity = (int)n;\n        for (int i = 0; i < n; i++) {\n            res.Add(IOBase.geti());\n        }\n        return res;\n    }\n    static public Vec<int> getv32(long n) {\n        var res = new Vec<int>();\n        res.Capacity = (int)n;\n        for (int i = 0; i < n; i++) {\n            res.Add(IOBase.geti32());\n        }\n        return res;\n    }\n    static public Vec<T> getv<T>(long n, Func<T> getter) {\n        var res = new Vec<T>();\n        res.Capacity = (int)n;\n        for (int i = 0; i < n; i++) {\n            res.Add(getter());\n        }\n        return res;\n    }\n    static public IEnumerable<long> gete(long n) {\n        for (int i = 0; i < n; i++) {\n            yield return IOBase.geti();\n        }\n    }\n    static public IEnumerable<T> gete<T>(long n, Func<T> getter) {\n        for (int i = 0; i < n; i++) {\n            yield return getter();\n        }\n    }\n    static public IEnumerable<T> gete<T>(long n, Func<int,T> getter) {\n        for (int i = 0; i < n; i++) {\n            yield return getter(i);\n        }\n    }\n    static public T[,] getarr<T>(long h, long width, Func<T> getter) {\n        var res = new T[h, width];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < width; j++) {\n                res[i, j] = getter();\n            }\n        }\n        return res;\n    }\n    static public Vec<int> gets_d() {\n        var s = IOBase.gets();\n        Vec<int> res = new();\n        res.Capacity = s.Length;\n        foreach (var it in s) {\n            res.Add(it - '0');\n        }\n        return res;\n    }\n    static public Vec<char> gets_c() { return IOBase.gets().ToVec(); }\n}\r\npublic class Vec<T> : List<T> {\n    public Vec() { }\n    public Vec(long v) : base(Enumerable.Repeat<T>(default, (int)v)) { }\n    public Vec(long v, T init) : base(Enumerable.Repeat(init, (int)v)) { }\n    public Vec(long v, Func<long,T> creator) {\n        Capacity = (int)v;\n        for(long i = 0; i < v; i++) {\n            Add(creator(i));\n        }\n    }\n    public Vec(IEnumerable<T> v) : base(v) { }\n    public ref T this[long i] => ref CollectionsMarshal.AsSpan(this)[(int)i];\n    public new ref T this[int i] => ref CollectionsMarshal.AsSpan(this)[i];\n    public ref T Back =>  ref this[^1];\n    public ref T Front => ref this[0];\n    public bool IsEmpty => Count == 0;\n    public bool Has => Count != 0;\n    public int Length => Count;\n    public override string ToString() {\n        return string.Join(' ', this);\n    }\n    public void Fill(T v) => this.AsSpan().Fill(v);\n}\npublic class Vec : Vec<long> {\n    public Vec() { }\n    public Vec(long v) : base(Enumerable.Repeat<long>(default, (int)v)) { }\n    public Vec(long v, Func<long, long> creator) {\n        Capacity = (int)v;\n        for (long i = 0; i < v; i++) {\n            Add(creator(i));\n        }\n    }\n    public Vec(long v, long init) : base(Enumerable.Repeat(init, (int)v)) {    }\n    public Vec(IEnumerable<long> v) : base(v) { }\n}\npublic static class Extension_ToVec {\n    public static Vec<T> ToVec<T>(this IEnumerable<T> lst) => new Vec<T>(lst);\n}\r\npublic static class Extensions_List\n{\n    public static void SortDesc<T>(this List<T> lst) {\n        lst.Sort((a, b) => Comparer<T>.Default.Compare(b, a));\n    }\n    [MethodImpl(256)] public static T PopBack<T>(this List<T> lst) { var res = lst[^1]; lst.RemoveAt(lst.Count - 1); return res; }\n    [MethodImpl(256)] public static void swap<T>(this List<T> a, long i1, long i2) { var t = a[(int)i1]; a[(int)i1] = a[(int)i2]; a[(int)i2] = t; }\n    [MethodImpl(256)]\n    public static void Resize<T>(this List<T> list, int size) {\n        int count = list.Count;\n        if (size < count) {\n            list.RemoveRange(size, count - size);\n        } else{\n            list.EnsureSize(size);\n        }\n    }\n    [MethodImpl(256)]\n    public static void EnsureSize<T>(this List<T> list, int size) {\n        while(list.Count < size) list.Add(default);\n    }\n    [MethodImpl(256)] public static Span<T> AsSpan<T>(this List<T> lst) => CollectionsMarshal.AsSpan(lst);\n    public static void Edit<TSource>(this List<TSource> source, Func<TSource, TSource> predicate) {\n        foreach (ref var elem in source.AsSpan()) {\n            elem = predicate(elem);\n        }\n    }\n}\r\nstatic public class Math1 {\n    public static long inf { get; private set; } = long.MaxValue / 2;\n    public static long Sum1n(long n) { if (n <= 0) return 0; return (n * n + n) / 2; }\n    public static long Sum1n_sqr(long n) { if (n <= 0) return 0; return ((n + 1) * n * (2 * n + 1)) / 6; }\n    public static long Abs(long a) { return Math.Abs(a); }\n    public static int Abs(int a) { return Math.Abs(a); }\n    public static double Abs(double a) { return Math.Abs(a); }\n    public static int Max(int a, int b) { return Math.Max(a, b); }\n    public static long Max(long a, long b) { return Math.Max(a, b); }\n    public static long Min(long a, long b) { return Math.Min(a, b); }\n    public static long Max(params long[] numbers) { return numbers.Max(); }\n    public static long Min(params long[] numbers) { return numbers.Min(); }\n    public static double Min(params double[] numbers) { return numbers.Min(); }\n    public static double Max(params double[] numbers) { return numbers.Max(); }\n    public static void Sort(ref long a, ref long b) {\n        if (a > b) Swap(ref a, ref b);\n    }\n    public static long GCD(long a, long b) {\n        while (b != 0) {\n            var tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a < 0 ? -a : a;\n    }\n    public static long GCD(params long[] numbers) { return GCD(numbers); }\n    public static long GCD(IEnumerable<long> numbers) { return numbers.Aggregate(GCD); }\n    public static long LCM(long a, long b) { return a / GCD(a, b) * b; }\n    public static long Pow(long bs, long exp) {\n        Debug.Assert(exp >= 0);\n        long result = 1;\n        for (; exp > 0; exp >>= 1) {\n            if ((exp & 1) != 0)\n                result *= bs;\n            bs *= bs;\n        }\n        return result;\n    }\n    public static long Log(long val, long k) {\n        Debug.Assert(k > 1);\n        long test = 1;\n        long cnt = 0;\n        while (test < val) { test *= k; ++cnt; }\n        if (test != val) { cnt--; }\n        return cnt;\n    }\n    public static long Log_up(long val, long k) {\n        Debug.Assert(k > 1);\n        long test = 1;\n        long cnt = 0;\n        while (test < val) { test *= k; ++cnt; }\n        return cnt;\n    }\n    public static void Swap<T>(ref T a, ref T b) {\n        var tmp = a;\n        a = b;\n        b = tmp;\n    }\n}\r\n"
}