{
    "id": 169526774,
    "contestId": 1109,
    "creationTimeSeconds": 1661351253,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1109,
        "index": "F",
        "name": "Sasha and Algorithm of Silence's Sounds",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1109,
        "members": [
            {
                "handle": "SunsetSamsara"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1550334900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 62,
    "timeConsumedMillis": 327,
    "memoryConsumedBytes": 43008000,
    "source": "// \u66b4\u529b\u679a\u4e3e\u533a\u95f4\uff01\uff08\u4e0d\u662f\r\n// \u56fa\u5b9a l\uff0c\u5982\u679c\u56fe\u4e2d\u6709\u73af\u5219\u589e\u5927 r \u540e\u73af\u4f9d\u7136\u5b58\u5728\u3002\u968f\u7740 l \u7684\u589e\u5927\uff0cr \u662f\u4e0d\u51cf\u7684\r\n// \u7ef4\u62a4 LCT \u5224\u73af\r\n// \u7ef4\u62a4\u7ebf\u6bb5\u6811\u6c42\u7b54\u6848\r\n// \u8bbe\u533a\u95f4 [1, mn] \u4e3a\u4ee5\u5f53\u524d l \u4e3a\u5de6\u8fb9\u754c\uff0c\u6539\u53d8\u53f3\u8fb9\u754c\u7684\u6811\u7684\u72b6\u6001\u3002\u8fd9\u65f6\u53ea\u8981\u7edf\u8ba1\u6700\u5c0f\u503c\u6570\u91cf\u3002\r\n// \u5f53\u589e\u52a0 r \u65f6\u5c31\u76f4\u63a5\u7528 lct \u5224\u65ad\u662f\u5426\u5408\u5e76\u4e86\u6811\u540c\u65f6\u4fee\u6539\u7b54\u6848\u3002\r\n// \u5f53\u589e\u52a0 l \u65f6\u8981\u4e48\u4e0d\u65ad\u8fb9\uff0c\u8981\u4e48\u65ad1\u6761\u8fb9\uff0c\u8981\u4e48\u65ad\u591a\u6761\u8fb9\u3002\r\n#include <stdio.h>\r\n#include <algorithm>\r\n#define lld long long\r\nusing namespace std;\r\nconst int N = 200010;\r\nstruct LCT {\r\n\tint top;\r\n\tint sons[300001][2];\r\n\tint fa[300001];\r\n\tint q[300001];\r\n\tint rev[300001];\r\n\tvoid pushdown(int id){\r\n\t\tint l=sons[id][0],r=sons[id][1];\r\n\t\tif(rev[id]){\r\n\t\t\trev[l]^=1;rev[r]^=1;rev[id]^=1;\r\n\t\t\tswap(sons[id][0],sons[id][1]);\r\n\t\t}\r\n\t}\r\n\tbool isroot(int id){return (sons[fa[id]][0]!=id&&sons[fa[id]][1]!=id)||fa[id]==0;}\r\n\tvoid rotate(int id){\r\n\t\tint f=fa[id],ff=fa[f],l,r;\r\n\t\tif(sons[f][0]==id)l=0;else l=1;r=l^1;\r\n\t\tif(!isroot(f)){\r\n\t\t\tif(sons[ff][0]==f)sons[ff][0]=id;\r\n\t\t\telse sons[ff][1]=id;\r\n\t\t}\r\n\t\tfa[id]=ff;fa[f]=id;fa[sons[id][r]]=f;\r\n\t\tsons[f][l]=sons[id][r];sons[id][r]=f;\r\n\t}\r\n\tvoid splay(int id){\r\n\t\ttop=1;q[top]=id;\r\n\t\tfor(int i=id;!isroot(i);i=fa[i])q[++top]=fa[i];\r\n\t\tfor(int i=top;i;--i)pushdown(q[i]);\r\n\t\tint f,ff;\r\n\t\twhile(!isroot(id)){\r\n\t\t\tf=fa[id];ff=fa[f];\r\n\t\t\tif(!isroot(f)){\r\n\t\t\t\tif((sons[f][0]==id)^(sons[ff][0]==f))rotate(id);\r\n\t\t\t\telse rotate(f);\r\n\t\t\t}\r\n\t\t\trotate(id);\r\n\t\t}\r\n\t}\r\n\tvoid access(int id){\r\n\t\tfor(int t=0;id;t=id,id=fa[id])\r\n\t\t\tsplay(id),sons[id][1]=t;\r\n\t}\r\n\tvoid makeroot(int id){\r\n\t\taccess(id);\r\n\t\tsplay(id);\r\n\t\trev[id]^=1;\r\n\t}\r\n\tint findroot(int id){\r\n\t\taccess(id);\r\n\t\tsplay(id);\r\n\t\twhile(sons[id][0])pushdown(id),id=sons[id][0];\r\n\t\tsplay(id);\r\n\t\treturn id;\r\n\t}\r\n\tvoid cut(int x,int y){\r\n\t\tmakeroot(x);\r\n\t\tif(findroot(y)==x&&fa[y]==x&&sons[y][0]==0)\r\n\t\t\tsons[x][1]=0,fa[y]=0;\r\n\t}\r\n\tvoid link(int x,int y){\r\n\t\tmakeroot(x);\r\n\t\tfa[x]=y;\r\n\t}\r\n\tinline bool connected(int x, int y) {\r\n\t\treturn findroot(x) == findroot(y);\r\n\t}\r\n} T1;\r\nstruct SGT {\r\n\tstruct node {\r\n\t\tint l, r;\r\n\t\tint mn, cnt, det;\r\n\t\tbool tag;\r\n\t} tr[N << 2];\r\n\tinline void pushup(int k) {\r\n\t\tif (tr[k << 1].mn == tr[k << 1 | 1].mn) {\r\n\t\t\ttr[k].mn = tr[k << 1].mn;\r\n\t\t\ttr[k].cnt = tr[k << 1].cnt + tr[k << 1 | 1].cnt;\r\n\t\t} else if (tr[k << 1].mn < tr[k << 1 | 1].mn)\r\n\t\t\ttr[k].mn = tr[k << 1].mn, tr[k].cnt = tr[k << 1].cnt;\r\n\t\telse tr[k].mn = tr[k << 1 | 1].mn, tr[k].cnt = tr[k << 1 | 1].cnt;\r\n\t}\r\n\tinline void build(int k, int l, int r) {\r\n\t\ttr[k].l = l, tr[k].r = r;\r\n\t\tif (l == r) return;\r\n\t\tint mid = (l + r) >> 1;\r\n\t\tbuild(k << 1, l, mid);\r\n\t\tbuild(k << 1 | 1, mid + 1, r);\r\n\t}\r\n\tinline void pushdown(int k) {\r\n\t\tif (tr[k].tag) {\r\n\t\t\ttr[k << 1].mn += tr[k].det, tr[k << 1 | 1].mn += tr[k].det;\r\n\t\t\ttr[k << 1].det += tr[k].det, tr[k << 1 | 1].det += tr[k].det;\r\n\t\t\ttr[k << 1].tag = tr[k << 1 | 1].tag = 1;\r\n\t\t\ttr[k].tag = 0;\r\n\t\t\ttr[k].det = 0;\r\n\t\t}\r\n\t}\r\n\tinline void modify(int k, int l, int r, int d) {\r\n//\t\tprintf(\"modify %d(%d~%d) %d %d %d\\n\", k, tr[k].l, tr[k].r, l, r, d);\r\n\t\tif (l <= tr[k].l && tr[k].r <= r) {\r\n\t\t\ttr[k].mn += d;\r\n\t\t\ttr[k].det += d;\r\n\t\t\ttr[k].tag = 1;\r\n//\t\t\tprintf(\"modify ends %d(%d~%d) %d %d %d\\n\", k, tr[k].l, tr[k].r, l, r, d);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpushdown(k);\r\n\t\tint mid = (tr[k].l + tr[k].r) >> 1;\r\n\t\tif (l <= mid) modify(k << 1, l, r, d);\r\n\t\tif (mid < r) modify(k << 1 | 1, l, r, d);\r\n\t\tpushup(k);\r\n//\t\tprintf(\"modify ends %d(%d~%d) %d %d %d\\n\", k, tr[k].l, tr[k].r, l, r, d);\r\n\t}\r\n\tinline int query(int k, int l, int r) {\r\n//\t\tprintf(\"query %d(%d~%d) %d %d\\n\", k, tr[k].l, tr[k].r, l, r);\r\n\t\tif (l <= tr[k].l && tr[k].r <= r) {\r\n//\t\t\tprintf(\"query ends %d(%d~%d) %d %d\\n\", k, tr[k].l, tr[k].r, l, r);\r\n\t\t\tif (tr[k].mn != 1) return 0;\r\n\t\t\treturn tr[k].cnt;\r\n\t\t}\r\n\t\tpushdown(k);\r\n\t\tint mid = (tr[k].l + tr[k].r) >> 1;\r\n\t\tint res = 0;\r\n\t\tif (l <= mid) res = query(k << 1, l, r);\r\n\t\tif (mid < r) res += query(k << 1 | 1, l, r);\r\n//\t\tprintf(\"query ends %d(%d~%d) %d %d\\n\", k, tr[k].l, tr[k].r, l, r);\r\n\t\treturn res;\r\n\t}\r\n} T2;\r\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\r\nint posx[N], posy[N];\r\nint mp[2010][2010], n, m;\r\ninline int get(int x, int y) {\r\n\treturn (0 <= x && x < n && 0 <= y && y < m) ? mp[x][y] : -1;\r\n}\r\nint main() {\r\n\tscanf(\"%d%d\", &n, &m);\r\n\tint p2 = 1;\r\n\tfor (; p2 < n * m; p2 <<= 1);\r\n\tfor (int i = 0; i < n; ++ i)\r\n\t\tfor (int j = 0; j < m; ++ j) {\r\n\t\t\tscanf(\"%d\", mp[i] + j);\r\n\t\t\tposx[mp[i][j]] = i;\r\n\t\t\tposy[mp[i][j]] = j;\r\n\t\t}\r\n\tT2.build(1, 1, p2);\r\n\tfor (int k = 1, cnt = p2, d = 1; k <= p2; d += k, k <<= 1, cnt >>= 1) {\r\n\t\tfor (int i = 0; i < k; ++ i)\r\n\t\t\tT2.tr[d + i].cnt = cnt;\r\n\t}\r\n\tlld ans = 0;\r\n\tint lnk[4], tot, cnt;\r\n\tfor (int l = 1, r = 0; l <= n * m; ++ l) {\r\n\t\tfor (int r2 = r + 1; r2 <= n * m; ++ r2) {\r\n\t\t\ttot = 0, cnt = 0;\r\n\t\t\tbool flag = 0;\r\n\t\t\tfor (int d = 0; d < 4; ++ d) {\r\n\t\t\t\tint to = get(posx[r2] + dx[d], posy[r2] + dy[d]);\r\n\t\t\t\tif (to == -1 || to > r2 || to < l) continue;\r\n\t\t\t\tif (!T1.connected(r2, to)) T1.link(r2, to), lnk[tot ++] = to, ++ cnt;\r\n\t\t\t\telse {\r\n\t\t\t\t\tflag = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag) {\r\n\t\t\t\tfor (int i = 0; i < tot; ++ i) T1.cut(r2, lnk[i]);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tT2.modify(1, r2, n * m, 1 - cnt);\r\n\t\t\tr = r2;\r\n\t\t}\r\n\t\tans += T2.query(1, l, r);\r\n\t\ttot = 0;\r\n\t\tfor (int d = 0; d < 4; ++ d) {\r\n\t\t\tint to = get(posx[l] + dx[d], posy[l] + dy[d]);\r\n\t\t\tif (to == -1) continue;\r\n\t\t\tif (T1.connected(l, to)) T1.cut(l, to), lnk[tot ++] = to;\r\n\t\t}\r\n\t\tsort(lnk, lnk + tot);\r\n\t\tif (tot > 0) T2.modify(1, l, lnk[0] - 1, -1);\r\n\t\telse T2.modify(1, l, m * n, -1);\r\n\t\tfor (int i = 1; i < tot; ++ i) if (!T1.connected(lnk[i - 1], lnk[i]))\r\n\t\t\tT2.modify(1, lnk[i], m * n, 1);\r\n\t}\r\n\tprintf(\"%lld\\n\", ans);\r\n}"
}