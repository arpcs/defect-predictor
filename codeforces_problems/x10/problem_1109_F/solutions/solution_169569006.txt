{
    "id": 169569006,
    "contestId": 1109,
    "creationTimeSeconds": 1661398023,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1109,
        "index": "F",
        "name": "Sasha and Algorithm of Silence's Sounds",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1109,
        "members": [
            {
                "handle": "DisconnectedGraph"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1550334900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "//Code by fjy666(https://www.luogu.com.cn/user/366338)\r\n//luogu-judger-enable-O2\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define _rep(i_,a_,b_) for(int i_ = (a_); i_ <= (b_); ++i_)\r\n#define _for(i_,a_,b_) for(int i_ = (a_); i_ < (b_); ++i_)\r\n#define mid ((L+R) >> 1)\r\n#define get(x) (((x) - 1) / kb + 1)\r\n#define multiCase() int testCnt = in(); _rep(curCase,1,testCnt)\r\n#define multi(init) int testCnt = (init); _rep(curCase,1,testCnt)\r\n#ifdef ONLINE_JUDGE\r\n#define debug(...) \r\n#else\r\n#define debug(...) fprintf(stderr, __VA_ARGS__)\r\n#endif\r\ntypedef long long ll;\r\n\r\nint in(void) { int x; scanf(\"%d\", &x); return x; }\r\nll inl(void) { ll x; scanf(\"%lld\", &x); return x; }\r\ntemplate<typename T> void chkmax(T &a, const T &b) { a = max(a, b); } \r\ntemplate<typename T> void chkmin(T &a, const T &b) { a = min(a, b); } \r\nconst int p = 1000000007;\r\nint fpm(int a, int b, int P = p) {\r\n\ta = (a % P + P) % P;\r\n\tint res = 1 % P;\r\n\tfor(;b; b >>= 1, a = 1ll * a * a % P) if(b & 1) res = 1ll * res * a % P;\r\n\treturn res;\r\n}\r\nint reduce(int x) { return (x % p + p) % p; }\r\nint add(int x, int y) { return reduce(x + y); }\r\nint sub(int x, int y) { return reduce(x - y); }\r\nint mul(int x, int y) { return reduce(1ll * x * y % p); }\r\nint divide(int x, int y) { return mul(x, fpm(y, p - 2)); }\r\nconst int kN = 1200, kM = 200500, dir[][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}}, inf = 0x3f3f3f3f;\r\nint cell[kN][kN], n = in(), m = in(), used[kN][kN];\r\npair<int,int> inv[kM];\r\n\r\nnamespace LCT {\r\n\tint fa[kM], ch[kM][2], rev[kM];\r\n\tint identify(int x) { return ch[fa[x]][0] == x ? 0 : (ch[fa[x]][1] == x ? 1 : -1); }\r\n\tvoid pushdown(int x) {\r\n\t\tif(rev[x]) {\r\n\t\t\tswap(ch[x][0], ch[x][1]);\r\n\t\t\trev[ch[x][0]] ^= 1;\r\n\t\t\trev[ch[x][1]] ^= 1;\r\n\t\t\trev[x] = 0;\r\n\t\t}\r\n\t}\r\n\tvoid pushall(int x) { if(identify(x) != -1) pushall(fa[x]); pushdown(x); }\r\n\tvoid rotate(int x) {\r\n\t\tint y = fa[x], z = fa[y], d = identify(x);\r\n\t\tfa[ch[x][d ^ 1]] = y, ch[y][d] = ch[x][d ^ 1];\r\n\t\tif(identify(y) != -1) ch[z][identify(y)] = x; fa[x] = z;\r\n\t\tfa[y] = x, ch[x][d ^ 1] = y;\r\n\t}\r\n\tvoid splay(int x) { pushall(x);\r\n\t\twhile(identify(x) != -1) { int y = fa[x];\r\n\t\t\tif(identify(y) != -1) rotate(identify(x) == identify(y) ? y : x);\r\n\t\t\trotate(x);\r\n\t\t}\r\n\t}\r\n\tvoid access(int x) { for(int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y; }\r\n\tvoid makeroot(int x) { access(x), splay(x), rev[x] ^= 1; }\r\n\tint findroot(int x) {\r\n\t\taccess(x), splay(x), pushdown(x);\r\n\t\twhile(ch[x][0]) pushdown(x = ch[x][0]);\r\n\t\treturn x;\r\n\t}\r\n\tbool link(int x, int y) {\r\n\t\tdebug(\"Link %d <=> %d\\n\", x, y);\r\n\t\tif(findroot(x) == findroot(y)) return false;\r\n\t\tmakeroot(x), fa[x] = y; return true;\r\n\t}\r\n\tvoid cut(int x, int y) {\r\n\t\tdebug(\"Cut %d <=> %d\\n\", x, y);\r\n\t\tassert(findroot(x) == findroot(y));\r\n\t\tmakeroot(x), access(y), splay(y);\r\n\t\tassert(ch[y][0] == x && fa[x] == y && !ch[x][1]);\r\n\t\tfa[x] = ch[y][0] = 0;\r\n\t}\r\n}\r\n\r\nnamespace SegmentTree {\r\n\tint mn[kM << 2], cnt[kM << 2], tag[kM << 2];\r\n\tvoid pushdown(int x) {\r\n\t\tif(tag[x]) {\r\n\t\t\tmn[x << 1] += tag[x];\r\n\t\t\tmn[x << 1 | 1] += tag[x];\r\n\t\t\ttag[x << 1] += tag[x];\r\n\t\t\ttag[x << 1 | 1] += tag[x];\r\n\t\t\ttag[x] = 0;\r\n\t\t}\r\n\t}\r\n\tvoid pushup(int x) {\r\n\t\tif(mn[x << 1] < mn[x << 1 | 1]) mn[x] = mn[x << 1], cnt[x] = cnt[x << 1];\r\n\t\telse if(mn[x << 1 | 1] < mn[x << 1]) mn[x] = mn[x << 1 | 1], cnt[x] = cnt[x << 1 | 1];\r\n\t\telse mn[x] = mn[x << 1], cnt[x] = cnt[x << 1] + cnt[x << 1 | 1];\r\n\t}\r\n\tvoid build(int x, int L, int R) {\r\n\t\tif(L == R) { cnt[x] = 1; return; }\r\n\t\tbuild(x << 1, L, mid); build(x << 1 | 1, mid + 1, R);\r\n\t\tpushup(x);\r\n\t}\r\n\tvoid add(int x, int L, int R, int l, int r, int delta) {\r\n\t\tif(l <= L && R <= r) { mn[x] += delta; tag[x] += delta; return; }\r\n\t\tpushdown(x);\r\n\t\tif(l <= mid) add(x << 1, L, mid, l, r, delta); if(mid < r) add(x << 1 | 1, mid + 1, R, l, r, delta);\r\n\t\tpushup(x);\r\n\t}\r\n\tpair<int,int> query(int x, int L, int R, int l, int r) {\r\n\t\tif(l <= L && R <= r) return make_pair(mn[x], cnt[x]);\r\n\t\tpushdown(x);\r\n\t\tif(r <= mid) return query(x << 1, L, mid, l, r); if(mid < l) return query(x << 1 | 1, mid + 1, R, l, r);\r\n\t\tpair<int,int> ansL = query(x << 1, L, mid, l, r), ansR = query(x << 1 | 1, mid + 1, R, l, r);\r\n\t\tif(ansL.first != ansR.first) return make_pair(min(ansL.first, ansR.first), (ansL.first < ansR.first ? ansL.second : ansR.second));\r\n\t\telse return make_pair(ansL.first, ansL.second + ansR.second);  \r\n\t}\r\n}\r\n\r\n#define encode(i, j) ((i - 1) * m + j)\r\nbool add(int x) {\r\n\tdebug(\"Trying to add %d\\n\", x);\r\n\t// auto &[px, py] = inv[x];\r\n\tint px = inv[x].first, py = inv[x].second;\r\n\tused[px][py] = 1;\r\n\t_for(i,0,4) {\r\n\t\tint dx = px + dir[i][0], dy = py + dir[i][1];\r\n\t\tdebug(\"dx = %d, dy = %d\\n\", dx, dy);\r\n\t\tif(used[dx][dy] && !LCT::link(cell[dx][dy], cell[px][py])) {\r\n\t\t\t_for(j,0,i) {\r\n\t\t\t\tdx = px + dir[j][0], dy = py + dir[j][1];\r\n\t\t\t\tif(used[dx][dy]) LCT::cut(cell[dx][dy], cell[px][py]);\r\n\t\t\t}\r\n\t\t\tused[px][py] = 0;\r\n\t\t\tdebug(\"Failed!\\n\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tdebug(\"Succeed!\\n\");\r\n\treturn true;\r\n}\r\n\r\nvoid del(int x) {\r\n\tdebug(\"Del %d\\n\", x);\r\n\t// auto &[px, py] = inv[x];\r\n\tint px = inv[x].first, py = inv[x].second;\r\n\tused[px][py] = 0;\r\n\t_for(i,0,4) {\r\n\t\tint dx = px + dir[i][0], dy = py + dir[i][1];\r\n\t\tif(used[dx][dy]) LCT::cut(cell[dx][dy], cell[px][py]);\r\n\t}\r\n}\r\n\r\nint main() { \r\n\t_rep(i,1,n) _rep(j,1,m) cell[i][j] = in(), inv[cell[i][j]] = make_pair(i, j);\r\n\tll ans = 0;\r\n\tSegmentTree::build(1, 1, n * m);\r\n\tfor(int l = 1, r = 1; r <= n * m; ++r) {\r\n\t\twhile(!add(r)) del(l++);\r\n\t\t// auto &[rx, ry] = inv[r];\r\n\t\tint rx = inv[r].first, ry = inv[r].second;\r\n\t\tSegmentTree::add(1, 1, n * m, l, r, 1); debug(\"Add [%d, %d]\\n\", l, r);\r\n\t\t_for(i,0,4) {\r\n\t\t\tint dx = rx + dir[i][0], dy = ry + dir[i][1];\r\n\t\t\tif(used[dx][dy]) SegmentTree::add(1, 1, n * m, l, cell[dx][dy], -1), debug(\"Del [%d, %d]\\n\", l, cell[dx][dy]);\t\t\r\n\t\t}\r\n\t\tpair<int, int> cur = SegmentTree::query(1, 1, n * m, l, r);\r\n\t\tassert(cur.first == 1);\r\n\t\tans += SegmentTree::query(1, 1, n * m, l, r).second;\r\n\t}\r\n\tprintf(\"%lld\\n\", ans);\r\n\treturn 0;\r\n}\r\n\r\n/* \r\na list of keywords\r\nclear empty push_back pop_back push pop top front back\r\nemplace_back emplace push_front pop_front insert erase\r\nfind count set reset bitset map vector string multiset\r\nfirst second iterator prev next deque multimap reverse\r\nsort begin end list modify query init check calc prime \r\nputchar getchar puts scanf printf max min swap replace\r\n*/"
}