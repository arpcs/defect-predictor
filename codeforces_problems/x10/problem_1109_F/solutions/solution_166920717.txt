{
    "id": 166920717,
    "contestId": 1109,
    "creationTimeSeconds": 1659618324,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1109,
        "index": "F",
        "name": "Sasha and Algorithm of Silence's Sounds",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1109,
        "members": [
            {
                "handle": "CQYZWJH"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1550334900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 18534400,
    "source": "#include <bits/stdc++.h>\r\n#define re(i, x, y) for (int i = (x); i < (y); ++i) \r\n#define rep(i, x, y) for (int i = (x); i <= (y); ++i)\r\n#define repp(i, x, y, d) for (int i = (x); i <= (y); i += (d))\r\n#define reep(i, x, y) for (int i = (x); i <= (y); i <<= 1)\r\n#define pe(i, x, y) for (int i = (x) - 1; i >= (y); --i)\r\n#define per(i, x, y) for (int i = (x); i >= (y); --i)\r\n#define rep_e(i, u) for (int i = head[(u)]; i; i = e[i].nxt)\r\n#define vi vector<int>\r\n#define vL vector<LL>\r\n#define vii vector<pii> \r\n#define viL vector<piL>\r\n#define vLi vector<pLi> \r\n#define vLL vector<pLL>\r\n#define eb emplace_back\r\n#define pb pop_back\r\n#define mp make_pair\r\n#define pii pair<int, int>\r\n#define piL pair<int, LL>\r\n#define pLi pair<LL, int>\r\n#define pLL pair<LL, LL>\r\n#define lowbit(x) ((x) & (-(x)))\r\n#define fi first\r\n#define se second\r\n#define all(x) x.begin(), x.end()\r\n#define debug(x) cout << #x << \" = \" << x << endl\r\nusing namespace std;\r\ntypedef unsigned int ui;\r\ntypedef long long LL;\r\ntypedef unsigned long long ULL;\r\ntypedef double db;\r\n#define getchar() (SB == TB && (TB = (SB = BB) + fread(BB, 1, 1 << 16, stdin), SB == TB) ? EOF : *SB++)\r\nchar BB[1 << 16], *SB = BB, *TB = BB;\r\ntemplate<typename T> void read(T &n) {\r\n\tT w = 1;\r\n\tn = 0;\r\n\tchar ch = getchar();\r\n\tfor ( ; !isdigit(ch); ch = getchar()) {\r\n\t\tif (ch == '-') {\r\n\t\t\tw = -1;\r\n\t\t}\r\n\t}\r\n\tfor ( ; isdigit(ch); ch = getchar()) {\r\n\t\tn = n * 10 + (ch & 15);\r\n\t}\r\n\tn *= w;\r\n}\r\ntemplate<typename T> void chkmn(T &a, const T &b) { \r\n\t(a > b) && (a = b); \r\n}\r\ntemplate<typename T> void chkmx(T &a, const T &b) { \r\n\t(a < b) && (a = b); \r\n}\r\n\r\nint MOD;\r\nint adt(const LL &a) { \r\n\treturn (a % MOD + MOD) % MOD; \r\n} \r\nint inc(const int &a, const int &b) { \r\n\treturn a + b >= MOD ? a + b - MOD : a + b; \r\n}\r\nint dec(const int &a, const int &b) { \r\n\treturn a - b < 0 ? a - b + MOD : a - b; \r\n}\r\nint mul(const int &a, const int &b) { \r\n\treturn 1LL * a * b % MOD; \r\n}\r\nint sqr(const int &a) { \r\n\treturn 1LL * a * a % MOD; \r\n}\r\nvoid Adt(LL &a) {\r\n\ta = (a % MOD + MOD) % MOD;\r\n}\r\nvoid Inc(int &a, const int &b) { \r\n\t((a += b) >= MOD) && (a -= MOD); \r\n}\r\nvoid Dec(int &a, const int &b) { \r\n\t((a -= b) < 0) && (a += MOD); \r\n}\r\nvoid Mul(int &a, const int &b) { \r\n\ta = 1LL * a * b % MOD; \r\n}\r\nvoid Sqr(int &a) { \r\n\ta = 1LL * a * a % MOD; \r\n}\r\nint fsp(int a, int x = MOD - 2) {\r\n\tint res = 1;\r\n\tfor ( ; x; x >>= 1, Sqr(a)) {\r\n\t\tif (x & 1) {\r\n\t\t\tMul(res, a);\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nconst int maxn = 1e3 + 5, maxN = 2e5 + 5, dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\r\nint n, m, N;\r\nint a[maxn][maxn];\r\npii p[maxN];\r\n\r\nnamespace SGT {\r\n    #define lc (id << 1)\r\n    #define rc (id << 1 | 1)\r\n    #define mid ((l + r) >> 1)\r\n    int tag[maxN * 4];\r\n    pii mn[maxN * 4];\r\n    pii operator + (pii x, pii y) {\r\n        int z = min(x.fi, y.fi);\r\n        return mp(z, (z == x.fi) * x.se + (z == y.fi) * y.se);\r\n    }\r\n    void Push_Up(int id) {\r\n        mn[id] = mn[lc] + mn[rc];\r\n    }\r\n    void Add_Tag(int id, int v) {\r\n        mn[id].fi += v, tag[id] += v;\r\n    }\r\n    void Push_Down(int id) {\r\n        if (tag[id]) {\r\n            Add_Tag(lc, tag[id]);\r\n            Add_Tag(rc, tag[id]);\r\n            tag[id] = 0;\r\n        }\r\n    }\r\n    void Build(int id = 1, int l = 1, int r = N) {\r\n        if (l == r) {\r\n            return mn[id] = mp(0, 1), void();\r\n        }\r\n        Build(lc, l, mid), Build(rc, mid + 1, r);\r\n        Push_Up(id);\r\n    }\r\n    void Update(int x, int y, int v, int id = 1, int l = 1, int r = N) {\r\n        if (x <= l && r <= y) {\r\n            return Add_Tag(id, v);\r\n        }\r\n        Push_Down(id);\r\n        if (x <= mid) {\r\n            Update(x, y, v, lc, l, mid);\r\n        }\r\n        if (y > mid) {\r\n            Update(x, y, v, rc, mid + 1, r);\r\n        }\r\n        Push_Up(id);\r\n    }\r\n    pii Query(int x, int y, int id = 1, int l = 1, int r = N) {\r\n        if (x <= l && r <= y) {\r\n            return mn[id];\r\n        }\r\n        Push_Down(id);\r\n        if (x > mid) {\r\n            return Query(x, y, rc, mid + 1, r);\r\n        } \r\n        if (y <= mid) {\r\n            return Query(x, y, lc, l, mid);\r\n        }\r\n        return Query(x, y, lc, l, mid) + Query(x, y, rc, mid + 1, r);\r\n    }\r\n    #undef lc\r\n    #undef rc\r\n}\r\nnamespace LCT {\r\n    #define lc ch[0]\r\n    #define rc ch[1]\r\n    struct node {\r\n        node *ch[2], *fa;\r\n        bool rev;\r\n        node() {\r\n            lc = rc = fa = NULL;\r\n            rev = 0;\r\n        }\r\n        void Reverse() {\r\n            swap(lc, rc);\r\n            rev ^= 1;\r\n        }\r\n        void Push_Down() {\r\n            if (rev) {\r\n                if (lc != NULL) {\r\n                    lc -> Reverse();\r\n                }\r\n                if (rc != NULL) {\r\n                    rc -> Reverse();\r\n                }\r\n                rev = 0;\r\n            }\r\n        }\r\n    } t[maxN];\r\n    #define Not_Root(x) (x -> fa != NULL && (x -> fa -> lc == x || x -> fa -> rc == x))\r\n    #define Which(x) (x -> fa -> rc == x)\r\n    void Rotate(node *x) {\r\n        node *y = x -> fa;\r\n        int k = Which(x);\r\n        if (Not_Root(y)) {\r\n            y -> fa -> ch[Which(y)] = x;\r\n        } \r\n        x -> fa = y -> fa;\r\n        if (x -> ch[k ^ 1] != NULL) {\r\n            x -> ch[k ^ 1] -> fa = y;\r\n        }\r\n        y -> ch[k] = x -> ch[k ^ 1];\r\n        x -> ch[k ^ 1] = y;\r\n        y -> fa = x;\r\n    }\r\n    void Spread(node *x) {\r\n        if (x -> fa != NULL) {\r\n            Spread(x -> fa);\r\n        }\r\n        x -> Push_Down();\r\n    }\r\n    void Splay(node *x) {\r\n        for (Spread(x); Not_Root(x); Rotate(x)) {\r\n            node *y = x -> fa;\r\n            if (Not_Root(y)) {\r\n                Rotate(Which(x) ^ Which(y) ? x : y);\r\n            }\r\n        }\r\n    }\r\n    void Access(node *x) {\r\n        for (node *y = NULL; x != NULL; x = (y = x) -> fa) {\r\n            Splay(x), x -> rc = y;\r\n        } \r\n    }\r\n    node *Find_Root(node *x) {\r\n        for (Access(x), Splay(x); x -> lc != NULL; x -> Push_Down(), x = x -> lc) ;\r\n        Splay(x);\r\n        return x;\r\n    }\r\n    void Make_Root(node *x) {\r\n        Access(x), Splay(x), x -> Reverse();\r\n    }\r\n    bool Link(node *x, node *y) {\r\n        Make_Root(x);\r\n        if (Find_Root(y) == x) {\r\n            return false;\r\n        }\r\n        x -> fa = y;\r\n        return true;\r\n    }\r\n    void Cut(node *x, node *y) {\r\n        Make_Root(x);\r\n        if (Find_Root(x) == y && y -> fa == x && y -> lc == NULL) {\r\n            x -> rc = y -> fa = NULL;\r\n        }\r\n    }\r\n}\r\nusing LCT::t;\r\n\r\nint main() {\r\n#ifdef sword \r\n\tfreopen(\"test.in\", \"r\", stdin);\r\n#endif\r\n\t\r\n    read(n), read(m);\r\n    N = n * m;\r\n    SGT::Build();\r\n    rep(i, 1, n) {\r\n        rep(j, 1, m) {\r\n            read(a[i][j]);\r\n            p[a[i][j]] = mp(i, j);\r\n        }\r\n    }\r\n\r\n    int l = 1, r;\r\n    LL ans = 0;\r\n\r\n    auto chk = [&] (int x, int y) {\r\n        return x >= 1 && y >= 1 && x <= n && y <= m;\r\n    };\r\n    auto del = [&] () {\r\n        int x = p[l].fi, y = p[l].se;\r\n        re(k, 0, 4) {\r\n            int xx = x + dx[k], yy = y + dy[k];\r\n            if (chk(xx, yy)) {\r\n                Cut(&t[l], &t[a[xx][yy]]);\r\n            }\r\n        }\r\n        ++l;\r\n    };\r\n\r\n    rep(i, 1, N) {\r\n        r = i;\r\n        int x = p[i].fi, y = p[i].se;\r\n        re(k, 0, 4) {\r\n            int xx = x + dx[k], yy = y + dy[k];\r\n            if (chk(xx, yy) && a[xx][yy] < i && l <= a[xx][yy]) {\r\n                for ( ; l <= a[xx][yy] && !LCT::Link(&t[a[xx][yy]], &t[i]); del()) ;\r\n            }\r\n        }\r\n        SGT::Update(l, r, 1);\r\n        re(k, 0, 4) {\r\n            int xx = x + dx[k], yy = y + dy[k];\r\n            if (chk(xx, yy) && a[xx][yy] < i && l <= a[xx][yy]) {\r\n                SGT::Update(l, a[xx][yy], -1);\r\n            }\r\n        }\r\n        pii p = SGT::Query(l, r);\r\n        ans += 1LL * (p.fi == 1) * p.se;\r\n    }\r\n    printf(\"%lld\\n\", ans);\r\n\treturn 0;\r\n}"
}