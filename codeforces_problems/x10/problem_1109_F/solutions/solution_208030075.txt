{
    "id": 208030075,
    "contestId": 1109,
    "creationTimeSeconds": 1685605710,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1109,
        "index": "F",
        "name": "Sasha and Algorithm of Silence's Sounds",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1109,
        "members": [
            {
                "handle": "Kocyk"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1550334900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 62,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 16076800,
    "source": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ll long long\r\n#define lll __int128\r\n#define ull unsigned long long\r\n#define fi first\r\n#define se second\r\n#define db double\r\n#define ld long double\r\n#define lld __float128\r\n\r\n/// order_of_key, find_by_order\r\n\r\ntemplate<class T, class COMP>\r\nusing custom_set = tree<T, null_type, COMP, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\ntemplate<class T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\ntemplate<class T>\r\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\ntemplate<class T, class U>\r\nusing ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\r\nmt19937_64 rnd_64(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nint dx[4] = {0, 1, 0, -1};\r\nint dy[4] = {1, 0, -1, 0};\r\n\r\nstruct node\r\n{\r\n    node *p, *l, *r;\r\n    bool rev = 0;\r\n    int ind = 0;\r\n\r\n    node()\r\n    {\r\n        p = l = r = 0;\r\n        rev = 0;\r\n    }\r\n};\r\n\r\nbool is_root(node *v)\r\n{\r\n    if(!v) return 1;\r\n    if(!v->p) return 1;\r\n    return (v->p->l != v && v->p->r != v);\r\n}\r\n\r\nvector<node> lct;\r\n\r\nvoid init(int n)\r\n{\r\n    lct = vector<node>(n);\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        lct[i] = node();\r\n        lct[i].ind = i;\r\n    }\r\n}\r\n\r\ninline void push(node *v)\r\n{\r\n    if(!v) return;\r\n\r\n    if(v->rev)\r\n    {\r\n        if(v->l) v->l->rev ^= 1;\r\n        if(v->r) v->r->rev ^= 1;\r\n        swap(v->l, v->r);\r\n        v->rev = 0;\r\n    }\r\n}\r\n\r\ninline void rot(node *v)\r\n{\r\n    if(!v)\r\n        return;\r\n    node *p = v->p;\r\n    if(!p)\r\n        return;\r\n    node *g = p->p;\r\n    if(!is_root(p))\r\n    {\r\n        if(g->l == p)\r\n            g->l = v;\r\n        else\r\n            g->r = v;\r\n    }\r\n\r\n    push(p);\r\n    push(v);\r\n\r\n    if(p->l == v)\r\n    {\r\n        p->l = v->r;\r\n        if(p->l)\r\n            p->l->p = p;\r\n        v->r = p;\r\n    }\r\n    else\r\n    {\r\n        p->r = v->l;\r\n        if(p->r)\r\n            p->r->p = p;\r\n        v->l = p;\r\n    }\r\n    p->p = v;\r\n    v->p = g;\r\n\r\n\r\n}\r\n\r\ninline void splay(node *v)\r\n{\r\n    if(!v) return;\r\n    while(!is_root(v))\r\n    {\r\n        node *p = v->p;\r\n        node *g = p->p;\r\n        if(!is_root(p))\r\n        {\r\n            if((g->l == p) == (p->l == v))\r\n                rot(p);\r\n            else\r\n                rot(v);\r\n        }\r\n        rot(v);\r\n    }\r\n    push(v);\r\n}\r\n\r\ninline node* access(int i)\r\n{\r\n    node *v = &lct[i], *c = v;\r\n    node *last = nullptr;\r\n    while(c)\r\n    {\r\n        splay(c);\r\n        c->r = last;\r\n        last = c;\r\n        c = c->p;\r\n    }\r\n    splay(v);\r\n    return last;\r\n}\r\n\r\nvoid make_root(int i)\r\n{\r\n    access(i);\r\n    node *v = &lct[i];\r\n    if(v->l)\r\n    {\r\n        v->l->rev ^= 1;\r\n        v->l = 0;\r\n    }\r\n}\r\n\r\nvoid link(int a, int b)\r\n{\r\n//    cout << \"link \" << a+1 << ' ' << b+1 << '\\n';\r\n    make_root(b);\r\n    node *v = &lct[b];\r\n    v->p = &lct[a];\r\n}\r\n\r\nvoid cut(int i)\r\n{\r\n    access(i);\r\n    node *v = &lct[i];\r\n    if(v->l)\r\n    {\r\n        v->l->p = 0;\r\n        v->l = 0;\r\n    }\r\n}\r\n\r\nvoid cut(int a, int b)\r\n{\r\n//    cout << \"cut \" << a+1 << ' ' << b+1 << '\\n';\r\n    make_root(a);\r\n    access(b);\r\n    if(lct[b].l)\r\n    {\r\n        lct[b].l->p = 0;\r\n        lct[b].l = 0;\r\n    }\r\n}\r\n\r\nbool conn(int a, int b)\r\n{\r\n    access(a);\r\n    access(b);\r\n    return lct[a].p != 0;\r\n}\r\n\r\nconst int MAXN = 200005;\r\n\r\npair<int, int> tre[MAXN*4];\r\nint psh[MAXN*4];\r\n\r\npair<int, int> combine(pair<int, int> a, pair<int, int> b)\r\n{\r\n    pair<int, int> res;\r\n    res.fi = min(a.fi, b.fi);\r\n    res.se = (a.fi == res.fi)*a.se + (b.fi == res.fi)*b.se;\r\n    return res;\r\n}\r\n\r\ninline void combine(int v)\r\n{\r\n    tre[v] = combine(tre[v*2], tre[v*2+1]);\r\n}\r\n\r\n\r\n\r\nvoid push(int v, int l, int r)\r\n{\r\n    if(!psh[v])\r\n        return;\r\n    tre[v].fi += psh[v];\r\n    if(l != r)\r\n    {\r\n        psh[v*2] += psh[v];\r\n        psh[v*2+1] += psh[v];\r\n    }\r\n    psh[v] = 0;\r\n}\r\n\r\nvoid build(int l, int r, int v)\r\n{\r\n    if(l == r)\r\n    {\r\n        tre[v] = {0, 1};\r\n        psh[v] = 0;\r\n        return;\r\n    }\r\n    int m = (l+r) / 2;\r\n    build(l, m, v*2);\r\n    build(m+1, r, v*2+1);\r\n    combine(v);\r\n    psh[v] = 0;\r\n}\r\n\r\nvoid Add(int l, int r, int L, int R, int v, int x)\r\n{\r\n    if(l >= L && r <= R)\r\n    {\r\n        psh[v] += x;\r\n        push(v, l, r);\r\n        return;\r\n    }\r\n    push(v, l, r);\r\n    if(l > R || r < L)\r\n        return;\r\n    int m = (l+r) / 2;\r\n    Add(l, m, L, R, v*2, x);\r\n    Add(m+1, r, L, R, v*2+1, x);\r\n    combine(v);\r\n}\r\n\r\npair<int, int> Min(int l, int r, int L, int R, int v)\r\n{\r\n    if(l >= L && r <= R)\r\n    {\r\n        push(v, l, r);\r\n        return tre[v];\r\n    }\r\n    push(v, l, r);\r\n    if(l > R || r < L)\r\n        return {1e9, 0};\r\n    int m = (l+r) / 2;\r\n    return combine(Min(l, m, L, R, v*2), Min(m+1, r, L, R, v*2+1));\r\n}\r\n\r\nvoid print(int l, int r, int n)\r\n{\r\n    for(int i = 0; i <= r; i++)\r\n    {\r\n\r\n        cout << Min(0, n-1, i, i, 1).fi << ' ';\r\n    } cout << '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0); cout.tie(0);\r\n\r\n\r\n    int n, m; cin >> n >> m;\r\n    vector<vector<int> > dat(n, vector<int>(m));\r\n    vector<pair<int, int> > pos(n*m);\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < m; j++)\r\n        {\r\n            cin >> dat[i][j];\r\n            dat[i][j]--;\r\n            pos[dat[i][j]] = {i, j};\r\n        }\r\n    }\r\n    build(0, n*m-1, 1);\r\n    init(n*m);\r\n\r\n    ll ans = 0;\r\n    int l = 0;\r\n    for(int r = 0; r < n*m; r++)\r\n    {\r\n        auto p = pos[r];\r\n        Add(0, n*m-1, 0, r, 1, 1);\r\n        for(int d = 0; d < 4; d++)\r\n        {\r\n            pair<int, int> q = {p.fi + dx[d], p.se + dy[d]};\r\n            if(q.fi < 0 || q.fi >= n || q.se < 0 || q.se >= m || dat[q.fi][q.se] > r || dat[q.fi][q.se] < l)\r\n                continue;\r\n\r\n            while(conn(r, dat[q.fi][q.se]) && dat[q.fi][q.se] >= l)\r\n            {\r\n                auto p2 = pos[l];\r\n                for(int d2 = 0; d2 < 4; d2++)\r\n                {\r\n                    pair<int, int> q2 = {p2.fi + dx[d2], p2.se + dy[d2]};\r\n                    if(q2.fi < 0 || q2.fi >= n || q2.se < 0 || q2.se >= m || dat[q2.fi][q2.se] >= r || dat[q2.fi][q2.se] < l)\r\n                        continue;\r\n                    cut(l, dat[q2.fi][q2.se]);\r\n                }\r\n                l++;\r\n            }\r\n            if(dat[q.fi][q.se] < l)\r\n                continue;\r\n            link(r, dat[q.fi][q.se]);\r\n            Add(0, n*m-1, 0, dat[q.fi][q.se], 1, -1);\r\n        }\r\n        //print(l, r, n*m);\r\n        auto res = Min(0, n*m-1, l, r, 1);\r\n//        cout << l << ' ' << res.fi << ' ' << res.se << '\\n';\r\n        if(res.fi == 1)\r\n            ans += res.se;\r\n    }\r\n    cout << ans;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// shche ne vmerla Ykraina\r\n"
}