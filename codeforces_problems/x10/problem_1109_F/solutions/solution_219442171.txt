{
    "id": 219442171,
    "contestId": 1109,
    "creationTimeSeconds": 1692360256,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1109,
        "index": "F",
        "name": "Sasha and Algorithm of Silence's Sounds",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1109,
        "members": [
            {
                "handle": "Gorgo"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1550334900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 62,
    "timeConsumedMillis": 358,
    "memoryConsumedBytes": 23244800,
    "source": "// #pragma GCC optimize(\"O3\")\r\n// #pragma GCC optimize(\"Ofast\")\r\n// #pragma GCC optimize(\"unroll-loops\")\r\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\r\ntree_order_statistics_node_update> ordered_set;\r\n\r\n#define rep(i, n) for (int i = 0; i < n; i++)\r\n#define pb push_back\r\n#define debug(x) cout << #x << \" \" << x << endl\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define ll long long\r\n#define vi vector<int>\r\n#define vvi vector<vi>\r\n#define vvvi vector<vvi>\r\n#define vll vector<ll>\r\n#define vvll vector<vll>\r\n#define ld long double\r\n#define ull unsigned long long\r\n#define vull vector<ull>\r\n#define fi first\r\n#define se second\r\n#define PII pair<int, int>\r\n#define vPII vector<PII>\r\n#define getunique(v)                                                           \\\r\n  {                                                                            \\\r\n    sort(v.begin(), v.end());                                                  \\\r\n    v.erase(unique(v.begin(), v.end()), v.end());                              \\\r\n  }\r\n#define int128 __int128\r\n#define LSOne(x) (x & (-x))\r\n\r\nstruct SplayTree {\r\n  struct Node {\r\n    int ch[2] = {0, 0}, p = 0;\r\n    long long self = 0, path = 0; // Path aggregates\r\n    long long sub = 0, vir = 0;   // Subtree aggregates\r\n    bool flip = 0;                // Lazy tags\r\n  };\r\n  vector<Node> T;\r\n\r\n  SplayTree(int n) : T(n + 1) {}\r\n\r\n  void push(int x) {\r\n    if (!x || !T[x].flip)\r\n      return;\r\n    int l = T[x].ch[0], r = T[x].ch[1];\r\n\r\n    T[l].flip ^= 1, T[r].flip ^= 1;\r\n    swap(T[x].ch[0], T[x].ch[1]);\r\n    T[x].flip = 0;\r\n  }\r\n\r\n  void pull(int x) {\r\n    int l = T[x].ch[0], r = T[x].ch[1];\r\n    push(l);\r\n    push(r);\r\n\r\n    T[x].path = T[l].path + T[x].self + T[r].path;\r\n    T[x].sub = T[x].vir + T[l].sub + T[r].sub + T[x].self;\r\n  }\r\n\r\n  void set(int x, int d, int y) {\r\n    T[x].ch[d] = y;\r\n    T[y].p = x;\r\n    pull(x);\r\n  }\r\n\r\n  void splay(int x) {\r\n    auto dir = [&](int w) {\r\n      int p = T[w].p;\r\n      if (!p)\r\n        return -1;\r\n      return T[p].ch[0] == w ? 0 : T[p].ch[1] == w ? 1 : -1;\r\n    };\r\n    auto rotate = [&](int w) {\r\n      int y = T[w].p, z = T[y].p, dx = dir(w), dy = dir(y);\r\n      set(y, dx, T[w].ch[!dx]);\r\n      set(w, !dx, y);\r\n      if (~dy)\r\n        set(z, dy, w);\r\n      T[w].p = z;\r\n    };\r\n    for (push(x); ~dir(x);) {\r\n      int y = T[x].p, z = T[y].p;\r\n      push(z);\r\n      push(y);\r\n      push(x);\r\n      int dx = dir(x), dy = dir(y);\r\n      if (~dy)\r\n        rotate(dx != dy ? x : y);\r\n      rotate(x);\r\n    }\r\n  }\r\n};\r\n\r\nstruct LinkCut : SplayTree {\r\n  LinkCut(int n) : SplayTree(n) {}\r\n\r\n  int access(int x) {\r\n    int u = x, v = 0;\r\n    for (; u; v = u, u = T[u].p) {\r\n      splay(u);\r\n      int &ov = T[u].ch[1];\r\n      T[u].vir += T[ov].sub;\r\n      T[u].vir -= T[v].sub;\r\n      ov = v;\r\n      pull(u);\r\n    }\r\n    return splay(x), v;\r\n  }\r\n\r\n  void reroot(int x) {\r\n    access(x);\r\n    T[x].flip ^= 1;\r\n    push(x);\r\n  }\r\n\r\n  void Link(int u, int v) {\r\n    reroot(u);\r\n    access(v);\r\n    T[v].vir += T[u].sub;\r\n    T[u].p = v;\r\n    pull(v);\r\n  }\r\n\r\n  void Cut(int u, int v) {\r\n    reroot(u);\r\n    access(v);\r\n    T[v].ch[0] = T[u].p = 0;\r\n    pull(v);\r\n  }\r\n\r\n  // Rooted tree LCA. Returns 0 if u and v arent connected.\r\n  int LCA(int u, int v) {\r\n    if (u == v)\r\n      return u;\r\n    access(u);\r\n    int ret = access(v);\r\n    return T[u].p ? ret : 0;\r\n  }\r\n\r\n  // Query subtree of u where v is outside the subtree.\r\n  long long Subtree(int u, int v) {\r\n    reroot(v);\r\n    access(u);\r\n    return T[u].vir + T[u].self;\r\n  }\r\n\r\n  // Query path [u..v]\r\n  long long Path(int u, int v) {\r\n    reroot(u);\r\n    access(v);\r\n    return T[v].path;\r\n  }\r\n\r\n  // Update vertex u with value v\r\n  void Update(int u, long long v) {\r\n    access(u);\r\n    T[u].self = v;\r\n    pull(u);\r\n  }\r\n};\r\n\r\nstruct SegTree{\r\n    vector<pair<int,int>> tree;\r\n    vi lazy;\r\n    ll N = 1;\r\n    SegTree(ll n){\r\n        while(N < n+1) N*=2;\r\n        tree.resize(2*N);\r\n        lazy.resize(2*N);\r\n        for(int i = N;i <N+N;i++) tree[i].se = 1;\r\n        for(int i=N-1;i>0;i--) tree[i].se = 2 * tree[2*i].se;\r\n    }\r\n\r\n    void push(int v){\r\n        if(lazy[v] == 0)return;\r\n        if(2*v + 1 < 2*N){\r\n            tree[2*v].fi += lazy[v];\r\n            tree[2*v+1].fi += lazy[v];\r\n            lazy[2*v] += lazy[v];\r\n            lazy[2*v+1] += lazy[v];\r\n        }\r\n        lazy[v] = 0;\r\n    }\r\n\r\n    int get(int l, int r, int v, int start, int kon){\r\n        push(v);\r\n        if(l>kon or r < start)return 0;\r\n        if(l<=start and kon<=r)return tree[v].fi == 1 ? tree[v].se : 0;\r\n        int mid = (start + kon) / 2;\r\n        int left = get(l, r, 2*v, start, mid);\r\n        int right = get(l, r, 2*v+1, mid+1, kon);\r\n        return left + right;\r\n    }\r\n\r\n    void add(int l, int r, int val, int v, int start, int kon){\r\n        push(v);\r\n        if(l>kon or r < start)return;\r\n        if(l<=start and kon<=r){\r\n            tree[v].fi += val;\r\n            lazy[v] += val;\r\n            return;\r\n        }\r\n        ll mid = (start + kon) / 2;\r\n        add(l, r, val, 2*v, start, mid);\r\n        add(l, r, val, 2*v+1, mid+1, kon);\r\n        if(tree[2*v].fi == tree[2*v + 1].fi){\r\n          tree[v] = tree[2*v];\r\n          tree[v].se += tree[2*v+1].se;\r\n        }else if(tree[2*v].fi < tree[2*v+1].fi){\r\n          tree[v] = tree[2*v];\r\n        }else{\r\n          tree[v] = tree[2*v+1];\r\n        }\r\n    }\r\n};\r\n\r\nint tab[1005][1005];\r\nPII where [200005];\r\n\r\nvoid solve([[maybe_unused]] int tc_idx = 0) {\r\n  int n,m; cin >> n >> m;\r\n  rep(i,n) rep(j,m) cin >> tab[i][j];\r\n  rep(i,n) rep(j,m) where[tab[i][j]] = {i,j};\r\n  auto get_nei = [&](int nr, int l=-1, int r=1e9){\r\n    vi som;\r\n    auto [x,y] = where[nr];\r\n    if(x and tab[x-1][y] <= r and tab[x-1][y] >= l) som.pb(tab[x-1][y]);\r\n    if(x < n-1 and tab[x+1][y] <= r and tab[x+1][y] >= l) som.pb(tab[x+1][y]);\r\n    if(y and tab[x][y-1] <= r and tab[x][y-1] >= l) som.pb(tab[x][y-1]);\r\n    if(y < m-1 and tab[x][y+1] <= r and tab[x][y+1] >= l) som.pb(tab[x][y+1]);\r\n    return som;\r\n  };\r\n  LinkCut lc(n*m+5);\r\n  SegTree st(n*m + 5);\r\n  ll ans = 0;\r\n  int l = 1;\r\n  for(int r = 1; r <= n*m; r++){\r\n    int ok = 0;\r\n    while(!ok){\r\n      vi som = get_nei(r, l, r);\r\n      int k = som.size();\r\n      ok = 1;\r\n      rep(i,k){\r\n        rep(j,i){\r\n          if(lc.LCA(som[i],som[j])){\r\n            ok = 0;\r\n            break;\r\n          }\r\n        }\r\n        if(!ok) break;\r\n      }\r\n      if(!ok){\r\n        vi s = get_nei(l, l, r-1);\r\n        for(int x : s) lc.Cut(l,x);\r\n        l++;\r\n      }\r\n    }\r\n    vi som = get_nei(r, l, r);\r\n    for(int x : som) lc.Link(r, x);\r\n    st.add(l, r, 1, 1, 0, st.N-1);\r\n    for(int x : som){\r\n      st.add(l, x, -1, 1, 0, st.N-1);\r\n    }\r\n    ans += (ll)st.get(l,r,1,0,st.N-1);\r\n  }\r\n  cout << ans;\r\n}\r\n\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(nullptr);\r\n  cout.tie(nullptr);\r\n  cout << setprecision(16) << fixed;\r\n  // srand(time(NULL));\r\n  // freopen(\"input.txt\", \"r\", stdin);\r\n  // freopen(\"output.txt\", \"w\", stdout);\r\n  int tt = 1;\r\n  // cin >> tt;\r\n  rep(i, tt) solve(i);\r\n}"
}