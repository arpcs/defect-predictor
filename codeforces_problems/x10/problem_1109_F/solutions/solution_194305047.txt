{
    "id": 194305047,
    "contestId": 1109,
    "creationTimeSeconds": 1676863087,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1109,
        "index": "F",
        "name": "Sasha and Algorithm of Silence's Sounds",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1109,
        "members": [
            {
                "handle": "_no__way"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1550334900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#define sz(v) ((int)(v).size())\r\n#define all(v) (v).begin(), (v).end()\r\nusing namespace std;\r\nusing lint = long long;\r\nusing pi = pair<int, int>;\r\nconst int mod = 1e9 + 7;\r\nconst int MAXN = 250005;\r\nconst int MAXT = 530000;\r\n\r\nstruct node{\r\n\tnode *l, *r, *p, *pp;\r\n\tint rev;\r\n\tnode(){\r\n\t\tl = r = p = pp = NULL;\r\n\t\trev = 0;\r\n\t}\r\n\tnode(int x){\r\n\t\tl = r = p = pp = NULL;\r\n\t\trev = 0;\r\n\t}\r\n\tvoid push(){\r\n\t\tif(rev){\r\n\t\t\tif(l) l->rev ^= 1;\r\n\t\t\tif(r) r->rev ^= 1;\r\n\t\t\trev = 0;\r\n\t\t\tswap(l, r);\r\n\t\t}\r\n\t}\r\n\tvoid pull(){}\r\n\tvoid setLeft(node *p){\r\n\t\tpush();\r\n\t\tl = p;\r\n\t\tp->p = this;\r\n\t\tpull();\r\n\t}\r\n\tvoid setRight(node *p){\r\n\t\tpush();\r\n\t\tr = p;\r\n\t\tp->p = this;\r\n\t\tpull();\r\n\t}\r\n\tvoid rotate(){\r\n\t\tnode *x = this;\r\n\t\tif(!x->p) return;\r\n\t\tx->p->push();\r\n\t\tx->push();\r\n\t\tnode *p = x->p;\r\n\t\tbool is_left = (p->l == x);\r\n\t\tnode *b = (is_left ? x->r : x->l);\r\n\t\tx->p = p->p;\r\n\t\tif(x->p && x->p->l == p) x->p->l = x;\r\n\t\tif(x->p && x->p->r == p) x->p->r = x;\r\n\t\tif(is_left){\r\n\t\t\tif(b) b->p = p;\r\n\t\t\tp->l = b;\r\n\t\t\tp->p = x;\r\n\t\t\tx->r = p;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(b) b->p = p;\r\n\t\t\tp->r = b;\r\n\t\t\tp->p = x;\r\n\t\t\tx->l = p;\r\n\t\t}\r\n\t\tp->pull();\r\n\t\tx->pull();\r\n\t\tif(p->pp){ // IF YOU ARE LINK CUT TREE\r\n\t\t\tx->pp = p->pp;\r\n\t\t\tp->pp = NULL;\r\n\t\t}\r\n\t}\r\n\tvoid splay(){\r\n\t\tnode *x = this;\r\n\t\twhile(x->p){\r\n\t\t\tnode *p = x->p;\r\n\t\t\tnode *g = p->p;\r\n\t\t\tif(g){\r\n\t\t\t\tif((p->l == x) ^ (g->l == p)) x->rotate();\r\n\t\t\t\telse p->rotate();\r\n\t\t\t}\r\n\t\t\tx->rotate();\r\n\t\t}\r\n\t}\r\n\tnode* prev(){\r\n\t\tsplay();\r\n\t\tif(!l) return NULL;\r\n\t\tauto prv = l;\r\n\t\tprv->push();\r\n\t\twhile(prv->r){\r\n\t\t\tprv = prv->r;\r\n\t\t\tprv->push();\r\n\t\t}\r\n\t\tprv->splay();\r\n\t\treturn prv;\r\n\t}\r\n\tnode* next(){\r\n\t\tsplay();\r\n\t\tif(!r) return NULL;\r\n\t\tauto nxt = r;\r\n\t\tnxt->push();\r\n\t\twhile(nxt->l){\r\n\t\t\tnxt = nxt->l;\r\n\t\t\tnxt->push();\r\n\t\t}\r\n\t\tnxt->splay();\r\n\t\treturn nxt;\r\n\t}\r\n\tvoid access(){\r\n\t\tsplay();\r\n\t\tpush();\r\n\t\tif(r){\r\n\t\t\tr->pp = this;\r\n\t\t\tr->p = NULL;\r\n\t\t\tr = NULL;\r\n\t\t}\r\n\t\tpull();\r\n\t\twhile(pp){\r\n\t\t\tnode *nxt = pp;\r\n\t\t\tnxt->splay();\r\n\t\t\tnxt->push();\r\n\t\t\tif(nxt->r){\r\n\t\t\t\tnxt->r->pp = nxt;\r\n\t\t\t\tnxt->r->p = NULL;\r\n\t\t\t\tnxt->r = NULL;\r\n\t\t\t}\r\n\t\t\tpp = NULL;\r\n\t\t\tnxt->setRight(this);\r\n\t\t\tsplay();\r\n\t\t}\r\n\t}\r\n\tnode* root(){\r\n\t\taccess();\r\n\t\tnode *x = this;\r\n\t\twhile(x->l){\r\n\t\t\tx->push();\r\n\t\t\tx = x->l;\r\n\t\t}\r\n\t\tx->access();\r\n\t\treturn x;\r\n\t}\r\n\tnode* par(){\r\n\t\taccess();\r\n\t\treturn prev();\r\n\t}\r\n\tvoid make_root(){\r\n\t\taccess();\r\n\t\trev ^= 1;\r\n\t\tpush();\r\n\t}\r\n};\r\n\r\nnode *lca(node *s, node *t){\r\n\ts->access(); t->access();\r\n\ts->splay();\r\n\tif(s->pp == NULL) return s;\r\n\treturn s->pp;\r\n}\r\n\r\nvoid link(node *par, node *son){\r\n\tpar->access();\r\n\tson->access();\r\n\tson->rev ^= 1;  // remove if needed\r\n\tson->setLeft(par);\r\n}\r\n\r\nvoid cut(node *p){\r\n\tp->access();\r\n\tp->push();\r\n\tif(p->l){\r\n\t\tp->l->p = NULL;\r\n\t\tp->l = NULL;\r\n\t}\r\n\tp->pull();\r\n}\r\n\r\nvoid cut(node *p, node *q){\r\n\tif(q->par() == p) swap(p, q);\r\n\tcut(p);\r\n}\r\n\r\nnode* lct[MAXN];\r\n\r\nint n;\r\n\r\npi merge(pi a, pi b){\r\n\tif(a > b) swap(a, b);\r\n\tif(a.first == b.first) a.second += b.second;\r\n\treturn a;\r\n}\r\n\r\nstruct seg{\r\n\tpi tree[MAXT];\r\n\tint lazy[MAXT];\r\n\tvoid lazydown(int p){\r\n\t\tfor(int i=2*p; i<2*p+2; i++){\r\n\t\t\ttree[i].first += lazy[p];\r\n\t\t\tlazy[i] += lazy[p];\r\n\t\t}\r\n\t\tlazy[p] = 0;\r\n\t}\r\n\tvoid init(int s = 1, int e = n, int p = 1){\r\n\t\tif(s == e){\r\n\t\t\ttree[p] = pi(0, 1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint m = (s+e)/2;\r\n\t\tinit(s, m, 2*p);\r\n\t\tinit(m + 1, e, 2*p+1);\r\n\t\ttree[p] = merge(tree[2*p], tree[2*p+1]);\r\n\t}\r\n\tpi query(int s, int e, int ps = 1, int pe = n, int p = 1){\r\n\t\tif(e < ps || pe < s) return pi(1e9, 0);\r\n\t\tif(s <= ps && pe <= e) return tree[p];\r\n\t\tlazydown(p);\r\n\t\tint pm = (ps + pe) / 2;\r\n\t\treturn merge(query(s, e, ps, pm, 2*p), query(s, e, pm+1, pe, 2*p+1));\r\n\t}\r\n\tvoid add(int s, int e, int x, int ps = 1, int pe = n, int p = 1){\r\n\t\tif(e < ps || pe < s) return;\r\n\t\tif(s <= ps && pe <= e){\r\n\t\t\ttree[p].first += x;\r\n\t\t\tlazy[p] += x;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlazydown(p);\r\n\t\tint pm = (ps + pe) / 2;\r\n\t\tadd(s, e, x, ps, pm, 2*p);\r\n\t\tadd(s, e, x, pm+1, pe, 2*p+1);\r\n\t\ttree[p] = merge(tree[2*p], tree[2*p+1]);\r\n\t}\r\n}seg;\r\n\r\nvector<int> gph[MAXN], rev[MAXN];\r\nint low[MAXN];\r\n\r\nint a[1005][1005];\r\n\r\nint main(){\r\n\tint m;\r\n\tscanf(\"%d %d\",&n,&m);\r\n\tif(n + m == 2){\r\n\t\tputs(\"1\");\r\n\t\treturn 0;\r\n\t}\r\n\tfor(int i=0; i<n; i++){\r\n\t\tfor(int j=0; j<m; j++){\r\n\t\t\ta[i][j] = i * m + j + 1;\r\n\t\t\tscanf(\"%d\",&a[i][j]);\r\n\t\t}\r\n\t}\r\n\tfor(int i=0; i<n; i++){\r\n\t\tfor(int j=0; j<m-1; j++){\r\n\t\t\tint l = a[i][j], r = a[i][j+1];\r\n\t\t\tgph[l].push_back(r);\r\n\t\t\tgph[r].push_back(l);\r\n\t\t}\r\n\t}\r\n\tfor(int i=0; i<n-1; i++){\r\n\t\tfor(int j=0; j<m; j++){\r\n\t\t\tint l = a[i][j], r = a[i+1][j];\r\n\t\t\tgph[l].push_back(r);\r\n\t\t\tgph[r].push_back(l);\r\n\t\t}\r\n\t}\r\n\tn = n * m;\r\n\tlow[0] = 1;\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tsort(all(gph[i]));\r\n\t}\r\n\tfor(int i=1; i<=n; i++) lct[i] = new node();\r\n\tpriority_queue<pi, vector<pi>, greater<pi>> pq;\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tfor(auto &j : gph[i]){\r\n\t\t\tif(j > i) break;\r\n\t\t\tpq.emplace(j, i);\r\n\t\t\tbool good = 1;\r\n\t\t\twhile(lct[i]->root() == lct[j]->root()){\r\n\t\t\t\tauto qfr = pq.top(); pq.pop();\r\n\t\t\t\tlow[i] = max(low[i], qfr.first + 1);\r\n\t\t\t\tif(qfr == pi(j, i)){\r\n\t\t\t\t\tgood = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcut(lct[qfr.first], lct[qfr.second]);\r\n\t\t\t}\r\n\t\t\tif(good) link(lct[i], lct[j]);\r\n\t\t}\r\n\t}\r\n\tfor(int i=1; i<=n; i++) low[i] = max(low[i], low[i - 1]);\r\n\tseg.init();\r\n\tlint ret = 0;\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tseg.add(1, i, 1);\r\n\t\tfor(auto &j : gph[i]){\r\n\t\t\tif(j > i) break;\r\n\t\t\tseg.add(1, j, -1);\r\n\t\t}\r\n\t\tauto qr = seg.query(low[i], i);\r\n\t\tif(qr.first == 1) ret += qr.second;\r\n\t}\r\n\tcout << ret << endl;\r\n}\r\n\u00a0"
}