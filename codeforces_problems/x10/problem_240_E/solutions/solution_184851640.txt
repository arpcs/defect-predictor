{
    "id": 184851640,
    "contestId": 240,
    "creationTimeSeconds": 1670825863,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 240,
        "index": "E",
        "name": "Road Repairs",
        "type": "PROGRAMMING",
        "rating": 2800,
        "tags": [
            "dfs and similar",
            "graphs",
            "greedy"
        ]
    },
    "author": {
        "contestId": 240,
        "members": [
            {
                "handle": "ParsaF"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1350370800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 19558400,
    "source": "#include <bits/stdc++.h>\r\n \r\nusing namespace std;\r\n \r\n#define TOF_IO                                   ios_base::sync_with_stdio(false);cin.tie(0) , cout.tie(0);\r\n#define File_IO(x,y)\t                         freopen(x, \"r\", stdin); freopen(y, \"w\", stdout);\r\n#define SEP                                      ' '\r\n#define endl                                     '\\n'\r\n#define Set_Prec(k, x)\t                         cout << fixed << setprecision(k) << x << '\\n';\r\n#define BSearch(first, second, t)                lower_bound(arr, arr+n, t)-arr\r\n#define F                                        first\r\n#define S                                        second\r\n#define ALL(x)                                   (x).begin(), (x).end()\r\n#define PB                                       push_back\r\n#define EDGE(arr, x, y)                          arr[x].PB(y), arr[y].PB(x)\r\n#define WEDGE(arr, x, y, z)                      arr[x].PB({y, z}), arr[y].PB({x, z})\r\n \r\ntypedef long long ll; \r\ntypedef long double lld;\r\n \r\nconst ll M = 1e9+7;\r\n//const ll IM = 1e18 + 37;\r\n \r\nll POW(ll a, ll b, ll md); ll GCD(ll a, ll b); ll LCM(ll a, ll b); int lis(std::vector<int>& v);\r\n/*\r\nll factI[N + 1], Numi[N + 1], fact[N + 1];\r\n \r\nvoid InverseofNumber(ll p = M); void InverseofFactorial(ll p = M); void factorial(ll p = M); ll nPr(ll N, ll R, ll p = M); ll nCr(ll N, ll R, ll p = M); void comb();\r\n*/\r\n \r\nconst ll N = 3e5 + 3;\r\nbool seen[N];\r\n\r\nll n, m, x, y, z, par[N], dist[N]; \r\n\r\nvector<ll> G2[N];\r\nvector<pair<ll, ll>> G1[N], E;\r\n\r\nset<pair<ll, ll>> st;\r\n\r\nll getPar(ll v)\r\n{\r\n\treturn (par[v] == v? v : par[v] = getPar(par[v]));\r\n}\r\n \r\nvoid Union(ll v, ll u, ll w)\r\n{\r\n\t\r\n}\r\n\r\nvoid dfs(ll v)\r\n{\r\n\tseen[v] = 1;\r\n\t\r\n\tfor(ll u: G2[v])\r\n\t{\r\n\t\tif(seen[u]) continue;\r\n\t\t\r\n\t\tdfs(u);\r\n\t}\r\n} \r\n/*\r\nvoid Im_fucking_tired()\r\n{\r\n\tfor(int i=1; i<=n; i++)\r\n\t{\r\n\t\tpar[i] = i;\r\n\t\tsz[i] = 1;\r\n\t}\r\n}*/\r\n\r\n\r\n\r\n/* _________________________________________________________________________________________________________________________________________________________________________________*/\r\n/*** ------------------------------------------------------------------------------SOLVE-----------------------------------------------------------------------------------------***/\r\n/* _______________________________________________________________________________________________________________________________________________________________________________*/\r\n\r\nmap<pair<ll, ll>, bool> A;\r\n\r\nvoid solve()\r\n{\r\n\tcin >> n >> m;\r\n\t\r\n\tfor(int i=0; i<m; i++)\r\n\t{\r\n\t\tcin >> x >> y >> z;\r\n\t\t\r\n\t\tG2[x].PB(y);\r\n\t\tG1[x].PB({y, z});\r\n\t\tE.PB({x, y});\r\n\t}\r\n\t\r\n\tdfs(1);\r\n\t\r\n\tfor(int i=1; i<=n; i++)\r\n\t{\r\n\t\tif(seen[i] == 0)\r\n\t\t{\r\n\t\t\tcout << -1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1; i<=n; i++) dist[i] = 8e18, seen[i] = 0;\r\n\t\r\n\tset<pair<ll, pair<ll, ll>>> st;\r\n\tst.insert({0, {1, 1}});\r\n\t\r\n\twhile(st.size())\r\n\t{\r\n\t\tll v = st.begin() -> S.S, u = st.begin() -> S.F, w = st.begin() -> F;\r\n\t\tst.erase(st.begin());\r\n\t\t\r\n\t\tif(seen[v] || par[u] == par[v]) continue; \r\n\t\tseen[v] = 1;\r\n\t\t\r\n\t\tpar[u] = par[v];\r\n\t\t\r\n\t\t//cout << u << SEP << v << endl;\r\n\t\t\r\n\t\tfor(auto p: G1[v])\r\n\t\t{\r\n\t\t\tll uu, w;\r\n\t\t\tuu = p.F; w = p.S;\r\n\t\t\t\r\n\t\t\t//cout << uu << SEP << seen[uu] << endl;\r\n\t\t\tif(seen[uu]) continue;\r\n\t\t\t\r\n\t\t\tst.insert({w, {v, uu}}); \r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif(w == 1) A[{u, v}] = 1; \r\n\t\t//cout << w;\r\n\t}\r\n\t\r\n\t\r\n\tll cnt = 0;\r\n\tvector<ll> ans;\r\n\tfor(auto e: E)\r\n\t{\r\n\t\tcnt++;\r\n\t\tll v, u;\r\n\t\tv = e.F; u = e.S;\r\n\t\t\r\n\t\tif(A[{v, u}]) ans.PB(cnt); \r\n\t}\r\n\t\r\n\tcout << ans.size() << endl;\r\n\tfor(ll id: ans) cout << id << SEP;\r\n}\r\n\r\n \r\n/* _________________________________________________________________________________________________________________________________________________________________________________*/\r\n/*** -------------------------------------------------------------------------------MAIN-----------------------------------------------------------------------------------------***/\r\n/* _______________________________________________________________________________________________________________________________________________________________________________*/\r\n \r\nint main()\r\n{\r\n\tFile_IO(\"input.txt\", \"output.txt\");\r\n\tTOF_IO;\r\n \r\n\tll t=1;\r\n\t//cin >> t;\r\n\t\r\n\tfor(int k=0; k<t; k++)\r\n\t{\r\n\t\tsolve();\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n \r\n \r\n \r\n \r\n/* _________________________________________________________________________________________________________________________________________________________________________________*/\r\n/*** ---------------------------------------------------------------------------FUNCTIONS----------------------------------------------------------------------------------------***/\r\n/* _______________________________________________________________________________________________________________________________________________________________________________*/\r\n/*\r\nvoid InverseofNumber(ll p = M){Numi[0] = Numi[1] = 1; for (ll i = 2; i <= N; i++){Numi[i] = Numi[p % i] * (p - p / i) % p;}}\r\nvoid InverseofFactorial(ll p = M){factI[0] = factI[1] = 1;for (ll i = 2; i <= N; i++){factI[i] = (Numi[i] * factI[i - 1]) % p;}}\r\nvoid factorial(ll p = M){fact[0] = 1;for (ll i = 1; i <= N; i++){fact[i] = (fact[i - 1] * i) % p;}}\r\nll nPr(ll N, ll R, ll p = M){if (N - R < 0 || R < 0) {return 0;}int ans = ((fact[N]) % p * factI[N - R]) % p;return ans;}\r\nll nCr(ll N, ll R, ll p = M){if (N - R < 0 || R < 0) {return 0};int ans = ((fact[N] * factI[R]) % p * factI[N - R]) % p;return ans;}\r\nvoid comb(){ll p = M;InverseofNumber(p);InverseofFactorial(p);factorial(p);}\r\n*/\r\nll POW(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * POW(a * a % md, b / 2, md) % md : POW(a * a % md, b / 2, md) % md));}\r\n//ll GCD(ll a, ll b) {return b?GCD(b,a%b):a;}\r\n//ll LCM(ll a, ll b) {return a/GCD(a,b)*b;}\r\n \r\n//int lis(std::vector<int>& v){if (v.size() == 0) {return 0;} vector<int> tail(v.size(), 0); int length = 1; tail[0] = v[0]; for (int i = 1; i < v.size(); i++) {auto b = tail.begin(), e = tail.begin() + length; auto it = lower_bound(b, e, v[i]); if (it == tail.begin() + length){tail[length++] = v[i];}else{*it = v[i];}} return length;} \r\n\r\n"
}