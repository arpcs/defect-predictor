{
    "id": 231335230,
    "contestId": 1359,
    "creationTimeSeconds": 1699102618,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1359,
        "index": "F",
        "name": "RC Kaboom Show",
        "type": "PROGRAMMING",
        "rating": 2900,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "geometry",
            "math"
        ]
    },
    "author": {
        "contestId": 1359,
        "members": [
            {
                "handle": "Jayint"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1590676500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 53,
    "timeConsumedMillis": 1778,
    "memoryConsumedBytes": 15974400,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// using point_t=long long;\r\nusing point_t = long double; //\u5168\u5c40\u6570\u636e\u7c7b\u578b\r\n\r\nconstexpr point_t eps = 1e-8;\r\nconstexpr point_t INF = numeric_limits<point_t>::max();\r\nconstexpr long double PI = 3.1415926535897932384l;\r\n\r\n// \u70b9\u4e0e\u5411\u91cf\r\ntemplate<typename T> struct point\r\n{\r\n    T x, y;\r\n    point() {}\r\n    point(T _x, T _y) { x = _x, y = _y;}\r\n    bool operator==(const point &a) const {return (abs(x - a.x) <= eps && abs(y - a.y) <= eps);}\r\n    bool operator<(const point &a) const {if (abs(x - a.x) <= eps) return y < a.y - eps; return x < a.x - eps;}\r\n    bool operator>(const point &a) const {return !(*this < a || *this == a);}\r\n    point operator+(const point &a) const {return {x + a.x, y + a.y};}\r\n    point operator-(const point &a) const {return {x - a.x, y - a.y};}\r\n    point operator-() const {return { -x, -y};}\r\n    point operator*(const T k) const {return {k * x, k * y};}\r\n    point operator/(const T k) const {return {x / k, y / k};}\r\n    T operator*(const point &a) const {return x * a.x + y * a.y;} // \u70b9\u79ef\r\n    T operator^(const point &a) const {return x * a.y - y * a.x;} // \u53c9\u79ef\uff0c\u6ce8\u610f\u4f18\u5148\u7ea7\r\n    //1\u8868\u793a\u5728\u5de6\u8fb9   0\u8868\u793a\u5728\u7ebf\u4e0a   -1\u8868\u793a\u5728\u53f3\u8fb9\r\n    int toleft(const point &a) const {const auto t = (*this)^a; return (t > eps) - (t < -eps);} // to-left \u6d4b\u8bd5\r\n    T len2() const {return (*this) * (*this);} // \u5411\u91cf\u957f\u5ea6\u7684\u5e73\u65b9\r\n    T dis2(const point &a) const {return (a - (*this)).len2();} // \u4e24\u70b9\u8ddd\u79bb\u7684\u5e73\u65b9\r\n\r\n    // \u6d89\u53ca\u6d6e\u70b9\u6570\r\n    long double len() const {return sqrtl(len2());}  // \u5411\u91cf\u957f\u5ea6\r\n    long double dis(const point &a) const {return sqrtl(dis2(a));}  // \u4e24\u70b9\u8ddd\u79bb\r\n    long double ang(const point &a) const {return acosl(max(-1.0l, min(1.0l, ((*this) * a) / (len() * a.len()))));} // \u5411\u91cf\u5939\u89d2\r\n    point rot(const long double rad) const {return {x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)};} // \u9006\u65f6\u9488\u65cb\u8f6c\uff08\u7ed9\u5b9a\u89d2\u5ea6\uff09\r\n    point rot(const long double cosr, const long double sinr) const {return {x*cosr - y * sinr, x*sinr + y * cosr};} // \u9006\u65f6\u9488\u65cb\u8f6c\uff08\u7ed9\u5b9a\u89d2\u5ea6\u7684\u6b63\u5f26\u4e0e\u4f59\u5f26\uff09\r\n    point rot1(const long double rad) const {return {x * cos(rad) + y * sin(rad), - x * sin(rad) + y * cos(rad)};} //\u987a\u65f6\u9488\u65cb\u8f6c\r\n};\r\nusing Point = point<point_t>;\r\n\r\n// \u6781\u89d2\u6392\u5e8f\r\nstruct argcmp\r\n{\r\n    bool operator()(const Point &a, const Point &b) const\r\n    {\r\n        const auto quad = [](const Point & a)\r\n        {\r\n            if (a.y < -eps) return 1;\r\n            if (a.y > eps) return 4;\r\n            if (a.x < -eps) return 5;\r\n            if (a.x > eps) return 3;\r\n            return 2;\r\n        };\r\n        const int qa = quad(a), qb = quad(b);\r\n        if (qa != qb) return qa < qb;\r\n        const auto t = a ^ b;\r\n        // if (abs(t)<=eps) return a*a<b*b-eps;  // \u4e0d\u540c\u957f\u5ea6\u7684\u5411\u91cf\u9700\u8981\u5206\u5f00\r\n        return t > eps;\r\n    }\r\n};\r\n\r\n// \u76f4\u7ebf\r\ntemplate<typename T> struct line\r\n{\r\n    point<T> p, v; // p \u4e3a\u76f4\u7ebf\u4e0a\u4e00\u70b9\uff0cv \u4e3a\u65b9\u5411\u5411\u91cf\r\n    line() = default;\r\n    line(Point p, Point v): p(p), v(v) {}\r\n    bool operator==(const line &a) const {return v.toleft(a.v) == 0 && v.toleft(p - a.p) == 0;}\r\n    int toleft(const point<T> &a) const {return v.toleft(a - p);} // to-left \u6d4b\u8bd5\r\n    bool operator<(const line &a) const  // \u534a\u5e73\u9762\u4ea4\u7b97\u6cd5\u5b9a\u4e49\u7684\u6392\u5e8f\r\n    {\r\n        if (abs(v ^ a.v) <= eps && v * a.v >= -eps) return toleft(a.p) == -1;\r\n        return argcmp()(v, a.v);\r\n    }\r\n\r\n    // \u6d89\u53ca\u6d6e\u70b9\u6570\r\n    point<T> inter(const line &a) const {return p + v * ((a.v ^ (p - a.p)) / (v ^ a.v));} // \u76f4\u7ebf\u4ea4\u70b9\r\n    long double dis(const point<T> &a) const {return abs(v ^ (a - p)) / v.len();} // \u70b9\u5230\u76f4\u7ebf\u8ddd\u79bb\r\n    point<T> proj(const point<T> &a) const {return p + v * ((v * (a - p)) / (v * v));} // \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\r\n};\r\n\r\nusing Line = line<point_t>;\r\n\r\n//\u7ebf\u6bb5\r\ntemplate<typename T> struct segment\r\n{\r\n    point<T> a, b;\r\n\r\n    bool operator<(const segment &s) const {return make_pair(a, b) < make_pair(s.a, s.b);}\r\n\r\n    // \u5224\u5b9a\u6027\u51fd\u6570\u5efa\u8bae\u5728\u6574\u6570\u57df\u4f7f\u7528\r\n\r\n    // \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a\r\n    // -1 \u70b9\u5728\u7ebf\u6bb5\u7aef\u70b9 | 0 \u70b9\u4e0d\u5728\u7ebf\u6bb5\u4e0a | 1 \u70b9\u4e25\u683c\u5728\u7ebf\u6bb5\u4e0a\r\n    int is_on(const point<T> &p) const\r\n    {\r\n        if (p == a || p == b) return -1;\r\n        return (p - a).toleft(p - b) == 0 && (p - a) * (p - b) < -eps;\r\n    }\r\n\r\n    // \u5224\u65ad\u7ebf\u6bb5\u76f4\u7ebf\u662f\u5426\u76f8\u4ea4\r\n    // -1 \u76f4\u7ebf\u7ecf\u8fc7\u7ebf\u6bb5\u7aef\u70b9 | 0 \u7ebf\u6bb5\u548c\u76f4\u7ebf\u4e0d\u76f8\u4ea4 | 1 \u7ebf\u6bb5\u548c\u76f4\u7ebf\u4e25\u683c\u76f8\u4ea4\r\n    int is_inter(const line<T> &l) const\r\n    {\r\n        if (l.toleft(a) == 0 || l.toleft(b) == 0) return -1;\r\n        return l.toleft(a) != l.toleft(b);\r\n    }\r\n\r\n    // \u5224\u65ad\u4e24\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4\r\n    // -1 \u5728\u67d0\u4e00\u7ebf\u6bb5\u7aef\u70b9\u5904\u76f8\u4ea4 | 0 \u4e24\u7ebf\u6bb5\u4e0d\u76f8\u4ea4 | 1 \u4e24\u7ebf\u6bb5\u4e25\u683c\u76f8\u4ea4\r\n    int is_inter(const segment<T> &s) const\r\n    {\r\n        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;\r\n        const line<T> l{a, b - a}, ls{s.a, s.b - s.a};\r\n        return l.toleft(s.a) * l.toleft(s.b) == -1 && ls.toleft(a) * ls.toleft(b) == -1;\r\n    }\r\n\r\n    // \u70b9\u5230\u7ebf\u6bb5\u8ddd\u79bb\r\n    long double dis(const point<T> &p) const\r\n    {\r\n        if ((p - a) * (b - a) < -eps || (p - b) * (a - b) < -eps) return min(p.dis(a), p.dis(b));\r\n        const line<T> l{a, b - a};\r\n        return l.dis(p);\r\n    }\r\n\r\n    // \u4e24\u7ebf\u6bb5\u95f4\u8ddd\u79bb\r\n    long double dis(const segment<T> &s) const\r\n    {\r\n        if (is_inter(s)) return 0;\r\n        return min({dis(s.a), dis(s.b), s.dis(a), s.dis(b)});\r\n    }\r\n};\r\n\r\nusing Segment = segment<point_t>;\r\n\r\nbool segs_inter(const vector<Segment> &segs)\r\n{\r\n    if (segs.empty()) return false;\r\n    using seq_t = tuple<point_t, int, Segment>;\r\n    const auto seqcmp = [](const seq_t & u, const seq_t & v)\r\n    {\r\n        const auto [u0, u1, u2] = u;\r\n        const auto [v0, v1, v2] = v;\r\n        if (abs(u0 - v0) <= eps) return make_pair(u1, u2) < make_pair(v1, v2);\r\n        return u0 < v0 - eps;\r\n    };\r\n    vector<seq_t> seq;\r\n    for (auto seg : segs)\r\n    {\r\n        if (seg.a.x > seg.b.x + eps) swap(seg.a, seg.b);\r\n        seq.push_back({seg.a.x, 0, seg});\r\n        seq.push_back({seg.b.x, 1, seg});\r\n    }\r\n    sort(seq.begin(), seq.end(), seqcmp);\r\n    point_t x_now;\r\n    auto cmp = [&](const Segment & u, const Segment & v)\r\n    {\r\n        if (abs(u.a.x - u.b.x) <= eps || abs(v.a.x - v.b.x) <= eps) return u.a.y < v.a.y - eps;\r\n        return ((x_now - u.a.x) * (u.b.y - u.a.y) + u.a.y * (u.b.x - u.a.x)) * (v.b.x - v.a.x) < ((x_now - v.a.x) * (v.b.y - v.a.y) + v.a.y * (v.b.x - v.a.x)) * (u.b.x - u.a.x) - eps;\r\n    };\r\n    multiset<Segment, decltype(cmp)> s{cmp};\r\n    for (const auto [x, o, seg] : seq)\r\n    {\r\n        x_now = x;\r\n        const auto it = s.lower_bound(seg);\r\n        if (o == 0)\r\n        {\r\n            if (it != s.end() && seg.is_inter(*it)) return true;\r\n            if (it != s.begin() && seg.is_inter(*prev(it))) return true;\r\n            s.insert(seg);\r\n        }\r\n        else\r\n        {\r\n            if (next(it) != s.end() && it != s.begin() && (*prev(it)).is_inter(*next(it))) return true;\r\n            s.erase(it);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nint n;\r\nPoint p[25005];\r\n\r\nlong long dx[25005], dy[25005], v[25005];\r\n\r\nbool check(point_t t) {\r\n    vector<Segment> seg;\r\n    for (int i = 0; i < n; i++) {\r\n        Point vv = Point(dx[i], dy[i]);\r\n        vv = vv / vv.len();\r\n        Segment ss;\r\n        ss.a = p[i];\r\n        ss.b = p[i] + vv * v[i] * t;\r\n        seg.push_back(ss);\r\n    }\r\n    return segs_inter(seg);\r\n}\r\n\r\nint main() {\r\n    cin >> n;\r\n    for (int i = 0; i < n; i++) {\r\n        int x, y;\r\n        cin >> x >> y >> dx[i] >> dy[i] >> v[i];\r\n        p[i] = Point(x, y);\r\n    }\r\n    point_t l = 0, r = 1e10;\r\n    while ((r - l) > 1e-7 && (r - l) / r > 1e-7) {\r\n        point_t mid = 0.5 * (l + r);\r\n        if (check(mid)) r = mid;\r\n        else l = mid;\r\n    }\r\n    if(r<1e10-eps) \r\n    printf(\"%.20Lf\\n\", r);\r\n    else printf(\"No show :(\\n\");\r\n}"
}