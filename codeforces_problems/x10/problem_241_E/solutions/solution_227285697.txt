{
    "id": 227285697,
    "contestId": 241,
    "creationTimeSeconds": 1696836124,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 241,
        "index": "E",
        "name": "Flights",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 241,
        "members": [
            {
                "handle": "cmk666"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1351783800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 614400,
    "source": "/*\r\n * @Author:             cmk666\r\n * @Created time:       2023-10-09 14:54:16\r\n * @Last Modified time: 2023-10-09 15:21:57\r\n */\r\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\r\n#include<bits/stdc++.h>\r\n#ifdef LOCAL\r\n#include\"debug.h\"\r\n#else\r\n#define D(...) ((void)0)\r\n#endif\r\nusing namespace std; using ll = long long;\r\n#define For(i, j, k) for ( int i = (j) ; i <= (k) ; i++ )\r\n#define Fol(i, j, k) for ( int i = (j) ; i >= (k) ; i-- )\r\nnamespace FastIO\r\n{\r\n// ------------------------------\r\n// #define IN_HAS_NEG\r\n// #define OUT_HAS_NEG\r\n// #define CHK_EOF\r\n// #define DISABLE_MMAP\r\n// ------------------------------\r\n#if __cplusplus < 201400\r\n#error Please use C++14 or higher.\r\n#endif\r\n#if __cplusplus > 201700\r\n#define INLINE_V inline\r\n#else\r\n#define INLINE_V\r\n#endif\r\n#if ( defined(LOCAL) || defined(_WIN32) ) && !defined(DISABLE_MMAP)\r\n#define DISABLE_MMAP\r\n#endif\r\n#ifndef DISABLE_MMAP\r\n#include<sys/mman.h>\r\n#endif\r\n#ifdef LOCAL\r\n\tinline char gc() { return getchar(); }\r\n\tinline void pc(char c) { putchar(c); }\r\n#else\r\n#ifdef DISABLE_MMAP\r\n\tINLINE_V constexpr int _READ_SIZE = 1 << 18;\r\n\tINLINE_V static char _read_buffer[_READ_SIZE], *_read_ptr = nullptr, *_read_ptr_end = nullptr;\r\n\tinline char gc()\r\n\t{\r\n\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) )\r\n\t\t{\r\n\t\t\t_read_ptr = _read_buffer;\r\n\t\t\t_read_ptr_end = _read_buffer + fread(_read_buffer, 1, _READ_SIZE, stdin);\r\n#ifdef CHK_EOF\r\n\t\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) ) return EOF;\r\n#endif\r\n\t\t}\r\n\t\treturn *_read_ptr++;\r\n\t}\r\n#else\r\n\tINLINE_V static const char *_read_ptr = (const char *)mmap(nullptr, INT_MAX, 1, 2, 0, 0);\r\n\tinline char gc() { return *_read_ptr++; }\r\n#endif\r\n\tINLINE_V constexpr int _WRITE_SIZE = 1 << 18;\r\n\tINLINE_V static char _write_buffer[_WRITE_SIZE], *_write_ptr = _write_buffer;\r\n\tinline void pc(char c)\r\n\t{\r\n\t\t*_write_ptr++ = c;\r\n\t\tif ( __builtin_expect(_write_buffer + _WRITE_SIZE == _write_ptr, false) )\r\n\t\t{\r\n\t\t\tfwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout);\r\n\t\t\t_write_ptr = _write_buffer;\r\n\t\t}\r\n\t}\r\n\tINLINE_V struct _auto_flush\r\n\t{\r\n\t\tinline ~_auto_flush() { fwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout); }\r\n\t}\t_auto_flush;\r\n#endif\r\n#ifdef CHK_EOF\r\n\tinline constexpr bool _isdigit(char c) { return ( c & 16 ) && c != EOF; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32 && c != EOF; }\r\n#else\r\n\tinline constexpr bool _isdigit(char c) { return c & 16; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32; }\r\n#endif\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_integer = numeric_limits < T >::is_integer;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_signed = numeric_limits < T >::is_signed;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_unsigned = _is_integer < T > && !_is_signed < T >;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __uint128_t > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_signed < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_unsigned < __uint128_t > = true;\r\n#undef INLINE_V\r\n\tinline void read(char &c) { do c = gc(); while ( !_isgraph(c) ); }\r\n\tinline void read_cstr(char *s)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) *s++ = c, c = gc();\r\n\t\t*s = 0;\r\n\t}\r\n\tinline void read(string &s)\r\n\t{\r\n\t\tchar c = gc(); s.clear(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) s.push_back(c), c = gc();\r\n\t}\r\n#ifdef IN_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); bool f = true; x = 0;\r\n\t\twhile ( !_isdigit(c) ) { if ( c == 45 ) f = false; c = gc(); }\r\n\t\tif ( f ) while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t\telse     while ( _isdigit(c) ) x = x * 10 - ( c & 15 ), c = gc();\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isdigit(c) ) c = gc();\r\n\t\tx = 0; while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t}\r\n\tinline void write(char c) { pc(c); }\r\n\tinline void write_cstr(const char *s) { while ( *s ) pc(*s++); }\r\n\tinline void write(const string &s) { for ( char c : s ) pc(c); }\r\n#ifdef OUT_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tif ( x >= 0 )  do buffer[digits++] =  ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\telse { pc(45); do buffer[digits++] = -( x % 10 ) | 48, x /= 10; while ( x ); }\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tdo buffer[digits++] = ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < int N > struct _tuple_io_helper\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_read(x), read(get < N - 1 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_write(x), pc(32), write(get < N - 1 > (x)); }\r\n\t};\r\n\ttemplate <> struct _tuple_io_helper < 1 >\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x) { read(get < 0 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x) { write(get < 0 > (x)); }\r\n\t};\r\n\ttemplate < class ...T >\r\n\tinline void read(tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_read(x); }\r\n\ttemplate < class ...T >\r\n\tinline void write(const tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_write(x); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void read(pair < T1, T2 > &x) { read(x.first), read(x.second); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void write(const pair < T1, T2 > &x) { write(x.first), pc(32), write(x.second); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void read(T1 &x, T2 &...y) { read(x), read(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void read_cstr(char *x, T *...y) { read_cstr(x), read_cstr(y...); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void write(const T1 &x, const T2 &...y) { write(x), write(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void write_cstr(const char *x, const T *...y) { write_cstr(x), write_cstr(y...); }\r\n\ttemplate < class T >\r\n\tinline void print(const T &x) { write(x); }\r\n\tinline void print_cstr(const char *x) { write_cstr(x); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void print(const T1 &x, const T2 &...y) { print(x), pc(32), print(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void print_cstr(const char *x, const T *...y) { print_cstr(x), pc(32), print_cstr(y...); }\r\n\tinline void println() { pc(10); }\r\n\tinline void println_cstr() { pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println(const T &...x) { print(x...), pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println_cstr(const T *...x) { print_cstr(x...), pc(10); }\r\n}\r\nusing namespace FastIO;\r\nconstexpr int inf = numeric_limits < int >::max() >> 1;\r\nint n, m, u[5009], v[5009], d[1009], cnt[1009]; bool used[1009], ko[1009];\r\nvector < int > g[1009]; vector < pair < int, int > > gg[1009]; queue < int > q;\r\ninline bool dfs(int u)\r\n{\r\n\tused[u] = true;\r\n\tif ( u == n ) return true;\r\n\tfor ( int i : g[u] ) if ( !used[i] && dfs(i) ) return true;\r\n\treturn ko[u] = true, false;\r\n}\r\nint main()\r\n{\r\n\tread(n, m);\r\n\tFor(i, 1, m) read(u[i], v[i]), g[u[i]].push_back(v[i]);\r\n\tif ( !dfs(1) ) return println(\"No\"s), 0;\r\n\tFor(i, 1, m) if ( !ko[u[i]] && !ko[v[i]] )\r\n\t\tgg[u[i]].emplace_back(v[i], 2), gg[v[i]].emplace_back(u[i], -1);\r\n\tfill(d + 1, d + n + 1, inf), fill(used + 1, used + n + 1, false), d[1] = 0, q.push(1);\r\n\tfor ( int u ; q.size() ; )\r\n\t{\r\n\t\tu = q.front(), q.pop(), used[u] = false;\r\n\t\tfor ( auto [i, j] : gg[u] ) if ( d[i] > d[u] + j )\r\n\t\t{\r\n\t\t\td[i] = d[u] + j;\r\n\t\t\tif ( !used[i] )\r\n\t\t\t{\r\n\t\t\t\tused[i] = true, q.push(i);\r\n\t\t\t\tif ( ++cnt[i] >= n ) return println(\"No\"s), 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprintln(\"Yes\"s);\r\n\tFor(i, 1, m) println(ko[u[i]] || ko[v[i]] ? 1 : d[v[i]] - d[u[i]]);\r\n\treturn 0;\r\n}\r\n// \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f\r\n// \u4f0a\u5a1c\u53ef\u7231\u634f \u4f0a\u5a1c\u8d34\u8d34\u634f"
}