{
    "id": 214549871,
    "contestId": 1585,
    "creationTimeSeconds": 1689814878,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1585,
        "index": "G",
        "name": "Poachers",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 2500,
        "tags": [
            "dp",
            "games",
            "graphs",
            "trees"
        ]
    },
    "author": {
        "contestId": 1585,
        "members": [
            {
                "handle": "1DWalker"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1639322100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 73,
    "timeConsumedMillis": 733,
    "memoryConsumedBytes": 254668800,
    "source": "// #pragma GCC optimize(\"O3,unroll-loops\")\r\n// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define _ << ' ' <<\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing dd = long double;\r\nusing str = string;\r\n#define mset multiset\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(x) int((x).size())\r\n#define g0 get<0>\r\n#define g1 get<1>\r\n#define g2 get<2>\r\n#define g3 get<3>\r\n#define fun function\r\n#define vec vector\r\n#define vi vector<int>\r\n#define vvi vector<vi>\r\n#define vvvi vector<vvi>\r\n#define vl vector<ll>\r\n#define vvl vector<vector<ll>>\r\n#define vvvl vector<vector<vector<ll>>>\r\n#define vb vector<bool>\r\n#define vvb vector<vector<bool>>\r\n#define vd vector<double>\r\n#define vvd vector<vector<double>>\r\n#define vdd vector<long double>\r\n#define vvdd vector<vector<long double>>\r\n#define vc vector<char>\r\n#define vvc vector<vector<char>>\r\n#define vs vector<string>\r\n#define vvs vector<vector<string>>\r\n#define pii pair<int, int>\r\n#define pll pair<ll, ll>\r\n#define mt make_tuple\r\n#define tii tuple<int, int>\r\n#define vtii vector<tuple<int, int>>\r\n#define tiii tuple<int, int, int>\r\n#define tiil tuple<int, int, ll>\r\n#define tll tuple<ll, ll>\r\n#define tli tuple<ll, int>\r\n#define tlii tuple<ll, int, int>\r\n#define til tuple<int, ll>\r\n#define till tuple<int, ll, ll>\r\n#define tlll tuple<ll, ll, ll>\r\n#define tiiii tuple<int, int, int, int>\r\n#define vtiii vector<tiii>\r\n#define vtiiii vector<tiiii>\r\n#define vtll vector<tll>\r\n#define vtli vector<tli>\r\n#define vtil vector<til>\r\n#define vtiil vector<tiil>\r\n#define vtill vector<till>\r\n#define vtlll vector<tlll>\r\n#define vvtii vector<vtii>\r\n#define vvtiii vector<vtiii>\r\n#define vvtll vector<vtll>\r\n#define vvtli vector<vtli>\r\n#define vvtil vector<vtil>\r\n#define vvtiil vector<tiil>\r\n#define vvtill vector<vtill>\r\n#define vvtlll vector<vtlll>\r\n#define qi queue<int>\r\n#define qll queue<ll>\r\n#define qtii queue<tii>\r\n#define si set<int>\r\n#define sl set<ll>\r\n#define usi uset<int>\r\n#define sc set<char>\r\n#define usc uset<char>\r\n#define stii set<tii>\r\n#define ustii uset<tii>\r\n#define mii map<int, int>\r\n#define umii umap<int, int>\r\n#define mci map<char, int>\r\n#define umci umap<char, int>\r\n#define mli map<ll, int>\r\n#define umli umap<ll, int>\r\n#define mil map<int, ll>\r\n#define umil umap<int, ll>\r\n#define mll map<ll, ll>\r\n#define umll umap<ll, ll>\r\n#define mivi map<int, vi>\r\n#define umivi umap<int, vi>\r\n#define mivl map<int, vl>\r\n#define umivl umap<int, vl>\r\n#define mlvi map<ll, vi>\r\n#define umlvi umap<ll, vi>\r\n#define mlvl map<ll, vl>\r\n#define umlvl umap<ll, vl>\r\n#define msi map<string, int>\r\n#define vmii vector<mii>\r\n#define iss istringstream\r\n#define pf push_front\r\n#define ef emplace_front\r\n#define pb push_back\r\n#define popb pop_back\r\n#define eb emplace_back\r\n#define ins insert\r\n#define lb lower_bound\r\n#define up upper_bound\r\n#define sordefault(a) sort(all(a))\r\n#define sorcmp(a, cmp) sort(all((a)), (cmp))\r\n#define GET_SORT(_1, _2, NAME, ...) NAME\r\n#define sor(...) GET_SORT(__VA_ARGS__, sorcmp, sordefault)(__VA_ARGS__)\r\n#define rev(a) reverse(all(a))\r\n#define mine(a) (*min_element((a).begin(), (a).end()))\r\n#define maxe(a) (*max_element((a).begin(), (a).end()))\r\n#define mini(a) int(min_element((a).begin(), (a).end()) - (a).begin())\r\n#define maxi(a) int(max_element((a).begin(), (a).end()) - (a).begin())\r\n#define lowb(a, x) int(lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\r\n#define uppb(a, x) int(upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\r\n#define repb(i, b) for (int i = 0; i < (b); ++i)\r\n#define repab(i, a, b) for (int i = (a); i < (b); ++i)\r\n#define repabd(i, a, b, d) for (int i = (a); i < (b); i += (d))\r\n#define GET_REP(_1, _2, _3, _4, NAME, ...) NAME\r\n#define re(...) GET_REP(__VA_ARGS__, repabd, repab, repb)(__VA_ARGS__)\r\n#define repra(i, a) for (int i = (a)-1; i >= 0; i--)\r\n#define reprab(i, a, b) for (int i = (a)-1; i >= (b); i--)\r\n#define reprabd(i, a, b, d) for (int i = (a)-1; i >= (b); i -= (d))\r\n#define GET_REPR(_1, _2, _3, _4, NAME, ...) NAME\r\n#define rer(...) GET_REPR(__VA_ARGS__, reprabd, reprab, repra)(__VA_ARGS__)\r\n#define eachone(a, x) for (auto &a : x)\r\n#define eachtwo(k, v, x) for (auto &[k, v] : x)\r\n#define eachthree(a, b, c, x) for (auto &[a, b, c] : x)\r\n#define eachfour(a, b, c, d, x) for (auto &[a, b, c, d] : x)\r\n#define GET_EACH(_1, _2, _3, _4, _5, NAME, ...) NAME\r\n#define ea(...) GET_EACH(__VA_ARGS__, eachfour, eachthree, eachtwo, eachone)(__VA_ARGS__)\r\n#define rvi(v, n) vi v = vi((n)); re(___i, n) cin >> v[___i];\r\n#define rvi2(v, n, m) vvi v = vvi((n), vi((m))); re(___i, n) re(___j, m) cin >> v[___i][___j];\r\n#define rvc(v, n) vc v = vc((n)); re(___i, n) cin >> v[___i];\r\n#define rvc2(v, n, m) vvc v = vvc((n), vc((m))); re(___i, n) re(___j, m) cin >> v[___i][___j];\r\n#define rvl(v, n) vl v = vl((n)); re(___i, n) cin >> v[___i];\r\n#define rvl2(v, n, m) vvl v = vvl((n), vl((m))); re(___i, n) re(___j, m) cin >> v[___i][___j];\r\n#define rvs(v, n) vs v = vs((n)); re(___i, n) cin >> v[___i];\r\n#define fail() fflush(stdout); cout.flush(); assert(false);\r\n#define YES cout << \"YES\\n\"\r\n#define YESR { cout << \"YES\\n\"; return; }\r\n#define Yes cout << \"Yes\\n\"\r\n#define Yesr { cout << \"Yes\\n\"; return; }\r\n#define yes cout << \"yes\\n\"\r\n#define yesr { cout << \"yes\\n\"; return; }\r\n#define NO cout << \"NO\\n\"\r\n#define NOR { cout << \"NO\\n\"; return; }\r\n#define No cout << \"No\\n\"\r\n#define Nor { cout << \"No\\n\"; return; }\r\n#define no cout << \"no\\n\";\r\n#define nor { cout << \"no\\n\"; return; }\r\n#define n0 cout << \"0\\n\"\r\n#define n0r { cout << \"0\\n\"; return; }\r\n#define n1 cout << \"-1\\n\"\r\n#define n1r { cout << \"-1\\n\"; return; }\r\ntemplate <typename A> using pqmax = priority_queue<A>;\r\ntemplate <typename A> using pqmin = priority_queue<A, vector<A>, greater<A>>;\r\n\r\nconst int MOD = (int) 1e9 + 7;\r\n// const int MOD = 998244353;\r\nconst dd PI = acos((dd) -1);\r\nconst int e1 = (int)1e1, e2 = (int)1e2, e3 = (int)1e3, e4 = (int)1e4, e5 = (int)1e5, e6 = (int)1e6, e7 = (int)1e7, e8 = (int)1e8, e9 = (int) 1e9;\r\nconst ll e10 = (ll)1e10, e11 = (ll)1e11, e12 = (ll)1e12, e13 = (ll)1e13, e14 = (ll)1e14, e15 = (ll)1e15, e16 = (ll) 1e16, e17 = (ll)1e17, e18 = (ll) 1e18;\r\n\r\ntemplate <typename A>\r\nvector<tuple<int, A>> enumerate(vector<A> v) {\r\n  vector<tuple<int, A>> res(sz(v));\r\n  re(i, sz(v)) res[i] = make_tuple(i, v[i]);\r\n  return res;\r\n}\r\n\r\nstruct mi {\r\n  ll v;\r\n  explicit operator ll() const { return v; }\r\n  mi() { v = 0; }\r\n  mi(ll _v) {\r\n    v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\r\n    if (v < 0) v += MOD;\r\n  }\r\n  friend bool operator==(const mi& a, const mi& b) { return a.v == b.v; }\r\n  friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\r\n  friend bool operator<(const mi& a, const mi& b) { return a.v < b.v; }\r\n  mi& operator+=(const mi& m) { if ((v += m.v) >= MOD) v -= MOD; return *this; }\r\n  mi& operator-=(const mi& m) { if ((v -= m.v) < 0) v += MOD; return *this; }\r\n  mi& operator*=(const mi& m) { v = v * m.v % MOD; return *this; }\r\n  mi& operator/=(const mi& m) { return (*this) *= inv(m); }\r\n  friend mi pow(mi a, ll p) {\r\n    mi ans = 1; assert(p >= 0);\r\n    for (; p; p /= 2, a *= a) if (p&1) ans *= a;\r\n    return ans;}\r\n  friend mi inv(const mi& a) {\r\n    assert(a.v != 0);\r\n    return pow(a, MOD - 2);}\r\n  mi operator-() const { return mi(-v); }\r\n  mi &operator++() { return *this += 1; }\r\n  mi &operator--() { return *this -= 1; }\r\n  mi operator++(int) {\r\n    mi temp = *this += 1;\r\n    return temp;}\r\n  mi operator--(int) {\r\n    mi temp = *this -= 1;\r\n    return temp;}\r\n  friend mi operator+(mi a, const mi &b) { return a += b; }\r\n  friend mi operator-(mi a, const mi &b) { return a -= b; }\r\n  friend mi operator*(mi a, const mi &b) { return a *= b; }\r\n  friend mi operator/(mi a, const mi &b) { return a /= b; }\r\n  friend ostream &operator<<(ostream &os, const mi &m) {\r\n    os << m.v;\r\n    return os;\r\n  }\r\n  friend istream &operator>>(istream &is, mi &m) {\r\n    ll x;\r\n    is >> x;\r\n    m.v = x;\r\n    return is;\r\n  }\r\n};\r\n\r\nstring to_string(mi x) { return to_string(x.v); }\r\nmi operator\"\" _mi(ull x) { return x; }\r\n\r\ntypedef vector<mi> vmi;\r\ntypedef vector<vector<mi>> vvmi;\r\ntypedef vector<vector<vector<mi>>> vvvmi;\r\ntypedef tuple<mi, mi> tmimi;\r\ntypedef tuple<mi, mi, mi> tmimimi;\r\ntypedef vector<tmimi> vmimi;\r\ntypedef vector<tmimimi> vmimimi;\r\ntypedef queue<mi> qmi;\r\n\r\ntemplate <typename T, typename = void> struct is_hashable_container {\r\n  static constexpr bool value = false;\r\n};\r\ntemplate <typename T>\r\nstruct is_hashable_container<T, void_t<decltype(T{}.begin()), decltype(T{}.end())>> {\r\n  static constexpr bool value = true;\r\n};\r\ntemplate <typename T, typename = void> struct is_tuple_like {\r\n  static constexpr bool value = false;\r\n};\r\ntemplate <typename T>\r\nstruct is_tuple_like<T, void_t<typename tuple_size<T>::type>> {\r\n  static constexpr bool value = true;\r\n};\r\ntemplate <typename T, typename = void> struct is_hashable {\r\n  static constexpr bool value = false;\r\n};\r\ntemplate <typename T> struct is_hashable<T, void_t<decltype(hash<T>{}(T{}))>> {\r\n  static constexpr bool value = true;\r\n};\r\n\r\nvector<size_t> VALS;\r\nstruct custom_hash {\r\n  static size_t getfixed(int i) {\r\n    while ((int) VALS.size() < i + 1)\r\n      if (VALS.empty())\r\n        VALS.push_back((size_t) chrono::steady_clock::now().time_since_epoch().count());\r\n      else\r\n        VALS.push_back(splitmix64(VALS.back()));\r\n    return VALS[i];\r\n  }\r\n  static size_t splitmix64(size_t x) {\r\n    x += (size_t)0x9e3779b97f4a7c15;\r\n    x = (x ^ (x >> (size_t)30)) * (size_t)0xbf58476d1ce4e5b9;\r\n    x = (x ^ (x >> (size_t)27)) * (size_t)0x94d049bb133111eb;\r\n    return x ^ (x >> (size_t)31);\r\n  }\r\n  size_t operator()(size_t x) const { return splitmix64(x + getfixed(0)); }\r\n  template <typename T>\r\n  enable_if_t<is_tuple_like<T>::value, size_t> operator()(const T &t) const {\r\n    int ic = 0;\r\n    size_t rh = 0;\r\n    apply([&](auto &&...args) {\r\n      ((rh ^= splitmix64(hash<decay_t<decltype(args)>>{}(args) + getfixed(ic++))), ...);\r\n    }, t);\r\n    return rh;\r\n  }\r\n  template <typename T>\r\n  enable_if_t<is_hashable_container<T>::value, size_t> operator()(const T &t) const {\r\n    int ic = 0; size_t rh = getfixed(0);\r\n    for (auto& x : t) rh &= splitmix64(x + getfixed(ic++));\r\n    return rh;\r\n  }\r\n};\r\n\r\n// Fix assignment/swap speed for gp_hash_table. https://codeforces.com/blog/entry/60737?#comment-850908\r\n// see temp/gp_swap.cpp for some tests\r\ntemplate<class K, class V, class H = std::hash<K>>\r\nclass fixed_gp : public __gnu_pbds::gp_hash_table<K, V, H> {\r\n  using base = __gnu_pbds::gp_hash_table<K, V, H>;\r\npublic:\r\n  fixed_gp() : base() {}\r\n  fixed_gp(const fixed_gp &other) : base(other) {}\r\n  fixed_gp(fixed_gp &&other) : base() { this->swap(other); }\r\n  auto operator=(const fixed_gp &other) -> fixed_gp & {\r\n    static_cast<base &>(*this).operator=(other);\r\n    return *this;\r\n  }\r\n  auto operator=(fixed_gp &&other) -> fixed_gp & {\r\n    this->swap(other);\r\n    other.clear();\r\n    return *this;\r\n  }\r\n  size_t count(const K &key) const { return this->find(key) != this->end(); }\r\n};\r\ntemplate <typename A, typename B> using umap = fixed_gp<A, B, custom_hash>;\r\ntemplate <typename A> using uset = fixed_gp<A, null_type, custom_hash>;\r\n\r\nconstexpr int pct(int x) { return __builtin_popcount(x); }\r\nconstexpr int pct(long long x) { return __builtin_popcountll(x); }\r\nconstexpr int bits(int x) { return x == 0 ? -1 : 31 - __builtin_clz(x); }\r\nconstexpr int bits(long long x) { return x == 0 ? -1 : 63 - __builtin_clzll(x); }\r\nconstexpr int p2(int x) { return 1 << x; }\r\n// msk2(i) = a mask with i+1 1s. msk2(-1) = 0.\r\nconstexpr int msk2(int x) { return x == 31 ? 0xFFFFFFFF : ((uint32_t)1 << (x + 1)) - 1; }\r\nconstexpr bool test(int x, int i) { return (x & (1 << i)) != 0; }\r\nconstexpr bool test(long long x, int i) { return (x & (1LL << i)) != 0; }\r\nint bitsrange(int l, int u) { assert(l <= u); return msk2(u) & ~msk2(l - 1); }\r\n\r\ntemplate <class T, class U> T ipow(T a, U p) {\r\n  T ans = 1; assert(p >= 0);\r\n  for (; p; p /= 2, a *= a) if (p&1) ans *= a;\r\n  return ans;\r\n}\r\ntemplate <class T, class U> T ipow(T a, U p, T m) {\r\n  T ans = 1; assert(p >= 0);\r\n  for (; p; p /= 2, a = (a * a) % m) if (p&1) ans = (ans * a) % m;\r\n  return ans;\r\n}\r\n\r\ntemplate <class T, class U> T fstTrue(T lo, T hi, U f) {\r\n  hi++;\r\n  assert(lo <= hi); // assuming f is increasing\r\n  while (lo < hi) { // find first index such that f is true\r\n    T mid = lo + (hi - lo) / 2;\r\n    f(mid) ? hi = mid : lo = mid + 1;\r\n  }\r\n  return lo;\r\n}\r\n\r\ntemplate <class T, class U> T lstTrue(T lo, T hi, U f) {\r\n  lo--;\r\n  assert(lo <= hi); // assuming f is decreasing\r\n  while (lo < hi) { // find first index such that f is true\r\n    T mid = lo + (hi - lo + 1) / 2;\r\n    f(mid) ? lo = mid : hi = mid - 1;\r\n  }\r\n  return lo;\r\n}\r\n\r\n// Requirements: f is unimodal. f has adjacent-distinct values except possibly at its mode\r\ntemplate <class T, class U>\r\nT ternary_search(T lo, T hi, U f, bool find_min = false) {\r\n  assert(lo <= hi);\r\n  return fstTrue(lo, hi - 1, [&](T n) { return find_min ? f(n) <= f(n + 1) : f(n) >= f(n + 1); });\r\n}\r\n\r\ntemplate <class T> T sum(vector<T> &v) {\r\n  if (v.empty()) return 0LL;\r\n  T sum = v[0];\r\n  for (int i = 1; i < (int) v.size(); i++) {\r\n    sum += v[i];\r\n  }\r\n  return sum;\r\n}\r\n\r\ntemplate <class F> F posmod(F a, F b) { return ((a % b) + b) % b; }\r\ntemplate <class F> F floordiv(F a, F d) { F res = a / d; if (res * d != a) res -= 1 & ((a>0)^(d>0)); return res; }\r\ntemplate <class F> F ceildiv(F a, F d) { F res = a / d; if (res * d != a) res += 1 & ((a<0)^(d>0)); return res; }\r\ntemplate <class F> F sq(F a) { return a * a; }\r\nll lcm(ll a, ll b) { return a*b / __gcd(a, b); }\r\n\r\nll arithprog(ll l, ll r, ll g=1) { // l + ... + r\r\n#ifdef LOCAL\r\n  assert((r - l) % g == 0);\r\n#endif\r\n  return ((r-l)/g + 1)*(l+r)/2;\r\n}\r\n\r\nlong long inv(long long a, long long b) {\r\n  return 1 < a ? b - inv(b % a, a) * b / a : 1;\r\n}\r\n\r\n// Not const T &b so that ckmax works with gp_hash_table with uninitialized element.\r\ntemplate <class T> bool ckmin(T &a, const T b) { return b < a ? a = b, 1 : 0; }\r\ntemplate <class T> bool ckmax(T &a, const T b) { return a < b ? a = b, 1 : 0; }\r\n\r\n// The sequence function from haskell but only for vectors, aka the cartesian product.\r\n// https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:sequence\r\n// example:\r\n// > sequence [[1,2,3],[4,5,6]]\r\n// [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]\r\ntemplate <class A>\r\nvec<vec<A>> sequence(const vec<vec<A>>& a) {\r\n  vec<vec<A>> res;\r\n  vec<A> current;\r\n  auto f = [&](auto&& self, int i) {\r\n    if (i == sz(a)) {\r\n      res.pb(current);\r\n      return;\r\n    }\r\n    ea(x, a[i]) {\r\n      current.pb(x);\r\n      self(self, i + 1);\r\n      current.popb();\r\n    }\r\n  };\r\n  f(f, 0);\r\n  return res;\r\n}\r\n\r\ndouble time() { return (double)chrono::steady_clock::now().time_since_epoch().count() / 1e9; }\r\n\r\n#ifdef LOCAL\r\nmt19937 rng(2222);\r\n#else\r\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\r\n#endif\r\nint rint(int a=std::numeric_limits<int>::min(), int b=std::numeric_limits<int>::max()) { // inclusive bounds\r\n  return uniform_int_distribution<int>(a, b)(rng);\r\n}\r\nll rlong(ll a=std::numeric_limits<ll>::min(), ll b=std::numeric_limits<ll>::max()) { // inclusive bounds\r\n  return uniform_int_distribution<ll>(a, b)(rng);\r\n}\r\ndouble rdouble(double a, double b) {\r\n  return uniform_real_distribution<double>(a, b)(rng);\r\n}\r\n// O(n/n + n/n-1 + ... _ n/(n-k+1)) = O(n*(H_n - H_{n-k})) ~ O(nlogn) for large k\r\nvi rsubset1(int n, int k) {\r\n  uset<int> found;\r\n  vi res;\r\n  re(i, k) {\r\n    while (true) {\r\n      int x = rint(0, n-1);\r\n      if (!found.count(x)) {\r\n        found.ins(x);\r\n        res.pb(x);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return res;\r\n}\r\n// O(n+k)\r\nvi rsubset2(int n, int k) {\r\n  vi pos(n); iota(all(pos), 0);\r\n  vi res;\r\n  re(i, k) {\r\n    int j = rint(0, sz(pos)-1);\r\n    res.pb(pos[j]);\r\n    if (j < sz(pos)-1) pos[j] = pos.back();\r\n    pos.popb();\r\n  }\r\n  return res;\r\n}\r\n// generate a subset of k elements from {0, 1, ..., n-1}.\r\nvi rsubset(int n, int k) {\r\n  assert(k <= n);\r\n  double cost1 = n*(log(n) - log(n-k+1));\r\n  double cost2 = 0.01*n + 0.2*k;\r\n  return cost1 < cost2 ? rsubset1(n, k) : rsubset2(n, k);\r\n}\r\n\r\ntemplate <class T> void shuffle(vector<T> &v) {\r\n  auto r0 = [](int x) { return rint(0, x-1); };\r\n  random_shuffle(all(v), r0);\r\n}\r\n\r\ntemplate <class T> void remdup(vector<T> &v, bool do_sort = true) { // sort and remove duplicates\r\n  if (do_sort) sort(all(v));\r\n  v.erase(unique(all(v)), end(v));\r\n}\r\n\r\ntemplate <class F> void print(const F a[], int n) {\r\n  for (int i = 0; i < n; i++) {\r\n    if (i > 0) cout << ' ';\r\n    cout << a[i];\r\n  }\r\n  cout << '\\n';\r\n}\r\n\r\ntemplate <class F> void print(const vector<F> &a) {\r\n  for (int i = 0; i < (int) a.size(); i++) {\r\n    if (i > 0) cout << ' ';\r\n    cout << a[i];\r\n  }\r\n  cout << '\\n';\r\n}\r\n\r\ntemplate <class F> void print2(const vector<vector<F>> &a) {\r\n  for (int i = 0; i < (int) a.size(); i++) {\r\n    for (int j = 0; j < (int) a[i].size(); j++) {\r\n      if (j > 0) cout << ' ';\r\n      cout << a[i][j];\r\n    }\r\n    cout << '\\n';\r\n  }\r\n}\r\n\r\nstring reps(string s, int t) {\r\n  string res = \"\"; res.reserve(sz(s) * t);\r\n  re(i, t) res += s;\r\n  return res;\r\n}\r\n\r\nstring reps(char c, int t) { return string(t, c); }\r\n\r\nll binary_to_ll(string s) { return stoll(s, nullptr, 2); }\r\nstring ll_to_binary(ll x) {\r\n  assert(x >= 0);\r\n  return !x ? \"0\" : bitset<64>(x).to_string().substr(63 - bits(x), 1 + bits(x));\r\n}\r\n\r\nvector<string> split(string s, string delimiter) {\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  string token;\r\n  vector<string> res;\r\n  while ((pos_end = s.find(delimiter, pos_start)) != string::npos) {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    pos_start = pos_end + delim_len;\r\n    res.push_back(token);\r\n  }\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\n\r\nvector<string> split(string s, char delimiter) { return split(s, string(1, delimiter)); }\r\n\r\ntemplate <typename... Ts> string to_string(const tuple<Ts...> t);\r\ntemplate <typename A, typename B> string to_string(const pair<A, B> t);\r\n\r\nstring to_string(const string s) { return string(s); }\r\nstring to_string(const char c) { return string(1, c); }\r\n\r\ntemplate <class T, size_t K> string to_string(array<T, K> v) {\r\n  string out = \"[\";\r\n  re(i, (int) K) { if (i > 0) out += \", \"; out += to_string(v[i]); }\r\n  out += ']';\r\n  return out;\r\n}\r\n\r\ntemplate <class T, size_t K> ostream &operator<<(ostream &output, const array<T, K> v) {\r\n  output << to_string(v);\r\n  return output;\r\n}\r\n\r\ntemplate<typename T, typename = void>\r\nstruct is_container : std::false_type {};\r\n\r\ntemplate<typename T>\r\nstruct is_container<T, std::void_t<decltype(T{}.begin()), decltype(T{}.end())>> : std::true_type {};\r\n\r\ntemplate<typename CharT, typename Traits, typename Alloc>\r\nstruct is_container<std::basic_string<CharT, Traits, Alloc>, void> : std::false_type {};\r\n\r\ntemplate <class T> enable_if_t<is_container<T>::value, string> to_string(const T &t) {\r\n  string out = \"[\";\r\n  int i = 0;\r\n  for (const auto &x : t) { if (i++ > 0) out += \", \"; out += to_string(x); }\r\n  out += ']';\r\n  return out;\r\n}\r\n\r\ntemplate <class T> enable_if_t<is_container<T>::value, ostream> &operator<<(ostream &output, const T &t) {\r\n    output << to_string(t);\r\n    return output;\r\n}\r\n\r\ntemplate <typename... Ts> string to_string(const tuple<Ts...> t) {\r\n  string out;\r\n  out += '(';\r\n  apply([&](auto &&...args) { ((out += to_string(args) + \", \"), ...); }, t);\r\n  out.pop_back();\r\n  out.pop_back();\r\n  out += ')';\r\n  return out;\r\n}\r\n\r\ntemplate <typename... Ts>\r\nostream &operator<<(ostream &output, const tuple<Ts...> t) {\r\n  output << to_string(t);\r\n  return output;\r\n}\r\n\r\ntemplate <typename A, typename B> string to_string(const pair<A, B> t) {\r\n  string out;\r\n  out += '(';\r\n  out += to_string(t.first);\r\n  out += \", \";\r\n  out += to_string(t.second);\r\n  out += ')';\r\n  return out;\r\n}\r\n\r\ntemplate <typename A, typename B> ostream &operator<<(ostream &output, const pair<A, B> t) {\r\n  output << to_string(t);\r\n  return output;\r\n}\r\n\r\n#ifdef LOCAL\r\n#define dbg(...) logger(#__VA_ARGS__, __VA_ARGS__)\r\ntemplate <typename... Args> void logger(string vars, Args &&...values) {\r\n  cout << \"| \" << vars << \" = \";\r\n  string delim = \"\";\r\n  (..., (cout << delim << values, delim = \", \"));\r\n  cout << endl;\r\n}\r\n#else\r\n#define dbg(...) 0\r\n#endif\r\n\r\nconst int MX = 0;\r\nbool facinit = false;\r\nmi facs[MX];\r\nmi facInvs[MX];\r\n\r\nmi ncr(ll a, ll b) {\r\n  assert(facinit && a < MX && b < MX);\r\n  assert(a >= 0 && b >= 0 && b <= a); // disable this assert whenever necessary\r\n  if (b > a || a < 0 || b < 0)\r\n    return 0;\r\n  mi cur = facs[a];\r\n  cur = cur * facInvs[b];\r\n  cur = cur * facInvs[a - b];\r\n  return cur;\r\n}\r\n\r\nvoid initfacs() {\r\n  facs[0] = 1;\r\n  re(i, 1, MX) facs[i] = i * facs[i - 1];\r\n  facInvs[MX - 1] = inv(facs[MX - 1]);\r\n  rer(i, MX - 1) facInvs[i] = facInvs[i + 1] * (i + 1);\r\n  facinit = true;\r\n}\r\n\r\nvoid setIO() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0); cout << fixed << setprecision(15);\r\n  #ifdef GDB\r\n  #define STRINGIZE(x) #x\r\n  #define STRINGIZE_VALUE_OF(x) STRINGIZE(x)\r\n  string basename = STRINGIZE_VALUE_OF(FNAME);\r\n  basename = basename.substr(1, sz(basename)-2);\r\n  string file_in = basename + \".in\";\r\n  string file_out = basename + \".out\";\r\n  freopen(file_in.c_str(), \"r\", stdin);\r\n  freopen(file_out.c_str(), \"w\", stdout);\r\n  #endif\r\n}\r\n\r\n// Uniformly generate trees of size n.\r\n// https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence\r\n// https://cp-algorithms.com/graph/pruefer_code.html#\r\nvvi pruferToTree(vi &code) {\r\n  int n = sz(code) + 2;\r\n  vector<int> degree(n, 1);\r\n  for (int i : code)\r\n    degree[i]++;\r\n\r\n  int ptr = 0;\r\n  while (degree[ptr] != 1)\r\n    ptr++;\r\n  int leaf = ptr;\r\n\r\n  vector<pair<int, int>> edges;\r\n  for (int v : code) {\r\n    edges.emplace_back(leaf, v);\r\n    if (--degree[v] == 1 && v < ptr) {\r\n      leaf = v;\r\n    } else {\r\n      ptr++;\r\n      while (degree[ptr] != 1)\r\n        ptr++;\r\n      leaf = ptr;\r\n    }\r\n  }\r\n  edges.emplace_back(leaf, n-1);\r\n\r\n  vvi adj(n);\r\n  ea(u, v, edges) {\r\n    adj[u].pb(v);\r\n    adj[v].pb(u);\r\n  }\r\n  return adj;\r\n}\r\n\r\n// Up until n=8 is fast. n=9 in < 10 seconds.\r\nvec<vvi> allTrees(int n) {\r\n  assert(n > 1);\r\n  vvi cart;\r\n  re(i, n-2) {\r\n    vi v(n); iota(all(v), 0);\r\n    cart.pb(v);\r\n  }\r\n  vec<vvi> res;\r\n  ea(v, sequence(cart)) {\r\n    res.pb(pruferToTree(v));\r\n  }\r\n  return res;\r\n}\r\n\r\n// Generate a random tree.\r\nvvi treeGen(int n) {\r\n  if (n == 1) {\r\n    vvi adj(1); return adj;\r\n  } else {\r\n    vi seq(n-2);\r\n    re(i, n-2) seq[i] = rint(0, n-1);\r\n    return pruferToTree(seq);\r\n  }\r\n}\r\n\r\n\r\nstruct Node {\r\n  int n = 1;\r\n  mset<int> s;\r\n  set<int> m = {0};\r\n\r\n  Node() {}\r\n\r\n  void inc() {\r\n    if (s.find(n) == s.end()) m.ins(n);\r\n    n++;\r\n  }\r\n\r\n  void add(int x) {\r\n    m.erase(x);\r\n    s.ins(x);\r\n  }\r\n\r\n  void rem(int x) {\r\n    s.erase(s.find(x));\r\n    if (s.find(x) == s.end()) m.ins(x);\r\n  }\r\n\r\n  int mex() {\r\n    while (m.empty() || n < *m.begin()) {\r\n      inc();\r\n    }\r\n    return *m.begin();\r\n  }\r\n};\r\n\r\nconst int N = 5*e5+10;\r\nvi act, rnk;\r\nvec<Node> b;\r\nvi a[N];\r\n\r\nbool sol(int n, vvi &adj, vi &roots) {\r\n  act.assign(n, 1);\r\n  b.assign(n, {});\r\n  rnk.assign(n, e9);\r\n  re(i, n) {\r\n    b[i].add(0);\r\n    a[i] = {0};\r\n  }\r\n\r\n  auto f = [&](auto&& self, int cur) -> void {\r\n    for (int e : adj[cur]) {\r\n      self(self, e);\r\n      rnk[cur] = min(rnk[cur], rnk[e]);\r\n      if (act[e] > act[cur]) {\r\n        swap(a[e], a[cur]);\r\n        swap(b[e], b[cur]);\r\n        swap(act[e], act[cur]);\r\n      }\r\n \r\n      while (act[e] != 1 && act[cur] > act[e]) {\r\n        int j = sz(a[cur]) - act[cur];\r\n        b[cur].rem(a[cur][j]);\r\n        act[cur]--;\r\n      }\r\n \r\n      for (int i=0; i<act[e]; i++) {\r\n        int j = sz(a[cur]) - 1 - i;\r\n        b[cur].rem(a[cur][j]);\r\n        a[cur][j] ^= a[e][sz(a[e]) - 1 - i];\r\n        b[cur].add(a[cur][j]);\r\n      }\r\n      b[e].s.clear();\r\n    }\r\n \r\n    if (rnk[cur] == (int)1e9) rnk[cur] = 0;\r\n    a[cur].push_back(b[cur].mex());\r\n    b[cur].add(a[cur].back());\r\n    rnk[cur]++;\r\n    act[cur]++;\r\n  };\r\n\r\n  int ans = 0;\r\n  ea(r, roots) {\r\n    f(f, r);\r\n    ans ^= a[r].back();\r\n  }\r\n  return ans != 0;\r\n}\r\n\r\nvoid solve() {\r\n  int n; cin >> n;\r\n  vvi adj(n);\r\n  rvi(p, n);\r\n  vi roots;\r\n  re(i, n) {\r\n    if (p[i] == 0) {\r\n      roots.pb(i);\r\n    } else {\r\n      adj[p[i]-1].pb(i);\r\n    }\r\n  }\r\n  bool s1 = sol(n, adj, roots);\r\n  if (s1) YESR;\r\n  NOR;\r\n\r\n\r\n  // re(_i, 1) {\r\n  //   int n = 5*e5;\r\n  //   // int n = 20;\r\n  //   // int n = rint(20, 30);\r\n  //   vvi gadj = treeGen(n);\r\n  //   vvi adj(n);\r\n  //   auto g = [&](auto&& self, int u, int p) -> void {\r\n  //     ea(v, gadj[u]) {\r\n  //       if (v == p) continue;\r\n  //       adj[u].pb(v);\r\n  //       self(self, v, u);\r\n  //     }\r\n  //   };\r\n  //   g(g, 0, 0);\r\n\r\n  //   vi roots = {0};\r\n  //   // dbg(\"start\");\r\n  //   bool s1 = sol(n, adj, roots);\r\n  //   dbg(s1);\r\n  // }\r\n}\r\n\r\nint32_t main() {\r\n  setIO();\r\n  int t = 1;\r\n  cin >> t;\r\n\r\n  #ifdef LOCAL\r\n  double time_start = time();\r\n  #endif\r\n  re(_t, t) solve();\r\n  #ifdef LOCAL\r\n  cout << \"done. elapsed: \" << setprecision(2) << time() - time_start << endl;\r\n  #endif\r\n  return 0;\r\n}\r\n"
}