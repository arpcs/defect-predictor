{
    "id": 223427172,
    "contestId": 1684,
    "creationTimeSeconds": 1694748078,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1684,
        "index": "H",
        "name": "Hard Cut",
        "type": "PROGRAMMING",
        "points": 3250.0,
        "rating": 3400,
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "divide and conquer",
            "math"
        ]
    },
    "author": {
        "contestId": 1684,
        "members": [
            {
                "handle": "cmk666"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1652970900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 6553600,
    "source": "/*\r\n * @Author:             cmk666\r\n * @Created time:       2023-09-15 08:16:24\r\n * @Last Modified time: 2023-09-15 11:21:06\r\n */\r\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\r\n#include<bits/stdc++.h>\r\n#ifdef LOCAL\r\n#include\"debug.h\"\r\n#else\r\n#define D(...) ((void)0)\r\n#endif\r\nusing namespace std; using ll = long long;\r\n#define For(i, j, k) for ( int i = (j) ; i <= (k) ; i++ )\r\n#define Fol(i, j, k) for ( int i = (j) ; i >= (k) ; i-- )\r\nnamespace FastIO\r\n{\r\n// ------------------------------\r\n// #define IN_HAS_NEG\r\n// #define OUT_HAS_NEG\r\n// #define CHK_EOF\r\n// #define DISABLE_MMAP\r\n// ------------------------------\r\n#if __cplusplus < 201400\r\n#error Please use C++14 or higher.\r\n#endif\r\n#if __cplusplus > 201700\r\n#define INLINE_V inline\r\n#else\r\n#define INLINE_V\r\n#endif\r\n#if ( defined(LOCAL) || defined(_WIN32) ) && !defined(DISABLE_MMAP)\r\n#define DISABLE_MMAP\r\n#endif\r\n#ifndef DISABLE_MMAP\r\n#include<sys/mman.h>\r\n#endif\r\n#ifdef LOCAL\r\n\tinline char gc() { return getchar(); }\r\n\tinline void pc(char c) { putchar(c); }\r\n#else\r\n#ifdef DISABLE_MMAP\r\n\tINLINE_V constexpr int _READ_SIZE = 1 << 18;\r\n\tINLINE_V static char _read_buffer[_READ_SIZE], *_read_ptr = nullptr, *_read_ptr_end = nullptr;\r\n\tinline char gc()\r\n\t{\r\n\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) )\r\n\t\t{\r\n\t\t\t_read_ptr = _read_buffer;\r\n\t\t\t_read_ptr_end = _read_buffer + fread(_read_buffer, 1, _READ_SIZE, stdin);\r\n#ifdef CHK_EOF\r\n\t\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) ) return EOF;\r\n#endif\r\n\t\t}\r\n\t\treturn *_read_ptr++;\r\n\t}\r\n#else\r\n\tINLINE_V static const char *_read_ptr = (const char *)mmap(nullptr, INT_MAX, 1, 2, 0, 0);\r\n\tinline char gc() { return *_read_ptr++; }\r\n#endif\r\n\tINLINE_V constexpr int _WRITE_SIZE = 1 << 18;\r\n\tINLINE_V static char _write_buffer[_WRITE_SIZE], *_write_ptr = _write_buffer;\r\n\tinline void pc(char c)\r\n\t{\r\n\t\t*_write_ptr++ = c;\r\n\t\tif ( __builtin_expect(_write_buffer + _WRITE_SIZE == _write_ptr, false) )\r\n\t\t{\r\n\t\t\tfwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout);\r\n\t\t\t_write_ptr = _write_buffer;\r\n\t\t}\r\n\t}\r\n\tINLINE_V struct _auto_flush\r\n\t{\r\n\t\tinline ~_auto_flush() { fwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout); }\r\n\t}\t_auto_flush;\r\n#endif\r\n#ifdef CHK_EOF\r\n\tinline constexpr bool _isdigit(char c) { return ( c & 16 ) && c != EOF; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32 && c != EOF; }\r\n#else\r\n\tinline constexpr bool _isdigit(char c) { return c & 16; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32; }\r\n#endif\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_integer = numeric_limits < T >::is_integer;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_signed = numeric_limits < T >::is_signed;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_unsigned = _is_integer < T > && !_is_signed < T >;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __uint128_t > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_signed < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_unsigned < __uint128_t > = true;\r\n#undef INLINE_V\r\n\tinline void read(char &c) { do c = gc(); while ( !_isgraph(c) ); }\r\n\tinline void read_cstr(char *s)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) *s++ = c, c = gc();\r\n\t\t*s = 0;\r\n\t}\r\n\tinline void read(string &s)\r\n\t{\r\n\t\tchar c = gc(); s.clear(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) s.push_back(c), c = gc();\r\n\t}\r\n#ifdef IN_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); bool f = true; x = 0;\r\n\t\twhile ( !_isdigit(c) ) { if ( c == 45 ) f = false; c = gc(); }\r\n\t\tif ( f ) while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t\telse     while ( _isdigit(c) ) x = x * 10 - ( c & 15 ), c = gc();\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isdigit(c) ) c = gc();\r\n\t\tx = 0; while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t}\r\n\tinline void write(char c) { pc(c); }\r\n\tinline void write_cstr(const char *s) { while ( *s ) pc(*s++); }\r\n\tinline void write(const string &s) { for ( char c : s ) pc(c); }\r\n#ifdef OUT_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tif ( x >= 0 )  do buffer[digits++] =  ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\telse { pc(45); do buffer[digits++] = -( x % 10 ) | 48, x /= 10; while ( x ); }\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tdo buffer[digits++] = ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < int N > struct _tuple_io_helper\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_read(x), read(get < N - 1 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_write(x), pc(32), write(get < N - 1 > (x)); }\r\n\t};\r\n\ttemplate <> struct _tuple_io_helper < 1 >\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x) { read(get < 0 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x) { write(get < 0 > (x)); }\r\n\t};\r\n\ttemplate < class ...T >\r\n\tinline void read(tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_read(x); }\r\n\ttemplate < class ...T >\r\n\tinline void write(const tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_write(x); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void read(pair < T1, T2 > &x) { read(x.first), read(x.second); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void write(const pair < T1, T2 > &x) { write(x.first), pc(32), write(x.second); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void read(T1 &x, T2 &...y) { read(x), read(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void read_cstr(char *x, T *...y) { read_cstr(x), read_cstr(y...); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void write(const T1 &x, const T2 &...y) { write(x), write(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void write_cstr(const char *x, const T *...y) { write_cstr(x), write_cstr(y...); }\r\n\ttemplate < class T >\r\n\tinline void print(const T &x) { write(x); }\r\n\tinline void print_cstr(const char *x) { write_cstr(x); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void print(const T1 &x, const T2 &...y) { print(x), pc(32), print(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void print_cstr(const char *x, const T *...y) { print_cstr(x), pc(32), print_cstr(y...); }\r\n\tinline void println() { pc(10); }\r\n\tinline void println_cstr() { pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println(const T &...x) { print(x...), pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println_cstr(const T *...x) { print_cstr(x...), pc(10); }\r\n}\r\nusing namespace FastIO;\r\nchar s[1000009]; int n, pos[1000009], len; bool used[1000009];\r\nvector < pair < int, int > > ans; ll sum, nw;\r\ninline void solve(int *p, int l)\r\n{\r\n\tconst auto f = [&](int l, int r) { ans.emplace_back(l, r); };\r\n\tconst auto f1 = [&](int l, int r) { For(i, l, r) f(p[i], p[i]); };\r\n\tconst auto f3 = [&](int l, int r) { f(l, l + 1); if ( l + 1 != r ) f(r, r); };\r\n\tswitch ( l )\r\n\t{\r\n\tcase 1:\r\n\t\tf1(1, 1);\r\n\t\treturn;\r\n\tcase 3:\r\n\t\tf3(p[1], p[2]), f1(3, 3);\r\n\t\treturn;\r\n\tcase 4:\r\n\t\tif ( p[1] + 1 == p[2] && p[2] + 1 == p[3] ) f(p[1], p[3]), f1(4, 4);\r\n\t\telse if ( p[1] + 1 == p[2] ) f(p[1], p[2] + 1), f1(3, 4);\r\n\t\telse if ( p[1] + 2 == p[2] ) f(p[1], p[2]), f3(p[3], p[4]);\r\n\t\telse f(p[1], p[1] + 2), f3(p[2], p[3]), f1(4, 4);\r\n\t\treturn;\r\n\tcase 5:\r\n\t\tif ( p[1] + 1 == p[2] )\r\n\t\t{\r\n\t\t\tif ( p[2] + 1 == p[3] )\r\n\t\t\t{\r\n\t\t\t\tif ( p[3] + 1 == p[4] ) f(p[1], p[4]), f(p[5], p[5]);\r\n\t\t\t\telse f(p[1], p[2]), f(p[3], p[3] + 1), f3(p[4], p[5]);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( p[2] + 2 == p[3] ) f(p[1], p[1]), f(p[2], p[3]), f1(4, 5);\r\n\t\t\t\telse f1(1, 1), f(p[2], p[2] + 2), f1(3, 5);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse f(p[1], p[1] + 1), f3(p[2], p[3]), f3(p[4], p[5]);\r\n\t\treturn;\r\n\tcase 9:\r\n\t\tif ( p[1] + 1 == p[2] )\r\n\t\t{\r\n\t\t\tif ( p[2] + 1 == p[3] ) f(p[1], p[3]), f3(p[4], p[5]), f3(p[6], p[7]), f3(p[8], p[9]);\r\n\t\t\telse f(p[1], p[2] + 1), f(p[3], p[3]), f3(p[4], p[5]), f3(p[6], p[7]), f3(p[8], p[9]);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( p[1] + 2 == p[2] )\r\n\t\t\t{\r\n\t\t\t\tif ( p[3] + 1 == p[4] )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( p[4] + 1 == p[5] ) f(p[1], p[2]), f(p[3], p[5]), f1(6, 9);\r\n\t\t\t\t\telse f(p[1], p[2]), f(p[3], p[4] + 1), f1(5, 9);\r\n\t\t\t\t}\r\n\t\t\t\telse f(p[1], p[2]), f(p[3], p[3] + 1), f3(p[4], p[5]), f3(p[6], p[7]), f3(p[8], p[9]);\r\n\t\t\t}\r\n\t\t\telse f(p[1], p[1] + 2), f3(p[2], p[3]), f3(p[4], p[5]), f3(p[6], p[7]), f3(p[8], p[9]);\r\n\t\t}\r\n\t\treturn;\r\n\tcase 10:\r\n\t\tif ( p[1] + 1 == p[2] )\r\n\t\t{\r\n\t\t\tif ( p[2] + 1 == p[3] ) f(p[1], p[3]), f3(p[4], p[5]), f3(p[6], p[7]), f1(8, 10);\r\n\t\t\telse f(p[1], p[2] + 1), f3(p[3], p[4]), f3(p[5], p[6]), f3(7, 10);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( p[1] + 2 == p[2] ) f(p[1], p[2]), f3(p[3], p[4]), f3(p[5], p[6]), f3(p[7], p[8]), f1(9, 10);\r\n\t\t\telse f(p[1], p[1] + 2), f3(p[2], p[3]), f3(p[4], p[5]), f3(p[6], p[7]), f(8, 10);\r\n\t\t}\r\n\t\treturn;\r\n\tcase 11:\r\n\t\tf3(p[1], p[2]), f3(p[3], p[4]), f3(p[5], p[6]), f3(p[7], p[8]), f3(p[9], p[10]), f1(11, 11);\r\n\t\treturn;\r\n\t}\r\n\tsolve(p, l / 2);\r\n\tif ( ( l & 1 ) && __builtin_popcount(l - l / 2) == 1 ) f1(l / 2 + 1, l);\r\n\telse solve(p + l / 2, l - l / 2);\r\n}\r\ninline void work()\r\n{\r\n\tread_cstr(s + 1), n = strlen(s + 1);\r\n\tans.clear(), len = 0, fill(used + 1, used + n + 1, false);\r\n\tFor(i, 1, n) if ( s[i] == '1' ) pos[++len] = i;\r\n\tif ( !len ) { println(\"-1\\n\"s); return; }\r\n\tsolve(pos, len);\r\n\tfor ( auto [i, j] : ans ) For(k, i, j) used[k] = true;\r\n\tFor(i, 1, n) if ( !used[i] ) ans.emplace_back(i, i);\r\n\tsum = 0;\r\n\tfor ( auto [i, j] : ans ) { nw = 0; For(k, i, j) nw = nw * 2 + s[k] - '0'; sum += nw; }\r\n\tassert(__builtin_popcountll(sum) == 1);\r\n\tsort(ans.begin(), ans.end()), println(ans.size());\r\n\tfor ( auto [i, j] : ans ) println(i, j);\r\n\tprintln();\r\n}\r\nint main() { int t; read(t); For(tt, 1, t) work(); return 0; }\r\n// \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f\r\n// \u4f0a\u5a1c\u53ef\u7231\u634f \u4f0a\u5a1c\u8d34\u8d34\u634f"
}