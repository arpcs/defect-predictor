{
    "id": 233011843,
    "contestId": 1671,
    "creationTimeSeconds": 1700160876,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1671,
        "index": "D",
        "name": "Insert a Progression",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1671,
        "members": [
            {
                "handle": "formidablechief_27"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1650638100
    },
    "programmingLanguage": "Java 8",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 155,
    "memoryConsumedBytes": 0,
    "source": "// By FormidableChief_27\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n    long mod = (long)1e9 + 7;\r\n    long inf = (long) (9e18);\r\n    PrintWriter out = new PrintWriter(System.out);\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n    StringTokenizer st;\r\n    Scanner SC = new Scanner(System.in);\r\n\r\n    String ins() {while (st == null || !st.hasMoreElements()) {try {st = new StringTokenizer(br.readLine());} catch (IOException e) {}} return st.nextToken();}\r\n    char[] inc() {return ins().toCharArray();}\r\n    ArrayList<Character> incl() {ArrayList<Character> ch = new ArrayList<>(); String s = ins(); for(int i=0;i<s.length();i++) ch.add(s.charAt(i)); return ch;}\r\n    int ini() {return Integer.parseInt(ins());}\r\n    long in() {return Long.parseLong(ins());}\r\n    double ind() {return Double.parseDouble(ins());}\r\n\r\n    void p(String s) {out.print(s);}\r\n    void p(int s) {out.print(s);}\r\n    void p(long s) {out.print(s);}\r\n    void p(double s) {out.print(s);}\r\n    void p(char s) {out.print(s);}\r\n    void pl(String s) {out.println(s);}\r\n    void pl(int s) {out.println(s);}\r\n    void pl(long s) {out.println(s);}\r\n    void pl(double s) {out.println(s);}\r\n    void pl(char c) {out.println(c);}\r\n    void pl() {out.println();}\r\n    void ps(int s) {out.print(s + \" \");}\r\n    void ps(long s) {out.print(s + \" \");}\r\n    void ps(double s) {out.print(s + \" \");}\r\n    void ps(char c) {out.print(c + \" \");}\r\n    void yes() {pl(\"YES\");}\r\n    void no() {pl(\"NO\");}\r\n\r\n    long max(long a, long b) {return a > b ? a : b;}\r\n    long min(long a, long b) {return a > b ? b : a;}\r\n    long ceil(long a, long b) {return ((long) Math.ceil(((double) (a) / b)));}\r\n    long abs(long a) {if (a < 0) return (-1 * a);return a;}\r\n    long log(long a) {return (long) (Math.log(a));}\r\n    long log2(long a) {return (long) (Math.log(a) / Math.log(2));}\r\n    long gcd(long a, long b) {if (b == 0)return a;return gcd(b, a % b);}\r\n    long lcm(long a, long b) {return ((a * b) / gcd(a, b));}\r\n    long add(long a, long b) {return (((a + mod) % mod + (b + mod) % mod) % mod);}\r\n    long sub(long a, long b) {return (((a + mod) % mod + ((-b) + mod) % mod) % mod);}\r\n    long mul(long a, long b) {return ((a % mod * b % mod) % mod);}\r\n    long inv(long x) {return pow(x, mod - 2);}\r\n    long div(long x, long y) {return mul(x, inv(y));}\r\n    long pow(long a, long b) {a %= mod;long res = 1;while (b > 0) {if ((b & 1) != 0)res = mul(res, a);a = mul(a, a);b /= 2;}return res;}\r\n    long sqrt(long x) {long start = 0, end = (long) 3e9, ans = 1; while (start <= end) {long mid = (start + end) / 2; if (mid * mid <= x) {ans = mid;start = mid + 1;} else end = mid - 1;} return ans;}\r\n\r\n    ArrayList<Long> lin(int n) {ArrayList<Long> a = new ArrayList<Long>(n);for (int i = 0; i < n; i++) a.add(in()); return a;}\r\n    long sum(ArrayList<Long> a) {long sum = 0; for(long ele : a) sum += ele; return sum;}\r\n    void sort(ArrayList<Long> a) {Collections.sort(a);}\r\n    void rsort(ArrayList<Long> a) {Collections.sort(a, Collections.reverseOrder());}\r\n    void ps(ArrayList<Long> a) {for(long ele : a) ps(ele); pl();}\r\n    \r\n    long[] in(int n) {long a[] = new long[n]; for (int i = 0; i < n; i++) a[i] = in();return a;}\r\n    int[] ini(int n) {int a[] = new int[n]; for (int i = 0; i < n; i++) a[i] = ini();return a;}\r\n    long sum(long a[]) {long sum = 0; for(long ele : a) sum += ele; return sum;}\r\n    void ps(long a[]) {for(long ele : a) ps(ele); pl();}\r\n    int max(long a[]) {int in = 0;long m = a[0];for (int i = 1; i < a.length; i++) {if (a[i] > m) {m = a[i];in = i;}}return in;}\r\n    int min(long a[]) {int in = 0;long m = a[0];for (int i = 1; i < a.length; i++) {if (a[i] < m) {m = a[i];in = i;}}return in;}\r\n    void sort(long a[]) {divide(a, 0, a.length - 1, true);}\r\n    void rsort(long a[]) {divide(a, 0, a.length - 1, false);}\r\n    void divide(long a[], int l, int r, boolean order) {if (l < r) {int m = l + (r - l) / 2;divide(a, l, m, order);divide(a, m + 1, r, order);merge(a, l, m, r, order);}}\r\n    void merge(long a[], int l, int m, int r, boolean order) {int n1 = m - l + 1;int n2 = r - m;long L[] = new long[n1];long R[] = new long[n2];for (int i = 0; i < n1; ++i) L[i] = a[l + i];for (int j = 0; j < n2; ++j) R[j] = a[m + 1 + j];int i = 0, j = 0; int k = l;while (i < n1 && j < n2) {if ((L[i] <= R[j] && order) || (L[i] >= R[j] && !order)) {a[k] = L[i];i++;} else {a[k] = R[j];j++;}k++;}while (i < n1) {a[k] = L[i];i++;k++;}while (j < n2) {a[k] = R[j];j++;k++;}}\r\n    void sort(long a[][]) {divide(a, 0, a[0].length - 1, true);}\r\n    void rsort(long a[][]) {divide(a, 0, a[0].length - 1, false);}\r\n    void divide(long a[][], int l, int r, boolean order) {if (l < r) {int m = l + (r - l) / 2;divide(a, l, m, order);divide(a, m + 1, r,order);merge(a, l, m, r, order);}}\r\n    void merge(long a[][], int l, int m, int r, boolean order) {int n1 = m - l + 1;int n2 = r - m;long L[] = new long[n1]; long R[] = new long[n2];long b1[][] = new long[a.length][n1]; long b2[][] = new long[a.length][n2];for (int i = 0; i < n1; ++i) {L[i] = a[0][l + i];for (int p = 1; p < a.length; p++) b1[p][i] = a[p][l + i];}for (int j = 0; j < n2; ++j) {R[j] = a[0][m + 1 + j];for (int p = 1; p < a.length; p++) b2[p][j] = a[p][m + 1 + j];}int i = 0, j = 0; int k = l;while (i < n1 && j < n2) {if ((L[i] <= R[j] && order) || (L[i] >= R[j] && !order)) {a[0][k] = L[i]; for (int p = 1; p < a.length; p++) a[p][k] = b1[p][i];i++;} else {a[0][k] = R[j];for (int p = 1; p < a.length; p++) a[p][k] = b2[p][j];j++;}k++;}while (i < n1) {a[0][k] = L[i];for (int p = 1; p < a.length; p++) a[p][k] = b1[p][i];i++;k++;}while (j < n2) {a[0][k] = R[j];for (int p = 1; p < a.length; p++) a[p][k] = b2[p][j];j++;k++;}}\r\n    \r\n    void fillmap(Map<Long, Long> map, long a[]) {for (int i = 0; i < a.length; i++) {fill(map, a[i]);}}\r\n    void fill(Map<Long, Long> map, long val) {if (map.containsKey(val))map.put(val, map.get(val) + 1); else map.put(val, (long) 1);}\r\n    void fill(Map<Long, Long> map, long val, long count) {if(map.containsKey(val)) map.put(val, map.get(val) + count); else map.put(val, count);}\r\n    void remove(Map<Long, Long> map, long val) {if (map.get(val) == 1) map.remove(val); else map.replace(val, map.get(val) - 1);}\r\n    void replace(Map<Long, Long> map, long val, long newval) {remove(map, val);fill(map, newval);}\r\n    void fill(Map<Long, ArrayList<Long>> map, long a[]) {for (int i = 0; i < a.length; i++) {fill(map, a[i], i);}}\r\n    void fill(Map<Long, ArrayList<Long>> map, long val, int i) {if (map.containsKey(val)) map.get(val).add((long) i); else {ArrayList<Long> index = new ArrayList<>();index.add((long) i);map.put(val, index);}}\r\n    void lfill(Map<Long, Long> map, ArrayList<Long> a) {for (Map.Entry<Long, Long> entry : map.entrySet()) {long val = entry.getValue(); long key = entry.getKey();for (long j = 0; j < val; j++) a.add(key);}}\r\n    int MAXN = 1000001;int spf[] = new int[MAXN];\r\n    public void sieve() {spf[1] = 1; for (int i = 2; i < MAXN; i++) spf[i] = i;for (int i = 4; i < MAXN; i += 2) spf[i] = 2;for (int i = 3; i * i < MAXN; i++) if (spf[i] == i) for (int j = i * i; j < MAXN; j += i) if (spf[j] == j) spf[j] = i;}\r\n    public void primefactors(HashMap<Long, Long> map, int x) {while (x != 1) {fill(map, spf[x]);x /= spf[x];}}\r\n   \r\n    ArrayList<Integer> search(char text[], char pattern[]) {ArrayList<Integer> indexes = new ArrayList<Integer>(text.length);int m = pattern.length;int n = text.length;long d = 31;long hashp = 0;long hasht = 0;long h = 1;for (int i = 0; i < m - 1; i++) {h = mul(h, d);}for (int i = 0; i < m; i++) {hashp = add(mul(d, hashp), pattern[i]);hasht = add(mul(d, hasht), text[i]);}for (int i = 0; i <= n - m; i++) {if (hashp == hasht) {indexes.add(i);}if (i < n - m) {hasht = add(mul(d, (sub(hasht, mul(text[i], h)))), text[i + m]);if (hasht < 0)hasht = add(hasht, mod);}}return indexes;}\r\n    long[] prehash(char ch[]) {int n = ch.length;long ans[] = new long[n];long a = 0;long pr = 1;for (int i = 0; i < n; i++) {a = add(a, mul(sub(ch[i], 96), pr));pr = mul(pr, 31);ans[i] = a;}return ans;}\r\n    long subhash(long ans[], int start, int end) {return div(sub(ans[end], ans[start - 1]), pow(31, start));}\r\n    char[] substring(char a[], int start, int end) {char ch[] = new char[end - start];int index = 0;for (int i = start; i < end; i++) ch[index++] = a[i];return ch;}\r\n    boolean equals(char a[], char b[]) {for (int i = 0; i < a.length; i++) if (a[i] != b[i]) return false;return a.length == b.length;}\r\n    char[] append(char a[], char[] b) {char ch[] = new char[a.length + b.length];int i = 0; for (i = 0; i < a.length; i++) ch[i] = a[i]; for (int j = 0; j < b.length; j++) ch[i++] = b[j];return ch;}\r\n    void p(char[] c) {for (char ch : c) p(ch);}\r\n    void ps(char[] c) {for (char ch : c) ps(ch); pl();}\r\n    void pl(char[] c) {for (char ch : c) p(ch); pl();}\r\n    void fillcount(char ch[], long count[]) {for (int i = 0; i < ch.length; i++) count[ch[i] - 97]++;}\r\n    ArrayList<Long>[] fill(char c1[]) {ArrayList<Long> ch[] = new ArrayList[26];for(int i=0;i<26;i++) ch[i] = new ArrayList<>();for(int i=0;i<c1.length;i++) ch[c1[i]-97].add((long)i);return ch;}\r\n    \r\n    int upper_bound(long a[], long val) {int start = 0;int end = a.length - 1;while (start <= end) {int mid = (start + end) / 2;if (a[mid] >= val) {if (mid == 0 || a[mid-1] < val)return mid;end = mid - 1;} else start = mid + 1;}return -1;}\r\n    int upper_bound(ArrayList<Long> a, long val) {if (a.size() == 0)return -1;int start = 0;int end = a.size() - 1;while (start <= end) {int mid = (start + end) / 2;if (a.get(mid) >= val) {if (mid == 0 || a.get(mid-1) < val) return mid;end = mid - 1;} else start = mid + 1;}return -1;}\r\n    int lower_bound(ArrayList<Long> a, long val) {if (a.size() == 0)return -1;int start = 0;int end = a.size() - 1;while (start <= end) {int mid = (start + end) / 2;if (a.get(mid) > val) {end = mid - 1;continue;} else {if (mid == a.size() - 1 || a.get(mid+1) > val) return mid; start = mid + 1;}}return -1;}\r\n    int lower_bound(long a[], long val) {int start = 0;int end = a.length - 1;while (start <= end) {int mid = (start + end) / 2;if (a[mid] > val) {end = mid - 1;continue;} else {if (mid == a.length - 1 || a[mid + 1] > val) return mid; start = mid + 1;}}return -1;}\r\n    \r\n    ArrayList<Integer> tree[];\r\n    void init(int size) {tree = new ArrayList[size + 1];for(int i=1;i<=size;i++) tree[i] = new ArrayList<>();}\r\n    void addEdge(int u, int v) {tree[u].add(v);tree[v].add(u);}\r\n    \r\n    class Pair {long first; long second; Pair(long first, long second) {this.first = first;this.second = second;}@Override public boolean equals(Object o) {if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;Pair pair = (Pair) o;return first == pair.first && second == pair.second;}@Override public int hashCode() {return Objects.hash(first, second);}}\r\n    \r\n    PriorityQueue<long[]> queue() {PriorityQueue<long[]> queue = new PriorityQueue<long[]>((a, b) -> {if (a[0] > b[0]) return 1; else if (a[0] == b[0] && a[1] > b[1]) return 1; else return -1;});return queue;}\r\n    \r\n    // Here we go\r\n    public static void main(String args[]) {\r\n        Main FC27 = new Main();\r\n        FC27.start();\r\n    }\r\n\r\n    // This is where the fun begins\r\n    public void start() {\r\n        int t = 1;\r\n        t = ini();\r\n        for(int i=0;i<t;i++) {\r\n            solve(i);\r\n        }\r\n        out.close();\r\n    }\r\n\r\n    public void solve(int test) {\r\n    \tint n = ini();\r\n    \tlong x = in();\r\n    \tlong a[] = in(n);\r\n    \tlong ans = 0;\r\n    \tfor(int i=0;i<n-1;i++) ans += abs(a[i] - a[i+1]);\r\n    \tTreeSet<Long> set = new TreeSet<>();\r\n    \twhile(x > 0) set.add(x--);\r\n    \tArrayList<Long> arr = new ArrayList<>();\r\n    \tfor(int i=0;i<n-1;i++) {\r\n    \t\tlong min = min(a[i], a[i+1]);\r\n    \t\tlong max = max(a[i], a[i+1]);\r\n    \t\tarr.add(a[i]);\r\n    \t\tArrayList<Long> temp = new ArrayList<>();\r\n    \t\twhile(true) {\r\n    \t\t\tLong key = set.higher(min);\r\n    \t\t\tif(set.contains(min)) key = min; \r\n    \t\t\tif(key == null || key > max) break;\r\n    \t\t\ttemp.add(key);\r\n    \t\t\tset.remove(key);\r\n    \t\t}\r\n    \t\tif(a[i] >= a[i+1]) rsort(temp);\r\n    \t\telse sort(temp);\r\n    \t\tfor(long ele : temp) arr.add(ele);\r\n    \t\tarr.add(a[i+1]);\r\n    \t}\r\n    \tif(n == 1) {\r\n    \t\tarr.add(a[0]);\r\n    \t\tif(a[0] >= x) {\r\n    \t\t\tpl(x - 1 + a[0] - x);\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\telse {\r\n    \t\t\tpl(x - 1);\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t}\r\n    \tif(set.size() == 0) {\r\n    \t\tpl(ans);\r\n    \t\treturn;\r\n    \t}\r\n    \tLong key1 = set.first();\r\n    \tLong key2 = set.last();\r\n    \tans += key2 - key1;\r\n    \tn = arr.size();\r\n    \tlong add = inf;\r\n    \tfor(int i=1;i<n-1;i++) add = min(add, abs(key1 - arr.get(i)) + abs(key2 - arr.get(i+1)));\r\n    \tadd = min(add, abs(arr.get(0) - key2));\r\n    \tadd = min(add, abs(arr.get(n-1) - key1));\r\n    \tpl(ans + add);\r\n    }\r\n}  "
}