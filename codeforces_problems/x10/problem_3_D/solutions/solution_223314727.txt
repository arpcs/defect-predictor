{
    "id": 223314727,
    "contestId": 3,
    "creationTimeSeconds": 1694678151,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 3,
        "index": "D",
        "name": "Least Cost Bracket Sequence",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "greedy"
        ]
    },
    "author": {
        "contestId": 3,
        "members": [
            {
                "handle": "harsh__h"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1267963200
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "//* dont stick to an approach */\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include <string>\r\n#include <algorithm>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <array>\r\n#include <unordered_set>\r\n#include <unordered_map>\r\n#include <stack>\r\n#include <cassert>\r\n#include <vector>\r\n#include <numeric>\r\n#include <cstdlib>\r\n#include <bitset>\r\n#include <chrono>\r\n#include <random>\r\n#include <fstream>\r\n#include <iterator>\r\n#include <complex>\r\n#include <cstring>\r\n#include <list>\r\n// c++20\r\n//#include <bit>\r\n\r\nusing namespace std;\r\n\r\n typedef long long ll;\r\n//typedef int ll;\r\n//typedef unsigned long long int ull;\r\ntypedef long double ldb;\r\n\r\n#define PB push_back\r\n\r\n#define For(i, n) for (ll i = 0; i < n; i++)\r\n\r\n#define trav(a,x) for (auto& a : x)\r\n\r\n#define PYES cout<<\"YES\\n\"\r\n#define PNO cout<<\"NO\\n\"\r\n#define PYes cout<<\"Yes\\n\"\r\n#define PNo cout<<\"No\\n\"\r\n//#define endl '\\n'\r\n\r\n#define sq(x)           (x*x)\r\n\r\n#define vll             vector<ll>\r\n#define pll             pair<ll,ll>\r\n#define ff              first\r\n#define ss              second\r\n#define rev(v)          reverse(v.begin(),v.end())\r\n#define srt(v)          sort(v.begin(),v.end())\r\n#define grtsrt(v)       sort(v.begin(),v.end(),greater<ll>())\r\n#define mnv(v)          *min_element(v.begin(),v.end())\r\n#define mxv(v)          *max_element(v.begin(),v.end())\r\n#define all(v)          v.begin(),v.end()\r\n#define ACC(v)          accumulate(v.begin(),v.end(),0ll)\r\n\r\n#define eps             1e-9\r\n\r\nconst double PI=acos(-1.0);\r\n\r\n#define topi ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\r\n\r\nmt19937 rng((unsigned int)chrono::steady_clock::now().time_since_epoch().count());\r\n\r\n//--------------------------------------------functions-------------------------------------------------//\r\n\r\nll power(ll a,ll b){\r\n    ll result=1;\r\n    while(b>0){\r\n        if(b%2 == 1){result *= a;} a *= a;b /= 2;}return result;}\r\nll gcd(ll x,ll y){\r\n    ll r;\r\n    while(y!=0&&(r=x%y)!=0){\r\n        x=y;y=r;\r\n    }\r\n    return y==0?x:y;\r\n}\r\nll countSetBits(ll x){ll Count=0;while(x>0){if(x&1) Count++;x=x>>1;}return Count;}\r\nll mod(ll x,ll M){return ((x%M + M)%M);}\r\nll add(ll a, ll b,ll M){return mod(mod(a,M)+mod(b,M),M);}\r\nll mul(ll a, ll b,ll M){return mod(mod(a,M)*mod(b,M),M);}\r\nll powerM(ll a,ll b,ll M){\r\n    ll res=1ll;\r\n    while(b){\r\n        if(b%2ll==1ll){\r\n            res=(a*res)%M;\r\n        }\r\n        a=(a*a)%M;b/=2ll;\r\n    }\r\n    return res;\r\n}\r\nll mod_inv(ll a, ll m) {\r\n    ll g = m, r = a, x = 0, y = 1;\r\n    while (r != 0) {\r\n        ll q = g / r;\r\n        g %= r; swap(g, r);\r\n        x -= q * y; swap(x, y);\r\n    }\r\n    return mod(x,m);\r\n}\r\n\r\n\r\n////------------------------------------sieve of Eratosthenes-----------------------------------------------//\r\n//ll MAXN=1e5;\r\n//vector<ll> fact(MAXN+1);\r\n//void sieve_of_erantothenes()\r\n//{\r\n//    fact[1] = 1;\r\n//    for (ll i = 2; i <= MAXN; i++)\r\n//        fact[i] = i;\r\n//    for (ll i = 4; i <= MAXN; i += 2)\r\n//        fact[i] = 2;\r\n//    for (ll i = 3; i * i <= MAXN; i++){\r\n//        if (fact[i] == i){\r\n//            for (ll j = i * i; j <= MAXN; j += i)\r\n//                if (fact[j] == j)\r\n//                    fact[j] = i;\r\n//        }\r\n//    }\r\n//}\r\n//----------------------------------------nCr mod------------------------------------------------------//\r\nll nCr(ll n, ll k){\r\n    if(n<k) return 0;\r\n    if(k==0) return 1;\r\n    ll res = 1;\r\n    if (k > n - k) k = n - k;\r\n    for(ll i = 0; i < k; ++i){\r\n        res *= (n - i);\r\n        res /= (i + 1);\r\n    }\r\n    return res;\r\n}\r\n\r\nvector<ll> FA,INV;\r\nvoid fcalc(ll n,ll M){\r\n    FA.resize(n+1);\r\n    FA[0]=1;\r\n    for(ll i=1;i<=n;i++){\r\n        FA[i]=(FA[i-1]*i)%M;\r\n    }\r\n}\r\n\r\nvoid icalc(ll n,ll M){\r\n    INV.resize(n+1);\r\n    INV[n]=mod_inv(FA[n],M);\r\n    for(ll i=n-1;i>=0;i--){\r\n        INV[i]=(INV[i+1]*(i+1))%M;\r\n    }\r\n}\r\nll nCrM(ll n,ll r,ll M){\r\n    if(r<0) return 0;\r\n    if(n<r) return 0;\r\n    if(r==0) return 1;\r\n    ll a=FA[n];\r\n    a*=INV[r];\r\n    a%=M;\r\n    a*=INV[n-r];\r\n    a%=M;\r\n    return a;\r\n}\r\nll rand_int(ll l, ll r){\r\n    return uniform_int_distribution<ll>(l, r)(rng);\r\n}\r\n\r\nifstream fin;\r\nofstream fout;\r\n\r\ntemplate <typename T>\r\nostream& operator <<(ostream& output, const vector<T>& data)\r\n{\r\n    for (const T& x : data)\r\n        output << x <<\" \";\r\n    return output;\r\n}\r\n\r\ntemplate<typename T>\r\nistream& operator>>(istream& input,vector<T>& data){\r\n    for (auto& item : data) {\r\n        input >> item;\r\n    }\r\n    return input;\r\n}\r\n//--------------------------------------------solve----------------------------------------------//\r\n\r\nstruct segtree{\r\n    struct node{\r\n        ll val;\r\n        ll lazy=0;\r\n    };\r\n    vector<node> tree;\r\n    vector<node> base;\r\n    ll n;\r\n    segtree (vector<ll> x){\r\n        n=x.size();\r\n        tree.resize(4*n);\r\n        base.resize(n);\r\n        for(ll i=0;i<n;i++){\r\n            base[i].val=x[i];\r\n        }\r\n        build(0,0,n-1);\r\n    }\r\n    \r\n    void build(ll ind,ll l,ll r){\r\n        if(l==r){\r\n            tree[ind]=base[l];\r\n            return;\r\n        }\r\n        ll mid=(l+r)/2;\r\n        build(2*ind+1,l,mid);\r\n        build(2*ind+2,mid+1,r);\r\n        tree[ind].val=min(tree[2*ind+1].val,tree[2*ind+2].val);\r\n    }\r\n    \r\n    void pushDown(ll ind){\r\n        tree[ind].val += tree[ind].lazy;\r\n        tree[2*ind+1].lazy += tree[ind].lazy;\r\n        tree[2*ind+2].lazy += tree[ind].lazy;\r\n        tree[ind].lazy=0;\r\n    }\r\n    \r\n    void update(ll ind,ll spanL,ll spanR, ll updL, ll updR, ll val){\r\n        pushDown(ind);\r\n        if(updR < spanL || updL > spanR){\r\n            return;\r\n        }\r\n        if(updL<=spanL && updR>=spanR){\r\n            tree[ind].lazy += val;\r\n            pushDown(ind);\r\n            return;\r\n        }\r\n        ll mid=(spanL+spanR)/2;\r\n        update(2*ind+1,spanL,mid,updL,updR,val);\r\n        update(2*ind+2,mid+1,spanR,updL,updR,val);\r\n        tree[ind].val = min(tree[2*ind+1].val, tree[2*ind+2].val);\r\n    }\r\n    ll query(){\r\n        pushDown(0);\r\n        return tree[0].val;\r\n    }\r\n};\r\n\r\nvoid solve(){\r\n    string s;cin>>s;\r\n    ll n=s.length();\r\n    vector<pair<ll,ll>> v;\r\n    vector<pll> cost(n);\r\n    ll cnt=0;\r\n    for(ll i=0;i<n;i++){\r\n        if(s[i]=='?'){\r\n            ll a,b;cin>>a>>b;\r\n            cost[i]={a,b};\r\n            v.PB({a-b,i});\r\n        }else if(s[i]==')'){\r\n            cnt++;\r\n        }\r\n    }\r\n    srt(v);\r\n    vector<ll> pre(n);\r\n    if(s[0]=='?'){\r\n        pre[0]=1;\r\n    }else if(s[0]=='('){\r\n        pre[0]=1;\r\n    }else{\r\n        pre[0]=-1;\r\n    }\r\n    for(ll i=1;i<n;i++){\r\n        if(s[i]=='?'){\r\n            pre[i]=pre[i-1]+1;\r\n        }else if(s[i]=='('){\r\n            pre[i]=pre[i-1]+1;\r\n        }else{\r\n            pre[i]=pre[i-1]-1;\r\n        }\r\n    }\r\n    segtree sg(pre);\r\n    if(n%2 || sg.query()<0){\r\n        cout<<-1<<endl;\r\n        return;\r\n    }\r\n    ll tot=0;\r\n    while (v.size() && cnt<n/2) {\r\n        auto x=v.back();\r\n        v.pop_back();\r\n        ll ind=x.ss;\r\n        sg.update(0,0,n-1,ind,n-1,-2);\r\n        if(sg.query()<0){\r\n            sg.update(0,0,n-1,ind,n-1,2);\r\n        }else{\r\n            s[ind]=')';\r\n            tot+=cost[ind].ss;\r\n            cnt++;\r\n        }\r\n    }\r\n    for(ll i=0;i<n;i++){\r\n        if(s[i]=='?'){\r\n            tot+=cost[i].ff;\r\n            s[i]='(';\r\n        }\r\n    }\r\n    ll op=0;\r\n    for(ll i=0;i<n;i++){\r\n        if(s[i]=='('){\r\n            op++;\r\n        }else{\r\n            op--;\r\n        }\r\n        if(op<0){\r\n            cout<<-1<<endl;\r\n            return;\r\n        }\r\n    }\r\n    if(op!=0){\r\n        cout<<-1<<endl;\r\n        return;\r\n    }\r\n    cout<<tot<<endl;\r\n    cout<<s<<endl;\r\n}\r\n\r\nauto main() -> int {\r\n    topi;\r\n\r\n//    freopen(\"calc.in\",\"r\",stdin);\r\n//    freopen(\"calc.out\",\"w\",stdout);\r\n\r\n    cout << fixed << setprecision(20);\r\n\r\n    ll t=1;\r\n\r\n//    cin >> t;\r\n\r\n    for(ll i=1;i<=t;i++){\r\n\r\n//        cout <<\"Case #\"<<i<<\": \";\r\n\r\n        solve();\r\n\r\n    }\r\n    return 0;\r\n}\r\n"
}