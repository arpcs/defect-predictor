{
    "id": 234321204,
    "contestId": 1218,
    "creationTimeSeconds": 1700938770,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1218,
        "index": "B",
        "name": "Guarding warehouses",
        "type": "PROGRAMMING",
        "rating": 3000,
        "tags": [
            "data structures",
            "geometry"
        ]
    },
    "author": {
        "contestId": 1218,
        "members": [
            {
                "handle": "lwh_lwh"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1568554500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "// generated by GPT4 2023-11-26 02:59:28\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nconst double EPS = 1e-9;\r\nconst double PI = acos(-1);\r\nconst int MAX = 100005;\r\nint n, m, tot;\r\ndouble ans;\r\nstruct Point {\r\n  double x, y;\r\n  Point(double x = 0, double y = 0): x(x), y(y) {}\r\n  bool operator < (const Point &rhs) const {\r\n    return atan2(y, x) < atan2(rhs.y, rhs.x);\r\n  }\r\n} P[MAX], Q[MAX], O;\r\nstruct Line {\r\n  Point p, v;\r\n  double ang;\r\n  Line() {}\r\n  Line(Point p, Point v): p(p), v(v) {\r\n    ang = atan2(v.y, v.x);\r\n  }\r\n  bool operator < (const Line &rhs) const {\r\n    return ang < rhs.ang;\r\n  }\r\n} L[MAX];\r\ndouble cross(Point a, Point b) {\r\n  return a.x * b.y - a.y * b.x;\r\n}\r\nbool onLeft(Line l, Point p) {\r\n  return cross(l.v, p - l.p) > 0;\r\n}\r\nPoint lineIntersection(Line a, Line b) {\r\n  Point u = a.p - b.p;\r\n  double t = cross(b.v, u) / cross(a.v, b.v);\r\n  return a.p + a.v * t;\r\n}\r\nvoid addLine(Point p1, Point p2) {\r\n  L[tot++] = Line(p1, p2 - p1);\r\n}\r\nvoid halfPlaneIntersection() {\r\n  sort(L, L + tot);\r\n  int head, tail;\r\n  head = tail = 0;\r\n  for(int i = 0; i < tot; i++) {\r\n    while(head < tail && !onLeft(L[i], Q[tail])) tail--;\r\n    while(head < tail && !onLeft(L[i], Q[head])) head++;\r\n    Q[++tail] = (head < tail) ? lineIntersection(L[tail], L[i]) : L[i].p;\r\n  }\r\n  while(head < tail && !onLeft(L[head], Q[tail])) tail--;\r\n  for(int i = head; i <= tail; i++) ans += cross(Q[i], Q[i + 1]);\r\n}\r\nint main() {\r\n  scanf(\"%d\", &n);\r\n  for(int i = 1; i <= n; i++) {\r\n    scanf(\"%d\", &m);\r\n    for(int j = 1; j <= m; j++) {\r\n      double x, y;\r\n      scanf(\"%lf%lf\", &x, &y);\r\n      P[j] = Point(x, y);\r\n    }\r\n    P[m + 1] = P[1];\r\n    for(int j = 1; j <= m; j++) {\r\n      if(cross(P[j], P[j + 1]) < 0) {\r\n        addLine(P[j], P[j + 1]);\r\n      }\r\n    }\r\n  }\r\n  halfPlaneIntersection();\r\n  printf(\"%.10lf\\n\", ans / 2);\r\n  return 0;\r\n}\r\n"
}