{
    "id": 224159440,
    "contestId": 117,
    "creationTimeSeconds": 1695211044,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 117,
        "index": "E",
        "name": "Tree or not Tree",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2900,
        "tags": [
            "data structures",
            "divide and conquer",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 117,
        "members": [
            {
                "handle": "Elza_York"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1316790000
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 36,
    "timeConsumedMillis": 590,
    "memoryConsumedBytes": 18636800,
    "source": "// LUOGU_RID: 125343555\n/*\r\n    \u50d5\u306b\u306f\u308f\u304b\u3089\u306a\u3044\u3093\u3060\u3000\u3044\u3064\u3082\r\n    \u307f\u3064\u3051\u3089\u308c\u306a\u3044\u3000\u6b63\u89e3\u3082\u666e\u901a\u3082\r\n    \u4e16\u754c\u306f\u305a\u3063\u3068\u3000\u305a\u3063\u3068\u305a\u3063\u3068\u9060\u304f\r\n    \u50d5\u306b\u306f\u5c4a\u304b\u306a\u3044\u5834\u6240\u306b\u3042\u308b\u3093\u3060\r\n    \u3072\u3060\u307e\u308a\u3092\u62b1\u304d\u3057\u3081\u3066\u3044\u305f\u6625\u3082\r\n    \u590f\u304c\u7167\u3089\u3057\u3059\u304e\u3066\u3000\u6d88\u3048\u3066\u3057\u307e\u3044\u305d\u3046\u3067\r\n    \u30a2\u30b9\u30d5\u30a1\u30eb\u30c8\u3067\u5e72\u304b\u3089\u3073\u3066\u3057\u307e\u3046\u306a\u3089\u50d5\u306f\r\n    \u305a\u3063\u3068\u3000\u77f3\u306e\u4e0b\u306b\u96a0\u308c\u3066\u3044\u305f\u304b\u3063\u305f\r\n*/\r\n\r\n//All OK\r\n#include <bits/stdc++.h>\r\n#define ios ios::sync_with_stdio(0);cin.tie(nullptr);cout.tie(0);cout << fixed << setprecision(7)\r\n#define fi first\r\n#define se second\r\n#define INF 0x3f3f3f3f\r\n#define LNF (1ll << 60)\r\n#define ll long long\r\n#define ull unsighed long long\r\n// #define mod 998244353\r\n#define mod 1000000007\r\nusing namespace std;\r\n\r\n// void solve(){\r\n//     ll n, m;\r\n//     cin >> n >> m;\r\n//     string s;\r\n//     cin >> s;\r\n//     ll ans = n * (m - 1);\r\n//     ll res = 0;\r\n//     for(int i = 1; i < n; i ++){\r\n//         if(i > 1 && s[i] == s[i - 2])\r\n//             res ++;\r\n//         else res = 0;\r\n//         if(s[i] != s[i - 1])\r\n//             ans += n * (m - 1) - res - 1;\r\n//     }\r\n//     cout << ans;\r\n// }   \r\n\r\n// signed main(){\r\n//     ios;\r\n\r\n//     // init();\r\n//     int _ = 1;\r\n//     // cin >> _;\r\n//     for(int __ = 1; __ <= _; __ ++){\r\n//         // cout << \"Case #\" << __ << \": \";\r\n\r\n//         solve();\r\n//         // cout << el;;\r\n//     }\r\n//     return 0;\r\n// }\r\n// using ll = long long;\r\n// using ull = unsigned long long;\r\nusing pii = pair<int, int>;\r\n\r\nbool Mbe;\r\nconstexpr int N = 1e5 + 5;\r\n\r\nint n, q, vis[N];\r\nint k, bel[N], pos[N];\r\nvector<int> e[N], cyc;\r\n\r\nint fa[N], dep[N], sz[N], son[N];\r\nint dn, dfn[N], top[N];\r\nvoid dfs1(int id, int ff) {\r\n  fa[id] = ff;\r\n  bel[id] = bel[ff];\r\n  dep[id] = dep[ff] + 1;\r\n  sz[id] = 1;\r\n  for(int it : e[id]) {\r\n    if(vis[it] || it == ff) continue;\r\n    dfs1(it, id);\r\n    sz[id] += sz[it];\r\n    if(sz[it] > sz[son[id]]) son[id] = it;\r\n  }\r\n}\r\nvoid dfs2(int id, int tp) {\r\n  dfn[id] = ++dn, top[id] = tp;\r\n  if(son[id]) dfs2(son[id], tp);\r\n  for(int it : e[id]) {\r\n    if(vis[it] || it == fa[id] || it == son[id]) continue;\r\n    dfs2(it, it);\r\n  }\r\n}\r\n\r\nvoid getcycle() {\r\n  vector<int> deg(n + 2, 0);\r\n  queue<int> q;\r\n  for(int i = 1; i <= n; i++) {\r\n    deg[i] = e[i].size(), vis[i] = 1;\r\n    if(deg[i] == 1) q.push(i);\r\n  }\r\n  while(!q.empty()) {\r\n    int t = q.front();\r\n    q.pop(), vis[t] = 0;\r\n    for(int it : e[t]) if(vis[it] && --deg[it] == 1) q.push(it);\r\n  }\r\n  for(int i = 1; i <= n; i++) \r\n    if(vis[i]) {\r\n      int cur = i, lst = -1;\r\n      do {\r\n        pos[cur] = cyc.size();\r\n        bel[cur] = cur;\r\n        dfs1(cur, cur), dfs2(cur, cur);\r\n        cyc.push_back(cur);\r\n        int nw = -1;\r\n        for(int it : e[cur]) if(vis[it] && it != lst) nw = it;\r\n        lst = cur, cur = nw;\r\n      } while(cur != i);\r\n      k = cyc.size();\r\n      break;\r\n    }\r\n}\r\n\r\nstruct Segtree {\r\n  int val[N << 2], len[N << 2], laz[N << 2];\r\n  void build(int l, int r, int x) {\r\n    len[x] = r - l + 1;\r\n    if(l == r) return;\r\n    int m = l + r >> 1;\r\n    build(l, m, x << 1);\r\n    build(m + 1, r, x << 1 | 1);\r\n  }\r\n  void tag(int x) {\r\n    laz[x] ^= 1;\r\n    val[x] = len[x] - val[x];\r\n  }\r\n  void down(int x) {\r\n    if(laz[x]) {\r\n      tag(x << 1);\r\n      tag(x << 1 | 1);\r\n      laz[x] = 0;\r\n    }\r\n  }\r\n  void push(int x) {\r\n    val[x] = val[x << 1] + val[x << 1 | 1];\r\n  }\r\n  void modify(int l, int r, int ql, int qr, int x) {\r\n    if(ql > qr) return;\r\n    if(ql <= l && r <= qr) return tag(x);\r\n    int m = l + r >> 1;\r\n    down(x);\r\n    if(ql <= m) modify(l, m, ql, qr, x << 1);\r\n    if(m < qr) modify(m + 1, r, ql, qr, x << 1 | 1);\r\n    push(x);\r\n  }\r\n} t1, t2;\r\n\r\nbool Med;\r\nint main() {\r\n    ios;\r\n  // fprintf(stderr, \"%.3lf MB\\n\", (&Mbe - &Med) / 1048576.0);\r\n  // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\r\n  cin >> n >> q;\r\n  for(int i = 1; i <= n; i++) {\r\n    int u, v;\r\n    cin >> u >> v;\r\n    e[u].push_back(v);\r\n    e[v].push_back(u);\r\n  }\r\n  getcycle();\r\n  t1.build(1, dn, 1);\r\n  t2.build(0, k - 1, 1);\r\n  \r\n  for(int i = 1; i <= q; i++) {\r\n    int u, v;\r\n    cin >> u >> v;\r\n    if(bel[u] == bel[v]) {\r\n      while(top[u] != top[v]) {\r\n        if(dep[top[u]] < dep[top[v]]) swap(u, v);\r\n        t1.modify(1, dn, dfn[top[u]], dfn[u], 1);\r\n        u = fa[top[u]];\r\n      }\r\n      if(dep[u] > dep[v]) swap(u, v);\r\n      t1.modify(1, dn, dfn[u] + 1, dfn[v], 1);\r\n    }\r\n    else {\r\n      while(top[u] != bel[u]) {\r\n        t1.modify(1, dn, dfn[top[u]], dfn[u], 1);\r\n        u = fa[top[u]];\r\n      }\r\n      while(top[v] != bel[v]) {\r\n        t1.modify(1, dn, dfn[top[v]], dfn[v], 1);\r\n        v = fa[top[v]];\r\n      }\r\n      t1.modify(1, dn, dfn[bel[u]] + 1, dfn[u], 1);\r\n      t1.modify(1, dn, dfn[bel[v]] + 1, dfn[v], 1);\r\n      u = pos[bel[u]];\r\n      v = pos[bel[v]];\r\n\r\n      if(abs(v - u) * 2 != k) {\r\n        if(u > v) swap(u, v);\r\n        if((v - u) * 2 < k) {\r\n          t2.modify(0, k - 1, u, v - 1, 1);\r\n        }\r\n        else {\r\n          t2.modify(0, k - 1, v, k - 1, 1);\r\n          t2.modify(0, k - 1, 0, u - 1, 1);\r\n        }\r\n      }\r\n      else {\r\n        int pr = cyc[u ? u - 1 : k - 1];\r\n        int su = cyc[u + 1 < k ? u + 1 : 0];\r\n        if(pr < su) {\r\n          if(u < v) {\r\n            t2.modify(0, k - 1, v, k - 1, 1);\r\n            t2.modify(0, k - 1, 0, u - 1, 1);\r\n          }\r\n          else {\r\n            t2.modify(0, k - 1, v, u - 1, 1);\r\n          }\r\n        }\r\n        else {\r\n          if(u < v) {\r\n            t2.modify(0, k - 1, u, v - 1, 1);\r\n          }\r\n          else {\r\n            t2.modify(0, k - 1, u, k - 1, 1);\r\n            t2.modify(0, k - 1, 0, v - 1, 1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    int ans = n - t1.val[1] - t2.val[1];\r\n    if(t2.val[1] == k) ans++;\r\n    cout << ans << \"\\n\";\r\n  }\r\n  // cerr << 1e3 * clock() / CLOCKS_PER_SEC << \" ms\\n\";\r\n  return 0;\r\n}"
}