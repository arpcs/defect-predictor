{
    "id": 212762534,
    "contestId": 464,
    "creationTimeSeconds": 1688788021,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 464,
        "index": "D",
        "name": "World of Darkraft - 2",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2700,
        "tags": [
            "dp",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 464,
        "members": [
            {
                "handle": "dlnd_vth"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1410103800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 226099200,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"avx2\")\r\n\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\n#define rep(i, n) for(int i = 1; i <= n; ++i)\r\n#define forn(i, l, r) for(int i = l; i <= r; ++i)\r\n#define ford(i, r, l) for(int i = r; i >= l; --i)\r\n#define FOR(i, n) for(int i = 0; i < n; ++i)\r\n#define fi first\r\n#define se second\r\n#define pii pair<int, int>\r\n#define pll pair<ll, ll>\r\n#define pb push_back\r\n#define task \"dijkstra\"\r\n#define endl \"\\n\"\r\n#define sz(a) int(a.size())\r\n#define bit(i, mask) (mask >> i & 1)\r\n#define all(a) (a).begin(), (a).end()\r\n\r\ntemplate<typename T> bool maximize(T &res, const T &val) { if (res <= val){ res = val; return true; }; return false; }\r\ntemplate<typename T> bool minimize(T &res, const T &val) { if (res >= val){ res = val; return true; }; return false; }\r\n\r\n/*\r\ntemplate <typename _Tp> void write_unsign(const _Tp &__n) { if (__n > 9) { write_unsign(__n / 10); } putchar(__n % 10 + '0'); }\r\nvoid write(const int       &__n) { if (__n < 0) { putchar('-'); write_unsign(-__n); } else { write_unsign(__n); } }\r\nvoid write(const long long &__n) { if (__n < 0) { putchar('-'); write_unsign(-__n); } else { write_unsign(__n); } }\r\nvoid write(const unsigned long long &__n) { if (__n < 0) { putchar('-'); write_unsign(-__n); } else { write_unsign(__n); } }\r\nvoid write(const char      &__c) {                                                                putchar(__c);   }\r\nvoid write(const string    &__s) { for (auto &__c : __s) {                                         putchar(__c); } }\r\ntemplate <typename _Tp, typename... _Ts> void write(const _Tp &__x, const _Ts &...__y) { write(__x), write(__y...); }\r\n\r\ninline int readInt()       {char c;while(c=getchar(),c!='-'&&(c<'0'||c>'9'));bool sign=(c=='-');if(sign)c=getchar();int n=c-'0';while(c=getchar(),c>='0'&&c<='9')n=10*n+c-'0';return(!sign)?n:-n;}\r\ninline ll readLong()       {char c;while(c=getchar(),c!='-'&&(c<'0'||c>'9'));bool sign=(c=='-');if(sign)c=getchar();ll  n=c-'0';while(c=getchar(),c>='0'&&c<='9')n=10*n+c-'0';return(!sign)?n:-n;}\r\ninline string readString() {char c;while(c=getchar(),c==' '||c=='\\n'||c=='\\t');string s({c});while(c=getchar(),c!=EOF&&c!=' '&&c!='\\n'&&c!='\\t')s+=c;return s;}\r\n*/\r\n\r\nconst int N =  3e5 + 100;\r\nconst int K = 1e2 + 1;\r\nconst int MOD = 1e9 + 7;\r\nconst ll MOD2 = 1e9 + 9;\r\nconst ll INF = 5e17 + 9999;\r\nconst int offset = N;\r\nconst int LIM = 1e5 + 2;\r\nconst int AL = 26;\r\nconst int LOG = 15;\r\nconst int p = 2;\r\n\r\nint subtask;\r\nint n, m, s, t, max_log = 0;\r\n\r\nint P[N], rt[30 * N], par[N];\r\n\r\nvector<pii> g[N];\r\n\r\nint add(int u, int v)\r\n{\r\n    u += v;\r\n    if(u >= MOD) u -= MOD;\r\n    return u;\r\n}\r\n\r\nint mul(int a, int b)\r\n{\r\n    return 1ll * a * b % MOD;\r\n}\r\n\r\nclass PersistentSeg\r\n{\r\n    public:\r\n    struct node\r\n    {\r\n        int l, r, s;\r\n    } st[N * 50];\r\n\r\n    int num = 0;\r\n\r\n    void build(int &id, int l, int r)\r\n    {\r\n        id = ++num;\r\n        st[id].s = 0;\r\n        if(l != r)\r\n        {\r\n            int mid = l + r >> 1;\r\n            build(st[id].l, l, mid);\r\n            build(st[id].r, mid + 1, r);\r\n        }\r\n        \r\n    }\r\n\r\n    bool update(int &id, int old, int l, int r, int pos)\r\n    {\r\n        id = ++num;\r\n        st[id].l = st[old].l, st[id].r = st[old].r, st[id].s = st[old].s;\r\n        \r\n        if(l == r)\r\n        {\r\n            st[id].s ^= 1;\r\n            return !st[id].s;\r\n        }\r\n        int mid = l + r >> 1;\r\n        bool flag = 0;\r\n        \r\n        if(pos <= mid)\r\n        {\r\n            if(update(st[id].l, st[old].l, l, mid, pos)) flag = update(st[id].r, st[old].r, mid + 1, r, mid + 1);\r\n            else flag = 0;\r\n        }\r\n        else flag = update(st[id].r, st[old].r, mid + 1, r, pos);\r\n        \r\n        st[id].s = add(st[st[id].l].s, mul(st[st[id].r].s, P[mid - l + 1]));\r\n        return flag;\r\n    }\r\n    bool comp(int x, int y, int l, int r)\r\n    {\r\n        if(l == r) return st[x].s <= st[y].s;\r\n        int mid = l + r >> 1;\r\n        if(st[st[x].r].s == st[st[y].r].s) return comp(st[x].l, st[y].l, l, mid);\r\n        return comp(st[x].r, st[y].r, mid + 1, r);\r\n    }\r\n} St;\r\n\r\n\r\n\r\nstruct Node\r\n{\r\n    int u, root;\r\n    Node(int u_, int root_) : u(u_), root(root_) {}\r\n    friend bool operator < (const Node &x, const Node &y) {\r\n        return !St.comp(rt[x.root], rt[y.root], 0, max_log);\r\n    }\r\n};\r\n\r\nvoid Dijkstra()\r\n{\r\n    St.build(rt[s], 0, max_log);\r\n    \r\n    priority_queue<Node> q;\r\n    q.push(Node(s, rt[s]));\r\n    par[s] = -1;\r\n\r\n    while(!q.empty())\r\n    {\r\n        //assert(St.num <= 3e5);\r\n        Node tmp = q.top(); q.pop();\r\n        int u = tmp.u, root = tmp.root;\r\n\r\n        if(rt[u] != root) continue;\r\n\r\n        for(pii e: g[u])\r\n        {\r\n            int v = e.fi, w = e.se;\r\n            int new_rt;\r\n            St.update(new_rt, root, 0, max_log, w);\r\n            if(!rt[v] || !St.comp(rt[v], new_rt, 0, max_log))\r\n            {\r\n                q.push(Node(v, rt[v] = new_rt));\r\n                par[v] = u;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    //cin >> subtask;\r\n    cin >> n >> m;\r\n    rep(i, m)\r\n    {\r\n        int u, v, c;\r\n        cin >> u >> v >> c;\r\n        g[u].pb({v, c});\r\n        g[v].pb({u, c});\r\n        maximize(max_log, c);\r\n    }\r\n    max_log += 20;\r\n    P[0] = 1;\r\n    rep(i, max_log) P[i] = 1ll * P[i - 1] * p % MOD;\r\n    cin >> s >> t;\r\n\r\n    Dijkstra();\r\n    if(!rt[t]) cout << -1;\r\n    else\r\n    {\r\n        cout << St.st[rt[t]].s << endl;\r\n        vector<int> path;\r\n        int u = t;\r\n        while(u != -1) path.pb(u), u = par[u];\r\n        cout << sz(path) << endl;\r\n        reverse(all(path));\r\n        for(int v : path) cout << v << \" \";\r\n        \r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nsigned main()\r\n{\r\n\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0); cout.tie(0);\r\n    if(fopen(task\".inp\", \"r\"))\r\n    {\r\n        freopen(task\".inp\", \"r\", stdin);\r\n        freopen(task\".out\", \"w\", stdout);\r\n    }\r\n\tint TC = 1;\r\n\r\n\r\n    while(TC--)\r\n    {\r\n        solve();\r\n    }\r\n\r\n    return 0;\r\n}"
}