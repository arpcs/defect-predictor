{
    "id": 209996234,
    "contestId": 1450,
    "creationTimeSeconds": 1687028232,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1450,
        "index": "D",
        "name": "Rating Compression",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1800,
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "implementation",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1450,
        "members": [
            {
                "handle": "jd_Kdcgc"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1607265300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 25,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 7270400,
    "source": "/*\r\n\u0924\u0938\u094d\u092e\u093e\u0924\u094d\u0924\u094d\u0935\u092e\u0941\u0924\u094d\u0924\u093f\u0937\u094d\u0920 \u092f\u0936\u094b \u0932\u092d\u0938\u094d\u0935\r\n\u091c\u093f\u0924\u094d\u0935\u093e \u0936\u0924\u094d\u0930\u0942\u0928\u094d\u092d\u0941\u0919\u094d \u0915\u094d\u0937\u094d\u0935 \u0930\u093e\u091c\u094d\u092f\u0902 \u0938\u092e\u0943\u0926\u094d\u0927\u092e\u094d |\r\n\u092e\u092f\u0948\u0935\u0948\u0924\u0947 \u0928\u093f\u0939\u0924\u093e: \u092a\u0942\u0930\u094d\u0935\u092e\u0947\u0935\r\n\u0928\u093f\u092e\u093f\u0924\u094d\u0924\u092e\u093e\u0924\u094d\u0930\u0902 \u092d\u0935 \u0938\u0935\u094d\u092f\u0938\u093e\u091a\u093f\u0928\u094d ||\r\n*/\r\n\r\n// Author : Jeewant Dhingra\r\n\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n/**********************************MACROS_START*********************************************/\r\n\r\n#define int            long long int\r\n#define F              first\r\n#define S              second\r\n#define pb             push_back\r\n#define si             set <int>\r\n#define vi             vector <int>\r\n#define vc             vector <char>\r\n#define vb \t\t\t   vector <bool>\r\n#define pN             cout << \"NO\" << endl; return\r\n#define pY             cout << \"YES\" << endl; return\r\n#define vvi            vector <vi>\r\n#define vvc            vector <vc>\r\n#define vvb            vector <vb>\r\n#define pii            pair <int, int>\r\n#define vpi            vector <pii>\r\n#define vpp            vector <pair<int, pii>>\r\n#define mii            map <int, int>\r\n#define mpi            map <pii, int>\r\n#define spi            set <pii>\r\n#define endl           \"\\n\"\r\n#define sz(x)          ((int) x.size())\r\n#define all(x)         x.begin(), x.end()\r\n#define p(x)           cout << x << endl; return\r\n#define double         long double\r\n#define que_max        priority_queue <int>\r\n#define que_min        priority_queue <int, vi, greater<int>>\r\n#define bug(...)       __f (#__VA_ARGS__, __VA_ARGS__)\r\n#define print(a)       for(auto x : a) cout << x << \" \"; cout << endl\r\n#define print1(a)      for(auto x : a) cout << x.F << \" \" << x.S << endl\r\n#define print2(a,x,y)  for(int i = x; i < y; i++) cout<< a[i]; cout << endl\r\n\r\n/**********************************MACROS_START*********************************************/\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**********************************IMPFUN_START*********************************************/\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\nint gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);}\r\n\r\nint lcm(int a,int b) {return a*b/gcd(a,b);}\r\n\r\nint inv(int i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}\r\n \r\nint mod_mul(int a, int b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}\r\n \r\nint mod_add(int a, int b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}\r\n\r\ninline int power(int a, int b)\r\n{\r\n\tint ans = 1;\r\n\twhile (b)\r\n\t{\r\n\t\tif (b & 1) ans *= a, ans %= mod;\r\n\r\n\t\ta *= a; a %= mod;\r\n\t\tb = b >> 1;\r\n\t}\r\n\r\n\treturn ans;\r\n}\r\n\r\nclass segTree {\r\n\r\n\tprivate:\r\n\r\n\t\tint sz;\r\n\t\tvector <int> sums;\r\n\t\tvector <int> lazy;\r\n\r\n\t\tvoid build (int starting, int ending, int x, vector <int> &v) {\r\n\r\n\t\t\tif (starting == ending) {\r\n\r\n\t\t\t\tsums [x] = v [starting];\r\n\t\t\t\treturn; \r\n\t\t\t}\r\n\r\n\t\t\tint mid = starting  + ((ending - starting) >> 1);\r\n\r\n\t\t\tbuild (starting, mid, 2 * x + 1, v);\r\n\t\t\tbuild (mid + 1, ending, 2 * x + 2, v);\r\n\r\n\t\t\tsums [x] = sums [2 * x + 1] + sums [2 * x + 2];\r\n\t\t}\r\n\r\n\t\tint query (int starting, int ending, int l, int r, int x) {\r\n\r\n\t\t\tif (starting > r or ending < l) return 0;\r\n\r\n\t\t\tif (lazy [x] != 0) {\r\n\r\n\t\t\t\tsums [x] += lazy [x] * (ending - starting + 1);\r\n\t\t\t\tif (starting != ending) {\r\n\r\n\t\t\t\t\tlazy [2 * x + 1] += lazy [x];\r\n\t\t\t\t\tlazy [2 * x + 2] += lazy [x];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlazy [x] = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (starting >= l and ending <= r) return sums [x];\r\n\r\n\t\t\tint mid = starting + ((ending - starting) >> 1);\r\n\t\t\tint q1 = query (starting, mid, l, r, 2 * x + 1);\r\n\t\t\tint q2 = query (mid + 1, ending, l, r, 2 * x + 2);\r\n\r\n\t\t\treturn q1 + q2;\r\n\t\t}\r\n\r\n\t\tvoid update (int starting, int ending, int l, int r, int x, int val) {\r\n\r\n\t\t\tif (starting > r or ending < l) return;\r\n\r\n\t\t\tif (lazy [x] != 0) {\r\n\r\n\t\t\t\tsums [x] += lazy [x] * (ending - starting + 1);\r\n\t\t\t\tif (starting != ending) {\r\n\r\n\t\t\t\t\tlazy [2 * x + 1] += lazy [x];\r\n\t\t\t\t\tlazy [2 * x + 2] += lazy [x];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlazy [x] = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (starting >= l and ending <= r) {\r\n\r\n\t\t\t\tsums [x] += val * (ending - starting + 1);\r\n\t\t\t\tif (starting != ending) {\r\n\r\n\t\t\t\t\tlazy [2 * x + 1] += val;\r\n\t\t\t\t\tlazy [2 * x + 2] += val;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tint mid = starting + ((ending - starting) >> 1);\r\n\t\t\tupdate (starting, mid, l, r, 2 * x + 1, val);\r\n\t\t\tupdate (mid + 1, ending, l, r, 2 * x + 2, val);\r\n\r\n\t\t\tsums [x] = (sums [2 * x + 1] + lazy [2 * x + 1] * (mid - starting + 1)) + (sums [2 * x + 2] + lazy [2 * x + 2] * (ending - mid));\r\n\t\t}\r\n\r\n\tpublic:\r\n\r\n\tvoid init (int n) {\r\n\r\n\t\tsz = n;\r\n\r\n\t\tsums.resize(4 * n, 0);\r\n\t\tlazy.resize(4 * n, 0);\r\n\r\n\t\tsums.assign (4 * n, 0);\r\n\t\tlazy.assign (4 * n, 0);\r\n\t}\r\n\r\n\tvoid build (vector<int>& v) {\r\n\r\n\t\tbuild (0, sz - 1, 0, v);\r\n\t}\r\n\r\n\tint query (int l, int r) {\r\n\r\n\t\treturn query (0, sz - 1, l, r, 0);\r\n\t}\r\n\r\n\tvoid update (int l, int r, int val) {\r\n\r\n\t\tupdate (0, sz - 1, l, r, 0, val);\r\n\t}\r\n\r\n};\r\n\r\n/**********************************IMPFUN_END*********************************************/\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**********************************IFNEEDED_START*********************************************/\r\n\r\n// vi sieve (N + 1);\r\n// void primes ()\r\n// {\r\n// \tfor (int i = 2; i <= N; i++)\r\n// \t{\r\n// \t\tif (sieve [i] == -1) sieve [i] = i;\r\n// \t\tfor (int j = i * i; j <= N; j += i)\r\n// \t\t{\r\n// \t\t\tif (sieve [j] == -1) sieve [j] = i;\r\n// \t\t}\r\n// \t}\r\n// }\r\n\r\n// vi fact (N + 1, 1);\r\n// void findFactorial () {\r\n \r\n// \tfact [0] = fact [1] = 1;\r\n// \tfor (int i = 2; i <= N; i++) {\r\n \r\n// \t\tfact [i] = mod_mul (fact [i - 1], i);\r\n// \t}\r\n// }\r\n \r\n// vi ifact (N + 1, 1);\r\n// void findIFactorial () {\r\n \r\n// \tifact[N] = inv (fact[N]);\r\n//     for (int i = N - 1; i > 0; i--)\r\n//     {\r\n//         ifact[i] = mod_mul (i + 1, ifact[i + 1]);\r\n//     }\r\n// }\r\n \r\n// int nCr (int n, int r)\r\n// {\r\n//     if (r > n) return 0;\r\n \r\n//     int ans = fact [n];\r\n//     ans = mod_mul (ans, ifact[r]);\r\n//     ans = mod_mul (ans, ifact[n - r]);\r\n \r\n//     return ans;\r\n// }\r\n\r\n/**********************************IFNEEDED_END*********************************************/\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**********************************DONTKNOW_START*********************************************/\r\n\r\ntemplate <typename Arg1>\r\nvoid __f (const char* name, Arg1&& arg1) { cout << name << \" : \" << arg1 << endl; }\r\ntemplate <typename Arg1, typename... Args>\r\nvoid __f (const char* names, Arg1&& arg1, Args&&... args)\r\n{\r\n\tconst char* comma = strchr (names + 1, ',');\r\n\tcout.write (names, comma - names) << \" : \" << arg1 << \" | \"; __f (comma + 1, args...);\r\n}\r\n\r\n/**********************************DONTKNOW_END*********************************************/\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**********************************GLOBAL_START*********************************************/\r\n\r\nconst int N = 2e5 + 5;\r\nconst int inf = 1e17;\r\n\r\nint n;\r\nvi v;\r\n\r\n/**********************************GLOBAL_END*********************************************/\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**********************************CODE_START*********************************************/\r\n\r\nvoid solve() {\r\n\r\n\tcin >> n;\r\n\r\n\tv.resize (n + 1);\r\n\tfor (int i = 1; i <= n; i++) cin >> v [i];\r\n\r\n\tvi cnt (n + 1, 0);\r\n\tfor (int i = 1; i <= n; i++) cnt [v [i]]++;\r\n\r\n\tvi ans (n + 1, 0);\r\n\tbool chk = false;\r\n\tfor (int i = 1; i <= n; i++) {\r\n\r\n\t\tif (cnt [i] != 1) chk = true;\r\n\t}\r\n\tif (chk == false) ans [1] = 1;\r\n\r\n\tint  l = 1, r = n;\r\n\tfor (int i = n; i >= 2; i--) {\r\n\r\n\t\tif (cnt [n - i + 1]) ans [i] = 1;\r\n\t\tif (cnt [n - i + 1] != 1) break;\r\n\r\n\t\tif (v [l] == n - i + 1) l++;\r\n\t\telse if (v [r] == n - i + 1) r--;\r\n\t\telse break;\r\n\t}\r\n\r\n\tprint2 (ans, 1, n + 1);\r\n}\r\n\r\n/**********************************CODE_END*********************************************/\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**********************************MAIN_START*********************************************/\r\n\r\nint32_t main()\r\n{\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n#ifndef ONLINE_JUDGE\r\n\tfreopen(\"input.txt\",  \"r\",  stdin);\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\r\n\tclock_t z = clock();\r\n\r\n\t// findFactorial ();\r\n\t// findIFactorial ();\r\n\t// primes ();\r\n\r\n\tcout << setprecision (12) << fixed;\r\n\r\n\tint t = 1;\r\n\tcin >> t;\r\n\twhile (t--) solve();\r\n\r\n\tcerr << \"Run Time : \" << ((double)(clock() - z) / CLOCKS_PER_SEC) << \" \";\r\n\r\n\treturn 0;\r\n}\r\n\r\n/**********************************MAIN_END*********************************************/"
}