{
    "id": 55751215,
    "contestId": 1160,
    "creationTimeSeconds": 1560948708,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1160,
        "index": "A2",
        "name": "Collaboration",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1160,
        "members": [
            {
                "handle": "nikit523"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1556614800
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "FAILED",
    "testset": "TESTS2",
    "passedTestCount": 889,
    "timeConsumedMillis": 15000,
    "memoryConsumedBytes": 1536000,
    "points": 367791.567,
    "source": "#ifndef LOCAL\r\n#pragma GCC optimize \"O3\"\r\n#pragma GCC target \"avx,tune=native\"\r\n#endif\r\n\r\n#pragma GCC optimize \"unroll-loops,omit-frame-pointer\"\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <climits>\r\n#include <cmath>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <tuple>\r\n#include <set>\r\n\r\nusing namespace std;\r\n\r\nstruct P {\r\n    int16_t x, y, tim, per, l, r, id;\r\n};\r\nistream& operator>>(istream& in, P& p) {\r\n    return in >> p.x >> p.y >> p.tim >> p.per >> p.l >> p.r;\r\n}\r\nostream& operator<<(ostream& out, P const& p) {\r\n    return out << '(' << p.x << \", \" << p.y << \"), time: [\" << p.l << \" \" << p.r << \"]\\n\";\r\n}\r\n\r\nstruct Per {\r\n    int16_t x, y; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b\r\n    int16_t timer; // \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u0437\u0430\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\r\n};\r\n\r\nint dist(P &a, P &b) {\r\n    return abs(a.x-b.x)+abs(a.y-b.y);\r\n}\r\nint dist(Per &a, P &b) {\r\n    return abs(a.x-b.x)+abs(a.y-b.y);\r\n}\r\n\r\nstruct state {\r\n    int s1 = 0, s2 = 0, s3 = 0;\r\n    vector<Per> m; // \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043b\u044e\u0434\u0435\u0439\r\n    vector<vector<int16_t> > order; // \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u043f\u043e\u0441\u0435\u0449\u0435\u043d\u0438\u044f \u0433\u043e\u0440\u043e\u0434\u043e\u0432 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430\r\n    vector<int16_t> when; // \u043a\u043e\u0433\u0434\u0430 \u043f\u043e\u0441\u0435\u0449\u0430\u0435\u043c i-\u044b\u0439 \u0433\u043e\u0440\u043e\u0434\r\n};\r\n\r\nint n;\r\nvector<P> point;\r\nP Main;\r\n\r\nvoid read() {\r\n    cin >> n >> Main;\r\n    --n;\r\n    point.resize(n);\r\n    int sum = 0;\r\n    for (size_t i = 0; i < size_t(n); ++i) {\r\n        cin >> point[i];\r\n        point[i].id = int16_t(i);\r\n        sum += int(point[i].tim)*point[i].per*(point[i].per+5);\r\n    }\r\n    #ifdef LOCAL\r\n    cout << sum << '\\n';\r\n    #endif\r\n}\r\n\r\nvoid answer(vector<vector<int16_t> > & order, vector<int16_t> & when) {\r\n    for (size_t i = 0; i < order.size(); ++i) {\r\n        for (size_t j = 0; j < order[i].size(); ++j) {\r\n            P& p = point[size_t(order[i][j])];\r\n            int times = when[size_t(order[i][j])];\r\n            if (j == 0)\r\n                cout << \"start \" << times - p.tim - dist(p, Main) << \" 1\\n\";\r\n            cout << \"arrive \" << times - p.tim << ' ' << p.id + 2 << '\\n';\r\n            cout << \"work \"   << times - p.tim << ' ' << times << ' ' << p.id + 2 << '\\n';\r\n            if (j == size_t(int(order[i].size()) - 1))\r\n                cout << \"arrive \" << times + dist(p, Main) << \" 1\\n\";\r\n        }\r\n        cout << \"end\\n\";\r\n    }\r\n}\r\n\r\nvoid solve() {\r\n    state beam;\r\n    beam.when.resize(n, 0);\r\n    for (size_t i = 0; i < size_t(n); ++i) { // n \u0440\u0430\u0437 \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0433\u043e\u0440\u043e\u0434\r\n        state New;\r\n        New.s1 = -10000000;\r\n        for (size_t j = 0; j < size_t(n); ++j) { // \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0433\u043e\u0440\u043e\u0434\r\n            if (beam.when[size_t(point[j].id)] != 0)\r\n                continue;\r\n            vector<Per>& M = beam.m;\r\n            vector<vector<int16_t> >& Order = beam.order;\r\n            vector<int16_t> s;\r\n            for (size_t k = 0; k < M.size(); ++k) // \u043d\u0430\u0445\u043e\u0434\u0438\u043c \u0440\u0430\u0431\u043e\u0442\u043d\u0438\u043a\u043e\u0432 \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0433\u043e\u0440\u043e\u0434\u0430\r\n                if (M[k].timer + dist(M[k], point[j]) <= point[j].r - point[j].tim)\r\n                    s.push_back(M[k].timer + int16_t(dist(M[k], point[j])));\r\n            int16_t newer = 0;\r\n            while (int16_t(s.size()) < point[j].per) {\r\n                Per new_p = (Per) {Main.x, Main.y, 0};\r\n                s.push_back(int16_t(dist(new_p, point[j])));\r\n                M.push_back(new_p);\r\n                Order.push_back(vector<int16_t>(0));\r\n                ++newer;\r\n            }\r\n            partial_sort(s.begin(), s.begin()+ min(int(s.size()), point[j].per - 1), s.end());\r\n\r\n            int S1 = beam.s1 + int(point[j].tim)*point[j].per*(point[j].per+5);\r\n            int S2 = beam.s2 + newer;\r\n            int S3 = beam.s3 + int(point[j].tim)*point[j].per;\r\n\r\n            const vector<int16_t>& When = beam.when;\r\n\r\n            if (S1 - 240*S2 - S3 <= New.s1 - 240*New.s2 - New.s3)\r\n                continue;\r\n            int16_t to = max(s[size_t(point[j].per-1)], point[j].l) + point[j].tim;\r\n            int16_t from = to - point[j].tim;\r\n\r\n            state Newstate;\r\n            Newstate.s1 = S1;\r\n            Newstate.s2 = S2;\r\n            Newstate.s3 = S3;\r\n            Newstate.when = When;\r\n            Newstate.when[size_t(point[j].id)] = to;\r\n            Newstate.m = M;\r\n            Newstate.order = Order;\r\n            vector<pair<int16_t, int16_t> > s_;\r\n\r\n            for (size_t k = 0; k < M.size(); ++k)\r\n                if (M[k].timer + dist(M[k], point[j]) <= from)\r\n                    s_.push_back(make_pair(from - M[k].timer, int(k)));\r\n\r\n            partial_sort(s_.begin(), s_.begin() + point[j].per, s_.end());\r\n\r\n            for (size_t k = 0; k < size_t(point[j].per); ++k) {\r\n                size_t id = size_t(s_[k].second);\r\n                if (Newstate.m[id].timer == 0)\r\n                    Newstate.s3 += dist(Main, point[j]);\r\n                else\r\n                    Newstate.s3 += s_[k].first;\r\n                Newstate.order[id].push_back(point[j].id);\r\n                Newstate.m[id].x = point[j].x;\r\n                Newstate.m[id].y = point[j].y;\r\n                Newstate.m[id].timer = to;\r\n            }\r\n\r\n            if (Newstate.s1 - 240*Newstate.s2 - Newstate.s3 > New.s1 - 240*New.s2 - New.s3)\r\n                New = move(Newstate);\r\n        }\r\n        beam = move(New);\r\n    }\r\n    answer(beam.order, beam.when);\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    #ifdef LOCAL\r\n        freopen(\"/Users/nikitaigumnov/Downloads/codeforces-vrt-2019/001.txt\", \"r\", stdin);\r\n        freopen(\"/Users/nikitaigumnov/Downloads/codeforces-vrt-2019/0001.txt\", \"w\", stdout);\r\n    #endif\r\n    ios::sync_with_stdio(0); cin.tie(nullptr);\r\n    read();\r\n    solve();\r\n    return 0;\r\n}"
}