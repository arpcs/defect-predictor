{
    "id": 57912910,
    "contestId": 1160,
    "creationTimeSeconds": 1564350652,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1160,
        "index": "A2",
        "name": "Collaboration",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1160,
        "members": [
            {
                "handle": "nikit523"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1556614800
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS2",
    "passedTestCount": 0,
    "timeConsumedMillis": 1700,
    "memoryConsumedBytes": 921600,
    "source": "#ifndef LOCAL\r\n#pragma GCC optimize \"O3\"\r\n#pragma GCC target \"avx,tune=native\"\r\n#endif\r\n\r\n#pragma GCC optimize \"unroll-loops,omit-frame-pointer\"\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <climits>\r\n#include <cmath>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <tuple>\r\n#include <set>\r\n\r\nusing namespace std;\r\n\r\nstruct P {\r\n    int16_t x, y, tim, per, l, r, id;\r\n};\r\nistream& operator>>(istream& in, P& p) {\r\n    return in >> p.x >> p.y >> p.tim >> p.per >> p.l >> p.r;\r\n}\r\nostream& operator<<(ostream& out, P const& p) {\r\n    return out << '(' << p.x << \", \" << p.y << \"), time: [\" << p.l << \" \" << p.r << \"]\\n\";\r\n}\r\n\r\nstruct Per {\r\n    int16_t x, y; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b\r\n    int16_t timer; // \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u0437\u0430\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\r\n};\r\n\r\nint dist(P &a, P &b) {\r\n    return abs(a.x-b.x)+abs(a.y-b.y);\r\n}\r\nint dist(Per &a, P &b) {\r\n    return abs(a.x-b.x)+abs(a.y-b.y);\r\n}\r\n\r\nbool comp(P & a, P & b) {\r\n    if (a.r-a.tim != b.r-b.tim) return (a.r-a.tim < b.r-b.tim);\r\n    if (a.l != b.l) return (a.l < b.l);\r\n    return (a.tim < b.tim);\r\n}\r\nbool comp2(P & a, P &b) {\r\n    return a.id < b.id;\r\n}\r\n\r\nint n;\r\nvector<P> point;\r\nP Main;\r\n\r\nvoid read() {\r\n    cin >> n >> Main;\r\n    --n;\r\n    point.resize(n);\r\n    int sum = 0;\r\n    for (size_t i = 0; i < size_t(n); ++i) {\r\n        cin >> point[i];\r\n        point[i].id = int16_t(i);\r\n        sum += int(point[i].tim)*point[i].per*(point[i].per+5);\r\n    }\r\n    #ifdef LOCAL\r\n    cout << sum << '\\n';\r\n    #endif\r\n}\r\n\r\nconst int BEAM_WIDTH = 5;\r\nconst int K_new = 14000;\r\n\r\nvoid answer(vector<vector<int16_t> > & order) {\r\n    sort(point.begin(), point.end(), comp2);\r\n    vector<int> s(order.size());\r\n    for (size_t i = 0; i < order.size(); ++i) {\r\n        int times, MAX = 0, MIN = 300;\r\n        P& prev = Main;\r\n        for (size_t j = 0; j < order[i].size(); ++j) {\r\n            P& p = point[size_t(order[i][j])];\r\n            if (j == 0)\r\n                times = p.l + p.tim;\r\n            else {\r\n                MAX += max(0, p.l-(times + dist(prev, p)));\r\n                times = max(times + dist(prev, p), int(p.l)) + p.tim;\r\n            }\r\n\r\n            MIN = min(MIN, p.r-times);\r\n            prev = p;\r\n        }\r\n        prev = Main;\r\n        for (size_t j = 0; j < order[i].size(); ++j) {\r\n            P& p = point[size_t(order[i][j])];\r\n            if (j == 0) {\r\n                times = p.l + p.tim;\r\n                cout << \"start \" << times - p.tim - dist(p, Main) << \" 1\\n\";\r\n            }\r\n            else\r\n                times = max(times + dist(prev, p), int(p.l)) + p.tim;\r\n            cout << \"arrive \" << times - p.tim << ' ' << p.id + 2 << '\\n';\r\n            cout << \"work \"   << times - p.tim << ' ' << times << ' ' << p.id + 2 << '\\n';\r\n            if (j == size_t(int(order[i].size()) - 1))\r\n                cout << \"arrive \" << times + dist(p, Main) << \" 1\\n\";\r\n            prev = p;\r\n        }\r\n        cout << \"end\\n\";\r\n    }\r\n}\r\n\r\nstruct state {\r\n    int s1 = 0, s2 = 0, s3 = 0;\r\n    vector<Per> m; // \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043b\u044e\u0434\u0435\u0439\r\n    vector<vector<int16_t> > order; // \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u043f\u043e\u0441\u0435\u0449\u0435\u043d\u0438\u044f \u0433\u043e\u0440\u043e\u0434\u043e\u0432 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430\r\n    vector<int16_t> when; // \u043a\u043e\u0433\u0434\u0430 \u043f\u043e\u0441\u0435\u0449\u0430\u0435\u043c i-\u044b\u0439 \u0433\u043e\u0440\u043e\u0434\r\n};\r\n\r\nvoid solve() {\r\n    sort(point.begin(), point.end(), comp);\r\n    vector<state> beam(1);\r\n    beam[0].when.resize(n, 0);\r\n    for (size_t i = 0; i < size_t(n); ++i) {\r\n        vector<state> v;\r\n        for (size_t b = 0; b < beam.size(); ++b) {\r\n            if (beam[b].when[size_t(point[i].id)] != 0)\r\n                continue;\r\n            vector<Per> M = beam[b].m;\r\n            vector<vector<int16_t> > Order = beam[b].order;\r\n            vector<int16_t> s;\r\n            for (size_t j = 0; j < M.size(); ++j)\r\n                if (M[j].timer + dist(M[j], point[i]) <= point[i].r - point[i].tim)\r\n                    s.push_back(M[j].timer + int16_t(dist(M[j], point[i])));\r\n            int newer = 0;\r\n            while (int(s.size()) < point[i].per) {\r\n                Per new_p = (Per) {Main.x, Main.y, 0};\r\n                s.push_back(int16_t(dist(new_p, point[i])));\r\n                M.push_back(new_p);\r\n                Order.push_back(vector<int16_t>(0));\r\n                ++newer;\r\n            }\r\n            partial_sort(s.begin(), s.begin()+ min(int(s.size()), point[i].per + K_new - 1), s.end());\r\n\r\n            int S1 = beam[b].s1 + int(point[i].tim)*point[i].per*(point[i].per+5);\r\n            int S2 = beam[b].s2 + newer;\r\n            int S3 = beam[b].s3 + int(point[i].tim)*point[i].per;\r\n\r\n            int16_t prevto = 0;\r\n            for (int quant = point[i].per - 1; quant < min(point[i].per - 1 + K_new, int(s.size())); ++quant) {\r\n\r\n                int16_t to = max(s[size_t(quant)], point[i].l) + point[i].tim;\r\n                if (to == prevto)\r\n                    continue;\r\n                prevto = to;\r\n                int16_t from = to - point[i].tim;\r\n\r\n                state Newstate;\r\n                Newstate.s1 = S1;\r\n                Newstate.s2 = S2;\r\n                Newstate.s3 = S3;\r\n                Newstate.when = beam[b].when;\r\n                Newstate.when[size_t(point[i].id)] = to;\r\n                Newstate.m = M;\r\n                Newstate.order = Order;\r\n                vector<pair<int16_t, int16_t> > s_;\r\n\r\n                for (size_t j = 0; j < Newstate.m.size(); ++j)\r\n                    if (Newstate.m[j].timer + dist(Newstate.m[j], point[i]) <= from)\r\n                        s_.push_back(make_pair(from - Newstate.m[j].timer, int(j)));\r\n\r\n                partial_sort(s_.begin(), s_.begin() + point[i].per, s_.end());\r\n\r\n                for (size_t j = 0; j < size_t(point[i].per); ++j) {\r\n                    size_t id = size_t(s_[j].second);\r\n                    if (Newstate.m[id].timer == 0) {\r\n                        Newstate.s3 += dist(Main, point[i]);\r\n                    }\r\n                    else {\r\n                        Newstate.s3 += s_[j].first;\r\n                    }\r\n                    Newstate.order[id].push_back(point[i].id);\r\n                    Newstate.m[id].x = point[i].x;\r\n                    Newstate.m[id].y = point[i].y;\r\n                    Newstate.m[id].timer = to;\r\n                }\r\n                v.push_back(move(Newstate));\r\n                size_t id = size_t(int(v.size())-1);\r\n                while (id != 0 && v[id].s1 - 240*v[id].s2 - v[id].s3 > v[size_t(int(id)-1)].s1 - 240*v[size_t(int(id)-1)].s2 - v[size_t(int(id)-1)].s3) {\r\n                    state c = move(v[id]);\r\n                    v[id] = move(v[size_t(int(id)-1)]);\r\n                    v[size_t(int(id)-1)] = move(c);\r\n                    --id;\r\n                }\r\n                if (int(v.size()) == BEAM_WIDTH + 1)\r\n                    v.pop_back();\r\n            }\r\n        }\r\n        beam = move(v);\r\n    }\r\n    int mini = 0;\r\n    size_t id = 0;\r\n    for (size_t i = 0; i < beam.size(); ++i) {\r\n        for (size_t j = 0; j < beam[i].m.size(); ++j) {\r\n            beam[i].s3 += dist(beam[i].m[j], Main);\r\n        }\r\n        if (beam[i].s1 - 240*beam[i].s2 - beam[i].s3 > mini) {\r\n            mini = beam[i].s1 - 240*beam[i].s2 - beam[i].s3;\r\n            id = i;\r\n        }\r\n        #ifdef LOCAL\r\n        cout << beam[i].s1 << ' ' << beam[i].s2 << ' ' << beam[i].s3 << '\\n';\r\n        cout << beam[i].s1 - 240*beam[i].s2 - beam[i].s3 << '\\n';\r\n        #endif\r\n    }\r\n    answer(beam[id].order);\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    #ifdef LOCAL\r\n        freopen(\"/Users/nikitaigumnov/Downloads/codeforces-vrt-2019/001.txt\", \"r\", stdin);\r\n        freopen(\"/Users/nikitaigumnov/Downloads/codeforces-vrt-2019/0001.txt\", \"w\", stdout);\r\n    #endif\r\n    ios::sync_with_stdio(0); cin.tie(nullptr);\r\n    read();\r\n    solve();\r\n    return 0;\r\n}"
}