{
    "id": 54008689,
    "contestId": 1160,
    "creationTimeSeconds": 1557614688,
    "relativeTimeSeconds": 999888,
    "problem": {
        "contestId": 1160,
        "index": "A2",
        "name": "Collaboration",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1160,
        "members": [
            {
                "handle": "okwedook"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1556614800
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS2",
    "passedTestCount": 0,
    "timeConsumedMillis": 14382,
    "memoryConsumedBytes": 1228800,
    "source": "#pragma GCC optimize(\"O3\", \"unroll-loops\")\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <sstream>\n#include <deque>\n#include <queue>\n#include <random>\n#include <complex>\n\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define FIXED cout << fixed << setprecision(12);\n#define RANDOM srand(94385)\n#define ll long long\n#define ld long double\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define graph vector<vector<int>>\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define f first\n#define s second\n#define hashmap unordered_map\n#define hashset unordered_set\n#define eps 1e-9\n#define mod 1000000007\n#define inf 3000000000000000007ll\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define shuffle(a) \\\n    for (int i = 0; i < sz(a); ++i) \\\n        swap(a[i], a[rand() % sz(a)])\n\ntemplate<class T, class U> inline void checkmin(T &x, U y) { if (y < x) x = y; }\ntemplate<class T, class U> inline void checkmax(T &x, U y) { if (y > x) x = y; }\ntemplate<class T, class U> inline bool ifmax(T &x, U y) { if (y > x) return x = y, true; return false; }\ntemplate<class T, class U> inline bool ifmin(T &x, U y) { if (y < x) return x = y, true; return false; }\ntemplate<class T> inline void sort(T &a) { sort(all(a)); }\ntemplate<class T> inline void rsort(T &a) { sort(rall(a)); }\ntemplate<class T> inline void reverse(T &a) { reverse(all(a)); }\ntemplate<class T, class U> inline istream& operator>>(istream& str, pair<T, U> &p) { return str >> p.f >> p.s; }\ntemplate<class T> inline istream& operator>>(istream& str, vector<T> &a) { for (auto &i : a) str >> i; return str; }\n\nvoid start(int moment, int location) {\n    cout << \"start \" << moment << ' ' << location + 1 << '\\n';\n} \n\nvoid arrive(int moment, int location) {\n    cout << \"arrive \" << moment << ' ' << location + 1 << '\\n';\n}\n\nvoid work(int start, int end, int location) {\n    cout << \"work \" << start << ' ' << end << ' ' << location + 1 << '\\n';\n}\n\nvoid end() {\n    cout << \"end\\n\";\n}\n\nstruct Location {   \n    int x, y, d, p, l, h;\n    int ind;\n    Location() {}\n    friend istream& operator>>(istream& str, Location &loc) {\n        return str >> loc.x >> loc.y >> loc.d >> loc.p >> loc.l >> loc.h;\n    }\n    bool isbase() { return d == 0; }\n    int cost() {\n        return d * p * (p + 5);\n    }\n};\n\nenum Type { START, ARRIVE, WORK, END };\n\nstruct Action {\n    Type type;\n    int from, to;\n    int loc;\n    Action(Type type, int loc, int from, int to = -1) {\n        this->type = type;\n        this->loc = loc;\n        this->from = from;\n        checkmax(to, from);\n        this->to = to;\n    }\n};\n\nvector<Location> a;\n\nstruct Human {\n    vector<Action> actions;\n    int t = 0, loc = 0;\n    void add(Action act) {\n        actions.pb(act);\n        t = act.to;\n        loc = act.loc;\n    }\n};\n\nstruct Answer {\n    vector<Human> human;\n    int sum = 0;\n    void apply() {\n        for (auto &h : human) \n            for (auto &act : h.actions)\n                act.loc = a[act.loc].ind;\n    }\n    void print() {\n        for (auto &h : human) {\n            for (auto i : h.actions) {\n                if (i.type == START) start(i.from, i.loc);\n                if (i.type == ARRIVE) arrive(i.from, i.loc);\n                if (i.type == WORK) work(i.from, i.to, i.loc);\n            }\n            end();\n        }\n    }\n};\n\nbool operator<(const Answer &a, const Answer &b) {\n    return a.sum < b.sum;\n}\n\nbool operator>(const Answer &a, const Answer &b) {\n    return a.sum > b.sum;\n}\n\nint eval(vector<Human> human) {\n    int ans = 0;\n    for (auto h : human) {\n        ans += 240;\n        ans += h.actions.back().to - h.actions.front().from;\n    }\n    return ans;\n}\n\nbool cmp1(Location a, Location b) {\n    return a.h < b.h;\n}\n\nint cb = 300;\nint ca = 15;\n\nbool cmp(Location a, Location b) {\n    if (a.h - a.l > cb && b.h - b.l > cb) return a.l < b.l;\n    if (a.l > b.h) return false;\n    if (b.l > a.h) return true;\n    if (a.h / ca == b.h / ca) return a.l < b.l;\n    return a.h < b.h;\n}\n\nbool cmp2(Location a, Location b) {\n    if (abs(a.h - b.h) < cb) return a.l < b.l;\n    return a.h < b.h;\n}\n\nint dist(Location a, Location b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nint dist(int i, int j) {\n    return dist(a[i], a[j]);\n}\n\nint getto(Human h, int a) {\n    return h.t + dist(h.loc, a);\n}\n\nAnswer solve(int mxlen = 34, int mxd = 40, float pcnt = 0.3, float ploc = 0.4) {\n    Answer ans;\n    int n = sz(a);\n    vector<Human> &human = ans.human;\n    for (int l = 1; l < n; ++l) {\n        int ptr = 0;\n        for (int i = 0; i < sz(human); ++i)\n            if (dist(human[i].loc, l) <= mxlen && a[l].l - human[i].t < mxd) \n                swap(human[i], human[ptr++]);\n        if (ptr) {\n            nth_element(human.begin(), human.begin() + min(7, ptr) - 1, human.begin() + ptr, [&](const Human &h1, const Human &h2) {\n                return getto(h1, l) < getto(h2, l);\n            });\n            sort(human.begin(), human.begin() + min(ptr, 7), [&](const Human &h1, const Human &h2) {\n                return getto(h1, l) < getto(h2, l);\n            });\n        }\n        int ind = 0, mx = a[l].l;\n        for (; ind < a[l].p && ind < sz(human); ++ind) {\n            if (getto(human[ind], l) >= a[l].h) break;\n            checkmax(mx, getto(human[ind], l));\n        }\n        int cost = 0;\n        for (int i = 0; i < ind; ++i) cost += (mx - human[i].t) + dist(0, l) - dist(0, human[i].loc);\n        for (int i = ind; i < a[l].p; ++i) cost += 2 * dist(0, l) + 240;\n        if (a[l].cost() > cost || sz(human) < n * pcnt || l < n * ploc) {\n            ans.sum += a[l].cost();\n            for (int i = 0; i < ind; ++i) {\n                human[i].add(Action(ARRIVE, l, mx));\n                human[i].add(Action(WORK, l, mx, mx + a[l].d));\n            }\n            for (int i = ind; i < a[l].p; ++i) {\n                Human h;\n                h.add(Action(START, 0, mx - dist(0, l)));\n                h.add(Action(ARRIVE, l, mx));   \n                h.add(Action(WORK, l, mx, mx + a[l].d));\n                human.pb(h);\n            }\n        }\n    }\n    for (auto &h : human) h.add(Action(ARRIVE, 0, h.t + dist(0, h.loc)));\n    ans.sum -= eval(human);\n    ans.apply();\n    return ans;\n}\n\nsigned main() {\n    FAST; FIXED; RANDOM;\n    int n;\n    cin >> n;\n    a = vector<Location>(n);\n    cin >> a;\n    for (int i = 0; i < n; ++i) a[i].ind = i, a[i].h -= a[i].d;\n    sort(all(a), cmp);\n    Answer ans = solve();\n    while (clock() < 14500) {\n        checkmax(ans, solve(rand() % 20 + 15, rand() % 50 + 35));\n        checkmax(ans, solve(rand() % 20 + 15, rand() % 50 + 35));\n        int t = rand() % 2 + 3;\n        for (int i = 0; i + t <= n; i += t) {\n            for (int j = i; j < i + t; ++j)\n                swap(a[j], a[rand() % t + i]);\n        }\n    }\n    #ifdef DEBUG\n        cout << ans.sum << '\\n';\n    #endif\n    ans.print();\n    return 0;\n}  "
}