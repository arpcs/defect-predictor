{
    "id": 223080358,
    "contestId": 439,
    "creationTimeSeconds": 1694519939,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 439,
        "index": "C",
        "name": "Devu and Partitioning of the Array",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "number theory"
        ]
    },
    "author": {
        "contestId": 439,
        "members": [
            {
                "handle": "Noureldein"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1401895800
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 23,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 2048000,
    "source": "/* \u0628\u0650\u0633\u0652\u0645\u0650 \u0627\u0644\u0644\u0651\u064e\u0640\u0647\u0650 \u0627\u0644\u0631\u0651\u064e\u062d\u0652\u0645\u064e\u0640\u0670\u0646\u0650 \u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 */\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define accelerate cin.tie(0); cin.sync_with_stdio(0);\ntypedef long long ll;\nusing namespace __gnu_pbds;\nusing namespace std;\n\n//#define ordered_set tree<ll,null_type,less_equal<ll>,rb_tree_tag,tree_order_statistics_node_update>\ntypedef tree<\n        int,\n        null_type,\n        less_equal<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\n\n\nbool sortPairBySecondElement(const pair<ll, ll> &a, const pair<ll, ll> &b);\n\nvector<pair<ll, int>> factorization(ll n);\n\nbool can(vector<int> arr, int n);\n\nvoid checkPermutation();\n\nlong long binaryExponentiation(long long base, long long exp);\n\nlong long binaryExponentiation(ll number, ll power, ll mod);\n\nbool isPrim(ll number);\n\nvector<bool> sieve(ll sieveNumber);\n\nll extended_euclid(ll a, ll b, ll &x, ll &y);\n\nll Fermat(ll n, ll mod);\n\nll modularMultiplication(ll a, ll b, ll p);\n\nll MOD = 998244353;\nll fre[100000 + 10];\n\nvoid fun() {\n    for (ll i = 1; i <= 1000; ++i) fre[i] = ((i * (1 + i)) / 2) + ((i * (i - 1)) / 2) + fre[i - 1];\n\n}\n\nvoid zeroFun() {\n    for (ll &i: fre) {\n        i = 0;\n    }\n}\n\n\nvector<vector<pair<int, int>>>\n\nprimeFactorization(int n = 10 + 5);\n\nint ttt = 1;\n\nbool cond(int i, int j) {\n    return i >= j;\n}\n\nbool ffff = false;\n\nvoid problems() {\n    int sz, k, p;\n    cin >> sz >> k >> p;\n    vector<int> odd, even;\n    for (int i = 0; i < sz; ++i) {\n        int x;\n        cin >> x;\n        if (x & 1)odd.push_back(x);\n        else even.push_back(x);\n    }\n    int reminder = 0;\n    if (even.size() < p) {\n        reminder = (p - (int) even.size()) * 2;\n    }\n//    cout<<((odd.size() - reminder) - (k - p));\n    if (reminder>odd.size()||(k - p) > (odd.size() - reminder) || (((odd.size() - reminder) - (k - p)) % 2 == 1)) {\n        cout << \"NO\";\n        return;\n    }\n    cout << \"YES\\n\";\n    int cop = p;\n\n    for (int i = 0; i < reminder; i += 2, p--) {\n        cout << 2 << ' ' << odd[i] << ' ' << odd[i + 1] << '\\n';\n    }\n    for (int i = 0; i < even.size() && p; ++i, p--) {\n        if (p == 1) {\n            cout << even.size() - i << ' ';\n            for (int j = i; j < even.size(); ++j) {\n                cout << even[j] << ' ';\n            }\n            cout << '\\n';\n            break;\n        } else\n            cout << 1 << ' ' << even[i] << '\\n';\n    }\n    int tem = k - cop;\n    for (int i = reminder; i < odd.size(); ++i, tem--) {\n        if (tem == 1) {\n            cout << odd.size() - i << ' ';\n            for (int j = i; j < odd.size(); ++j) {\n                cout << odd[j] << ' ';\n            }\n            cout << '\\n';\n            break;\n        } else {\n            cout << 1 << ' ' << odd[i] << '\\n';\n        }\n    }\n\n}\n\n\nint main() {\n\n    //freopen(\"cubes.in\", \"r\", stdin);\n    accelerate\n    int test = 1;\n    // cin >> test;\n    while (test--) {\n        problems();\n//        cout << '\\n';\n    }\n}\n\n\n//Note 0 and 1\nvector<pair<ll, int>> factorization(ll n) {\n    vector<pair<ll, int>> primes;\n    for (ll i = 2; i * i <= n; ++i) {\n\n        while (n % i == 0) {\n            int cnt = 0;\n            while (n % i == 0)n /= i, cnt++;\n\n            primes.emplace_back(i, cnt);\n        }\n\n    }\n    if (n > 1)primes.emplace_back(n, 1);\n\n    return primes;\n}\n\nbool isPrim(ll number) {\n    if (number == 2)return true;\n    if (2 > number || !(number & 1ll))return false;\n\n    for (ll i = 3; i * i <= number; i += 2) {\n        if (number % i == 0)return false;\n    }\n    return true;\n}\n\nbool sortPairBySecondElement(const pair<ll, ll> &a,\n                             const pair<ll, ll> &b) {\n    return (a.second < b.second);\n}\n\n\nvector<bool> sieve(ll sieveNumber) {\n    vector<bool> prime(sieveNumber, true);\n    prime[0] = prime[1] = false;\n    for (ll i = 2; i <= sieveNumber; i++) {\n        if (prime[i]) {\n            for (ll j = i * 2; j <= sieveNumber; j += i)\n                prime[j] = false;\n        }\n    }\n    return prime;\n}\n\n////O(R-L+1)loglog(R)+sqrt(R)loglog(sqrt(R))\nvector<bool> segmentedSieve(long long L, long long R) {\n    // generate all primes up to sqrt(R)\n    long long lim = sqrt(R);\n    vector<bool> mark(lim + 1, false);\n    vector<long long> primes;\n    for (long long i = 2; i <= lim; ++i) {\n        if (!mark[i]) {\n            primes.emplace_back(i);\n            for (long long j = i * i; j <= lim; j += i)\n                mark[j] = true;\n        }\n    }\n\n    vector<bool> isPrime(R - L + 1, true);\n    for (long long i: primes)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n\nvector<vector<pair<int, int>>> primeFactorization(int n) {\n    vector<vector<pair<int, int>>> p(n + 1);\n    vector<bool> is(n + 1, true);\n    for (int i = 2; i <= n; ++i) {\n        if (is[i]) {\n            for (int j = i; j <= n; j += i) {\n                is[j] = false;\n                int cnt = 0, cpy = j;\n                while (cpy % i == 0)cpy /= i, cnt++;\n\n                p[j].emplace_back(i, cnt);\n            }\n        }\n    }\n    return p;\n}\n\nlong long binaryExponentiation(long long base, long long exp) {\n    long long res = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            res = (res * base);\n        exp = exp >> 1;\n        base = (base * base);\n    }\n    return res;\n}\n\nlong long binaryExponentiation(long long base, long long exp, ll mod) {\n    long long res = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            res = (res * base) % mod;\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return res % mod;\n}\n\nll extended_euclid(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1, y = 0;\n        return a;\n    }\n    ll g = extended_euclid(b, a % b, y, x);\n    y -= (a / b) * x;\n    return g;\n}\n\nll Fermat(ll n, ll mod) {\n//using it if MOD is prime number\n    return binaryExponentiation(n, mod - 2, mod);\n}\n\nll modularMultiplication(ll a, ll b, ll p) {\n    a %= p;\n    ll res = 0;\n    while (b) {\n        if (b & 1)res = ((res % p) + (a % p)) % p;\n\n        a = ((a % p) + (a % p)) % p;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid checkPermutation() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 1; i <= n; ++i)arr[i - 1] = i;\n\n    do {\n        if (can(arr, n)) {\n            for (int i = 0; i < n; ++i) cout << arr[i] << ' ';\n            cout << '\\n';\n        }\n    } while (next_permutation(arr.begin(), arr.end()));\n}\n\n\nbool can(vector<int> arr, int n) {\n\n\n}"
}