{
    "id": 176865285,
    "contestId": 883,
    "creationTimeSeconds": 1666089915,
    "relativeTimeSeconds": 3915,
    "problem": {
        "contestId": 883,
        "index": "L",
        "name": "Berland.Taxi",
        "type": "PROGRAMMING",
        "rating": 2500,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 883,
        "members": [
            {
                "handle": "_su1sen"
            },
            {
                "handle": "kencho"
            },
            {
                "handle": "ikuyo_kita"
            }
        ],
        "participantType": "VIRTUAL",
        "teamId": 100317,
        "teamName": "Bu-Bu-Du-Ke",
        "ghost": false,
        "startTimeSeconds": 1666086000
    },
    "programmingLanguage": "Java 11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 90,
    "timeConsumedMillis": 1840,
    "memoryConsumedBytes": 39526400,
    "source": "import java.util.*;\n\npublic class L {\n\n    public static final int MOD998 = 998244353;\n    public static final int MOD100 = 1000000007;\n\n    public static void main(String[] args) throws Exception {\n        ContestScanner sc = new ContestScanner();\n        ContestPrinter cp = new ContestPrinter();\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int M = sc.nextInt();\n        int[] init = sc.nextIntArray(K);\n        TreeMap<Integer, TreeSet<Long>> map = new TreeMap<>();\n        int free = K;\n        PriorityQueue<long[]> queue = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));\n        for (int k = 0; k < K; k++) {\n            if (!map.containsKey(init[k])) {\n                map.put(init[k], new TreeSet<>());\n            }\n            map.get(init[k]).add((long) (k + 1));\n        }\n        long now = 0;\n        for (int m = 0; m < M; m++) {\n            long t = sc.nextLong();\n            now = Math.max(now, t);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            while (!queue.isEmpty() && queue.peek()[0] <= t) {\n                long[] car = queue.poll();\n                if (!map.containsKey((int) car[1])) {\n                    map.put((int) car[1], new TreeSet<>());\n                }\n                map.get((int) car[1]).add(car[0] * 1000000 + car[2] % 1000000);\n                free++;\n            }\n            if (free == 0) {\n                long next = queue.peek()[0];\n                now = next;\n                while (!queue.isEmpty() && queue.peek()[0] == next) {\n                    long[] car = queue.poll();\n                    if (!map.containsKey((int) car[1])) {\n                        map.put((int) car[1], new TreeSet<>());\n                    }\n                    map.get((int) car[1]).add(car[0] * 1000000 + car[2] % 1000000);\n                    free++;\n                }\n            }\n            int fl = map.floorKey(a) == null ? -10000000 : map.floorKey(a);\n            int ce = map.ceilingKey(a) == null ? 10000000 : map.ceilingKey(a);\n            if (a - fl == ce - a) {\n                if (map.get(fl).first() < map.get(ce).first()) {\n                    long num = map.get(fl).first();\n                    map.get(fl).remove(num);\n                    if (map.get(fl).isEmpty()) {\n                        map.remove(fl);\n                    }\n                    cp.println(num % 1000000 + \" \" + ((a - fl) + now - t));\n                    queue.add(new long[] { (a - fl) + now + Math.abs(a - b), b,\n                            ((a - fl) + now + Math.abs(a - b)) * 1000000 + num % 1000000 });\n                } else {\n                    long num = map.get(ce).first();\n                    map.get(ce).remove(num);\n                    if (map.get(ce).isEmpty()) {\n                        map.remove(ce);\n                    }\n                    cp.println(num % 1000000 + \" \" + ((a - fl) + now - t));\n                    queue.add(new long[] { (a - fl) + now + Math.abs(a - b), b,\n                            ((a - fl) + now + Math.abs(a - b)) * 1000000 + num % 1000000 });\n                }\n            } else if (a - fl < ce - a) {\n                long num = map.get(fl).first();\n                map.get(fl).remove(num);\n                if (map.get(fl).isEmpty()) {\n                    map.remove(fl);\n                }\n                cp.println(num % 1000000 + \" \" + ((a - fl) + now - t));\n                queue.add(new long[] { (a - fl) + now + Math.abs(a - b), b,\n                        ((a - fl) + now + Math.abs(a - b)) * 1000000 + num % 1000000 });\n            } else {\n                long num = map.get(ce).first();\n                map.get(ce).remove(num);\n                if (map.get(ce).isEmpty()) {\n                    map.remove(ce);\n                }\n                cp.println(num % 1000000 + \" \" + ((ce - a) + now - t));\n                queue.add(new long[] { (ce - a) + now + Math.abs(a - b), b,\n                        ((ce - a) + now + Math.abs(a - b)) * 1000000 + num % 1000000 });\n            }\n            free--;\n        }\n        cp.close();\n    }\n\n    //////////////////\n    // My Library //\n    //////////////////\n\n    public static int zeroOneBFS(int[][][] weighted_graph, int start, int goal) {\n        int[] dist = new int[weighted_graph.length];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int now = queue.poll();\n            if (now == goal) {\n                return dist[goal];\n            }\n            for (int[] info : weighted_graph[now]) {\n                if (dist[info[0]] > dist[now] + info[1]) {\n                    dist[info[0]] = dist[now] + info[1];\n                    if (info[1] == 0) {\n                        queue.addFirst(info[0]);\n                    } else {\n                        queue.addLast(info[0]);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static int[] zeroOneBFSAll(int[][][] weighted_graph, int start) {\n        int[] dist = new int[weighted_graph.length];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int now = queue.poll();\n            for (int[] info : weighted_graph[now]) {\n                if (dist[info[0]] > dist[now] + info[1]) {\n                    dist[info[0]] = dist[now] + info[1];\n                    if (info[1] == 0) {\n                        queue.addFirst(info[0]);\n                    } else {\n                        queue.addLast(info[0]);\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n\n    public static long dijkstra(int[][][] weighted_graph, int start, int goal) {\n        long[] dist = new long[weighted_graph.length];\n        Arrays.fill(dist, 0, dist.length, Long.MAX_VALUE);\n        dist[start] = 0;\n        PriorityQueue<Pair<Integer, Long>> unsettled = new PriorityQueue<>((u, v) -> (int) (u.cdr - v.cdr));\n        unsettled.offer(new Pair<Integer, Long>(start, 0L));\n        while (!unsettled.isEmpty()) {\n            Pair<Integer, Long> pair = unsettled.poll();\n            int now = pair.car;\n            if (now == goal) {\n                return dist[goal];\n            }\n            if (dist[now] < pair.cdr) {\n                continue;\n            }\n            for (int[] info : weighted_graph[now]) {\n                if (dist[info[0]] > dist[now] + info[1]) {\n                    dist[info[0]] = dist[now] + info[1];\n                    unsettled.offer(new Pair<Integer, Long>(info[0], dist[info[0]]));\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static long[] dijkstraAll(int[][][] weighted_graph, int start) {\n        long[] dist = new long[weighted_graph.length];\n        Arrays.fill(dist, 0, dist.length, Long.MAX_VALUE);\n        dist[start] = 0;\n        PriorityQueue<Pair<Integer, Long>> unsettled = new PriorityQueue<>((u, v) -> (int) (u.cdr - v.cdr));\n        unsettled.offer(new Pair<Integer, Long>(start, 0L));\n        while (!unsettled.isEmpty()) {\n            Pair<Integer, Long> pair = unsettled.poll();\n            int now = pair.car;\n            if (dist[now] < pair.cdr) {\n                continue;\n            }\n            for (int[] info : weighted_graph[now]) {\n                if (dist[info[0]] > dist[now] + info[1]) {\n                    dist[info[0]] = dist[now] + info[1];\n                    unsettled.offer(new Pair<Integer, Long>(info[0], dist[info[0]]));\n                }\n            }\n        }\n        return dist;\n    }\n\n    public static class Pair<A, B> {\n        public final A car;\n        public final B cdr;\n\n        public Pair(A car_, B cdr_) {\n            car = car_;\n            cdr = cdr_;\n        }\n\n        private static boolean eq(Object o1, Object o2) {\n            return o1 == null ? o2 == null : o1.equals(o2);\n        }\n\n        private static int hc(Object o) {\n            return o == null ? 0 : o.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof Pair))\n                return false;\n            Pair<?, ?> rhs = (Pair<?, ?>) o;\n            return eq(car, rhs.car) && eq(cdr, rhs.cdr);\n        }\n\n        @Override\n        public int hashCode() {\n            return hc(car) ^ hc(cdr);\n        }\n    }\n\n    public static class Tuple1<A> extends Pair<A, Object> {\n        public Tuple1(A a) {\n            super(a, null);\n        }\n    }\n\n    public static class Tuple2<A, B> extends Pair<A, Tuple1<B>> {\n        public Tuple2(A a, B b) {\n            super(a, new Tuple1<>(b));\n        }\n    }\n\n    public static class Tuple3<A, B, C> extends Pair<A, Tuple2<B, C>> {\n        public Tuple3(A a, B b, C c) {\n            super(a, new Tuple2<>(b, c));\n        }\n    }\n\n    public static class Tuple4<A, B, C, D> extends Pair<A, Tuple3<B, C, D>> {\n        public Tuple4(A a, B b, C c, D d) {\n            super(a, new Tuple3<>(b, c, d));\n        }\n    }\n\n    public static class Tuple5<A, B, C, D, E> extends Pair<A, Tuple4<B, C, D, E>> {\n        public Tuple5(A a, B b, C c, D d, E e) {\n            super(a, new Tuple4<>(b, c, d, e));\n        }\n    }\n\n    public static class PriorityQueueLogTime<T> {\n        private PriorityQueue<T> queue;\n        private Multiset<T> total;\n        private int size = 0;\n\n        public PriorityQueueLogTime() {\n            queue = new PriorityQueue<>();\n            total = new Multiset<>();\n        }\n\n        public PriorityQueueLogTime(Comparator<T> c) {\n            queue = new PriorityQueue<>(c);\n            total = new Multiset<>();\n        }\n\n        public void clear() {\n            queue.clear();\n            total.clear();\n            size = 0;\n        }\n\n        public boolean contains(T e) {\n            return total.count(e) > 0;\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public boolean offer(T e) {\n            total.addOne(e);\n            size++;\n            return queue.offer(e);\n        }\n\n        public T peek() {\n            if (total.isEmpty()) {\n                return null;\n            }\n            simplify();\n            return queue.peek();\n        }\n\n        public T poll() {\n            if (total.isEmpty()) {\n                return null;\n            }\n            simplify();\n            size--;\n            T res = queue.poll();\n            total.removeOne(res);\n            return res;\n        }\n\n        public void remove(T e) {\n            total.removeOne(e);\n            size--;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        private void simplify() {\n            while (total.count(queue.peek()) == 0) {\n                queue.poll();\n            }\n        }\n\n    }\n\n    static int[][] scanGraphOneIndexed(ContestScanner sc, int node, int edge, boolean undirected) {\n        int[][] arr = sc.nextIntArrayMulti(edge, 2);\n        for (int n = 0; n < edge; n++) {\n            arr[0][n]--;\n            arr[1][n]--;\n        }\n        return GraphBuilder.makeGraph(node, edge, arr[0], arr[1], undirected);\n    }\n\n    static int[][][] scanWeightedGraphOneIndexed(ContestScanner sc, int node, int edge, boolean undirected) {\n        int[][] arr = sc.nextIntArrayMulti(edge, 3);\n        for (int n = 0; n < edge; n++) {\n            arr[0][n]--;\n            arr[1][n]--;\n        }\n        return GraphBuilder.makeGraphWithWeight(node, edge, arr[0], arr[1], arr[2], undirected);\n    }\n\n    static class EdgeData {\n        private int capacity;\n        private int[] from, to, weight;\n        private int p = 0;\n        private boolean weighted;\n\n        public EdgeData(boolean weighted) {\n            this(weighted, 500000);\n        }\n\n        public EdgeData(boolean weighted, int initial_capacity) {\n            capacity = initial_capacity;\n            from = new int[capacity];\n            to = new int[capacity];\n            weight = new int[capacity];\n            this.weighted = weighted;\n        }\n\n        public void addEdge(int u, int v) {\n            if (weighted) {\n                System.err.println(\"The graph is weighted!\");\n                return;\n            }\n            if (p == capacity) {\n                int[] newfrom = new int[capacity * 2];\n                int[] newto = new int[capacity * 2];\n                System.arraycopy(from, 0, newfrom, 0, capacity);\n                System.arraycopy(to, 0, newto, 0, capacity);\n                from = newfrom;\n                to = newto;\n                capacity *= 2;\n            }\n            from[p] = u;\n            to[p] = v;\n            p++;\n        }\n\n        public void addEdge(int u, int v, int w) {\n            if (!weighted) {\n                System.err.println(\"The graph is NOT weighted!\");\n                return;\n            }\n            if (p == capacity) {\n                int[] newfrom = new int[capacity * 2];\n                int[] newto = new int[capacity * 2];\n                int[] newweight = new int[capacity * 2];\n                System.arraycopy(from, 0, newfrom, 0, capacity);\n                System.arraycopy(to, 0, newto, 0, capacity);\n                System.arraycopy(weight, 0, newweight, 0, capacity);\n                from = newfrom;\n                to = newto;\n                weight = newweight;\n                capacity *= 2;\n            }\n            from[p] = u;\n            to[p] = v;\n            weight[p] = w;\n            p++;\n        }\n\n        public int[] getFrom() {\n            int[] result = new int[p];\n            System.arraycopy(from, 0, result, 0, p);\n            return result;\n        }\n\n        public int[] getTo() {\n            int[] result = new int[p];\n            System.arraycopy(to, 0, result, 0, p);\n            return result;\n        }\n\n        public int[] getWeight() {\n            int[] result = new int[p];\n            System.arraycopy(weight, 0, result, 0, p);\n            return result;\n        }\n\n        public int size() {\n            return p;\n        }\n    }\n\n    ////////////////////////////////\n    // Atcoder Library for Java //\n    ////////////////////////////////\n\n    static class MathLib {\n        private static long safe_mod(long x, long m) {\n            x %= m;\n            if (x < 0)\n                x += m;\n            return x;\n        }\n\n        private static long[] inv_gcd(long a, long b) {\n            a = safe_mod(a, b);\n            if (a == 0)\n                return new long[] { b, 0 };\n            long s = b, t = a;\n            long m0 = 0, m1 = 1;\n            while (t > 0) {\n                long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;\n                long tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0)\n                m0 += b / s;\n            return new long[] { s, m0 };\n        }\n\n        public static long gcd(long a, long b) {\n            a = java.lang.Math.abs(a);\n            b = java.lang.Math.abs(b);\n            return inv_gcd(a, b)[0];\n        }\n\n        public static long lcm(long a, long b) {\n            a = java.lang.Math.abs(a);\n            b = java.lang.Math.abs(b);\n            return a / gcd(a, b) * b;\n        }\n\n        public static long pow_mod(long x, long n, int m) {\n            assert n >= 0;\n            assert m >= 1;\n            if (m == 1)\n                return 0L;\n            x = safe_mod(x, m);\n            long ans = 1L;\n            while (n > 0) {\n                if ((n & 1) == 1)\n                    ans = (ans * x) % m;\n                x = (x * x) % m;\n                n >>>= 1;\n            }\n            return ans;\n        }\n\n        public static long[] crt(long[] r, long[] m) {\n            assert (r.length == m.length);\n            int n = r.length;\n\n            long r0 = 0, m0 = 1;\n            for (int i = 0; i < n; i++) {\n                assert (1 <= m[i]);\n                long r1 = safe_mod(r[i], m[i]), m1 = m[i];\n                if (m0 < m1) {\n                    long tmp = r0;\n                    r0 = r1;\n                    r1 = tmp;\n                    tmp = m0;\n                    m0 = m1;\n                    m1 = tmp;\n                }\n                if (m0 % m1 == 0) {\n                    if (r0 % m1 != r1)\n                        return new long[] { 0, 0 };\n                    continue;\n                }\n\n                long[] ig = inv_gcd(m0, m1);\n                long g = ig[0], im = ig[1];\n\n                long u1 = m1 / g;\n                if ((r1 - r0) % g != 0)\n                    return new long[] { 0, 0 };\n\n                long x = (r1 - r0) / g % u1 * im % u1;\n\n                r0 += x * m0;\n                m0 *= u1;\n                if (r0 < 0)\n                    r0 += m0;\n                // System.err.printf(\"%d %d\\n\", r0, m0);\n            }\n            return new long[] { r0, m0 };\n        }\n\n        public static long floor_sum(long n, long m, long a, long b) {\n            long ans = 0;\n            if (a >= m) {\n                ans += (n - 1) * n * (a / m) / 2;\n                a %= m;\n            }\n            if (b >= m) {\n                ans += n * (b / m);\n                b %= m;\n            }\n\n            long y_max = (a * n + b) / m;\n            long x_max = y_max * m - b;\n            if (y_max == 0)\n                return ans;\n            ans += (n - (x_max + a - 1) / a) * y_max;\n            ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n            return ans;\n        }\n\n        public static java.util.ArrayList<Long> divisors(long n) {\n            java.util.ArrayList<Long> divisors = new ArrayList<>();\n            java.util.ArrayList<Long> large = new ArrayList<>();\n\n            for (long i = 1; i * i <= n; i++)\n                if (n % i == 0) {\n                    divisors.add(i);\n                    if (i * i < n)\n                        large.add(n / i);\n                }\n            for (int p = large.size() - 1; p >= 0; p--) {\n                divisors.add(large.get(p));\n            }\n            return divisors;\n        }\n    }\n\n    static class Multiset<T> extends java.util.TreeMap<T, Long> {\n        public Multiset() {\n            super();\n        }\n\n        public Multiset(java.util.List<T> list) {\n            super();\n            for (T e : list)\n                this.addOne(e);\n        }\n\n        public long count(Object elm) {\n            return getOrDefault(elm, 0L);\n        }\n\n        public void add(T elm, long amount) {\n            if (!this.containsKey(elm))\n                put(elm, amount);\n            else\n                replace(elm, get(elm) + amount);\n            if (this.count(elm) == 0)\n                this.remove(elm);\n        }\n\n        public void addOne(T elm) {\n            this.add(elm, 1);\n        }\n\n        public void removeOne(T elm) {\n            this.add(elm, -1);\n        }\n\n        public void removeAll(T elm) {\n            this.add(elm, -this.count(elm));\n        }\n\n        public static <T> Multiset<T> merge(Multiset<T> a, Multiset<T> b) {\n            Multiset<T> c = new Multiset<>();\n            for (T x : a.keySet())\n                c.add(x, a.count(x));\n            for (T y : b.keySet())\n                c.add(y, b.count(y));\n            return c;\n        }\n    }\n\n    static class GraphBuilder {\n        public static int[][] makeGraph(int NumberOfNodes, int NumberOfEdges, int[] from, int[] to,\n                boolean undirected) {\n            int[][] graph = new int[NumberOfNodes][];\n            int[] outdegree = new int[NumberOfNodes];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                outdegree[from[i]]++;\n                if (undirected)\n                    outdegree[to[i]]++;\n            }\n            for (int i = 0; i < NumberOfNodes; i++)\n                graph[i] = new int[outdegree[i]];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                graph[from[i]][--outdegree[from[i]]] = to[i];\n                if (undirected)\n                    graph[to[i]][--outdegree[to[i]]] = from[i];\n            }\n            return graph;\n        }\n\n        public static int[][][] makeGraphWithWeight(int NumberOfNodes, int NumberOfEdges, int[] from, int[] to,\n                int[] weight, boolean undirected) {\n            int[][][] graph = new int[NumberOfNodes][][];\n            int[] outdegree = new int[NumberOfNodes];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                outdegree[from[i]]++;\n                if (undirected)\n                    outdegree[to[i]]++;\n            }\n            for (int i = 0; i < NumberOfNodes; i++)\n                graph[i] = new int[outdegree[i]][];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                graph[from[i]][--outdegree[from[i]]] = new int[] { to[i], weight[i] };\n                if (undirected)\n                    graph[to[i]][--outdegree[to[i]]] = new int[] { from[i], weight[i] };\n            }\n            return graph;\n        }\n\n        public static int[][][] makeGraphWithEdgeInfo(int NumberOfNodes, int NumberOfEdges, int[] from, int[] to,\n                boolean undirected) {\n            int[][][] graph = new int[NumberOfNodes][][];\n            int[] outdegree = new int[NumberOfNodes];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                outdegree[from[i]]++;\n                if (undirected)\n                    outdegree[to[i]]++;\n            }\n            for (int i = 0; i < NumberOfNodes; i++)\n                graph[i] = new int[outdegree[i]][];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                graph[from[i]][--outdegree[from[i]]] = new int[] { to[i], i, 0 };\n                if (undirected)\n                    graph[to[i]][--outdegree[to[i]]] = new int[] { from[i], i, 1 };\n            }\n            return graph;\n        }\n\n        public static int[][][] makeGraphWithWeightAndEdgeInfo(int NumberOfNodes, int NumberOfEdges, int[] from,\n                int[] to, int[] weight, boolean undirected) {\n            int[][][] graph = new int[NumberOfNodes][][];\n            int[] outdegree = new int[NumberOfNodes];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                outdegree[from[i]]++;\n                if (undirected)\n                    outdegree[to[i]]++;\n            }\n            for (int i = 0; i < NumberOfNodes; i++)\n                graph[i] = new int[outdegree[i]][];\n            for (int i = 0; i < NumberOfEdges; i++) {\n                graph[from[i]][--outdegree[from[i]]] = new int[] { to[i], weight[i], i, 0 };\n                if (undirected)\n                    graph[to[i]][--outdegree[to[i]]] = new int[] { from[i], weight[i], i, 1 };\n            }\n            return graph;\n        }\n    }\n\n    static class DSU {\n        private int n;\n        private int[] parentOrSize;\n\n        public DSU(int n) {\n            this.n = n;\n            this.parentOrSize = new int[n];\n            java.util.Arrays.fill(parentOrSize, -1);\n        }\n\n        int merge(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n\n            int x = leader(a);\n            int y = leader(b);\n            if (x == y)\n                return x;\n            if (-parentOrSize[x] < -parentOrSize[y]) {\n                int tmp = x;\n                x = y;\n                y = tmp;\n            }\n            parentOrSize[x] += parentOrSize[y];\n            parentOrSize[y] = x;\n            return x;\n        }\n\n        boolean same(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n            return leader(a) == leader(b);\n        }\n\n        int leader(int a) {\n            if (parentOrSize[a] < 0) {\n                return a;\n            } else {\n                parentOrSize[a] = leader(parentOrSize[a]);\n                return parentOrSize[a];\n            }\n        }\n\n        int size(int a) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"\" + a);\n            return -parentOrSize[leader(a)];\n        }\n\n        java.util.ArrayList<java.util.ArrayList<Integer>> groups() {\n            int[] leaderBuf = new int[n];\n            int[] groupSize = new int[n];\n            for (int i = 0; i < n; i++) {\n                leaderBuf[i] = leader(i);\n                groupSize[leaderBuf[i]]++;\n            }\n            java.util.ArrayList<java.util.ArrayList<Integer>> result = new java.util.ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                result.add(new java.util.ArrayList<>(groupSize[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                result.get(leaderBuf[i]).add(i);\n            }\n            result.removeIf(java.util.ArrayList::isEmpty);\n            return result;\n        }\n    }\n\n    static class ModIntFactory {\n        private final ModArithmetic ma;\n        private final int mod;\n\n        private final boolean usesMontgomery;\n        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;\n\n        private ArrayList<Integer> factorial;\n        private ArrayList<Integer> factorial_inversion;\n\n        public ModIntFactory(int mod) {\n            this.ma = ModArithmetic.of(mod);\n            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;\n            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;\n            this.mod = mod;\n\n            this.factorial = new ArrayList<>();\n            this.factorial_inversion = new ArrayList<>();\n        }\n\n        public ModInt create(long value) {\n            if ((value %= mod) < 0)\n                value += mod;\n            if (usesMontgomery) {\n                return new ModInt(maMontgomery.generate(value));\n            } else {\n                return new ModInt((int) value);\n            }\n        }\n\n        private void prepareFactorial(int max) {\n            factorial.ensureCapacity(max + 1);\n            if (factorial.size() == 0)\n                factorial.add(1);\n            for (int i = factorial.size(); i <= max; i++) {\n                factorial.add(ma.mul(factorial.get(i - 1), i));\n            }\n        }\n\n        public ModInt factorial(int i) {\n            prepareFactorial(i);\n            return create(factorial.get(i));\n        }\n\n        public ModInt permutation(int n, int r) {\n            if (n < 0 || r < 0 || n < r)\n                return create(0);\n            prepareFactorial(n);\n            if (factorial_inversion.size() > n) {\n                return create(ma.mul(factorial.get(n), factorial_inversion.get(n - r)));\n            }\n            return create(ma.div(factorial.get(n), factorial.get(n - r)));\n        }\n\n        public ModInt combination(int n, int r) {\n            if (n < 0 || r < 0 || n < r)\n                return create(0);\n            prepareFactorial(n);\n            if (factorial_inversion.size() > n) {\n                return create(\n                        ma.mul(factorial.get(n), ma.mul(factorial_inversion.get(n - r), factorial_inversion.get(r))));\n            }\n            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r), factorial.get(n - r))));\n        }\n\n        public void prepareFactorialInv(int max) {\n            prepareFactorial(max);\n            factorial_inversion.ensureCapacity(max + 1);\n            for (int i = factorial_inversion.size(); i <= max; i++) {\n                factorial_inversion.add(ma.inv(factorial.get(i)));\n            }\n        }\n\n        public int getMod() {\n            return mod;\n        }\n\n        public class ModInt {\n            private int value;\n\n            private ModInt(int value) {\n                this.value = value;\n            }\n\n            public int mod() {\n                return mod;\n            }\n\n            public int value() {\n                if (ma instanceof ModArithmetic.ModArithmeticMontgomery) {\n                    return ((ModArithmetic.ModArithmeticMontgomery) ma).reduce(value);\n                }\n                return value;\n            }\n\n            public ModInt add(ModInt mi) {\n                return new ModInt(ma.add(value, mi.value));\n            }\n\n            public ModInt add(ModInt mi1, ModInt mi2) {\n                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);\n            }\n\n            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {\n                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);\n            }\n\n            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);\n            }\n\n            public ModInt add(ModInt mi1, ModInt... mis) {\n                ModInt mi = add(mi1);\n                for (ModInt m : mis)\n                    mi.addAsg(m);\n                return mi;\n            }\n\n            public ModInt add(long mi) {\n                return new ModInt(ma.add(value, ma.remainder(mi)));\n            }\n\n            public ModInt sub(ModInt mi) {\n                return new ModInt(ma.sub(value, mi.value));\n            }\n\n            public ModInt sub(long mi) {\n                return new ModInt(ma.sub(value, ma.remainder(mi)));\n            }\n\n            public ModInt mul(ModInt mi) {\n                return new ModInt(ma.mul(value, mi.value));\n            }\n\n            public ModInt mul(ModInt mi1, ModInt mi2) {\n                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);\n            }\n\n            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {\n                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);\n            }\n\n            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);\n            }\n\n            public ModInt mul(ModInt mi1, ModInt... mis) {\n                ModInt mi = mul(mi1);\n                for (ModInt m : mis)\n                    mi.mulAsg(m);\n                return mi;\n            }\n\n            public ModInt mul(long mi) {\n                return new ModInt(ma.mul(value, ma.remainder(mi)));\n            }\n\n            public ModInt div(ModInt mi) {\n                return new ModInt(ma.div(value, mi.value));\n            }\n\n            public ModInt div(long mi) {\n                return new ModInt(ma.div(value, ma.remainder(mi)));\n            }\n\n            public ModInt inv() {\n                return new ModInt(ma.inv(value));\n            }\n\n            public ModInt pow(long b) {\n                return new ModInt(ma.pow(value, b));\n            }\n\n            public ModInt addAsg(ModInt mi) {\n                this.value = ma.add(value, mi.value);\n                return this;\n            }\n\n            public ModInt addAsg(ModInt mi1, ModInt mi2) {\n                return addAsg(mi1).addAsg(mi2);\n            }\n\n            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {\n                return addAsg(mi1).addAsg(mi2).addAsg(mi3);\n            }\n\n            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);\n            }\n\n            public ModInt addAsg(ModInt... mis) {\n                for (ModInt m : mis)\n                    addAsg(m);\n                return this;\n            }\n\n            public ModInt addAsg(long mi) {\n                this.value = ma.add(value, ma.remainder(mi));\n                return this;\n            }\n\n            public ModInt subAsg(ModInt mi) {\n                this.value = ma.sub(value, mi.value);\n                return this;\n            }\n\n            public ModInt subAsg(long mi) {\n                this.value = ma.sub(value, ma.remainder(mi));\n                return this;\n            }\n\n            public ModInt mulAsg(ModInt mi) {\n                this.value = ma.mul(value, mi.value);\n                return this;\n            }\n\n            public ModInt mulAsg(ModInt mi1, ModInt mi2) {\n                return mulAsg(mi1).mulAsg(mi2);\n            }\n\n            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {\n                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);\n            }\n\n            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);\n            }\n\n            public ModInt mulAsg(ModInt... mis) {\n                for (ModInt m : mis)\n                    mulAsg(m);\n                return this;\n            }\n\n            public ModInt mulAsg(long mi) {\n                this.value = ma.mul(value, ma.remainder(mi));\n                return this;\n            }\n\n            public ModInt divAsg(ModInt mi) {\n                this.value = ma.div(value, mi.value);\n                return this;\n            }\n\n            public ModInt divAsg(long mi) {\n                this.value = ma.div(value, ma.remainder(mi));\n                return this;\n            }\n\n            @Override\n            public String toString() {\n                return String.valueOf(value());\n            }\n\n            @Override\n            public boolean equals(Object o) {\n                if (o instanceof ModInt) {\n                    ModInt mi = (ModInt) o;\n                    return mod() == mi.mod() && value() == mi.value();\n                }\n                return false;\n            }\n\n            @Override\n            public int hashCode() {\n                return (1 * 37 + mod()) * 37 + value();\n            }\n        }\n\n        private static abstract class ModArithmetic {\n            abstract int mod();\n\n            abstract int remainder(long value);\n\n            abstract int add(int a, int b);\n\n            abstract int sub(int a, int b);\n\n            abstract int mul(int a, int b);\n\n            int div(int a, int b) {\n                return mul(a, inv(b));\n            }\n\n            int inv(int a) {\n                int b = mod();\n                if (b == 1)\n                    return 0;\n                long u = 1, v = 0;\n                while (b >= 1) {\n                    int t = a / b;\n                    a -= t * b;\n                    int tmp1 = a;\n                    a = b;\n                    b = tmp1;\n                    u -= t * v;\n                    long tmp2 = u;\n                    u = v;\n                    v = tmp2;\n                }\n                if (a != 1) {\n                    throw new ArithmeticException(\"divide by zero\");\n                }\n                return remainder(u);\n            }\n\n            int pow(int a, long b) {\n                if (b < 0)\n                    throw new ArithmeticException(\"negative power\");\n                int r = 1;\n                int x = a;\n                while (b > 0) {\n                    if ((b & 1) == 1)\n                        r = mul(r, x);\n                    x = mul(x, x);\n                    b >>= 1;\n                }\n                return r;\n            }\n\n            static ModArithmetic of(int mod) {\n                if (mod <= 0) {\n                    throw new IllegalArgumentException();\n                } else if (mod == 1) {\n                    return new ModArithmetic1();\n                } else if (mod == 2) {\n                    return new ModArithmetic2();\n                } else if (mod == 998244353) {\n                    return new ModArithmetic998244353();\n                } else if (mod == 1000000007) {\n                    return new ModArithmetic1000000007();\n                } else if ((mod & 1) == 1) {\n                    return new ModArithmeticMontgomery(mod);\n                } else {\n                    return new ModArithmeticBarrett(mod);\n                }\n            }\n\n            private static final class ModArithmetic1 extends ModArithmetic {\n                int mod() {\n                    return 1;\n                }\n\n                int remainder(long value) {\n                    return 0;\n                }\n\n                int add(int a, int b) {\n                    return 0;\n                }\n\n                int sub(int a, int b) {\n                    return 0;\n                }\n\n                int mul(int a, int b) {\n                    return 0;\n                }\n\n                int pow(int a, long b) {\n                    return 0;\n                }\n            }\n\n            private static final class ModArithmetic2 extends ModArithmetic {\n                int mod() {\n                    return 2;\n                }\n\n                int remainder(long value) {\n                    return (int) (value & 1);\n                }\n\n                int add(int a, int b) {\n                    return a ^ b;\n                }\n\n                int sub(int a, int b) {\n                    return a ^ b;\n                }\n\n                int mul(int a, int b) {\n                    return a & b;\n                }\n            }\n\n            private static final class ModArithmetic998244353 extends ModArithmetic {\n                private final int mod = 998244353;\n\n                int mod() {\n                    return mod;\n                }\n\n                int remainder(long value) {\n                    return (int) ((value %= mod) < 0 ? value + mod : value);\n                }\n\n                int add(int a, int b) {\n                    int res = a + b;\n                    return res >= mod ? res - mod : res;\n                }\n\n                int sub(int a, int b) {\n                    int res = a - b;\n                    return res < 0 ? res + mod : res;\n                }\n\n                int mul(int a, int b) {\n                    return (int) (((long) a * b) % mod);\n                }\n            }\n\n            private static final class ModArithmetic1000000007 extends ModArithmetic {\n                private final int mod = 1000000007;\n\n                int mod() {\n                    return mod;\n                }\n\n                int remainder(long value) {\n                    return (int) ((value %= mod) < 0 ? value + mod : value);\n                }\n\n                int add(int a, int b) {\n                    int res = a + b;\n                    return res >= mod ? res - mod : res;\n                }\n\n                int sub(int a, int b) {\n                    int res = a - b;\n                    return res < 0 ? res + mod : res;\n                }\n\n                int mul(int a, int b) {\n                    return (int) (((long) a * b) % mod);\n                }\n            }\n\n            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {\n                private final long negInv;\n                private final long r2;\n\n                private ModArithmeticMontgomery(int mod) {\n                    super(mod);\n                    long inv = 0;\n                    long s = 1, t = 0;\n                    for (int i = 0; i < 32; i++) {\n                        if ((t & 1) == 0) {\n                            t += mod;\n                            inv += s;\n                        }\n                        t >>= 1;\n                        s <<= 1;\n                    }\n                    long r = (1l << 32) % mod;\n                    this.negInv = inv;\n                    this.r2 = (r * r) % mod;\n                }\n\n                private int generate(long x) {\n                    return reduce(x * r2);\n                }\n\n                private int reduce(long x) {\n                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;\n                    return (int) (x < mod ? x : x - mod);\n                }\n\n                @Override\n                int remainder(long value) {\n                    return generate((value %= mod) < 0 ? value + mod : value);\n                }\n\n                @Override\n                int mul(int a, int b) {\n                    return reduce((long) a * b);\n                }\n\n                @Override\n                int inv(int a) {\n                    return super.inv(reduce(a));\n                }\n\n                @Override\n                int pow(int a, long b) {\n                    return generate(super.pow(a, b));\n                }\n            }\n\n            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {\n                private static final long mask = 0xffff_ffffl;\n                private final long mh;\n                private final long ml;\n\n                private ModArithmeticBarrett(int mod) {\n                    super(mod);\n                    /**\n                     * m = floor(2^64/mod) 2^64 = p*mod + q, 2^32 = a*mod + b => (a*mod + b)^2 =\n                     * p*mod + q => p = mod*a^2 + 2ab + floor(b^2/mod)\n                     */\n                    long a = (1l << 32) / mod;\n                    long b = (1l << 32) % mod;\n                    long m = a * a * mod + 2 * a * b + (b * b) / mod;\n                    mh = m >>> 32;\n                    ml = m & mask;\n                }\n\n                private int reduce(long x) {\n                    long z = (x & mask) * ml;\n                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);\n                    z = (x >>> 32) * mh + (z >>> 32);\n                    x -= z * mod;\n                    return (int) (x < mod ? x : x - mod);\n                }\n\n                @Override\n                int remainder(long value) {\n                    return (int) ((value %= mod) < 0 ? value + mod : value);\n                }\n\n                @Override\n                int mul(int a, int b) {\n                    return reduce((long) a * b);\n                }\n            }\n\n            private static class ModArithmeticDynamic extends ModArithmetic {\n                final int mod;\n\n                ModArithmeticDynamic(int mod) {\n                    this.mod = mod;\n                }\n\n                int mod() {\n                    return mod;\n                }\n\n                int remainder(long value) {\n                    return (int) ((value %= mod) < 0 ? value + mod : value);\n                }\n\n                int add(int a, int b) {\n                    int sum = a + b;\n                    return sum >= mod ? sum - mod : sum;\n                }\n\n                int sub(int a, int b) {\n                    int sum = a - b;\n                    return sum < 0 ? sum + mod : sum;\n                }\n\n                int mul(int a, int b) {\n                    return (int) (((long) a * b) % mod);\n                }\n            }\n        }\n    }\n\n    static class Convolution {\n        /**\n         * Find a primitive root.\n         *\n         * @param m A prime number.\n         * @return Primitive root.\n         */\n        private static int primitiveRoot(int m) {\n            if (m == 2)\n                return 1;\n            if (m == 167772161)\n                return 3;\n            if (m == 469762049)\n                return 3;\n            if (m == 754974721)\n                return 11;\n            if (m == 998244353)\n                return 3;\n\n            int[] divs = new int[20];\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0)\n                x /= 2;\n            for (int i = 3; (long) (i) * i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                boolean ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok)\n                    return g;\n            }\n        }\n\n        /**\n         * Power.\n         *\n         * @param x Parameter x.\n         * @param n Parameter n.\n         * @param m Mod.\n         * @return n-th power of x mod m.\n         */\n        private static long pow(long x, long n, int m) {\n            if (m == 1)\n                return 0;\n            long r = 1;\n            long y = x % m;\n            while (n > 0) {\n                if ((n & 1) != 0)\n                    r = (r * y) % m;\n                y = (y * y) % m;\n                n >>= 1;\n            }\n            return r;\n        }\n\n        /**\n         * Ceil of power 2.\n         *\n         * @param n Value.\n         * @return Ceil of power 2.\n         */\n        private static int ceilPow2(int n) {\n            int x = 0;\n            while ((1L << x) < n)\n                x++;\n            return x;\n        }\n\n        /**\n         * Garner's algorithm.\n         *\n         * @param c    Mod convolution results.\n         * @param mods Mods.\n         * @return Result.\n         */\n        private static long garner(long[] c, int[] mods) {\n            int n = c.length + 1;\n            long[] cnst = new long[n];\n            long[] coef = new long[n];\n            java.util.Arrays.fill(coef, 1);\n            for (int i = 0; i < n - 1; i++) {\n                int m1 = mods[i];\n                long v = (c[i] - cnst[i] + m1) % m1;\n                v = v * pow(coef[i], m1 - 2, m1) % m1;\n\n                for (int j = i + 1; j < n; j++) {\n                    long m2 = mods[j];\n                    cnst[j] = (cnst[j] + coef[j] * v) % m2;\n                    coef[j] = (coef[j] * m1) % m2;\n                }\n            }\n            return cnst[n - 1];\n        }\n\n        /**\n         * Pre-calculation for NTT.\n         *\n         * @param mod NTT Prime.\n         * @param g   Primitive root of mod.\n         * @return Pre-calculation table.\n         */\n        private static long[] sumE(int mod, int g) {\n            long[] sum_e = new long[30];\n            long[] es = new long[30];\n            long[] ies = new long[30];\n            int cnt2 = Integer.numberOfTrailingZeros(mod - 1);\n            long e = pow(g, (mod - 1) >> cnt2, mod);\n            long ie = pow(e, mod - 2, mod);\n            for (int i = cnt2; i >= 2; i--) {\n                es[i - 2] = e;\n                ies[i - 2] = ie;\n                e = e * e % mod;\n                ie = ie * ie % mod;\n            }\n            long now = 1;\n            for (int i = 0; i < cnt2 - 2; i++) {\n                sum_e[i] = es[i] * now % mod;\n                now = now * ies[i] % mod;\n            }\n            return sum_e;\n        }\n\n        /**\n         * Pre-calculation for inverse NTT.\n         *\n         * @param mod Mod.\n         * @param g   Primitive root of mod.\n         * @return Pre-calculation table.\n         */\n        private static long[] sumIE(int mod, int g) {\n            long[] sum_ie = new long[30];\n            long[] es = new long[30];\n            long[] ies = new long[30];\n\n            int cnt2 = Integer.numberOfTrailingZeros(mod - 1);\n            long e = pow(g, (mod - 1) >> cnt2, mod);\n            long ie = pow(e, mod - 2, mod);\n            for (int i = cnt2; i >= 2; i--) {\n                es[i - 2] = e;\n                ies[i - 2] = ie;\n                e = e * e % mod;\n                ie = ie * ie % mod;\n            }\n            long now = 1;\n            for (int i = 0; i < cnt2 - 2; i++) {\n                sum_ie[i] = ies[i] * now % mod;\n                now = now * es[i] % mod;\n            }\n            return sum_ie;\n        }\n\n        /**\n         * Inverse NTT.\n         *\n         * @param a     Target array.\n         * @param sumIE Pre-calculation table.\n         * @param mod   NTT Prime.\n         */\n        private static void butterflyInv(long[] a, long[] sumIE, int mod) {\n            int n = a.length;\n            int h = ceilPow2(n);\n\n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                long inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        long l = a[i + offset];\n                        long r = a[i + offset + p];\n                        a[i + offset] = (l + r) % mod;\n                        a[i + offset + p] = (mod + l - r) * inow % mod;\n                    }\n                    int x = Integer.numberOfTrailingZeros(~s);\n                    inow = inow * sumIE[x] % mod;\n                }\n            }\n        }\n\n        /**\n         * Inverse NTT.\n         *\n         * @param a    Target array.\n         * @param sumE Pre-calculation table.\n         * @param mod  NTT Prime.\n         */\n        private static void butterfly(long[] a, long[] sumE, int mod) {\n            int n = a.length;\n            int h = ceilPow2(n);\n\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                long now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        long l = a[i + offset];\n                        long r = a[i + offset + p] * now % mod;\n                        a[i + offset] = (l + r) % mod;\n                        a[i + offset + p] = (l - r + mod) % mod;\n                    }\n                    int x = Integer.numberOfTrailingZeros(~s);\n                    now = now * sumE[x] % mod;\n                }\n            }\n        }\n\n        /**\n         * Convolution.\n         *\n         * @param a   Target array 1.\n         * @param b   Target array 2.\n         * @param mod NTT Prime.\n         * @return Answer.\n         */\n        public static long[] convolution(long[] a, long[] b, int mod) {\n            int n = a.length;\n            int m = b.length;\n            if (n == 0 || m == 0)\n                return new long[0];\n\n            int z = 1 << ceilPow2(n + m - 1);\n            {\n                long[] na = new long[z];\n                long[] nb = new long[z];\n                System.arraycopy(a, 0, na, 0, n);\n                System.arraycopy(b, 0, nb, 0, m);\n                a = na;\n                b = nb;\n            }\n\n            int g = primitiveRoot(mod);\n            long[] sume = sumE(mod, g);\n            long[] sumie = sumIE(mod, g);\n\n            butterfly(a, sume, mod);\n            butterfly(b, sume, mod);\n            for (int i = 0; i < z; i++) {\n                a[i] = a[i] * b[i] % mod;\n            }\n            butterflyInv(a, sumie, mod);\n            a = java.util.Arrays.copyOf(a, n + m - 1);\n\n            long iz = pow(z, mod - 2, mod);\n            for (int i = 0; i < n + m - 1; i++)\n                a[i] = a[i] * iz % mod;\n            return a;\n        }\n\n        /**\n         * Convolution.\n         *\n         * @param a   Target array 1.\n         * @param b   Target array 2.\n         * @param mod Any mod.\n         * @return Answer.\n         */\n        public static long[] convolutionLL(long[] a, long[] b, int mod) {\n            int n = a.length;\n            int m = b.length;\n            if (n == 0 || m == 0)\n                return new long[0];\n\n            int mod1 = 754974721;\n            int mod2 = 167772161;\n            int mod3 = 469762049;\n\n            long[] c1 = convolution(a, b, mod1);\n            long[] c2 = convolution(a, b, mod2);\n            long[] c3 = convolution(a, b, mod3);\n\n            int retSize = c1.length;\n            long[] ret = new long[retSize];\n            int[] mods = { mod1, mod2, mod3, mod };\n            for (int i = 0; i < retSize; ++i) {\n                ret[i] = garner(new long[] { c1[i], c2[i], c3[i] }, mods);\n            }\n            return ret;\n        }\n\n        /**\n         * Convolution by ModInt.\n         *\n         * @param a Target array 1.\n         * @param b Target array 2.\n         * @return Answer.\n         */\n        public static java.util.List<ModIntFactory.ModInt> convolution(java.util.List<ModIntFactory.ModInt> a,\n                java.util.List<ModIntFactory.ModInt> b) {\n            int mod = a.get(0).mod();\n            long[] va = a.stream().mapToLong(ModIntFactory.ModInt::value).toArray();\n            long[] vb = b.stream().mapToLong(ModIntFactory.ModInt::value).toArray();\n            long[] c = convolutionLL(va, vb, mod);\n\n            ModIntFactory factory = new ModIntFactory(mod);\n            return java.util.Arrays.stream(c).mapToObj(factory::create).collect(java.util.stream.Collectors.toList());\n        }\n\n        /**\n         * Naive convolution. (Complexity is O(N^2)!!)\n         *\n         * @param a   Target array 1.\n         * @param b   Target array 2.\n         * @param mod Mod.\n         * @return Answer.\n         */\n        public static long[] convolutionNaive(long[] a, long[] b, int mod) {\n            int n = a.length;\n            int m = b.length;\n            int k = n + m - 1;\n            long[] ret = new long[k];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i + j] += a[i] * b[j] % mod;\n                    ret[i + j] %= mod;\n                }\n            }\n            return ret;\n        }\n    }\n\n    static class ContestScanner {\n        private final java.io.InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private static final long LONG_MAX_TENTHS = 922337203685477580L;\n        private static final int LONG_MAX_LAST_DIGIT = 7;\n        private static final int LONG_MIN_LAST_DIGIT = 8;\n\n        public ContestScanner(java.io.InputStream in) {\n            this.in = in;\n        }\n\n        public ContestScanner() {\n            this(System.in);\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (java.io.IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte())\n                return buffer[ptr++];\n            else\n                return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n                ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext())\n                throw new java.util.NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext())\n                throw new java.util.NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    int digit = b - '0';\n                    if (n >= LONG_MAX_TENTHS) {\n                        if (n == LONG_MAX_TENTHS) {\n                            if (minus) {\n                                if (digit <= LONG_MIN_LAST_DIGIT) {\n                                    n = -n * 10 - digit;\n                                    b = readByte();\n                                    if (!isPrintableChar(b)) {\n                                        return n;\n                                    } else if (b < '0' || '9' < b) {\n                                        throw new NumberFormatException(\n                                                String.format(\"%d%s... is not number\", n, Character.toString(b)));\n                                    }\n                                }\n                            } else {\n                                if (digit <= LONG_MAX_LAST_DIGIT) {\n                                    n = n * 10 + digit;\n                                    b = readByte();\n                                    if (!isPrintableChar(b)) {\n                                        return n;\n                                    } else if (b < '0' || '9' < b) {\n                                        throw new NumberFormatException(\n                                                String.format(\"%d%s... is not number\", n, Character.toString(b)));\n                                    }\n                                }\n                            }\n                        }\n                        throw new ArithmeticException(\n                                String.format(\"%s%d%d... overflows long.\", minus ? \"-\" : \"\", n, digit));\n                    }\n                    n = n * 10 + digit;\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n                throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long[] nextLongArray(int length) {\n            long[] array = new long[length];\n            for (int i = 0; i < length; i++)\n                array[i] = this.nextLong();\n            return array;\n        }\n\n        public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map) {\n            long[] array = new long[length];\n            for (int i = 0; i < length; i++)\n                array[i] = map.applyAsLong(this.nextLong());\n            return array;\n        }\n\n        public int[] nextIntArray(int length) {\n            int[] array = new int[length];\n            for (int i = 0; i < length; i++)\n                array[i] = this.nextInt();\n            return array;\n        }\n\n        public int[][] nextIntArrayMulti(int length, int width) {\n            int[][] arrays = new int[width][length];\n            for (int i = 0; i < length; i++) {\n                for (int j = 0; j < width; j++)\n                    arrays[j][i] = this.nextInt();\n            }\n            return arrays;\n        }\n\n        public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map) {\n            int[] array = new int[length];\n            for (int i = 0; i < length; i++)\n                array[i] = map.applyAsInt(this.nextInt());\n            return array;\n        }\n\n        public double[] nextDoubleArray(int length) {\n            double[] array = new double[length];\n            for (int i = 0; i < length; i++)\n                array[i] = this.nextDouble();\n            return array;\n        }\n\n        public double[] nextDoubleArray(int length, java.util.function.DoubleUnaryOperator map) {\n            double[] array = new double[length];\n            for (int i = 0; i < length; i++)\n                array[i] = map.applyAsDouble(this.nextDouble());\n            return array;\n        }\n\n        public long[][] nextLongMatrix(int height, int width) {\n            long[][] mat = new long[height][width];\n            for (int h = 0; h < height; h++)\n                for (int w = 0; w < width; w++) {\n                    mat[h][w] = this.nextLong();\n                }\n            return mat;\n        }\n\n        public int[][] nextIntMatrix(int height, int width) {\n            int[][] mat = new int[height][width];\n            for (int h = 0; h < height; h++)\n                for (int w = 0; w < width; w++) {\n                    mat[h][w] = this.nextInt();\n                }\n            return mat;\n        }\n\n        public double[][] nextDoubleMatrix(int height, int width) {\n            double[][] mat = new double[height][width];\n            for (int h = 0; h < height; h++)\n                for (int w = 0; w < width; w++) {\n                    mat[h][w] = this.nextDouble();\n                }\n            return mat;\n        }\n\n        public char[][] nextCharMatrix(int height, int width) {\n            char[][] mat = new char[height][width];\n            for (int h = 0; h < height; h++) {\n                String s = this.next();\n                for (int w = 0; w < width; w++) {\n                    mat[h][w] = s.charAt(w);\n                }\n            }\n            return mat;\n        }\n    }\n\n    static class ContestPrinter extends java.io.PrintWriter {\n        public ContestPrinter(java.io.PrintStream stream) {\n            super(stream);\n        }\n\n        public ContestPrinter() {\n            super(System.out);\n        }\n\n        private static String dtos(double x, int n) {\n            StringBuilder sb = new StringBuilder();\n            if (x < 0) {\n                sb.append('-');\n                x = -x;\n            }\n            x += Math.pow(10, -n) / 2;\n            sb.append((long) x);\n            sb.append(\".\");\n            x -= (long) x;\n            for (int i = 0; i < n; i++) {\n                x *= 10;\n                sb.append((int) x);\n                x -= (int) x;\n            }\n            return sb.toString();\n        }\n\n        @Override\n        public void print(float f) {\n            super.print(dtos(f, 20));\n        }\n\n        @Override\n        public void println(float f) {\n            super.println(dtos(f, 20));\n        }\n\n        @Override\n        public void print(double d) {\n            super.print(dtos(d, 20));\n        }\n\n        @Override\n        public void println(double d) {\n            super.println(dtos(d, 20));\n        }\n\n        public void printArray(int[] array, String separator) {\n            int n = array.length;\n            for (int i = 0; i < n - 1; i++) {\n                super.print(array[i]);\n                super.print(separator);\n            }\n            super.println(array[n - 1]);\n        }\n\n        public void printArray(int[] array) {\n            this.printArray(array, \" \");\n        }\n\n        public void printArray(int[] array, String separator, java.util.function.IntUnaryOperator map) {\n            int n = array.length;\n            for (int i = 0; i < n - 1; i++) {\n                super.print(map.applyAsInt(array[i]));\n                super.print(separator);\n            }\n            super.println(map.applyAsInt(array[n - 1]));\n        }\n\n        public void printArray(int[] array, java.util.function.IntUnaryOperator map) {\n            this.printArray(array, \" \", map);\n        }\n\n        public void printArray(long[] array, String separator) {\n            int n = array.length;\n            for (int i = 0; i < n - 1; i++) {\n                super.print(array[i]);\n                super.print(separator);\n            }\n            super.println(array[n - 1]);\n        }\n\n        public void printArray(long[] array) {\n            this.printArray(array, \" \");\n        }\n\n        public void printArray(long[] array, String separator, java.util.function.LongUnaryOperator map) {\n            int n = array.length;\n            for (int i = 0; i < n - 1; i++) {\n                super.print(map.applyAsLong(array[i]));\n                super.print(separator);\n            }\n            super.println(map.applyAsLong(array[n - 1]));\n        }\n\n        public void printArray(long[] array, java.util.function.LongUnaryOperator map) {\n            this.printArray(array, \" \", map);\n        }\n\n    }\n\n    public static void safeSort(int[] array) {\n        Integer[] temp = new Integer[array.length];\n        for (int n = 0; n < array.length; n++) {\n            temp[n] = array[n];\n        }\n        Arrays.sort(temp);\n        for (int n = 0; n < array.length; n++) {\n            array[n] = temp[n];\n        }\n    }\n\n    public static void safeSort(long[] array) {\n        Long[] temp = new Long[array.length];\n        for (int n = 0; n < array.length; n++) {\n            temp[n] = array[n];\n        }\n        Arrays.sort(temp);\n        for (int n = 0; n < array.length; n++) {\n            array[n] = temp[n];\n        }\n    }\n\n    public static void safeSort(double[] array) {\n        Double[] temp = new Double[array.length];\n        for (int n = 0; n < array.length; n++) {\n            temp[n] = array[n];\n        }\n        Arrays.sort(temp);\n        for (int n = 0; n < array.length; n++) {\n            array[n] = temp[n];\n        }\n    }\n\n}\n"
}