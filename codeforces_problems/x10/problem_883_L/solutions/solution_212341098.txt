{
    "id": 212341098,
    "contestId": 883,
    "creationTimeSeconds": 1688638557,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 883,
        "index": "L",
        "name": "Berland.Taxi",
        "type": "PROGRAMMING",
        "rating": 2500,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 883,
        "members": [
            {
                "handle": "cpchenpi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1508573100
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "// const INF: usize = 100_0000_0000_0000_0000;\r\n\r\nuse std::{\r\n    cmp::Reverse,\r\n    collections::{BTreeMap, BinaryHeap},\r\n};\r\n\r\nfn main() {\r\n    // --------------------- init -----------------\r\n    prelude!(scanner, _out);\r\n    #[allow(unused_macros)]\r\n    macro_rules! outln {($($format:tt)*) => { let _ = writeln!(_out, $($format)*);};}\r\n    #[allow(unused_macros)]\r\n    macro_rules! out {($($format:tt)*) => (let _ = write!(_out, $($format)*););}\r\n    // --------------------- init -----------------\r\n    // let t: usize = scanner.next();\r\n    let t = 1;\r\n    for _ in 0..t {\r\n        let _n: usize = scanner.next();\r\n        let k: usize = scanner.next();\r\n        let q: usize = scanner.next();\r\n        let mut now_time = 0;\r\n        let mut event = BinaryHeap::<Reverse<(usize, usize, usize)>>::new();\r\n        // (time, id, pos)\r\n        let mut cars = BTreeMap::<usize, BinaryHeap<Reverse<(usize, usize)>>>::new();\r\n        // (pos, (avail_time, id))\r\n        for i in 1..=k {\r\n            let pos: usize = scanner.next();\r\n            if !cars.contains_key(&pos) {\r\n                cars.insert(pos, BinaryHeap::new());\r\n            }\r\n            cars.get_mut(&pos).unwrap().push(Reverse((0, i)));\r\n        }\r\n        for _ in 0..q {\r\n            let ot = scanner.next::<usize>();\r\n            let mut bind_time: usize = ot.max(now_time);\r\n            let a: usize = scanner.next();\r\n            let b: usize = scanner.next();\r\n            while let Some(&Reverse((time, id, pos))) = event.peek() {\r\n                if time <= bind_time {\r\n                    event.pop();\r\n                    if !cars.contains_key(&pos) {\r\n                        cars.insert(pos, BinaryHeap::new());\r\n                    }\r\n                    cars.get_mut(&pos).unwrap().push(Reverse((time, id)));\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if cars.is_empty() {\r\n                if let Some(Reverse((time, id, pos))) = event.pop() {\r\n                    bind_time = time;\r\n                    if !cars.contains_key(&pos) {\r\n                        cars.insert(pos, BinaryHeap::new());\r\n                    }\r\n                    cars.get_mut(&pos).unwrap().push(Reverse((time, id)));\r\n                } else {\r\n                    unreachable!();\r\n                }\r\n                while let Some(&Reverse((time, id, pos))) = event.peek() {\r\n                    if time <= bind_time {\r\n                        event.pop();\r\n                        if !cars.contains_key(&pos) {\r\n                            cars.insert(pos, BinaryHeap::new());\r\n                        }\r\n                        cars.get_mut(&pos).unwrap().push(Reverse((time, id)));\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            let mut nearest;\r\n            match cars.range(0..=a).next() {\r\n                None => {\r\n                    nearest = *cars.range(a + 1..).next().unwrap().0;\r\n                }\r\n                Some(_) => {\r\n                    nearest = *cars.range(0..=a).last().unwrap().0;\r\n                    if cars.range(a + 1..).next().is_some() {\r\n                        let tmp = *cars.range(a + 1..).next().unwrap().0;\r\n                        if tmp - a < a - nearest {\r\n                            nearest = tmp;\r\n                        } else if tmp - a == a - nearest {\r\n                            if cars[&nearest].peek() > cars[&tmp].peek() {\r\n                                nearest = tmp;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            if let Some(Reverse((_av, id))) = cars.get_mut(&nearest).unwrap().pop() {\r\n                if cars[&nearest].is_empty() {\r\n                    cars.remove(&nearest);\r\n                }\r\n                outln!(\"{} {}\", id, bind_time - ot + nearest.abs_diff(a));\r\n                event.push(Reverse((\r\n                    bind_time + nearest.abs_diff(a) + a.abs_diff(b),\r\n                    id,\r\n                    b,\r\n                )))\r\n            } else {\r\n                unreachable!();\r\n            }\r\n            now_time = bind_time;\r\n        }\r\n    }\r\n}\r\n\r\n// --------------------------- tools -----------------------------------\r\nmod io {\r\n    use std::fs::File;\r\n    use std::io::{stdin, stdout, BufRead, BufReader, BufWriter, Write};\r\n\r\n    #[cfg(windows)]\r\n    pub fn in_out() -> (impl BufRead, impl Write) {\r\n        use std::os::windows::prelude::{AsRawHandle, FromRawHandle};\r\n        unsafe {\r\n            let stdin = File::from_raw_handle(stdin().as_raw_handle());\r\n            let stdout = File::from_raw_handle(stdout().as_raw_handle());\r\n            (BufReader::new(stdin), BufWriter::new(stdout))\r\n        }\r\n    }\r\n\r\n    #[cfg(unix)]\r\n    pub fn in_out() -> (impl BufRead, impl Write) {\r\n        use std::os::unix::prelude::{AsRawFd, FromRawFd};\r\n        unsafe {\r\n            let stdin = File::from_raw_fd(stdin().as_raw_fd());\r\n            let stdout = File::from_raw_fd(stdout().as_raw_fd());\r\n            (BufReader::new(stdin), BufWriter::new(stdout))\r\n        }\r\n    }\r\n\r\n    pub struct Scanner<R> {\r\n        reader: R,\r\n        buf_str: Vec<u8>,\r\n        buf_iter: std::str::SplitAsciiWhitespace<'static>,\r\n    }\r\n\r\n    impl<R: BufRead> Scanner<R> {\r\n        pub fn new(reader: R) -> Self {\r\n            Self {\r\n                reader,\r\n                buf_str: Vec::new(),\r\n                buf_iter: \"\".split_ascii_whitespace(),\r\n            }\r\n        }\r\n        pub fn next<T: std::str::FromStr>(&mut self) -> T {\r\n            loop {\r\n                if let Some(token) = self.buf_iter.next() {\r\n                    return token.parse().ok().expect(\"Failed parse\");\r\n                }\r\n                unsafe {\r\n                    self.buf_str.set_len(0);\r\n                }\r\n                self.reader\r\n                    .read_until(b'\\n', &mut self.buf_str)\r\n                    .expect(\"Failed read\");\r\n                self.buf_iter = unsafe {\r\n                    let slice = std::str::from_utf8_unchecked(&self.buf_str);\r\n                    std::mem::transmute(slice.split_ascii_whitespace())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    #[macro_export(local_inner_macros)]\r\n    macro_rules! prelude {\r\n        ($scanner: ident, $out: ident) => {\r\n            use crate::io::in_out;\r\n            use crate::io::Scanner;\r\n            use std::io::Write;\r\n            let ($scanner, mut $out) = in_out();\r\n            let mut $scanner = Scanner::new($scanner);\r\n        };\r\n    }\r\n}\r\n"
}