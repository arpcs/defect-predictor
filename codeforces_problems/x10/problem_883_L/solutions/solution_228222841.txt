{
    "id": 228222841,
    "contestId": 883,
    "creationTimeSeconds": 1697317993,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 883,
        "index": "L",
        "name": "Berland.Taxi",
        "type": "PROGRAMMING",
        "rating": 2500,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 883,
        "members": [
            {
                "handle": "Timur_Sitdikov"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1508573100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 13,
    "timeConsumedMillis": 873,
    "memoryConsumedBytes": 92672000,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define pb push_back\r\n#define mp make_pair\r\ntypedef long long ll;\r\ntypedef pair<int, int> pii;\r\ntypedef vector<int> vi;\r\ntypedef double DOUBLE;\r\ntypedef complex<double> point;\r\n#define xx real()\r\n#define yy imag()\r\n\r\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\r\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\r\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\r\n#define SZ(x) (int)(x).size()\r\n#define BE(x) (x).begin(), (x).end()\r\n#define SORT(x) sort(BE(x))\r\n#define _1 first\r\n#define _2 second\r\n\r\n#define x0 gray_cat_x0\r\n#define y0 gray_cat_y0\r\n#define x1 gray_cat_x1\r\n#define y1 gray_cat_y1\r\n#define j0 gray_cat_j0\r\n\r\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\r\n\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\n#define file \"I1\"\r\n\r\nconst double EPS = 1e-9;\r\nconst double PI = acos(-1.);\r\nconst ll LL_INF = 1e17 + 16;\r\nconst int INF = 1e9 + 10;\r\n// const ll MOD = 1e9 + 7;\r\nconst ll MOD = 998244353;\r\n\r\nconst int MAXN = 3e5 + 5;\r\n\r\nconst int TAXI_AVAILABLE = 0;\r\nconst int TAXI_REQUESTED = 1;\r\n\r\ntypedef pair<pair<long long, int>, pair<int, int> > event;\r\n\r\n// List of free taxis by corresponding house number.\r\nmap<int, queue<int> > free_taxis_by_house;\r\n\r\n// Queue of passengers waiting for taxi.\r\nqueue<event> queued_passengers;\r\n\r\n// A pool of events as a tuple (time, event type, supplementary data).\r\n// Time corresponds to the time of the events, used for sorting all the events.\r\n// Event type can be either TAXI_REQUESTED (corresponds to passenger request for a taxi)\r\n// or TAXI_AVAILABLE (corresponds to a taxi finishing work with a passenge\r\n// and being ready to serve a next passenger).\r\n//\r\n// In case of time clashing, TAXI_AVAILABLE events preced TAXI_REQUESTED events.\r\nset<event> events;\r\n\r\n// For each taxi we store the time of its last usage, to decide which taxi to choose in case of clashes.\r\nlong long last_taxi_use_time[MAXN];\r\n\r\nvoid solve(){\r\n\tint houses, cars, requests;\r\n\t// Read inputs.\r\n\tscanf(\"%d%d%d\", &houses, &cars, &requests);\r\n\tfor(int i = 1; i <= cars; i++) {\r\n\t\tint x;\r\n\t\tscanf(\"%d\", &x);\r\n\t\t// Assign the driver to the corresponding house.\r\n\t\tfree_taxis_by_house[x].push(i);\r\n\t}\r\n\tfor(int i = 0; i < requests; i++) {\r\n\t\tlong long t;\r\n\t\tint a, b;\r\n\t\tscanf(\"%lld%d%d\", &t, &a, &b);\r\n\t\t// Add event (t, TAXI_REQUESTED, a, b) to the pool of events.\r\n\t\tevents.insert({{t, TAXI_REQUESTED}, {a, b}});\r\n\t}\r\n\t// Process all the events one by one, according to their schedule.\r\n\twhile(!events.empty()) {\r\n\t\tevent current_event = *events.begin();\r\n\t\tevents.erase(current_event);\r\n\t\tif (current_event.first.second == TAXI_REQUESTED) {\r\n\t\t\tif (free_taxis_by_house.empty()) {\r\n\t\t\t\t// No taxi available -> push the request to the queue.\r\n\t\t\t\tqueued_passengers.push(current_event);\r\n\t\t\t} else {\r\n\t\t\t\tint current_house = current_event.second.first;\r\n\t\t\t\tint closest_to_left = -1, closest_to_right = INF, chosen_house = -1;\r\n\t\t\t\tif (free_taxis_by_house.lower_bound(current_house) == free_taxis_by_house.end()) {\r\n\t\t\t\t\tclosest_to_left = free_taxis_by_house.rbegin()->first;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tauto closest_iterator = free_taxis_by_house.lower_bound(current_house);\r\n\t\t\t\t\tclosest_to_right = closest_iterator->first;\r\n\t\t\t\t\tif (closest_iterator != free_taxis_by_house.begin()) {\r\n\t\t\t\t\t\tclosest_iterator--;\r\n\t\t\t\t\t\tclosest_to_left = closest_iterator->first;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (closest_to_left == -1 || closest_to_right != INF && (\r\n\t\t\t\t\tclosest_to_right - current_house < current_house - closest_to_left || (\r\n\t\t\t\t\t\tclosest_to_right - current_house == current_house - closest_to_left && (\r\n\t\t\t\t\t\t\tlast_taxi_use_time[free_taxis_by_house[closest_to_right].front()] < last_taxi_use_time[free_taxis_by_house[closest_to_left].front()] || (\r\n\t\t\t\t\t\t\t\tlast_taxi_use_time[free_taxis_by_house[closest_to_right].front()] == last_taxi_use_time[free_taxis_by_house[closest_to_left].front()] && (\r\n\t\t\t\t\t\t\t\t\tfree_taxis_by_house[closest_to_right].front() < free_taxis_by_house[closest_to_left].front())))))) {\r\n\t\t\t\t\t// Choose the closest taxi to the right.\r\n\t\t\t\t\tchosen_house = closest_to_right;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Choose the closest taxi to the right.\r\n\t\t\t\t\tchosen_house = closest_to_left;\r\n\t\t\t\t}\r\n\t\t\t\t// Asssign the chosen axi and remove it from the pool of free taxis.\r\n\t\t\t\tint assigned_taxi = free_taxis_by_house[chosen_house].front();\r\n\t\t\t\tfree_taxis_by_house[chosen_house].pop();\r\n\t\t\t\tif (free_taxis_by_house[chosen_house].empty()) {\r\n\t\t\t\t\tfree_taxis_by_house.erase(chosen_house);\r\n\t\t\t\t}\r\n\t\t\t\tevent future_availability = {\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrent_event.first.first + abs(current_event.second.first - chosen_house) + abs(current_event.second.second - current_event.second.first),\r\n\t\t\t\t\t\tTAXI_AVAILABLE\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tassigned_taxi,\r\n\t\t\t\t\t\tcurrent_event.second.second\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tevents.insert(future_availability);\r\n\t\t\t\tprintf(\"%d %lld\\n\", assigned_taxi, (ll)abs(current_event.second.first - chosen_house));\r\n\t\t\t}\r\n\t\t} else {  // TAXI_AVAILABLE\r\n\t\t\tif (queued_passengers.empty()) {\r\n\t\t\t\t// No queued requests -> mark the taxi as available and assign to its current house.\r\n\t\t\t\tfree_taxis_by_house[current_event.second.second].push(current_event.second.first);\r\n\t\t\t\t// Update last use time for the taxi.\r\n\t\t\t\tlast_taxi_use_time[current_event.second.first] = current_event.first.first;\r\n\t\t\t} else {\r\n\t\t\t\t// Non-empty queue of requests -> assign the car to the oldest request.\r\n\t\t\t\tevent queued_request = queued_passengers.front();\r\n\t\t\t\tqueued_passengers.pop();\r\n\t\t\t\t// Create the future event when the assigned driver finishes the current order.\r\n\t\t\t\tevent future_availability = {\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrent_event.first.first + abs(queued_request.second.first - current_event.second.second) + abs(queued_request.second.second - queued_request.second.first),\r\n\t\t\t\t\t\tTAXI_AVAILABLE\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrent_event.second.first,\r\n\t\t\t\t\t\tqueued_request.second.second\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tevents.insert(future_availability);\r\n\t\t\t\tprintf(\"%d %lld\\n\", current_event.second.first, current_event.first.first - queued_request.first.first + abs(queued_request.second.first - current_event.second.second));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(){\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    freopen(\"out.txt\", \"w\", stdout);\r\n#endif\r\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\r\n    int t = 1;\r\n    //cin >> t;\r\n    while(t--){\r\n        solve();\r\n    }\r\n}\r\n"
}