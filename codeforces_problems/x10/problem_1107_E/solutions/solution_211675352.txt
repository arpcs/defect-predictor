{
    "id": 211675352,
    "contestId": 1107,
    "creationTimeSeconds": 1688183942,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1107,
        "index": "E",
        "name": "Vasya and Binary String",
        "type": "PROGRAMMING",
        "rating": 2400,
        "tags": [
            "dp"
        ]
    },
    "author": {
        "contestId": 1107,
        "members": [
            {
                "handle": "ravikjha7"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1548516900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 10137600,
    "source": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n#define mod 1000000007\n#define nl \"\\n\"\n\nvoid file() {\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n\nclass SegmentTree {\n\tll *seg;\n\tll *lazy;\n\tpublic :\n\n\tSegmentTree(ll n) {\n\t\t// Maximum Size Of Tree could be 4n only\n\t\tseg = new ll[4*n + 1];\n\t\tlazy = new ll[4*n + 1];\n\t}\n\n\t// Time Complexity Of Build : O(4N) == O(N) !!!\n\tvoid BuildTree(ll arr[], ll i, ll low, ll high) {\n\t\tif(low == high) {\n\t\t\tseg[i] = arr[low];\n\t\t\treturn;\n\t\t}\n\n\t\tll mid = low + (high - low) / 2;\n\n\t\t// Left Child\n\t\tBuildTree(arr, 2 * i + 1, low, mid);\n\t\t// Right Child\n\t\tBuildTree(arr, 2 * i + 2, mid + 1, high);\n\t\t\n\t\t// Sum Of Two\n\t\tseg[i] = seg[2 * i + 1] + seg[2 * i + 2];\n\t}\n\n\t// Query Time Complexity : O(logN)\n\tll query(ll ind, ll l, ll r, ll low, ll high) {\n\n\t\t// If Update is Remaining, First Update The Values\n\t\tif(lazy[ind] != 0) {\n\n\t\t\tseg[ind] += (high - low + 1) * lazy[ind];\n\n\t\t\t// If it is a leaf node, it will not have childrens\n\t\t\tif(low != high) {\n\t\t\t\tlazy[2 * ind + 1] += lazy[ind];\n\t\t\t\tlazy[2 * ind + 2] += lazy[ind];\n\t\t\t}\n\t\t\tlazy[ind] = 0;\n\t\t}\n\n\t\t// No Overlap\n\t\t// l r low high or low high l r\n\t\tif(high < l || low > r) return 0;\n\n\t\t// Complete Overlap\n\t\t// l low high r\n\t\tif(high <= r && low >= l) return seg[ind];\n\n\t\t// Partial Overlap\n\t\tll mid = low + (high - low) / 2;\n\n\t\tll left = query(2 * ind + 1, l, r, low, mid);\n\t\tll right = query(2 * ind + 2, l, r, mid + 1, high);\n\t\treturn left + right;\n\t}\n\n\n\t// Update Time Complexity : O(logN)\n\tvoid update(ll i, ll val, ll low, ll high, ll ind) {\n\t\t// If we found the required Node\n\t\tif(low == high) {\n\t\t\tseg[ind] = val;\n\t\t\treturn;\n\t\t}\n\n\t\tll mid = low + (high - low)/2;\n\n\t\t// If required node is left to mid, \n\t\t// Move To Left Child Else Move To Right Child\n\t\tif(i <= mid) update(i, val, low, mid, 2 * ind + 1);\n\t\telse update(i, val, mid + 1, high, 2 * ind + 2);\n\n\t\t// Since, One Of The Child's Value is Updated\n\t\t// We have to find minimum again !!!\n\t\tseg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\n\t}\n\n\tvoid updateRange(ll l, ll r, ll val, ll low, ll high, ll ind) {\n\t\t// First Update The Remaining Updates\n\t\t// Lazy Propagate To The Child\n\t\tif(lazy[ind] != 0) {\n\n\t\t\tseg[ind] += (high - low + 1) * lazy[ind];\n\n\t\t\t// If it is a leaf node, it will not have childrens\n\t\t\tif(low != high) {\n\t\t\t\tlazy[2 * ind + 1] += lazy[ind];\n\t\t\t\tlazy[2 * ind + 2] += lazy[ind];\n\t\t\t}\n\t\t\tlazy[ind] = 0;\n\t\t}\n\n\t\t// No Overlap\n\t\t// l r low high or low high l r\n\t\tif(high < l || low > r) return;\n\n\t\t// Complete Overlap\n\t\t// l low high r\n\t\tif(high <= r && low >= l) {\n\t\t\tseg[ind] += (high - low + 1) * val;\n\t\t\tif(low != high) {\n\t\t\t\tlazy[2 * ind + 1] += val;\n\t\t\t\tlazy[2 * ind + 2] += val;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tll mid = low + (high - low)/2;\n\n\t\t// Partial Overlap ke case me left and right dono update karenge\n\t\tupdateRange(l, r, val, low, mid, 2 * ind + 1);\n\t\tupdateRange(l, r, val, mid + 1, high, 2 * ind + 2);\n\n\t\t// Since, One Of The Child's Value is Updated\n\t\t// We have to find minimum again !!!\n\t\tseg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\n\t}\n};\n\nstruct fenwick {\n\n    vector<ll> fn;\n    ll n;\n\n    void init(ll n) {\n\n        this->n = n + 1;\n        fn.resize(this->n, 0);\n\n    }\n\n    void add(ll x, ll y) {\n\n        x++;\n\n        while (x < n) {\n            fn[x] += y;\n            x += (x & (-x));\n        }\n    }\n\n    ll sum(ll x) {\n        x++;\n\n        ll ans = 0;\n        while (x) {\n            ans += fn[x];\n            x -= (x & (-x));\n        }\n\n        return ans;\n    }\n\n    ll sum(ll l, ll r) {\n        return sum(r) - sum(l - 1);\n    }\n};\n\nclass DisjointSet {\n\tvector<ll> rank, parent, size;\n\npublic:\n\n\tDisjointSet(ll n) {\n\t\trank.resize(n + 1, 0);\n\t\tparent.resize(n + 1);\n\t\tsize.resize(n + 1, 1);\n\t\tfor(ll i = 1; i <= n; i++) parent[i] = i;\n\t}\n\n\tvoid unionByRank(ll x, ll y) {\n\n\t\tll par_x = findPar(x);\n\t\tll par_y = findPar(y);\n\n\t\tif(par_x == par_y) return;\n\n\t\tif(rank[par_x] < rank[par_y]) {\n\t\t\tparent[par_x] = par_y;\n\t\t} else if(rank[par_y] < rank[par_x]) {\n\t\t\tparent[par_y] = par_x;\n\t\t} else {\n\t\t\tparent[par_x] = par_y;\n\t\t\trank[par_y]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(ll x, ll y) {\n\n\t\tll par_x = findPar(x);\n\t\tll par_y = findPar(y);\n\n\t\tif(par_x == par_y) return;\n\n\t\tif(size[par_x] < size[par_y]) {\n\t\t\tparent[par_x] = par_y;\n\t\t\tsize[par_y] += size[par_x];\n\t\t} else {\n\t\t\tparent[par_y] = par_x;\n\t\t\tsize[par_x] += size[par_y];\n\t\t}\n\t}\n\n\tll findPar(ll x) {\n\n\t\tif(parent[x] == x) return x;\n\n\t\treturn parent[x] = findPar(parent[x]);\n\n\t}\n\n};\n\nll binpow(ll a,ll b) {\n    ll ans = 1;\n    while(b > 0) {\n        if((b & 1) == 1) ans *= a;\n        a *= a;\n        b = b >> 1;\n    }\n    return ans;\n}\n\nll binpowmod(ll a,ll b) {\n    ll ans = 1;\n    while(b > 0) {\n        if((b & 1) == 1) {\n        \tans *= a;\n        \tans %= mod;\n        }\n        a *= a;\n        a %= mod;\n        b = b >> 1;\n    }\n    return ans;\n}\n\n\nll gcd(ll a,ll b) {\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a,ll b) {\n\treturn (a / gcd(a,b)) * b;\n}\n\nconst ll MAX = 2e5 + 7;\nvector<ll> fact(MAX);\n \nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\n \nll sub(ll a, ll b) {\n\treturn ((a - b) % mod + mod) % mod;\n}\n \nll mult(ll a, ll b) {\n\treturn ((a * b) % mod);\n}\n\nll inv(ll a) {\n\treturn binpowmod(a, mod - 2);\n}\n \nll divide(ll a, ll b) {\n\treturn mult(a, inv(b));\n}\n \nll nCr(ll n, ll r) {\n\tif(n < r) return 0;\n\treturn divide(fact[n], mult(fact[r], fact[n - r]));\n}\n \nvoid preFactorial() {\n\tfact[0] = 1;\n\tfor(ll i = 1; i < MAX; i++) fact[i] = mult(i, fact[i - 1]);\n}\n\nbool isVowel(char c) {\n\tif(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true;\n\tif(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') return true;\n\treturn false;\n}\n\nbool isSame(ll n, ll arr[]) {\n\tfor(ll i = 0; i < n; i++) {\n\t\tif(arr[i] != arr[0]) return false;\n\t}\n\treturn true;\n}\n\nbool isSame(ll n, vector<ll> &arr) {\n\tfor(ll i = 0; i < n; i++) {\n\t\tif(arr[i] != arr[0]) return false;\n\t}\n\treturn true;\n}\n\nbool isSorted(ll n, ll arr[]) {\n\tfor(ll i = 1; i < n; i++) {\n\t\tif(arr[i] < arr[i - 1]) return false;\n\t}\n\treturn true;\n}\n\nbool isSorted(ll n, vector<ll> &arr) {\n\tfor(ll i = 1; i < n; i++) {\n\t\tif(arr[i] < arr[i - 1]) return false;\n\t}\n\treturn true;\n}\n\nvoid inputArr(ll n, ll arr[]) {\n\tfor(ll i = 0; i < n; i++) cin >> arr[i];\n}\n\nvoid inputArr(ll n, vector<ll> &arr) {\n\tll x;\n\tfor(ll i = 0; i < n; i++) {\n\t\tcin >> x;\n\t\tarr.push_back(x);\n\t}\n}\n\nvoid printArr(ll n, ll arr[]) {\n\tfor(ll i = 0; i < n; i++) cout << arr[i] << \" \";\n\tcout << nl;\n}\n\nvoid printArr(ll n, vector<ll> &arr) {\n\tfor(ll i = 0; i < n; i++) cout << arr[i] << \" \";\n\tcout << nl;\n}\n\nll sumOfArr(ll n, ll arr[]) {\n\tll ans = 0;\n\tfor(ll i = 0; i < n; i++) ans += arr[i];\n\treturn ans;\n}\n\nll sumOfArr(ll n, vector<ll> &arr) {\n\tll ans = 0;\n\tfor(ll i = 0; i < n; i++) ans += arr[i];\n\treturn ans;\n}\n\nbool isPrime(ll n) {\n\tif(n == 1) return false;\n\tfor(ll i = 2; i <= sqrt(n); i++) {\n\t\tif(n % i == 0) return false;\n\t}\n\treturn true;\n}\n\nll countSetBits(ll n) {\n\tll ans = 0;\n\twhile(n) {\n\t\tans++;\n\t\tn = n & (n - 1);\n\t}\n\treturn ans;\n}\n\nvector<ll> primeFactorization(ll n) {\n\tvector<ll> factors;\n\tfor(ll i = 2; i * i <= n; i++) {\n\t\tll cnt = 0; \n\t\twhile(n % i == 0) {\n\t\t\tcnt++;\n\t\t\tn /= i;\n\t\t\tfactors.push_back(i);\n\t\t}\n\t}\n\tif(n > 1) factors.push_back(n);\n\treturn factors;\n}\n\nbool isPalindrome(string s) {\n\tll i = 0;\n\tll j = s.size() - 1;\n\twhile(i <= j) {\n\t\tif(s[i] != s[j]) return false;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\n\n// ----------- Code Starts Here ----------- //\n\nll dp[102][102][102];\nll bestLen[102];\n\nvoid preCompute(vector<ll> &cost) {\n\n\tfor(ll i = 0; i < 102; i++) {\n\t\tfor(ll j = 0; j < 102; j++) {\n\t\t\tfor(ll k = 0; k < 102; k++) dp[i][j][k] = -1;\n\t\t}\n\t}\n\n\tfor(ll i = 0; i < 102; i++) bestLen[i] = 0;\n\n\tfor(ll i = 1; i <= cost.size(); i++) {\n\t\tfor(ll j = 1; j <= i; j++) {\n\t\t\tbestLen[i] = max(bestLen[i], cost[j] + bestLen[i - j]);\n\t\t}\n\t}\n\n}\n\nll helper(vector<ll> &groups, ll i, ll j, ll extra) {\n\n\tif(i > j) return 0;\n\tif(dp[i][j][extra] != -1) return dp[i][j][extra];\n\n\tll ans = bestLen[groups[i] + extra] + helper(groups, i + 1, j, 0);\n\n\tfor(ll k = i + 2; k <= j; k += 2) {\n\t\tans = max(ans, helper(groups, i + 1, k - 1, 0) + helper(groups, k, j, extra + groups[i]));\n\t}\n\n\treturn dp[i][j][extra] = ans;\n\n}\n\nvoid solve() \n{\n\tll n;\n\tcin >> n;\n\n\tstring s;\n\tcin >> s;\n\n\tvector<ll> cost;\n\tcost.push_back(0);\n\tinputArr(n, cost);\n\n\tpreCompute(cost);\n\n\tvector<ll> groups;\n\tll curr = 1;\n\tfor(ll i = 1; i < s.size(); i++) {\n\t\tif(s[i] == s[i - 1]) curr++;\n\t\telse {\n\t\t\tgroups.push_back(curr);\n\t\t\tcurr = 1;\n\t\t}\n\t}\n\n\tgroups.push_back(curr);\n\n\tcout << helper(groups, 0, n - 1, 0) << nl;\n\n\n}\n\nint main()\n{\n\tfile();\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\tint t = 1;\n\t// cin >> t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t}\n\treturn 0;\n}"
}