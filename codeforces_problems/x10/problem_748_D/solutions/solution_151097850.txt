{
    "id": 151097850,
    "contestId": 748,
    "creationTimeSeconds": 1648385071,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 748,
        "index": "D",
        "name": "Santa Claus and a Palindrome",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2100,
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy"
        ]
    },
    "author": {
        "contestId": 748,
        "members": [
            {
                "handle": "nez17444"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1482656700
    },
    "programmingLanguage": "Python 3",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 109,
    "memoryConsumedBytes": 7372800,
    "source": "import copy\nfrom turtle import pos\n\nfrom itsdangerous import exc\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    def insert(self, value):\n        if self.value:\n            if value < self.value:\n                if self.left is None:\n                    self.left = Node(value)\n                else:\n                    self.left.insert(value)\n            else:\n                if self.right is None:\n                    self.right = Node(value)\n                else:\n                    self.right.insert(value)\n        else:\n            self.value = value\n    def getLen(self):\n        l = 1\n        if self.left:\n            l += self.left.getLen()\n        if self.right:\n            l += self.right.getLen()\n        return l\n    def getSum(self):\n        s = self.value\n        if self.left:\n            s += self.left.getSum()\n        if self.right:\n            s += self.right.getSum()\n        return s\n    def getMax(self):\n        mx = self.value\n        if self.right:\n            mx = self.right.getMax()\n        return mx\n    def getMin(self):\n        mn = self.value\n        if self.left:\n            mn = self.left.getMin()\n        return mn\n\n    def getTree(self):\n        ll = []\n        lr = []\n        if self.left:\n            ll = self.left.getTree()\n        if self.right:\n            lr= self.right.getTree()\n        return ll + [self.value] + lr\n\n    def printTree(self):\n        if self.left:\n            self.left.printTree()\n        with open('a_print_tree.txt', 'w') as f:\n            print(self.value, end=\" \", file=f)\n        if self.right:\n            self.right.printTree()\n\ndef deleteMax(root):\n    if not root:\n        return root\n    if root.right:\n        root.right = deleteMax(root.right)\n    else:\n        if root.left:\n            return root.left      \n    if root.left is None and root.right is None:\n        return None\n    return root\n\ndef deleteMin(root):\n    if not root:\n        return root\n    if root.left:\n        root.left = deleteMin(root.left)\n    else:\n        if root.right:\n            return root.right      \n    if root.left is None and root.right is None:\n        return None\n    return root\n\n\nkn = input().split()\nk = int(kn[0])\nn = int(kn[1])\n \nd = {}\nd_pos = {}\nd_neg = {}\ntotal_sum = 0\n\ndef is_palindrome(s):\n    if len(s) == 1:\n        return True\n    pal = True\n    n = len(s)\n    for i in range(n//2):\n        if s[i] != s[n-1-i]:\n            pal = False\n            break\n    return pal\n \ndef reverse_string(s):\n    if len(s) == 1:\n        return s\n    new_s = ''\n    for i in range(len(s)-1, -1, -1):\n        new_s += s[i]\n    return new_s\n\n \nfor i in range(k):\n    sa = input().split()\n    s = sa[0]\n    a = int(sa[1])\n    try:\n        if d[s] is not None:\n            d[s].insert(a)\n            if a > 0:\n                try:\n                    if d_pos[s] is not None:\n                        d_pos[s].insert(a)\n                except KeyError:\n                    d_pos[s] = Node(a)\n            else:\n                try:\n                    if d_neg[s] is not None:\n                        d_neg[s].insert(a)\n                except KeyError:\n                    d_neg[s] = Node(a)\n    except KeyError:\n        d[s] = Node(a)\n        if a > 0:\n            d_pos[s] = Node(a)\n        else:\n            d_neg[s] = Node(a)\n \nkeys_to_skip = []\nsolo_pal_max = 0\n\nd_keys_sorted = []\n\nfor key in sorted(d_pos, key=lambda key: d_pos[key].getMin(), reverse=True):\n    if d[key].getLen() % 2 != 0 and d_pos[key].getLen() % 2 != 0:\n        d_keys_sorted.append(key)\nfor key in sorted(d_pos, key=lambda key: d_pos[key].getMin(), reverse=True):\n    try:\n        if d_pos[key] is not None:\n            continue\n    except KeyError:\n        d_keys_sorted.append(key)\n    \nfor key in d_neg.keys():\n    try:\n        if d_pos[key] is not None:\n            continue\n    except KeyError:\n        d_keys_sorted.append(key)\n\n#print(d_keys_sorted)\n\nfor key in d_keys_sorted:\n    if d[key] is None:\n        continue\n\n    d_len = d[key].getLen()\n\n    if key in keys_to_skip:\n        continue\n    try:\n        if d[key].getMax() < 0:\n            continue\n    except KeyError:\n        pass\n    \n\n    new_solo_pal_max = False\n    if is_palindrome(key):\n        if d_len > 1:\n            try:\n                if d_pos[key]:\n                    neg_len = 0\n                    pos_len = d_pos[key].getLen()\n                    pos_min = d_pos[key].getMin()\n                    pos_sum = d_pos[key].getSum()\n\n                    if pos_len % 2 == 0:\n                        total_sum += pos_sum\n                        continue\n                    \n                    if d_len > pos_len:\n                        neg_max = d_neg[key].getMax()\n                        total_sum += (pos_sum - pos_min)\n                        if pos_min > pos_min + neg_max + solo_pal_max:\n                            solo_pal_max = pos_min\n                        elif pos_min + neg_max > 0:\n                            total_sum += pos_min + neg_max\n                    else:\n                        total_sum += pos_sum - pos_min\n                        if pos_min > solo_pal_max:\n                            solo_pal_max = pos_min\n                    #try:\n                    #    neg_pos_diff = neg_max + pos_min\n\n                    #    if pos_min > pos_min + neg_max + solo_pal_max and d_len % 2 != 0:\n                    #        solo_pal_max = pos_min\n                    #        total_sum += (pos_sum - pos_min)\n                    #    else:\n                    #        if pos_sum + neg_max > 0:\n                    #            total_sum += pos_sum + neg_max\n                    #except KeyError:\n                    #    total_sum += (pos_sum - pos_min)\n                    #    if pos_min > solo_pal_max:\n                    #        solo_pal_max = pos_min \n            except KeyError:\n                pass\n        else:\n            if d[key].getMin() > solo_pal_max:\n                solo_pal_max = d[key].getMin()\n    else:\n        try:\n            rev_key = reverse_string(key)\n            while d[key] and d[rev_key]:\n                if d_len > 0 and d[rev_key].getLen() > 0:\n                    last_two_sum = d[key].getMax() + d[rev_key].getMax()\n                    if last_two_sum > 0:\n                        total_sum += last_two_sum\n                    else:\n                        break\n                    d[key] = deleteMax(d[key])\n                    d[rev_key] = deleteMax(d[rev_key])\n            keys_to_skip.append(rev_key)\n        except KeyError:\n            pass\n\n#for key in sorted(d_copy, key=lambda key: d_copy[key].getLen(), reverse=False):\n#    d_len = d_copy[key].getLen()\n#\n#    if d_len % 2 != 0:\n#        continue\n#\n#    if key in keys_to_skip:\n#        continue\n#    try:\n#        if d_copy[key].getMax() < 0:\n#            continue\n#    except KeyError:\n#        pass\n#    \n#\n#    new_solo_pal_max = False\n#    if is_palindrome(key):\n#        if d_len > 1:\n#            try:\n#                if d_pos[key]:\n#                    neg_len = 0\n#                    pos_len = d_pos[key].getLen()\n#                    pos_min = d_pos[key].getMin()\n#                    pos_sum = d_pos[key].getSum()\n#\n#                    if pos_len % 2 == 0:\n#                        total_sum += pos_sum\n#                        continue\n#\n#                    if pos_min > solo_pal_max and d_len % 2 != 0:\n#                        new_solo_pal_max = True\n#                        solo_pal_max = pos_min\n#\n#                    try:\n#                        neg_max = d_neg[key].getMax()\n#                        neg_pos_diff = neg_max + pos_min\n#                        \n#                        if neg_pos_diff >= solo_pal_max and not new_solo_pal_max:\n#                            total_sum += pos_sum + neg_max\n#                        else:\n#                            total_sum += (pos_sum - pos_min)\n#                            if pos_min > solo_pal_max:\n#                                solo_pal_max = pos_min \n#                    except KeyError:\n#                        total_sum += (pos_sum - pos_min)\n#                        if pos_min > solo_pal_max:\n#                            solo_pal_max = pos_min \n#            except KeyError:\n#                pass\n#        else:\n#            if d_copy[key].getMin() > solo_pal_max:\n#                solo_pal_max = d_copy[key].getMin()\n#    else:\n#        try:\n#            rev_key = reverse_string(key)\n#            while d_copy[key] and d_copy[rev_key]:\n#                if d_len > 0 and d_copy[rev_key].getLen() > 0:\n#                    last_two_sum = d_copy[key].getMax() + d_copy[rev_key].getMax()\n#                    if last_two_sum > 0:\n#                        total_sum += last_two_sum\n#                    else:\n#                        break\n#                    d_copy[key] = deleteMax(d_copy[key])\n#                    d_copy[rev_key] = deleteMax(d_copy[rev_key])\n#            keys_to_skip.append(rev_key)\n#        except KeyError:\n#            pass\n\n\nprint(total_sum + solo_pal_max)\n"
}