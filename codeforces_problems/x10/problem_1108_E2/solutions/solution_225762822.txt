{
    "id": 225762822,
    "contestId": 1108,
    "creationTimeSeconds": 1695983079,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1108,
        "index": "E2",
        "name": "Array and Segments (Hard version)",
        "type": "PROGRAMMING",
        "rating": 2100,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 1108,
        "members": [
            {
                "handle": "liupengsay"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1548254100
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 106,
    "timeConsumedMillis": 468,
    "memoryConsumedBytes": 29900800,
    "source": "import random\r\nimport sys\r\nfrom math import inf\r\n\r\nfrom typing import List\r\n\r\n\r\n# sys.setrecursionlimit(10**8)\u8bbe\u7f6e\u6700\u5927\u9012\u5f52\u6b21\u6570\r\n\r\n\r\nclass FastIO:\r\n    def __init__(self):\r\n        self.random_seed = random.randint(0, 10 ** 9 + 7)\r\n        return\r\n\r\n    @staticmethod\r\n    def read_int():\r\n        return int(sys.stdin.readline().strip())\r\n\r\n    @staticmethod\r\n    def read_float():\r\n        return float(sys.stdin.readline().strip())\r\n\r\n    @staticmethod\r\n    def read_list_ints():\r\n        return list(map(int, sys.stdin.readline().strip().split()))\r\n\r\n    @staticmethod\r\n    def read_list_floats():\r\n        return list(map(float, sys.stdin.readline().strip().split()))\r\n\r\n    @staticmethod\r\n    def read_list_ints_minus_one():\r\n        return list(map(lambda x: int(x) - 1, sys.stdin.readline().strip().split()))\r\n\r\n    @staticmethod\r\n    def read_str():\r\n        return sys.stdin.readline().strip()\r\n\r\n    @staticmethod\r\n    def read_list_strs():\r\n        return sys.stdin.readline().strip().split()\r\n\r\n    @staticmethod\r\n    def read_list_str():\r\n        return list(sys.stdin.readline().strip())\r\n\r\n    @staticmethod\r\n    def st(x):\r\n        return print(x)\r\n\r\n    @staticmethod\r\n    def lst(x):\r\n        return print(*x)\r\n\r\n    @staticmethod\r\n    def round_5(f):\r\n        res = int(f)\r\n        if f - res >= 0.5:\r\n            res += 1\r\n        return res\r\n\r\n    @staticmethod\r\n    def max(a, b):\r\n        return a if a > b else b\r\n\r\n    @staticmethod\r\n    def min(a, b):\r\n        return a if a < b else b\r\n\r\n    @staticmethod\r\n    def ceil(a, b):\r\n        return a // b + int(a % b != 0)\r\n\r\n    def hash_num(self, x):\r\n        return x ^ self.random_seed\r\n\r\n    @staticmethod\r\n    def accumulate(nums):\r\n        n = len(nums)\r\n        pre = [0] * (n + 1)\r\n        for i in range(n):\r\n            pre[i + 1] = pre[i] + nums[i]\r\n        return pre\r\n\r\n    def inter_ask(self, lst):\r\n        # CF\u4ea4\u4e92\u9898\u8f93\u51fa\u8be2\u95ee\u5e76\u8bfb\u53d6\u7ed3\u679c\r\n        self.st(lst)\r\n        sys.stdout.flush()\r\n        res = self.read_int()\r\n        # \u8bb0\u5f97\u4efb\u4f55\u4e00\u4e2a\u8f93\u51fa\u4e4b\u540e\u90fd\u8981 sys.stdout.flush() \u5237\u65b0\r\n        return res\r\n\r\n    def inter_out(self, lst):\r\n        # CF\u4ea4\u4e92\u9898\u8f93\u51fa\u6700\u7ec8\u7b54\u6848\r\n        self.st(lst)\r\n        sys.stdout.flush()\r\n        return\r\n\r\n\r\nclass SegmentTreeRangeUpdateQuerySumMinMax:\r\n    def __init__(self, n) -> None:\r\n        # \u6a21\u677f\uff1a\u533a\u95f4\u503c\u589e\u51cf\u3001\u533a\u95f4\u548c\u67e5\u8be2\u3001\u533a\u95f4\u6700\u5c0f\u503c\u67e5\u8be2\u3001\u533a\u95f4\u6700\u5927\u503c\u67e5\u8be2\r\n        self.n = n\r\n        self.lazy = [0] * (4 * self.n)  # \u61d2\u6807\u8bb0\u53ea\u80fd\u521d\u59cb\u5316\u4e3a0\r\n        self.floor = [0] * (4 * self.n)  # \u6700\u5c0f\u503c\u4e5f\u53ef\u521d\u59cb\u5316\u4e3ainf\r\n        return\r\n\r\n    @staticmethod\r\n    def max(a: int, b: int) -> int:\r\n        return a if a > b else b\r\n\r\n    @staticmethod\r\n    def min(a: int, b: int) -> int:\r\n        return a if a < b else b\r\n\r\n    def build(self, nums: List[int]) -> None:\r\n        # \u4f7f\u7528\u6570\u7ec4\u521d\u59cb\u5316\u7ebf\u6bb5\u6811\r\n        assert self.n == len(nums)\r\n        stack = [[0, self.n - 1, 1]]\r\n        while stack:\r\n            s, t, ind = stack.pop()\r\n            if ind >= 0:\r\n                if s == t:\r\n                    self.make_tag(ind, s, t, nums[s])\r\n                else:\r\n                    stack.append([s, t, ~ind])\r\n                    m = s + (t - s) // 2\r\n                    stack.append([s, m, 2 * ind])\r\n                    stack.append([m + 1, t, 2 * ind + 1])\r\n            else:\r\n                ind = ~ind\r\n                self.push_up(ind)\r\n        return\r\n\r\n    def push_down(self, i: int, s: int, m: int, t: int) -> None:\r\n        # \u4e0b\u653e\u61d2\u6807\u8bb0\r\n        if self.lazy[i]:\r\n\r\n            self.floor[2 * i] += self.lazy[i]\r\n            self.floor[2 * i + 1] += self.lazy[i]\r\n\r\n            self.lazy[2 * i] += self.lazy[i]\r\n            self.lazy[2 * i + 1] += self.lazy[i]\r\n\r\n            self.lazy[i] = 0\r\n\r\n    def push_up(self, i) -> None:\r\n        self.floor[i] = self.min(self.floor[2 * i], self.floor[2 * i + 1])\r\n        return\r\n\r\n    def make_tag(self, i, s, t, val) -> None:\r\n        self.floor[i] += val\r\n        self.lazy[i] += val\r\n        return\r\n\r\n    def update_range(self, left: int, right: int, s: int, t: int, val: int, i: int) -> None:\r\n        # \u589e\u51cf\u533a\u95f4\u503c left \u4e0e right \u53d6\u503c\u4e3a 0 \u5230 n-1 \u800c i \u4ece 1 \u5f00\u59cb\r\n        stack = [[s, t, i]]\r\n        while stack:\r\n            s, t, i = stack.pop()\r\n            if i >= 0:\r\n                if left <= s and t <= right:\r\n                    self.make_tag(i, s, t, val)\r\n                    continue\r\n\r\n                m = s + (t - s) // 2\r\n                self.push_down(i, s, m, t)\r\n                stack.append([s, t, ~i])\r\n\r\n                if left <= m:  # \u6ce8\u610f\u5de6\u53f3\u5b50\u6811\u7684\u8fb9\u754c\u4e0e\u8303\u56f4\r\n                    stack.append([s, m, 2 * i])\r\n                if right > m:\r\n                    stack.append([m + 1, t, 2 * i + 1])\r\n            else:\r\n                i = ~i\r\n                self.push_up(i)\r\n        return\r\n\r\n    def update_point(self, left: int, right: int, s: int, t: int, val: int, i: int) -> None:\r\n        # \u589e\u51cf\u5355\u70b9\u503c left \u4e0e right \u53d6\u503c\u4e3a 0 \u5230 n-1 \u800c i \u4ece 1 \u5f00\u59cb\r\n\r\n        while True:\r\n            if left <= s and t <= right:\r\n                self.make_tag(i, s, t, val)\r\n                break\r\n            m = s + (t - s) // 2\r\n            self.push_down(i, s, m, t)\r\n            if left <= m:  # \u6ce8\u610f\u5de6\u53f3\u5b50\u6811\u7684\u8fb9\u754c\u4e0e\u8303\u56f4\r\n                s, t, i = s, m, 2 * i\r\n            if right > m:\r\n                s, t, i = m + 1, t, 2 * i + 1\r\n        while i > 1:\r\n            i //= 2\r\n            self.push_up(i)\r\n        return\r\n\r\n    def query_min(self, left: int, right: int, s: int, t: int, i: int) -> int:\r\n        # \u67e5\u8be2\u533a\u95f4\u7684\u6700\u5c0f\u503c\r\n        stack = [[s, t, i]]\r\n        highest = inf\r\n        while stack:\r\n            s, t, i = stack.pop()\r\n            if left <= s and t <= right:\r\n                highest = self.min(highest, self.floor[i])\r\n                continue\r\n            m = s + (t - s) // 2\r\n            self.push_down(i, s, m, t)\r\n            if left <= m:\r\n                stack.append([s, m, 2 * i])\r\n            if right > m:\r\n                stack.append([m + 1, t, 2 * i + 1])\r\n        return highest\r\n\r\n\r\nclass Solution:\r\n    def __init__(self):\r\n        return\r\n\r\n    @staticmethod\r\n    def main(ac=FastIO()):\r\n        n, m = ac.read_list_ints()\r\n        nums = ac.read_list_ints()\r\n        lst = [ac.read_list_ints_minus_one() for _ in range(m)]\r\n        ceil = max(nums)\r\n        ans = ceil - min(nums)\r\n        tree = SegmentTreeRangeUpdateQuerySumMinMax(n)\r\n        tree.build(nums)\r\n        res = -1\r\n        cur_min = nums[:]\r\n        tmp = sorted(lst, key=lambda it: it[1])\r\n        j = 0\r\n        for i in range(n):\r\n            while j < m and tmp[j][1] < i:\r\n                a, b = tmp[j]\r\n                tree.update_range(a, b, 0, n - 1, -1, 1)\r\n                j += 1\r\n\r\n            if i:\r\n                cur = tree.query_min(0, i-1, 0, n-1, 1)\r\n                if cur < cur_min[i]:\r\n                    cur_min[i] = cur\r\n\r\n        tmp = sorted(lst, key=lambda it: -it[0])\r\n        tree = SegmentTreeRangeUpdateQuerySumMinMax(n)\r\n        tree.build(nums)\r\n        j = 0\r\n        for i in range(n-1, -1, -1):\r\n            while j < m and tmp[j][0] > i:\r\n                a, b = tmp[j]\r\n                tree.update_range(a, b, 0, n - 1, -1, 1)\r\n                j += 1\r\n\r\n            if i+1<n:\r\n                cur = tree.query_min(i + 1, n-1, 0, n - 1, 1)\r\n                if cur < cur_min[i]:\r\n                    cur_min[i] = cur\r\n        cur_min = [nums[i]-cur_min[i] for i in range(n)]\r\n        ans = max(cur_min)\r\n        res = cur_min.index(ans)\r\n        ac.st(ans)\r\n        if res != -1:\r\n            tmp = [i+1 for i in range(m) if not lst[i][0]<=res<=lst[i][1]]\r\n            ac.st(len(tmp))\r\n            ac.lst(tmp)\r\n        else:\r\n            ac.st(0)\r\n        return\r\n\r\n\r\nSolution().main()\r\n"
}