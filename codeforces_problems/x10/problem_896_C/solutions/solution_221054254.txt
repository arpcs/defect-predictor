{
    "id": 221054254,
    "contestId": 896,
    "creationTimeSeconds": 1693381216,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 896,
        "index": "C",
        "name": "Willem, Chtholly and Seniorious",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2600,
        "tags": [
            "data structures",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 896,
        "members": [
            {
                "handle": "gala_xk"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1512223500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 34,
    "timeConsumedMillis": 561,
    "memoryConsumedBytes": 11468800,
    "source": "// LUOGU_RID: 123311190\n/* Use the slash-star style comments or the system won't see your\r\n   identification information */\r\n/*\r\nID: zhuheng1\r\nTASK:\r\nLANG: C++\r\n*/\r\n/* LANG can be C++11 or C++14 for those more recent releases */\r\n#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nnamespace stan{//standard\r\n\tconst int maxn=100005;\r\n\tconst int maxm=100005;\r\n\tint modx=998244353;\r\n}\r\nnamespace lucas{\r\n\tlong long n,m,p,cnt,pr[1010],al[1010];\r\n\tvoid exgcd(long long a,long long b,long long &x,long long &y){\r\n\t    if(b==0) {x=1;y=0;\r\n\t    \treturn ;\r\n\t\t}\r\n\t    exgcd(b,a%b,x,y);\r\n\t    long long tmp=x;\r\n\t\tx=y;\r\n\t\ty=tmp-a/b*y;\r\n\t\treturn;\r\n\t}\r\n\tlong long inv(long long a,long long p){\r\n\t    long long x,y;\r\n\t    exgcd(a,p,x,y);\r\n\t    return (x+p)%p;\r\n\t}\r\n\tlong long POW(long long a,long long b,long long p){\r\n\t    long long t=1;\r\n\t\ta%=p;\r\n\t    for(;b;b>>=1){\r\n\t        if(b&1) t=t*a%p;\r\n\t        a=a*a%p;\r\n\t    }\r\n\t    return t;\r\n\t}\r\n\tlong long fac(long long n,long long p,long long ppa){\r\n\t    if (n==0) return 1;\r\n\t    long long cir=1,rem=1;\r\n\t    for(long long i=1;i<=ppa;i++){\r\n\t    \tif(i%p){\r\n\t    \t\tcir=cir*i%ppa;\r\n\t\t\t}\r\n\t\t}\r\n\t    cir=POW(cir,n/ppa,ppa);\r\n\t    for(long long i=ppa*(n/ppa);i<=n;i++){\r\n\t    \tif(i%p){\r\n\t    \t\trem=rem*(i%ppa)%ppa;\r\n\t\t\t}\r\n\t\t}\r\n\t    return fac(n/p,p,ppa)*cir%ppa*rem%ppa;\r\n\t}\r\n\tlong long sum_fac(long long n,long long p){\r\n\t\tif(n<p) return 0;\r\n\t    return sum_fac(n/p,p)+n/p;\r\n\t}\r\n\tlong long C(long long n,long long m,long long p,long long ppa){\r\n\t    long long fz=fac(n,p,ppa),fm1=inv(fac(m,p,ppa),ppa),fm2=inv(fac(n-m,p,ppa),ppa);\r\n\t    long long mi=POW(p,sum_fac(n,p)-sum_fac(m,p)-sum_fac(n-m,p),ppa);\r\n\t    return fz*fm1%ppa*fm2%ppa*mi%ppa;\r\n\t}\r\n\tvoid getpr(long long n,long long m){\r\n\t    long long P=p;\r\n\t    for(long long i=2;i*i<=p;i++){\r\n\t        if(!(P%i)){\r\n\t            long long ppa=1;\r\n\t            while(!(P%i)) ppa*=i,P/=i;\r\n\t            pr[++cnt]=ppa;\r\n\t\t\t\tal[cnt]=C(n,m,i,ppa);\r\n\t        }\r\n\t    }\r\n\t    if(P!=1){\r\n\t    \tpr[++cnt]=P;\r\n\t\t\tal[cnt]=C(n,m,P,P);\r\n\t\t}\r\n\t}\r\n\tlong long crt()\t{\r\n\t    long long ans=0;\r\n\t    for(long long i=1;i<=cnt;i++){\r\n\t        long long M=p/pr[i],T=inv(M,pr[i]);\r\n\t        ans=(ans+al[i]*M%p*T%p)%p;\r\n\t    }\r\n\t    return ans;\r\n\t}\r\n\tlong long lucas(long long n,long long m,int pp){\r\n\t\tp=pp;\r\n\t\tgetpr(n,m);\r\n\t    return crt();\r\n\t}\r\n}\r\nnamespace data_str{//data structures\r\n\tstruct queue{//\u961f\u5217\r\n\t\tint h,t,q[stan::maxn];\r\n\t\tvoid push(int num){\r\n\t\t\tq[t++]=num;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvoid tot(){\r\n\t\t\th++;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tint pop(){\r\n\t\t\treturn q[t-1];\r\n\t\t}\r\n\t\tint size(){\r\n\t\t\treturn t-h;\r\n\t\t}\r\n\t};\r\n\tstruct stack{//\u6808\r\n\t\tint t,q[stan::maxn];\r\n\t\tvoid push(int num){\r\n\t\t\tq[t++]=num;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvoid tot(){\r\n\t\t\tt--;return;\r\n\t\t}\r\n\t\tint pop(){\r\n\t\t\treturn q[t-1];\r\n\t\t}\r\n\t\tint size(){\r\n\t\t\treturn t;\r\n\t\t}\r\n\t};\r\n\tstruct tree{//\u7ebf\u6bb5\u6811\r\n\t\tint m[stan::maxn*4];\r\n\t\tvoid build(int k,int l,int r,const int v[],int clac(int,int)){\r\n\t\t\tif(l==r){\r\n\t\t\t\tm[k]=v[l];\r\n\t\t\t\treturn ;\r\n\t\t\t}\r\n\t\t\tint mid=(l+r)/2;\r\n\t\t\tbuild(k*2,l,mid,v,clac);\r\n\t\t\tbuild(k*2+1,mid+1,r,v,clac);\r\n\t\t\tm[k]=clac(m[k*2],m[k*2+1]);\r\n\t\t}\r\n\t\tint find(int k,int l,int r,int aimx,int aimy,int clac(int,int)){\r\n\t\t\tif(r<aimx||l>aimy) return 0;//\u53ef\u4fee\u6539\r\n\t\t\tif(aimx<=l&&aimy>=r) return m[k];\r\n\t\t\tint mid=(l+r)/2;\r\n\t\t\treturn clac(find(k*2,l,mid,aimx,aimy,clac),find(k*2+1,mid+1,r,aimx,aimy,clac));\r\n\t\t}\r\n\t\tvoid change(int k,int l,int r,int x,int y,int v,int clac(int,int),int clac2(int,int)){\r\n\t\t\tif(r<x||l>y) return;\r\n\t\t\tif(l==r&&l>=x&&l<=y){\r\n\t\t\t\tm[k]=clac2(m[k],v);return;\r\n\t\t\t}\r\n\t\t\tint mid=(l+r)/2;\r\n\t\t\tchange(k*2,l,mid,x,y,v,clac,clac2);change(k*2+1,mid+1,r,x,y,v,clac,clac2);\r\n\t\t\tm[k]=clac(m[k*2],m[k*2+1]);\r\n\t\t}\r\n\t};\r\n\tstruct treap_point{\r\n\t\tint lc,rc,key,pri,cnt,sze;\r\n\t};\r\n\tstruct treap{\r\n\t\ttreap_point t[stan::maxn*2];\r\n\t\t#define lc(x) t[x].lc\r\n\t\t#define rc(x) t[x].rc\r\n\t\t#define v(x) t[x].key\r\n\t\t#define p(x) t[x].pri\r\n\t\t#define c(x) t[x].cnt\r\n\t\t#define s(x) t[x].sze\r\n\t\tint pool,rt;\r\n\t\tvoid ins(int x) {insert(rt,x);return;}\r\n\t\tvoid del(int x) {Delete(rt,x);return;}\r\n\t\tvoid upt(const int &x){\r\n\t\t\ts(x)=s(lc(x))+s(rc(x))+c(x);return;\r\n\t\t}\r\n\t\tvoid zig(int &k){\r\n\t\t\tint y=lc(k);lc(k)=rc(y);rc(y)=k;\r\n\t\t\ts(y)=s(k);upt(k);k=y;return;\r\n\t\t}\r\n\t\tvoid zag(int &k){\r\n\t\t\tint y=rc(k);rc(k)=lc(y);lc(y)=k;\r\n\t\t\ts(y)=s(k);upt(k);k=y;return;\r\n\t\t}\r\n\t\tvoid insert(int &k,const int &key){\r\n\t\t\tif(!k){\r\n\t\t\t\tk=++pool;v(k)=key;p(k)=rand();\r\n\t\t\t\tc(k)=1;s(k)=1;lc(k)=0;rc(k)=0;\r\n\t\t\t\treturn ;\r\n\t\t\t}\r\n\t\t\telse s(k)++;\r\n\t\t\tif(v(k)==key)c(k)++;\r\n\t\t\telse if(key<v(k)){\r\n\t\t\t\tinsert(lc(k),key);if(p(lc(k))<p(k))zig(k);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tinsert(rc(k),key);if(p(rc(k))<p(k))zag(k);\r\n\t\t\t}return;\r\n\t\t}\r\n\t\tvoid Delete(int &k,const int &key){\r\n\t\t\tif(v(k)==key){\r\n\t\t\t\tif(c(k)>1) c(k)--,s(k)--;\r\n\t\t\t\telse if(!lc(k)||!rc(k))k=lc(k)+rc(k);\r\n\t\t\t\telse if(p(lc(k))<p(rc(k)))zig(k),Delete(k,key);\r\n\t\t\t\telse zag(k),Delete(k,key);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ts(k)--;\r\n\t\t\tif(key<v(k))Delete(lc(k),key);\r\n\t\t\telse Delete(rc(k),key);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint qpre(const int &key){\r\n\t\t\tint x=rt,res=-0x3f3f3f3f;\r\n\t\t\twhile(x){\r\n\t\t\t\tif(key>v(x)) res=v(x),x=rc(x);\r\n\t\t\t\telse x=lc(x);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\r\n\t\tint qsuf(const int &key){\r\n\t\t\tint x=rt,res=0x3f3f3f3f;\r\n\t\t\twhile(x){\r\n\t\t\t\tif(key<v(x)) res=v(x),x=lc(x);\r\n\t\t\t\telse x=rc(x);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\r\n\t\tint qkth(int k){\r\n\t\t\tint x=rt;\r\n\t\t\twhile(x){\r\n\t\t\t\tif(s(lc(x))<k&&s(lc(x))+c(x)>=k) return v(x);\r\n\t\t\t\tif(s(lc(x))>=k)x=lc(x);\r\n\t\t\t\telse k-=s(lc(x))+c(x),x=rc(x);\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tint qrank(const int &key){\r\n\t\t\tint x=rt,res=0;\r\n\t\t\twhile(x){\r\n\t\t\t\tif(key==v(x))return res+s(lc(x))+1;\r\n\t\t\t\tif(key<v(x))x=lc(x);\r\n\t\t\t\telse res+=s(lc(x))+c(x),x=rc(x);\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t};\r\n}\r\nstruct node{\r\n\tint l,r;\r\n\tmutable int num;\r\n\tfriend bool operator < (node x,node y){\r\n\t\treturn x.l<y.l;\r\n\t}\r\n};\r\nstruct node2{\r\n\tint l,r;\r\n\tmutable int num;\r\n\tfriend bool operator < (const node2 x,const node2 y){\r\n\t\treturn x.num<y.num;\r\n\t}\r\n};\r\nset<node> Chtholly;\r\nset<node>::iterator brea(int x){\r\n\tset<node>::iterator it=Chtholly.lower_bound({x,0,0});\r\n\tif(it->l==x&&it!=Chtholly.end()) return it;\r\n\tit--;\r\n\tif(it->r<x) return Chtholly.end();\r\n\tint l=it->l,r=it->r,num=it->num;\r\n\tChtholly.erase(it);\r\n\tChtholly.insert({l,x-1,num});\r\n\treturn Chtholly.insert({x,r,num}).first;\r\n}\r\nvoid change(int l,int r,int num){\r\n\tset<node>::iterator ir=brea(r+1),il=brea(l);\r\n\tChtholly.erase(il,ir);\r\n\tChtholly.insert({l,r,num});\r\n}\r\nvoid add(int l,int r,int num2){\r\n\tset<node>::iterator ir=brea(r+1),il=brea(l);\r\n\t//puts(\"0\");\r\n\tfor(set<node>::iterator it=il;it!=ir;it++) it->num+=num2; \r\n}\r\nint sortC(int l,int r,int num){\r\n\tset<node>::iterator ir=brea(r+1),il=brea(l);\r\n\tvector<node2> q;\r\n\tfor(set<node>::iterator it=il;it!=ir;++it) q.push_back({it->l,it->r,it->num}); \r\n//\tfor(int i=0;;){\r\n//\t\tnode2 x=q.top();\r\n//\t\ti+=x.r-x.l+1;\r\n//\t\tif(i>=num) return x.num;\r\n//\t\tq.pop();\r\n//\t}\r\n\tsort(q.begin(),q.end());\r\n\tfor(int i=0;i<q.size();i++){\r\n\t\tnum-=q[i].r-q[i].l+1;\r\n\t\tif(num<=0) return q[i].num;\r\n\t}\r\n\treturn -1;\r\n}\r\nint ksm(const int &x,const int &y,const int &p){\r\n\tif(y==0) return 1;\r\n\tif(y==1) return x;\r\n\tlong long z=ksm(x%p,y/2,p);\r\n\tz=z*z%p;\r\n\tif(y&1) z=z*x%p;\r\n\treturn z;\r\n}\r\nint sigma(const int &l,const int &r,const int &x,const int &y){\r\n\tset<node>::iterator ir=brea(r+1),il=brea(l);\r\n\tint ans=0;\r\n\tfor(set<node>::iterator it=il;it!=ir;++it){\r\n\t\tans=(ans+(it->r-it->l+1)*ksm(it->num,x,y))%y; \r\n\t} \r\n\treturn ans;\r\n}\r\nint seed,vmax;\r\nint rd(){\r\n\tint ret=seed;\r\n\tseed=(seed*7+13)%1000000007;\r\n\treturn ret;\r\n}\r\nsigned main()\r\n{\r\n\tint t,n;\r\n\tcin>>n>>t>>seed>>vmax;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint x=rd()%vmax+1;\r\n\tChtholly.insert({i,i,x});\r\n\t}\r\n\twhile(t--){\r\n\t\tint k,l,r,x,y=-1,ans;\r\n\t\tk=rd()%4+1;l=rd()%n+1;r=rd()%n+1;\r\n\t\tif(l>r)swap(l,r);\r\n\t\tif(k==3) x=rd()%(r-l+1)+1;\r\n\t\telse x=rd()%vmax+1;\r\n\t\tif(k==4) y=rd()%vmax+1;\r\n//\t\tprintf(\"\\n%d %d %d %d %d\\n\",k,l,r,x,y);\r\n\t\tif(k==1) add(l,r,x);\r\n\t\telse if(k==2) change(l,r,x);\r\n\t\telse if(k==3) ans=sortC(l,r,x);\r\n\t\telse {\r\n\t\t\tans=sigma(l,r,x,y);\r\n\t\t} \r\n\t\tif(k>2)printf(\"%lld\\n\",ans);\r\n\t}\r\n     return 0;\r\n}\r\n\r\n\r\n\r\n"
}