{
    "id": 233682767,
    "contestId": 1419,
    "creationTimeSeconds": 1700568609,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1419,
        "index": "C",
        "name": "Killjoy",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1500,
        "tags": [
            "greedy",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 1419,
        "members": [
            {
                "handle": "NathanB"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1600526100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;\r\ntemplate <typename T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate<typename T>\r\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\nstruct custom_hash_pair {\r\n\tstatic uint64_t splitmix64(uint64_t x) {\r\n\t\tx += 0x9e3779b97f4a7c15;\r\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n\t\treturn x ^ (x >> 31);\r\n\t}\r\n\r\n\tsize_t operator()(pair<uint64_t,uint64_t> x) const {\r\n\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n\t\treturn splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1);\r\n\t}\r\n};\r\n\r\n#define all(x) (x).begin(), (x).end()\r\n#define allg(x) (x).begin(), (x).end(), greater<int>()\r\nusing ull = unsigned long long;\r\nusing ll =  long long;\r\nusing ld = double;\r\nusing vi = vector<int>;\r\nusing vb = vector<bool>;\r\nusing vl = vector<ll>;\r\nusing vd = vector<ld>;\r\nusing si = set<int>;\r\nusing ssi = set<si>;\r\nusing sl = set<ll>;\r\nusing ssl = set<sl>;\r\nusing vvi = vector<vi>;\r\nusing vvb = vector<vb>;\r\nusing vvl = vector<vl>;\r\nusing pii = pair<int,int>;\r\nusing pll = pair<ll,ll>;\r\nusing vs = vector<string>;\r\nusing vpi = vector<pii>;\r\nusing vpl = vector<pll>;\r\nusing vvpl = vector<vpl>;\r\n#define umap unordered_map\r\n#define eb emplace_back\r\n#define pb push_back\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define mp make_pair\r\n#define ff first\r\n#define ss second\r\n#define ar array\r\ninline void yn(bool b)\r\n{\r\n    if(b==true)\r\n        cout<<\"Yes\\n\";\r\n    else\r\n        cout<<\"No\\n\";\r\n}\r\n  inline void fastio() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(nullptr);\r\n  cout.tie(nullptr);\r\n}\r\n\r\nll Mod;\r\n\r\ntemplate <typename T> struct Fenwick {\r\n    vector<T> a;\r\n    int n;\r\n    Fenwick(): a(),n(0) {}\r\n    Fenwick(int _n){\r\n        n = _n;\r\n        a = vector<T>(n, T());\r\n    }\r\n    void clear(){\r\n    a = vector<T>(n,T());\r\n    }\r\n    void add(int p, T x){\r\n    for(;p < n ; p |= p+1)\r\n        a[p] += x;\r\n    }\r\n    T get(int p){\r\n    if(p < 0 ) return T();\r\n    p = min(p,n-1);\r\n    T res = T();\r\n    for(;p >= 0 ; p  = (p & (p+1)) - 1)\r\n        res += a[p];\r\n    return res;\r\n    }\r\n    T getSum(int l,int r){\r\n    return get(r-1) - get(l-1);\r\n    }\r\n};\r\n\r\ntemplate<typename T> struct SegmentProd{\r\n    vector<T> adi;\r\n    int n;\r\n    SegmentProd(): adi(), n(0) {}\r\n    SegmentProd(int _n){\r\n        n=_n;\r\n        adi = vector<T>(4*n, (T)1);\r\n    }\r\n    void clear(){\r\n    adi = vector<T>(4*n,(T)1);\r\n    }\r\n    void update(int poz,ll val){\r\n        updateintern(1,1,n,poz,val);\r\n    }\r\n    ll query(int st,int dr){\r\n        return (queryintern(1,1,n,st,dr) % Mod);\r\n    }\r\n\r\n    ll queryintern(int nod,int st,int dr,int ST,int DR)\r\n    {\r\n        if(st>=ST && dr<=DR) return adi[nod] % Mod;\r\n        int mij = (st+dr)/2;\r\n        ll a=1,b=1;\r\n        if(mij >= ST)\r\n            a = queryintern(2*nod,st,mij,ST,DR);\r\n        if(mij<DR)\r\n            b = queryintern(2*nod+1,mij+1,dr,ST,DR);\r\n        return (a*b)%Mod;\r\n    }\r\n\r\n    void updateintern(int nod,int st,int dr,int poz,ll val)\r\n    {\r\n        if(st==dr)\r\n            {adi[nod] = val;\r\n            return;}\r\n        ll mij = (st+dr)/2;\r\n        if(poz <= mij)\r\n            updateintern(2*nod,st,mij,poz,val);\r\n        else updateintern(2*nod+1,mij+1,dr,poz,val);\r\n        if(st!=dr)\r\n        adi[nod] = (adi[2*nod] * adi[2*nod+1]) % Mod;\r\n    }\r\n};\r\n\r\ntemplate <typename T> struct SegmentSum{\r\n    vector<T> adi;\r\n    int n;\r\n    SegmentSum(): adi(), n(0) {}\r\n    SegmentSum(int _n){\r\n    n = _n;\r\n    adi = vector<T>(4*n,(T)0);\r\n    }\r\n    void clear(){\r\n    adi = vector<T>(4*n,0);\r\n    }\r\n    void update(int poz,int val){\r\n    updateintern(1,1,n,poz,val);\r\n    }\r\n    void updateintern(int nod,int st,int dr,int poz,int val)\r\n    {\r\n        if(st==dr){\r\n            adi[nod] = val;\r\n            return;\r\n        }\r\n        int mij = (st+dr)/2;\r\n        if(poz<=mij)\r\n            updateintern(2*nod,st,mij,poz,val);\r\n        else updateintern(2*nod+1,mij+1,dr,poz,val);\r\n        if(st!=dr)\r\n        adi[nod] = (adi[2*nod] + adi[2*nod+1]) % Mod;\r\n    }\r\n    ll query(int st,int dr){\r\n    return queryintern(1,1,n,st,dr);\r\n    }\r\n    ll queryintern(int nod,int st,int dr,int ST,int DR){\r\n    if(st>=ST && dr<=DR) return adi[nod];\r\n    ll a = 0, b = 0;\r\n    ll mij = (st+dr)/2;\r\n    if(mij >= ST) a = queryintern(2*nod,st,mij,ST,DR);\r\n    if(mij < DR) b = queryintern(2*nod+1,mij+1,dr,ST,DR);\r\n    return a+b;\r\n    }\r\n};\r\n\r\nconst string TASK(\"trie\");\r\nifstream fin(TASK + \".in\");\r\nofstream fout(TASK + \".out\");\r\n//#define cin fin\r\n//#define cout fout\r\nint di[]={0,0,-1,1},dj[]={-1,1,0,0};\r\nint d8i[]={-1,-1,-1,0,0,1,1,1},d8j[]={-1,0,1,-1,1,-1,0,1};\r\nconst int Inf = 0x3f3f3f3f;\r\nbool testCase = true;\r\nconst ll Nmax=2e5+1;\r\n\r\n\r\nvoid solve_testcase()\r\n{\r\n    int n,k;\r\n    cin>>n>>k;\r\n    ll dif = 0;\r\n    bool ok = true;\r\n    bool ok2 = false;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        int c;\r\n        cin>>c;\r\n        if(c!=k) ok = false;\r\n        else ok2 = true;\r\n        dif += k-c;\r\n    }\r\n    if(ok) cout<<0<<'\\n';\r\n    else if(dif == 0 || ok2) cout<<1<<'\\n';\r\n    else cout<<2<<'\\n';\r\n}\r\n\r\n/// Check for interruption of input!!\r\n\r\nint main() {\r\n    fastio();\r\n    int t=1;\r\n    if (testCase) cin >> t;\r\n    while (t--) solve_testcase();\r\n      return 0;\r\n}\r\n"
}