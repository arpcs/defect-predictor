{
    "id": 230984451,
    "contestId": 1380,
    "creationTimeSeconds": 1698933617,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1380,
        "index": "F",
        "name": "Strange Addition",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "data structures",
            "dp",
            "matrices"
        ]
    },
    "author": {
        "contestId": 1380,
        "members": [
            {
                "handle": "MridulAhi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1594565100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 280,
    "memoryConsumedBytes": 60313600,
    "source": "//#pragma GCC optimize(\"O3\")\r\n//#pragma GCC optimize(\"Ofast\")\r\n//#pragma GCC optimize(\"unroll-loops\")\r\n//#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n\r\n\r\n#include<bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n\r\nstruct custom_hash {\r\n        static uint64_t splitmix64(uint64_t x) {\r\n                // http://xorshift.di.unimi.it/splitmix64.c\r\n                x += 0x9e3779b97f4a7c15;\r\n                x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n                x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n                return x ^ (x >> 31);\r\n        }\r\n\r\n        size_t operator()(uint64_t x) const {\r\n                static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n                return splitmix64(x + FIXED_RANDOM);\r\n        }\r\n};\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\ntemplate<typename T>\r\nT rand(T a, T b){\r\n    return uniform_int_distribution<T>(a, b)(rng);\r\n}\r\n\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\r\ntypedef tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef vector<ll> vl;\r\ntypedef vector<int> vi;\r\n\r\n\r\n#define rep(i, a, b) for(int i = a; i < b; i++)\r\n#define all(x) begin(x), end(x)\r\n#define sz(x) static_cast<int>((x).size())\r\n#define int long long\r\n\r\nconst ll mod = 998244353;\r\nconst ll INF = 1e18;\r\n\r\n/* ----------------------------------------------------- GO DOWN ---------------------------------------------------------------------- */\r\n\r\nint norm (int x) {\r\n        if (x < 0) {\r\n                x += mod;\r\n        }\r\n        if (x >= mod) {\r\n                x -= mod;\r\n        }\r\n        return x;\r\n}\r\ntemplate<class T>\r\nT power(T a, int b) {\r\n        T res = 1;\r\n        for (; b; b /= 2, a *= a) {\r\n                if (b % 2) {\r\n                res *= a;\r\n                }\r\n        }\r\n        return res;\r\n}\r\nstruct Z {\r\n        int x;\r\n        Z(int x = 0) : x(norm(x)) {}\r\n        int val() const {\r\n                return x;\r\n        }\r\n        Z operator-() const {\r\n                return Z(norm(mod - x));\r\n        }\r\n        Z inv() const {\r\n                assert(x != 0);\r\n                return power(*this, mod - 2);\r\n        }\r\n        Z &operator*=(const Z &rhs) {\r\n                x = x * rhs.x % mod;\r\n                return *this;\r\n        }\r\n        Z &operator+=(const Z &rhs) {\r\n                x = norm(x + rhs.x);\r\n                return *this;\r\n        }\r\n        Z &operator-=(const Z &rhs) {\r\n                x = norm(x - rhs.x);\r\n                return *this;\r\n        }\r\n        Z &operator/=(const Z &rhs) {\r\n                return *this *= rhs.inv();\r\n        }\r\n        friend Z operator*(const Z &lhs, const Z &rhs) {\r\n                Z res = lhs;\r\n                res *= rhs;\r\n                return res;\r\n        }\r\n        friend Z operator+(const Z &lhs, const Z &rhs) {\r\n                Z res = lhs;\r\n                res += rhs;\r\n                return res;\r\n        }\r\n        friend Z operator-(const Z &lhs, const Z &rhs) {\r\n                Z res = lhs;\r\n                res -= rhs;\r\n                return res;\r\n        }\r\n        friend Z operator/(const Z &lhs, const Z &rhs) {\r\n                Z res = lhs;\r\n                res /= rhs;\r\n                return res;\r\n        }\r\n        friend std::istream &operator>>(std::istream &is, Z &a) {\r\n                int v;\r\n                is >> v;\r\n                a = Z(v);\r\n                return is;\r\n        }\r\n        friend std::ostream &operator<<(std::ostream &os, const Z &a) {\r\n                return os << a.val();\r\n        }\r\n};\r\n\r\n\r\nZ c[20];\r\n\r\nsigned main() {\r\n\r\n        ios::sync_with_stdio(0);\r\n        cin.tie(0);\r\n        cout.tie(0);\r\n\r\n        int n, m;\r\n        cin >> n >> m;\r\n\r\n        for (int i = 0; i < 10; i++) c[i] = i + 1;\r\n        for (int i = 10; i < 20; i++) c[i] = i + 1 - 2 * (i - 9);\r\n\r\n        vector<vector<Z>> dp(5e5 + 1, vector<Z>(10));\r\n        for (int i = 0; i < 10; i++) {\r\n                dp[0][i] = c[i];\r\n                dp[1][i] = c[i + 10] + c[i] * c[1];\r\n        }\r\n\r\n        for (int i = 2; i <= (int)5e5; i++) {\r\n                for (int j = 0; j < 10; j++) {\r\n                        dp[i][j] = dp[i - 1][j] * c[1] + dp[i - 2][j] * c[11];\r\n                }\r\n        }\r\n\r\n        set<int> st;\r\n        string s;\r\n        cin >> s;\r\n        Z ans = 1;\r\n        st.insert(-1);\r\n        for (int i = 0; i < n; i++) {\r\n                if (i < n - 1 && s[i] == '1') continue;\r\n                int prev = *st.rbegin();\r\n                st.insert(i);\r\n                ans *= dp[i - prev - 1][(int)s[i] - '0'];\r\n        }\r\n        \r\n        while (m--) {\r\n\r\n                int i, j;\r\n                cin >> i >> j;\r\n                i--;\r\n\r\n                if (i == n - 1) {\r\n                        auto it = st.lower_bound(i);\r\n                        it--;\r\n                        int prev = *it;\r\n                        ans /= dp[i - prev - 1][(int)s[i] - '0'];\r\n                        s[i] = '0' + j;\r\n                        ans *= dp[i - prev - 1][(int)s[i] - '0'];\r\n                        cout << ans << \"\\n\";\r\n                        continue;\r\n                }\r\n\r\n                if (s[i] == '1') {\r\n                        if (j == 1) {\r\n                                cout << ans << \"\\n\";\r\n                                continue;\r\n                        }\r\n                        auto it = st.lower_bound(i);\r\n                        int i2 = *it;\r\n                        it--;\r\n                        int prev = *it;\r\n                        ans /= dp[i2 - prev - 1][(int)s[i2] - '0'];\r\n                        st.insert(i);\r\n                        s[i] = '0' + j;\r\n                        ans *= dp[i2 - i - 1][(int)s[i2] - '0'];\r\n                        ans *= dp[i - prev - 1][(int)s[i] - '0'];\r\n                        cout << ans << \"\\n\";\r\n                }\r\n                else {\r\n                        if (j == 1) {\r\n                                auto it = st.lower_bound(i);\r\n                                it--;\r\n                                int prev = *it;\r\n                                it++; it++;\r\n                                int i2 = *it;\r\n                                ans /= dp[i - prev - 1][(int)s[i] - '0'];\r\n                                ans /= dp[i2 - i - 1][(int)s[i2] - '0'];\r\n                                ans *= dp[i2 - prev - 1][(int)s[i2] - '0'];\r\n                                s[i] = '1';\r\n                                cout << ans << \"\\n\";\r\n                                continue;\r\n                        }\r\n                        auto it = st.lower_bound(i);\r\n                        it--;\r\n                        int prev = *it;\r\n                        ans /= dp[i - prev - 1][(int)s[i] - '0'];\r\n                        s[i] = '0' + j;\r\n                        ans *= dp[i - prev - 1][(int)s[i] - '0'];\r\n                        cout << ans << \"\\n\";\r\n                }\r\n\r\n        }\r\n       \r\n}"
}