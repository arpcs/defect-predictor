{
    "id": 226768476,
    "contestId": 1612,
    "creationTimeSeconds": 1696523166,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1612,
        "index": "B",
        "name": "Special Permutation",
        "type": "PROGRAMMING",
        "rating": 900,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1612,
        "members": [
            {
                "handle": "c_real_killer"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1637573700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 102400,
    "source": "//-----------------------X LET YOUR SUCCESS MAKE THE NOISE X-----------------------------------------------\r\n\r\n   \r\n    /*\r\n    \r\n    \r\n?????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????\r\n \r\n??????????????????????????\r\n??????????????????????????\r\n??????????????????????????\r\n??????????????????????????\r\n??????????????????????????\r\n??????????????????????????\r\n \r\n?????????????????????????????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????????????????????????????\r\n \r\n?????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????????????\r\n \r\n????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????\r\n \r\n????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????\r\n \r\n???????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????\r\n \r\n??????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????\r\n \r\n???????????????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????????????\r\n \r\n????????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????????\r\n \r\n??????????????????????????????????????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????????????????????????????????????????????\r\n \r\n?????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????\r\n?????????????????????????????????????????????????????????????????????????????\r\n \r\n???????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????\r\n \r\n???????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????\r\n???????????????????????????????????????????????????????????????????????????????????????????????\r\n \r\n??????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????\r\n??????????????????????????????????????????????????????????\r\n \r\n????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????\r\n????????????????????????????????????????????????????????????????????????????????????????????\r\n    \r\n    */\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntemplate <typename T> using ordered_set = tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>;\r\n// order_of_key: The number of items in a set that are strictly smaller than k\r\n// find_by_order: It returns an iterator to the ith largest element\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define ld long double\r\n#define __test ll _tc;cin>>_tc;while(_tc--)\r\n#define an \"\\n\"\r\n#define nl cout<<an\r\n#define yes cout<<\"YES\"<<an\r\n#define no cout<<\"NO\"<<an\r\n#define ms1 cout<<-1<<an\r\n#define zr0 cout<<0<<an\r\n#define FULL_THROTTLE ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\r\n#define mod7 1000000007\r\n#define modlu 998244353\r\n#define pb push_back\r\n#define srtf(x_) sort(x_.begin(),x_.end())\r\n#define srtb(x_) sort(x_.begin(),x_.end(),greater<int>())\r\n#define print(__v) for(int __i=0;__i<__v.size();++__i){ cout<<__v[__i]<<\" \";}\r\n\r\nconst int mod=1e9+7;\r\n\r\n\r\n\r\n\r\n\r\nint getDifferentNumber2(vector<int>&arr) {\r\n      \r\n    int n=arr.size();\r\n    vector<int> b;\r\n    for(int i=0;i<n;i++){\r\n    \tb.push_back(arr[i]);\r\n\t}\r\n\tsort(b.begin(),b.end());\r\n    for (int i=0;i<n;i++) {\r\n      if(b[i]!=i){\r\n        return i;\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n\r\nbool is_prime(int num_){\r\n    \r\n     if (num_<=1){\r\n        return false;\r\n    }\r\n    if(num_<=3){\r\n        return true;\r\n    }\r\n    else if(num_%2==0||num_%3==0){\r\n        return false;\r\n    }\r\n    else{\r\n        for(int i=5;i*i<=num_;i+=6){\r\n            if(num_%i==0||num_%(i+2)==0){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nbool ispow(int y, int x){\r\n    \r\n    int res1 = log(y) / log(x);\r\n    double res2 = log(y) / log(x); \r\n    return (res1 == res2);\r\n}\r\n\r\nstatic bool srtb2(const pair<int,int> &a,const pair<int,int> &b)\r\n{\r\n    if (a.first < b.first)return false;\r\n    else if (a.first > b.first)return true;\r\n    return a.second < b.second;\r\n}\r\n\r\n\r\n\r\n\r\nll fact(ll n)\r\n{\r\n      if(n==0)\r\n      return 1;\r\n    ll res = 1;\r\n    for (ll i = 2; i <= n; i++)\r\n        res = res * i;\r\n    return res;\r\n}\r\n\r\nll ncr(ll nn,ll mm){\r\n        return (fact(nn)/(fact(nn-mm)*fact(mm)));\r\n}\r\n\r\nvoid prt(ll val,vector<ll>&mul)\r\n{\r\n    \r\n    for (ll i=1; i<=sqrt(val); i++)\r\n    {\r\n        if (val%i == 0)\r\n        {\r\n        \r\n            if (val/i == i)\r\n                mul.push_back(i);\r\n \r\n            else{\r\n                   mul.push_back(i);\r\n                   mul.push_back(val/i);\r\n            } \r\n               \r\n        }\r\n    }\r\n}\r\n\r\n\r\nint cntsubstr(string& str, string& sub)\r\n{\r\n    if (sub.length() == 0) return 0;\r\n    int count = 0;\r\n    for (size_t offset = str.find(sub); offset != std::string::npos;\r\n     offset = str.find(sub, offset + sub.length()))\r\n    {\r\n        ++count;\r\n    }\r\n    return count;\r\n}\r\nll cntdiv(ll n)\r\n{\r\n   ll cnt = 0;\r\n    for (ll i = 1; i <= sqrt(n); i++) {\r\n        if (n % i == 0) {\r\n            // If divisors are equal,\r\n            // count only one\r\n            if (n / i == i)\r\n                cnt++;\r\n \r\n            else // Otherwise count both\r\n                cnt = cnt + 2;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\n\r\nint rev(int x)\r\n{\r\n\tint y=0;\r\n\tfor(int i=0;i<8;i++)\r\n\t\tif((x>>i)&1)y^=(1<<(7-i));\r\n\treturn y;\r\n}\r\n#define ull unsigned long long\r\n \r\null facto(int N)\r\n{\r\n \r\n   \r\n    ull f = 1; \r\n \r\n    \r\n    for (ull i = 2; i <= N; i++)\r\n        f = (1LL*f*i)%1000000007;\r\n \r\n    return f;\r\n}\r\nbool cp(unsigned long long n)\r\n{\r\n    unsigned long long reverse = 0;\r\n    unsigned long long temp = n;\r\n    while (temp != 0) {\r\n        reverse = (reverse * 10) + (temp % 10);\r\n        temp = temp / 10;\r\n    }\r\n    return (reverse == n); \r\n}\r\n\r\nbool cmp(const std::string& a, const std::string& b)\r\n{\r\n    return (a.size() > b.size()); \r\n}\r\nll mo(string num, ll aa)\r\n{\r\n    // Initialize result\r\n    ll res = 0;\r\n \r\n    // One by one process all digits of 'num'\r\n    for (ll i = 0; i < num.length(); i++)\r\n        res = (res * 10 + num[i] - '0') % aa;\r\n \r\n    return res;\r\n}\r\n\r\nbool cmp2(const pair<ll,string>&a, const pair<ll,string>&b)\r\n{\r\n    if(a.first==b.first) return (b.second < a.second);\r\n}\r\nstring addStrings(string x, string y) {\r\n        string ans=\"\";\r\n        int flag=0;\r\n        int i;\r\n        string str1=\"\";\r\n        int j=0;\r\n        while(x[j]=='0'){\r\n            j++;\r\n        }\r\n        while(j<x.size()){\r\n            str1+=x[j];\r\n            j++;\r\n        }\r\n        string str2=\"\";\r\n        j=0;\r\n        while(y[j]=='0'){\r\n            j++;\r\n        }\r\n        while(j<y.size()){\r\n            str2+=y[j];\r\n            j++;\r\n        }\r\n        i=str1.size()-1,j=str2.size()-1;\r\n        if(str1.size()==0 and str2.size()==0){\r\n            return \"0\";\r\n        }\r\n        while(i>=0 or j>=0){\r\n            if(i>=0 and j>=0){\r\n                int r=(str1[i]-'0')+(str2[j]-'0');\r\n                r+=flag;\r\n                flag=r/10;\r\n                string res=to_string(r%10);\r\n                ans+=res;\r\n                i--;\r\n                j--;\r\n            }\r\n            else if(j>=0){\r\n                int r=(str2[j]-'0')+flag;\r\n                flag=r/10;\r\n                ans+=to_string(r%10);\r\n                j--;\r\n            }\r\n            else if(i>=0){\r\n                int r=(str1[i]-'0')+flag;\r\n                flag=r/10;\r\n                ans+=to_string(r%10);\r\n                i--;\r\n            }\r\n        }\r\n        if(flag>0){\r\n            ans+=to_string(flag);\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n        return ans;\r\n    }\r\n\r\nbool is_sbsq(string child,string parent,int m,int n)\r\n{\r\n \r\n    if (m == 0)\r\n        return true;\r\n    if (n == 0)\r\n        return false;\r\n \r\n  \r\n    if (child[m - 1] == parent[n - 1])\r\n        return is_sbsq(child, parent, m - 1, n - 1);\r\n \r\n    \r\n    return is_sbsq(child, parent, m, n - 1);\r\n}\r\n\r\nll f(string &s,char ch){\r\n\tif(s.size()==1){\r\n\t\tif(s[0]!=ch) return 1;\r\n\t\treturn 0;\r\n\t}\r\n\tll mid=s.size()/2;\r\n\tstring str1=s.substr(0,mid);\r\n\tstring str2=s.substr(mid);\r\n\tll cnt1=f(str1,ch+1)+(mid-count(s.begin()+mid,s.end(),ch));\r\n\tll cnt2=f(str2,ch+1)+(mid-count(s.begin(),s.begin()+mid,ch));\r\n\treturn min(cnt1,cnt2);\r\n}\r\n\r\nbool isValid(string s) {\r\n       stack<char>st;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i]=='('||s[i]=='{'||s[i]=='[')\r\n                st.push(s[i]);\r\n            \r\n            else\r\n            {\r\n                if(st.empty())\r\n                   return 0;\r\n                    char x=st.top();\r\n                    st.pop();\r\n                    if(s[i]==')'&& x=='('||s[i]=='}' && x=='{' || s[i]==']' && x=='['){\r\n                       continue;\r\n                }\r\n                else\r\n                    return 0;        \r\n            \r\n        }\r\n            }\r\n        \r\n        if(st.empty())\r\n            return true;\r\n        \r\n        else return 0;\r\n        \r\n    }\r\n    \r\nbool palin(string arr){\r\n   \r\n    int n = arr.size();\r\n    int flag = 0;\r\n \r\n    for (int i = 0; i < (n+1) / 2; i++) {\r\n \r\n        \r\n        if (arr[i] != arr[n - i - 1]) {\r\n           return false;\r\n        }\r\n        return true;\r\n}\r\n}\r\n\r\nint find(ll v,vector<ll> &parent){\r\n    if(v==parent[v]){\r\n        return v;\r\n    }\r\n    return parent[v]=find(parent[v],parent);\r\n}\r\nvoid Union(ll a,ll b,vector<ll> &size,vector<ll> &parent){\r\n    a=find(a,parent);\r\n    b=find(b,parent);\r\n    if(a!=b){\r\n        if(size[a]<size[b]) swap(a,b);\r\n        parent[b]=a;\r\n        size[a]+=size[b]+0LL;\r\n    }\r\n}\r\n\r\nvoid xx(int i, vector<ll>&col,unordered_map<ll,vector<ll>>&mpp,int &f)\r\n{\r\n    for(int j = 0;j<mpp[i].size();++j)\r\n    {\r\n        if(col[mpp[i][j]]==-1)\r\n        {\r\n            col[mpp[i][j]] = 1-col[i];\r\n            xx(mpp[i][j],col,mpp,f);\r\n        }\r\n        else if(col[mpp[i][j]]==col[i])\r\n        {\r\n            f++;\r\n            break;\r\n        }\r\n    }\r\n}\r\nstatic bool cmppp(pair<pair<ll,ll>,ll> p1, pair<pair<ll,ll>,ll> p2){\r\n    if(p1.first.first<p2.first.first || (p1.first.first==p2.first.first && p1.first.second>p2.first.second))return true;\r\n    return false;\r\n}\r\n\r\nvector<ll>v,Tree, Lazy;\r\n\r\nvoid buildTree(ll tidx, ll lo, ll hi){\r\n\r\n\tif(lo==hi)\r\n\t{\r\n\t\tTree[tidx] = v[hi];\r\n\t\treturn;\r\n\t}\r\n\r\n\tll mid = (lo+hi)/2;\r\n\r\n\tbuildTree(2*tidx+1, lo, mid);\r\n\tbuildTree(2*tidx+2, mid+1, hi);\r\n\r\n\tTree[tidx] = (Tree[2*tidx+1] ^ Tree[2*tidx+2]);\r\n\r\n}\r\n\r\nvoid updateTree(ll tidx, ll lo, ll hi, ll idx, ll val){\r\n\r\n\tif(lo==hi){\r\n\t\tTree[tidx] = val;\r\n\t\treturn;\r\n\t}\r\n\r\n\tll mid = (lo+hi)/2;\r\n\r\n\tif(idx<=mid)\r\n\t\tupdateTree(2*tidx+1, lo, mid, idx, val);\r\n\telse\r\n\t\tupdateTree(2*tidx+2, mid+1, hi, idx, val);\r\n\r\n\tTree[tidx] = (Tree[2*tidx+1] ^ Tree[2*tidx+2]);\r\n\r\n}\r\n\r\nll query(ll tidx, ll lo, ll hi, ll L, ll R){\r\n\r\n\r\n\tif( R<lo || L>hi )\r\n\t\treturn 0;\r\n\r\n\t// In Range\r\n\tif( lo>=L && hi<=R )\r\n\t\treturn Tree[tidx];\r\n\r\n\t// Partial Overlap\r\n\tll mid = (lo+hi)/2;\r\n\tll leftans = query(2*tidx+1, lo, mid, L, R);\r\n\tll rightans = query(2*tidx+2, mid+1, hi, L, R);\r\n\r\n\treturn (leftans ^ rightans);\r\n\r\n}\r\n\r\nvoid rangeUpdate(ll treeIndex, ll lo, ll hi, ll i, ll j, ll val)\r\n{\r\n    if (Lazy[treeIndex] != 0) \r\n    {                             \r\n        Tree[treeIndex] += (hi - lo + 1) * Lazy[treeIndex]; \r\n        if (lo != hi)\r\n        {                                    \r\n            Lazy[2 * treeIndex + 1] += Lazy[treeIndex];\r\n            Lazy[2 * treeIndex + 2] += Lazy[treeIndex];\r\n        }\r\n\r\n        Lazy[treeIndex] = 0;                                \r\n    }\r\n    if (lo > hi || lo > j || hi < i) return;                                            \r\n\r\n    if (i <= lo && hi <= j) \r\n    {                               \r\n        Tree[treeIndex] += (hi - lo + 1) * val;            \r\n\r\n        if (lo != hi) \r\n        {                                    \r\n            Lazy[2 * treeIndex + 1] += val;\r\n            Lazy[2 * treeIndex + 2] += val;\r\n        }\r\n\r\n        return;\r\n    }\r\n    ll mid = lo + (hi - lo) / 2;                            \r\n    rangeUpdate(2 * treeIndex + 1, lo, mid, i, j, val);\r\n    rangeUpdate(2 * treeIndex + 2, mid + 1, hi, i, j, val);\r\n    Tree[treeIndex] = Tree[2 * treeIndex + 1] + Tree[2 * treeIndex + 2];\r\n}\r\n\r\nll queryLazySegTree(ll treeIndex, ll lo, ll hi, ll i, ll j)\r\n{\r\n   \r\n    if (lo > j || hi < i)                                \r\n        return 0;                                          \r\n\r\n    if (Lazy[treeIndex] != 0)\r\n    {                            \r\n        Tree[treeIndex] += (hi - lo + 1) * Lazy[treeIndex]; \r\n\r\n        if (lo != hi) {                               \r\n            Lazy[2 * treeIndex + 1] += Lazy[treeIndex];\r\n            Lazy[2 * treeIndex + 2] += Lazy[treeIndex];\r\n        }\r\n\r\n        Lazy[treeIndex] = 0;                         \r\n    }\r\n\r\n    if (i <= lo && j >= hi) return Tree[treeIndex];\r\n    int mid = lo + (hi - lo) / 2;                          \r\n    if (i > mid) return queryLazySegTree(2 * treeIndex + 2, mid + 1, hi, i, j);\r\n    else if (j <= mid) return queryLazySegTree(2 * treeIndex + 1, lo, mid, i, j);\r\n    ll leftQuery = queryLazySegTree(2 * treeIndex + 1, lo, mid, i, mid);\r\n    ll rightQuery = queryLazySegTree(2 * treeIndex + 2, mid + 1, hi, mid + 1, j);\r\n    return leftQuery + rightQuery;\r\n}\r\n\r\nvoid mr_kamran(){\r\n\r\nll n,a,b;\r\ncin>>n>>a>>b;\r\nvector<ll>l,r;\r\nfor(int i=1;i<=n;++i)\r\n{\r\n    if(i==a || i==b) continue;\r\n    else if(i<b && r.size()<(n/2-1)) r.push_back(i);\r\n    else if(i>a) l.push_back(i);\r\n}\r\n/*for(auto it : l) cout<<it<<\" \";\r\nnl;\r\nfor(auto it : r) cout<<it<<\" \";*/\r\nvector<ll>v;\r\nv.push_back(a);\r\nfor(auto it : l) v.push_back(it);\r\nfor(auto it : r) v.push_back(it);\r\nv.push_back(b);\r\nll mini = INT_MAX;\r\nll maxi = INT_MIN;\r\nfor(int i = 0;i<n/2;++i) mini = min(mini, v[i]);\r\nfor(int i = n/2;i<n;++i) maxi = max(maxi, v[i]);\r\nif(mini!=a || maxi!=b)\r\n{\r\n    cout<<-1<<an;\r\n    return;\r\n}\r\nfor(auto it : v) cout<<it<<\" \";\r\nnl;\r\n\r\n\r\n\r\n}\r\n\r\nint main(){\r\n    \r\nFULL_THROTTLE\r\n//freopen(\"input.txt\", \"r\", stdin);\r\n//freopen(\"output.txt\", \"w\", stdout);\r\n\r\n__test{\r\n   \r\n  mr_kamran();   \r\n}\r\n\treturn 0;\r\n}",
    "defect_evaluation_v4": {
        "good solution": 80,
        "wrong solution": 20,
        "compilation error": 0,
        "runtime error": 0
    },
    "category_evaluation": {
        "mathematics": 10,
        "dynamic programming": 20,
        "bit manipulation": 10,
        "greedy": 20,
        "brute force": 30,
        "graphs": 20,
        "sortings": 20,
        "search": 20,
        "trees": 20,
        "strings": 30,
        "number theory": 10,
        "combinatorics": 10,
        "two pointers": 20,
        "geometry": 10,
        "shortest paths": 10,
        "divide and conquer": 10,
        "probabilities": 10,
        "data structures": 30,
        "game theory": 10,
        "2d, 3d": 10,
        "recursive": 10,
        "well-commented": 100,
        "self-documenting": 100,
        "complex": 20,
        "readable": 20,
        "well-named": 100,
        "efficient": 30,
        "reusable": 30,
        "documented": 100,
        "good error-handling": 30,
        "good solution": 30,
        "compilation error": 20,
        "runtime error": 20
    }
}