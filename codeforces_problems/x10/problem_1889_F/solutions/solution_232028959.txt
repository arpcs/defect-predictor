{
    "id": 232028959,
    "contestId": 1889,
    "creationTimeSeconds": 1699513992,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1889,
        "index": "F",
        "name": "Doremy's Average Tree",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1889,
        "members": [
            {
                "handle": "ritvikprathapani"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1698503700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 116,
    "timeConsumedMillis": 1388,
    "memoryConsumedBytes": 74649600,
    "source": "#include <algorithm>\r\n#include <array>\r\n#include <bitset>\r\n#include <cassert>\r\n#include <chrono>\r\n#include <climits>\r\n#include <cmath>\r\n#include <complex>\r\n#include <cstring>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <map>\r\n#include <numeric>\r\n#include <queue>\r\n#include <random>\r\n#include <set>\r\n#include <vector>\r\nusing namespace std;\r\n \r\nusing ll = long long;\r\nusing db = long double;  // or double, if TL is tight\r\nusing str = string;      // yay python!\r\n \r\n// pairs\r\nusing pi = pair<int, int>;\r\nusing pl = pair<ll, ll>;\r\nusing pd = pair<db, db>;\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n \r\n#define tcT template <class T\r\n#define tcTU tcT, class U\r\n// ^ lol this makes everything look weird but I'll try it\r\ntcT > using V = vector<T>;\r\ntcT, size_t SZ > using AR = array<T, SZ>;\r\nusing vi = V<int>;\r\nusing vb = V<bool>;\r\nusing vl = V<ll>;\r\nusing vd = V<db>;\r\nusing vs = V<str>;\r\nusing vpi = V<pi>;\r\nusing vpl = V<pl>;\r\nusing vpd = V<pd>;\r\n \r\n// vectors\r\n// oops size(x), rbegin(x), rend(x) need C++17\r\n#define sz(x) int((x).size())\r\n#define bg(x) begin(x)\r\n#define all(x) bg(x), end(x)\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define sor(x) sort(all(x))\r\n#define rsz resize\r\n#define ins insert\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ft front()\r\n#define bk back()\r\n \r\n#define lb lower_bound\r\n#define ub upper_bound\r\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\r\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\r\n \r\n// loops\r\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i, a) FOR(i, 0, a)\r\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i, a) ROF(i, 0, a)\r\n#define rep(a) F0R(_, a)\r\n#define each(a, x) for (auto &a : x)\r\n \r\nconst int MOD = 998244353;  // 1e9+7;\r\nconst int MX = (int)2e5 + 5;\r\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\r\nconst db PI = acos((db)-1);\r\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\r\nmt19937 rng(0);\r\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\r\n \r\n// bitwise ops\r\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\r\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\r\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\r\n\t                         // USACO updates ...\r\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\r\n}  // floor(log2(x))\r\nconstexpr int p2(int x) { return 1 << x; }\r\nconstexpr int msk2(int x) { return p2(x) - 1; }\r\n \r\nll cdiv(ll a, ll b) {\r\n\treturn a / b + ((a ^ b) > 0 && a % b);\r\n}  // divide a by b rounded up\r\nll fdiv(ll a, ll b) {\r\n\treturn a / b - ((a ^ b) < 0 && a % b);\r\n}  // divide a by b rounded down\r\n \r\ntcT > bool ckmin(T &a, const T &b) {\r\n\treturn b < a ? a = b, 1 : 0;\r\n}  // set a = min(a,b)\r\ntcT > bool ckmax(T &a, const T &b) {\r\n\treturn a < b ? a = b, 1 : 0;\r\n}  // set a = max(a,b)\r\n \r\ntcTU > T fstTrue(T lo, T hi, U f) {\r\n\t++hi;\r\n\tassert(lo <= hi);  // assuming f is increasing\r\n\twhile (lo < hi) {  // find first index such that f is true\r\n\t\tT mid = lo + (hi - lo) / 2;\r\n\t\tf(mid) ? hi = mid : lo = mid + 1;\r\n\t}\r\n\treturn lo;\r\n}\r\ntcTU > T lstTrue(T lo, T hi, U f) {\r\n\t--lo;\r\n\tassert(lo <= hi);  // assuming f is decreasing\r\n\twhile (lo < hi) {  // find first index such that f is true\r\n\t\tT mid = lo + (hi - lo + 1) / 2;\r\n\t\tf(mid) ? lo = mid : hi = mid - 1;\r\n\t}\r\n\treturn lo;\r\n}\r\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\r\n\tsort(all(v));\r\n\tv.erase(unique(all(v)), end(v));\r\n}\r\ntcTU > void safeErase(T &t, const U &u) {\r\n\tauto it = t.find(u);\r\n\tassert(it != end(t));\r\n\tt.erase(it);\r\n}\r\n \r\ninline namespace IO {\r\n#define SFINAE(x, ...)                                                         \\\r\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\r\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\r\n \r\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\r\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\r\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\r\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\r\n \r\ntemplate <auto &is> struct Reader {\r\n\ttemplate <class T> void Impl(T &t) {\r\n\t\tif constexpr (DefaultI<T>::value) is >> t;\r\n\t\telse if constexpr (Iterable<T>::value) {\r\n\t\t\tfor (auto &x : t) Impl(x);\r\n\t\t} else if constexpr (IsTuple<T>::value) {\r\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\r\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\r\n\t}\r\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\r\n};\r\n \r\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\r\n#define def(t, args...)                                                        \\\r\n\tt args;                                                                    \\\r\n\tre(args);\r\n \r\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\r\n\tstring comma() const { return debug ? \",\" : \"\"; }\r\n\ttemplate <class T> constexpr char Space(const T &) const {\r\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\r\n\t\t                                                             : ' ';\r\n\t}\r\n\ttemplate <class T> void Impl(T const &t) const {\r\n\t\tif constexpr (DefaultO<T>::value) os << t;\r\n\t\telse if constexpr (Iterable<T>::value) {\r\n\t\t\tif (debug) os << '{';\r\n\t\t\tint i = 0;\r\n\t\t\tfor (auto &&x : t)\r\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\r\n\t\t\tif (debug) os << '}';\r\n\t\t} else if constexpr (IsTuple<T>::value) {\r\n\t\t\tif (debug) os << '(';\r\n\t\t\tstd::apply(\r\n\t\t\t    [this](auto const &...args) {\r\n\t\t\t\t    int i = 0;\r\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\r\n\t\t\t\t     ...);\r\n\t\t\t    },\r\n\t\t\t    t);\r\n\t\t\tif (debug) os << ')';\r\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\r\n\t}\r\n\ttemplate <class T> void ImplWrapper(T const &t) const {\r\n\t\tif (debug) os << \"\\033[0;31m\";\r\n\t\tImpl(t);\r\n\t\tif (debug) os << \"\\033[0m\";\r\n\t}\r\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\r\n\t\t((Impl(ts)), ...);\r\n\t}\r\n\ttemplate <class F, class... Ts>\r\n\tvoid print_with_sep(const std::string &sep, F const &f,\r\n\t                    Ts const &...ts) const {\r\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\r\n\t}\r\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\r\n};\r\n \r\ntemplate <class... Ts> void pr(Ts const &...ts) {\r\n\tWriter<cout, false, true>{}.print(ts...);\r\n}\r\ntemplate <class... Ts> void ps(Ts const &...ts) {\r\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\r\n}\r\n}  // namespace IO\r\n \r\ninline namespace Debug {\r\ntemplate <typename... Args> void err(Args... args) {\r\n\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);\r\n}\r\ntemplate <typename... Args> void errn(Args... args) {\r\n\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);\r\n}\r\n \r\nvoid err_prefix(str func, int line, string args) {\r\n\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\r\n\t     << \" | \"\r\n\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\r\n\t     << \":\"\r\n\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\r\n\t     << \" - \"\r\n\t     << \"[\" << args << \"] = \";\r\n}\r\n \r\n#ifdef LOCAL\r\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\r\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\r\n#else\r\n#define dbg(...)\r\n#define dbgn(args...)\r\n#endif\r\n \r\nconst auto beg_time = std::chrono::high_resolution_clock::now();\r\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\r\ndouble time_elapsed() {\r\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\r\n\t                                beg_time)\r\n\t    .count();\r\n}\r\n}  // namespace Debug\r\n \r\ninline namespace FileIO {\r\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\r\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\r\nvoid setIO(str s = \"\") {\r\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\r\n\tcout << fixed << setprecision(12);\r\n\t// cin.exceptions(cin.failbit);\r\n\t// throws exception when do smth illegal\r\n\t// ex. try to read letter into int\r\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\r\n}\r\n}  // namespace FileIO\r\n \r\n// make sure to intialize ALL GLOBAL VARS between tcs!\r\n \r\n/**\r\n * Description: Generate various types of trees.\r\n * Source: Own + Dhruv Rohatgi\r\n */\r\n \r\n////////////// DISTRIBUTIONS\r\n \r\n// return int in [L,R] inclusive\r\nint rng_int(int L, int R) {\r\n\tassert(L <= R);\r\n\treturn uniform_int_distribution<int>(L, R)(rng);\r\n}\r\nll rng_ll(ll L, ll R) {\r\n\tassert(L <= R);\r\n\treturn uniform_int_distribution<ll>(L, R)(rng);\r\n}\r\n \r\n// return double in [L,R] inclusive\r\ndb rng_db(db L, db R) {\r\n\tassert(L <= R);\r\n\treturn uniform_real_distribution<db>(L, R)(rng);\r\n}\r\n \r\n// http://cplusplus.com/reference/random/geometric_distribution/geometric_distribution/\r\n// flip a coin which is heads with probability p until you flip heads\r\n// mean value of c is 1/p-1\r\nint rng_geo(db p) {\r\n\tassert(0 < p && p <= 1);  // p large -> closer to 0\r\n\treturn geometric_distribution<int>(p)(rng);\r\n}\r\n \r\n////////////// VECTORS + PERMS\r\n \r\n// shuffle a vector\r\ntemplate <class T> void shuf(vector<T> &v) { shuffle(all(v), rng); }\r\n \r\n// generate random permutation of [0,N-1]\r\nvi randPerm(int N) {\r\n\tvi v(N);\r\n\tiota(all(v), 0);\r\n\tshuf(v);\r\n\treturn v;\r\n}\r\n \r\n// random permutation of [0,N-1] with first element 0\r\nvi randPermZero(int N) {\r\n\tvi v(N - 1);\r\n\tiota(all(v), 1);\r\n\tshuf(v);\r\n\tv.ins(bg(v), 0);\r\n\treturn v;\r\n}\r\n \r\n// shuffle permutation of [0,N-1]\r\nvi shufPerm(vi v) {\r\n\tint N = sz(v);\r\n\tvi key = randPerm(N);\r\n\tvi res(N);\r\n\tF0R(i, N) res[key[i]] = key[v[i]];\r\n\treturn res;\r\n}\r\n \r\n// vector with all entries in [L,R]\r\nvi rng_vec(int N, int L, int R) {\r\n\tvi res;\r\n\tF0R(_, N) res.pb(rng_int(L, R));\r\n\treturn res;\r\n}\r\n \r\n// vector with all entries in [L,R], unique\r\nvi rng_vec_unique(int N, int L, int R) {\r\n\tset<int> so_far;\r\n\tvi res;\r\n\tF0R(_, N) {\r\n\t\tint x;\r\n\t\tdo { x = rng_int(L, R); } while (so_far.count(x));\r\n\t\tso_far.ins(x);\r\n\t\tres.pb(x);\r\n\t}\r\n\treturn res;\r\n}\r\n \r\n////////////// GRAPHS\r\n \r\n// relabel edges ed according to perm, shuffle\r\nvpi relabelAndShuffle(vpi ed, vi perm) {\r\n\teach(t, ed) {\r\n\t\tt.f = perm[t.f], t.s = perm[t.s];\r\n\t\tif (rng() & 1) swap(t.f, t.s);\r\n\t}\r\n\tshuf(ed);\r\n\treturn ed;\r\n}\r\n \r\n// shuffle graph with vertices [0,N-1]\r\nvpi shufGraph(int N, vpi ed) {  // randomly swap endpoints, rearrange labels\r\n\treturn relabelAndShuffle(ed, randPerm(N));\r\n}\r\nvpi shufGraphZero(int N, vpi ed) {\r\n\treturn relabelAndShuffle(ed, randPermZero(N));\r\n}\r\n \r\n// shuffle tree given N-1 edges\r\nvpi shufTree(vpi ed) { return shufGraph(sz(ed) + 1, ed); }\r\n// randomly swap endpoints, rearrange labels\r\nvpi shufRootedTree(vpi ed) {\r\n\treturn relabelAndShuffle(ed, randPermZero(sz(ed) + 1));\r\n}\r\n \r\nvoid pgraphOne(int N, vpi ed) {\r\n\tps(N, sz(ed));\r\n\teach(e, ed) ps(1 + e.f, 1 + e.s);\r\n}\r\n \r\n////////////// GENERATING TREES\r\n \r\n// for generating tall tree\r\npi geoEdge(int i, db p) {\r\n\tassert(i > 0);\r\n\treturn {i, max(0, i - 1 - rng_geo(p))};\r\n}\r\n \r\n// generate edges of tree with verts [0,N-1]\r\n// smaller back -> taller tree\r\nvpi treeRand(int N, int back) {\r\n\tassert(N >= 1 && back >= 0);\r\n\tvpi ed;\r\n\tFOR(i, 1, N) ed.eb(i, i - 1 - rng_int(0, min(back, i - 1)));\r\n\treturn ed;\r\n}\r\n \r\n// generate path\r\nvpi path(int N) { return treeRand(N, 0); }\r\n \r\n// generate tall tree (large diameter)\r\n// the higher the p the taller the tree\r\nvpi treeTall(int N, db p) {\r\n\tassert(N >= 1);\r\n\tvpi ed;\r\n\tFOR(i, 1, N) ed.pb(geoEdge(i, p));\r\n\treturn ed;\r\n}\r\n \r\n// generate tall tree, then add rand at end\r\nvpi treeTallShort(int N, db p) {\r\n\tassert(N >= 1);\r\n\tint mid = (N + 1) / 2;\r\n\tvpi ed = treeTall(mid, p);\r\n\tFOR(i, mid, N) ed.eb(i, rng_int(0, i - 1));\r\n\treturn ed;\r\n}\r\n \r\n// lots of stuff connected to either heavy1 or heavy2\r\nvpi treeTallHeavy(int N, db p) {\r\n\tassert(N >= 1);  // + bunch of rand\r\n\tvpi ed;\r\n\tint heavy1 = 0, heavy2 = N / 2;\r\n\tFOR(i, 1, N) {\r\n\t\tif (i < N / 4) ed.eb(i, heavy1);\r\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\r\n\t\telse ed.pb(geoEdge(i, p));\r\n\t}\r\n\treturn ed;\r\n}\r\n \r\n// heavy tall tree + random\r\n// lots of verts connected to heavy1 or heavy2\r\nvpi treeTallHeavyShort(int N, db p) {\r\n\tassert(N >= 1);  // + almost-path + rand\r\n\tvpi ed;\r\n\tint heavy1 = 0, heavy2 = N / 2;\r\n\tFOR(i, 1, N) {\r\n\t\tif (i < N / 4) ed.eb(i, heavy1);\r\n\t\telse if (i <= heavy2) ed.pb(geoEdge(i, p));  // tall -> heavy1\r\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\r\n\t\telse ed.eb(i, rng_int(0, i - 1));\r\n\t}\r\n\treturn ed;\r\n}\r\n \r\nint rand_prime(int l, int r) {\r\n\twhile (1) {\r\n\t\tint x = rng_int(l, r);\r\n\t\tbool bad = 0;\r\n\t\tfor (int i = 2; i * i <= x; ++i)\r\n\t\t\tif (x % i == 0) bad = 1;\r\n\t\tif (!bad) return x;\r\n\t}\r\n}\r\n \r\nstruct Frac {\r\n\tll n, d;\r\n\tbool operator<(const Frac &o) const { return n * o.d < o.n * d; }\r\n\tbool operator==(const Frac &o) const { return n * o.d == o.n * d; }  // OK\r\n};\r\n \r\nostream &operator<<(ostream &os, const Frac &f) {\r\n\tos << \"Frac(\" << f.n << \", \" << f.d << \")\";\r\n\treturn os;\r\n}\r\n \r\nstruct RangeInfo {\r\n\tpair<int, Frac> d0, d1;\r\n\tbool single_value() const { return d1.f == INT_MAX; }\r\n\tpair<int, Frac> first_dif(Frac f) const {\r\n\t\tif (d0.s == f) return d1;\r\n\t\treturn d0;\r\n\t}\r\n\tbool greater_than(Frac f) {\r\n\t\tauto [idx, val] = first_dif(f);\r\n\t\tif (idx == INT_MAX) return false;\r\n\t\tassert(!(f == val));\r\n\t\treturn f < val;\r\n\t}\r\n\tbool greater_or_equal(Frac f) {\r\n\t\tauto [idx, val] = first_dif(f);\r\n\t\tif (idx == INT_MAX) return true;\r\n\t\tassert(!(f == val));\r\n\t\treturn f < val;\r\n\t}\r\n};\r\n \r\nostream &operator<<(ostream &os, const pair<int, Frac> &p) {\r\n\tos << \"{\" << p.f << \", \" << p.s << \"}\";\r\n\treturn os;\r\n}\r\n \r\nostream &operator<<(ostream &os, const RangeInfo &i) {\r\n\tos << \"RangeInfo{\" << i.d0 << \", \" << i.d1 << \"}\";\r\n\treturn os;\r\n}\r\n \r\nRangeInfo operator+(RangeInfo l, RangeInfo r) {\r\n\tif (l.d0.f > r.d0.f) swap(l, r);\r\n\tassert(l.d0.f < r.d0.f);\r\n\treturn RangeInfo{l.d0, min(l.d1, l.d0.s == r.d0.s ? r.d1 : r.d0)};\r\n}\r\n \r\nstruct Info {\r\n\tint k, first_different;\r\n\tpi prev_pair;\r\n\tRangeInfo r;\r\n};\r\n \r\nostream &operator<<(ostream &os, const Info &i) {\r\n\tos << \"Info{\" << i.k << \", \" << i.first_different << \", \"\r\n\t   << \"{\" << i.prev_pair.f << \", \" << i.prev_pair.s << \"}\"\r\n\t   << \", \" << i.r << \"}\";\r\n\treturn os;\r\n}\r\n \r\nInfo info_single(int x, int w) {\r\n\treturn {0, INT_MAX, {-1, -1}, RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}};\r\n}\r\n \r\nint N, K;\r\nV<V<Info>> dp, stor;\r\nvi W;\r\nV<vi> adj;\r\nvl sum;\r\nvi num;\r\n \r\nV<Info> conv(const V<Info> &dp_l, const V<Info> &dp_r) {\r\n\t// dbg(\"COMPUTING\", sz(dp_l), sz(dp_r));\r\n\tint max_ops = min(dp_l.bk.k + dp_r.bk.k, K);\r\n\tV<vpi> cands(max_ops + 1);\r\n\tF0R(i, sz(dp_l)) F0R(j, sz(dp_r)) if (dp_l[i].k + dp_r[j].k <= K) {\r\n\t\tcands[dp_l[i].k + dp_r[j].k].pb({i, j});\r\n\t}\r\n\tauto better_pair = [&](pi a, pi b) {\r\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\r\n\t\tswap(a, b);\r\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\r\n\t\tif (a.f > b.f) swap(a, b);\r\n\t\tassert(a.f < b.f && a.s > b.s);\r\n\t\tint min_dif_a = INT_MAX;\r\n\t\tFOR(i, a.f + 1, b.f + 1) ckmin(min_dif_a, dp_l.at(i).first_different);\r\n\t\tint min_dif_b = INT_MAX;\r\n\t\tFOR(i, b.s + 1, a.s + 1) ckmin(min_dif_b, dp_r.at(i).first_different);\r\n\t\tif (min_dif_a < min_dif_b) return b;\r\n\t\treturn a;\r\n\t};\r\n\tauto first_different = [&](pi a, pi b) {\r\n\t\tint min_dif = INT_MAX;\r\n\t\tFOR(i, min(a.f, b.f) + 1, max(a.f, b.f) + 1)\r\n\t\tckmin(min_dif, dp_l.at(i).first_different);\r\n\t\tFOR(i, min(a.s, b.s) + 1, max(a.s, b.s) + 1)\r\n\t\tckmin(min_dif, dp_r.at(i).first_different);\r\n\t\treturn min_dif;\r\n\t};\r\n\tvpi best;\r\n\tF0R(i, sz(cands)) {\r\n\t\twhile (sz(cands[i]) > 1) {\r\n\t\t\tend(cands[i])[-2] =\r\n\t\t\t    better_pair(end(cands[i])[-2], end(cands[i])[-1]);\r\n\t\t\tcands[i].pop_back();\r\n\t\t}\r\n\t\tif (sz(cands[i])) {\r\n\t\t\tif (sz(best) && better_pair(best.bk, cands[i].bk) == best.bk)\r\n\t\t\t\tcontinue;\r\n\t\t\tbest.pb(cands[i].bk);\r\n\t\t\t// ret.pb();\r\n\t\t}\r\n\t}\r\n\tV<Info> ndp;\r\n\tF0R(i, sz(best)) {\r\n\t\tauto [l, r] = best[i];\r\n\t\tndp.pb({dp_l[l].k + dp_r[r].k,\r\n\t\t        i == 0 ? INT_MAX : first_different(best.at(i - 1), best.at(i)),\r\n\t\t        {l, r},\r\n\t\t        dp_l[l].r + dp_r[r].r});\r\n\t}\r\n\treturn ndp;\r\n\t// V<Info> ndp;\r\n\t// F0R(ops, max_ops + 1) {  // SLOW\r\n\t// \tint l = 0, r = 0;\r\n\t// \tint last_mn = INT_MAX;\r\n\t// \twhile (true) {\r\n\t// \t\tint mn = INT_MAX;\r\n\t// \t\tpi best;\r\n\t// \t\tFOR(i, l + 1, sz(dp_l))\r\n\t// \t\tif (dp_l[i].k + dp_r[r].k <= ops) {\r\n\t// \t\t\tif (ckmin(mn, dp_l[i].first_different)) { best = {0, i}; }\r\n\t// \t\t} else break;\r\n\t// \t\tFOR(j, r + 1, sz(dp_r))\r\n\t// \t\tif (dp_l[l].k + dp_r[j].k <= ops) {\r\n\t// \t\t\tif (ckmin(mn, dp_r[j].first_different)) { best = {1, j}; }\r\n\t// \t\t} else break;\r\n\t// \t\tif (mn == INT_MAX) {\r\n\t// \t\t\tif (dp_l[l].k + dp_r[r].k == ops) {\r\n\t// \t\t\t\tndp.pb({ops, last_mn, {l, r}, dp_l[l].r + dp_r[r].r});\r\n\t// \t\t\t}\r\n\t// \t\t\tbreak;\r\n\t// \t\t} else {\r\n\t// \t\t\tif (best.f == 0) l = best.s;\r\n\t// \t\t\telse r = best.s;\r\n\t// \t\t\tlast_mn = mn;\r\n\t// \t\t}\r\n\t// \t}\r\n\t// }\r\n\t// return ret;\r\n}\r\n \r\nvoid construct(int x, int p) {\r\n\tsum[x] = W[x];\r\n\tnum[x] = 1;\r\n\tdp[x] = {info_single(x, W[x])};\r\n \r\n\t// {{INT_MAX, RangeInfo{{x, Frac{W[x], 1}}, {INT_MAX, {}}}}};\r\n\tfor (int y : adj[x])\r\n\t\tif (y != p) {\r\n\t\t\tconstruct(y, x);\r\n\t\t\tsum[x] += sum[y];\r\n\t\t\tnum[x] += num[y];\r\n\t\t\tauto ndp = conv(dp[x], dp[y]);\r\n\t\t\tswap(dp[x], stor[y]);\r\n\t\t\tswap(dp[x], ndp);\r\n\t\t}\r\n\tFrac f{sum[x], num[x]};\r\n\tif (!dp[x][0].r.greater_than(f)) return;\r\n\tif (sz(dp[x]) > 1) {\r\n\t\tassert(dp[x].at(1).k == 1);\r\n\t\tif (!dp[x].at(1).r.greater_than(f)) return;\r\n\t}\r\n\tint idx = 1;\r\n\twhile (idx < sz(dp[x]) && dp[x][idx].r.greater_or_equal(f)) ++idx;\r\n\tV<Info> ndp{dp[x][0]};\r\n\t{\r\n\t\tRangeInfo r{{dp[x][0].r.d0.f, f}, {INT_MAX, {}}};\r\n\t\tndp.pb({1, dp[x][0].r.first_dif(f).f, {-1, -1}, r});\r\n\t}\r\n\tif (idx < sz(dp[x])) {\r\n\t\tFOR(i, idx, sz(dp[x])) {\r\n\t\t\tassert(!dp[x][i].r.greater_or_equal(f));\r\n\t\t\tif (i == idx) {\r\n\t\t\t\tdp[x][i].first_different = dp[x][i].r.first_dif(f).f;\r\n\t\t\t\tndp.pb(dp[x][i]);\r\n\t\t\t} else {\r\n\t\t\t\tndp.pb(dp[x][i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tswap(dp[x], ndp);\r\n}\r\n \r\nvoid reconstruct(vi &ans, int idx, int x, int p) {\r\n\tif (idx == 0) return;\r\n\tassert(idx < sz(dp[x]));\r\n\tauto [lhs, rhs] = dp[x].at(idx).prev_pair;\r\n\tif (lhs == -1) {\r\n\t\tans.pb(x);\r\n\t\treturn;\r\n\t}\r\n\tassert(lhs >= 0 && rhs >= 0);\r\n\tR0F(y_idx, sz(adj[x])) {\r\n\t\tint y = adj[x][y_idx];\r\n\t\tif (y == p) continue;\r\n\t\tassert(lhs < sz(stor[y]));\r\n\t\tassert(rhs < sz(dp[y]));\r\n\t\treconstruct(ans, rhs, y, x);\r\n\t\ttie(lhs, rhs) = stor[y].at(lhs).prev_pair;\r\n\t}\r\n\tassert(lhs == -1 && rhs == -1);\r\n}\r\n \r\nstruct NaiveSol {\r\n\tV<pair<int, Frac>> result;\r\n\tvi moves;\r\n};\r\n \r\ntemplate <class T> V<T> operator+(V<T> a, V<T> b) {\r\n\ta.ins(end(a), all(b));\r\n\treturn a;\r\n}\r\n \r\nNaiveSol operator+(NaiveSol a, NaiveSol b) {\r\n\tNaiveSol c{a.result + b.result, a.moves + b.moves};\r\n\tsor(c.result);\r\n\treturn c;\r\n}\r\n \r\nV<NaiveSol> brute(int x, int p) {\r\n\tsum[x] = W[x];\r\n\tnum[x] = 1;\r\n\tV<NaiveSol> dp;\r\n\tdp.pb({{{x, Frac{W[x], 1}}}, {}});\r\n\tfor (int y : adj[x])\r\n\t\tif (y != p) {\r\n\t\t\tauto child_dp = brute(y, x);\r\n\t\t\tsum[x] += sum[y];\r\n\t\t\tnum[x] += num[y];\r\n\t\t\tV<NaiveSol> ndp;\r\n\t\t\tF0R(i, sz(dp)) F0R(j, sz(child_dp)) if (i + j <= K) {\r\n\t\t\t\tauto s = dp[i] + child_dp[j];\r\n\t\t\t\tif (i + j == sz(ndp)) {\r\n\t\t\t\t\tndp.pb(s);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (s.result < ndp.at(i + j).result) ndp.at(i + j) = s;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tswap(dp, ndp);\r\n\t\t}\r\n\t{\r\n\t\tauto result = dp.at(0).result;\r\n\t\teach(t, result) t.s = Frac{sum[x], num[x]};\r\n\t\tNaiveSol kill_sub{result, {x}};\r\n\t\tif (sz(dp) == 1) dp.pb(kill_sub);\r\n\t\telse if (kill_sub.result < dp[1].result) dp[1] = kill_sub;\r\n\t}\r\n\treturn dp;\r\n}\r\n \r\nvi solve1(int R) {\r\n\tauto cands = brute(R, 0);\r\n\tFOR(i, 1, sz(cands)) if (cands[i].result < cands[0].result) {\r\n\t\tcands[0] = cands[i];\r\n\t}\r\n\tvi ans = cands[0].moves;\r\n\treturn ans;\r\n}\r\n \r\nvi solve2(int R) {\r\n\tconstruct(R, 0);\r\n\tint k = dp[R].bk.k;\r\n\tvi ans;\r\n\treconstruct(ans, sz(dp[R]) - 1, R, 0);\r\n\tassert(sz(ans) == k);\r\n\treturn ans;\r\n}\r\n \r\n/**\r\n * Description: wraps a lambda so it can call itself\r\n * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\r\n */\r\n \r\nnamespace std {\r\n \r\ntemplate <class Fun> class y_combinator_result {\r\n\tFun fun_;\r\n \r\n  public:\r\n\ttemplate <class T>\r\n\texplicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\r\n \r\n\ttemplate <class... Args> decltype(auto) operator()(Args &&...args) {\r\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\r\n\t}\r\n};\r\n \r\ntemplate <class Fun> decltype(auto) y_combinator(Fun &&fun) {\r\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\r\n}\r\n \r\n}  // namespace std\r\n \r\nvoid y_comb_demo() {\r\n\tcout << y_combinator([](auto gcd, int a, int b) -> int {\r\n\t\treturn b == 0 ? a : gcd(b, a % b);\r\n\t})(20, 30)\r\n\t     << \"\\n\";  // outputs 10\r\n}\r\n \r\nV<Frac> eval(int R, vi v) {\r\n\tV<Frac> res(N + 1);\r\n\t// dbg(\"EVAL\", R, v);\r\n\ty_combinator([&](auto dfs_set, int x, int p, Frac val) -> void {\r\n\t\tif (!val.d) {\r\n\t\t\tif (find(all(v), x) != end(v)) val = Frac{sum[x], num[x]};\r\n\t\t}\r\n\t\t// dbg(\"AT\", x, p, val);\r\n\t\tif (val.d) {\r\n\t\t\tres[x] = val;\r\n\t\t} else {\r\n\t\t\tres[x] = Frac{W[x], 1};\r\n\t\t}\r\n\t\tfor (int y : adj[x])\r\n\t\t\tif (y != p) dfs_set(y, x, val);\r\n\t})(R, 0, Frac{});\r\n\treturn res;\r\n}\r\n \r\nvoid solve(int tc, bool gen = true) {\r\n\t// dbg(\"DOING\", tc);\r\n\tint R;\r\n\tif (gen) {\r\n\t\tN = 6;\r\n\t\t// N = rng_int(2, 5);\r\n\t\tR = rng_int(1, N);\r\n\t\tK = rng_int(0, N);\r\n\t} else {\r\n\t\tre(N, R, K);\r\n\t}\r\n\tW.rsz(N + 1);\r\n\tint mx = rng_int(1, 10);\r\n\tFOR(i, 1, N + 1) {\r\n\t\tif (gen) {\r\n\t\t\tW[i] = rng_int(1, mx);\r\n\t\t} else re(W[i]);\r\n\t}\r\n\tadj = V<vi>(N + 1);\r\n\tFOR(i, 2, N + 1) {\r\n\t\tif (gen) {\r\n\t\t\tint u = rng_int(1, i - 1), v = i;\r\n\t\t\tadj[u].pb(v), adj[v].pb(u);\r\n\t\t} else {\r\n\t\t\tdef(int, u, v);\r\n\t\t\tadj[u].pb(v), adj[v].pb(u);\r\n\t\t}\r\n\t}\r\n\t// dbg(tc);\r\n\t// if (tc == 47336) { dbg(N, R, K, W, adj); }\r\n\tdp = {};\r\n\tdp.rsz(N + 1);\r\n\tstor = {};\r\n\tstor.rsz(N + 1);\r\n\tsum = vl(N + 1);\r\n\tnum = vi(N + 1);\r\n \r\n\t// vi ans = solve1(R);\r\n\tvi ans = solve2(R);\r\n\t// ps(eval(R, ans));\r\n\t// if (!gen) {\r\n\tps(sz(ans));\r\n\tps(ans);\r\n\t// } else {\r\n\t// \tif (eval(R, ans) != eval(R, ans2)) {\r\n\t// \t\tdbg(\"WHOOPS\", tc, N, R, K, W, adj);\r\n\t// \t\tdbg(ans, eval(R, ans));\r\n\t// \t\tdbg(ans2, eval(R, ans2));\r\n\t// \t\tFOR(i, 1, N + 1) dbg(i, dp[i]);\r\n\t// \t\texit(0);\r\n\t// \t}\r\n\t// }\r\n}\r\n \r\nint main() {\r\n\tsetIO();\r\n\t// RangeInfo r1{{1, Frac{2, 5}}, {2, Frac{2, 7}}};\r\n\t// RangeInfo r2{{3, Frac{2, 6}}, {4, Frac{2, 3}}};\r\n\t// auto r3 = r1 + r2;\r\n\t// dbg(r3.d0.f, r3.d1.f);\r\n\t// exit(0);\r\n \r\n\t// RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}\r\n\t// ps(Frac{1, 2} < Frac{2, 4});\r\n\t// ps(Frac{2, 4} < Frac{1, 2});\r\n\t// ps(Frac{1, 2} < Frac{2, 3});\r\n\t// exit(0);\r\n\tint TC;\r\n\tre(TC);\r\n\tFOR(i, 1, TC + 1) solve(i, false);\r\n}"
}