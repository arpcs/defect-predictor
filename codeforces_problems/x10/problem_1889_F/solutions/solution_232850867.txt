{
    "id": 232850867,
    "contestId": 1889,
    "creationTimeSeconds": 1700049100,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1889,
        "index": "F",
        "name": "Doremy's Average Tree",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1889,
        "members": [
            {
                "handle": "luogu_bot2"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1698503700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 116,
    "timeConsumedMillis": 155,
    "memoryConsumedBytes": 7270400,
    "source": "// LUOGU_RID: 135257798\n#include<bits/stdc++.h>\r\n#define For(i,l,r) for(register int i=(l);i<=(r);++i)\r\n#define For_down(i,r,l) for(register int i=(r);i>=(l);--i)\r\nusing namespace std;\r\nconstexpr int n_MAX=5000+5,tr_MAX=100000+5;\r\n\r\nint mem[n_MAX],U[n_MAX],V[n_MAX];\r\n\r\nstruct fraction\r\n{\r\n\tlong long p; int q;\r\n\tbool operator == (const fraction &other) const {return ((p*other.q)==(other.p*q));}\r\n\t//bool operator == (const fraction &other) const {return ((p==other.p)&&(q==other.q));}\r\n\tbool operator < (const fraction &other) const {return ((p*other.q)<(other.p*q));}\r\n\tvoid reduce(){const int gcd=__gcd((int)(p%q),q); p/=gcd,q/=gcd;}\r\n};\r\nint n,m,k,Rt,Fa[n_MAX]; vector<int> adj[n_MAX]; int a[n_MAX],b[n_MAX]; fraction f[n_MAX],g[n_MAX<<1];\r\nvoid DFS1(const int u){for(const int v:adj[u]) if(v!=Fa[u]) Fa[v]=u,DFS1(v),f[u].p+=f[v].p,f[u].q+=f[v].q;}\r\n\r\nbool is_test_499=false;\r\n\r\nconstexpr bool DEBUG=false;\r\n\r\nvoid procedure_1()\r\n{\r\n\tcin>>n>>Rt>>k;\r\n\tif(is_test_499) cerr<<n<<' '<<Rt<<' '<<k<<'\\n';\r\n\tFor(i,1,n)\r\n\t{\r\n\t\tcin>>a[i],f[i]=g[i]={a[i],1},mem[i]=a[i];\r\n\t\tif(is_test_499) cerr<<a[i]<<\" \\n\"[i==n];\r\n\t}\r\n\tFor(i,1,n-1)\r\n\t{\r\n\t\tint u,v; cin>>u>>v,adj[u].push_back(v),adj[v].push_back(u);\r\n\t\tif(is_test_499) cerr<<u<<' '<<v<<'\\n';\r\n\t\tU[i]=u,V[i]=v;\r\n\t}\r\n\tDFS1(Rt); For(i,1,n) f[i].reduce(),g[n+i]=f[i]; sort(g+1,g+(n<<1)+1),m=(unique(g+1,g+(n<<1)+1)-g-1);\r\n\tFor(i,1,n) a[i]=(lower_bound(g+1,g+m+1,(fraction){a[i],1})-g),b[i]=(lower_bound(g+1,g+m+1,f[i])-g);\r\n\tif(DEBUG)\r\n\t{\r\n\t\tFor(i,1,n-1)\r\n\t\t{\r\n\t\t\tconst int u=U[i],v=V[i];\r\n\t\t\tprintf(\"%d(%d) %d(%d)\\n\",u,a[u],v,a[v]);\r\n\t\t}\r\n\t}\r\n}\r\nint jump[n_MAX][13],best[n_MAX][13],dfn[n_MAX],L[n_MAX],R[n_MAX],seq[n_MAX],stamp;\r\nint select(const int u,const int v){return ((b[u]<=b[v])?u:v);}\r\nvoid DFS2(const int u)\r\n{\r\n\tdfn[u]=L[u]=R[u]=(++stamp),seq[stamp]=u,jump[u][0]=Fa[u],best[u][0]=u;\r\n\tFor(i,1,12){const int v=jump[u][i-1]; jump[u][i]=jump[v][i-1],best[u][i]=select(best[u][i-1],best[v][i-1]);}\r\n\tfor(const int v:adj[u]) if(v!=Fa[u]) DFS2(v),R[u]=R[v];\r\n}\r\nint euler_L[n_MAX],euler_R[n_MAX],euler_stamp; map<int,int> T[n_MAX<<1];\r\nvoid DFS3(const int u)\r\n{\r\n\tconst int prev=((--T[b[u]].end())->second); euler_L[u]=(++euler_stamp),T[b[u]][euler_stamp]=u;\r\n\tfor(const int v:adj[u]) if(v!=Fa[u]) DFS3(v); euler_R[u]=(++euler_stamp),T[b[u]][euler_stamp]=prev;\r\n}\r\nbool in_subtree(const int u,const int v){return ((L[u]<=L[v])&&(R[v]<=R[u]));}\r\nint find_lca(int u,const int v)\r\n{\r\n\tif(!u) return v; if(!v) return u; if(in_subtree(u,v)) return u;\r\n\tFor_down(i,12,0) if(jump[u][i]&&(!in_subtree(jump[u][i],v))) u=jump[u][i]; return Fa[u];\r\n}\r\nbool in_subtree_2(const int u,const int v)\r\n{\r\n\tif(!u) return true;\r\n\tif(!v) return false;\r\n\treturn ((L[u]<=L[v])&&(R[v]<=R[u]));\r\n}\r\nint find_best(int u,const int x,const int y)\r\n{\r\n\tif(in_subtree_2(u,x)||in_subtree_2(u,y)) return 0;\r\n\tint ans=0;\r\n\tFor_down(i,12,0)\r\n\t{\r\n\t\tif(in_subtree_2(jump[u][i],x)||in_subtree_2(jump[u][i],y)) continue;\r\n\t\tif(ans) ans=select(ans,best[u][i]);\r\n\t\telse ans=best[u][i];\r\n\t\tu=jump[u][i];\r\n\t}\r\n\tif(ans) ans=select(ans,u);\r\n\telse ans=u;\r\n\treturn ans;\r\n}\r\nint find_deepest(const int u,const int w)\r\n{\r\n\tconst pair<int,int> P=(*(--T[w].upper_bound(euler_L[u])));\r\n\treturn P.second;\r\n\t//return ((--T[w].upper_bound(euler_L[u]))->second);\r\n}\r\nvoid procedure_2(){For(i,1,m) T[i].insert({0,0}); DFS2(Rt),DFS3(Rt);}\r\nchar col[n_MAX];\r\n/*string col[n_MAX];*/ set<int> S_red,S_white;\r\nint cov1[n_MAX],cov2[n_MAX],prec[n_MAX],succ[n_MAX],ans[n_MAX],cur;\r\nbool is_alive(const int u,const int v){return ((succ[u]==v)&&(prec[v]==u));}\r\nstruct Segment_Tree_validity\r\n{\r\n\tint val[n_MAX<<2];\r\n\tinline int lch(const int x){return (x<<1);}\r\n\tinline int rch(const int x){return (x<<1|1);}\r\n\tint merge(int a,int b){if(a>b) swap(a,b); if(a==(-1)) return (-1); if(!a) return b; return ((a==b)?a:(-1));}\r\n\tvoid push_up(const int x){val[x]=merge(val[lch(x)],val[rch(x)]);}\r\n\tvoid Modify(const int x,const int l,const int r,const int p,const int w)\r\n\t{\r\n\t\tif(l==r){val[x]=w;return;} const int mid=((l+r)>>1);\r\n\t\tif(p<=mid) Modify(lch(x),l,mid,p,w); else Modify(rch(x),mid+1,r,p,w); push_up(x);\r\n\t}\r\n\tint Query(const int x,const int l,const int r,const int ql,const int qr)\r\n\t{\r\n\t\tif((ql<=l)&&(r<=qr)) return val[x]; const int mid=((l+r)>>1); int ans=0;\r\n\t\tif(ql<=mid) ans=Query(lch(x),l,mid,ql,qr); if(qr>mid) ans=merge(ans,Query(rch(x),mid+1,r,ql,qr)); return ans;\r\n\t}\r\n};\r\nSegment_Tree_validity St_valid;\r\nstruct Segment_Tree_cover\r\n{\r\n\tarray<int,3> A[n_MAX<<2]; vector<pair<int,int>> vec[n_MAX<<2];\r\n\tinline int lch(const int x){return (x<<1);}\r\n\tinline int rch(const int x){return (x<<1|1);}\r\n\tvoid cover(const int x,const int w,const int u,const int v)\r\n\t\t{A[x][0]=w; if(!u) ++A[x][1]; else ++A[x][2],vec[x].push_back({u,v});}\r\n\tvoid cover(const int x,const int l,const int r,const int ql,const int qr,const int w,const int u,const int v)\r\n\t{\r\n\t\tif((ql<=l)&&(r<=qr))\r\n\t\t{\r\n\t\t\tcover(x,w,u,v);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst int mid=((l+r)>>1);\r\n\t\tif(ql<=mid)\r\n\t\t\tcover(lch(x),l,mid,ql,qr,w,u,v);\r\n\t\tif(qr>mid)\r\n\t\t\tcover(rch(x),mid+1,r,ql,qr,w,u,v);\r\n\t}\r\n\tvoid uncover(const int x){--A[x][2]; if((!A[x][1])&&(!A[x][2])) A[x][0]=0;}\r\n\tvoid uncover(const int x,const int l,const int r,const int ql,const int qr)\r\n\t{\r\n\t\tif((ql<=l)&&(r<=qr)){uncover(x);return;} const int mid=((l+r)>>1);\r\n\t\tif(ql<=mid) uncover(lch(x),l,mid,ql,qr); if(qr>mid) uncover(rch(x),mid+1,r,ql,qr);\r\n\t}\r\n\tvoid Query(const int x,const int l,const int r,const int p,array<int,3> &B)\r\n\t{\r\n\t\tif(A[x][0])\r\n\t\t{\r\n\t\t\tB[0]=A[x][0],B[1]+=A[x][1],B[2]+=A[x][2];\r\n\t\t}\r\n\t\tif(l==r) return;\r\n\t\tconst int mid=((l+r)>>1);\r\n\t\tif(p<=mid)\r\n\t\t\tQuery(lch(x),l,mid,p,B);\r\n\t\telse\r\n\t\t\tQuery(rch(x),mid+1,r,p,B);\r\n\t}\r\n\tvoid Eliminate(const int x,const int l,const int r,const int p,vector<pair<int,int>> &name)\r\n\t{\r\n\t\tfor(const pair<int,int> P:vec[x])\r\n\t\t{\r\n\t\t\tconst int u=P.first,v=P.second;\r\n\t\t\tif(is_alive(u,v)) /*uncover(1,1,n,u,v),*/name.push_back({u,v});\r\n\t\t}\r\n\t\t//for(const auto [u,v]:vec[x]) if(alive(u,v)) uncover(1,1,n,u,v),name.push_back({u,v});\r\n\t\tvec[x].clear(),vec[x].shrink_to_fit(); if(l==r) return; const int mid=((l+r)>>1);\r\n\t\tif(p<=mid) Eliminate(lch(x),l,mid,p,name); else Eliminate(rch(x),mid+1,r,p,name);\r\n\t}\r\n};\r\nSegment_Tree_cover St_cover;\r\n\r\nbool is_valid(const int u)\r\n{\r\n\tconst int que=St_valid.Query(1,1,n,L[u],R[u]);\r\n\treturn ((!que)||(que==b[u]));\r\n}\r\nbool valid_1(const int u)\r\n{\r\n\tconst int d=find_deepest(u,ans[u]);\r\n\tif(!d) return false;\r\n\treturn is_valid(d);\r\n}\r\nbool valid_2(const int u,const int v)\r\n{\r\n\tif(ans[u]!=ans[v]) return false;\r\n\tconst int lca=find_lca(u,v);\r\n\tconst int d=find_deepest(lca,ans[u]);\r\n\tif(!d) return false;\r\n\treturn is_valid(d);\r\n}\r\nmap<int,int> tried;\r\nbool Try_value(const int u,const int w,const int x,const int y,const array<int,3> &A)\r\n{\r\n\tif(tried.count(w)) return false;\r\n\tans[u]=w;\r\n\tint Delta=0;\r\n\tif(w==a[u])\r\n\t{\r\n\t\tif(A[0]&&(A[0]!=w))\r\n\t\t{\r\n\t\t\tDelta+=A[2];\r\n\t\t\tif(A[1]) return false;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(x&&y&&is_alive(x,y)&&ans[x]==w)\r\n\t\t{\r\n\t\t\tassert(A[0]==w);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tDelta=1;\r\n\t\tif(!valid_1(u)) return false;\r\n\t\tif(x&&valid_2(x,u)) --Delta;\r\n\t\tif(y&&valid_2(u,y)) --Delta;\r\n\t\tif(A[0]&&(A[0]!=w))\r\n\t\t{\r\n\t\t\tDelta+=A[2];\r\n\t\t\tif(A[1]) return false;\r\n\t\t}\r\n\t}\r\n\ttried[w]=Delta; return ((cur+Delta)<=k);\r\n}\r\nvoid add_single(const int u)\r\n{\r\n\tconst int d=find_deepest(u,ans[u]);\r\n\tcov1[u]=d;\r\n\tSt_cover.cover(1,1,n,L[d],R[d],b[d],0,0);\r\n}\r\nvoid add_link(const int u,const int v)\r\n{\r\n\tsucc[u]=v,prec[v]=u;\r\n\tconst int lca=find_lca(u,v);\r\n\tconst int d=find_deepest(lca,ans[u]);\r\n\tcov2[u]=d;\r\n\tSt_cover.cover(1,1,n,L[d],R[d],b[d],u,v);\r\n}\r\nvoid break_link(const int u,const int v)\r\n{\r\n\tsucc[u]=prec[v]=0;\r\n\tconst int a=cov2[u];\r\n\tSt_cover.uncover(1,1,n,L[a],R[a]);\r\n}\r\nvector<pair<int,int>> name;\r\nvoid Fix_value(const int u,const int w,const int x,const int y,const array<int,3> &A)\r\n{\r\n\tconst int Delta=tried[w];\r\n\tcur+=Delta,ans[u]=w;\r\n\tSt_valid.Modify(1,1,n,dfn[u],w);\r\n\tname.clear(),name.shrink_to_fit();\r\n\tif(w==a[u])\r\n\t{\r\n\t\tcol[u]='W';\r\n\t\t//col[u]=\"white\";\r\n\t\tif(A[0]&&(A[0]!=w))\r\n\t\t{\r\n\t\t\tSt_cover.Eliminate(1,1,n,dfn[u],name);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcol[u]='R';\r\n\t\t//col[u]=\"red\";\r\n\t\tadd_single(u);\r\n\t\tif(x&&y&&is_alive(x,y)&&ans[x]==w)\r\n\t\t{\r\n\t\t\tbreak_link(x,y),add_link(x,u),add_link(u,y);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(x&&valid_2(x,u))\r\n\t\t{\r\n\t\t\tadd_link(x,u);\r\n\t\t}\r\n\t\tif(y&&valid_2(u,y))\r\n\t\t{\r\n\t\t\tadd_link(u,y);\r\n\t\t}\r\n\t\tif(A[0]&&(A[0]!=w))\r\n\t\t{\r\n\t\t\tSt_cover.Eliminate(1,1,n,dfn[u],name);\r\n\t\t}\r\n\t}\r\n\tfor(const auto P:name)\r\n\t{\r\n\t\tconst int u=P.first,v=P.second;\r\n\t\tbreak_link(u,v);\r\n\t}\r\n}\r\nvoid chk_min(int &a,const int b){((b<a)&&(a=b));}\r\nvoid main_procedure()\r\n{\r\n\tFor(i,1,n) col[i]='.'; // !!!!!!!!!!!\r\n\tFor(u,1,n)\r\n\t{\r\n\t\tif(DEBUG)\r\n\t\t{\r\n\t\t\tprintf(\"u = %d\\n\",u);\r\n\t\t\tif(u==4)\r\n\t\t\t\tprintf(\"!!!!!!\\n\");\r\n\t\t}\r\n\t\tint x=0,y=0,x2=0,y2=0; array<int,3> A={};\r\n\t\tconst set<int>::iterator it=S_white.lower_bound(dfn[u]);\r\n\t\tif(it!=S_white.end()) y=seq[*it];\r\n\t\tif(it!=S_white.begin()) x=seq[*prev(it)];\r\n\t\tconst set<int>::iterator it2=S_red.lower_bound(dfn[u]);\r\n\t\tif(it2!=S_red.end()) y2=seq[*it2];\r\n\t\tif(it2!=S_red.begin()) x2=seq[*prev(it2)];\r\n\t\t\r\n\t\tSt_cover.Query(1,1,n,dfn[u],A);\r\n\t\tint w=INT_MAX;\r\n\t\ttried.clear();\r\n\t\tif(Try_value(u,a[u],x2,y2,A))\r\n\t\t\tchk_min(w,a[u]);\r\n\t\tif(x)\r\n\t\t{\r\n\t\t\tif(Try_value(u,ans[x],x2,y2,A))\r\n\t\t\t\tchk_min(w,ans[x]);\r\n\t\t}\r\n\t\tif(y)\r\n\t\t{\r\n\t\t\tif(Try_value(u,ans[y],x2,y2,A))\r\n\t\t\t\tchk_min(w,ans[y]);\r\n\t\t}\r\n\t\tconst int h=find_best(u,x,y);\r\n\t\tif(h)\r\n\t\t{\r\n\t\t\tif(Try_value(u,b[h],x2,y2,A))\r\n\t\t\t\tchk_min(w,b[h]);\r\n\t\t}\r\n\t\tassert(w!=INT_MAX);\r\n\t\tFix_value(u,w,x2,y2,A);\r\n\t\tif(col[u]=='R') S_red.insert(dfn[u]);\r\n\t\tS_white.insert(dfn[u]);\r\n\t}\r\n}\r\nint stk[n_MAX],top,Final[n_MAX];\r\nvoid Trace()\r\n{\r\n\tFor(i,1,n)\r\n\t{\r\n\t\tif(col[i]!='R') continue;\r\n\t\tif(prec[i]) continue;\r\n\t\tint a=0;\r\n\t\tif(!succ[i]) a=cov1[i];\r\n\t\telse\r\n\t\t{\r\n\t\t\tint u=i;\r\n\t\t\twhile(succ[u])\r\n\t\t\t{\r\n\t\t\t\tconst int b=cov2[u];\r\n\t\t\t\tif(!a) a=b;\r\n\t\t\t\telse if((R[b]-L[b]+1)>(R[a]-L[a]+1)) a=b;\r\n\t\t\t\tu=succ[u];\r\n\t\t\t}\r\n\t\t\tstk[++top]=a;\r\n\t\t}\r\n\t}\r\n\tFor(i,1,n) Final[i]=mem[i];\r\n\tsort(stk+1,stk+top+1);\r\n\t/*assert(top<=k);\r\n\tFor(i,1,top)\r\n\t{\r\n\t\tconst int u=stk[i];\r\n\t\tassert(1<=u&&u<=n);\r\n\t\tint Sum=0,Siz=0;\r\n\t\tFor(j,L[u],R[u]) Sum+=Final[seq[j]],++Siz;\r\n\t\tassert(!(Sum%Siz));\r\n\t\tFor(j,L[u],R[u]) Final[seq[j]]=(Sum/Siz);\r\n\t}\r\n\tFor(i,1,n) cout<<Final[i]<<\" \\n\"[i==n];*/\r\n\tcout<<top<<'\\n';\r\n\tFor(i,1,top) cout<<stk[i]<<\" \\n\"[i==top];\r\n}\r\nvoid clear()\r\n{\r\n\tfill(mem,mem+n+1,0),fill(U,U+n+1,0),fill(V,V+n+1,0);\r\n\tfill(Fa,Fa+n+1,0);\r\n\tFor(i,0,n) adj[i].clear(),adj[i].shrink_to_fit();\r\n\tfill(a,a+n+1,0),fill(b,b+n+1,0);\r\n\tfill(f,f+n+1,(fraction){0,0}),fill(g,g+(n<<1)+1,(fraction){0,0});\r\n\tFor(i,0,n) memset(jump[i],0,sizeof(jump[i])),memset(best[i],0,sizeof(best[i]));\r\n\tfill(L,L+n+1,0),fill(R,R+n+1,0),fill(seq,seq+n+1,0);\r\n\tstamp=0;\r\n\tfill(euler_L,euler_L+n+1,0),fill(euler_R,euler_R+n+1,0);\r\n\teuler_stamp=0;\r\n\tFor(i,0,n<<1) T[i].clear();\r\n\tfill(col,col+n+1,'\\0');\r\n\tS_red.clear(),S_white.clear();\r\n\tfill(cov1,cov1+n+1,0),fill(cov2,cov2+n+1,0),fill(prec,prec+n+1,0),fill(succ,succ+n+1,0);\r\n\tfill(ans,ans+n+1,0),cur=0;\r\n\ttried.clear();\r\n\tname.clear(),name.shrink_to_fit();\r\n\tfill(stk,stk+n+1,0);\r\n\ttop=0;\r\n\tfill(Final,Final+n+1,0);\r\n\tfill(St_valid.val,St_valid.val+(n<<2)+1,0);\r\n\tfill(St_cover.A,St_cover.A+(n<<2)+1,(array<int,3>){});\r\n\tFor(i,0,n<<2) St_cover.vec[i].clear(),St_cover.vec[i].shrink_to_fit();\r\n\tn=m=k=Rt=0;\r\n}\r\nint main()\r\n{\r\n\t//freopen(\"7.in\",\"r\",stdin);\r\n\t//freopen(\"7.out\",\"w\",stdout);\r\n\tios::sync_with_stdio(false),cin.tie(nullptr);\r\n\tint T; cin>>T;\r\n\twhile(T--)\r\n\t{\r\n\t\t//is_test_499=(T==499);\r\n\t\tprocedure_1();\r\n\t\tprocedure_2();\r\n\t\tmain_procedure();\r\n\t\tTrace();\r\n\t\tclear();\r\n\t}\r\n\treturn 0;\r\n}"
}