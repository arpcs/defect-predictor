{
    "id": 231021326,
    "contestId": 1294,
    "creationTimeSeconds": 1698948385,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1294,
        "index": "F",
        "name": "Three Paths on a Tree",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "dfs and similar",
            "dp",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1294,
        "members": [
            {
                "handle": "Shubham_0605"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1579703700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 374,
    "memoryConsumedBytes": 11059200,
    "source": "#include <iostream>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <queue>\r\n#include <set>\r\n#include <unordered_set>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <stack>\r\n#include<limits>\r\n#include<string>\r\n#include <bits/stdc++.h>\r\n#include <list>\r\n using namespace std;\r\n// #include<bits/stdc++.h>\r\n \r\n// #include<ext/pb_ds/assoc_container.hpp>\r\n// #include<ext/pb_ds/tree_policy.hpp>\r\n \r\n// using namespace std;\r\n// using namespace __gnu_pbds;\r\n// typedef long long ll;\r\n// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;  \r\n#define pb push_back\r\n#define mp make_pair\r\n//#define all(x) x.begin(),x.end()\r\n#define mset(m,v) memset(m,v,sizeof(m))\r\n#define ff first\r\n#define ss second\r\n#define fastio() ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define inp(x) int x; cin >> x\r\n#define fo(i,x,n) for(int i=x;i<n;i++)\r\n#define fi(a,n) for(int x=0;x<n;x++)cin>>a[x]\r\n#define debug(x) for(int i=0;i<x.size();i++)cout << x[i] << \" \"; cout << endl\r\n#define nl endl\r\n#define cont continue \r\n#define lb lower_bound\r\n#define ub upper_bound\r\n \r\n//using namespace std;\r\n \r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef vector<int> vi;\r\ntypedef vector<vector<int> > vvi;\r\ntypedef vector<long long> vl;\r\ntypedef vector<vector<long long> > vvl;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<ll, ll> pll;\r\ntypedef priority_queue<int, vector<int>, greater<int> > pqm;\r\n \r\n \r\n#define mod 1000000007\r\nconst ll INF = 8 * 1e18;\r\nconst int big = 1e6 + 7;\r\n \r\nll gcd(ll a, ll b) {if (!b)return a; return gcd(b, a % b);}\r\nll powe(ll x, ll y, ll p = mod) { ll res = 1; x %= p; while (y > 0) { if (y & 1) res = (res * x) % p; y >>= 1; x = (x * x) % p;} return res; }\r\nll lcm(ll x, ll y) { return ((x * y) / (gcd(x, y))); }\r\nll modi(ll x, ll p = mod) { return powe(x, p - 2, p); }\r\n \r\nll power(ll x, ll y, ll p) \r\n{ \r\n    ll res = 1;      // Initialize result \r\n  \r\n    x = x % p;  // Update x if it is more than or \r\n                // equal to p \r\n  \r\n    while (y > 0) \r\n    { \r\n        // If y is odd, multiply x with result \r\n        if (y & 1)   \r\n            res = (res*x) % p; \r\n  \r\n        // y must be even now \r\n        y = y>>1; // y = y/2 \r\n        x = (x*x) % p; \r\n    } \r\n    return res; \r\n} \r\n  \r\n// Returns n^(-1) mod p \r\nll modInverse(ll n, ll p) \r\n{ \r\n    return power(n, p-2, p); \r\n} \r\n  \r\n// Returns nCr % p using Fermat's little \r\n// theorem. \r\nll nCrModPFermat(ll n, ll r, ll p) \r\n{ \r\n   // Base case \r\n   if (r==0) \r\n      return 1;  \r\n    ll fac[n+1]; \r\n    fac[0] = 1; \r\n    for (ll i=1 ; i<=n; i++) \r\n        fac[i] = fac[i-1]*i%p; \r\n  \r\n    return (fac[n]* modInverse(fac[r], p) % p * \r\n            modInverse(fac[n-r], p) % p) % p; \r\n} \r\nll prime[300001]={0};\r\nvoid SieveOfEratosthenes(int n)\r\n{\r\n    // Create a boolean array\r\n    // \"prime[0..n]\" and initialize\r\n    // all entries it as true.\r\n    // A value in prime[i] will\r\n    // finally be false if i is\r\n    // Not a prime, else true.\r\n    ///bool prime[n + 1];\r\n    //memset(prime, true, sizeof(prime));\r\n \r\n    for (int p = 2; p * p <= n; p++)\r\n    {\r\n        // If prime[p] is not changed,\r\n        // then it is a prime\r\n        if (prime[p] == 0)\r\n        {\r\n            // Update all multiples\r\n            // of p greater than or\r\n            // equal to the square of it\r\n            // numbers which are multiple\r\n            // of p and are less than p^2\r\n            // are already been marked.\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = 1;\r\n        }\r\n    }\r\n \r\n    \r\n}\r\nll fast_pow(ll a, ll p) {\r\n  ll res = 1;\r\n  while (p) {\r\n    if (p % 2 == 0) {\r\n      a = a * 1ll * a % mod;\r\n      p /= 2;\r\n    } else {\r\n      res = res * 1ll * a % mod;\r\n      p--;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n \r\nll fact(int n) {\r\n  ll res = 1;\r\n  for (ll i = 1; i <= n; i++) {\r\n    res = res * 1ll * i % mod;\r\n  }\r\n  return res;\r\n}\r\n \r\nll C(ll n, ll k) {\r\n  return fact(n) * 1ll * fast_pow(fact(k), mod - 2) % mod * 1ll * fast_pow(fact(n - k), mod - 2) % mod;\r\n}\r\n// //0-1 bfs\r\n// // ll n,m;\r\n// // vector<pair<ll,ll>>g[100100];\r\n// // int dis[100100];\r\n// // void bfs_01(ll source){\r\n// //     deque<ll>dq;\r\n// //     for(ll i=1;i<=n;i++){\r\n// //         dis[i]=1e9;\r\n// //     }\r\n// //     dis[source]=0;\r\n// //     dq.push_back(source);\r\n// //     while(!dq.empty()){\r\n// //         ll node=dq.front();\r\n// //         dq.pop_front();\r\n// //         for(auto v:g[node]){\r\n// //             ll neigh=v.ff;\r\n// //             ll weight=v.ss;\r\n// //             if(dis[neigh]>dis[node]+weight){\r\n// //                 dis[neigh]=dis[node]+weight;\r\n// //                 if(weight==0){\r\n// //                     dq.push_front(neigh);\r\n// //                 }\r\n// //                 else {\r\n// //                     dq.push_back(neigh);\r\n// //                 }\r\n// //             }\r\n// //         }\r\n// //     }   \r\n// // }\r\n \r\n// // class prioritize{\r\n// //     public: bool operator()(pair<ll,ll>&p1, pair<ll,ll>&p2){\r\n// //         return p1.ss>p2.ss;\r\n// //     }\r\n// // };\r\n// //dijsktra algo\r\n// ll n,m;\r\n// ll vis[100100];\r\n// vector<vector<ll>>dist(100100,vector<ll>(10,0ll));\r\n// ll par[100100];\r\n// vector<pair<ll,ll>>g[100100];\r\n// void dijkstra(ll sc,ll k){\r\n//     for(ll i=1;i<=n;i++){\r\n//         for(ll j=0;j<=9;j++){\r\n//             dist[i][j]=1e18;\r\n//         }\r\n//         //vis[i]=0;\r\n//     }\r\n    \r\n//     priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\r\n//     pq.push(make_pair(0ll,sc));\r\n//     while(!pq.empty()){\r\n//         pair<ll,ll> fs=pq.top();\r\n//         pq.pop();\r\n//         if(dist[fs.ss][k-1]<fs.ff){\r\n//             continue;\r\n//         }\r\n//         // vis[fs.ss]=1;\r\n//         for(auto v:g[fs.ss]){\r\n//             ll neigh=v.ff;\r\n//             ll weight=v.ss;\r\n//             if(dist[neigh][k-1]>fs.ff+weight){\r\n//                 dist[neigh][k-1]=fs.ff+weight;\r\n//                 pq.push(make_pair(dist[neigh][k-1],neigh));\r\n//                 sort(dist[neigh].begin(),dist[neigh].end()); \r\n//             }\r\n//         }\r\n \r\n//     }\r\n \r\n// }\r\n\r\n// //  \r\n// // ll n,m;\r\n// // vector<string>arr;\r\n// // vector<vector<ll>>dist;\r\n// // vector<vector<pair<ll,ll>>>par;\r\n// // int dx[]={-1,0,1,0};\r\n// // int dy[]={0,-1,0,1};\r\n// // bool check(ll x,ll y){\r\n// //     if(x>=0 && x<n && y>=0 && y<m && arr[x][y]!='#'){\r\n// //         return 1;\r\n// //     }\r\n// //     return 0;\r\n// // }\r\n// // // bool check1(ll x,ll y){\r\n// // //     if(x>=0 && x<n && y>=0 && y<m && arr[x][y]!='B' && arr[x][y]!='G'){\r\n// // //         return 1;\r\n// // //     }\r\n// // //     return 0;\r\n// // // }\r\n// // //here we are using the dist array as the visited array too \r\n// // void bfs(pair<ll,ll>st){\r\n// //     queue<pair<ll,ll>>q;\r\n// //     dist=vector<vector<ll>>(n,vector<ll>(m,1e9));\r\n// //     par=vector<vector<pair<ll,ll>>>(n,vector<pair<ll,ll>>(m,{0,0}));\r\n// //     dist[st.ff][st.ss]=0;\r\n// //     par[st.ff][st.ss]={-1,-1};\r\n// //     q.push(st);\r\n// //     while(!q.empty()){\r\n// //         auto pos=q.front();\r\n// //         q.pop();\r\n// //         for(ll k=0;k<4;k++){\r\n// //             if(check(pos.ff+dx[k],pos.ss+dy[k]) && dist[pos.ff+dx[k]][pos.ss+dy[k]]>dist[pos.ff][pos.ss]+1){\r\n// //                    dist[pos.ff+dx[k]][pos.ss+dy[k]]=dist[pos.ff][pos.ss]+1;\r\n// //                    par[pos.ff+dx[k]][pos.ss+dy[k]]={pos.ff,pos.ss};\r\n// //                    q.push({pos.ff+dx[k],pos.ss+dy[k]});\r\n// //             }\r\n// //         }\r\n// //     }\r\n// // }\r\n// // void print_bfs(pair<ll,ll>en){\r\n// //     string s=\"\";\r\n// //     pair<ll,ll>x=en;\r\n// //     while(en!=make_pair(-1ll,-1ll)){\r\n// //         pair<ll,ll>p;\r\n// //         p=par[en.ff][en.ss];  \r\n// //         //cout << p.ff << \" \" << p.ss << endl;\r\n// //         if(p!=make_pair(-1ll,-1ll)){\r\n// //         if(p.ff==en.ff && p.ss>en.ss){\r\n// //             s+='L';\r\n// //         }\r\n// //         else if(p.ff==en.ff){\r\n// //             s+='R';\r\n// //         }\r\n// //         else if(p.ss==en.ss && p.ff>en.ff){\r\n// //             s+='U';\r\n// //         }\r\n// //         else {\r\n// //             s+='D';\r\n// //         }\r\n// //     }\r\n// //         en=par[en.ff][en.ss];\r\n// //     }\r\n// //     reverse(s.begin(),s.end());\r\n// //     cout << s << endl;\r\n// // }  \r\n// // char matrix[1001][1001];\r\n// //  void dfs(vector<vector<ll>>&visited, ll i, ll j,ll m,ll n){\r\n// //     visited[i][j]=1;\r\n    \r\n// //     ll dx[]={1,0,-1,0};\r\n// //     ll dy[]={0,1,0,-1};\r\n// //     for(ll k=0;k<4;k++){\r\n// //          ll x=i+dx[k];\r\n// //          ll y=j +dy[k];\r\n// //          if(x>=0 && x<m && y>=0 && y<n && matrix[x][y]=='.' && visited[x][y]==0){\r\n// //             dfs(visited,x,y,m,n);\r\n// //          }\r\n// //     }\r\n// // return;\r\n   \r\n// // }\r\n// ll n,m;\r\n// ll dist[500][500];\r\n// void floyd_wrashall(){\r\n//     int n, m, q;\r\n//     cin >> n >> m >> q;\r\n\r\n//     ll dist[n + 1][n + 1];\r\n//     for(int i = 1; i <= n; i++) {\r\n//         for(int j = 1; j <= n; j++) {\r\n//             dist[i][j] = 1e18;\r\n//         }\r\n//         dist[i][i] = 0;\r\n//     }\r\n\r\n//     for(int i = 0; i < m; i++) {\r\n//         int a, b, c;\r\n//         cin >> a >> b >> c;\r\n//         dist[a][b] = dist[b][a] = min(dist[a][b], 1LL * c);\r\n//     }\r\n\r\n//     for(int k = 1; k <= n; k++) {\r\n//         for(int i = 1; i <= n; i++) {\r\n//             for(int j = 1; j <= n; j++) {\r\n//                 dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); \r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     while(q--) {\r\n//         int a, b;\r\n//         cin >> a >> b;\r\n//         if(dist[a][b] == 1e18) cout << \"-1\\n\";\r\n//         else cout << dist[a][b] << \"\\n\";\r\n//     }\r\n// }\r\n// ll start[100100]={0};\r\n// ll cycle_start[100100]={0};\r\n// vector<ll>g[100100];\r\n// stack<ll>rs;\r\n// ll n,m;\r\n// bool dfs(ll sc){\r\n//     start[sc]=1;\r\n//      rs.push(sc);\r\n//     cycle_start[sc]=1;\r\n//     for(auto neigh:g[sc]){\r\n//         //cout << sc << \" \" << neigh << \"aaaa\" <<endl;\r\n//         if(start[neigh]==0){\r\n//             if(dfs(neigh)){\r\n//                 return true;\r\n//             }\r\n//         }\r\n//         else if(cycle_start[neigh]){\r\n//             //cout << sc << \" \" << neigh << \"bbbbb\" << endl;\r\n//             rs.push(neigh);\r\n//             return true;\r\n//         }\r\n//     }\r\n//     rs.pop();\r\n//     cycle_start[sc]=0;\r\n//     return false;\r\n// }\r\n\r\n//--topo_sort using kahnsalgo\r\n// ll indegree[100100]={0};\r\n// void toposort(){\r\n//     for(ll i=1;i<=n;i++){\r\n//         for(auto it:adj[i]){\r\n//             indegree[it]++;\r\n//         }\r\n//     }\r\n//     queue<ll>q;\r\n//     for(ll i=1;i<=n;i++){\r\n//         if(indegree[i]==0){\r\n//             q.push(i);\r\n//         }\r\n//     }\r\n//     while(!q.empty()){\r\n//         cout << q.front();\r\n//         ll node=q.front();\r\n//         q,pop();\r\n//         for(auto it : adj[node]){\r\n//             indegree[it]--;\r\n//             if(indegree[it]==0){\r\n//                 q.push(it);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n// }\r\n\r\n//vector<ll>g[400100];\r\n// ll vis[100100];\r\n// vector<ll>topo;\r\n// void dfs(ll node){\r\n//     vis[node]=1;\r\n//     for(auto neigh:g[node]){\r\n//         if(!vis[neigh]){\r\n//             dfs(v);  \r\n//         }\r\n//     }\r\n//     topo.push_back(node);\r\n// }\r\n    // ll n,m;\r\n    // cin >> n >> m;\r\n    // for(ll i=0;i<m;i++){\r\n    //     ll a,b;\r\n    //     cin >> a >> b;\r\n    //     g[b].pb(a);\r\n    // }\r\n    // for(ll i=1;i<=n;i++){\r\n    //     if(!vis[i]){\r\n    //         dfs(i);\r\n    //     }\r\n    // }\r\n//--dfs tree\r\n// ll n;\r\n// ll ans=0;\r\n// ll cc=0;\r\n// vector<ll>parent;\r\n// vector<ll>g[100100];\r\n// ll a[100100];\r\n// ll subtree_size[100100]={0};\r\n// //vetor<ll>centroid;\r\n// void dfs(ll node,ll parent){\r\n//     subtree_size[node]=1;\r\n//     for(auto neigh:g[node]){\r\n//         if(neigh!=parent){\r\n//             dfs(neigh,node);\r\n//             subtree_size[node]+=subtree_size[neigh];\r\n//             if(subtree_size[neigh]%2==0){\r\n//                 ans++;\r\n//             }\r\n            \r\n//         }\r\n//     }\r\n//     // for(auto neigh:g[node]){\r\n//     //     if(neigh!=parent && (n-subtree_size[neigh])%2==0 && subtree_size[neigh]%2==0){\r\n//     //         //cout << node << \" \" << neigh << endl;\r\n//     //         ans++;\r\n//     //     }\r\n//     // }\r\n        \r\n\r\n// }\r\n// ll n;\r\n//vector<ll>parent;\r\n vector<ll>g[100100];\r\nll dis[100100]={0};\r\nll par[100100]={0};\r\nvoid dfs(ll node,ll parent,ll dist){\r\n    dis[node]=dist;\r\n    par[node]=parent;\r\n    for(auto neigh:g[node]){\r\n        if(neigh!=parent){\r\n            dfs(neigh,node,dist+1);\r\n        }\r\n    }\r\n}\r\n///dfs tree int main() content\r\n\r\n    // vector<ll>path;\r\n    // ll current_node=max2;\r\n    // while(current_node!=max1){\r\n    //     path.pb(current_node);\r\n    //     current_node=max1;\r\n    // }\r\n    // path.pb(max1);\r\n\r\nint main()\r\n{\r\nll t;\r\n//cin >> t;\r\nt=1;\r\n    while(t--){\r\n        ll n;\r\n      cin >> n;\r\n    for(ll i=0;i<n-1;i++){\r\n        ll a,b;\r\n        cin >> a >> b;\r\n        g[a].pb(b);\r\n        g[b].pb(a);\r\n\r\n    }\r\n    dfs(1,-1,0);\r\n    ll max1=1;\r\n    for(ll i=2;i<=n;i++){\r\n        if(dis[i]>dis[max1]){\r\n            max1=i;\r\n        }\r\n    }\r\n    //cout << max1 << endl;\r\n    dfs(max1,-1,0);\r\n    ll max2=1;\r\n    for(ll i=1;i<=n;i++){\r\n        if(dis[i]>dis[max2]){\r\n            max2=i;\r\n        }\r\n    }\r\n    vector<ll>path;\r\n    //path.pb(max2);\r\n    ll current=max2;\r\n    while(current!=-1){\r\n        path.pb(current);\r\n        current=par[current];\r\n    }\r\n    //cout << max2 << endl;\r\n    queue<ll>q;\r\n    ll dist[n+1];\r\n    for(ll i=0;i<=n;i++){\r\n        dist[i]=-1;\r\n    }\r\n    for(ll i=0;i<path.size();i++){\r\n        //cout << path[i] << \" \";\r\n        q.push(path[i]);\r\n        dist[path[i]]=0;\r\n    }\r\n    \r\n    \r\n    if(dis[max2]==n-1){\r\n        cout << dis[max2] << endl;\r\n        cout << max1 << \" \" << max2 << endl;\r\n    }\r\n    else {\r\n        ll opmax=-1;\r\n        ll third_node=-1;\r\n        while(q.size()>0){\r\n            ll x=q.front();\r\n            q.pop();\r\n            for(auto p:g[x]){\r\n                if(dist[p]==-1){\r\n                    dist[p]=dist[x]+1;\r\n                    q.push(p);\r\n                    if(opmax<dist[p]){\r\n                        third_node=p;\r\n                        opmax=dist[p];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //cout << opmax << endl;\r\n        //cout << dis[max2] << endl;\r\n        cout << opmax+dis[max2] << endl;\r\n        cout << third_node << \" \" << max1 << \" \" << max2 << endl;\r\n    }\r\n    }\r\n    \r\n    \r\n}         \r\n   "
}