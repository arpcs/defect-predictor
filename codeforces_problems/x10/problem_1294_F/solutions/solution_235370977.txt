{
    "id": 235370977,
    "contestId": 1294,
    "creationTimeSeconds": 1701515183,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1294,
        "index": "F",
        "name": "Three Paths on a Tree",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "dfs and similar",
            "dp",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1294,
        "members": [
            {
                "handle": "arodnap33"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1579703700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 305,
    "timeConsumedMillis": 202,
    "memoryConsumedBytes": 15155200,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing i64 = long long;\r\nusing u64 = unsigned long long int;\r\nusing namespace std;\r\n\r\nmt19937_64 gen64(chrono::steady_clock::now().time_since_epoch().count());\r\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\r\nuniform_int_distribution<i64> distrib(1, LLONG_MAX);\r\n\r\nvector<vector<i64>> matrixMul(vector<vector<i64>>& a, vector<vector<i64>>& b,\r\n                              i64 mod) {\r\n    int n = (int)a.size();\r\n    int m = (int)b[0].size();\r\n    vector<vector<i64>> c(n, vector<i64>(m));\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            for (int k = 0; k < (int)b.size(); k++) {\r\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j] % mod) % mod;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\n// const int d = 30;\r\n\r\n// struct XorBasis {\r\n//     int basis[d];\r\n\r\n//     void init() {\r\n//         for (int i = 0; i < d; i++) basis[i] = 0;\r\n//     }\r\n\r\n//     void insert(int mask) {\r\n//         for (int i = d - 1; i >= 0; i--) {\r\n//             if (((mask >> i) & 1) == 0) continue;\r\n\r\n//             if (!basis[i]) {\r\n//                 basis[i] = mask;\r\n//                 return;\r\n//             }\r\n//             mask ^= basis[i];\r\n//         }\r\n//     }\r\n\r\n//     void merge(const XorBasis& from) {\r\n//         for (int i = d - 1; i >= 0; i--) {\r\n//             if (!from.basis[i]) continue;\r\n\r\n//             insert(from.basis[i]);\r\n//         }\r\n//     }\r\n\r\n//     int findMax() {\r\n//         int ret = 0;\r\n//         for (int i = d - 1; i >= 0; i--) {\r\n//             if (!basis[i] || (ret >> i & 1)) continue;\r\n\r\n//             ret ^= basis[i];\r\n//         }\r\n//         return ret;\r\n//     }\r\n// };\r\n\r\ni64 ceil(i64 a, i64 b) { return (a + b - 1) / b; }\r\n\r\nint ceil(int a, int b) { return (a + b - 1) / b; }\r\n\r\n// https://codeforces.com/problemset/problem/1725/C\r\n// https://codeforces.com/contest/1863/problem/E\r\n// https://codeforces.com/contest/1691/problem/D\r\n// https://codeforces.com/problemset/problem/1712/D\r\n// https://codeforces.com/problemset/problem/1696/E\r\n// https://codeforces.com/contest/1678/problem/C\r\n// https://codeforces.com/problemset/problem/1682/D\r\n// https://codeforces.com/contest/1674/problem/E\r\n// https://codeforces.com/contest/1611/problem/G\r\n// https://codeforces.com/contest/1622/problem/E\r\n// https://codeforces.com/problemset/problem/1613/D\r\n\r\n// https://codeforces.com/problemset/problem/1641/B\r\n// https://codeforces.com/contest/1619/problem/H\r\n// https://codeforces.com/problemset/problem/1612/E\r\n// https://codeforces.com/contest/1593\r\n// https://codeforces.com/contest/1610/problem/D\r\n// https://codeforces.com/contest/1574\r\n\r\n// https://codeforces.com/contest/1493\r\n// https://codeforces.com/contest/1494/my\r\n// https://live.bilibili.com/25439759?broadcast_type=0&is_room_feed=1&spm_id_from=333.999.to_liveroom.0.click&live_from=86002\r\nconst i64 MOD = 1E9 + 7;  // 998244353;\r\nint add(int x, int y) {\r\n    x += y;\r\n    while (x >= MOD) x -= MOD;\r\n    while (x < 0) x += MOD;\r\n    return x;\r\n}\r\n\r\nbool frac_greater(pair<int, int> a, pair<int, int> b) {\r\n    return a.first * b.second > a.second * b.first;\r\n}\r\n\r\nbool intersect(pair<int, int> a, pair<int, int> b) {\r\n    if (a.first > b.first) swap(a, b);\r\n    return a.second > b.first and a.second < b.second;\r\n}\r\n\r\nstruct DSU {\r\n    vector<int> pa;\r\n    vector<int> sz;\r\n    int n;\r\n\r\n    DSU(int n_) : n(n_) {\r\n        pa.resize(n);\r\n        iota(pa.begin(), pa.end(), 0);\r\n        sz.resize(n, 1);\r\n    }\r\n\r\n    int find(int i) {\r\n        while (i != pa[i]) {\r\n            i = pa[i] = pa[pa[i]];\r\n        }\r\n        return i;\r\n    }\r\n\r\n    bool merge(int i, int j) {\r\n        i = find(i);\r\n        j = find(j);\r\n        if (i == j) {\r\n            return false;\r\n        }\r\n        if (sz[i] > sz[j]) {\r\n            pa[j] = i;\r\n            sz[i] += sz[j];\r\n        } else {\r\n            pa[i] = j;\r\n            sz[j] += sz[i];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    int siz(int i) { return sz[find(i)]; }\r\n};\r\n\r\n// https://codeforces.com/contest/1454\r\n// https://codeforces.com/problemset/problem/1458/B\r\n// https://codeforces.com/contest/1437/problem/D\r\n// https://codeforces.com/contest/1430\r\n// https://codeforces.com/contest/1428\r\n// https://codeforces.com/contest/1398\r\n\r\nclass matching {\r\n   public:\r\n    vector<vector<int>> g;\r\n    vector<int> pa;\r\n    vector<int> pb;\r\n    vector<int> was;\r\n    int n, m;\r\n    int res;\r\n    int iter;\r\n\r\n    matching(int _n, int _m) : n(_n), m(_m) {\r\n        pa = vector<int>(n, -1);\r\n        pb = vector<int>(m, -1);\r\n        was = vector<int>(n, 0);\r\n        g.resize(n);\r\n        res = 0;\r\n        iter = 0;\r\n    }\r\n\r\n    void add(int from, int to) { g[from].push_back(to); }\r\n\r\n    bool dfs(int u) {\r\n        was[u] = iter;\r\n        for (int v : g[u]) {\r\n            if (pb[v] == -1) {\r\n                pa[u] = v;\r\n                pb[v] = u;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (int v : g[u]) {\r\n            if (was[pb[v]] != iter && dfs(pb[v])) {\r\n                pa[u] = v;\r\n                pb[v] = u;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    int solve() {\r\n        while (true) {\r\n            iter++;\r\n            int add = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                if (pa[i] == -1 && dfs(i)) {\r\n                    add++;\r\n                }\r\n            }\r\n            if (add == 0) {\r\n                break;\r\n            }\r\n            res += add;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    int run_one(int u) {\r\n        if (pa[u] == -1) {\r\n            return 0;\r\n        }\r\n        iter++;\r\n        return (int)dfs(u);\r\n    }\r\n};\r\n// https://codeforces.com/contest/1399\r\n// https://codeforces.com/contest/1385\r\n\r\nstruct SegmentTree {\r\n    int n;\r\n    vector<vector<int>> tree;\r\n\r\n    void build(vector<int>& a, int x, int l, int r) {\r\n        if (l + 1 == r) {\r\n            tree[x] = {a[l]};\r\n            return;\r\n        }\r\n        int m = (l + r) / 2;\r\n        build(a, 2 * x + 1, l, m);\r\n        build(a, 2 * x + 2, m, r);\r\n        merge(tree[2 * x + 1].begin(), tree[2 * x + 1].end(),\r\n              tree[2 * x + 2].begin(), tree[2 * x + 2].end(),\r\n              back_inserter(tree[x]));\r\n    }\r\n\r\n    SegmentTree(vector<int>& a) : n(a.size()) {\r\n        int SIZE = 1 << (__lg(n) + bool(__builtin_popcount(n) - 1));\r\n        tree.resize(2 * SIZE - 1);\r\n        build(a, 0, 0, n);\r\n    }\r\n\r\n    int count(int lq, int rq, int mn, int mx, int x, int l, int r) {\r\n        if (rq <= l || r <= lq) return 0;\r\n        if (lq <= l && r <= rq)\r\n            return lower_bound(tree[x].begin(), tree[x].end(), mx) -\r\n                   lower_bound(tree[x].begin(), tree[x].end(), mn);\r\n\r\n        int m = (l + r) / 2;\r\n        int a = count(lq, rq, mn, mx, 2 * x + 1, l, m);\r\n        int b = count(lq, rq, mn, mx, 2 * x + 2, m, r);\r\n        return a + b;\r\n    }\r\n\r\n    int count(int lq, int rq, int mn, int mx) {\r\n        return count(lq, rq, mn, mx, 0, 0, n);\r\n    }\r\n};\r\n// https://codeforces.com/contest/1353\r\nconstexpr int dx[] = {-1, 1, 0, 0};\r\nconstexpr int dy[] = {0, 0, -1, 1};\r\n\r\nstruct SCC {\r\n    int n;\r\n    vector<vector<int>> adj;\r\n    vector<int> stk;\r\n    vector<int> dfn, low, bel;\r\n    int cur, cnt;\r\n\r\n    SCC() {}\r\n    SCC(int n) { init(n); }\r\n\r\n    void init(int n) {\r\n        this->n = n;\r\n        adj.assign(n, {});\r\n        dfn.assign(n, -1);\r\n        low.resize(n);\r\n        bel.assign(n, -1);\r\n        stk.clear();\r\n        cur = cnt = 0;\r\n    }\r\n\r\n    void addEdge(int u, int v) { adj[u].push_back(v); }\r\n\r\n    void dfs(int x) {\r\n        dfn[x] = low[x] = cur++;\r\n        stk.push_back(x);\r\n\r\n        for (auto y : adj[x]) {\r\n            if (dfn[y] == -1) {\r\n                dfs(y);\r\n                low[x] = min(low[x], low[y]);\r\n            } else if (bel[y] == -1) {\r\n                low[x] = min(low[x], dfn[y]);\r\n            }\r\n        }\r\n\r\n        if (dfn[x] == low[x]) {\r\n            int y;\r\n            do {\r\n                y = stk.back();\r\n                bel[y] = cnt;\r\n                stk.pop_back();\r\n            } while (y != x);\r\n            cnt++;\r\n        }\r\n    }\r\n\r\n    vector<int> work() {\r\n        for (int i = 0; i < n; i++) {\r\n            if (dfn[i] == -1) {\r\n                dfs(i);\r\n            }\r\n        }\r\n        return bel;\r\n    }\r\n};\r\n\r\n// https://codeforces.com/contest/1296/problem/F\r\n// https://codeforces.com/contest/1295/problem/D\r\nconst i64 INF = 1e16;\r\n\r\ni64 phi(i64 a) {\r\n    i64 t = a, ans = a;\r\n    i64 d = 2;\r\n\r\n    while (d * d <= t) {\r\n        i64 cnt = 0;\r\n\r\n        while (t % d == 0) {\r\n            t /= d;\r\n            cnt++;\r\n        }\r\n        if (cnt > 0) {\r\n            ans -= ans / d;\r\n        }\r\n        d++;\r\n    }\r\n    if (t > 1) {\r\n        ans -= ans / t;\r\n    }\r\n    return ans;\r\n}\r\n\r\nvoid solve() {\r\n    int n;\r\n    cin >> n;\r\n\r\n    vector<vector<int>> adj(n);\r\n    for (int i = 0; i < n - 1; i++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        --u, --v;\r\n        adj[u].push_back(v);\r\n        adj[v].push_back(u);\r\n    }\r\n\r\n    vector<int> pa(n);\r\n    vector<int> dep(n);\r\n    function<void(int, int)> dfs = [&](int u, int p) {\r\n        pa[u] = p;\r\n        for (auto v : adj[u]) {\r\n            if (v == p) continue;\r\n\r\n            dep[v] = dep[u] + 1;\r\n\r\n            dfs(v, u);\r\n        }\r\n    };\r\n    dfs(0, -1);\r\n    int mx = *max_element(dep.begin(), dep.end());\r\n    int start = -1;\r\n    for (int i = 0; i < n; i++) {\r\n        if (dep[i] == mx) {\r\n            start = i;\r\n            break;\r\n        }\r\n    }\r\n    pa.assign(n, -1);\r\n    dep.assign(n, 0);\r\n\r\n    dfs(start, -1);\r\n\r\n    mx = *max_element(dep.begin(), dep.end());\r\n    int end = -1;\r\n    for (int i = 0; i < n; i++) {\r\n        if (dep[i] == mx) {\r\n            end = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (mx == n - 1) {\r\n        cout << n - 1 << \"\\n\";\r\n        cout << start + 1 << \" \" << end + 1 << \" \";\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (i != start && i != end) {\r\n                cout << i + 1 << \"\\n\";\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    int i = end;\r\n\r\n    vector<bool> visited(n);\r\n    visited[i] = true;\r\n    while (pa[i] != -1) {\r\n        visited[pa[i]] = true;\r\n        i = pa[i];\r\n    }\r\n\r\n    int mxx = -1;\r\n    int mxy = -1;\r\n    i = end;\r\n    while (pa[i] != -1) {\r\n        queue<int> que;\r\n\r\n        que.push(pa[i]);\r\n        int d = 0;\r\n        while (!que.empty()) {\r\n            for (int j = que.size() - 1; j >= 0; j--) {\r\n                int u = que.front();\r\n                if (d > mxy) {\r\n                    mxx = u;\r\n                    mxy = d;\r\n                }\r\n                que.pop();\r\n                for (auto v : adj[u]) {\r\n                    if (!visited[v]) {\r\n                        visited[v] = true;\r\n                        que.push(v);\r\n                    }\r\n                }\r\n            }\r\n            d++;\r\n        }\r\n\r\n        i = pa[i];\r\n    }\r\n\r\n    cout << dep[end] + mxy << \"\\n\";\r\n    cout << start + 1 << \" \" << end + 1 << \" \" << mxx + 1 << \"\\n\";\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    // int tt;\r\n    // cin >> tt;\r\n    // while (tt--) {\r\n    //     solve();\r\n    // }\r\n    solve();\r\n}"
}