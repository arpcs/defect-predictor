{
    "id": 232015718,
    "contestId": 1359,
    "creationTimeSeconds": 1699502936,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1359,
        "index": "E",
        "name": "Modular Stability",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "combinatorics",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1359,
        "members": [
            {
                "handle": "psyducc"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1590676500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 15,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 18022400,
    "source": "#pragma GCC optimize(\"O3\")\r\n#pragma GCC target(\"avx2\")\r\n#pragma GCC optimize(\"Ofast\")\r\n// #pragma comment(linker, \"/STACK:1073741824\")\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <functional>\r\n\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\nusing ll = long long int;\r\n// #define int long long int\r\n// using ll = int;\r\nusing ull = unsigned long long;\r\nusing ld = long double;\r\n#define pq_min priority_queue<ll, vector<ll>, greater<ll>>\r\n#define ordered_set tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\r\n#define ordered_multiset tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>\r\n// order_of_key => number of elements less than, find_by_order => position, s.erase(s.upper_bound(x)) => erase elements\r\n#define MOD 1000000007\r\n#define mod 998244353\r\n#define all(x) begin(x), end(x)\r\n#define allr(x) rbegin(x), rend(x)\r\n#define F first\r\n#define S second\r\n#define fastio                        \\\r\n    ios_base::sync_with_stdio(false); \\\r\n    cin.tie(NULL)\r\n\r\nconst unsigned gen_seed = std::chrono::system_clock::now().time_since_epoch().count();\r\nstd::mt19937_64 gen(gen_seed);\r\n\r\nvoid init_code()\r\n{\r\n    fastio;\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nstruct custom_hash\r\n{\r\n    static uint64_t splitmix64(uint64_t x)\r\n    {\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const\r\n    {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\ntemplate <class K, class V>\r\nusing um = unordered_map<K, V, custom_hash>;\r\n\r\nll powermod(ll a, ll b, ll m = MOD)\r\n{\r\n    ll ans = 1;\r\n    while (b > 0)\r\n    {\r\n        if (b & 1ll)\r\n            ans = (1ll * (ans % m) * 1ll * (a % m)) % m;\r\n        a = (1ll * (a % m) * 1ll * (a % m)) % m;\r\n        b >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nll power(ll b, ll p)\r\n{\r\n    if (p == 0)\r\n        return 1;\r\n    else if (p == 1)\r\n        return b;\r\n    else\r\n    {\r\n        ll r = power(b, p / 2);\r\n        if (p % 2 == 0)\r\n            return (r * r);\r\n        else\r\n            return (((r * r)) * b);\r\n    }\r\n}\r\n\r\nclass DSU\r\n{\r\nprivate:\r\n    vector<int> parent, size;\r\n\r\npublic:\r\n    DSU(int n)\r\n    {\r\n        parent = vector<int>(n);\r\n        size = vector<int>(n, 1);\r\n        iota(begin(parent), end(parent), 0);\r\n    }\r\n\r\n    int getParent(int x)\r\n    {\r\n        if (parent[x] == x)\r\n            return x;\r\n        return parent[x] = getParent(parent[x]);\r\n    }\r\n\r\n    bool join(int x, int y)\r\n    {\r\n        x = getParent(x);\r\n        y = getParent(y);\r\n\r\n        if (x == y)\r\n            return false;\r\n\r\n        if (size[x] > size[y])\r\n            swap(x, y);\r\n\r\n        parent[x] = y;\r\n        size[y] += size[x];\r\n        return true;\r\n    }\r\n\r\n    int getSize(int x)\r\n    {\r\n        return size[x] = size[getParent(x)];\r\n    }\r\n};\r\n\r\nstruct FenwickTreeOneBasedIndexing\r\n{\r\n    vector<ll> bit; // binary indexed tree\r\n    int n;\r\n\r\n    FenwickTreeOneBasedIndexing(int n)\r\n    {\r\n        this->n = n + 1;\r\n        bit.assign(n + 1, 0);\r\n    }\r\n\r\n    FenwickTreeOneBasedIndexing(vector<ll> a)\r\n        : FenwickTreeOneBasedIndexing(a.size())\r\n    {\r\n        for (size_t i = 0; i < a.size(); i++)\r\n            add(i, a[i]);\r\n    }\r\n\r\n    ll sum(int idx)\r\n    {\r\n        ll ret = 0;\r\n        for (++idx; idx > 0; idx -= idx & -idx)\r\n            ret += bit[idx];\r\n        return ret;\r\n    }\r\n\r\n    ll sum(int l, int r)\r\n    {\r\n        return sum(r) - sum(l - 1);\r\n    }\r\n\r\n    void add(int idx, ll val)\r\n    {\r\n        for (++idx; idx < n; idx += idx & -idx)\r\n            bit[idx] += val;\r\n    }\r\n\r\n    void range_add(int l, int r, ll val)\r\n    {\r\n        add(l, val);\r\n        add(r + 1, -val);\r\n    }\r\n\r\n    int point_query(int idx)\r\n    {\r\n        int ret = 0;\r\n        for (++idx; idx > 0; idx -= idx & -idx)\r\n            ret += bit[idx];\r\n        return ret;\r\n    }\r\n};\r\n\r\ntemplate <class S, S (*op)(S, S), S (*e)()>\r\nstruct segtree\r\n{\r\npublic:\r\n    int ceil_pow2(int n)\r\n    {\r\n        int x = 0;\r\n        while ((1U << x) < (unsigned int)(n))\r\n            x++;\r\n        return x;\r\n    }\r\n    segtree() : segtree(0) {}\r\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\r\n    explicit segtree(const std::vector<S> &v) : _n(int(v.size()))\r\n    {\r\n        log = ceil_pow2(_n);\r\n        size = 1 << log;\r\n        d = std::vector<S>(2 * size, e());\r\n        for (int i = 0; i < _n; i++)\r\n            d[size + i] = v[i];\r\n        for (int i = size - 1; i >= 1; i--)\r\n        {\r\n            update(i);\r\n        }\r\n    }\r\n\r\n    void set(int p, S x)\r\n    {\r\n        assert(0 <= p && p < _n);\r\n        p += size;\r\n        d[p] = x;\r\n        for (int i = 1; i <= log; i++)\r\n            update(p >> i);\r\n    }\r\n\r\n    S get(int p) const\r\n    {\r\n        assert(0 <= p && p < _n);\r\n        return d[p + size];\r\n    }\r\n\r\n    S prod(int l, int r) const\r\n    {\r\n        assert(0 <= l && l <= r && r <= _n);\r\n        S sml = e(), smr = e();\r\n        l += size;\r\n        r += size;\r\n\r\n        while (l < r)\r\n        {\r\n            if (l & 1)\r\n                sml = op(sml, d[l++]);\r\n            if (r & 1)\r\n                smr = op(d[--r], smr);\r\n            l >>= 1;\r\n            r >>= 1;\r\n        }\r\n        return op(sml, smr);\r\n    }\r\n\r\n    S all_prod() const { return d[1]; }\r\n\r\n    template <bool (*f)(S)>\r\n    int max_right(int l) const\r\n    {\r\n        return max_right(l, [](S x)\r\n                         { return f(x); });\r\n    }\r\n    template <class F>\r\n    int max_right(int l, F f) const\r\n    {\r\n        assert(0 <= l && l <= _n);\r\n        assert(f(e()));\r\n        if (l == _n)\r\n            return _n;\r\n        l += size;\r\n        S sm = e();\r\n        do\r\n        {\r\n            while (l % 2 == 0)\r\n                l >>= 1;\r\n            if (!f(op(sm, d[l])))\r\n            {\r\n                while (l < size)\r\n                {\r\n                    l = (2 * l);\r\n                    if (f(op(sm, d[l])))\r\n                    {\r\n                        sm = op(sm, d[l]);\r\n                        l++;\r\n                    }\r\n                }\r\n                return l - size;\r\n            }\r\n            sm = op(sm, d[l]);\r\n            l++;\r\n        } while ((l & -l) != l);\r\n        return _n;\r\n    }\r\n\r\n    template <bool (*f)(S)>\r\n    int min_left(int r) const\r\n    {\r\n        return min_left(r, [](S x)\r\n                        { return f(x); });\r\n    }\r\n    template <class F>\r\n    int min_left(int r, F f) const\r\n    {\r\n        assert(0 <= r && r <= _n);\r\n        assert(f(e()));\r\n        if (r == 0)\r\n            return 0;\r\n        r += size;\r\n        S sm = e();\r\n        do\r\n        {\r\n            r--;\r\n            while (r > 1 && (r % 2))\r\n                r >>= 1;\r\n            if (!f(op(d[r], sm)))\r\n            {\r\n                while (r < size)\r\n                {\r\n                    r = (2 * r + 1);\r\n                    if (f(op(d[r], sm)))\r\n                    {\r\n                        sm = op(d[r], sm);\r\n                        r--;\r\n                    }\r\n                }\r\n                return r + 1 - size;\r\n            }\r\n            sm = op(d[r], sm);\r\n        } while ((r & -r) != r);\r\n        return 0;\r\n    }\r\n\r\nprivate:\r\n    int _n, size, log;\r\n    std::vector<S> d;\r\n\r\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\r\n};\r\n\r\nvector<ll> primes;\r\nbool prime[10000001 + 1];\r\nvoid SieveOfEratosthenes(int n)\r\n{\r\n    memset(prime, true, sizeof(prime));\r\n\r\n    for (int p = 2; p * p <= n; p++)\r\n        if (prime[p] == true)\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n\r\n    prime[0] = false;\r\n\r\n    for (int p = 2; p <= n; p++)\r\n        if (prime[p])\r\n            primes.push_back(p);\r\n}\r\n\r\nvoid SPFSieve(int n)\r\n{\r\n    primes.assign(n + 1, 0);\r\n    iota(all(primes), 0);\r\n\r\n    for (int i = 2; i * i <= n; i++)\r\n    {\r\n        if (primes[i] == i)\r\n        {\r\n            for (int j = i * i; j <= n; j += i)\r\n                if (primes[j] == j)\r\n                    primes[j] = i;\r\n        }\r\n    }\r\n}\r\n\r\nll __lcm(ll a, ll b)\r\n{\r\n    ll gcd = __gcd(a, b);\r\n    return (a * b) / gcd;\r\n}\r\n\r\nll setBitNumber(ll n)\r\n{\r\n    if (n == 0)\r\n        return 0;\r\n\r\n    ll msb = 0;\r\n    n = n / 2;\r\n    while (n != 0)\r\n    {\r\n        n = n / 2;\r\n        msb++;\r\n    }\r\n\r\n    return (1LL << msb);\r\n}\r\n\r\n// Returns n^(-1) mod p\r\nunsigned long long modInverse(unsigned long long n,\r\n                              int p)\r\n{\r\n    return powermod(n, p - 2, p);\r\n}\r\n\r\n// Returns nCr % p using Fermat's little\r\n// theorem.\r\nunsigned long long fac[(ll)1e6 + 5];\r\n\r\nvoid factorial(ll p = MOD)\r\n{\r\n    fac[0] = 1;\r\n\r\n    // precompute factorials\r\n    for (ll i = 1; i < (ll)1e6 + 5; i++)\r\n        fac[i] = (fac[i - 1] * i) % p;\r\n}\r\n\r\nunsigned long long nCrModPFermat(unsigned long long n,\r\n                                 int r, ll p = MOD)\r\n{\r\n    // If n<r, then nCr should return 0\r\n    if (n < r)\r\n        return 0;\r\n    // Base case\r\n    if (r == 0)\r\n        return 1;\r\n\r\n    // Fill factorial array so that we\r\n    // can find all factorial of r, n\r\n    // and n-r\r\n    if (fac[0] != 1)\r\n        factorial(p);\r\n\r\n    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\r\n}\r\n\r\nll nCr(ll n, ll k)\r\n{\r\n    ld res = 1;\r\n    for (ll i = 1; i <= k; ++i)\r\n        res = res * (n - k + i) / i;\r\n    return (ll)(res + 0.01);\r\n}\r\n\r\nll naturalSum(ll val)\r\n{\r\n    ll ret = (val * 1ll * (val + 1ll)) / 2ll;\r\n    return ret;\r\n}\r\n\r\nll mul(ll a, ll b, ll m = MOD)\r\n{\r\n    return ((a % m) * (b % m)) % m;\r\n}\r\n\r\nstring decimalToBinary(long n, int bits = 10)\r\n{\r\n    string s = \"\";\r\n    for (long i = 1 << bits; i > 0; i = i / 2)\r\n    {\r\n        if ((n & i) != 0)\r\n            s += '1';\r\n        else\r\n            s += '0';\r\n    }\r\n\r\n    return s;\r\n}\r\n\r\nbool isPrime(ll n)\r\n{\r\n    // Corner case\r\n    if (n <= 1)\r\n        return false;\r\n\r\n    // Check from 2 to n-1\r\n    for (ll i = 2; i * i <= n; i++)\r\n        if (n % i == 0)\r\n            return false;\r\n\r\n    return true;\r\n}\r\n\r\nint testcase;\r\n// Read and try to understand every single test case\r\n// Divide test cases into cases. Almost every test case is there for a reason.\r\n// Taking more time than expected? Open paint and start writing\r\n// Still can't find a pattern? Write a bruteforce and look for a pattern there.\r\n// Try to minimize code for A and B. It will almost always have a simple solution.\r\n// __builtin_popcount(x): the number of ones in the bit representation\r\n\r\n// find first point where prefix sum becomes negative after current index\r\n\r\nll op(ll a, ll b) { return min(a, b); }\r\nll e() { return 1e15; }\r\n\r\nvoid solve()\r\n{\r\n    ll n, k;\r\n    cin >> n >> k;\r\n\r\n    ll ans = 0;\r\n\r\n    for (int i = 1; i <= n; i++)\r\n    {\r\n        ll tot = (n / i) - 1;\r\n\r\n        ans = (ans + nCrModPFermat(tot, k - 1, mod)) % mod;\r\n    }\r\n\r\n    cout << ans << \"\\n\";\r\n}\r\n\r\nint32_t main()\r\n{\r\n    init_code();\r\n    cout << fixed;\r\n\r\n    int t = 1;\r\n    // cin >> t;\r\n\r\n    for (testcase = 1; testcase <= t; testcase++)\r\n    {\r\n        // cout << \"Case #\" << testcase << \": \";\r\n        solve();\r\n    }\r\n    return 0;\r\n}"
}