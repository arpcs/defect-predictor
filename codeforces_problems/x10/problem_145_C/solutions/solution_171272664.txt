{
    "id": 171272664,
    "contestId": 145,
    "creationTimeSeconds": 1662577702,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 145,
        "index": "C",
        "name": "Lucky Subsequence",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "math"
        ]
    },
    "author": {
        "contestId": 145,
        "members": [
            {
                "handle": "shubhambhadada"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1327215600
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 58,
    "timeConsumedMillis": 186,
    "memoryConsumedBytes": 13209600,
    "source": "// \u0950 \u092d\u0942\u0930\u094d \u092d\u0941\u0935\u0903 \u0938\u094d\u0935\u0903 \u0964 \u0924\u0924\u094d \u0938\u0935\u093f\u0924\u0941\u0930\u094d\u0935\u0930\u0947\u0923\u094d\u092f\u0902 \u0964 \u092d\u0930\u094d\u0917\u094b \u0926\u0947\u0935\u0938\u094d\u092f \u0927\u0940\u092e\u0939\u093f \u0964 \u0927\u093f\u092f\u094b \u092f\u094b \u0928\u0903 \u092a\u094d\u0930\u091a\u094b\u0926\u092f\u093e\u0924\u094d \u0965\r\n\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp> \r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <ext/rope>\r\n\r\n\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\nusing namespace __gnu_cxx;\r\n\r\n\r\nvoid __print(int x) {cerr << x;}\r\nvoid __print(long x) {cerr << x;}\r\nvoid __print(long long x) {cerr << x;}\r\nvoid __print(unsigned x) {cerr << x;}\r\nvoid __print(unsigned long x) {cerr << x;}\r\nvoid __print(unsigned long long x) {cerr << x;}\r\nvoid __print(float x) {cerr << x;}\r\nvoid __print(double x) {cerr << x;}\r\nvoid __print(long double x) {cerr << x;}\r\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\r\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\r\n\r\ntemplate<typename T, typename V>\r\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\r\ntemplate<typename T>\r\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\r\nvoid _print() {cerr << \"]\\n\";}\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\r\n#ifndef ONLINE_JUDGE\r\n#define bug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\r\n#else\r\n#define bug(x...)\r\n#endif\r\n\r\n\r\n\r\n#define         int              long long int\r\n#define         F                first\r\n#define         S                second\r\n#define         pb               push_back\r\n#define         si               set<int>\r\n#define         vi               vector<int>\r\n#define         pii              pair<int,int>\r\n#define         vpi              vector<pii>\r\n#define         vpp              vector<pair<int,pii>>\r\n#define         mii              map<int,int>\r\n#define         mpi              map<pii,int>\r\n#define         spi              set<pii>\r\n#define         endl             \"\\n\"\r\n#define         sz(x)            ((int)x.size())\r\n#define         all(p)           p.begin(),p.end()\r\n#define         double           long double\r\n#define         que_max          priority_queue<int>\r\n#define         que_min          priority_queue<int,vi,greater<int>>\r\n#define         setbits(x)       __builtin_popcountll(x)\r\n#define         zerobits(x)       __builtin_ctzll(x)\r\n#define         msb(x)           (int)log2(x)\r\n\r\n#define         ordered_set      tree<int , null_type, less<int> , rb_tree_tag , tree_order_statistics_node_update> \r\n#define         ordered_multiset tree<int , null_type ,  less_equal<int> , rb_tree_tag , tree_order_statistics_node_update> \r\n\r\n\r\nconst int N=200005;\r\nconst int MOD1=1000000007;\r\nconst int MOD2=998244353;\r\n\r\n\r\nint bexp(int a,int b,int mod){\r\n    if(b==0){\r\n        return 1;\r\n    }\r\n    a%=mod;\r\n    if(b&1){\r\n        return (a*bexp(a,b-1,mod))%mod;\r\n    }\r\n    else{\r\n        return bexp((a*a)%mod,b>>1,mod);\r\n    }\r\n}\r\n\r\n\r\nclass blift{\r\npublic:\r\n\r\n    int n;\r\n    vector<vector<int>> dp;\r\n    vector<int> in,out;\r\n    int timer;\r\n\r\n    blift(int n,vector<int> *g){\r\n        this->n=n;\r\n        dp.resize(n);\r\n        in.resize(n,0);\r\n        out.resize(n,0);\r\n        fill(all(in),0);\r\n        fill(all(out),0);\r\n\r\n        timer=0;\r\n\r\n        for(int i=0;i<n;++i){\r\n            dp[i].resize(log2(n)+1);\r\n        }\r\n\r\n        dfs(0,0,g);\r\n    }\r\n\r\n    void dfs(int node,int par,vector<int> *g){\r\n        dp[node][0]=par;\r\n        int l=log2(n)+1;\r\n        in[node]=++timer;\r\n        for(int j=1;j<l;++j){\r\n            dp[node][j]=dp[dp[node][j-1]][j-1];\r\n        }\r\n        for(auto j:g[node]){\r\n            if(j==par){\r\n                continue;\r\n            }\r\n            dfs(j,node,g);\r\n        }\r\n        out[node]=++timer;\r\n    }\r\n\r\n    bool same(int u,int v){\r\n        return (in[u]<=in[v] and out[u]>=out[v]);\r\n    }\r\n\r\n    int lca(int u,int v){\r\n        if(same(u,v)){\r\n            return u;\r\n        }\r\n        if(same(v,u)){\r\n            return v;\r\n        }\r\n        int l=log2(n);\r\n\r\n        for(int i=l;i>=0;--i){\r\n            if(!same(dp[u][i],v)){\r\n                u=dp[u][i];\r\n            }\r\n        }\r\n        return dp[u][0];\r\n    }\r\n};\r\n\r\n\r\nclass dsu{\r\npublic:\r\n    int n;\r\n    vi par,size;\r\n    dsu(int n){\r\n        this->n=n;\r\n        par.resize(n);\r\n        size.resize(n);\r\n        for(int i=0;i<n;++i){\r\n            par[i]=i;\r\n            size[i]=1;\r\n        }\r\n    }\r\n    int find(int u){\r\n        if(par[u]==u){\r\n            return u;\r\n        }\r\n        return par[u]=find(par[u]);\r\n    }\r\n    void merge(int u,int v){\r\n        u=find(u);\r\n        v=find(v);\r\n        if(u==v){\r\n            return ;\r\n        }\r\n        if(size[u]>size[v]){\r\n            size[u]+=size[v];\r\n            par[v]=u;\r\n        }\r\n        else{\r\n            size[v]+=size[u];\r\n            par[u]=v;\r\n        }\r\n    }\r\n};\r\n\r\n\r\nclass facm {\r\npublic:\r\n    vector<int>fac,inv;\r\n    int n=0,mod;\r\n    facm(int x,int M) { \r\n        n=x;\r\n        mod=M;\r\n        fac.resize(n+1),inv.resize(n+1); \r\n        fac[0]=1;\r\n        for(int i=1;i<=n;i++) {\r\n            fac[i]=(fac[i-1]*i)%mod;\r\n        }\r\n    }\r\n    void preinv() { \r\n        inv[n]=bexp(fac[n],mod-2,mod);\r\n        for(int i=n-1;i>=0;i--) {\r\n            inv[i]=(inv[i+1]*(i+1))%mod;\r\n        }\r\n    }\r\n    int choose(int a,int b) { \r\n        if(a<b || a<0 || b<0) {\r\n            return 0;\r\n        }\r\n        return ((fac[a]*inv[b])%mod*inv[a-b])%mod;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nclass segm{\r\npublic:\r\n    vi seg;\r\n    int n;\r\n    segm(int n,int *a){\r\n        this->n=n;\r\n        seg.resize(4*n);\r\n        build(0,0,n-1,a);\r\n    }\r\n    void build(int node,int l,int r,int *a){\r\n        if(l==r){\r\n            seg[node]=a[l];\r\n            return ;\r\n        }\r\n        int mid=(l+r)/2;\r\n        build(2*node+1,l,mid,a);\r\n        build(2*node+2,mid+1,r,a);\r\n        seg[node]=seg[2*node+1]+seg[2*node+2];\r\n    }\r\n    int get(int node,int l,int r,int ql,int qr){\r\n        if(l>qr or r<ql){\r\n            return 0;\r\n        }\r\n        if(ql<=l and qr>=r){\r\n            return seg[node];\r\n        }\r\n        int mid=(l+r)/2;\r\n        int a=get(2*node+1,l,mid,ql,qr);\r\n        int b=get(2*node+2,mid+1,r,ql,qr);\r\n        return a+b;\r\n    }\r\n    void upd(int node,int l,int r,int idx,int data,int *a){\r\n        if(l==r){\r\n            a[l]+=data;\r\n            seg[node]+=data;\r\n            return ;\r\n        }\r\n        int mid=(l+r)/2;\r\n        if(idx>=l and idx<=mid){\r\n            upd(2*node+1,l,mid,idx,data,a);\r\n        }\r\n        else{\r\n            upd(2*node+2,mid+1,r,idx,data,a);\r\n        }\r\n        seg[node]=(seg[2*node+1]+seg[2*node+2]);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass sparse{\r\npublic:\r\n    vector<vector<int>> st;\r\n    int n;\r\n    sparse(int n,int *a){\r\n        this->n=n;\r\n        st.resize(n+1);\r\n        for(int i=0;i<=n;++i){\r\n            st[i].resize(30);\r\n        }\r\n        for(int i=0;i<n;++i){\r\n            st[i][0]=a[i];\r\n        }\r\n        for(int j=1;j<=log2(n);++j){\r\n            for(int i=0;i+(1<<j)<=n;++i){\r\n                st[i][j]=__gcd(st[i][j-1],st[i+(1<<(j-1))][j-1]);\r\n            }\r\n        }\r\n    }\r\n    int shoot(int l,int r){\r\n        int j=log2(r-l+1);\r\n        int ans=__gcd(st[l][j],st[r-(1<<(j))+1][j]);\r\n        return ans;\r\n    }\r\n\r\n};\r\n\r\nint dp[1050][1050];\r\n\r\nint rec(int i,int n,int cnt,vpi &v){\r\n\r\n    if(i==n){\r\n        if(cnt==0){\r\n            return 1;\r\n        }\r\n        else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    if(dp[i][cnt]!=-1){\r\n        return dp[i][cnt];\r\n    }\r\n\r\n\r\n\r\n    int ans=0;\r\n    if(cnt){\r\n        ans=(ans+v[i].S*(rec(i+1,n,cnt-1,v)))%MOD1;\r\n    }\r\n    ans=(ans+rec(i+1,n,cnt,v))%MOD1;\r\n    return dp[i][cnt]=ans;\r\n}\r\n\r\nvoid solve(){\r\n    int n,k;\r\n    cin>>n>>k;\r\n    int a[n];\r\n    map<int,int> fr;\r\n    int un=0;\r\n    for(int i=0;i<n;++i){\r\n        cin>>a[i];\r\n        string s;\r\n        s=to_string(a[i]);\r\n        if(count(all(s),'7')+count(all(s),'4')==sz(s)){\r\n            fr[a[i]]++;\r\n        }\r\n        else{\r\n            un++;\r\n        }\r\n    }\r\n    vpi v;\r\n    for(auto i:fr){\r\n        v.pb(i);\r\n    }\r\n    int m=sz(v);\r\n    memset(dp,-1,sizeof(dp));\r\n    int cnt[m+1]={0};\r\n\r\n    for(int i=m;i>=0;--i){\r\n        cnt[i]=rec(0,m,i,v);\r\n    }\r\n\r\n    for(int i=0;i<=m;++i){\r\n        bug(cnt[i]);\r\n    }\r\n\r\n    facm ff(200000,MOD1);\r\n    ff.preinv();\r\n\r\n\r\n    int res=0;\r\n\r\n\r\n    for(int i=0;i<=k;++i){\r\n        int dist=k-i;\r\n\r\n        if(m>=dist){\r\n            int x;\r\n            if(un<i){\r\n                continue;\r\n            }\r\n            if(un==i){\r\n                x=(cnt[dist])%MOD1;\r\n\r\n            }\r\n            else{\r\n                x=(cnt[dist]*ff.choose(un,i))%MOD1;\r\n\r\n            }\r\n            res+=x;\r\n            res%=MOD1;\r\n        }\r\n    }\r\n\r\n    cout<<res<<endl;\r\n}\r\n\r\nint32_t main()\r\n{\r\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\r\n\r\n    #ifndef ONLINE_JUDGE\r\n        freopen(\"input.txt\",\"r\",stdin);\r\n        freopen(\"output.txt\",\"w\",stdout);\r\n    #endif\r\n\r\n    clock_t z=clock();\r\n    int t;\r\n    // cin>>t;\r\n    t=1;\r\n    while(t--)\r\n    {\r\n        solve();\r\n    }\r\n    \r\n    cerr<<\"Runtime : \"<<((double)(clock()-z)/CLOCKS_PER_SEC);\r\n    return 0;\r\n}"
}