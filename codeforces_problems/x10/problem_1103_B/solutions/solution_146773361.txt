{
    "id": 146773361,
    "contestId": 1103,
    "creationTimeSeconds": 1645125728,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1103,
        "index": "B",
        "name": "Game with modulo",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 2000,
        "tags": [
            "binary search",
            "constructive algorithms",
            "interactive"
        ]
    },
    "author": {
        "contestId": 1103,
        "members": [
            {
                "handle": "amit_kumar112"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1548167700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define vi             vector<ll> \r\n#define mi             map<ll,ll>\r\n#define pi             pair<ll,ll>\r\n#define pqueue         priority_queue<ll,vector<ll>,greater<ll>>\r\n#define si             set<ll>\r\n#define endl            \"\\n\"\r\n#define ins             insert \r\n#define hell             1000000007\r\n#define INF             +2e+18\r\n#define PI              3.1415926535897932384\r\n#define ll              long long \r\n#define f               first\r\n#define s              second\r\n#define pb             push_back\r\n#define pp             pop_back\r\n#define fr(n)          for(ll i=0;i<n;i++)\r\n#define FAST           ios_base::sync_with_stdio(false); cin.tie(NULL);\r\n#define narak             998244353 \r\n#define decimal(n)  std::cout << std::fixed;std::cout << std::setprecision(n);\r\n#define make make_pair\r\n#define mem0(a)         memset(a,0,sizeof(a))\r\n#define mem1(a)         memset(a,-1,sizeof(a))\r\n#define ALL(v) v.begin(), v.end()\r\n#define SORT(v) sort(ALL(v))  \r\n#define REVERSE(v) reverse(ALL(v))\r\n#define maxc(v) max_element(all(v))\r\n#define minc(v) min_element(all(v))\r\n#define GCD(m,n) __gcd(m,n)\r\n#define LCM(m,n) m*(n/GCD(m,n))\r\n#define sz(a) (ll)a.size()\r\n#define loop(i,a,b) for(ll i=a;i<=b;i++)\r\n/*\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\n\r\n//template <typename T> \r\n//jj\r\n//using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n//#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>\r\n//#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\r\n//std::ifstream in(\"input.txt\");\r\n//std::ofstream out(\"output.txt\");\r\n\r\n\r\nINT_MIN Minimum value for a variable of type int. -2147483647 \r\nINT_MAX Maximum value for a variable of type int.  2147483647\r\nLLONG_MIN Minimum value for a variable of type long long. -9,223,372,036,854,775,807 \r\nLLONG_MAX Maximum value for a variable of type long long.  9,223,372,036,854,775,807\r\n\r\n\r\nbool comp(ll a,ll b) \r\n{ return (a < b); } \r\n\r\nmap<ll,ll>allpowofno(ll n)\r\n{\r\n    map<ll,ll>mp;\r\n    for(ll i=2;i*i<=n;i++)\r\n    {\r\n        if(n%i==0)\r\n        {\r\n            mp[i]++;\r\n            n/=i;\r\n            i--;\r\n        }\r\n    }\r\n    if(n!=1)\r\n    mp[n]++;\r\n    return mp;}\r\nll primepow(ll n,ll k)\r\n{\r\n    ll res=0;\r\n    while(n)\r\n    {\r\n      n/=k;\r\n      res+=n;\r\n    }\r\n    return res;}\r\nll allpowofnocomp(ll n,ll k)\r\n{\r\n    mi mp=allpowofno(k);\r\n    ll ans;\r\n    for(auto it=mp.begin();it!=mp.end();++it)\r\n    {\r\n        cout<<it->f<<\" \"<<it->s<<endl;\r\n        ll z=primepow(n,it->f);\r\n        ans=min(ans,z/(it->s));\r\n    }\r\n    return ans;    }\r\n\r\n\r\nbool sortbysec(const pair<ll,ll> &a, const pair<ll,ll> &b) \r\n{\r\n  return (a.second < b.second); \r\n} \r\n\r\n\r\n\r\nll modInverse(ll n,ll p) \r\n{ \r\n    return power(n,p-2,p); \r\n}\r\n\r\n\r\nvoid buildtree(ll *tree,ll *s,ll index,ll start,ll end)\r\n{\r\n    if(start>end)\r\n    return ;\r\n    if(start==end)\r\n    {\r\n        tree[index]=s[start];\r\n        return;\r\n    }\r\n    ll mid=(start+end)/2;\r\n    buildtree(tree,s,2*index,start,mid);\r\n    buildtree(tree,s,2*index+1,mid+1,end);\r\n    ll left=tree[2*index];\r\n    ll right=tree[2*index+1];\r\n    tree[index]=max(left,right);\r\n    return ;\r\n}\r\nll query(ll *tree,ll index,ll s,ll e,ll qs,ll qe)\r\n{\r\n    // no overlap\r\n    if(qs>e||s>qe)\r\n    return int_MIN;\r\n    if(qe>=e&&s>=qs)\r\n    {\r\n        return tree[index];\r\n    }\r\n    ll mid=(s+e)/2;\r\n    ll left=query(tree,2*index,s,mid,qs,qe);\r\n    ll right=query(tree,2*index+1,mid+1,e,qs,qe);\r\n    return max(left,right);\r\n}\r\nbuildtree(tree,s,1,0,n-1); // 1 based tree is formed but array is 0 based\r\nquery(tree,1,0,n-1,x,y); // x and y are indexss\r\n\r\n\r\n\r\n\r\n\r\nvoid Mobius()\r\n{\r\n    mobius[1]=1;\r\n    for(ll i=2;i<=N-2;++i)\r\n    {\r\n        if(lpf[i/lpf[i]]==lpf[i])\r\n            mobius[i]=0;\r\n        else\r\n            mobius[i]=-1*mobius[i/lpf[i]];\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nvector<ll>fac(200005);\r\nvoid build()\r\n{\r\n    fac[0]=1;\r\n    fac[1]=1;\r\n    for(ll i=2;i<=200000;i++)\r\n    {\r\n        fac[i]=i*fac[i-1];\r\n        fac[i]%=N;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nll power(ll x,ll y,ll p)\r\n{\r\n    ll res = 1; // Initialize result\r\n    x = x % p; // Update x if it is more than or equal to p\r\n    while (y > 0) \r\n    {\r\n        // If y is odd, multiply x with result\r\n        if (y & 1)\r\n            res = (res * x) % p;\r\n        // y must be even now\r\n        y = y >> 1; // y = y/2\r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\nll modInverse(ll n,ll p)\r\n{\r\n    return power(n, p - 2, p);\r\n}\r\n \r\n// Returns nCr % p using Fermat's little\r\n// theorem.\r\nll ncr(ll n,ll r,ll p)\r\n{\r\n    // If n<r, then nCr should return 0\r\n    if (n < r)\r\n        return 0;\r\n    // Base case\r\n    if (r == 0)\r\n        return 1;\r\n \r\n    // Fill factorial array so that we\r\n    // can find all factorial of r, n\r\n    // and n-r\r\n    \r\n \r\n    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\r\n}\r\n*/  \r\n\r\n// Matrix power\r\n\r\n\r\nvoid solve(ll nn)\r\n{\r\n    ll ans=-1;\r\n    ll x=0;\r\n    ll y=1;\r\n    ll l=1,r=INF;\r\n    for(ll i=1;i<=30;i++)\r\n    {\r\n        cout<<\"? \"<<x<<\" \"<<y<<endl;\r\n        string s;\r\n        cin>>s;\r\n        if(s==\"x\")\r\n        {\r\n            l=x;\r\n            r=y;\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            if(i==1)\r\n            {\r\n                y=1;\r\n            }\r\n            else\r\n            y*=2;\r\n            x*=2;\r\n        }\r\n    }\r\n    \r\n    while(l<r)\r\n    {\r\n        cout<<\"? \"<<(l)<<\" \"<<r<<endl;\r\n        string s;\r\n        cin>>s;\r\n        if(s==\"x\")\r\n        {\r\n            r=(l+r)/2;\r\n            \r\n        }\r\n        else\r\n        {\r\n            l=(l+r)/2+1;\r\n        }\r\n    }\r\n    \r\n    \r\n    cout<<\"! \"<<l<<endl;\r\n    \r\n    \r\n    return ;\r\n}\r\n        \r\n\r\nint main()\r\n{ \r\n   decimal(15);\r\n   //FAST;\r\n   //build();\r\n   //LPF();\r\n   ll t;\r\n   t=1;\r\n   //cin>>t; \r\n   while(1)\r\n   {\r\n       string s;\r\n       cin>>s;\r\n       if(s==\"start\")\r\n       solve(1);\r\n       else\r\n       return 0;\r\n   }\r\n   //for(ll i=1;i<=t;i++)\r\n   //solve(i);\r\n   return 0;\r\n}\r\n\r\n\r\n  "
}