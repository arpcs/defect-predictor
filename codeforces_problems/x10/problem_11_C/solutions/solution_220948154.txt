{
    "id": 220948154,
    "contestId": 11,
    "creationTimeSeconds": 1693300803,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 11,
        "index": "C",
        "name": "How Many Squares?",
        "type": "PROGRAMMING",
        "rating": 2200,
        "tags": [
            "implementation"
        ]
    },
    "author": {
        "contestId": 11,
        "members": [
            {
                "handle": "mora_unie_youer"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1272294000
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 38,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 14848000,
    "source": "use std::io::BufRead;\r\n\r\n/**\r\n * C. How Many Squares?\r\n * time limit per test: 2 seconds\r\n * memory limit per test: 64 megabytes\r\n * input: standard input\r\n * output: standard output\r\n *\r\n * You are given a 0-1 rectangular matrix. What is the number of squares in it? A square is a solid square frame (border)\r\n * with linewidth equal to 1. A square should be at least 2\u2009\u00d7\u20092. We are only interested in two types of squares:\r\n *   squares with each side parallel to a side of the matrix;\r\n *   squares with each side parallel to a diagonal of the matrix.\r\n *\r\n * For example the following matrix contains only one square of the first type:\r\n * 0000000\r\n * 0111100\r\n * 0100100\r\n * 0100100\r\n * 0111100\r\n *\r\n *\r\n * The following matrix contains only one square of the second type:\r\n * 0000000\r\n * 0010000\r\n * 0101000\r\n * 0010000\r\n * 0000000\r\n *\r\n * Regardless of type, a square must contain at least one 1 and can't touch (by side or corner) any foreign 1. Of course,\r\n * the lengths of the sides of each square should be equal.\r\n *\r\n * How many squares are in the given matrix?\r\n *\r\n * Input\r\n * The first line contains integer t (1\u2009\u2264\u2009t\u2009\u2264\u200910000), where t is the number of test cases in the input. Then test cases\r\n * follow. Each case starts with a line containing integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009250), where n is the number of rows and m\r\n * is the number of columns. The following n lines contain m characters each (0 or 1).\r\n *\r\n * The total number of characters in all test cases doesn't exceed 106 for any input file.\r\n *\r\n * Output\r\n * You should output exactly t lines, with the answer to the i-th test case on the i-th line.\r\n *\r\n * Examples\r\n *   Input\r\n *   2\r\n *   8 8\r\n *   00010001\r\n *   00101000\r\n *   01000100\r\n *   10000010\r\n *   01000100\r\n *   00101000\r\n *   11010011\r\n *   11000011\r\n *   10 10\r\n *   1111111000\r\n *   1000001000\r\n *   1011001000\r\n *   1011001010\r\n *   1000001101\r\n *   1001001010\r\n *   1010101000\r\n *   1001001000\r\n *   1000001000\r\n *   1111111000\r\n *   \r\n *   Output\r\n *   1\r\n *   2\r\n *   \r\n *   Input\r\n *   1\r\n *   12 11\r\n *   11111111111\r\n *   10000000001\r\n *   10111111101\r\n *   10100000101\r\n *   10101100101\r\n *   10101100101\r\n *   10100000101\r\n *   10100000101\r\n *   10111111101\r\n *   10000000001\r\n *   11111111111\r\n *   00000000000\r\n *   \r\n *   Output\r\n *   3\r\n */\r\nfn main() {\r\n    let stdin = std::io::stdin();\r\n    let mut lines = stdin.lock().lines();\r\n\r\n    let t: usize = lines.next().unwrap().unwrap().parse().unwrap();\r\n    for _ in 0..t {\r\n        let dimensions = lines.next().unwrap().unwrap();\r\n        let (n, m) = dimensions.split_once(' ').unwrap();\r\n        let (n, m): (usize, usize) = (n.parse().unwrap(), m.parse().unwrap());\r\n\r\n        let mut grid: Vec<Vec<bool>> = lines\r\n            .by_ref()\r\n            .take(n)\r\n            .map(Result::unwrap)\r\n            .map(|line| line.chars().take(m).map(|ch| ch == '1').collect())\r\n            .collect();\r\n\r\n        let mut squares = 0;\r\n        for y in 0..n {\r\n            for x in 0..m {\r\n                if grid[y][x] {\r\n                    let sq1 = square1(&grid, x, y, n, m);\r\n                    let sq2 = square2(&grid, x, y, n, m);\r\n                    let p = perimeter(&mut grid, x, y, n, m);\r\n\r\n                    if p == 4 * sq1.saturating_sub(1) || p == 4 * sq2.saturating_sub(1) {\r\n                        squares += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        println!(\"{squares}\");\r\n    }\r\n}\r\n\r\n// Must be called only in left-upper corner of square\r\nfn square1(grid: &[Vec<bool>], mut x: usize, mut y: usize, n: usize, m: usize) -> usize {\r\n    let (mut up, mut right, mut down, mut left) = (1, 1, 1, 1);\r\n\r\n    // Up\r\n    while x < m - 1 && grid[y][x + 1] {\r\n        x += 1;\r\n        up += 1;\r\n    }\r\n\r\n    // Right\r\n    while y < n - 1 && grid[y + 1][x] {\r\n        y += 1;\r\n        right += 1;\r\n    }\r\n\r\n    // Down\r\n    while x > 0 && grid[y][x - 1] {\r\n        x -= 1;\r\n        down += 1;\r\n    }\r\n\r\n    // Left\r\n    while y > 0 && grid[y - 1][x] {\r\n        y -= 1;\r\n        left += 1;\r\n    }\r\n\r\n    if up == right && right == down && down == left {\r\n        up\r\n    } else {\r\n        0\r\n    }\r\n}\r\n\r\n// Must be called in upper vertex\r\nfn square2(grid: &[Vec<bool>], mut x: usize, mut y: usize, n: usize, m: usize) -> usize {\r\n    let (mut up, mut right, mut down, mut left) = (1, 1, 1, 1);\r\n\r\n    // Up (up-right)\r\n    while x < m - 1 && y < n - 1 && grid[y + 1][x + 1] {\r\n        x += 1;\r\n        y += 1;\r\n        up += 1;\r\n    }\r\n\r\n    // Right (down-right)\r\n    while x > 0 && y < n - 1 && grid[y + 1][x - 1] {\r\n        x -= 1;\r\n        y += 1;\r\n        right += 1;\r\n    }\r\n\r\n    // Down (down-left)\r\n    while x > 0 && y > 0 && grid[y - 1][x - 1] {\r\n        x -= 1;\r\n        y -= 1;\r\n        down += 1;\r\n    }\r\n\r\n    // Left (up-left)\r\n    while x < m - 1 && y > 0 && grid[y - 1][x + 1] {\r\n        x += 1;\r\n        y -= 1;\r\n        left += 1;\r\n    }\r\n\r\n    if up == right && right == down && down == left {\r\n        up\r\n    } else {\r\n        0\r\n    }\r\n}\r\n\r\nfn perimeter(grid: &mut [Vec<bool>], x: usize, y: usize, n: usize, m: usize) -> usize {\r\n    const DIRECTIONS: [(isize, isize); 8] = [\r\n        (-1, -1),\r\n        (-1, 0),\r\n        (-1, 1),\r\n        (0, -1),\r\n        (0, 1),\r\n        (1, -1),\r\n        (1, 0),\r\n        (1, 1),\r\n    ];\r\n\r\n    grid[y][x] = false;\r\n    let mut cells = 1;\r\n    for (dx, dy) in DIRECTIONS {\r\n        if dx == -1 && x == 0 || dy == -1 && y == 0 {\r\n            continue;\r\n        }\r\n\r\n        let (nx, ny) = ((x as isize + dx) as usize, (y as isize + dy) as usize);\r\n        if ny < n && nx < m && grid[ny][nx] {\r\n            cells += perimeter(grid, nx, ny, n, m);\r\n        }\r\n    }\r\n\r\n    cells\r\n}\r\n"
}