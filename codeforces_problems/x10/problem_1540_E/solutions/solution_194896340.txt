{
    "id": 194896340,
    "contestId": 1540,
    "creationTimeSeconds": 1677317406,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1540,
        "index": "E",
        "name": "Tasty Dishes",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3500,
        "tags": [
            "math",
            "matrices"
        ]
    },
    "author": {
        "contestId": 1540,
        "members": [
            {
                "handle": "BeyondHeaven"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1624635300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 4758,
    "memoryConsumedBytes": 2457600,
    "source": "#include <bits/stdc++.h>\r\nconstexpr int P = 1e9 + 7;\r\nstruct mint {\r\n  public:\r\n  \tmint(int x = 0): v(x % P) { v += ((v >> 31) & P); }\r\n  \tint val() const { return v; }\r\n  \t\r\n  \tmint &operator += (const mint &rhs) { v += rhs.v - P; v += ((v >> 31) & P); return *this; }\r\n  \tmint &operator -= (const mint &rhs) { v -= rhs.v; v += ((v >> 31) & P); return *this; }\r\n  \tmint &operator *= (const mint &rhs) { v = (unsigned long long)(v) * rhs.v % P; return *this; }\r\n  \tmint &operator /= (const mint &rhs) { return *this *= rhs.inv(); }\r\n  \t\r\n\tmint operator - () const { return mint(-v); }\r\n\r\n  \tbool operator == (const mint &rhs) const { return v == rhs.v; }\r\n    bool operator != (const mint &rhs) const { return v != rhs.v; } \r\n  \t\r\n  \tfriend mint operator + (mint lhs, const mint &rhs) { return lhs += rhs; }\r\n  \tfriend mint operator - (mint lhs, const mint &rhs) { return lhs -= rhs; }\r\n  \tfriend mint operator * (mint lhs, const mint &rhs) { return lhs *= rhs; }\r\n  \tfriend mint operator / (mint lhs, const mint &rhs) { return lhs /= rhs; }\r\n\r\n  \tfriend std::istream &operator >> (std::istream &is, mint &m) { return is >> m.v; }\r\n\tfriend std::ostream &operator << (std::ostream &os, const mint &m) { return os << m.v; }\r\n  \t\r\n  \tmint inv() const;\r\n  \t\r\n  \tmint pow(int n) const {\r\n  \t\tmint x = *this, r = 1;\r\n  \t\tfor (; n; n >>= 1, x *= x) {\r\n  \t\t\tif (n & 1) {\r\n  \t\t\t\tr *= x;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n  private:\r\n  \tint v;\r\n};\r\n\r\nstruct _simple {\r\n  public:\r\n\tfriend struct mint;\r\n\t_simple() { init(1); }\r\n\t\r\n\tmint fac(int n) const { return _fac[n]; }\r\n\tmint ifac(int n) const { return _ifac[n]; }\r\n\tmint inv(int n)\tconst { return _inv[n]; }\r\n\tmint binom(int n, int m) const {\r\n\t\tif (m < 0 || m > n) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn _fac[n] * _ifac[m] * _ifac[n - m];\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid init(int n) {\r\n\t\t_n = n;\r\n\t\t_fac.resize(n + 1), _ifac.resize(n + 1), _inv.resize(n + 1);\r\n\t\t\r\n\t\t_fac[0] = 1;\r\n\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\t_fac[i] = _fac[i - 1] * i;\r\n\t\t}\r\n\t\t\r\n\t\t_ifac[n] = _fac[n].pow(P - 2);\r\n\t\tfor (int i = n; i >= 1; i--) {\r\n\t\t\t_ifac[i - 1] = _ifac[i] * i;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\t_inv[i] = _ifac[i] * _fac[i - 1];\r\n\t\t}\r\n\t}\r\n  private:\r\n  \tint _n;\r\n  \tstd::vector<mint> _fac, _ifac, _inv;\r\n} simple;\r\n\r\nmint mint::inv() const {\r\n\tif (v <= simple._n) {\r\n\t\treturn simple.inv(v);\r\n\t} else {\r\n\t\treturn pow(P - 2);\r\n\t}\r\n}\r\n\r\nconstexpr int maxn = 300 + 5;\r\nconstexpr int inf = 1e9;\r\n\r\nint n, q, a[maxn], sz[maxn], d[maxn];\r\nstd::vector<int> G[maxn];\r\nmint mat[maxn][maxn], v[maxn][maxn], nv[maxn][maxn], c[maxn][maxn], coef[maxn][maxn], ps[maxn][maxn];\r\n\r\nvoid add(mint c[], int x, mint v) {\r\n\tfor (x++; x <= n + 1; x += (x & -x)) {\r\n\t\tc[x] += v;\r\n\t}\r\n}\r\n\r\nmint qsum(mint c[], int x) {\r\n\tmint res = 0;\r\n\tfor (x++; x; x -= (x & -x)) {\r\n\t\tres += c[x];\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nint main() {\r\n\tstd::ios::sync_with_stdio(false);\r\n\tstd::cin.tie(nullptr);\r\n\t\r\n\tstd::cin >> n;\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tstd::cin >> a[i];\r\n\t}\r\n\r\n\tfor (int i = 1, c; i <= n; i++) {\r\n\t\tstd::cin >> c;\r\n\t\tG[i].resize(c);\r\n\t\tfor (int &j : G[i]) {\r\n\t\t\tstd::cin >> j;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tmat[i][i] = i;\r\n\t\tfor (int j : G[i]) {\r\n\t\t\tmat[i][j] = j;\r\n\t\t}\r\n\t}\r\n\r\n\tauto rebuild = [&]() {\r\n\t\tstd::fill(d + 1, d + n + 1, inf);\r\n\t\tfor (int i = n; i; i--) {\r\n\t\t\tif (a[i] > 0) {\r\n\t\t\t\td[i] = 0;\r\n\t\t\t} else {\r\n\t\t\t\tfor (int j : G[i]) {\r\n\t\t\t\t\td[i] = std::min(d[i], d[j] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmemset(ps, 0, sizeof(ps));\r\n\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\t\tif (d[i] == inf) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tadd(ps[j], d[i], c[j][i] * a[i] * mint(j).pow(d[i]).inv());\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tfor (int t = 1; t <= n; t++) {\r\n\t\tfor (int i = n; i; i--) {\r\n\t\t\tmint cur = 0;\r\n\t\t\tfor (int j = i + 1; j <= n; j++) {\r\n\t\t\t\tcur -= mat[i][j] * v[j][t];\r\n\t\t\t}\r\n\t\t\tv[i][t] = (i == t ? 1 : cur / (mat[i][i] - t));\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tc[i][i] = 1;\r\n\t}\r\n\r\n\tmemcpy(nv, v, sizeof(nv));\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tif (!v[i][i].val()) {\r\n\t\t\tfor (int j = i + 1; j <= n; j++) {\r\n\t\t\t\tif (v[j][i].val()) {\r\n\t\t\t\t\tstd::swap(v[i], v[j]);\r\n\t\t\t\t\tstd::swap(c[i], c[j]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmint t = v[i][i].inv();\r\n\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\tv[i][j] *= t;\r\n\t\t\tc[i][j] *= t;\r\n\t\t}\r\n\r\n\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\tif (j != i) {\r\n\t\t\t\tmint t = v[j][i];\r\n\t\t\t\tfor (int k = 1; k <= n; k++) {\r\n\t\t\t\t\tv[j][k] -= v[i][k] * t;\r\n\t\t\t\t\tc[j][k] -= c[i][k] * t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmemcpy(v, nv, sizeof(v));\r\n\r\n\tfor (int x = 1; x <= n; x++) {\r\n\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\tcoef[x][j] = coef[x - 1][j] + v[x][j];\r\n\t\t}\r\n\t}\r\n\r\n\trebuild();\r\n\tstd::cin >> q;\r\n\twhile (q--) {\r\n\t\tint opt;\r\n\t\tstd::cin >> opt;\r\n\t\tif (opt == 1) {\r\n\t\t\tint k, l, r;\r\n\t\t\tstd::cin >> k >> l >> r;\r\n\r\n\t\t\tmint ans = 0;\r\n\t\t\tfor (int i = l; i <= r; i++) {\r\n\t\t\t\tif (d[i] > k) {\r\n\t\t\t\t\tans += a[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\t\tans += (coef[r][j] - coef[l - 1][j]) * mint(j).pow(k) * qsum(ps[j], std::min(n, k));\r\n\t\t\t}\r\n\r\n\t\t\tstd::cout << ans << \"\\n\";\r\n\t\t} else {\r\n\t\t\tint v, x;\r\n\t\t\tstd::cin >> v >> x;\r\n\t\t\ta[v] += x;\r\n\t\t\tif (a[v] > 0 && a[v] - x <= 0) {\r\n\t\t\t\trebuild();\r\n\t\t\t} else {\r\n\t\t\t\tfor (int j = 1, i = v; j <= n; j++) {\r\n\t\t\t\t\tif (d[i] == inf) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tadd(ps[j], d[i], c[j][i] * x * mint(j).pow(d[i]).inv());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
}