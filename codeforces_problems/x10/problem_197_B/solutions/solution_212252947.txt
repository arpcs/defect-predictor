{
    "id": 212252947,
    "contestId": 197,
    "creationTimeSeconds": 1688574209,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 197,
        "index": "B",
        "name": "Limit",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1400,
        "tags": [
            "math"
        ]
    },
    "author": {
        "contestId": 197,
        "members": [
            {
                "handle": "Sankalp_Ashish"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1339506000
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 80,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 1024000,
    "source": "#include <iostream>\r\n#include <cstdio>\r\n#include <bits/stdc++.h>\r\n#include <algorithm>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n// *setname.find_by_order(index);// tells the number at the given index\r\n// setname.order_of_key(element);// tells the number less than the given element\r\n// *setname.lower_bound(element);// first element >= given element in the set\r\n// *setname.upper_bound(element);// first element > given element in the set\r\n#define o_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\r\n#include <cmath>\r\n#include <chrono>\r\nusing namespace std;\r\n#define flash auto start = chrono::high_resolution_clock::now()\r\n#define lightning                                                                        \\\r\n    auto end = chrono::high_resolution_clock::now();                                     \\\r\n    double time_taken = chrono::duration_cast<chrono::nanoseconds>(end - start).count(); \\\r\n    time_taken *= 1e-6;                                                                  \\\r\n    cerr << fixed << time_taken << setprecision(6) << \" sec\" << endl\r\n#define dfast                    \\\r\n    ios::sync_with_stdio(false); \\\r\n    cin.tie(0);                  \\\r\n    cout.tie(0)\r\n#define FL                            \\\r\n    freopen(\"input.txt\", \"r\", stdin); \\\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#define in(a) cin >> a\r\n#define in2(a, b) cin >> a >> b\r\n#define in3(a, b, c) cin >> a >> b >> c\r\n#define in4(a, b, c, d) cin >> a >> b >> c >> d\r\n#define in5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\r\n#define out(a) cout << a << endl;\r\n\r\n#define fe(i, x, y) for (long long int i = x; i <= y; i++)\r\n#define f(i, x, y) for (long long int i = x; i < y; i++)\r\n#define fr(i, l, h, s) for (long long i = l; i < h; i += s)\r\n#define frr(i, h, l, s) for (long long i = h; i > l; i -= s)\r\n#define fre(i, l, h, s) for (long long i = l; i <= h; i += s)\r\n#define frre(i, h, l, s) for (long long i = h; i >= l; i -= s)\r\n#define ray(arr)        \\\r\n    for (auto &x : arr) \\\r\n    cin >> x\r\n#define oute cout << \"\\n\";\r\n#define set_bits __builtin_popcountll\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n\r\n/******************************For Vectors***********************************/\r\n#define vi vector<int>\r\n#define vll vector<ll>\r\n#define pb push_back\r\n#define pp pop_back\r\n#define ff first\r\n#define ss second\r\n#define all(x) x.begin(), x.end()\r\nvoid zmdd(vector<ll> v)\r\n{\r\n    f(i, 0, v.size()) { cout << v[i] << \" \"; }\r\n    cout << endl;\r\n}\r\n\r\n/***************************************************************************/\r\nconst int mod = 1e9 + 7;\r\nconst int _M = 1e5;\r\n#define PI 3.14159265358979323846264338327\r\n#define E 2.7182818284590452353602874713527\r\n\r\null mpow_mod(ll base, ll exp)\r\n{\r\n    base %= mod;\r\n    ull result = 1;\r\n    while (exp > 0)\r\n    {\r\n        if (exp & 1)\r\n            result = ((ll)result * base) % mod;\r\n        base = ((ll)base * base) % mod;\r\n        exp >>= 1;\r\n    }\r\n    return result;\r\n}\r\null mpow_normal(ll base, ll exp)\r\n{ /*base%=mod;*/\r\n    ull result = 1;\r\n    while (exp > 0)\r\n    {\r\n        if (exp & 1)\r\n            result = ((ll)result * base) /*% mod*/;\r\n        base = ((ll)base * base) /* % mod*/;\r\n        exp >>= 1;\r\n    }\r\n    return result;\r\n}\r\n/*gcd finder:*/ ll gcd(ll a, ll b)\r\n{\r\n    if (b == 0)\r\n        return a;\r\n    return gcd(b, a % b);\r\n}\r\n/*lcm finder*/ ll lcm(ll a, ll b)\r\n{\r\n    ll c = gcd(a, b);\r\n    return (a * b) / c;\r\n}\r\n/*msb*/ ll msb(ll n)\r\n{\r\n    ll res = 0;\r\n    while (n / 2 != 0)\r\n    {\r\n        n /= 2;\r\n        res++;\r\n    }\r\n    return res;\r\n}\r\n/*count_divisors*/ ll countDivisors(ll n)\r\n{\r\n    ll cnt = 0;\r\n    for (ll i = 1; i <= sqrt(n); i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            if (n / i == i)\r\n                cnt++;\r\n            else\r\n                cnt = cnt + 2;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\n/*Check whether the string is in palindrome  or grid[i+1][j]=='X) not*/ bool ispalindrome(string str, ll n)\r\n{ // Start from leftmost and rightmost corners of str\r\n    ll l = 0;\r\n    ll h = n - 1;\r\n    // Keep comparing characters while they are same\r\n    while (h > l)\r\n    {\r\n        if (str[l++] != str[h--])\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/*vector having prime factors*/ vector<ll> primes(ll n)\r\n{\r\n    ll *arr = new ll[n + 1]();\r\n    vector<ll> vect;\r\n    for (ll i = 2; i <= n; i++)\r\n        if (arr[i] == 0)\r\n        {\r\n            vect.push_back(i);\r\n            for (ll j = (ll(i) * ll(i)); j <= n; j += i)\r\n                arr[j] = 1;\r\n        }\r\n    return vect;\r\n}\r\n/*vector having all factors*/ vector<ll> divisor(ll n)\r\n{\r\n    vector<ll> res;\r\n    for (ll i = 1; i <= sqrt(n); i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            if (n / i == i)\r\n                res.pb(i);\r\n            else\r\n            {\r\n                res.pb(i);\r\n                res.pb(n / i);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\nchar let[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\r\n// 0,4,8,14,20(positions of vowels)\r\nchar vowel[] = {'a', 'e', 'i', 'o', 'u'};\r\n/*sum of digits*/ ll summation(ll num)\r\n{\r\n    ll sumb = 0;\r\n    while (num > 0)\r\n    {\r\n        ll rem = num % 10;\r\n        num /= 10;\r\n        sumb += rem;\r\n    }\r\n    return sumb;\r\n}\r\n/*column wise sorting in 2-D vector sort(v.begin(),v.end(),mycomp)*/\r\nbool mycomp(vector<ll> A, vector<ll> B)\r\n{\r\n    // if first element of first\r\n    // row<first element of second row\r\n    if (A[0] < B[0])\r\n        return true; // no swap\r\n    // other wise swap the rows\r\n    return false;\r\n}\r\n\r\nbool sortbysec(const pair<ll, ll> &a,\r\n               const pair<ll, ll> &b)\r\n{\r\n    return (a.second < b.second);\r\n}\r\n\r\nbool isPrime(ll num)\r\n{\r\n    if (num <= 1)\r\n        return 0;\r\n    f(i, 2, num) if (num % i == 0) return false;\r\n\r\n    return true;\r\n}\r\nll fact(ll n);\r\n\r\nll nCr(ll n, ll r)\r\n{\r\n    return fact(n) / (fact(r) * fact(n - r));\r\n}\r\n\r\n// Returns factorial of n\r\nll fact(ll n)\r\n{\r\n    if (n == 0)\r\n        return 1;\r\n    int res = 1;\r\n    for (int i = 2; i <= n; i++)\r\n        res = res * i;\r\n\r\n    return res;\r\n}\r\n\r\nll log_a_to_base_b(ll a, ll b)\r\n{\r\n    return (a > b - 1)\r\n               ? 1 + log_a_to_base_b(a / b, b)\r\n               : 0;\r\n}\r\n/*MODULAR ARITHMETIC*/\r\n\r\nll mod_add(ll a, ll b, ll m)\r\n{\r\n    return ((a % m) + (b % m)) % m;\r\n}\r\nll mod_mul(ll a, ll b, ll m)\r\n{\r\n    return ((a % m) * (b % m)) % m;\r\n}\r\nll mod_sub(ll a, ll b, ll m)\r\n{\r\n    return (((a % m) - (b % m)) % m + m) % m;\r\n}\r\nll power(ll a, ll b, ll m)\r\n{\r\n    ll ans = 1;\r\n    while (b)\r\n    {\r\n        if (b & 1)\r\n            ans = (ans * 1LL * a) % m;\r\n        a = (a * 1LL * a) % m;\r\n        b >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nll modulo_inverse_prime(ll a, ll m)\r\n{\r\n    return power(a, m - 2, m);\r\n}\r\nll mod_div(ll a, ll b, ll m)\r\n{\r\n    ll B_inverse = 0;\r\n    B_inverse = modulo_inverse_prime(b, m);\r\n    return ((a % m) * (B_inverse % m)) % m;\r\n}\r\n\r\n/*MODULO ARITHMETIC OVER*/\r\n\r\n/* Returns length of LCS for X[0..m-1], Y[0..n-1] */\r\n/*LCS*/\r\n// vector<vector<int>>dp(n+1,vector<int>(n+1,0)); // define it in main function\r\n// LCS(X, Y, n, n, dp);\r\nll LCS(string X, string Y, ll m, ll n,\r\n       vector<vector<int>> &dp)\r\n{\r\n\r\n    fe(j, 1, n)\r\n    {\r\n        fe(i, 1, n)\r\n        {\r\n            if (X[j - 1] == Y[i - 1])\r\n                dp[j][i] = 1 + dp[j - 1][i - 1];\r\n            else\r\n                dp[j][i] = max(dp[j - 1][i], dp[j][i - 1]);\r\n        }\r\n    }\r\n    return dp[n][n];\r\n}\r\n/*Modify Bits (number,position, 0  or grid[i+1][j]=='X) 1 )*/\r\n/*set bits by taking  or grid[i+1][j]=='X)*/\r\n/*set bits by taking xor*/\r\nll modifyBit(ll n, ll p, ll b)\r\n{\r\n    ll mask = 1LL << p;\r\n    return ((n & ~mask) | (b << p));\r\n}\r\nll mod_fact(ll n)\r\n{\r\n    if (n == 0)\r\n        return 1;\r\n    ll res = 1;\r\n    for (int i = 2; i <= n; i++)\r\n        res = mod_mul(res, i, 1000000007);\r\n\r\n    return res;\r\n}\r\n\r\n/* array to store all prime numbers between the given range*/\r\nconst int ppp = 1e6 + 5;\r\nbool arr[ppp];\r\nvoid SieveOfEratosthenes(ll srt, ll n)\r\n{\r\n\r\n    bool prime[n + 2 - srt];\r\n    memset(prime, true, sizeof(prime));\r\n    prime[0] = false;\r\n    prime[1] = false;\r\n\r\n    for (ll p = srt; p * p <= n; p++)\r\n    {\r\n\r\n        if (prime[p] == true)\r\n        {\r\n\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n    for (int p = srt; p <= n; p++)\r\n        if (prime[p])\r\n            arr[p] = true;\r\n        else\r\n            arr[p] = false;\r\n}\r\n/*finds the given number is a perfect square of which number*/\r\nll bin(ll low, ll high, ll num)\r\n{\r\n    ll ans = -1;\r\n    while (low < high - 1)\r\n    {\r\n        ll mid = (high + low) / 2;\r\n        if (mid * mid > num)\r\n        {\r\n            high = mid - 1;\r\n        }\r\n        else if (mid * mid < num)\r\n        {\r\n            low = mid + 1;\r\n        }\r\n        else if (mid * mid == num)\r\n        {\r\n            ans = mid;\r\n            break;\r\n        }\r\n        if (low * low == num)\r\n        {\r\n            ans = low;\r\n            break;\r\n        }\r\n        else if (high * high == num)\r\n        {\r\n            ans = high;\r\n            break;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\nclass DisjointSet\r\n{\r\n    vector<ll> rank, parent, size;\r\n\r\npublic:\r\n    DisjointSet(ll n)\r\n    {\r\n        rank.resize(n + 1, 0);\r\n        parent.resize(n + 1);\r\n        size.resize(n + 1);\r\n        for (ll i = 0; i <= n; i++)\r\n        {\r\n            parent[i] = i;\r\n            size[i] = 1;\r\n        }\r\n    }\r\n\r\n    ll findUPar(ll node)\r\n    {\r\n        if (node == parent[node])\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionByRank(ll u, ll v)\r\n    {\r\n        ll ulp_u = findUPar(u);\r\n        ll ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v)\r\n            return;\r\n        if (rank[ulp_u] < rank[ulp_v])\r\n        {\r\n            parent[ulp_u] = ulp_v;\r\n        }\r\n        else if (rank[ulp_v] < rank[ulp_u])\r\n        {\r\n            parent[ulp_v] = ulp_u;\r\n        }\r\n        else\r\n        {\r\n            parent[ulp_v] = ulp_u;\r\n            rank[ulp_u]++;\r\n        }\r\n    }\r\n\r\n    void unionBySize(ll u, ll v)\r\n    {\r\n        ll ulp_u = findUPar(u);\r\n        ll ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v)\r\n            return;\r\n        if (size[ulp_u] < size[ulp_v])\r\n        {\r\n            parent[ulp_u] = ulp_v;\r\n            size[ulp_v] += size[ulp_u];\r\n        }\r\n        else\r\n        {\r\n            parent[ulp_v] = ulp_u;\r\n            size[ulp_u] += size[ulp_v];\r\n        }\r\n    }\r\n};\r\n\r\nvoid bfs(ll i, ll j, vector<vector<ll>> &vis, char mn[1005][1005], vector<vector<char>> &ans, ll &cnt, ll n, ll m)\r\n{\r\n    // ll n = grid.size();\r\n    // ll m = grid[0].size();\r\n    vis[i][j] = 1;\r\n    ++cnt;\r\n    queue<pair<ll, ll>> q;\r\n    q.push({i, j});\r\n    while (!q.empty())\r\n    {\r\n        ll i = q.front().first;\r\n        ll j = q.front().second;\r\n        q.pop();\r\n\r\n        ll delrow[] = {-1, 0, 1, 0};\r\n        ll delcol[] = {0, 1, 0, -1};\r\n        f(k, 0, 4)\r\n        {\r\n            ll a = i + delrow[k];\r\n            ll b = j + delcol[k];\r\n            if (a >= 0 and b >= 0 and a < n and b < m and !(vis[a][b]) and mn[a][b] == '.')\r\n            {\r\n                vis[a][b] = 1;\r\n                ++cnt;\r\n                q.push({a, b});\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid dfs(ll start, set<ll> adj[], vector<ll> &vis)\r\n{\r\n    vis[start] = 1;\r\n    for (auto it : adj[start])\r\n    {\r\n        if (!vis[it])\r\n        {\r\n            dfs(it, adj, vis);\r\n        }\r\n    }\r\n}\r\n\r\nsigned main()\r\n{\r\n    dfast;\r\n    // ll tt;\r\n    // in(tt);\r\n\r\n    // while (tt--)\r\n    // {\r\n\r\n    ll n, m;\r\n    in2(n, m);\r\n    vll v1(n + 1);\r\n    vll v2(m + 1);\r\n    ray(v1);\r\n    ray(v2);\r\n    if (n > m)\r\n    {\r\n        if (v1[0] > 0 and v2[0]>0 or v1[0]<0 and v2[0]<0)\r\n        {\r\n            out(\"Infinity\");\r\n        }\r\n        else\r\n        {\r\n            out(\"-Infinity\");\r\n        }\r\n    }\r\n    else if (n < m)\r\n    {\r\n        out(\"0/1\");\r\n    }\r\n    else\r\n    {\r\n        ll GCD=__gcd(v2[0], v1[0]);\r\n        \r\n            v2[0]/= GCD;\r\n            v1[0] /=GCD;\r\n        \r\n        if (v2[0] < 0 and v1[0] > 0 or v2[0]<0 and v1[0]<0)\r\n        {\r\n            cout << -v1[0] << \"/\" << -v2[0] << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << v1[0] << \"/\" << v2[0] << endl;\r\n        }\r\n    }\r\n\r\n    //}\r\n\r\n    return 0;\r\n    // lightning;\r\n}"
}