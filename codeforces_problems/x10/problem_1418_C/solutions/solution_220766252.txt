{
    "id": 220766252,
    "contestId": 1418,
    "creationTimeSeconds": 1693166531,
    "relativeTimeSeconds": 2951,
    "problem": {
        "contestId": 1418,
        "index": "C",
        "name": "Mortal Kombat Tower",
        "type": "PROGRAMMING",
        "rating": 1500,
        "tags": [
            "dp",
            "graphs",
            "greedy",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1418,
        "members": [
            {
                "handle": "llc5pg"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1693163580
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 204800,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n//#include <atcoder/modint>\r\n//using namespace atcoder;\r\n//using mint = modint998244353;\r\n# define M_PI           3.14159265358979323846  /* pi */\r\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\r\n \r\n//#pragma GCC target (\"avx2\")\r\n#pragma GCC optimization (\"Ofast\")\r\n \r\nconst int MOD = (1e9+7);\r\ntemplate < typename T = int > ostream& operator << (ostream &out, const vector < T > &v){ \r\n    for (const T &x: v) out << x << ' '; \r\n    return out;\r\n}\r\ntemplate<class T>\r\nvoid printmat(const vector<vector<T>>& mat) {\r\n    for (auto row : mat) {\r\n        for (auto elem : row)\r\n            cout << elem << \" \";\r\n        cout << \"\\n\";\r\n    }\r\n}\r\nvoid printdq(const deque<int>& v) {\r\n    for (auto elem : v)\r\n        cout << elem << \" \";\r\n    cout << endl;\r\n}\r\ntemplate<class T>\r\nvoid printv(const vector<T>& v) {\r\n    for (auto elem : v)\r\n        cout << elem << \" \";\r\n    cout << \"\\n\";\r\n}\r\ntemplate<class T>\r\nvoid printdq(const deque<T>& v) {\r\n    for (auto elem : v)\r\n        cout << elem << \" \";\r\n    cout << endl;\r\n}\r\ntemplate<class T1, class T2>\r\nvoid printvp(const vector<pair<T1,T2>>& vp) {\r\n    for (auto pr : vp) {\r\n        cout << pr.first << \" \" << pr.second;\r\n        cout << \"\\n\";\r\n    }\r\n}\r\nvoid printvs(const vector<set<int>>& vs) {\r\n    for (auto row : vs) {\r\n        for (auto elem : row)\r\n            cout << elem << \", \";\r\n        cout << endl;\r\n    }\r\n}\r\ntemplate<class T>\r\nvoid printht(const unordered_map<T, T>& ht) {\r\n    for (auto elem : ht)\r\n        cout << elem.first << \" : \" << elem.second << endl;\r\n}\r\ntemplate<class T1, class T2>\r\nvoid printmp(const map<T1, T2>& ht) {\r\n    for (auto elem : ht)\r\n        cout << elem.first << \" : \" << elem.second << endl;\r\n}\r\ntemplate<class T>\r\nvoid printst(const set<T>& st) {\r\n    for (auto elem : st)\r\n        cout << elem << \" \";\r\n    cout << endl;\r\n}\r\ntemplate<class T>\r\nvoid printms(const multiset<T>& st) {\r\n    for (auto elem : st)\r\n        cout << elem << \" \";\r\n    cout << endl;\r\n}\r\n \r\nbool isPrime(long long n) {\r\n    if (n <= 1)\r\n        return false;\r\n    if (n <= 3)\r\n        return true;\r\n    if (n % 2 == 0 || n % 3 == 0)\r\n        return false;\r\n    for (long long i = 5; i * i <= n; i = i + 6)\r\n        if (n % i == 0 || n % (i + 2) == 0)\r\n            return false;\r\n    return true;\r\n}\r\n \r\nmap<long long, long long> primeFactors(long long n) {\r\n    map<long long, long long> ans;\r\n    while (n % 2 == 0) {\r\n        ans[2]++;\r\n        n = n/2;\r\n    }\r\n    for (long long i = 3; i*i <= (n); i = i + 2) {\r\n        while (n % i == 0) {\r\n            ans[i]++;\r\n            n = n/i;\r\n        }\r\n    }\r\n    if (n > 2)\r\n        ans[n]++;\r\n    return ans;\r\n}\r\n \r\n/*\r\n    vector<int> uf(n), sz(n,1);\r\n    for (int i=0; i<n; i++) \r\n        uf[i] = i;\r\n*/\r\nint find_f(const vector<int>& uf, int i) {\r\n    while (uf[i]!=i)\r\n        i = uf[i];\r\n    return i;\r\n}\r\nbool union_f(vector<int>& uf, vector<int>& sz, int a, int b) {\r\n    a = find_f(uf, a);\r\n    b = find_f(uf, b);\r\n    //cout << \"a, b = \" << a << \", \" << b << endl;\r\n    if (a==b) return false;\r\n    if (sz[a] < sz[b]) {\r\n        //cout << \"sz[a], sz[b] = \" << sz[a] << \", \" << sz[b] << endl;\r\n        //cout << \"a, b = \" << a << \", \" << b << endl;\r\n        swap(a,b);\r\n        //cout << \"a, b = \" << a << \", \" << b << endl;\r\n    }\r\n    sz[a] += sz[b];\r\n    uf[b] = a;\r\n    return true;\r\n}\r\n \r\nlong long modexp(long long b, long long e, long long M) {\r\n    if (!e) return 1;\r\n    b %= M;\r\n    long long x = modexp(b * b % M, e / 2, M);\r\n    if (e % 2) {\r\n        return b * x % M;\r\n    } else {\r\n        return x;\r\n    }\r\n}\r\n\r\n\r\nll gcdExtended(ll a, ll b, ll* x, ll* y) {\r\n    if (a == 0) {\r\n        *x = 0, *y = 1;\r\n        return b;\r\n    }\r\n    ll x1, y1;\r\n    ll gcd = gcdExtended(b % a, a, &x1, &y1);\r\n    *x = y1 - (b / a) * x1;\r\n    *y = x1;\r\n    return gcd;\r\n}\r\n\r\nll modInverse(ll a, ll m) {\r\n    ll x, y, res=-1;\r\n    ll g = gcdExtended(a, m, &x, &y);\r\n    if (g != 1) {\r\n        //cout << \"Inverse doesn't exist\";\r\n        res = -1;\r\n    } else {\r\n        // m is added to handle negative x\r\n        res = (x % m + m) % m;\r\n    }\r\n    return res;\r\n}\r\n\r\nint lenOfLIS(vector<int>& v) {        \r\n    int n = v.size(), len = 0;\r\n    vector<int> dp(n,0);\r\n    for (int num : v) {\r\n        int i = lower_bound(dp.begin(), dp.begin()+len, num) - dp.begin();\r\n        dp[i] = num;\r\n        if (i == len) {\r\n            len++;\r\n        }\r\n    }\r\n    return len;        \r\n}\r\n\r\n\r\n#if 0\r\nconst int N = 1e6+4;  // limit for array size\r\nint n;  // array size\r\nint t[2 * N];\r\n\r\nvoid build() {  // build the tree\r\n  for (int i = n - 1; i > 0; --i) t[i] = max(t[i<<1], t[i<<1|1]);\r\n}\r\n\r\nvoid modify(int p, int value) {  // set value at position p\r\n  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];\r\n}\r\n\r\nint query(int l, int r) {  // max on interval [l, r)\r\n  int res = 0;\r\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\r\n    if (l&1) res = max(res, t[l++]);\r\n    if (r&1) res = max(res, t[--r]);\r\n  }\r\n  return res;\r\n}\r\n#endif\r\n\r\nvector<int> SieveOfEratosthenes(int n) {\r\n    bool prime[n+1];\r\n    memset(prime, true, sizeof(prime));\r\n  \r\n    for (int p=2; p*p<=n; p++) {\r\n        if (prime[p]) {\r\n            for (int i=p*p; i<=n; i+=p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n    vector<int> v;\r\n    for (int p=2; p<=n; p++)\r\n        if (prime[p])\r\n            v.push_back(p);\r\n    return v;\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);    \r\n    int T=1, caseIdx=0;   \r\n    cin >> T;  \r\n    while (T--) {\r\n        //caseIdx++;\r\n        //const int M = 998244353;\r\n        int n, ans=0, turn=1, k=0;\r\n        cin >> n;\r\n        vector<int> v(n);\r\n        for (int i=0; i<n; i++) {\r\n            cin >> v[i];\r\n        }\r\n        //printv(v); \r\n        while (k<n) {\r\n            if (turn==1) {\r\n                if (v[k]==0) {\r\n                    k++;\r\n                } else {\r\n                    //watch(k);\r\n                    ans++;\r\n                    k++;    \r\n                }\r\n                if (k<n && v[k]==0) {\r\n                    k++;\r\n                }                \r\n            } else {\r\n                k++;\r\n                if (k<n && v[k]==1) {\r\n                    k++;\r\n                } \r\n            }\r\n            turn = 1 - turn;\r\n        }\r\n        \r\n        //cout << fixed << setprecision(9);\r\n        cout << ans << \"\\n\";\r\n        //cout << \"Case #\" << caseIdx << \": \" << ans << \"\\n\";   \r\n    }\r\n}\r\n"
}