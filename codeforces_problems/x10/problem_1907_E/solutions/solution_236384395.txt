{
    "id": 236384395,
    "contestId": 1907,
    "creationTimeSeconds": 1702050612,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1907,
        "index": "E",
        "name": "Good Triples",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "combinatorics",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1907,
        "members": [
            {
                "handle": "Likhith228"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1701787500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define ull unsigned long long\r\nconst int mod = 1e9+7;\r\nconst int modi = 1e8;\r\n\r\n// const int k = 1e7+10;\r\n// vector<bool>v(k,1);\r\n// v[1]=false;\r\n    // v[0]=false;\r\n    // for(int i=2;i<k;i++)\r\n    // {\r\n    // \tif(v[i]==true)\r\n    // \t{\r\n    // \t\tfor(int j=2*i;j<k;j+=i)\r\n\t//     \t{\r\n\t//     \t\tv[i]=false;\r\n\t//     \t}\r\n\t//     }\r\n    // }\r\n// ll exp(ll x, ll y){\r\n//     ll ans = 1;\r\n//     // x = x%md;\r\n//     while (y > 0) {\r\n//         if (y&1)\r\n//             ans = ans*x;\r\n//         y = y>>1;\r\n//         x = x*x;\r\n//     }\r\n//     return ans;\r\n// }\r\n// ll sum(ll n)\r\n// {\r\n// \tif(n<0)\r\n// \t\treturn -1;\r\n// \tll temp=0;\r\n// \twhile(n)\r\n// \t{\r\n// \t\tint k = n%10;\r\n// \t\ttemp += k;\r\n// \t\tn/=10;\r\n// \t}\r\n// \treturn temp;\r\n// }\r\n// ll l,r;\r\n// set<ll>s;\r\n\r\n// ll lucky_num(ll n)\r\n// {\r\n//     s.insert(n);\r\n//     if(n<r)\r\n//     {\r\n//         lucky_num(n*10+4);\r\n//         lucky_num(n*10+7);\r\n//     }\r\n// }\r\n// int f(int x, int y) {\r\n \r\n// //     // If both are equal then return 0\r\n// //     if (x == y)\r\n// //         return 0;\r\n \r\n// //     // Check if conversion is possible or not\r\n// //     if (x <= 0 && y > 0)\r\n// //         return -1;\r\n \r\n// //     // If x > y then we can just increase y by 1\r\n// //     // Therefore return the number of increments required\r\n// //     if (x > y)\r\n// //         return x - y;\r\n \r\n// //     // If last bit is odd\r\n// //     // then increment y so that we can make it even\r\n// //     if (y & 1)\r\n// //         return 1 + f(x, y + 1);\r\n \r\n// //     // If y is even then divide it by 2 to make it closer to\r\n// //     // x\r\n// //     else\r\n// //         return 1 + f(x, y / 2);\r\n// // }\r\n// // #define mx 100003\r\n\r\n// // vector<int>v[mx];\r\n// // int dp[mx];\r\n// // void sieve ()\r\n// // {\r\n// //     memset(prime, true, sizeof(prime));\r\n\r\n// //     for (int p=2; p<=mx; p++)\r\n// //     {\r\n// //         dp[p]=1;\r\n// //         // If prime[p] is not changed, then it is a prime\r\n// //         if (prime[p] == true)\r\n// //         {\r\n// //             v[p].push_back(p);\r\n// //             for (int i=2*p; i<=mx; i += p) {\r\n// //                 prime[i] = false;\r\n// //                 v[i].push_back(p);// take all number's prime_factors\r\n// //             }\r\n// //         }\r\n// //     }\r\n// // }\r\n// int n,m;\r\n// \tcin >> n >> m;\r\n// \tvector<vector<int>>v(n+1,vector<int>(m+1,0));\r\n// \tvector<vector<int>>t(n+1,vector<int>(m+1,0));\r\n// \tfor(int i=0;i<n;i++)\r\n// \t{\r\n// \t\tfor(int j=0;j<m;j++)\r\n// \t\t{\r\n// \t\t\tcin >> v[i][j];\r\n// \t\t\tif(f(v[i][j]))\r\n// \t\t\t\tt[i][j]=0;\r\n// \t\t\telse\r\n// \t\t\t{\r\n// \t\t\t\tint cnt=0;\r\n// \t\t\t\twhile(!f(v[i][j]))\r\n// \t\t\t\t{\r\n// \t\t\t\t\tv[i][j]+=1;\r\n// \t\t\t\t\tcnt++;\r\n// \t\t\t\t\tif(f(v[i][j]))\r\n// \t\t\t\t\t\tbreak;\r\n// \t\t\t\t}\r\n// \t\t\t\tt[i][j]=cnt;\r\n// \t\t\t}\r\n// \t\t}\r\n// \t}\r\n// \t// vector<ll>r;\r\n// \tll sum=0,mini=0;\r\n// \tfor(int i=0;i<n;i++)\r\n// \t{\r\n// \t\tfor(int j=0;j<m;j++)\r\n// \t\t{\r\n// \t\t\tsum += t[i][j];\r\n// \t\t}\r\n// \t\tmini=min(mini, sum);\r\n// \t}\r\n// \tfor(int i=0;i<n;i++)\r\n// \t{\r\n// \t\tfor(int j=0;j<m;j++)\r\n// \t\t{\r\n// \t\t\tsum += t[j][i];\r\n// \t\t}\r\n// \t\tmini=min(mini, sum);\r\n// \t}\r\n// \tcout << mini << endl;\r\n\r\n// }\r\n\r\n// bool f(int n)\r\n// {\r\n// \t if (n <= 1)\r\n//         return false;\r\n//     for (int i = 2; i <= n / 2; i++)\r\n//         if (n % i == 0)\r\n//             return false;\r\n \r\n//     return true;\r\n// }\r\n// int mex(vector<int> &arr, int N)\r\n// {\r\n \r\n//   // sort the array\r\n//   sort(arr.begin(), arr.end());\r\n \r\n//   int mex = 0;\r\n//   for (int idx = 0; idx < N; idx++)\r\n//   {\r\n//     if (arr[idx] == mex)\r\n//     {\r\n//       mex++;\r\n//     }\r\n//   }\r\n//   return mex;\r\n// }\r\n// int diff(string &s,string &t)\r\n// {\r\n// \tint n = s.size();\r\n// \tint cnt=0;\r\n// \tfor(int i=0;i<n;i++)\r\n// \t{\r\n// // \t\tcnt += abs((int)s[i]-(int)t[i]);\r\n// // \t}\r\n// // \treturn cnt;\r\n// // \r\n// // int check(int l,int r)\r\n// // {\r\n// // \tint x;\r\n// // \tcout << \"? \"<<l << \" \"<<r<<endl;\r\n// // \tcin >> x;\r\n// // \treturn x;\r\n// // }\r\n// // void bfs(int row,int col,vector<vector<int>>&vis)\r\n// // {\r\n\r\n// // }\r\n// // ll a[200005];\r\n// // const int mod = 1e9+7;\r\n// // double dp[3001][3001];\r\n// // double f(vector<double>&v,int ind,int heads)\r\n// // {\r\n// // \tif(heads==0)\r\n// // \t\treturn 1;\r\n// // \tif(ind==0)\r\n// // \t\treturn 0;\r\n\r\n// // \tif(dp[ind][heads]>-0.9)\r\n// // \t\treturn dp[ind][heads];\r\n\r\n// // \tdouble head = f(v,ind-1,heads-1)*v[ind];\r\n// // \tdouble tail = f(v,ind-1,heads)*(1-v[ind]);\r\n// // \treturn dp[ind][heads] = head +tail;\r\n\r\n// // }\r\n// // int dp[100010];\r\n// // int f(int ind,vector<int>&v)\r\n// // {\r\n// // \tif(ind==1)\r\n// // \t{\r\n// // \t\tif(v[ind]%ind==0)\r\n// // \t\t\treturn 1;\r\n// // \t\telse\r\n// // \t\t\treturn 0;\r\n// // \t}\r\n// // \tif(dp[ind]!=-1)\r\n// // \t\treturn dp[ind];\r\n// // \tint take=0,not_take=0;\r\n// // \tif(v[ind]%ind==0)\r\n// // \t\ttake = 1+f(ind-1,v);\r\n// // \telse\r\n// // \t\tnot_take = f(ind-1,v);\r\n// // \treturn dp[ind] = (take+not_take)%mod;\r\n\r\n// // }\r\n// // int dp[200200][200200]\r\n// // int f(int ind,int prev,vector<int>&v)\r\n// // {\r\n// // \tint n = v.size();\r\n// // \tif(ind == n)\r\n// // \t{\r\n// // \t\treturn 0;\r\n// // \t}\r\n// // \tint len=0;\r\n// // \tlen = 1+f(ind+1,prev);\r\n// // \tif(prev==-1||v[ind]>v[prev])\r\n// // \t\tlen = max(len,1+f(ind+1,ind));\r\n// // \treturn len;\r\n// // }\r\n// #define ull unsigned long long\r\n\r\n// ull a[5005], n, m, k, dp[5005][5005];\r\n\r\n// ull call(ull ind, ull cnt){\r\n\r\n//     if(dp[i][cnt]!=-1)\r\n//         return dp[ind][cnt];\r\n\r\n//     if(ind>(n-m) || cnt>=k)\r\n//         return 0;\r\n\r\n//     ull opt1=0, opt2=0;\r\n\r\n//     for(ull i=ind; i<ind+m; i++)\r\n//     {\r\n//         opt1+=a[i];\r\n//     }\r\n\r\n//     opt1= opt1+call(ind+m,cnt+1);\r\n// \topt2= call(ind+1,cnt);\r\n\r\n//     return dp[ind][cnt] = max(opt1,opt2);\r\n// }\r\n// int dp[1001][1001];\r\n// int f(int row,int col,vector<vector<char>>&v)\r\n// {\r\n// \tif(row>=0 && col>=0 && v[row][col]=='*')\r\n// \t\treturn 0;\r\n// \tif(row<0 || col <0)\r\n// \t\treturn 0;\r\n// \tif(row==0 and col==0)\r\n// \t\treturn 1;\r\n// \tif(dp[row][col]!=-1)\r\n// \t\treturn dp[row][col];\r\n// \tint up = f(row-1,col,v);\r\n// \tint left = f(row,col-1,v);\r\n// \treturn dp[row][col]=(up+left)%mod;\r\n// }\r\n\r\n// int binpow(int x,int y)\r\n// {\r\n// \tint ans=1;\r\n// \twhile(x>0)\r\n// \t{\r\n// \t\tif(y&1)\r\n// \t\t{\r\n// \t\t\tans *= x;\r\n// \t\t}\r\n// \t\ty>>=1;\r\n// \t\tx = x*x;\r\n// \t}\r\n// \treturn ans;\r\n// }\r\n// void f()\r\n// {\r\n// \tcout << 1 << endl;\r\n// \tf();\r\n// }\r\n// int f(int ind,string s,int k,int n)\r\n// {\r\n// \tif(ind==n)\r\n// \t{\r\n// \t\tif(k==0)\r\n// \t\t\treturn 1;\r\n// \t\treturn 0;\r\n// \t}\r\n\r\n// \tint not_take=0,take=0;\r\n// \tnot_take = f(ind+1,s,k,n);\r\n\r\n// \tif(k>0 and s[ind]=='1')\r\n// \t\ttake = f(ind+1,s,k-1,n);\r\n\r\n// \treturn take+not_take;\r\n\r\n// }\r\n// void dfs(int row,int col,vector<int>adj[],vector<vector<int>>&vis)\r\n// {\r\n// \tvis[row][col]=1;\r\n// }\r\nint f(int x)\r\n{\r\n    int ans = 0;\r\n    for (int i = 0; i <= x; i++)\r\n    {\r\n        for (int j = 0; j <= x - i; j++)\r\n        {\r\n            ans++;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\nint main()\r\n{\r\n\tios_base::sync_with_stdio(0), cin.tie(0);\r\n\t// freopen (\"input.txt\",\"r\",stdin);\r\n    // freopen (\"output.txt\",\"w\",stdout);\r\n\tint t;\r\n\tcin >> t;\r\n\twhile(t--)\r\n\t{\r\n\t\tll n; \r\n\t\tcin >> n;\r\n    \tint ans = 1;\r\n\t    while (n != 0)\r\n\t    {\r\n\t        int d = n % 10;\r\n\t        n /= 10;\r\n\t        ans *= f(d);\r\n\t    }\r\n\t    cout << ans << endl;\r\n   \t}\r\n}\r\n"
}