{
    "id": 211662065,
    "contestId": 713,
    "creationTimeSeconds": 1688163393,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 713,
        "index": "B",
        "name": "Searching Rectangles",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 2200,
        "tags": [
            "binary search",
            "constructive algorithms",
            "interactive"
        ]
    },
    "author": {
        "contestId": 713,
        "members": [
            {
                "handle": "NK_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1473784500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n/////////////////////// MACROS ////////////////////////////////////////////\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing db = double;\r\nusing str = string;\r\n\r\nusing pi = pair<int,int>;\r\nusing pl = pair<ll,ll>;\r\n\r\nusing vi = vector<int>;\r\nusing vl = vector<ll>;\r\nusing vs = vector<str>;\r\nusing vc = vector<char>;\r\nusing vpi = vector<pi>;\r\nusing vpl = vector<pl>;\r\n\r\n#define tcT template<class T\r\n#define tcTU tcT, class U\r\ntcT> using V = vector<T>;\r\ntcT, size_t SZ> using AR = array<T,SZ>;\r\ntcTU> using PR = pair<T,U>;\r\ntcTU> using umap = unordered_map<T, U>;\r\ntcT> using uset = unordered_set<T>;\r\ntcT> using mset = multiset<T>;\r\n\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n\r\n#define sz(x) int((x).size())\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define rsz resize\r\n#define ins insert\r\n#define ft front()\r\n#define bk back()\r\n#define ppb pop_back()\r\n#define ppf pop_front()\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define pf push_front\r\n\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n\r\n// LOOPS\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define rep(a) F0R(_, a)\r\n#define each(a,x) for (auto& a: x)\r\n\r\n/////////////////////// IMPORANT VARS /////////////////////////////////////\r\n\r\nconst int MOD = 1e9+7; // 998244353;\r\nconst int MX = 2e5+5;\r\nconst ll INFL = ll(3e18)+10;\r\nconst int INF = int(1e9)+10;\r\nconst ld PI = acos((ld)-1);\r\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\r\ntcT> using pqg = priority_queue<T,vector<T>,greater<T>>;\r\ntcT> using pql = priority_queue<T,vector<T>,less<T>>;\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n#define nl '\\n'\r\n\r\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\r\nconstexpr int bits(int x) { \r\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); }\r\nconstexpr int p2(int x) { return 1<<x; }\r\nconstexpr int msk2(int x) { return p2(x)-1; }\r\n \r\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\r\n \r\ntcT> bool ckmin(T& a, const T& b) {\r\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\r\ntcT> bool ckmax(T& a, const T& b) {\r\n\treturn a < b ? a = b, 1 : 0; }\r\n \r\ntcTU> T fstTrue(T lo, T hi, U f) {\r\n\thi ++; assert(lo <= hi); // assuming f is increasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo)/2;\r\n\t\tf(mid) ? hi = mid : lo = mid+1; \r\n\t} \r\n\treturn lo;\r\n}\r\ntcTU> T lstTrue(T lo, T hi, U f) {\r\n\tlo --; assert(lo <= hi); // assuming f is decreasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo+1)/2;\r\n\t\tf(mid) ? lo = mid : hi = mid-1;\r\n\t} \r\n\treturn lo;\r\n}\r\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\r\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\r\ntcTU> void erase(T& t, const U& u) { // don't erase\r\n\tauto it = t.find(u); assert(it != end(t));\r\n\tt.erase(it); } // element that doesn't exist from (multi)set\r\n\r\n\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// using namespace __gnu_pbds;\r\n\r\n// tcT> using iset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; \r\n// #define ook order_of_key\r\n// #define fbo find_by_order\r\n\r\n// struct chash { \r\n// \tconst uint64_t C = ll(2e18*PI)+71;\r\n// \tconst int RANDOM = rng();\r\n// \tll operator()(ll x) const {\r\n// \t\treturn __builtin_bswap64((x^RANDOM)*C); }\r\n// };\r\n// template<class K,class V> using um = unordered_map<K,V,chash>;\r\n// template<class K,class V> using ht = gp_hash_table<K,V,chash>;\r\n// template<class K,class V> V get(ht<K,V>& u, K x) {\r\n// \tauto it = u.find(x); return it == end(u) ? 0 : it->s; }\r\n\r\n/////////////////////// OUPUT /////////////////////////////////////////////\r\n#define ts to_string\r\nstr ts(char c) { return str(1,c); }\r\nstr ts(const char* s) { return (str)s; }\r\nstr ts(str s) { return s; }\r\nstr ts(bool b) {\r\n\t#ifdef LOCAL\r\n\t\treturn b ? \"true\" : \"false\";\r\n\t#else\r\n\t\treturn ts((int)b);\r\n\t#endif\r\n}\r\ntcTU> str ts(pair<T,U> p) {\r\n\t#ifdef LOCAL\r\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\";\r\n\t#else\r\n\t\treturn ts(p.f)+\" \"+ts(p.s);\r\n\t#endif\r\n}\r\n\r\ntcTU> str ts(V<pair<T, U>> v) {\r\n\t#ifdef LOCAL\r\n\t\tbool fst = 1; str res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\t#endif\r\n}\r\n\r\ntcT> str ts(T v) {\r\n\t#ifdef LOCAL\r\n\t\tbool fst = 1; str res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\r\n\t#endif\r\n}\r\n\r\n///////////////////////// DEBUG ///////////////////////////////////////////\r\n#define tcTUU tcT, class ...U\r\nvoid DBG() { cerr << \"]\" << \"\\e[0m\" << endl; }\r\ntcTUU> void DBG(const T& t, const U&... u) {\r\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\r\n\tDBG(u...); }\r\n#ifdef LOCAL\r\n\t#define dbg(...) cerr << \"\\e[1m\" << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__);\r\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\r\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\r\n#else\r\n\t#define dbg(...) 0\r\n\t#define chk(...) 0\r\n#endif\t\r\n\r\n///////////////////////// FILE I/O ////////////////////////////////////////\r\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\r\nvoid setPrec() { cout << fixed << setprecision(15); }\r\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\r\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\nvoid setIO(str s = \"\") {\r\n\tunsyncIO(); setPrec();\r\n\t#ifndef LOCAL\t\r\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for USACO\r\n\t#endif\r\n}\r\n\r\n///////////////////////// TEMPLATE ABOVE //////////////////////////////////\r\n\r\n// REMEMBER\r\n// - Don't Focus On Only One Approach\r\n// - Read And Understand Problem Fully\r\n// - Think Of Edges Cases\r\n// - Implement Carefully\r\n// - Always Check For Overflows\r\n// - Reset Global Variables\r\n// - Look At The Bigger Picture\r\n// - Don't Get Discouraged, You Can Pull It Back\r\n\r\nvoid solve() {\r\n\tint N; cin >> N;\r\n\r\n\tint t = 0; \r\n\r\n\tauto ask = [&](int r1, int c1, int r2, int c2) {\r\n\t\tcout << \"? \" << r1 << \" \" << c1 << \" \" << r2 << \" \" << c2 << endl;\r\n\t\tint RES; cin >> RES;\r\n\t\treturn RES;\r\n\t};\r\n\r\n\tauto query = [&](int r) {\r\n\t\tcout << \"? \";\r\n\t\tif (t == 0) cout << r << \" \" << 1 << \" \" << N << \" \" << N << endl;\r\n\t\tif (t == 1) cout << 1 << \" \" << r << \" \" << N << \" \" << N << endl;\r\n\r\n\t\tif (t == 2) cout << 1 << \" \" << 1 << \" \" << N - r + 1 << \" \" << N << endl;\r\n\t\tif (t == 3) cout << 1 << \" \" << 1 << \" \" << N << \" \" << N - r + 1 << endl;\r\n\r\n\t\tint RES; cin >> RES;\r\n\t\treturn RES;\r\n\t};\r\n\r\n\tvi ans(8);\r\n\r\n\tint x = 0;\r\n\tfor(; t < 4; t++) {\r\n\t\tfor(int r = 2; r >= 1; r--) {\r\n\t\t\tint lo = 1, hi = N;\r\n\t\t\twhile(lo < hi) {\r\n\t\t\t\tint mid = (lo + hi + 1) / 2;\r\n\t\t\t\tdbg(lo, mid, hi);\r\n\t\t\t\tif (query(mid) >= r) lo = mid;\r\n\t\t\t\telse hi = mid - 1;\r\n\t\t\t}\r\n\t\t\tdbg(lo);\r\n\t\t\tans[x++] = (t >= 2 ? N - lo + 1 : lo);\r\n\t\t}\t\r\n\t}\r\n\r\n\tdbg(ans);\r\n\tvi dup = ans;\r\n\r\n\r\n\tsort(all(ans));\r\n\tdo {\r\n\t\tbool ok = (ans[0] <= ans[2] && ans[4] <= ans[6] && ans[1] <= ans[3] && ans[5] <= ans[7]);\r\n\r\n\t\tfor(int i = 0; i < 4; i += 2) {\r\n\t\t\tvi a = {dup[2*i], dup[2*i+1]};\r\n\t\t\tvi b = {ans[i], ans[i+4]};\r\n\t\t\tsort(all(a)); sort(all(b));\r\n\t\t\tif (a != b) ok = 0;\r\n\t\t}\r\n\r\n\t\tint x_overlap = max(0, min(ans[2], ans[6]) - max(ans[0], ans[7]) + 1);\r\n\t\tint y_overlap = max(0, min(ans[3], ans[7]) - max(ans[1], ans[5]) + 1);\r\n\t\t\r\n\t\tok &= (x_overlap == 0 && y_overlap == 0);\r\n\r\n\t\t// ok &= (ask(ans[0], ans[1], ans[2], ans[3]) == 1);\r\n\t\t// ok &= (ask(ans[4], ans[5], ans[6], ans[7]) == 1);\r\n\t\t\r\n\t\tdbg(ok);\r\n\t\tif (ok) {\r\n\t\t\tcout << \"! \";\r\n\t\t\tF0R(i, 8) cout << ans[i] << \" \";\r\n\t\t\tcout << endl;\r\n\t\t\texit(0);\r\n\t\t}\r\n\t} while(next_permutation(all(ans)));\r\n\r\n\tassert(false);\r\n}\r\n\r\nint main() {\r\n\tsetIO(); \r\n\r\n\tint TT = 1;\r\n\t// cin >> TT;\r\n\r\n\trep(TT) solve();\r\n\t\r\n\texit(0-0);\r\n}\r\n\r\n/*\r\n5\r\n\r\n1\r\n2\r\n1\r\n0\r\n1\r\n2\r\n1\r\n1\r\n0\r\n2\r\n1\r\n2\r\n1\r\n0\r\n1\r\n1\r\n1\r\n1\r\n0\r\n\r\n\r\n\r\n*/"
}