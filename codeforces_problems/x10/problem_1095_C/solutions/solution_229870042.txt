{
    "id": 229870042,
    "contestId": 1095,
    "creationTimeSeconds": 1698325770,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1095,
        "index": "C",
        "name": "Powers Of Two",
        "type": "PROGRAMMING",
        "rating": 1400,
        "tags": [
            "bitmasks",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1095,
        "members": [
            {
                "handle": "red-akb"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1545921300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 1945600,
    "source": "\r\n///POLICY BASED DATA STRUCTURE..\r\n///order_of_key return number of element which are strictly greater/smaller than x..\r\n// ///find_by_order return ans iterator corresponding to the xth position of the set..\r\n// #include<ext/pb_ds/assoc_container.hpp>\r\n// #include<ext/pb_ds/tree_policy.hpp>\r\n// using namespace __gnu_pbds;\r\n// #define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>\r\n\r\n\r\n\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long int\r\n#define endl '\\n'\r\n#define pb(x) push_back(x)\r\n#define loop for(int i=0;i<n;i++)\r\n\r\n#define yes cout << \"YES\\n\";\r\n#define no cout << \"NO\\n\";\r\nconstexpr long long SZ = 1e5 + 7;\r\nconstexpr long long INF = 1e18;\r\nconstexpr long long mod = 1e9 + 7;\r\nconstexpr long long MOD = 998244353;\r\nconstexpr long double PI = 3.141592653589793238462;\r\n#define ll long long\r\n#define all(X) (X).begin(), (X).end()\r\n#define allr(X) (X).rbegin(), (X).rend()\r\n#define sz(X) (int)X.size()\r\n\r\n#define endl '\\n'\r\n\r\n// Modulo Arithmetic\r\nint modadd(int a, int b, int m = mod) { a = a % m; b = b % m; return (((a + b) % m) + m) % m; }\r\nint modsub(int a, int b, int m = mod) { a = a % m; b = b % m; return (((a - b) % m) + m) % m; }\r\nint modmul(int a, int b, int m = mod) { a = a % m; b = b % m; return (((a * b) % m) + m) % m; }\r\n\r\n\r\n// GCD\r\nint gcd(int a, int b) { if (b == 0) { return a; } return gcd(b, a % b); }\r\n\r\n// LCM\r\nint lcm(int a, int b) { return (a / gcd(a, b)) * b; }\r\n\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(pair<uint64_t,uint64_t> x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1);\r\n    }\r\n};\r\n//unordered_map<long long, int, custom_hash> safe_map;\r\n//gp_hash_table<long long, int, custom_hash> safe_hash_table;\r\n\r\n/* class SgTree{\r\nvector<int> seg;\r\npublic:\r\n   SgTree(ll n){\r\n       seg=vector<ll>(4*n);\r\n   } \r\nvoid Build(vector<int>&ar,ll idx,ll low,ll high){\r\n    if(low==high){\r\n      seg[idx]=(ar[low]);\r\n      return; \r\n    }\r\n    \r\n    ll mid=(low+high)>>1;\r\n \r\n    Build(ar,2*idx+1,low,mid);\r\n    Build(ar,2*idx+2,mid+1,high);\r\n \r\n    seg[idx]=seg[2*idx+1]+seg[2*idx+2]; \r\n \r\n}\r\nll Query(ll idx,ll l,ll r,ll low,ll high){\r\n     //case 1:  No overlap [l r] [low high]  OR [low high] [l r]\r\n      if(l>r)return 0;\r\n \r\n      if(r<low or high<l)return 0;\r\n \r\n    // case 2:  Full overlap [l low high r]\r\n \r\n     if(l<=low and high<=r)return seg[idx]; \r\n \r\n     ll mid=(low+high)>>1;\r\n \r\n    // case 3: partial overlap\r\n    \r\n    ll left=Query(2*idx+1,l,r,low,mid);\r\n    ll right=Query(2*idx+2,l,r,mid+1,high);\r\n \r\n    return left+right;  \r\n}\r\n  \r\n}; */\r\n\r\n\r\nbool isPrime(int n) \r\n{\r\n    if(n <= 3) return true;\r\n    for(int i = 2; i * i <= n; i++) {\r\n        if(n % i == 0) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid print(vector<int>& v) \r\n{\r\n    for(auto& x: v) {\r\n        cout << x << \" \";\r\n    }\r\n    cout << endl;\r\n}\r\nint countInversion(vector<int>& v, int n) {\r\n\t\r\n\tvector<int> suff(n, 0);\r\n\tsuff[n-1] = v[n-1] == 0;\r\n\tfor(int i = n - 2; i >= 0; i--) {\r\n\t\tsuff[i] += suff[i+1];\r\n\t\tif(v[i] == 0) suff[i]++;\r\n\t}\r\n\t\r\n\tint ans = 0;\r\n\tfor(int i = 0; i < n-1; i++)\r\n\t{\r\n\t\tif(v[i] == 1) {\r\n\t\t\tans += suff[i + 1];\r\n\t\t}\r\n\t}\r\n\t\r\n\t// cout << ans << endl;\r\n\treturn ans;\r\n}\r\n/*\r\nclass dsu {\r\n public:\r\n  vector<int> p;\r\n  int n;\r\n  vector<int> sz;\r\n \r\n  dsu(int _n) : n(_n) {\r\n    p.resize(n);\r\n    iota(p.begin(), p.end(), 0);\r\n    sz.assign(n, 1);\r\n  }\r\n \r\n  inline int get(int x) {\r\n    return (x == p[x] ? x : (p[x] = get(p[x])));\r\n  }\r\n \r\n  inline bool unite(int x, int y) {\r\n    x = get(x);\r\n    y = get(y);\r\n    if (x != y) {\r\n      p[x] = y;\r\n      sz[y] += sz[x];\r\n      sz[x] = 0;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n};*/\r\n\r\n//constexpr int v1 = 2E6;\r\nvoid solve()\r\n{\r\n    int n,k;\r\n    cin>>n>>k;\r\n    map<int,int>ans;\r\n    queue<int>q;\r\n\r\n    for(int i=0;i<=30;i++){\r\n    \tif(n&(1<<i)){\r\n    \t\tif(i>0) q.push(1<<i);\r\n    \t\tans[1<<i]++;\r\n    \t}\r\n    }\r\n    if(ans.size()>k){\r\n    \tno  \r\n    \treturn;\r\n    }\r\n    int cnt=ans.size();\r\n    while(cnt<k && !q.empty()){\r\n    \tint t=q.front();\r\n    \tq.pop();\r\n    \tans[t]--;\r\n    \tans[t/2]+=2;\r\n    \tif(t/2>1){\r\n    \t\tq.push(t/2);\r\n    \t\tq.push(t/2);\r\n    \t}\r\n    \tcnt++;\r\n    }\r\n    if(cnt<k){\r\n    \tno\r\n    \treturn;\r\n    }\r\n    yes\r\n    for(auto x:ans){\r\n    \tfor(int i=0;i<x.second;i++){\r\n    \t\tcout<<x.first<<\" \";\r\n    \t}\r\n    }\r\n\r\n  \r\n}\r\nint32_t main()\r\n{\r\n   ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    int t = 1;\r\n    //cin >> t;\r\n    while (t--)\r\n    {\r\n        solve();\r\n    }\r\n}\r\n/*------------------------------------------------ \r\n                        \\.   \\.      __,-\"-.__      ./   ./\r\n       \\.   \\`.  \\`.-'\"\" _,=\"=._ \"\"`-.'/  .'/   ./\r\n        \\`.  \\_`-''      _,=\"=._      ``-'_/  .'/\r\n         \\ `-',-._   _.  _,=\"=._  ,_   _.-,`-' /\r\n      \\. /`,-',-._\"\"\"  \\ _,=\"=._ /  \"\"\"_.-,`-,'\\ ./\r\n       \\`-'  /    `-._  \"       \"  _.-'    \\  `-'/\r\n       /)   (         \\    ,-.    /         )   (\\\r\n    ,-'\"     `-.       \\  /   \\  /       .-'     \"`-,\r\n  ,'_._         `-.____/ /  _  \\ \\____.-'         _._`,\r\n /,'   `.                \\_/ \\_/                .'   `,\\\r\n/'       )                  _                  (       `\\\r\n        /   _,-'\"`-.  ,++|T|||T|++.  .-'\"`-,_   \\\r\n       / ,-'        \\/|`|`|`|'|'|'|\\/        `-, \\\r\n      /,'             | | | | | | |             `,\\\r\n     /'               ` | | | | | '               `\\\r\n                        ` | | | '\r\n                          ` | '                                \r\n              \r\n-------------------------------------------------------*/"
}