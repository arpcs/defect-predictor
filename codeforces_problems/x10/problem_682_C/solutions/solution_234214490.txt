{
    "id": 234214490,
    "contestId": 682,
    "creationTimeSeconds": 1700907202,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 682,
        "index": "C",
        "name": "Alyona and the Tree",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1600,
        "tags": [
            "dfs and similar",
            "dp",
            "graphs",
            "trees"
        ]
    },
    "author": {
        "contestId": 682,
        "members": [
            {
                "handle": "YudoTLE"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1466181300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\n/*--------------SETTING--------------*/\r\nconst bool MULTICASE   = false;\r\nconst bool INTERACTIVE = false;\r\nconst bool ENABLE_GUI  = true;\r\n\r\n#pragma region Competitive Programming\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#ifdef _LOCAL\r\n    #include <tle/debug>\r\n    #define dout \r\n#else\r\n    #define debug(...)\r\n    #define dline(...)\r\n#endif\r\n\r\n\r\ntemplate <typename _Key>\r\nusing ordered_set            = tree<_Key, null_type, less<_Key>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate <typename _Key, typename _Tp>\r\nusing ordered_map            = tree<_Key, _Tp, less<_Key>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate <typename _Tp> \r\nusing reverse_priority_queue = priority_queue<_Tp, vector<_Tp>, greater<_Tp>>;\r\n\r\n#define vi      vector<int>    \r\n#define vvi     vector<vi>     \r\n#define ll      long long      \r\n#define vll     vector<ll>     \r\n#define vvll    vector<vll>    \r\n#define ld      long double    \r\n#define vld     vector<ld>     \r\n#define vvld    vector<vld>    \r\n#define vb      vector<bool>   \r\n#define vvb     vector<vb>     \r\n#define pi      pair<int, int> \r\n#define vpi     vector<pi>     \r\n#define vvpi    vector<vpi>    \r\n#define pll     pair<ll, ll>   \r\n#define vpll    vector<pll>    \r\n#define vvpll   vector<vpll>   \r\n#define uset    unordered_set\r\n#define mset    multiset\r\n#define oset    ordered_set\r\n#define umset   unordered_multiset\r\n#define umap    unordered_map\r\n#define mmap    multimap \r\n#define omap    ordered_map \r\n#define ummap   unordered_multimap\r\n#define pqueue  priority_queue\r\n#define rpqueue reverse_priority_queue\r\n\r\n#define fi  first\r\n#define se  second\r\n#define pb  push_back\r\n#define pf  push_front\r\n#define lb  lower_bound\r\n#define ub  upper_bound\r\n#define acc accumulate\r\n\r\n#define all(item)   item.begin(), item.end()\r\n#define rall(item)  item.rbegin(), item.rend()\r\n\r\n#define forn(index, size)           for (ll i = 0; i < size; i++)\r\n#define rforn(index, size)          for (ll i = size - 1; i >= 0; i--)\r\n#define forit(iterator, container)  for (auto iterator = container.begin(); iterator != container.end(); iterator++)\r\n#define rforit(iterator, container) for (auto iterator = container.rbegin(); iterator != container.rend(); iterator++)\r\n\r\n\r\ntemplate <typename T, typename = void>\r\nstruct is_iterator : false_type {};\r\ntemplate <typename T>\r\nstruct is_iterator<T, void_t<typename iterator_traits<T>::iterator_category>> : true_type {};\r\n\r\ntemplate <typename _Tp, typename = void>\r\nstruct is_container : false_type {};\r\ntemplate <typename _Tp>\r\nstruct is_container<_Tp, void_t<decltype(declval<_Tp>().begin()), decltype(declval<_Tp>().end()), typename _Tp::value_type>> : true_type {};\r\n\r\n\r\ntemplate <typename _Tp, typename = enable_if_t<!is_same_v<_Tp, string> && (is_iterator<_Tp>::value || is_container<_Tp>::value)>>\r\nostream& operator<< (ostream& _os, const _Tp& _item);\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nostream& operator<< (ostream& _os, const pair<_Tp1, _Tp2>& _item);\r\n\r\ntemplate <typename... _Tps>\r\nostream& operator<< (ostream& _os, const tuple<_Tps...>& _item);\r\n\r\n\r\ntemplate <typename _Tp, typename>\r\nostream& operator<< (ostream& _os, const _Tp& _item)\r\n{\r\n    if constexpr (is_iterator<_Tp>::value)\r\n        return _os << *_item;\r\n\r\n    for (auto it = _item.begin(); it != _item.end(); it++)\r\n    {\r\n        _os << *it;\r\n        if (it != prev(_item.end()))\r\n            _os << ' ';\r\n    }\r\n    return _os;\r\n}\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nostream& operator<< (ostream& _os, const pair<_Tp1, _Tp2>& _item)\r\n{\r\n    return _os << _item.first << ' ' << _item.second;\r\n}\r\n\r\ntemplate <typename... _Tps>\r\nostream& operator<< (ostream& _os, const tuple<_Tps...>& _item)\r\n{\r\n    apply(\r\n        [&_os](_Tps const&... args)\r\n        {\r\n            size_t k = sizeof...(_Tps);\r\n            ((_os << args << \" \\0\"[k == 0]), ...);\r\n        },\r\n        _item\r\n    );\r\n    return _os;\r\n}\r\n\r\n\r\ntemplate <typename _Tp>\r\nvoid print(const _Tp& _item)\r\n{\r\n    if (INTERACTIVE)\r\n        cout << _item << endl;\r\n    else\r\n        cout << _item << '\\n';\r\n}\r\ntemplate <typename _Tp, typename... _Tps>\r\nvoid print(const _Tp& _item, const _Tps&... _items)\r\n{\r\n    cout << _item << ' ';\r\n    print(_items...);\r\n}\r\n\r\n\r\ntemplate <typename _Tp, typename = enable_if_t<!is_same_v<_Tp, string> && (is_iterator<_Tp>::value || is_container<_Tp>::value)>>\r\nistream& operator>> (istream& _is, _Tp& _item);\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nistream& operator>> (istream& _is, pair<_Tp1, _Tp2>& _item);\r\n\r\ntemplate <typename _Index, typename... _Tps>\r\nistream& operator>> (istream& _is, tuple<_Tps...>& _item);\r\n\r\n\r\ntemplate <typename _Tp, typename>\r\nistream& operator>> (istream& _is, _Tp& _item)\r\n{\r\n    if constexpr (is_iterator<_Tp>::value)\r\n        return _is >> *_item;\r\n\r\n    for (auto it = _item.begin(); it != _item.end(); it++)\r\n        _is >> *it;\r\n    return _is;\r\n}\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nistream& operator>> (istream& _is, pair<_Tp1, _Tp2>& _item)\r\n{\r\n    return _is >> _item.first >> _item.second;\r\n}\r\n\r\ntemplate <size_t _Index = 0, typename... _Tps>\r\nistream& operator>> (istream& _is, tuple<_Tps...>& _item)\r\n{\r\n    if constexpr (_Index < sizeof...(_Tps))\r\n    {\r\n        _is >> get<_Index>(_item);\r\n        operator>><_Index + 1>(_is, _item);\r\n    }\r\n    return _is;\r\n}\r\n\r\ntemplate <typename _Tp>\r\nistream& operator- (istream& _is,_Tp& _item)\r\n{\r\n    return _is >> _item;\r\n}\r\n\r\nvoid scan()\r\n    { cin.ignore(); }\r\ntemplate<typename _Type, typename... _Types>\r\nvoid scan(_Type& _item, _Types&... _items)\r\n{\r\n    cin >> _item;\r\n    scan(_items...);\r\n}\r\n\r\nvoid scanln() {}\r\ntemplate<typename... _Types>\r\nvoid scanln(string& _item, _Types&... _items)\r\n{\r\n    getline(cin, _item);\r\n    scanln(_items...);\r\n}\r\n\r\n\r\ntemplate <typename _Container>\r\nauto cut(const _Container& _container, const int& _begin, const int& _end, int _add=0)\r\n{\r\n    _Container result;\r\n    if (!_add)\r\n        _add = (_begin < _end) - (_begin > _end);\r\n    for (int i = _begin; _add > 0 ? i < _end : i > _end; i += _add)\r\n        result.push_back(_container[i]);\r\n    return result;\r\n}\r\n\r\n\r\ntemplate <typename _Tp>\r\nauto range(const _Tp& _end)\r\n{\r\n    vector<_Tp> result(_end);\r\n    iota(all(result), 0);\r\n    return result;\r\n}\r\n\r\ntemplate <typename _Tp>\r\nauto range(const _Tp& _begin, const _Tp& _end, _Tp _add=0)\r\n{\r\n    vector<_Tp> result;\r\n    if (!_add)\r\n        _add = (_begin < _end) - (_begin > _end);\r\n    for (_Tp i = _begin; _add > 0 ? i < _end : i > _end; i += _add)\r\n        result.push_back(i);\r\n    return result;\r\n}\r\n\r\n\r\ntemplate <typename _Container>\r\nauto enumerate(const _Container& _item)\r\n{\r\n    vector<pair<int, typename _Container::value_type>> result;\r\n    int i = 0;\r\n    for (auto x : _item)\r\n        result.emplace_back(i++, x);\r\n    return result;\r\n}\r\n\r\ntemplate <typename _Container, size_t _Size>\r\nauto enumerate(const _Container (&_item)[_Size])\r\n{\r\n    vector<pair<int, _Container>> result;\r\n    for (int i = 0; i < _Size; i++)\r\n        result.emplace_back(i, _item[i]);\r\n    return result;\r\n}\r\n\r\n\r\ntemplate <typename... _Containers>\r\nauto zip(const _Containers&... _items)\r\n{\r\n    const size_t n = min({_items.size()...});\r\n\r\n    vector<tuple<typename _Containers::value_type...>> result;\r\n    result.reserve(n);\r\n    for (size_t i = 0; i < n; i++)\r\n        result.emplace_back(_items[i]...);\r\n    return result;\r\n}\r\n\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nvoid erase_one(_Tp1& _item, const _Tp2& _target)\r\n{\r\n    if (_item.count(_target))\r\n        _item.erase(_item.find(_target));\r\n}\r\n\r\n\r\ntemplate <typename _Tp>\r\nvoid merge_duplicate(vector<_Tp>& _item)\r\n{\r\n    for (int i = 1, j = 1; i <= _item.size(); i++)\r\n    {\r\n        if (i == _item.size())\r\n        {\r\n            _item.resize(j);\r\n            break;\r\n        }\r\n        if (_item[i] == _item[j - 1])\r\n            continue;\r\n        _item[j++] = _item[i];\r\n    }\r\n}\r\n\r\n\r\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3>\r\nbool in_range(const _Tp1& _item, const _Tp2& _low, const _Tp3& _high)\r\n    { return _low <= _item && _item <= _high; }\r\n\r\n\r\ntemplate <typename _Tp>\r\nauto min(const _Tp& _item)\r\n    { return *min_element(all(_item)); }\r\n\r\ntemplate <typename _Tp>\r\nauto max(const _Tp& _item)\r\n    { return *max_element(all(_item)); }\r\n\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nbool set_min(_Tp1& _target, const _Tp2& _new_val)\r\n    { return _new_val < _target ? _target = _new_val, true : false; }\r\n\r\ntemplate <typename _Tp1, typename _Tp2>\r\nbool set_max(_Tp1& _target, const _Tp2& _new_val)\r\n    { return _new_val > _target ? _target = _new_val, true : false; }\r\n\r\n\r\nvoid initialize();\r\nvoid solve();\r\n\r\nint main()\r\n{\r\n    initialize();\r\n    int t = 1;\r\n#ifdef _LOCAL\r\n    auto begin_timer = chrono::high_resolution_clock::now();\r\n    if (MULTICASE)\r\n    {\r\n        cin >> t;\r\n        for (int i = 1; i <= t; i++)\r\n        {\r\n            cout << \"\\x1b[1m\\x1b[3m\\x1b[48;2;85;85;85m  TESTCASE \\x1b[38;2;255;156;15m\" << i << \"  \\x1b[0m\\n\";\r\n            solve();\r\n            cout << '\\n';\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"\\x1b[1m\\x1b[3m\\x1b[48;2;85;85;85m  TESTCASE  \\x1b[0m\\n\";\r\n        solve();\r\n        cout << '\\n';\r\n    }\r\n    auto end_timer = chrono::high_resolution_clock::now();\r\n    cout << \"\\n\\nexecution time: \" << (end_timer - begin_timer) / chrono::milliseconds(1) << \" ms\" << '\\n';\r\n#else\r\n    cin.tie(NULL), ios_base::sync_with_stdio(false);\r\n    if (MULTICASE)\r\n    {\r\n        cin >> t;\r\n        for (int i = 1; i <= t; i++)\r\n            solve();\r\n    }\r\n    else\r\n    {\r\n        solve();\r\n    }\r\n#endif\r\n    return 0;\r\n}\r\n\r\n\r\n#pragma endregion\r\n/*----------WELCOME-YUDOTLE----------*/\r\n\r\nvi val;\r\nvvpi adj;\r\n\r\nint use;\r\n\r\nvoid dfs(int u, int p=0, ll d=0)\r\n{\r\n    if (d > val[u])\r\n        return;\r\n\r\n    ++use;\r\n\r\n    for (auto [v, w] : adj[u])\r\n    {\r\n        if (v == p)\r\n            continue;\r\n\r\n        dfs(v, u, d + max(0, w));\r\n    }\r\n}\r\n\r\nvoid initialize()\r\n{\r\n    \r\n}\r\n\r\nvoid solve()\r\n{\r\n    int n; cin >> n;\r\n    val.resize(n); cin >> val;\r\n    adj.resize(n);\r\n\r\n    for (int u = 1; u < n; u++)\r\n    {\r\n        int v, w;\r\n        cin >> v >> w;\r\n        --v;\r\n\r\n        // adj[u].pb({v, w});\r\n        adj[v].pb({u, w});\r\n    }\r\n\r\n    dfs(0);\r\n\r\n    int answer = n - use;\r\n    print(answer);\r\n}"
}