{
    "id": 156971786,
    "contestId": 477,
    "creationTimeSeconds": 1652415288,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 477,
        "index": "E",
        "name": "Dreamoon and Notepad",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3100,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 477,
        "members": [
            {
                "handle": "L7-56"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1413122400
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 20,
    "timeConsumedMillis": 3150,
    "memoryConsumedBytes": 135680000,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef double db;\r\ntypedef pair <int, int> pii;\r\n#define fir first\r\n#define sec second\r\n\r\nconst int maxn = 4e5 + 10, inf = 1e9;\r\nint n, a[maxn], q, ans[maxn];\r\nstruct node {\r\n\tint r1, c1, r2, c2;\r\n} b[maxn];\r\nvector <int> t[maxn];\r\n\r\nint lg2[maxn], st[maxn][20];\r\nvoid st_prework() {\r\n\tlg2[0] = -1;\r\n\tfor (int i = 1; i <= n; ++i) st[i][0] = a[i], lg2[i] = lg2[i >> 1] + 1;\r\n\tfor (int j = 1; j < 20; ++j)\r\n\t\tfor (int i = 1; i + (1 << j) <= n; ++i)\r\n\t\t\tst[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\r\n}\r\n\r\nint st_query(int l, int r) {\r\n\tif (l > r) return inf;\r\n\tint i = lg2[r - l + 1];\r\n\treturn min(st[l][i], st[r - (1 << i) + 1][i]);\r\n}\r\n\r\nint arr[maxn];\r\nstruct SegTree {\r\n\tint mn[maxn << 2], add[maxn << 2];\r\n\t#define ls (rt << 1)\r\n\t#define rs (rt << 1 | 1)\r\n\t#define mid ((l + r) >> 1)\r\n\tvoid init() {\r\n\t\tmemset(add, 0, sizeof add);\r\n\t\tmemset(mn, 0x3f, sizeof mn);\r\n\t}\r\n\tvoid push_up(int rt) { mn[rt] = min(mn[ls], mn[rs]); }\r\n\tvoid tag(int rt, int v) { add[rt] += v, mn[rt] += v; }\r\n\tvoid push_down(int rt) { if (add[rt]) tag(ls, add[rt]), tag(rs, add[rt]), add[rt] = 0; }\r\n\tvoid update(int rt, int l, int r, int pos, int val) {\r\n\t\tif (l == r) return void(mn[rt] = val);\r\n\t\tpush_down(rt); pos <= mid ? update(ls, l, mid, pos, val) : update(rs, mid + 1, r, pos, val); push_up(rt);\r\n\t}\r\n\tvoid update(int rt, int l, int r, int L, int R, int val) {\r\n\t\tif (L > r || R < l || L > R) return;\r\n\t\tif (L <= l && r <= R) return tag(rt, val);\r\n\t\tpush_down(rt), update(ls, l, mid, L, R, val), update(rs, mid + 1, r, L, R, val), push_up(rt);\r\n\t}\r\n\tint query(int rt, int l, int r, int L, int R) {\r\n\t\tif (L > r || R < l || L > R) return inf;\r\n\t\tif (L <= l && r <= R) return mn[rt];\r\n\t\treturn push_down(rt), min(query(ls, l, mid, L, R), query(rs, mid + 1, r, L, R));\r\n\t}\r\n\t#undef ls\r\n\t#undef rs\r\n\t#undef mid\r\n};\r\n\r\nvector <int> tq;\r\n\r\nnamespace solve {\r\n\r\nnamespace solve1 {\r\n\r\nSegTree tr1; // a[j]\r\nSegTree tr2; // a[j] - 2 * i\r\nSegTree tr3; // -a[j]\r\nSegTree tr4; // -a[j] - 2 * i\r\n\r\nint sta[maxn], tp;\r\nint get_pos(int val) {\r\n\tint l = 1, r = tp, mid, res = tp + 1;\r\n\twhile (l <= r) {\r\n\t\tmid = (l + r) >> 1;\r\n\t\tif (a[sta[mid]] >= val) res = mid, r = mid - 1;\r\n\t\telse l = mid + 1;\r\n\t}\r\n\treturn sta[res - 1] + 1;\r\n}\r\n\r\nvoid add(int l, int r, int val) {\r\n\ttr1.update(1, 1, n, l, r, val);\r\n\ttr2.update(1, 1, n, l, r, val);\r\n\ttr3.update(1, 1, n, l, r, -val);\r\n\ttr4.update(1, 1, n, l, r, -val);\r\n}\r\n\r\nvoid update(int i) {\r\n\ttr1.update(1, 1, n, i, a[i]);\r\n\ttr2.update(1, 1, n, i, a[i] - 2 * i);\r\n\ttr3.update(1, 1, n, i, -a[i]);\r\n\ttr4.update(1, 1, n, i, -a[i] - 2 * i);\r\n}\r\n\r\nvoid work() {\r\n\ttr1.init(), tr2.init(), tr3.init(), tr4.init();\r\n\ta[sta[tp = 1] = 0] = -1;\r\n\tfor (int i = 1; i <= n; ++i) {\r\n\t\twhile (tp && a[sta[tp]] >= a[i])\r\n\t\t\tadd(sta[tp - 1] + 1, sta[tp], a[i] - a[sta[tp]]), --tp;\r\n\t\tsta[++tp] = i;\r\n\t\tupdate(i);\r\n\t\tfor (int p : t[i]) {\r\n\t\t\tint r1 = b[p].r1, r2 = b[p].r2, c1 = b[p].c1, c2 = b[p].c2;\r\n\t\t\tint p1 = get_pos(c1), p2 = get_pos(c2), res = inf;\r\n\t\t\tres = min(res, tr1.query(1, 1, n, max(p2, r1), r2) - c2);\r\n\t\t\tres = min(res, tr2.query(1, 1, n, p2, r1 - 1) - c2 + r1 * 2);\r\n\t\t\tres = min(res, tr3.query(1, 1, n, r1, p2 - 1) + c2);\r\n\t\t\tres = min(res, tr4.query(1, 1, n, 1, min(p2 - 1, r1 - 1)) + c2 + r1 * 2);\r\n\t\t\tans[p] = min(ans[p], res + r2 - r1 + 1);\r\n\r\n\t\t\tres = inf;\r\n\t\t\tres = min(res, tr2.query(1, 1, n, p2, min(r1, p1 - 1)) - c2);\r\n\t\t\tres = min(res, tr4.query(1, 1, n, 1, min(min(p2 - 1, p1 - 1), r1)) + c2);\r\n\t\t\tif (p1 <= r1) res = min(res, abs(c1 - c2) - r1 * 2);\r\n\t\t\tans[p] = min(ans[p], res + r1 + r2);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n}\r\n\r\nnamespace solve2 {\r\n\r\nSegTree tr1; // a[j] + 2 * i\r\nSegTree tr2; // -a[j] + 2 * i\r\n\r\nint sta[maxn], tp;\r\nint get_pos(int val) {\r\n\tint l = 1, r = tp, mid, res = tp + 1;\r\n\twhile (l <= r) {\r\n\t\tmid = (l + r) >> 1;\r\n\t\tif (a[sta[mid]] >= val) res = mid, r = mid - 1;\r\n\t\telse l = mid + 1;\r\n\t}\r\n\treturn sta[res - 1] - 1;\r\n}\r\n\r\nvoid add(int l, int r, int val) {\r\n\ttr1.update(1, 1, n, l, r, val);\r\n\ttr2.update(1, 1, n, l, r, -val);\r\n}\r\n\r\nvoid update(int i) {\r\n\ttr1.update(1, 1, n, i, a[i] + 2 * i);\r\n\ttr2.update(1, 1, n, i, -a[i] + 2 * i);\r\n}\r\n\r\nvoid work() {\r\n\ttr1.init(), tr2.init();\r\n\ta[sta[tp = 1] = n + 1] = -1;\r\n\tfor (int i = n; i >= 1; --i) {\r\n\t\twhile (tp && a[sta[tp]] >= a[i])\r\n\t\t\tadd(sta[tp], sta[tp - 1] - 1, a[i] - a[sta[tp]]), --tp;\r\n\t\tsta[++tp] = i;\r\n\t\tupdate(i);\r\n\t\tfor (int p : t[i]) {\r\n\t\t\tint r1 = b[p].r1, r2 = b[p].r2, c1 = b[p].c1, c2 = b[p].c2;\r\n\t\t\tint p1 = get_pos(c1 = min(c1, st_query(r1, r2 - 1))), p2 = get_pos(c2), res = inf;\r\n\t\t\tres = min(res, tr1.query(1, 1, n, r2, p2) - c2);\r\n\t\t\tres = min(res, tr2.query(1, 1, n, max(r2, p2 + 1), n) + c2);\r\n\t\t\tans[p] = min(ans[p], res - r1 - r2 + 1);\r\n\r\n\t\t\tres = inf;\r\n\t\t\tres = min(res, tr1.query(1, 1, n, max(p1 + 1, r2), p2) - c2);\r\n\t\t\tres = min(res, tr2.query(1, 1, n, max(p1 + 1, max(p2 + 1, r2)), n) + c2);\r\n\t\t\tif (p1 >= r1) res = min(res, abs(c1 - c2) + 2 * r2);\r\n\t\t\tans[p] = min(ans[p], res - r1 - r2);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n}\r\n\r\nvoid work() {\r\n\tif (tq.empty()) return;\r\n\tfor (int i = 1; i <= n; ++i) t[i].clear();\r\n\tfor (int i : tq) t[b[i].r2].push_back(i);\r\n\tst_prework();\r\n\tfor (int i : tq) ans[i] = b[i].c2 + b[i].r2 - b[i].r1 + 1;\r\n\tsolve1 :: work();\r\n\tsolve2 :: work();\r\n}\r\n\r\n}\r\n\r\nint main() {\r\n\tscanf(\"%d\", &n);\r\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\r\n\tscanf(\"%d\", &q);\r\n\tfor (int i = 1; i <= q; ++i) {\r\n\t\tscanf(\"%d%d%d%d\", &b[i].r1, &b[i].c1, &b[i].r2, &b[i].c2);\r\n\t\tif (b[i].r1 <= b[i].r2) tq.push_back(i);\r\n\t}\r\n\tsolve :: work();\r\n\ttq.clear();\r\n\treverse(a + 1, a + n + 1);\r\n\tfor (int i = 1; i <= q; ++i) {\r\n\t\tb[i].r1 = n - b[i].r1 + 1;\r\n\t\tb[i].r2 = n - b[i].r2 + 1;\r\n\t\tif (b[i].r1 < b[i].r2) tq.push_back(i);\r\n\t}\r\n\tsolve :: work();\r\n\tfor (int i = 1; i <= q; ++i) printf(\"%d\\n\", ans[i]);\r\n\treturn 0;\r\n}\r\n"
}