{
    "id": 229728010,
    "contestId": 1389,
    "creationTimeSeconds": 1698252743,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1389,
        "index": "C",
        "name": "Good String",
        "type": "PROGRAMMING",
        "rating": 1500,
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1389,
        "members": [
            {
                "handle": "hitesh03"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1596033300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 9,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 6860800,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define FOR(i, j, k, in) for (ll i = j; i < k; i += in)\r\n#define RFOR(i, j, k, in) for (ll i = j; i >= k; i -= in)\r\n#define REP(i, j) FOR(i, 0, j, 1)\r\n#define RREP(i, j) RFOR(i, j, 0, 1)\r\n#define PI 3.1415926535897932384626433832795\r\n#define MOD 1000000007\r\n#define pb push_back\r\n#define f(v) v.begin(), v.end()\r\n\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<ll> vl;\r\ntypedef vector<vl> vvl;\r\ntypedef vector<bool> vb;\r\ntypedef vector<vector<bool>> vvb;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<ll, ll> pll;\r\ntypedef pair<string, string> pss;\r\ntypedef unordered_map<int, int> umap_ii;\r\ntypedef map<int, int> mii;\r\nll modAdd(ll a, ll b) { return (a % MOD + b % MOD) % MOD; }\r\nll modSubtract(ll a, ll b) { return ((a % MOD - b % MOD) + MOD) % MOD; }\r\nll modProduct(ll a, ll b) { return (a % MOD * b % MOD) % MOD; }\r\nll binPow(ll a, ll b)\r\n{\r\n    if (b == 0)\r\n        return 1;\r\n    ll res = binPow(a, b / 2);\r\n    if (b & 1ll)\r\n        res = res * a;\r\n    return res;\r\n}\r\nll inv(ll x) { return binPow(x, MOD - 2); }\r\nll divide(ll x, ll y) { return modProduct(x, inv(y)); }\r\nvoid printVector(vector<long long> v)\r\n{\r\n    for (long long i = 0; i < v.size(); i++)\r\n        cout << v[i] << \" \";\r\n    cout << endl;\r\n}\r\nvoid printMatrix(vector<vector<ll>> v)\r\n{\r\n    for (ll i = 0; i < v.size(); i++)\r\n    {\r\n        for (ll j = 0; j < v[i].size(); j++)\r\n            cout << v[i][j] << \" \";\r\n        cout << endl;\r\n    }\r\n}\r\nvoid printPairVector(vector<pair<ll, ll>> v)\r\n{\r\n    for (ll i = 0; i < v.size(); i++)\r\n        cout << v[i].first << \",\" << v[i].second << \" \";\r\n    cout << endl;\r\n}\r\nvoid printGraph(vvl &adj, ll n)\r\n{\r\n    for (ll i = 1; i <= n; i++)\r\n    {\r\n        cout << i << \" -> \";\r\n        for (ll j = 0; j < adj[i].size(); j++)\r\n        {\r\n            cout << adj[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    cout << endl;\r\n}\r\nvoid inputUndirectedGraph(vvl &adj, ll n, ll m)\r\n{\r\n    for (ll i = 0; i < m; i++)\r\n    {\r\n        ll u, v;\r\n        cin >> u >> v;\r\n        adj[u].push_back(v);\r\n        adj[v].push_back(u);\r\n    }\r\n}\r\nvoid inputDirectedGraph(vvl &adj, ll n, ll m)\r\n{\r\n    for (ll i = 0; i < m; i++)\r\n    {\r\n        ll u, v;\r\n        cin >> u >> v;\r\n        adj[u].push_back(v);\r\n    }\r\n}\r\nvoid inputVector(vl &v)\r\n{\r\n    for (ll i = 0; i < v.size(); i++)\r\n    {\r\n        cin >> v[i];\r\n    }\r\n}\r\nll spacesplit(string s)\r\n{\r\n    ll i = 0;\r\n    while (i < s.length() && s[i] != ' ')\r\n    {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nll maxn;\r\nvl segt;\r\nvb marked;\r\nvoid push(int v)\r\n{\r\n    if (marked[v])\r\n    {\r\n        segt[v * 2] = segt[v * 2 + 1] = segt[v];\r\n        marked[v * 2] = marked[v * 2 + 1] = true;\r\n        marked[v] = false;\r\n    }\r\n}\r\n\r\nvoid update(ll v, ll tl, ll tr, ll l, ll r, ll new_val)\r\n{\r\n    if (l > r)\r\n        return;\r\n    if (l == tl && tr == r)\r\n    {\r\n        segt[v] = new_val;\r\n        marked[v] = true;\r\n    }\r\n    else\r\n    {\r\n        push(v);\r\n        ll tm = (tl + tr) / 2;\r\n        update(v * 2, tl, tm, l, min(r, tm), new_val);\r\n        update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, new_val);\r\n    }\r\n}\r\n\r\nll get(ll v, ll tl, ll tr, ll pos)\r\n{\r\n    if (tl == tr)\r\n    {\r\n        return segt[v];\r\n    }\r\n    push(v);\r\n    ll tm = (tl + tr) / 2;\r\n    if (pos <= tm)\r\n        return get(v * 2, tl, tm, pos);\r\n    else\r\n        return get(v * 2 + 1, tm + 1, tr, pos);\r\n}\r\n\r\nvoid build(ll v, ll tl, ll tr, vl &a)\r\n{\r\n    if (tl == tr)\r\n    {\r\n        segt[v] = a[tl];\r\n        return;\r\n    }\r\n    ll tm = (tl + tr) >> 1;\r\n    build(2 * v, tl, tm, a);\r\n    build(2 * v + 1, tm + 1, tr, a);\r\n    segt[v] = min(segt[2 * v], segt[2 * v + 1]);\r\n}\r\n\r\nll query(ll v, ll tl, ll tr, ll l, ll r)\r\n{\r\n    if (l > r)\r\n        return LLONG_MAX;\r\n    if (l == tl && r == tr)\r\n        return segt[v];\r\n    ll tm = (tl + tr) >> 1;\r\n    return min(query(2 * v, tl, tm, l, min(r, tm)), query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\r\n}\r\n\r\nvoid update(ll pos, ll x, ll v, ll tl, ll tr)\r\n{\r\n    if (tl == tr)\r\n    {\r\n        segt[v] = x;\r\n        return;\r\n    }\r\n    ll tm = (tl + tr) >> 1;\r\n    if (pos <= tm)\r\n    {\r\n        update(pos, x, 2 * v, tl, tm);\r\n    }\r\n    else\r\n    {\r\n        update(pos, x, 2 * v + 1, tm + 1, tr);\r\n    }\r\n    segt[v] = min(segt[2 * v], segt[2 * v + 1]);\r\n}\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    ll t;\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n        string s;\r\n        cin >> s;\r\n        ll n = s.length();\r\n        vl fr(10);\r\n        vector<set<ll>> st(10);\r\n        REP(i, n)\r\n        {\r\n            fr[s[i] - '0']++;\r\n            st[s[i] - '0'].insert(i);\r\n        }\r\n\r\n        ll ans = n - 2;\r\n        for (char f = '0'; f <= '9'; f++)\r\n        {\r\n            for (char s = '0'; s <= '9'; s++)\r\n            {\r\n                ll i = -1, cnt = 0;\r\n                bool mid = false;\r\n                while (i < n)\r\n                {\r\n                    ll ind = n;\r\n                    auto it = st[f - '0'].upper_bound(i);\r\n                    if (it != st[f - '0'].end())\r\n                    {\r\n                        ind = *it;\r\n                    }\r\n                    i = ind;\r\n                    if(i<n)\r\n                        mid = true;\r\n                    else\r\n                        mid = false;\r\n                    it = st[s - '0'].upper_bound(i);\r\n                    ind = n;\r\n                    if (it != st[s - '0'].end())\r\n                    {\r\n                        ind = *it;\r\n                    }\r\n                    i = ind;\r\n                    if (i < n)\r\n                        cnt += 2;\r\n                    else if(mid && f==s)\r\n                        cnt++;\r\n                }\r\n                // cout<<\"cnt for \"<<f<<s<<\" : \"<<cnt<<endl;\r\n                ans = min(ans, n - cnt);\r\n            }\r\n        }\r\n        cout << ans << endl;\r\n    }\r\n    return 0;\r\n}"
}