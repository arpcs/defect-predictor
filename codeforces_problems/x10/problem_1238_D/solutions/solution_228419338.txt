{
    "id": 228419338,
    "contestId": 1238,
    "creationTimeSeconds": 1697461900,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1238,
        "index": "D",
        "name": "AB-string",
        "type": "PROGRAMMING",
        "rating": 1900,
        "tags": [
            "binary search",
            "combinatorics",
            "dp",
            "strings"
        ]
    },
    "author": {
        "contestId": 1238,
        "members": [
            {
                "handle": "jsg121"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1570545300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 19353600,
    "source": "#include  <iostream>\r\n#include <vector>\r\n#include <map>\r\n#include <set>\r\n#include <algorithm>\r\n#include <map>\r\n#include <queue>\r\n#include <cmath>\r\n#include <numeric>\r\n#include <stack>\r\n#include <set>\r\n#include <iomanip>\r\n#include <deque>\r\n#include <cstring>\r\n\r\n#include <unordered_map>\r\nconst long double pi=2*acosl(0);\r\nconst long long mod=1e9+7;\r\n\r\n\r\n\r\nusing namespace std;\r\n//// Method to calculate xor\r\n////vector<bool> isPrime (MAX, true);\r\n////https://codeforces.com/problemset/page/3?order=BY_RATING_ASC\r\n\r\n/////* returns true if given string is a palindrome *///\r\n//bool checkPalin(string s){\r\n//    long long i=0;long long j=s.length()-1;\r\n//    long long n=s.length();\r\n//    while(i<n && j>=0 && j>i){\r\n//        if(s[i]!=s[j]){\r\n//            return false;\r\n//        }\r\n//        i+=1;j-=1;\r\n//    }\r\n//    return true;\r\n//}\r\n//char alpha[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\r\n////int computeXOR(int n)\r\n////{\r\n////\r\n////    // If n is a multiple of 4\r\n////    if (n % 4 == 0)\r\n////        return n;\r\n////\r\n////    // If n%4 gives remainder 1\r\n////    if (n % 4 == 1)\r\n////        return 1;\r\n////\r\n////    // If n%4 gives remainder 2\r\n////    if (n % 4 == 2)\r\n////        return n + 1;\r\n////\r\n////    // If n%4 gives remainder 3\r\n////    return 0;\r\n////}\r\n////long long factorial(long long n)\r\n////{   long long modu=1e9+7;\r\n////    long long res = 1, i;\r\n////    for (i = 2; i <= n; i++){\r\n////        res *= (i%modu);\r\n////        res%=modu;\r\n////    }\r\n////    return res;\r\n////}\r\n// string decToBinary(long long  n)\r\n// {\r\n//     // Size of an integer is assumed to be 32 bits\r\n//     int binaryNum[65]={0};\r\n\r\n//     // counter for binary array\r\n//     int i = 0;\r\n//     while (n > 0) {\r\n\r\n//         // storing remainder in binary array\r\n//         binaryNum[i] = n % 2;\r\n//         n = n / 2;\r\n//         i++;\r\n//     }\r\n//     string s=\"\";\r\n//     for(int i=64;i>=0;i--){\r\n//         char c=binaryNum[i]+'0';\r\n//         s+=c;\r\n//     }\r\n//     return s;\r\n\r\n//     // printing binary array in reverse order\r\n\r\n// }\r\n////long long brokenCalc(long long startValue, long long target) {\r\n////    int ans=0;\r\n////    while(target>startValue){\r\n////\r\n////        if(target%2==0){\r\n////            target/=2;\r\n////        }\r\n////        else{\r\n////            target--;\r\n////        }\r\n////        ans+=1;\r\n////    }\r\n////    long long p=startValue-target;\r\n////    return p+ans;\r\n////\r\n////}\r\n//bool isPrime(long long n)\r\n//{\r\n//    // Corner cases\r\n//    if (n <= 1)\r\n//        return false;\r\n//    if (n <= 3)\r\n//        return true;\r\n//\r\n//    // This is checked so that we can skip\r\n//    // middle five numbers in below loop\r\n//    if (n % 2 == 0 || n % 3 == 0)\r\n//        return false;\r\n//\r\n//    for (int i = 5; i * i <= n; i = i + 6)\r\n//        if (n % i == 0 || n % (i + 2) == 0)\r\n//            return false;\r\n//\r\n//        return true;\r\n//}\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//bool checkIfSorted(vector<int>& v){\r\n//    for(int i=1;i<v.size();i++){\r\n//        if(v[i]<v[i-1]){\r\n//            return false;\r\n//        }\r\n//    }\r\n//    return true;\r\n//}\r\n//\r\n/////*finds Factorial*/\r\n//long long fact(long long n)\r\n//{\r\n//    long long i,fact=1;\r\n//    if(n==0){\r\n//        return 1;\r\n//    }\r\n//\r\n//    for(i=1; i<=n; i++)\r\n//    {\r\n//        fact=fact*i;\r\n//        fact%=998244353;\r\n//    }\r\n//    return fact%998244353;\r\n//}\r\n/////*find gcd in O(log(min(a,b))*/\r\nlong long gcd(long long a, long long b)\r\n{\r\n    return b == 0 ? a : gcd(b, a % b);\r\n}\r\n/////*******//checks if given number is power of 2********/\r\n//bool checkIFPOwof2(long long n){\r\n//    while(n%2==0 && n>1){\r\n//        n/=2;\r\n//    }\r\n//    if(n==1){\r\n//        return true;\r\n//    }\r\n//    return false;\r\n//}\r\n/////*finds n choose 2 */\r\n//long long nC2(long long n){\r\n//    return n*(n-1)/2;\r\n//}\r\n/////*finds power of 2*/\r\n//long long findPowO2(long long x){\r\n//    long long ans=0;\r\n//    while(x>0 && x%2==0){\r\n//        x/=2;\r\n//        ans+=1;\r\n//    }\r\n//    return ans;\r\n//\r\n//\r\n//\r\n//}\r\n//\r\n/////* returns index of a value in vector && if it is ot present returns -1*/\r\n//long long findVal(vector<long long> &v,long long val){\r\n//    for(long long i=0;i<v.size();i++){\r\n//        if(v[i]==val){\r\n//            return i;\r\n//        }\r\n//    }\r\n//    return -1;\r\n//}\r\n/////*Converts  a decimal number to any base*/\r\n//vector<int> convertDectoAnyBase(long long n,long long k){\r\n//    vector<int> v(64,0);\r\n//    long long i=63;\r\n//    while(n>0){\r\n//        int p=n%k;\r\n//        v[i]=p;\r\n//        n/=k;\r\n//        i-=1;\r\n//\r\n//    }\r\n//    return v;\r\n//}\r\n//\r\n/////*returns number of power of a number exists in a given number*/\r\n//long long findNumofPow(long long a,long long m){\r\n//    long long cnt=0;\r\n//    while(a%m==0 && a>0){\r\n//        a/=m;\r\n//        cnt+=1;\r\n//    }\r\n//    return cnt;\r\n//}\r\nlong long fastPow(long long a,long long b){\r\n    long long res=1;\r\n    while(b){\r\n        if(b&1) res=(res*a);\r\n        a=(a*a);\r\n        b/=2;\r\n    }\r\n    return res;\r\n}\r\n//\r\n//\r\n/////* checks if one string is subsequence of other*///\r\n//bool checkISsub(string dn,string dr ){\r\n//    long long i=0,j=0;\r\n//    if(dn.length()>dr.length()){\r\n//        return false;\r\n//    }\r\n//    long long n=dr.length(),m=dn.length();\r\n//    while(i<m && j<n){\r\n//        if(dn[i]==dr[j]){\r\n//            i+=1;j+=1;\r\n//        }\r\n//        else{\r\n//            j+=1;\r\n//        }\r\n//    }\r\n//    if(i<m){\r\n//        return false;\r\n//    }\r\n//    return true;\r\n//}\r\n//int parent[500005],sz[500005];\r\n//int findParent(int a){\r\n//    return parent[a]==a?a:parent[a]= findParent(parent[a]);\r\n//}\r\n//void merge(int a,int b){\r\n//    int af= findParent(a);\r\n//    int bf= findParent(b);\r\n//    if(af!=bf){\r\n//        if(sz[af]>=sz[bf]){\r\n//            sz[af]+=sz[bf];\r\n//            parent[bf]=af;\r\n//        }\r\n//        else{\r\n//            sz[bf]+=sz[af];\r\n//            parent[af]=bf;\r\n//        }\r\n//    }\r\n//}\r\n/////*finds Sum of two strings*///\r\n//string findsum(string &s1,string &s2){\r\n//    string ans=\"\";\r\n//    int carr=0;\r\n//    while(s1.size() && s2.size()){\r\n//        char c1=s1.back();\r\n//        char c2=s2.back();\r\n//        s1.pop_back();\r\n//        s2.pop_back();\r\n//        int val=c1-'0'+c2-'0'+carr;\r\n//        carr=val/10;\r\n//        char c=val%10+'0';\r\n//        ans+=c;\r\n//    }\r\n//    while(s1.size()){\r\n//        char c1=s1.back();\r\n//        s1.pop_back();\r\n//        int val=c1-'0'+carr;\r\n//        carr=val/10;\r\n//        char c=val%10+'0';\r\n//        ans+=c;\r\n//    }\r\n//    while(s2.size()){\r\n//        char c1=s2.back();\r\n//        s2.pop_back();\r\n//        int val=c1-'0'+carr;\r\n//        carr=val/10;\r\n//        char c=val%10+'0';\r\n//        ans+=c;\r\n//    }\r\n//    if(carr>0){\r\n//        char c=carr+'0';\r\n//        ans+=c;\r\n//\r\n//    }\r\n//\r\n//    reverse(ans.begin(),ans.end());\r\n//    return ans;\r\n//}\r\n//long long giveEuGcd(long long a,long long b){\r\n//    long long x=min(a,b),y=max(a,b);\r\n//    long long r=y%x;\r\n//    while(r!=0){\r\n//        r=y%x;\r\n//        x=r;\r\n//        if(r==0){\r\n//            return x;\r\n//        }\r\n//        swap(x,y);\r\n//    }\r\n//    return x;\r\n//}\r\n//long long convStrtoll(string &s){\r\n//    long long ans=0;\r\n//    for(int i=0;i<s.length();i++){\r\n//        ans+=(s[i]-'0')*pow(10,s.length()-i-1);\r\n//    }\r\n//    return ans;\r\n//}\r\n//\r\n//long long mode=1e9+7;\r\n//string finds(string s,int k){\r\n//\r\n//    while(s.length()<k){\r\n//        s+=s;\r\n//\r\n//    }\r\n//    while(s.length()>k){\r\n//        s.pop_back();\r\n//    }\r\n//    return s;\r\n//}\r\n//vector<long long > primeFactorisation(long long n){\r\n//    vector<long long> v;\r\n//\r\n//    while(n%2==0){\r\n//        n/=2;\r\n//        v.push_back(2);\r\n//    }\r\n//    for(int i=3;i*i<=n;i+=2){\r\n//        while(n%i==0){\r\n//            n/=i;\r\n//            v.push_back(i);\r\n//        }\r\n//    }\r\n//    if(n>2){\r\n//        v.push_back(n);\r\n//    }\r\n//    return v;\r\n//\r\n//}\r\n//\r\nint isPrimes[100009];\r\nvoid linearSieve(){\r\n\r\n    for(int i=0;i<100009;i++){\r\n\r\n        isPrimes[i]=i;\r\n    }\r\n    for(int i=2;i*i<100009;i++){\r\n\r\n        if(isPrimes[i]==i && i*i<100009){\r\n            for(int j=i*i;j<100009;j+=i){\r\n                isPrimes[j]=i;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\nlong long arrfact[200005];\r\n//void precomputepow2(){\r\n//    arrpow2[0]=1;\r\n//    for(int i=1;i<200005;i++){\r\n//        arrpow2[i]=arrpow2[i-1]*2;\r\n//        arrpow2[i]%=998244353;\r\n//    }\r\n//    return;\r\n//}\r\nvoid precomputefact(){\r\n    arrfact[0]=1;arrfact[1]=1;\r\n    //    arrfactinv[0]=1;arrfactinv[1]=1;\r\n    long long modu=998244353;\r\n    for(long long i=2;i<=200004;i++){\r\n\r\n\r\n        arrfact[i]=arrfact[i-1]*i;\r\n        arrfact[i]%=modu;\r\n        //        arrfactinv[i]= fastPow(arrfact[i],modu-2);\r\n    }\r\n}\r\n//bool checker(vector<vector<long long>>v,long long l){\r\n//    for(long long )\r\n//}\r\n//long long findSumofDig(long long n){\r\n//    string s= to_string(n);\r\n//    long long ans=0;\r\n//    for(int i=0;i<s.length();i++){\r\n//        ans+=s[i]-'0';\r\n//    }\r\n//    return ans;\r\n//}\r\n//long long findifApowinB(long long a,long long b){\r\n//    long long c=b;\r\n//    long long cnt=0;\r\n//    while(c%a==0){\r\n//        c/=a;\r\n//        cnt+=1;\r\n//    }\r\n//    if(c==1){\r\n//        return cnt;\r\n//    }\r\n//    return -1;\r\n//}\r\n\r\nstring toConvertInBinaryOfReqdSize(int m,int sz){\r\n    string p(sz,'0');\r\n    int i=sz-1;\r\n    while(m>0){\r\n        if(m%2){\r\n            p[i]='1';\r\n        }\r\n        m/=2;\r\n        i-=1;\r\n    }\r\n    return p;\r\n}\r\n\r\nint findlsb(int n){\r\n    int ans=0;\r\n    for(int j=0;j<31;j++){\r\n        int val=(1<<j);\r\n        if(val&n){\r\n            return j;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n//\r\n//int findPar(int a,vector<int> &daddy){\r\n//    return daddy[a]==a?a:daddy[a]= findPar(daddy[a],daddy);\r\n//}\r\n//void merge(int a,int b,vector<int>&daddy,vector<int>&vol){\r\n//    int af= findPar(a,daddy);\r\n//    int bf= findPar(b,daddy);\r\n//    if(af!=bf){\r\n//        if(vol[af]>=vol[bf]){\r\n//            daddy[bf]=af;\r\n//            vol[af]+=vol[bf];\r\n//        }\r\n//        else{\r\n//            daddy[af]=bf;\r\n//            vol[bf]+=vol[af];\r\n//        }\r\n//    }\r\n//}\r\n//double calcProb(vector<int>&v){\r\n//    long double sum=0;\r\n//    for(auto it:v){\r\n//        if(it>1){\r\n//            long double val=(it*(it-1))/2;\r\n//            sum+=val;\r\n//        }\r\n//    }\r\n//    long double denom=N*(N-1)/2;\r\n//    long double fAns=sum/denom;\r\n//    return fAns;\r\n//}\r\nvector<int> getPrimeFac(int b){\r\n    vector<int> ans;\r\n    int a=b;\r\n    while(isPrimes[a]!=a){\r\n        ans.push_back(isPrimes[a]);\r\n        a/=isPrimes[a];\r\n    }\r\n    if(a!=1){\r\n        ans.push_back(a);\r\n    }\r\n    return ans;\r\n}\r\n\r\nvoid solve(){\r\n   int n;\r\n   cin>>n;\r\n   string s;\r\n   cin>>s;\r\n   vector<vector<int>> v(n,vector<int>(4));\r\n   if(s.back()=='A'){\r\n       v[n-1][0]=n-1;\r\n       v[n-1][1]=-1;\r\n       v[n-1][2]=1;\r\n       v[n-1][3]=0;\r\n   }\r\n   else{\r\n       v[n-1][1]=n-1;\r\n       v[n-1][0]=-1;\r\n       v[n-1][3]=1;\r\n       v[n-1][2]=0;\r\n   }\r\n   for(int i=n-2;i>=0;i--){\r\n       if(s[i]=='A'){\r\n           v[i][0]=i;\r\n           v[i][1]=v[i+1][1];\r\n           v[i][2]=1+v[i+1][2];\r\n           v[i][3]=v[i+1][3];\r\n       }\r\n       else{\r\n           v[i][0]=v[i+1][0];\r\n           v[i][1]=i;\r\n           v[i][2]=v[i+1][2];\r\n           v[i][3]=1+v[i+1][3];\r\n       }\r\n   }\r\n//   for(int i=0;i<n;i++){\r\n//       cout<<v[i][0]<<\" \"<<v[i][1]<<\" \"<<v[i][2]<<\" \"<<v[i][3]<<endl;\r\n//   }\r\n   long long ans=0;\r\n   for(int i=0;i<n-1;i++){\r\n       if(v[i][2]==0 || v[i][3]==0){\r\n           ans+=(n-i-1);\r\n       }\r\n       else{\r\n           if(s[i]=='A'){\r\n               if(v[i][2]==1){\r\n                   continue;\r\n               }\r\n               else{\r\n                   ans+=(n-i-1);\r\n                   int idx=v[i][1];\r\n                   ans-=1;\r\n               }\r\n           }\r\n           else{\r\n               if(v[i][3]==1){\r\n                   continue;\r\n               }\r\n               else{\r\n                   ans+=(n-i-1);\r\n                   int idx=v[i][1];\r\n                   ans-=1;\r\n               }\r\n           }\r\n       }\r\n//       cout<<ans<<endl;\r\n   }\r\n   cout<<ans<<endl;\r\n}\r\nint main(){\r\n//    int t;\r\n//    cin>>t;\r\n//    while(t--){\r\n//        solve();\r\n//    }\r\n    solve();\r\n}"
}