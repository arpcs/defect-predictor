{
    "id": 231502599,
    "contestId": 1670,
    "creationTimeSeconds": 1699208616,
    "relativeTimeSeconds": 876,
    "problem": {
        "contestId": 1670,
        "index": "A",
        "name": "Prof. Slim",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "greedy",
            "implementation",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1670,
        "members": [
            {
                "handle": "abdouBR"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1699207740
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 23,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 10854400,
    "source": "#include<bits/stdc++.h>\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compile and get accepted.\n *      ____________\n *     /            \\\n *    /  /\\      /\\  \\\n *   /  /  \\    /  \\  \\\n *   \\                /\n *    \\     \\___/    /\n *     \\____________/\n */\n\n\n\n\n\n\n#define f(i,j,k) for(long long i=j;i<k;i++)\n#define fb(i,j,k) for(long long i=j;i>=k;i--)\n#define fs(i,j,k,p) for(long long i=j;i<k;i+=p)\n#define fbs(i,j,k,p) for(long long i=j;i>=k;i-=p)\n#define cond(a) if(a)cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl\n#define yes cout<<\"YES\"<<endl\n#define no cout<<\"NO\"<<endl\n#define test int t;cin>>t;while(t--)\n#define endl \"\\n\"\n#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define nline \"\\n\"\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define PI 3.141592653589793238462\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<int>> vvi;\n\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\n#else\n#define debug(x)\n#endif\n\nvoid _print(ll t) {cerr << t;}\nvoid _print(int t) {cerr << t;}\nvoid _print(string t) {cerr << t;}\nvoid _print(char t) {cerr << t;}\nvoid _print(lld t) {cerr << t;}\nvoid _print(double t) {cerr << t;}\nvoid _print(ull t) {cerr << t;}\n\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\n\n//template<class T> using oset =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\n\nll PRO(ll a,ll b,ll MOD)\n{\n  return ((a%MOD)*(b%MOD)%MOD);\n}\nll power(ll x, ll y, ll M)\n{\n  if (y == 0)\n    return 1;\n  ll p = power(x, y / 2, M) % M;\n  p = (p * p) % M;\n  return (y % 2 == 0) ? p : (x * p) % M;\n}\nbool isprime(ll n)\n{\n\n  for(ll i=2;i*i<=n;i++)\n  {\n    if(n%i==0)return false;\n  }\n  return true;\n}\n\n\nconst ll mod = 1e9+7;\nconst int N=10000001;\nbool prime[N + 1];\nvoid SieveOfEratosthenes(int n)\n{\n  memset(prime, true, sizeof(prime));\n    for (int p=2;p*p<=n;p++){\n      if (prime[p] == true) {\n        for (int i = p * p; i <= n; i += p)\n          prime[i] = false;\n      }\n    }\n}\nint add(int a, int b){\n    return (a + b) % mod;\n}\nint sub(int a, int b){\n    return (a - b + mod) % mod;\n}\nll mul(int a, int b){\n    return (((ll)a%mod) * ((ll)b%mod)) % mod;\n}\nll mod_inv (ll a,ll modi)\n{\n    return power(a,modi-2,modi);\n}\n\nll n1,n2;\n\nstruct node\n{\n    ll x;\n    node()\n    {\n        x=-1e6;\n    }\n    node(ll i)\n    {\n        x=i;\n    }\n    void applyLazy(ll p,ll ns,ll ne)\n    {\n        x+=p;\n    }\n};\n\nnode merg (node i ,node j )\n{\n    return node(max(i.x,j.x));\n}\n\nstruct segment_tree_lazy_propagation\n{\n    vector<node> tree;\n    vector<int> lazy; // Lazy propagation array\n    vector<bool> lazyFlag; // Lazy propagation flag array\n\n    void clear ()\n    {\n        tree.clear();\n        lazy.clear();\n        lazyFlag.clear();\n    }\n\n    void init(int num, const vector<int>& pr)\n    {\n        n2=num;\n        tree.assign(4 * n2, node());\n        lazy.assign(4 * n2, 0);\n        lazyFlag.assign(4 * n2, false);\n        build(pr);\n    }\n\n    void build(const vector<int>& pr, int id = 0, int ns = 0, int ne = n2 - 1)\n    {\n        if (ns == ne) {\n            tree[id] = node(pr[ns]);\n            return;\n        }\n\n        int l = 2 * id + 1;\n        int r = l + 1;\n        int md = ns + (ne - ns) / 2;\n\n        build(pr, l, ns, md);\n        build(pr, r, md + 1, ne);\n\n        tree[id] = merg(tree[l], tree[r]);\n    }\n\n    // Lazy propagation function\n    void propagate(int id, int ns, int ne)\n    {\n        if (lazyFlag[id]) {\n            tree[id].applyLazy(lazy[id],ns,ne);\n\n            if (ns != ne) {\n                lazy[2 * id + 1] += lazy[id];\n                lazy[2 * id + 2] += lazy[id];\n                lazyFlag[2 * id + 1] = lazyFlag[2 * id + 2] = true;\n            }\n\n            lazy[id] = 0;\n            lazyFlag[id] = false;\n        }\n    }\n\n    node query(int qs, int qe, int id = 0, int ns = 0, int ne = n2 - 1)\n    {\n        propagate(id, ns, ne);\n\n        if (ns > qe || qs > ne) {\n            return node(); // Infinity\n        }\n\n        if (qs <= ns && qe >= ne) {\n            return tree[id];\n        }\n\n        int l = 2 * id + 1;\n        int r = l + 1;\n        int md = ns + (ne - ns) / 2;\n\n        node ndl = query(qs, qe, l, ns, md);\n        node ndr = query(qs, qe, r, md + 1, ne);\n\n        return merg(ndl, ndr);\n    }\n\n    void upd(int qs, int qe, ll val, int id = 0, int ns = 0, int ne = n2 - 1)\n    {\n        propagate(id, ns, ne);\n\n        if (ns > qe || qs > ne) {\n            return;\n        }\n\n        if (qs <= ns && qe >= ne) {\n            tree[id].applyLazy(val,ns,ns);\n\n            if (ns != ne) {\n                lazy[2 * id + 1] += val;\n                lazy[2 * id + 2] += val;\n                lazyFlag[2 * id + 1] = lazyFlag[2 * id + 2] = true;\n            }\n\n            return;\n        }\n\n        int l = 2 * id + 1;\n        int r = l + 1;\n        int md = ns + (ne - ns) / 2;\n\n        upd(qs, qe, val, l, ns, md);\n        upd(qs, qe, val, r, md + 1, ne);\n\n        tree[id] = merg(tree[l], tree[r]);\n    }\n\n}sta;\n\n\nll gcd(ll a , ll b) {return b ? gcd(b , a % b) : a ;}\nll lcm(ll a , ll b) {return (a * b) / gcd(a , b);}\n\n\n\n\n\n\n\nconst ll moo = 1e9+7;\n\n\n\n\n\nvoid solve()\n{\n  int n ;\n  cin>>n;\n  vll a(n);\n  ll pos = 0,neg = 0;\n  f(i,0,n){\n    cin>>a[i];\n    if(a[i]>=0)pos++;\n    else neg++;\n  }\n  f(i,0,n){\n    if(neg==0)a[i]=abs(a[i]);\n    else {\n      a[i]=-abs(a[i]);\n      neg--;\n    }\n  }\n  f(i,1,n){\n    if(a[i]<a[i-1]){\n      no;return;\n    }\n  }\n  yes;\n}\n\nint main()\n{\n  fastio();\n  //std::cout << std::setprecision(11) << a << '\\n';\n  //freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);\n\n  test\n  {\n    solve();\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}