{
    "id": 227730867,
    "contestId": 1353,
    "creationTimeSeconds": 1697053819,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1353,
        "index": "F",
        "name": "Decreasing Heights",
        "type": "PROGRAMMING",
        "rating": 2200,
        "tags": [
            "brute force",
            "dp"
        ]
    },
    "author": {
        "contestId": 1353,
        "members": [
            {
                "handle": "Satoru_81"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1589466900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 49,
    "timeConsumedMillis": 1856,
    "memoryConsumedBytes": 716800,
    "source": "\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#define pb push_back\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pil pair<int,long long>\r\n#define fer(i,a,n) for(int i=(a);i<=(n);++i)\r\n#define rep(i,n,a) for(int i=(n);i>=(a);--i)\r\n#define ferl(i,a,n) for(long long i=(a);i<=(n);++i)\r\n#define repl(i,n,a) for(long long i=(n);i>=(a);--i)\r\n#define fi first\r\n#define se second\r\n#define elif else if\r\n#define no cout<<\"NO\\n\";\r\n#define yes cout<<\"YES\\n\";\r\n#define none cout<<\"-1\\n\";\r\n#define mul_t int _t;cin>>_t;while(_t--)\r\n#define FASTIO ios::sync_with_stdio(false);cin.tie(0);\r\n#define Hash gp_hash_table\r\n#define notall(x) x.begin()+1,x.end()\r\n#define all(x) x.begin(),x.end()\r\ntemplate<class T>\r\nvoid print(const T& t) {\r\n\tcout << t;\r\n}\r\ntemplate<class T, class...args>\r\nvoid print(const T& t, const args&...rest) {\r\n\tcout << t << ' ';\r\n\tprint(rest...);\r\n}\r\ntypedef long long ll;\r\n\r\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_int_set;\r\ntypedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> ordered_ll_set;\r\ntypedef tree<double,null_type,less_equal<double>,rb_tree_tag,tree_order_statistics_node_update> ordered_multiset;\r\nconst int int_inf= 0x3f3f3f3f;\r\nconst ll ll_inf=1e16;\r\nll qpow(ll a,ll k,ll mod){ll res=1;a%=mod;while(k){if(k&1)res=res*a%mod;a=a*a%mod;k>>=1;}return res;}\r\ntemplate<class T1,class T2>\r\nvoid mul(T1&x,T2 y,ll mod){x=(x+mod)%mod,y=(y+mod)%mod,x=(x*y)%mod;}\r\ntemplate<class T1,class T2>\r\nvoid dif(T1&x,T2 y,ll mod){x=(x+mod)%mod,y=qpow(y,mod-2,mod),x=(x*y)%mod;}\r\ntemplate<class T1,class T2>\r\nvoid add(T1&x,T2 y,ll mod){x=(x+mod)%mod,y=(y+mod)%mod,x=(x+y)%mod;}\r\ntemplate<class T1,class T2>\r\nvoid dec(T1&x,T2 y,ll mod){x=(x+mod)%mod,y=(y+mod)%mod,x=(x-y+mod)%mod;}\r\ntemplate<class T>\r\nT gcd(T a,T b){return b?gcd(b,a%b):a;}\r\n//exgcd ax+by=gcd(a,b) ax+by=z (z > a*b-a-b)\r\ntemplate<class T>\r\nT exgcd(T a,T b,T &x,T &y){T d=a;if(b==0)x=1,y=0;else{d=exgcd(b,a%b,y,x),y-=a/b*x;}return d;}\r\nvector<bool>isnotprime;\r\nvector<int>primes;\r\nvoid getprime(int n){isnotprime.resize(n+1,0);isnotprime[1]=1;for(int i=2;i<=n;i++){if(isnotprime[i]==0)primes.push_back(i);for(size_t j=0;j<primes.size()&&i*primes[j]<=n;j++){isnotprime[i*primes[j]]=1;if(i%primes[j]==0)break;}}}\r\n//\u6c42\u6b27\u62c9\u51fd\u6570 \u2211(d|n)\u03c6(d)=n\r\nvector<ll>phi;\r\nvoid getphi(int n){isnotprime.resize(n+1,0);phi.resize(n+1,0);phi[1]=1,isnotprime[1]=1;for(int i=2;i<=n;i++){if(isnotprime[i]==0){primes.push_back(i);phi[i]=i-1;}for(size_t j=0;j<primes.size()&&i*primes[j]<=n;j++){isnotprime[i*primes[j]]=1;if(i%primes[j]==0){phi[i*primes[j]]=phi[i]*primes[j];break;}phi[i*primes[j]]=phi[i]*(primes[j]-1);}}}\r\nstruct combination{combination(int n,ll mo){siz=n,mod=mo;inv.resize(n+1,1),preinv.resize(n+1,1),fac.resize(n+1,1);for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod,preinv[i]=preinv[i-1]*inv[i]%mod;for(long long i=2;i<=n;i++)fac[i]=fac[i-1]*i%mod;}ll C(int n,int m){if(n==0&&m==0)return 1;if(n<m||m<0||n<0)return 0;return fac[n]*preinv[m]%mod*preinv[n-m]%mod;}ll A(int n,int m){if(n==0&&m==0)return 1;if(n<m||m<0||n<0)return 0;return fac[n]*preinv[n-m]%mod;}vector<ll>inv;vector<ll>preinv;vector<ll>fac;private:int siz;ll mod;};\r\nstruct dsu{vector<int>fa,siz;dsu(int n){fa.resize(n+1),siz.resize(n+1);for(int i=1;i<=n;i++)fa[i]=i,siz[i]=1;}int ffind(int x){return x==fa[x]?x:fa[x]=ffind(fa[x]);}bool uuion(int x,int y){x=ffind(x),y=ffind(y);if(x==y)return false;if(siz[x]<siz[y])swap(x,y);fa[y]=x,siz[x]+=siz[y],siz[y]=0;return true;}bool check(int x,int y){return ffind(x)==ffind(y);}void init(){for(size_t i=1;i<=fa.size()-1;i++)fa[i]=i,siz[i]=1;}int getsize(int x){return siz[x];}};\r\ntemplate<class T>\r\nstruct segtree{int siz;vector<T>sum,minn,maxx,a;segtree(vector<T>&v){a=v;siz=a.size()-1;sum.resize(siz*4+5),minn.resize(siz*4+5),maxx.resize(siz*4+5);build(1,1,siz);}segtree(int sz,T val){siz=sz;a.resize(siz+1,val);sum.resize(siz*4+5),minn.resize(siz*4+5),maxx.resize(siz*4+5);build(1,1,siz);}void upchange(int k,int l,int r,int x,T y){if(l==r){sum[k]=minn[k]=maxx[k]=y;return;}int mid=(l+r)>>1;if(x<=mid)upchange(k<<1,l,mid,x,y);else upchange(k<<1|1,mid+1,r,x,y);up(k);}void upadd(int k,int l,int r,int x,T y){if(l==r){sum[k]+=y,minn[k]+=y,maxx[k]+=y;return;}int mid=(l+r)>>1;if(x<=mid)upadd(k<<1,l,mid,x,y);else upadd(k<<1|1,mid+1,r,x,y);up(k);}T qsum(int k,int l,int r,int x,int y){if(l==x&&r==y)return sum[k];int mid=(l+r)>>1;if(y<=mid)return qsum(k<<1,l,mid,x,y);else if(x>mid)return qsum(k<<1|1,mid+1,r,x,y);else return qsum(k<<1,l,mid,x,mid)+qsum(k<<1|1,mid+1,r,mid+1,y);}T qmin(int k,int l,int r,int x,int y){if(l==x&&r==y)return minn[k];int mid=(l+r)>>1;if(y<=mid)return qmin(k<<1,l,mid,x,y);else if(x>mid)return qmin(k<<1|1,mid+1,r,x,y);else return min(qmin(k<<1,l,mid,x,mid),qmin(k<<1|1,mid+1,r,mid+1,y));}T qmax(int k,int l,int r,int x,int y){if(l==x&&r==y)return maxx[k];int mid=(l+r)>>1;if(y<=mid)return qmax(k<<1,l,mid,x,y);else if(x>mid)return qmax(k<<1|1,mid+1,r,x,y);else return max(qmax(k<<1,l,mid,x,mid),qmax(k<<1|1,mid+1,r,mid+1,y));}private:void build(int k,int l,int r){if(l==r){sum[k]=minn[k]=maxx[k]=a[l];return;}int mid=(l+r)>>1;build(k<<1,l,mid),build(k<<1|1,mid+1,r);up(k);}void up(int k){sum[k]=sum[k<<1]+sum[k<<1|1],minn[k]=min(minn[k<<1],minn[k<<1|1]),maxx[k]=max(maxx[k<<1],maxx[k<<1|1]);}};\r\nstruct Bitcounter{template<class T>T reversebit(T x){int f=1;if(x<0)x=-x,f=-1;vector<int>v;while(x){v.push_back(x&1);x>>=1;}reverse(v.begin(),v.end());T now=1,ans=0;for(auto&x:v)ans+=x*now,now<<=1;return ans*f;}template<class T>T lowbit(T x){return x&-x;}template<class T>int countbit(T x){int sum=0;while(x)sum+=x&1,x>>=1;return sum;}template<class T>void setbit(int*arr,T x){int cnt=0;while(x)arr[cnt]=x&1,x>>=1,++cnt;}ll getbit(int*arr,int n=61){ll sum=0;for(int i=0;i<n;i++)sum+=arr[i],sum<<=1;sum+=arr[n];return sum;}};\r\ntemplate<class T>\r\nT reverseD(T x){int f=1;if(x<0)x=-x,f=-1;vector<int>v;while(x){v.push_back(x%10);x/=10;}reverse(v.begin(),v.end());T now=1,ans=0;for(auto&x:v)ans+=x*now,now*=10;return ans*f;}\r\ntemplate<class T1,class T2>\r\nT1 updiv(T1 a,T2 b){if(a<0)return a/b;return a/b+(a%b!=0);}\r\ntemplate<class T1,class T2>\r\nT1 downdiv(T1 a,T2 b){if(a>0)return a/b;return a/b-(a%b!=0);}\r\nvoid strerase(string&s,char c){string t;for(auto&ch:s){if(ch==c)continue;t+=ch;}s=t;}\r\ntemplate<class T1,class T2>\r\nvoid cmin(T1&a,T2 b){a=min<T1>(a,b);}\r\ntemplate<class T1,class T2>\r\nvoid cmax(T1&a,T2 b){a=max<T1>(a,b);}\r\n//-------------------------------------------\r\nvoid solve()\r\n{\t\r\n\tll n,m;\r\n\tcin>>n>>m;\r\n\tvector<vector<ll>>mp(n+1,vector<ll>(m+1));\r\n\tfunction<bool(ll x,ll y)>ck=[&](ll x,ll y)\r\n\t{\r\n\t\treturn x>=1&&x<=n&&y>=1&&y<=m;\r\n\t};\r\n\tfer(i,1,n)fer(j,1,m)cin>>mp[i][j];\r\n\tferl(i,1,n)ferl(j,1,m)mp[i][j]-=(i+j-2);\r\n\tset<ll>s;\r\n\tfer(i,1,n)fer(j,1,m)s.insert(mp[i][j]);\r\n\tint sz=0;\r\n\tfor(const auto&c:s)if(c<=mp[1][1])++sz;\r\n\tll dp[n+1][m+1];\r\n\tll ans=2e18;\r\n\tfor(const auto&c:s)\r\n\t{\r\n\t\tif(c>mp[1][1])break;\r\n\t\tfer(i,1,n)fer(j,1,m)dp[i][j]=2e18;\r\n\t\tdp[1][1]=mp[1][1]-c;\r\n\t\tfer(i,1,n)fer(j,1,m)\r\n\t\t{\r\n\t\t\tif(i==1&&j==1)continue;\r\n\t\t\tif(ck(i-1,j)&&mp[i][j]>=c)cmin(dp[i][j],dp[i-1][j]+mp[i][j]-c);\r\n\t\t\tif(ck(i,j-1)&&mp[i][j]>=c)cmin(dp[i][j],dp[i][j-1]+mp[i][j]-c);\r\n\t\t}\r\n\t\tcmin(ans,dp[n][m]);\r\n\t}\r\n\tcout<<ans<<'\\n';\r\n}\r\nsigned main()\r\n{\r\n\tFASTIO\r\n#define\tOJ\r\n#ifndef OJ\r\n\tfreopen(\".in\", \"r\", stdin);\r\n\tfreopen(\".out\", \"w\", stdout);\r\n#endif\r\n#define MUL_CASE\r\n#ifdef MUL_CASE\r\n\tmul_t solve();\r\n#else \r\n\tsolve();\r\n#endif\r\n}\r\n"
}