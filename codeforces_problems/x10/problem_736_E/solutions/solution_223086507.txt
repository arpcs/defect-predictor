{
    "id": 223086507,
    "contestId": 736,
    "creationTimeSeconds": 1694523393,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 736,
        "index": "E",
        "name": "Chess Championship",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2900,
        "tags": [
            "constructive algorithms",
            "flows",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 736,
        "members": [
            {
                "handle": "youbot"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1480264500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 18022400,
    "source": "// Problem: Chess Championship\r\n// Contest: Luogu\r\n// URL: https://www.luogu.com.cn/problem/CF736E\r\n// Memory Limit: 250 MB\r\n// Time Limit: 2000 ms\r\n// \r\n// Powered by CP Editor (https://cpeditor.org)\r\n\r\n// dottle bot\r\n#ifndef ONLINE_JUDGE\r\n#define DEBUG\r\n#endif\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <queue>\r\n#include <vector>\r\n#include <bitset>\r\n#include <map>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <set>\r\n#define nln puts(\"\")\r\n#define od(x) printf(\"%d\",x)\r\n#define odb(x) printf(\"%d \",x)\r\n#define odl(x) printf(\"%d\\n\",x)\r\n#define odp(x,y) printf(\"%d %d\\n\",x,y)\r\n#define ol(x) puts(\"\")\r\n#define old(x) printf(\"%lld\",x)\r\n#define oldb(x) printf(\"%lld \",x)\r\n#define oldl(x) printf(\"%lld\\n\",x)\r\n#define oldp(x,y) printf(\"%lld %lld\\n\",x,y)\r\n#define rg(x) for(int i=1;i<=(x);i++){\r\n#define rg_(i,x) for(int i=1;i<=(x);i++){\r\n#define fe(u) for(int i=h[u];i;i=e[i].nxt){int v=e[i].v;\r\n#define gr }\r\n#define rrg(x) for(int i=0;i<(x);i++){\r\n#define rdln(a) a[i]=read();\r\n#define rdln0(a,x) rrg(x) rdln(a) gr\r\n#define rdln1(a,x) rg(x) rdln(a) gr\r\n\r\n// #define int long long\r\nconst int mod=998244353;\r\n#ifdef int \r\n#define inf 0x3f3f3f3f3f3f3f3fll\r\n#else \r\n#define inf 0x3f3f3f3f\r\n#endif\r\ninline int min(int a,int b){return a>b?b:a;}\r\ninline int max(int a,int b){return a<b?b:a;}\r\n#define cmlSEGMIN\r\n#define cmlSEGMAX\r\n#define cmlSEGSUM\r\nclass SegTreeAl{\r\n#ifdef cmlSEGMIN\r\n\tint minn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\tint maxn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\tint sum[1000005<<2];\r\n#endif\r\n\tint tag[1000005<<2];\r\n#ifdef cmlSEGSUM\r\n\tvoid pushdown(int o,int l,int r)\r\n#else \r\n\tvoid pushdown(int o)\r\n#endif\r\n\t{\r\n\t\tint&t=tag[o];\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o<<1]+=t;\r\n\t\tminn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o<<1]+=t;\r\n\t\tmaxn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tint m=l+r>>1;\r\n\t\tsum[o<<1]+=t*(m-l+1);\r\n\t\tsum[o<<1|1]+=t*(r-m);\r\n#endif\r\n\t\ttag[o<<1]+=t;\r\n\t\ttag[o<<1|1]+=t;\r\n\t\tt=0;\r\n\t}\r\n\tvoid add(int o,int l,int r,int L,int R,int v)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n#ifdef cmlSEGMAX\r\n\t\t\tmaxn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\t\tminn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\t\tsum[o]+=v*(r-l+1);\r\n#endif\r\n\t\t\ttag[o]+=v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint m=l+r>>1;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)add(o<<1,l,m,L,R,v);\r\n\t\tif(m<R)add(o<<1|1,m+1,r,L,R,v);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t}\r\n#ifdef cmlSEGMIN\r\n\tint qmin(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn minn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=min(res,qmin(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=min(res,qmin(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGMAX\r\n\tint qmax(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn maxn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=-inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=max(res,qmax(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=max(res,qmax(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGSUM\r\n\tint qsum(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn sum[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=0;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res+=qsum(o<<1,l,m,L,R);\r\n\t\tif(m<R)res+=qsum(o<<1|1,m+1,r,L,R);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n};\r\n#define newe(n) struct Edge{int v,w,nxt;}e[2*n+5];\\\r\ntypedef int arr[n+5];\\\r\narr h;\\\r\nint cnt=1;\\\r\ninline void addedge(int u,int v,int w){e[cnt]=(Edge){v,w,h[u]};h[u]=cnt++;}\\\r\nstruct node{\\\r\n\tint u,d;\\\r\n\tbool operator<(const node&b)const{return d>b.d;}\\\r\n};\\\r\nvoid dij(int s,int *d,int N)\\\r\n{\\\r\n\tmemset(d,0x3f,sizeof(int)*(N+3));\\\r\n\td[s]=0;std::priority_queue<node>q;q.push((node){s,0});\\\r\n\twhile(!q.empty())\\\r\n\t{\\\r\n\t\tint u=q.top().u,D=q.top().d;q.pop();if(D!=d[u])continue;\\\r\n\t\tfor(int i=h[u];i;i=e[i].nxt){int v=e[i].v,w=e[i].w;\\\r\n\t\tif(d[u]+w<d[v])d[v]=d[u]+w,q.push((node){v,d[v]});\\\r\n\t\t}\\\r\n\t}\\\r\n}\r\n#define mgs int fa[1<<22],sz[1<<22];\\\r\ninline int f(int x){return x==fa[x]?x:fa[x]=f(fa[x]);}\\\r\ninline int uf(int x,int y)\\\r\n{\\\r\n    int fx=f(x),fy=f(y);\\\r\n    if(fx==fy)return 0;\\\r\n    if(sz[fx]>sz[fy])fx^=fy^=fx^=fy;\\\r\n    fa[fx]=fy,sz[fy]+=sz[fx];\\\r\n    return 1;\\\r\n}\r\ninline int read()\r\n{\r\n    int num=0,f=1;char c=getchar();\r\n    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}\r\n    while(c>47&&c<58)num=num*10+(c^48),c=getchar();\r\n    return num*f;\r\n}\r\ninline int re1d()\r\n{\r\n    char c=getchar();\r\n    while(c<48||c>49)c=getchar();\r\n    return c&1;\r\n}\r\n#ifdef cmlBIT\r\nstruct BIT{int a[1<<20|1],n;\r\nvoid add(int x,int p){while(x<=n)a[x]+=p,x+=x&-x;}\r\nint operator[](int x){int res=0;while(x)res+=a[x],x-=x&-x;return res;}\r\nint operator()(int l,int r){return (*this)[r]-(*this)[l-1];}};\r\n#endif\r\nint rnv[1000005];\r\n// #define COMB\r\n#ifdef COMB\r\n#ifndef int\r\n#define int long long\r\n#endif\r\nint fac[1000005],inv[1000005];\r\n#endif\r\nvoid initprog()\r\n{\r\n#ifdef COMB\r\n\tfac[0]=inv[0]=inv[1]=1;\r\n\trg(1000000)fac[i]=fac[i-1]*i%mod;gr\r\n\trg(1000000)if(i>1)inv[i]=inv[mod%i]*(mod-mod/i)%mod;gr\r\n\trg(1000000)rnv[i]=inv[i];gr\r\n\trg(1000000)inv[i]=inv[i]*inv[i-1]%mod;gr\r\n#endif\r\n}\r\n#ifdef COMB\r\nint C(int n,int m)\r\n{\r\n\tif(n==m||m==0)return 1;\r\n\tif(n<m)return 0;\r\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r\n}\r\n#endif\r\ninline int qp(int a,int b){int c=1;while(b){if(b&1)c=c*a%mod;a=a*a%mod;b>>=1;}return c;}\r\ninline int mae(int &a,int b){a+=b;if(a>=mod)a-=mod;return a;}\r\ninline int mde(int &a,int b){a+=mod-b;if(a>=mod)a-=mod;return a;}\r\ninline int mle(int &a,int b){a=a*b%mod;return a;}\r\ninline int mve(int &a,int b){a=a*qp(b,mod-2)%mod;return a;}\r\ninline int mxe(int &a,int b){return a=a>b?a:b;}\r\ninline int mne(int &a,int b){return a=a<b?a:b;}\r\ninline int ae(int a,int b){int c=a+b;return c>=mod?c-mod:c;}\r\ninline int de(int a,int b){return ae(a,mod-b);}\r\ninline int me(int a,int b){return a*b%mod;}\r\ninline int mive(int &a,int b){a=a*rnv[b]%mod;return a;}\r\ninline int ive(int a,int b){return a*rnv[b]%mod;}\r\ninline int ve(int a,int b){return a*qp(b,mod-2)%mod;}\r\n#ifdef cmlST\r\nstruct STmin{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=min(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn min(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\nstruct STmax{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=max(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn max(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\n#endif\r\n#ifdef cmlSAM\r\nstruct SAM{\r\n\tint ch[1000005][26],lnk[1000005],len[1000005],lst=1,cc=1;\r\n\tint sz[1000005];\r\n\tvoid insert(int c)\r\n\t{\r\n\t\tlen[++cc]=len[lst]+1;sz[cc]=1;\r\n\t\tint p=lst;lst=cc;\r\n\t\twhile(p&&ch[p][c]==0)ch[p][c]=cc,p=lnk[p];\r\n\t\tif(p==0)lnk[cc]=1;\r\n\t\telse\r\n\t\t{\r\n\t\t\tint x=ch[p][c];\r\n\t\t\tif(len[p]+1==len[x])lnk[cc]=x;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint q=cc;++cc;\r\n\t\t\t\tlnk[cc]=lnk[x];\r\n\t\t\t\tlnk[x]=lnk[q]=cc;\r\n\t\t\t\tlen[cc]=len[p]+1;\r\n\t\t\t\tmemcpy(ch[cc],ch[x],sizeof(ch[cc]));\r\n\t\t\t\twhile(p&&ch[p][c]==x)ch[p][c]=cc,p=lnk[p];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tnewe(1000005);\r\n\tlong long ans;\r\n\tvoid build()\r\n\t{\r\n\t\trg(cc)addedge(lnk[i],i,0);gr\r\n\t}\r\n\tvoid dfs(int u)\r\n\t{\r\n\t\tfe(u)dfs(v),sz[u]+=sz[v];gr\r\n\t\tif(sz[u]>1)ans=max(ans,1ll*sz[u]*len[u]);\r\n\t}\r\n}t;\r\n#endif\r\nint a[1234567];\r\nchar g[3005][3005];\r\nint nw[3005];\r\n#include <vector>\r\nsigned main()\r\n{\r\n\tinitprog();\r\n\tint n=read(),m=read();\r\n\tint sum=n*(n-1);\r\n\tfor(int i=1;i<=m;i++)a[i]=read(),sum-=a[i];\r\n\tif(n!=m)\r\n\t{\r\n\t\tint D=sum/(n-m);\r\n\t\tfor(int i=m+1;i<=n;i++)a[i]=D,sum-=D;\r\n\t\tfor(int i=m+1;i<=sum+m;i++)a[i]++;\r\n\t}\r\n\tstd::reverse(a+1,a+1+n);\r\n\tif(!std::is_sorted(a+1,a+1+n))return puts(\"no\"),0;\r\n\tsum=0;\r\n\tfor(int i=1;i<=n;i++)\r\n\t{\r\n\t\tsum+=a[i];\r\n\t\tif(sum<i*(i-1))return puts(\"no\"),0;\r\n\t}\r\n\tstd::set<std::pair<int,int> >q;\r\n\tstd::reverse(a+1,a+1+n);\r\n\tfor(int i=1;i<=n;i++)q.insert({a[i],i});\r\n\t// while(!q.empty())\r\n\tint lst=0;\r\n\tfor(int i=1;i<=n;i++)\r\n\t{\r\n\t\tauto[d,u]=*--q.end();q.erase({d,u});\r\n\t\t// odp(d,u);\r\n\t\t\tstd::vector<std::pair<int,int> >q2;\r\n\t\tif(d&1)\r\n\t\t{\r\n\t\t\td--;\r\n\t\t\tif(lst==0)lst=u;\r\n\t\t\telse g[lst][u]=g[u][lst]='D',q2.push_back({a[lst],lst}),q.erase({a[lst],lst});\r\n\t\t}\r\n\t\tg[i][i]='X';\r\n\t\t\r\n\t\twhile(d)\r\n\t\t{\r\n\t\t\tauto [e,v]=*q.begin();\r\n\t\t\tq2.push_back({e,v});\r\n\t\t\tq.erase({e,v});\r\n\t\t\t// odp(u,v);\r\n\t\t\tg[u][v]='W',g[v][u]='L';\r\n\t\t\td-=2;\r\n\t\t}\t\r\n\t\tfor(auto t:q2)q.insert(t);\r\n\t\tfor(int i=1;i<=n;i++)\r\n\t\t\tif(g[u][i]==0)\r\n\t\t\t{\r\n\t\t\t\tg[u][i]='L';\r\n\t\t\t\tg[i][u]='W';\r\n\t\t\t\tq.erase({a[i],i});\r\n\t\t\t\ta[i]-=2;\r\n\t\t\t\tq.insert({a[i],i});\r\n\t\t\t}\r\n\t}\r\n\tputs(\"yes\");\r\n\trg(n)puts(g[i]+1);gr\r\n\treturn 0;\r\n}"
}