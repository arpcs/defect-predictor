{
    "id": 210819464,
    "contestId": 744,
    "creationTimeSeconds": 1687571005,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 744,
        "index": "D",
        "name": "Hongcow Draws a Circle",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 3200,
        "tags": [
            "geometry"
        ]
    },
    "author": {
        "contestId": 744,
        "members": [
            {
                "handle": "2qbingxuan"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1481992500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 10,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 8806400,
    "source": "// An AC a day keeps the doctor away.\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#ifdef local\n#define safe std::cerr<<__PRETTY_FUNCTION__<<\" line \"<<__LINE__<<\" safe\\n\"\n#define debug(args...) qqbx(#args, args)\n#define orange(args...) danb(#args, args)\nusing std::cerr;\ntemplate <typename ...T> void qqbx(const char *s, T ...args) {\n    int cnt = sizeof...(T);\n    ((cerr << \"\\e[1;32m(\" << s << \") = (\"), ..., (cerr << args << (--cnt ? \", \" : \")\\e[0m\\n\")));\n}\ntemplate <typename I> void danb(const char *s, I L, I R) {\n    cerr << \"\\e[1;32m[ \" << s << \" ] = [ \";\n    for (int f = 0; L != R; ++L) cerr << (f++ ? \", \" : \"\") << *L;\n    cerr << \" ]\\e[0m\\n\";\n}\n#else\n#define safe ((void)0)\n#define debug(...) ((void)0)\n#define orange(...) ((void)0)\n#endif // local\n#define all(v) begin(v),end(v)\n\nusing namespace std;\n\nusing lld = int64_t;\nusing llf = long double;\n\nint sgn(lld x) { return (x > 0) - (x < 0); }\n\n// return the faces with pt indexes\nstruct P3{\n  lld x,y,z;\n  P3 operator - (const P3 &b) const {\n    return (P3){x-b.x,y-b.y,z-b.z};}\n  P3 operator * (const P3 &b) const {\n    return(P3){y*b.z-b.y*z,z*b.x-b.z*x,x*b.y-b.x*y};\n  }\n  P3(lld tx, lld ty, lld tz) : x(tx), y(ty), z(tz) {}\n  lld dot(const P3 &b) {\n      return x*b.x+y*b.y+z*b.z;\n  }\n};\nP3 ver(P3 a, P3 b, P3 c) { return (b - a) * (c - a); }\nstruct Face {\n  int a, b, c;\n  Face(int ta,int tb,int tc):a(ta),b(tb),c(tc){}\n};\nvector<Face> convex_hull_3D(const vector<P3> &pt) {\n  int n = int(pt.size()); vector<Face> now;\n  if (n <= 2) return {}; // be careful about edge case\n  vector<vector<int>> flag(n, vector<int>(n));\n  vector<vector<int>> parallel(n, vector<int>(n));\n  now.emplace_back(0,1,2); now.emplace_back(2,1,0);\n  for (int i = 3; i < n; i++) {\n    vector<Face> next;\n    vector<pair<int,int>> para;\n    for (const auto &f : now) {\n      lld d = (pt[i] - pt[f.a]).dot(\n          ver(pt[f.a], pt[f.b], pt[f.c]));\n      if (d <= 0) next.push_back(f);\n      int ff = (d > 0) - (d < 0);\n      flag[f.a][f.b]=flag[f.b][f.c]=flag[f.c][f.a]=ff;\n    }\n    for (const auto &f : now) {\n      P3 N = ver(pt[f.a], pt[f.b], pt[f.c]);\n      const auto F = [&](int x, int y) {\n          if (parallel[x][y]) return;\n          if (flag[x][y] > 0 && flag[y][x] <= 0)\n              next.emplace_back(x, y, i);\n          else if (flag[x][y] == 0 && flag[y][x] == 0) {\n              P3 A = ver(pt[y], pt[x], pt[i]);\n              // A = kN, check if k < 0\n              int k = sgn(A.x)*sgn(N.x) + sgn(A.y)*sgn(N.y) + sgn(A.z)*sgn(N.z);\n              if (k > 0) {\n                  para.emplace_back(y, x);\n                  next.emplace_back(y, x, i);\n              }\n          }\n      };\n      F(f.a, f.b); F(f.b, f.c); F(f.c, f.a);\n    }\n    for (auto [x, y]: para) parallel[x][y] = parallel[y][x] = true;\n    now = next;\n  }\n  return now;\n}\n// delaunay: facets with negative z normal of\n// convexhull of (x, y, x^2 + y^2)\n\n\n#define x first\n#define y second\ntemplate<typename P>\nllf getCircum(const P &a, const P &b, const P &c){\n    llf a1 = a.x-b.x, b1 = a.y-b.y;\n    llf c1 = (a.x+b.x)/2.0 * a1 + (a.y+b.y)/2.0 * b1;\n    llf a2 = a.x-c.x, b2 = a.y-c.y;\n    llf c2 = (a.x+c.x)/2.0 * a2 + (a.y+c.y)/2.0 * b2;\n    pair<llf,llf> o;\n    o.x = (c1*b2-b1*c2)/(a1*b2-b1*a2);\n    o.y = (a1*c2-c1*a2)/(a1*b2-b1*a2);\n    llf r = hypot(o.x-a.x, o.y-a.y);\n    return r;\n}\n#undef x\n#undef y\n\n#define ALL(v) begin(v),end(v)\n#define pll pair<int,int>\n#define pb emplace_back\n#define SZ(v) int(v.size())\nint64_t ori(pll a, pll b, pll c) {\n    return 1LL * (b.first - a.first) * (c.second - a.second) - 1LL * (c.first - a.first) * (b.second - a.second);\n}\nvoid make_hull(vector<pll> &dots) { // n=1 => ans = {}\n    sort(dots.begin(), dots.end());\n    vector<pll> ans(1, dots[0]);\n    for (int ct = 0; ct < 2; ++ct, reverse(ALL(dots)))\n        for (int i = 1, t = SZ(ans); i < SZ(dots); i++) {\n            while (SZ(ans) > t && ori(\n                        ans[SZ(ans) - 2], ans.back(), dots[i]) <= 0)\n                ans.pop_back();\n            ans.pb(dots[i]);\n        }\n    ans.pop_back(), ans.swap(dots);\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    debug(setprecision(5), fixed);\n\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int,int>> red(n), blue(m);\n    for (auto &[x, y]: red) cin >> x >> y;\n    for (auto &[x, y]: blue) cin >> x >> y;\n\n    if (blue.size() <= 2) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n\n    // mt19937 rng(12938);\n    // shuffle(blue.begin(), blue.end(), rng);\n\n    vector<P3> pt;\n    for (auto [x, y]: blue) {\n        pt.emplace_back(x, y, x*x+y*y);\n    }\n\n    auto faces = convex_hull_3D(pt);\n    {\n        ofstream fout(\"out.txt\");\n        for (auto f: faces) {\n            // if (ver(pt[f.a], pt[f.b], pt[f.c]).z < 0) {\n                auto A = blue[f.a];\n                auto B = blue[f.b];\n                auto C = blue[f.c];\n                fout << A.first << ' ' << A.second << ' ';\n                fout << B.first << ' ' << B.second << '\\n';\n                fout << B.first << ' ' << B.second << ' ';\n                fout << C.first << ' ' << C.second << '\\n';\n                fout << C.first << ' ' << C.second << ' ';\n                fout << A.first << ' ' << A.second << '\\n';\n            // }\n        }\n    }\n\n    {\n        auto B = blue;\n        make_hull(B);\n        if (B.size() <= 2) {\n            cout << -1 << '\\n';\n            return 0;\n        }\n        for (auto p: red) {\n            bool inside = true;\n            for (size_t i = 0; i < B.size(); i++)\n                if (ori(B[i], B[(i+1)%B.size()], p) <= 0)\n                    inside = false;\n            if (!inside)\n                return cout << -1 << '\\n', 0;\n        }\n    }\n\n\n    vector<vector<int>> flag(m, vector<int>(m));\n\n    llf ans = 0;\n    const auto check = [&](pair<int,int> a, pair<int,int> b, pair<int,int> c) {\n        P3 A(a.first, a.second, a.first*a.first+a.second*a.second);\n        P3 B(b.first, b.second, b.first*b.first+b.second*b.second);\n        P3 C(c.first, c.second, c.first*c.first+c.second*c.second);\n        if (ver(A, B, C).z >= 0)\n            return;\n        auto r = getCircum(a, b, c);\n        ans = max(ans, r);\n    };\n\n    for (auto [X, Y]: red) {\n        const P3 P = { X, Y, X*X+Y*Y };\n        for (const auto &f : faces) {\n            lld d = (P - pt[f.a]).dot(\n                    ver(pt[f.a], pt[f.b], pt[f.c]));\n            if (d >= 0) check(blue[f.a], blue[f.b], blue[f.c]);\n            int ff = (d > 0) - (d < 0);\n            flag[f.a][f.b]=flag[f.b][f.c]=flag[f.c][f.a]=ff;\n        }\n        for (const auto &f : faces) {\n            P3 N = ver(pt[f.a], pt[f.b], pt[f.c]);\n            const auto F = [&](int x, int y) {\n                if (flag[x][y] > 0 && flag[y][x] <= 0)\n                    check(blue[x], blue[y], {X, Y});\n                else if (flag[x][y] == 0 && flag[y][x] == 0) {\n                    P3 A = ver(pt[x], pt[y], P);\n                    int k; // A = kN, check if k < 0\n                    if (A.x != 0) k = sgn(A.x) * sgn(N.x);\n                    else if (A.y != 0) k = sgn(A.y) * sgn(N.y);\n                    else if (A.z != 0) k = sgn(A.z) * sgn(N.z);\n                    else k = 0;\n                    if (k < 0) check(blue[x], blue[y], {X, Y});\n                }\n            };\n            F(f.a, f.b); F(f.b, f.c); F(f.c, f.a);\n        }\n    }\n\n    cout << fixed << setprecision(20);\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
}