{
    "id": 109068496,
    "contestId": 571,
    "creationTimeSeconds": 1614852557,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 571,
        "index": "D",
        "name": "Campus",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 3100,
        "tags": [
            "binary search",
            "data structures",
            "dsu",
            "trees"
        ]
    },
    "author": {
        "contestId": 571,
        "members": [
            {
                "handle": "SoraKasugan0"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1440261000
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 9,
    "timeConsumedMillis": 327,
    "memoryConsumedBytes": 179200000,
    "source": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define pb push_back\r\n#define mkp make_pair\r\n#define vi vector<int>\r\n#define pii pair<int,int>\r\n#define FI(n) FastIO::read(n)\r\n#define FO(n) FastIO::write(n)\r\n#define ull unsigned long long\r\n#define mst(a,b) memset(a,b,sizeof(a))\r\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\r\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\r\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\r\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\r\n#define Fin(s) freopen(s,\"r\",stdin)\r\n#define Fout(s) freopen(s,\"w\",stdout)\r\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\r\n#define INF ((1<<30)-1)\r\n//#define int long long\r\nconst int P=998244353; //\r\nusing namespace std;\r\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\r\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\r\ninline int mul(int a,int b) {return 1ll*a*b%P;}\r\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\r\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\r\ninline void mulmod(int &a,int b) {a=mul(a, b);}\r\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\r\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\r\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\r\ninline int inv(int a) {return ksm(a,P-2);}\r\nnamespace FastIO {\r\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\r\n  int read(char *s) {\r\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\r\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\r\n  }\r\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\r\n  void write(int x) {\r\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\r\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\r\n  }\r\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\r\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\r\n};\r\ninline int read() {int x; FI(x); return x;}\r\nconst int MN=5e5+5;\r\nint n,m;\r\nstruct ele {\r\n\tint o,x,y;\r\n\tele(){} ele(int O,int X,int Y) : o(O),x(X),y(Y) {}\t\r\n};\r\nstruct SMT {\r\n\tstatic const int N=MN<<3;\r\n\tll tag[N],sum[N];\r\n\t#define ls (k<<1)\r\n\t#define rs (k<<1|1)\r\n\t#define mid ((l+r)>>1)\r\n\tvoid pushr(int k,int l,int r,int v) {\r\n\t\ttag[k]+=v,sum[k]+=1ll*(r-l+1)*v;\t\r\n\t}\r\n\tvoid pushdown(int k,int l,int r) {\r\n\t\tif(tag[k]) {\r\n\t\t\tpushr(ls,l,mid,tag[k]),pushr(rs,mid+1,r,tag[k]);\r\n\t\t\ttag[k]=0;\r\n\t\t}\r\n\t}\r\n\tvoid upd(int k,int l,int r,int ql,int qr,int v) {\r\n\t\tif(l>qr||r<ql) return void();\r\n\t\tif(ql<=l&&r<=qr) return pushr(k,l,r,v); pushdown(k,l,r);\r\n\t\tupd(ls,l,mid,ql,qr,v),upd(rs,mid+1,r,ql,qr,v); \r\n\t}\r\n\tll qry(int k,int l,int r,int p) {\r\n\t\tif(l==r) return sum[k]; pushdown(k,l,r);\r\n\t\treturn p<=mid?qry(ls,l,mid,p):qry(rs,mid+1,r,p);\r\n\t}\r\n}tr1;\r\nstruct SMT_cov {\r\n\tstatic const int N=MN<<3;\r\n\tint tag[N],sum[N];\r\n\t#define ls (k<<1)\r\n\t#define rs (k<<1|1)\r\n\tvoid pushr(int k,int l,int r,int v) {\r\n\t\ttag[k]=v,sum[k]=v;\t\r\n\t}\r\n\tvoid pushdown(int k,int l,int r) {\r\n\t\tif(tag[k]) {\r\n\t\t\tpushr(ls,l,mid,tag[k]),pushr(rs,mid+1,r,tag[k]);\r\n\t\t\ttag[k]=0;\r\n\t\t}\r\n\t}\r\n\tvoid upd(int k,int l,int r,int ql,int qr,int v) {\r\n\t\tif(l>qr||r<ql) return void();\r\n\t\tif(ql<=l&&r<=qr) return pushr(k,l,r,v); pushdown(k,l,r);\r\n\t\tupd(ls,l,mid,ql,qr,v),upd(rs,mid+1,r,ql,qr,v); \r\n\t}\r\n\tint qry(int k,int l,int r,int p) {\r\n\t\tif(l==r) return sum[k]; pushdown(k,l,r);\r\n\t\treturn p<=mid?qry(ls,l,mid,p):qry(rs,mid+1,r,p);\r\n\t}\r\n}tr2;\r\nstruct DSU {\r\n\tstatic const int N=MN<<1;\r\n\tint f[N],L[N],R[N],siz[N],tot=0,ind=0;\r\n\tvector<int>e[N];\r\n\tDSU() {For(i,0,N-5) f[i]=i,siz[i]=1;}\r\n\tint find(int x) {\r\n\t\treturn x==f[x]?x:f[x]=find(f[x]);\r\n\t}\r\n\tint merge(int x,int y) {\r\n\t\tx=find(x),y=find(y); \r\n\t\ttot++; f[x]=f[y]=tot; siz[tot]=siz[x]+siz[y]; e[tot].pb(x),e[tot].pb(y);\r\n\t\treturn tot;\r\n\t}\r\n\tvoid dfs(int u) {\r\n\t\tL[u]=++ind;\r\n\t\tfor(auto v:e[u]) {\r\n\t\t\tdfs(v);\r\n\t\t}R[u]=ind;\r\n\t}\r\n\tvoid init() {\r\n\t\tfoR(i,tot,1) if(!L[i]) dfs(i);\t\r\n\t}\r\n}d1,d2;\r\nele t[MN];\r\nll ans[MN];\r\nvector<pii>q[MN];\r\nsigned main() {\r\n\t#ifndef ONLINE_JUDGE\r\n\t\tfreopen(\"pro.in\",\"r\",stdin);\r\n\t\tfreopen(\"pro.out\",\"w\",stdout);\r\n\t#endif\r\n\tn=read(),m=read();\r\n\td1.tot=d2.tot=n;\r\n\tFor(i,1,m) {\r\n\t\tchar o[55]; FI(o); int oo=-1 ,x=read(),y=0;\r\n\t\tif(o[0]=='U') {\r\n\t\t\ty=read(),oo=1;\r\n\t\t\td1.merge(x,y);\r\n\t\t}\r\n\t\tif(o[0]=='M') y=read(),oo=2,d2.merge(x,y);\r\n\t\tif(o[0]=='A') oo=3;\r\n\t\tif(o[0]=='Z') oo=4;\r\n\t\tif(o[0]=='Q') oo=5;\r\n\t\tt[i]=ele(oo,x,y);\r\n\t}\r\n\td1.init(),d2.init();\r\n//\tcerr<<d1.tot<<' '<<d2.tot<<endl;\r\n//\tFor(i,1,d2.tot) {\r\n//\t\tcerr<<d2.L[i]<<' '<<d2.R[i]<<endl;\r\n//\t}\r\n\tFor(i,1,d2.tot) d2.f[i]=i;\r\n\tint p=d2.tot; d2.tot=n;\r\n\tFor(i,1,m) {\r\n\t\tif(t[i].o==2) {\r\n\t\t\td2.merge(t[i].x,t[i].y);\r\n\t\t}\r\n\t\tif(t[i].o==4) {\r\n\t\t\tint f=d2.find(t[i].x);\r\n//\t\t\tcerr<<f<<' '<<d2.L[f]<<' '<<d2.R[f]<<endl;\r\n\t\t\ttr2.upd(1,1,p,d2.L[f],d2.R[f],i);\r\n\t\t}\r\n\t\tif(t[i].o==5) {\r\n//\t\t\tcerr<<i<<' '<<tr2.qry(1,1,p,d2.L[t[i].x])<<endl;\r\n\t\t\tq[tr2.qry(1,1,p,d2.L[t[i].x])].push_back(mkp(t[i].x,i));\r\n\t\t}\r\n\t}\r\n\tFor(i,1,d1.tot) d1.f[i]=i,d1.siz[i]=1;\r\n\tp=d1.tot; d1.tot=n;\r\n\tFor(i,1,m) {\r\n\t\tfor(auto it:q[i]) {\r\n//\t\t\tcerr<<it.first<<' '<<it.second<<' '<<id[it.first]<<' '<<tr1.qry(1,1,p,id[it.first])<<endl;\r\n\t\t\tans[it.second]-=tr1.qry(1,1,p,d1.L[it.first])\t;\r\n\t\t}\r\n\t\tif(t[i].o==1) {\r\n\t\t\td1.merge(t[i].x,t[i].y);\r\n\t\t}\r\n\t\tif(t[i].o==3) {\r\n\t\t\tint f=d1.find(t[i].x);\r\n\t\t\ttr1.upd(1,1,p,d1.L[f],d1.R[f],d1.siz[f]);\r\n\t\t}\r\n\t\tif(t[i].o==5) {\r\n\t\t\tans[i]+=tr1.qry(1,1,p,d1.L[t[i].x]);\r\n\t\t}\r\n\t}\r\n\tFor(i,1,m) {\r\n\t\tif(t[i].o==5) printf(\"%lld\\n\",ans[i]);\t\r\n\t}\r\n\treturn FastIO::Fflush(),0;\r\n}\r\n/*\r\n0. Enough array size? Enough array size? Integer overflow?\r\n\r\n1. Think TWICE, Code ONCE!\r\nAre there any counterexamples to your algo?\r\n\r\n2. Be careful about the BOUNDARIES!\r\nN=1? P=1? Something about 0?\r\n\r\n3. Do not make STUPID MISTAKES!\r\nTime complexity? Memory usage? Precision error?\r\n*/"
}