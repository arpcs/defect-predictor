{
    "id": 216780381,
    "contestId": 1444,
    "creationTimeSeconds": 1690940967,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1444,
        "index": "D",
        "name": "Rectangular Polyline",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2900,
        "tags": [
            "constructive algorithms",
            "dp",
            "geometry"
        ]
    },
    "author": {
        "contestId": 1444,
        "members": [
            {
                "handle": "galen_colin"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1604228700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 42,
    "timeConsumedMillis": 217,
    "memoryConsumedBytes": 154009600,
    "source": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n \r\n// #pragma GCC optimize(\"O3,unroll-loops\")\r\n// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n \r\n/* \r\nfind my code templates at https://github.com/galencolin/cp-templates\r\nalso maybe subscribe please thanks \r\n*/\r\n \r\n#define send {ios_base::sync_with_stdio(false);}\r\n#define help {cin.tie(NULL);}\r\n#define f first\r\n#define s second\r\n#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}\r\n \r\nusing ll = long long;\r\n// using ll = int;\r\n// #pragma warning(\"int\")\r\n//\r\nusing vl = vector<ll>;\r\n \r\ntypedef long double ld;\r\ntypedef unsigned long long ull;\r\n \r\n#include <ext/pb_ds/assoc_container.hpp> \r\n#include <ext/pb_ds/tree_policy.hpp>\r\n \r\nusing namespace std;\r\nusing namespace __gnu_pbds; \r\n \r\ntemplate <typename num_t>\r\nusing ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;\r\n \r\n// benq - print any container + pair\r\ntemplate<typename T, typename = void> struct is_iterable : false_type {};\r\ntemplate<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};\r\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);\r\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\r\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {\r\n\tcout << \"[\"; \r\n\tfor (auto it = v.begin(); it != v.end();) {\r\n\t\tcout << *it;\r\n\t\tif (++it != v.end()) cout << \", \";\r\n\t}\r\n\treturn cout << \"]\";\r\n}\r\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\r\n\tcin >> p.first;\r\n\treturn cin >> p.second;\r\n}\r\n\r\ntemplate<typename T> void debug(string s, T x) {cerr << \"\\033[1;34m\" << s << \"\\033[0;32m = \\033[35m\" << x << \"\\033[0m\\n\";}\r\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) {for (int i=0, b=0; i<(int)s.size(); i++) if (s[i] == '(' || s[i] == '{') b++; else\r\n        if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {cerr << \"\\033[1;34m\" << s.substr(0, i) << \"\\033[0;32m = \\033[35m\" << x << \"\\033[31m | \"; debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}\r\ntemplate<typename T> void debug_nameless(T x) {cerr << \"\\033[35m\" << x << \"\\033[0m\\n\";}\r\ntemplate<typename T, typename... Args> void debug_nameless(T x, Args... args) {cerr << \"\\033[35m\" << x << \"\\033[31m | \"; debug_nameless(args...);}\r\n\r\n#ifdef galen_colin_local\r\n#define pr(...) debug(#__VA_ARGS__, __VA_ARGS__)\r\n#define prs(...) debug_nameless(__VA_ARGS__)\r\nconst bool local_ = true;\r\n#else\r\n#define pr(...) 135\r\n#define prs(...) 135\r\nconst bool local_ = false;\r\n#endif\r\n \r\nmt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\r\n// mt19937_64 rng(61378913);\r\n/* usage - just do rng() */\r\n \r\nvoid usaco(string filename) {\r\n  // #pragma message(\"be careful, freopen may be wrong\")\r\n\tfreopen((filename + \".in\").c_str(), \"r\", stdin);\r\n\tfreopen((filename + \".out\").c_str(), \"w\", stdout);\r\n}\r\n \r\n// #include <atcoder/all>\r\n// using namespace atcoder;\r\n \r\nconst ld pi = 3.14159265358979323846;\r\n// const ll mod = 1000000007;\r\nconst ll mod = 998244353;\r\n// ll mod;\r\n\r\n\r\n\r\nll n, m, q, k, l, r, x, y, z;\r\nconst ll template_array_size = 1e6 + 141141;\r\nll a[template_array_size];\r\nll b[template_array_size];\r\nll c[template_array_size];\r\nstring s, t;\r\n\r\nbool dp[505][250005];\r\n\r\npair<vl, vl> find(ll n, ll *a) {\r\n\tll s = 0;\r\n\tfor (ll i = 0; i < n; i++) s += a[i];\r\n\tif (s % 2 == 1) return {{}, {}};\r\n\ts /= 2;\r\n\r\n\tfor (ll i = 0; i <= n; i++) for (ll j = 0; j <= s; j++) dp[i][j] = 0;\r\n\tdp[0][0] = 1;\r\n\tfor (ll i = 0; i < n; i++) {\r\n\t\tfor (ll j = 0; j <= s; j++) {\r\n\t\t\tif (dp[i][j]) {\r\n\t\t\t\tdp[i + 1][j] = 1;\r\n\t\t\t\tif (j + a[i] <= s) dp[i + 1][j + a[i]] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (!dp[n][s]) return {{}, {}};\r\n\r\n\tvl x, y;\r\n\tfor (ll i = n; i > 0; i--) {\r\n\t\tif (dp[i - 1][s]) {\r\n\t\t\tx.push_back(a[i - 1]);\r\n\t\t} else {\r\n\t\t\ts -= a[i - 1];\r\n\t\t\ty.push_back(a[i - 1]);\r\n\t\t}\r\n\t}\r\n\treturn {x, y};\r\n}\r\n\r\nvoid solve(int tc = 0) { pr(tc); prs(string(50, '-'));\r\n\t\r\n\tcin >> n;\r\n\tfor (ll i = 0; i < n; i++) cin >> a[i];\r\n\tcin >> m;\r\n\tfor (ll i = 0; i < m; i++) cin >> b[i];\r\n\r\n\tif (n != m) {\r\n\t\tcout << \"No\\n\";\r\n\t\treturn;\r\n\t}\r\n\r\n\tauto av = find(n, a);\r\n\tauto bv = find(m, b);\r\n\r\n\tif ((av.f.empty() && av.s.empty()) || (bv.f.empty() && bv.s.empty())) {\r\n\t\tcout << \"No\\n\";\r\n\t\treturn;\r\n\t}\r\n\r\n\tpair<vl, vl> cv; // (h, v)\r\n\r\n\tsort(av.f.rbegin(), av.f.rend());\r\n\tsort(av.s.rbegin(), av.s.rend());\r\n\tsort(bv.f.begin(), bv.f.end());\r\n\tsort(bv.s.begin(), bv.s.end());\r\n\r\n\tif (av.f.size() > bv.f.size()) swap(av.f, av.s), swap(bv.f, bv.s);\r\n\r\n\twhile (av.f.size() < bv.f.size()) {\r\n\t\tcv.f.push_back(av.s.back());\r\n\t\tav.s.pop_back();\r\n\t\tcv.s.push_back(bv.f.back());\r\n\t\tbv.f.pop_back();\r\n\t}\r\n\tassert(av.f.size() == bv.f.size());\r\n\tassert(av.s.size() == bv.s.size());\r\n\tassert(cv.f.size() == cv.s.size());\r\n\r\n\tcout << \"Yes\\n\";\r\n\tll x = 0, y = 0;\r\n\r\n\tfor (ll i = 0; i < av.f.size(); i++) {\r\n\t\tx += av.f[i];\r\n\t\tcout << x << \" \" << y << '\\n';\r\n\t\ty += bv.f[i];\r\n\t\tcout << x << \" \" << y << '\\n';\r\n\t}\r\n\r\n\tfor (ll i = 0; i < cv.f.size(); i++) {\r\n\t\tx -= cv.f[i];\r\n\t\tcout << x << \" \" << y << '\\n';\r\n\t\ty += cv.s[i];\r\n\t\tcout << x << \" \" << y << '\\n';\r\n\t}\r\n\r\n\tfor (ll i = 0; i < av.s.size(); i++) {\r\n\t\tx -= av.s[i];\r\n\t\tcout << x << \" \" << y << '\\n';\r\n\t\ty -= bv.s[i];\r\n\t\tcout << x << \" \" << y << '\\n';\r\n\t}\r\n\r\n\tpr(av, bv, cv);\r\n\r\nprs(string(50, '-') + \"\\n\");}\r\n\r\nint main() {\r\n\t#ifdef galen_colin_local\r\n\t\tauto begin = std::chrono::high_resolution_clock::now();\r\n\t#endif\r\n\t\r\n\tsend help\r\n \r\n\t#ifndef galen_colin_local\r\n\t\t// usaco(\"evacuation\");\r\n\t#endif\r\n\t\r\n\t// usaco(\"cowland\");\r\n\t\r\n\t// freopen(\"tc.cpp\", \"r\", stdin);\r\n\t// freopen(\"tc2.cpp\", \"w\", stdout);\r\n\t// freopen(\"in.txt\", \"r\", stdin);\r\n\t// freopen(\"out.txt\", \"w\", stdout);\r\n\t\t\r\n\tcout << setprecision(15) << fixed;\r\n \r\n\r\n\t\t\r\n\tint tc = 1;\r\n\tcin >> tc;\r\n\tfor (int t = 0; t < tc; t++) {\r\n\t\tsolve(t);\r\n\t}\r\n\t\r\n\t#ifdef galen_colin_local\r\n\t\tauto end = std::chrono::high_resolution_clock::now();\r\n\t\tcerr << setprecision(4) << fixed;\r\n\t\tcerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;\r\n\t#endif\r\n}"
}