{
    "id": 219133444,
    "contestId": 1444,
    "creationTimeSeconds": 1692200516,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1444,
        "index": "D",
        "name": "Rectangular Polyline",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2900,
        "tags": [
            "constructive algorithms",
            "dp",
            "geometry"
        ]
    },
    "author": {
        "contestId": 1444,
        "members": [
            {
                "handle": "Mirali7"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1604228700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 13,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 15872000,
    "source": "\ufeff#include <iostream>\r\n#include <string>\r\n#include <deque>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <map>\r\n#include <set>\r\n#include <queue>\r\n#include <fstream>\r\n#include <stack>\r\n#include <cmath>\r\n#include <bitset>\r\n#include <unordered_set>\r\n#include <unordered_map>\r\n#include <random>\r\n#include <array>\r\n#include <chrono>\r\n#include <functional>\r\n#include <numeric>\r\n#include <complex>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define ld long double\r\n#define ull uint64_t\r\n#define pll pair<ll, ll>\r\n#define pii pair<int, int>\r\n#define pli pair<ll, int>\r\n#define fst first\r\n#define snd second\r\n\r\n#define forn(i, n) for (int i = 1; i <= n; i++)\r\n#define dforn(i, a, b) for (int i = a; i <= b; i++) \r\n#define rforn(i, n) for (int i = n; i >= 1; i--)\r\n#define rdforn(i, a, b) for (int i = b; i >= a; i--)\r\n#define sforn(i, a, b, s) for (ll i = a; i <= b; i += s)\r\n#define aforn(v, a) for (auto& v : a)\r\n\r\nconst int mod = 998244353;\r\nconst ld pi = acos(-1);\r\nconst ll N = 250000;\r\nconst ll inf = 1e17;\r\nconst int iinf = 1 << 30;\r\nconst ld dinf = 1e10;\r\nconst double eps = 1e-10;\r\n\r\nstruct custom_bitset {\r\n    vector<uint64_t> bits;\r\n    int64_t b, n;\r\n\r\n    custom_bitset(int64_t _b = 0) {\r\n        init(_b);\r\n    }\r\n\r\n    void init(int64_t _b) {\r\n        b = _b;\r\n        n = (b + 63) / 64;\r\n        bits.assign(n, 0);\r\n    }\r\n\r\n    void clear() {\r\n        b = n = 0;\r\n        bits.clear();\r\n    }\r\n\r\n    void reset() {\r\n        bits.assign(n, 0);\r\n    }\r\n\r\n    void _clean() {\r\n        if (b != 64 * n)\r\n            bits.back() &= (1LLU << (b - 64 * (n - 1))) - 1;\r\n    }\r\n\r\n    bool get(int64_t index) const {\r\n        return bits[index / 64] >> (index % 64) & 1;\r\n    }\r\n\r\n    void set(int64_t index, bool value) {\r\n        bits[index / 64] &= ~(1LLU << (index % 64));\r\n        bits[index / 64] |= uint64_t(value) << (index % 64);\r\n    }\r\n\r\n    void or_shift(int64_t shift) {\r\n        int64_t div = shift / 64, mod = shift % 64;\r\n\r\n        if (mod == 0) {\r\n            for (int64_t i = n - 1; i >= div; i--)\r\n                bits[i] |= bits[i - div];\r\n\r\n            return;\r\n        }\r\n\r\n        for (int64_t i = n - 1; i >= div + 1; i--)\r\n            bits[i] |= bits[i - (div + 1)] >> (64 - mod) | bits[i - div] << mod;\r\n\r\n        if (div < n)\r\n            bits[div] |= bits[0] << mod;\r\n\r\n        _clean();\r\n    }\r\n\r\n    void or_shift_down(int64_t shift) {\r\n        int64_t div = shift / 64, mod = shift % 64;\r\n\r\n        if (mod == 0) {\r\n            for (int64_t i = div; i < n; i++)\r\n                bits[i - div] |= bits[i];\r\n\r\n            return;\r\n        }\r\n\r\n        for (int64_t i = 0; i < n - (div + 1); i++)\r\n            bits[i] |= bits[i + (div + 1)] << (64 - mod) | bits[i + div] >> mod;\r\n\r\n        if (div < n)\r\n            bits[n - div - 1] |= bits[n - 1] >> mod;\r\n\r\n        _clean();\r\n    }\r\n\r\n    custom_bitset& operator&=(const custom_bitset& other) {\r\n        for (int i = 0; i < n; i++)\r\n            bits[i] &= other.bits[i];\r\n\r\n        return *this;\r\n    }\r\n};\r\n\r\nvoid solve() {\r\n    int n, m, sum1 = 0, sum2 = 0;\r\n    cin >> n;\r\n    vector<int> v1(n + 1);\r\n    forn(i, n) {\r\n        cin >> v1[i];\r\n        sum1 += v1[i];\r\n    }\r\n    cin >> m;\r\n    vector<int> v2(m + 1);\r\n    forn(i, m) {\r\n        cin >> v2[i];\r\n        sum2 += v2[i];\r\n    }\r\n    if (n != m || sum1 % 2 == 1 || sum2 % 2 == 1) {\r\n        cout << \"No\" << '\\n';\r\n        return;\r\n    }\r\n    sum1 >>= 1;\r\n    sum2 >>= 1;\r\n    vector<int> r, l, u, d;\r\n    vector<bool> nused(n + 1), mused(m + 1);\r\n    vector<custom_bitset> dp1(1, custom_bitset(N + 1)), dp2(1, custom_bitset(N + 1));\r\n    dp1[0].set(0, 1);\r\n    bool f = false;\r\n    forn(i, n) {\r\n        dp1.push_back(dp1.back());\r\n        dp1.back().or_shift(v1[i]);\r\n        if (dp1.back().get(sum1)) {\r\n            ll pos = i, csum = sum1;\r\n            while (pos) {\r\n                if (csum - v1[pos] >= 0 && dp1[pos - 1].get(csum - v1[pos])) {\r\n                    nused[pos] = true;\r\n                    csum -= v1[pos];\r\n                }\r\n                pos--;\r\n            }\r\n            f = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!f) {\r\n        cout << \"No\" << '\\n';\r\n        return;\r\n    }\r\n    f = false;\r\n    dp2[0].set(0, 1);\r\n    forn(i, m) {\r\n        dp2.push_back(dp2.back());\r\n        dp2.back().or_shift(v2[i]);\r\n        if (dp2.back().get(sum2)) {\r\n            ll pos = i, csum = sum2;\r\n            while (pos) {\r\n                if (csum - v2[pos] >= 0 && dp2[pos - 1].get(csum - v2[pos])) {\r\n                    mused[pos] = true;\r\n                    csum -= v2[pos];\r\n                }\r\n                pos--;\r\n            }\r\n            f = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!f) {\r\n        cout << \"No\" << '\\n';\r\n        return;\r\n    }\r\n    forn(i, n) {\r\n        if (nused[i]) {\r\n            r.push_back(v1[i]);\r\n        }\r\n        else {\r\n            l.push_back(v1[i]);\r\n        }\r\n    }\r\n    forn(i, m) {\r\n        if (mused[i]) {\r\n            u.push_back(v2[i]);\r\n        }\r\n        else {\r\n            d.push_back(v2[i]);\r\n        }\r\n    }\r\n    if (r.size() > l.size()) {\r\n        swap(r, l);\r\n    }\r\n    if (d.size() > u.size()) {\r\n        swap(u, d);\r\n    }\r\n    vector<pii> nv1, nv2, nv3;\r\n    dforn(i, 0, r.size() - 1) {\r\n        nv1.push_back({ r[i], u[i] });\r\n    }\r\n    dforn(i, 0, d.size() - 1) {\r\n        nv2.push_back({ -l[i], -d[i] });\r\n    }\r\n    dforn(i, d.size(), l.size() - 1) {\r\n        nv3.push_back({ -l[i], u[i - r.size() + d.size()]});\r\n    }\r\n    sort(nv1.begin(), nv1.end(), [&](pii x, pii y) {return atan2(x.snd, x.fst) < atan2(y.snd, y.fst); });\r\n    sort(nv2.begin(), nv2.end(), [&](pii x, pii y) {return atan2(x.snd, x.fst) < atan2(y.snd, y.fst); });\r\n    cout << \"Yes\" << '\\n';\r\n    int x = 0, y = 0;\r\n    aforn(p, nv1) {\r\n        x += p.fst;\r\n        cout << x << \" \" << y << '\\n';\r\n        y += p.snd;\r\n        cout << x << \" \" << y << '\\n';\r\n    }\r\n    aforn(p, nv3) {\r\n        x += p.fst;\r\n        cout << x << \" \" << y << '\\n';\r\n        y += p.snd;\r\n        cout << x << \" \" << y << '\\n';\r\n    }\r\n    aforn(p, nv2) {\r\n        x += p.fst;\r\n        cout << x << \" \" << y << '\\n';\r\n        y += p.snd;\r\n        cout << x << \" \" << y << '\\n';\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\tint t = 1;\r\n\tcin >> t;\r\n\twhile (t--) solve();\r\n\treturn 0;\r\n}"
}