{
    "id": 235276309,
    "contestId": 1251,
    "creationTimeSeconds": 1701457540,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1251,
        "index": "F",
        "name": "Red-White Fence",
        "type": "PROGRAMMING",
        "rating": 2500,
        "tags": [
            "combinatorics",
            "fft"
        ]
    },
    "author": {
        "contestId": 1251,
        "members": [
            {
                "handle": "qualdoom"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571929500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 107,
    "timeConsumedMillis": 4851,
    "memoryConsumedBytes": 51916800,
    "source": "#include \"bits/stdc++.h\"\r\n\r\nusing namespace std;\r\n\r\n#define sz(v) ((int)(v).size())\r\n#define all(a) (a).begin(), (a).end()\r\n#define rall(a) a.rbegin(), (a).rend()\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define eb emplace_back\r\n#define time ((double)clock() / (double)CLOCKS_PER_SEC)\r\n\r\nusing pii = pair<int, int>;\r\nusing ll = long long;\r\nusing int64 = long long;\r\nusing ld = double;\r\n\r\nconst ll infll = (ll) 1e18 + 27;\r\nconst ll inf = (ll) 1e9;\r\n\r\ntemplate<class T>\r\nusing pq = priority_queue<T, vector<T>, less<T>>;\r\ntemplate<class T>\r\nusing pqr = priority_queue<T, vector<T>, greater<T>>;\r\n\r\ntemplate<typename T, typename T2>\r\nistream &operator>>(istream &in, pair<T, T2> &b) {\r\n    in >> b.first >> b.second;\r\n    return in;\r\n}\r\n\r\ntemplate<typename T, typename T2>\r\nostream &operator<<(ostream &out, const pair<T, T2> &b) {\r\n    out << \"{\" << b.first << \", \" << b.second << \"}\";\r\n    return out;\r\n}\r\n\r\ntemplate<typename T>\r\nistream &operator>>(istream &in, vector<T> &b) {\r\n    for (auto &v : b) {\r\n        in >> v;\r\n    }\r\n    return in;\r\n}\r\n\r\ntemplate<typename T>\r\nostream &operator<<(ostream &out, vector<T> &b) {\r\n    for (auto &v : b) {\r\n        out << v << ' ';\r\n    }\r\n    return out;\r\n}\r\n\r\ntemplate<typename T>\r\nostream &operator<<(ostream &out, deque<T> &b) {\r\n    for (auto &v : b) {\r\n        out << v << ' ';\r\n    }\r\n    return out;\r\n}\r\n\r\ntemplate<typename T>\r\nvoid print(T x, string end = \"\\n\") {\r\n    cout << x << end;\r\n}\r\n\r\n\r\ntemplate<typename T1, typename T2>\r\nbool chkmin(T1 &x, const T2 &y) { return x > y && (x = y, true); }\r\n\r\ntemplate<typename T1, typename T2>\r\nbool chkmax(T1 &x, const T2 &y) { return x < y && (x = y, true); }\r\n\r\n#ifdef LOCAL\r\n#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\r\n#else\r\n#define eprintf(...) 42\r\n#endif\r\n\r\nusing uint = unsigned int;\r\nusing ull = unsigned long long;\r\n\r\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nll myRand(ll B) {\r\n    return (ull)rng() % B;\r\n}\r\n\r\nconst uint MOD = 998244353;\r\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\r\n    uint x;\r\n\r\n    mint() : x(0) {}\r\n    mint(ll _x) {\r\n        _x %= mod;\r\n        if (_x < 0) _x += mod;\r\n        x = _x;\r\n    }\r\n\r\n    mint& operator += (const mint &a) {\r\n        x += a.x;\r\n        if (x >= mod) x -= mod;\r\n        return *this;\r\n    }\r\n    mint& operator -= (const mint &a) {\r\n        x += mod - a.x;\r\n        if (x >= mod) x -= mod;\r\n        return *this;\r\n    }\r\n    mint& operator *= (const mint &a) {\r\n        x = (ull)x * a.x % mod;\r\n        return *this;\r\n    }\r\n    mint pow(ll pw) const {\r\n        mint res = 1;\r\n        mint cur = *this;\r\n        while(pw) {\r\n            if (pw & 1) res *= cur;\r\n            cur *= cur;\r\n            pw >>= 1;\r\n        }\r\n        return res;\r\n    }\r\n    mint inv() const {\r\n        assert(x != 0);\r\n        uint t = x;\r\n        uint res = 1;\r\n        while(t != 1) {\r\n            uint z = mod / t;\r\n            res = (ull)res * (mod - z) % mod;\r\n            t = mod - t * z;\r\n        }\r\n        return res;\r\n    }\r\n    mint& operator /= (const mint &a) {\r\n        return *this *= a.inv();\r\n    }\r\n    mint operator + (const mint &a) const {\r\n        return mint(*this) += a;\r\n    }\r\n    mint operator - (const mint &a) const {\r\n        return mint(*this) -= a;\r\n    }\r\n    mint operator * (const mint &a) const {\r\n        return mint(*this) *= a;\r\n    }\r\n    mint operator / (const mint &a) const {\r\n        return mint(*this) /= a;\r\n    }\r\n\r\n    bool sqrt(mint &res) const {\r\n        if (mod == 2 || x == 0) {\r\n            res = *this;\r\n            return true;\r\n        }\r\n        if (pow((mod - 1) / 2) != 1) return false;\r\n        if (mod % 4 == 3) {\r\n            res = pow((mod + 1) / 4);\r\n            return true;\r\n        }\r\n        int pw = (mod - 1) / 2;\r\n        int K = 30;\r\n        while((1 << K) > pw) K--;\r\n        while(true) {\r\n            mint t = myRand(mod);\r\n            mint a = 0, b = 0, c = 1;\r\n            for (int k = K; k >= 0; k--) {\r\n                a = b * b;\r\n                b = b * c * 2;\r\n                c = c * c + a * *this;\r\n                if (((pw >> k) & 1) == 0) continue;\r\n                a = b;\r\n                b = b * t + c;\r\n                c = c * t + a * *this;\r\n            }\r\n            if (b == 0) continue;\r\n            c -= 1;\r\n            c *= mint() - b.inv();\r\n            if (c * c == *this) {\r\n                res = c;\r\n                return true;\r\n            }\r\n        }\r\n        assert(false);\r\n    }\r\n\r\n    bool operator == (const mint &a) const {\r\n        return x == a.x;\r\n    }\r\n    bool operator != (const mint &a) const {\r\n        return x != a.x;\r\n    }\r\n    bool operator < (const mint &a) const {\r\n        return x < a.x;\r\n    }\r\n};\r\ntemplate<uint mod = MOD> struct Factorials {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> f, fi;\r\n\r\n    Factorials() : f(), fi() {}\r\n    Factorials(int n) {\r\n        n += 10;\r\n        f = vector<Mint>(n);\r\n        fi = vector<Mint>(n);\r\n        f[0] = 1;\r\n        for (int i = 1; i < n; i++)\r\n            f[i] = f[i - 1] * i;\r\n        fi[n - 1] = f[n - 1].inv();\r\n        for (int i = n - 1; i > 0; i--)\r\n            fi[i - 1] = fi[i] * i;\r\n    }\r\n\r\n    Mint C(int n, int k) {\r\n        if (k < 0 || k > n) return 0;\r\n        return f[n] * fi[k] * fi[n - k];\r\n    }\r\n};\r\ntemplate<uint mod = MOD> struct Powers {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> p, pi;\r\n\r\n    Powers() : p(), pi() {}\r\n    Powers(int n, Mint x) {\r\n        n += 10;\r\n        if (x == 0) {\r\n            p = vector<Mint>(n);\r\n            p[0] = 1;\r\n        } else {\r\n            p = vector<Mint>(n);\r\n            pi = vector<Mint>(n);\r\n            p[0] = pi[0] = 1;\r\n            Mint xi = x.inv();\r\n            for (int i = 1; i < n; i++) {\r\n                p[i] = p[i - 1] * x;\r\n                pi[i] = pi[i - 1] * xi;\r\n            }\r\n        }\r\n    }\r\n\r\n    Mint pow(int n) {\r\n        if (n >= 0)\r\n            return p[n];\r\n        else\r\n            return pi[-n];\r\n    }\r\n};\r\ntemplate<uint mod = MOD> struct Inverses {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> ii;\r\n\r\n    Inverses() : ii() {}\r\n    Inverses(int n) {\r\n        n += 10;\r\n        ii = vector<Mint>(n);\r\n        ii[1] = 1;\r\n        for (int x = 2; x < n; x++)\r\n            ii[x] = Mint() - ii[mod % x] * (mod / x);\r\n    }\r\n\r\n    Mint inv(Mint x) {\r\n        assert(x != 0);\r\n        uint t = x.x;\r\n        uint res = 1;\r\n        while(t >= (int)ii.size()) {\r\n            uint z = mod / t;\r\n            res = (ull)res * (mod - z) % mod;\r\n            t = mod - t * z;\r\n        }\r\n        return ii[t] * res;\r\n    }\r\n};\r\nusing Mint = mint<>;\r\n\r\nconst int LOG = 20; // CHECK!!!!\r\nPowers<> W;\r\nvector<int> binRev;\r\nvoid initFFT() {\r\n    binRev = vector<int>((1 << LOG) + 3, 0);\r\n    Mint w = 2;\r\n    while(true) {\r\n        Mint x = w;\r\n        for (int i = 1; i < LOG; i++)\r\n            x *= x;\r\n        if (x == -1) break;\r\n        w += 1;\r\n    }\r\n    W = Powers<>(1 << LOG, w);\r\n    for (int mask = 1; mask < (1 << LOG); mask++) {\r\n        binRev[mask] = (binRev[mask >> 1] >> 1) ^ ((mask & 1) << (LOG - 1));\r\n    }\r\n}\r\n\r\ntemplate<unsigned mod = MOD> struct Poly {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> a;\r\n\r\n    Poly() : a() {}\r\n    Poly(vector<Mint> _a) {\r\n        a = _a;\r\n        while(!a.empty() && a.back() == 0) a.pop_back();\r\n    }\r\n\r\n    void print(int n = -1) {\r\n        if (n == -1) n = (int)a.size();\r\n        for (int i = 0; i < n; i++)\r\n            printf(\"%u \", at(i).x);\r\n        printf(\"\\n\");\r\n    }\r\n    void eprint() {\r\n        eprintf(\"[\");\r\n        for (int i = 0; i < (int)a.size(); i++)\r\n            eprintf(\"%u \", a[i].x);\r\n        eprintf(\"]\\n\");\r\n    }\r\n\r\n    static void fft(vector<Mint> &A) {\r\n        int L = (int)A.size();\r\n        assert((L & (L - 1)) == 0);\r\n        int k = 0;\r\n        while((1 << k) < L) k++;\r\n        for (int i = 0; i < L; i++) {\r\n            int x = binRev[i] >> (LOG - k);\r\n            if (i < x) swap(A[i], A[x]);\r\n        }\r\n        for (int lvl = 0; lvl < k; lvl++) {\r\n            int len = 1 << lvl;\r\n            for (int st = 0; st < L; st += (len << 1))\r\n                for (int i = 0; i < len; i++) {\r\n                    Mint x = A[st + i], y = A[st + len + i] * W.pow(i << (LOG - 1 - lvl));\r\n                    A[st + i] = x + y;\r\n                    A[st + len + i] = x - y;\r\n                }\r\n        }\r\n    }\r\n\r\n    Mint& operator [] (const int i) {\r\n        assert(0 <= i && i <= deg());\r\n        return a[i];\r\n    }\r\n    Mint at(const int i) const {\r\n        if (i < 0 || i > deg()) return 0;\r\n        return a[i];\r\n    }\r\n    int deg() const { // deg of polynomial 0 is -1\r\n        return (int)a.size() - 1;\r\n    }\r\n    Mint eval(const Mint &x) const {\r\n        Mint res = 0;\r\n        for (int i = deg(); i >= 0; i--)\r\n            res = res * x + a[i];\r\n        return res;\r\n    }\r\n    Poly substr(const int &l, const int &r) const {\r\n        vector<Mint> f(r - l);\r\n        for (int i = l; i < r; i++)\r\n            f[i - l] = at(i);\r\n        return f;\r\n    }\r\n\r\n    Poly& operator += (const Poly &A) {\r\n        if (deg() < A.deg()) a.resize(A.a.size());\r\n        for (int i = 0; i <= A.deg(); i++)\r\n            a[i] += A.a[i];\r\n        while(!a.empty() && a.back() == 0) a.pop_back();\r\n        return *this;\r\n    }\r\n    Poly& operator -= (const Poly &A) {\r\n        if (deg() < A.deg()) a.resize(A.a.size());\r\n        for (int i = 0; i <= A.deg(); i++)\r\n            a[i] -= A.a[i];\r\n        while(!a.empty() && a.back() == 0) a.pop_back();\r\n        return *this;\r\n    }\r\n    Poly& operator *= (const Mint &k) {\r\n        if (k == 0) a.clear();\r\n        for (Mint &x : a) x *= k;\r\n        return *this;\r\n    }\r\n    Poly& operator /= (const Mint &k) {\r\n        Mint ki = k.inv();\r\n        for (Mint &x : a) x *= ki;\r\n        return *this;\r\n    }\r\n    Poly operator + (const Poly &A) const {\r\n        return Poly(*this) += A;\r\n    }\r\n    Poly operator - (const Poly &A) const {\r\n        return Poly(*this) -= A;\r\n    }\r\n    Poly operator * (const Mint &k) const {\r\n        return Poly(*this) *= k;\r\n    }\r\n    Poly operator / (const Mint &k) const {\r\n        return Poly(*this) /= k;\r\n    }\r\n\r\n    Poly& operator *= (const Poly &A) {\r\n        if (a.empty() || A.a.empty()) {\r\n            a.clear();\r\n            return *this;\r\n        }\r\n        int nd = deg() + A.deg();\r\n\r\n        if (deg() < LOG || A.deg() < LOG) {\r\n            vector<Mint> res(nd + 1, 0);\r\n            for (int i = 0; i <= deg(); i++)\r\n                for (int j = 0; j <= A.deg(); j++)\r\n                    res[i + j] += a[i] * A.a[j];\r\n            return *this = Poly(res);\r\n        }\r\n\r\n        int k = 0;\r\n        while((1 << k) <= nd) k++;\r\n        int L = 1 << k;\r\n        vector<Mint> f = a, g = A.a;\r\n        f.resize(L, 0);\r\n        g.resize(L, 0);\r\n        fft(f);\r\n        fft(g);\r\n        for (int i = 0; i < L; i++)\r\n            f[i] *= g[i];\r\n        fft(f);\r\n        reverse(f.begin() + 1, f.end());\r\n        return *this = (Poly(f) / L);\r\n    }\r\n    Poly operator * (const Poly &A) const {\r\n        return Poly(*this) *= A;\r\n    }\r\n\r\n    Poly inv(int n) const {\r\n        assert(deg() >= 0 && at(0) != 0);\r\n        if (n <= 0) return Poly();\r\n        vector<Mint> res(n);\r\n        res[0] = a[0].inv();\r\n        vector<Mint> f, g;\r\n        for (int L = 1; L < n; L <<= 1) {\r\n            f = vector<Mint>(2 * L);\r\n            g = vector<Mint>(2 * L);\r\n            for (int i = 0; i < 2 * L && i <= deg(); i++)\r\n                f[i] = a[i];\r\n            for (int i = 0; i < L; i++)\r\n                g[i] = res[i];\r\n            fft(f);\r\n            fft(g);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            for (int i = 0; i < L; i++)\r\n                f[i] = 0;\r\n            for (int i = L; i < 2 * L; i++)\r\n                f[i] = Mint() - f[i];\r\n            fft(f);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Mint Li = Mint(2 * L).inv();\r\n            Li *= Li;\r\n            for (int i = L; i < 2 * L && i < n; i++)\r\n                res[i] = f[i] * Li;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static vector<Mint> div_stupid(vector<Mint> A, vector<Mint> B) {\r\n        int n = (int)A.size(), m = (int)B.size();\r\n        Mint Bi = B.back().inv();\r\n        for (auto &x : B) x *= Bi;\r\n        vector<Mint> C(n - m + 1);\r\n        for (int i = n; i >= m; i--) {\r\n            C[i - m] = A[i - 1] * Bi;\r\n            for (int j = 0; j < m; j++)\r\n                A[i - m + j] -= B[j] * A[i - 1];\r\n        }\r\n        return C;\r\n    }\r\n    Poly& operator /= (const Poly &A) {\r\n        int d1 = deg(), d2 = A.deg();\r\n        assert(d2 >= 0);\r\n        if (d1 < d2) return *this = Poly();\r\n        if (d2 < 4 * LOG || d1 - d2 < 4 * LOG)\r\n            return *this = div_stupid(a, A.a);\r\n        vector<Mint> f = a, g = A.a;\r\n        reverse(all(f));\r\n        reverse(all(g));\r\n        Poly H = Poly(vector<Mint>(f.begin(), f.begin() + d1 - d2 + 1)) * Poly(g).inv(d1 - d2 + 1);\r\n        vector<Mint> t = vector<Mint>(H.a.begin(), H.a.begin() + d1 - d2 + 1);\r\n        reverse(all(t));\r\n        return *this = t;\r\n    }\r\n    Poly operator / (const Poly &A) const {\r\n        return Poly(*this) /= A;\r\n    }\r\n    Poly& operator %= (const Poly &A) {\r\n        assert(A.deg() >= 0);\r\n        if (deg() < A.deg()) return *this;\r\n        return *this -= A * (*this / A);\r\n    }\r\n    Poly operator % (const Poly &A) const {\r\n        return Poly(*this) %= A;\r\n    }\r\n\r\n    Poly derivate() const {\r\n        int n = deg();\r\n        if (n <= 0) return Poly();\r\n        vector<Mint> f(n);\r\n        for (int i = 0; i < n; i++)\r\n            f[i] = a[i + 1] * (i + 1);\r\n        return f;\r\n    }\r\n    Poly integrate() const {\r\n        int n = deg();\r\n        if (n < 0) return Poly();\r\n        n += 2;\r\n        vector<Mint> f(n);\r\n        Inverses<> I = Inverses<>(n);\r\n        for (int i = 1; i < n; i++)\r\n            f[i] = a[i - 1] * I.inv(i);\r\n        return f;\r\n    }\r\n    Poly log(int n) const {\r\n        if (n <= 1) return Poly();\r\n        assert(deg() >= 0 && at(0) == 1);\r\n        return (derivate() * inv(n)).substr(0, n - 1).integrate();\r\n    }\r\n    Poly exp(int n) const {\r\n        if (n <= 0) return Poly();\r\n        if (deg() < 0) return Poly({1});\r\n        assert(at(0) == 0);\r\n        vector<Mint> res(n);\r\n        res[0] = 1;\r\n        vector<Mint> f, g;\r\n        for (int L = 1; L < n; L <<= 1) {\r\n            f = vector<Mint>(2 * L);\r\n            g = vector<Mint>(2 * L);\r\n            Poly LG = Poly(vector<Mint>(res.begin(), res.begin() + L)).log(2 * L);\r\n            for (int i = 0; i < L; i++)\r\n                assert(at(i) == LG.at(i));\r\n            for (int i = 0; i < L; i++) {\r\n                f[i] = res[i];\r\n                g[i] = at(L + i) - LG.at(L + i);\r\n            }\r\n            fft(f);\r\n            fft(g);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Mint Li = Mint(2 * L).inv();\r\n            for (int i = L; i < 2 * L && i < n; i++)\r\n                res[i] = f[i - L] * Li;\r\n        }\r\n        return res;\r\n    }\r\n    Poly sqr(int n) const {\r\n        return (*this * *this).substr(0, n);\r\n    }\r\n    Poly pow_(Mint k, int n) const { // k can be non-negative rational (k = 1/2 is sqrt), but assert(a[0] == 1);\r\n        if (deg() < 0 || n <= 0) return Poly();\r\n        return (log(n) * k).exp(n);\r\n    }\r\n    Poly pow(ll k, int n) const { // k is non-negative integer\r\n        if (n <= 0) return Poly();\r\n        if (k == 0) return Poly({1});\r\n        if (k == 1) return substr(0, n);\r\n        if (k == 2) return sqr(n);\r\n        if (k < LOG) {\r\n            Poly cur = substr(0, n);\r\n            Poly res = Poly({1});\r\n            while(k) {\r\n                if (k & 1) res = (res * cur).substr(0, n);\r\n                cur = cur.sqr(n);\r\n                k >>= 1;\r\n            }\r\n            return res;\r\n        }\r\n        int z = 0;\r\n        while(z * k < n && at(z) == 0) z++;\r\n        if (z * k >= n) return Poly();\r\n        Poly A = substr(z, z + n - z * k);\r\n        Mint cf = A[0].pow(k);\r\n        A /= A[0];\r\n        A = A.pow_(k, n - z * k) * cf;\r\n        return A.substr(-z * k, n - z * k);\r\n    }\r\n    Poly sqrt_(int n) const {\r\n        if (deg() < 0 || n <= 0) return Poly();\r\n        assert(at(0) == 1);\r\n//      return pow_(Mint(2).inv(), n);\r\n        vector<Mint> res(n);\r\n        res[0] = 1;\r\n        vector<Mint> f, g;\r\n        for (int L = 1; L < n; L <<= 1) {\r\n            f = vector<Mint>(2 * L);\r\n            g = vector<Mint>(2 * L);\r\n            for (int i = 0; i < L; i++)\r\n                f[i] = res[i];\r\n            fft(f);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= f[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Mint Li = Mint(2 * L).inv();\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= Li;\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] = at(i) - f[i];\r\n            for (int i = 0; i < L; i++)\r\n                assert(f[i] == 0);\r\n            for (int i = 0; i < L; i++) {\r\n                f[i] = f[i + L];\r\n                f[i + L] = 0;\r\n            }\r\n            Poly Q = Poly(vector<Mint>(res.begin(), res.begin() + L)).inv(L);\r\n            for (int i = 0; i < L; i++)\r\n                g[i] = Q.at(i);\r\n            fft(f);\r\n            fft(g);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Li /= 2;\r\n            for (int i = L; i < 2 * L && i < n; i++)\r\n                res[i] = f[i - L] * Li;\r\n        }\r\n        return res;\r\n    }\r\n    bool sqrt(int n, Poly &R) const {\r\n        if (deg() < 0) {\r\n            R = Poly();\r\n            return true;\r\n        }\r\n        if (at(0) == 1) {\r\n            R = sqrt_(n);\r\n            return true;\r\n        }\r\n        int z = 0;\r\n        while(at(z) == 0) z++;\r\n        if (z & 1) return false;\r\n        Poly A = substr(z, n + z / 2);\r\n        Mint cf;\r\n        if (!A[0].sqrt(cf)) return false;\r\n        A /= A[0];\r\n        A = A.sqrt_(n - z / 2) * cf;\r\n        R = A.substr(-z / 2, n - z / 2);\r\n        return true;\r\n    }\r\n\r\n    static Poly multiply_all(vector<Poly> polys) {\r\n        if (polys.empty()) return Poly({1});\r\n        set<pii> setik;\r\n        for (int i = 0; i < (int)polys.size(); i++)\r\n            setik.insert(mp(polys[i].deg(), i));\r\n        while((int)setik.size() > 1) {\r\n            int p = setik.begin()->second;\r\n            setik.erase(setik.begin());\r\n            int q = setik.begin()->second;\r\n            setik.erase(setik.begin());\r\n            polys[p] *= polys[q];\r\n            setik.insert(mp(polys[p].deg(), p));\r\n        }\r\n        return polys[setik.begin()->second];\r\n    }\r\n    static Poly given_roots(const vector<Mint> &xs) {\r\n        int n = (int)xs.size();\r\n        vector<Poly> polys(n);\r\n        for (int i = 0; i < n; i++)\r\n            polys[i] = Poly({Mint() - xs[i], 1});\r\n        return multiply_all(polys);\r\n    }\r\n\r\n    vector<Mint> multipoint(const vector<Mint> &xs) const {\r\n        int n = (int)xs.size();\r\n        if (n == 0) return {};\r\n        if (n == 1) return {eval(xs[0])};\r\n        int L = n;\r\n        while(L & (L - 1)) L++;\r\n        vector<Poly> tree(2 * L);\r\n        for (int i = 0; i < n; i++)\r\n            tree[L + i] = Poly({Mint() - xs[i], 1});\r\n        for (int i = n; i < L; i++)\r\n            tree[L + i] = Poly({1});\r\n        for (int i = L - 1; i > 0; i--)\r\n            tree[i] = tree[2 * i] * tree[2 * i + 1];\r\n        tree[1] = *this % tree[1];\r\n        for (int i = 2; i < L + n; i++)\r\n            tree[i] = tree[i / 2] % tree[i];\r\n        vector<Mint> res(n);\r\n        for (int i = 0; i < n; i++)\r\n            res[i] = tree[L + i].at(0);\r\n        return res;\r\n    }\r\n    static pair<Poly, Poly> interpolate_(const vector<pair<Mint, Mint>> &vals, int l, int r) {\r\n        if (r - l == 1) return mp(Poly({vals[l].second}), Poly({Mint() - vals[l].first, 1}));\r\n        int m = (l + r) / 2;\r\n        auto L = interpolate_(vals, l, m), R = interpolate_(vals, m, r);\r\n        return mp(L.first * R.second + R.first * L.second, L.second * R.second);\r\n\r\n    }\r\n    static Poly interpolate(vector<pair<Mint, Mint>> vals) {\r\n        if (vals.empty()) return Poly();\r\n        int n = (int)vals.size();\r\n        vector<Mint> xs(n);\r\n        for (int i = 0; i < n; i++)\r\n            xs[i] = vals[i].first;\r\n        Poly P = given_roots(xs);\r\n        P = P.derivate();\r\n        vector<Mint> cf = P.multipoint(xs);\r\n        for (int i = 0; i < n; i++)\r\n            vals[i].second /= cf[i];\r\n        return interpolate_(vals, 0, (int)vals.size()).first;\r\n    }\r\n    Poly x_k_mod_this(ll k) const { // x^k % P\r\n        Poly res = Poly({1});\r\n        int t = 0;\r\n        while((1LL << t) <= k) t++;\r\n        for (int i = t - 1; i >= 0; i--) {\r\n            res *= res;\r\n            if ((k >> i) & 1) res = res.substr(-1, res.deg() + 1);\r\n            res %= *this;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    vector<Mint> chirp_z(Mint z, int n) const { // eval at [z^0, z^1, ..., z^(n-1)]\r\n        int m = deg();\r\n        if (m < 0 || n == 0) return vector<Mint>(n);\r\n        if (z == 0) {\r\n            vector<Mint> res(n, at(0));\r\n            res[0] = eval(1);\r\n            return res;\r\n        }\r\n        Mint zi = z.inv();\r\n        vector<Mint> Z(n + m, 1), Zi(max(m + 1, n), 1);\r\n        Mint w = 1, wi = 1;\r\n        for (int i = 1; i < (int)Z.size(); i++) {\r\n            Z[i] = Z[i - 1] * w;\r\n            w *= z;\r\n        }\r\n        for (int i = 1; i < (int)Zi.size(); i++) {\r\n            Zi[i] = Zi[i - 1] * wi;\r\n            wi *= zi;\r\n        }\r\n        vector<Mint> f(m + 1);\r\n        for (int i = 0; i <= m; i++)\r\n            f[i] = at(i) * Zi[i];\r\n        reverse(all(Z));\r\n        Poly C = Poly(f) * Z;\r\n        vector<Mint> res(n);\r\n        for (int k = 0; k < n; k++)\r\n            res[k] = C.at(n + m - 1 - k) * Zi[k];\r\n        return res;\r\n    }\r\n\r\n    Poly shift_c(Mint c) const { // P(x + c)\r\n        int n = deg();\r\n        if (n < 0) return Poly();\r\n        Factorials<> F(n);\r\n        Powers<> P(n, c);\r\n        vector<Mint> f(n + 1), g(n + 1);\r\n        for (int i = 0; i <= n; i++) {\r\n            f[i] = at(i) * F.f[i];\r\n            g[i] = P.pow(i) * F.fi[i];\r\n        }\r\n        reverse(all(g));\r\n        Poly C = Poly(f) * g;\r\n        for (int i = 0; i <= n; i++)\r\n            f[i] = C.at(n + i) * F.fi[i];\r\n        return f;\r\n    }\r\n\r\n    static pair<Poly, Poly> _sub_exp(const vector<Mint> &a, int l, int r) {\r\n        if (r - l == 1) return mp(Poly({a[l]}), Poly({1, -l}));\r\n        int m = (l + r) / 2;\r\n        auto L = _sub_exp(a, l, m), R = _sub_exp(a, m, r);\r\n        return mp(L.first * R.second + R.first * L.second, L.second * R.second);\r\n    }\r\n    Poly substitute_exp(int m) const { // P(e^x)\r\n        auto t = _sub_exp(a, 0, deg() + 1);\r\n        auto A = (t.first * t.second.inv(m)).substr(0, m);\r\n        Factorials<mod> F(m);\r\n        vector<Mint> b(m, 0);\r\n        for (int i = 0; i < m; i++)\r\n            b[i] = A.at(i) * F.fi[i];\r\n        return b;\r\n    }\r\n};\r\n\r\n\r\nvector<Mint> ans;\r\n\r\nPoly<> InitOne () {\r\n    vector<Mint> a(2, Mint(1));\r\n    a[1] = Mint(2);\r\n    return Poly<>(a);\r\n}\r\n\r\nPoly<> InitTwo() {\r\n    vector<Mint> a(3, Mint(1));\r\n    a[1] = Mint(2);\r\n    return Poly<>(a);\r\n}\r\n\r\nPoly<> solve(vector<int> &a, int s = 0) {\r\n    if (sz(a) == 0) {\r\n        return Poly<>(vector<Mint>(1, Mint(1)));\r\n    } else if (sz(a) == 1) {\r\n        if (a[0] == 1) return InitOne();\r\n        return InitTwo();\r\n    }\r\n    vector<int> left, right;\r\n    int ls = 0, rs = 0;\r\n    for (int i = 0; i < sz(a); i++) {\r\n        if (ls + a[i] <= s / 2) {\r\n            ls += a[i];\r\n            left.push_back(a[i]);\r\n        } else {\r\n            rs += a[i];\r\n            right.push_back(a[i]);\r\n        }\r\n    }\r\n    Poly<> l = solve(left, ls);\r\n    Poly<> r = solve(right, rs);\r\n    return l * r;\r\n}\r\n\r\nvoid solve (int mx, vector<int> a, vector<int> &q) {\r\n    vector<int> b;\r\n    vector<int> cnt;\r\n    map<int, int> z;\r\n    for (int i = 0; i < sz(a); i++) {\r\n        if (a[i] < mx) {\r\n            b.push_back(a[i]);\r\n            z[a[i]]++;\r\n        }\r\n    }\r\n    a = b;\r\n    int n = sz(a);\r\n\r\n    for (auto v : z) {\r\n        if (v.second >= 2) {\r\n            cnt.push_back(2);\r\n        } else {\r\n            cnt.push_back(1);\r\n        }\r\n    }\r\n\r\n    int s = accumulate(all(cnt), 0ll);\r\n\r\n    Poly<> final = solve(cnt, s);\r\n\r\n    vector<Mint> len(n + 1, 1);\r\n\r\n    for (int i = 0; i < sz(q); i++) {\r\n        ll x = (1ll * q[i] - 1ll * mx - 1);\r\n        if (x < 0 || x > final.deg()) continue;\r\n        ans[i] = ans[i] + final.at(x);\r\n    }\r\n\r\n}\r\n\r\nvoid solve() {\r\n    int n, m;\r\n    cin >> n >> m;\r\n    vector<int> a(n);\r\n    cin >> a;\r\n    vector<int> b(m);\r\n    cin >> b;\r\n    int q;\r\n    cin >> q;\r\n    vector<int> Q(q);\r\n    ans.assign(q, 0);\r\n    for (int i = 0; i < q; i++) {\r\n        cin >> Q[i];\r\n        Q[i] /= 2;\r\n    }\r\n\r\n    for (int i = 0; i < m; i++) {\r\n        solve(b[i], a, Q);\r\n    }\r\n\r\n    for (int i = 0; i < q; i++) {\r\n        cout << ans[i].x << \"\\n\";\r\n    }\r\n}\r\n\r\nint32_t main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n    cout << fixed << setprecision(15);\r\n#ifdef home\r\n    freopen(\"in.txt\", \"r\", stdin);\r\n#endif\r\n    int32_t test = 1;\r\n    initFFT();\r\n    // cin >> test;\r\n    while (test--)\r\n        solve();\r\n    return 0;\r\n}"
}