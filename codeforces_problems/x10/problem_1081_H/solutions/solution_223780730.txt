{
    "id": 223780730,
    "contestId": 1081,
    "creationTimeSeconds": 1694992391,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1081,
        "index": "H",
        "name": "Palindromic Magic",
        "type": "PROGRAMMING",
        "points": 4000.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "hashing",
            "strings"
        ]
    },
    "author": {
        "contestId": 1081,
        "members": [
            {
                "handle": "magnus.hegdahl"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1544970900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 2252800,
    "source": "/**\n * author:  magnus_hegdahl\n * created: 17.09.2023 20:12\n * problem: H. Palindromic Magic\n * url:     https://codeforces.com/problemset/problem/1081/H\n */\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n// <ints.hpp>\n#include <cstddef>\n#include <cstdint>\nusing i8 = std::int8_t;\nusing u8 = std::uint8_t;\nusing i16 = std::int16_t;\nusing u16 = std::uint16_t;\nusing i32 = std::int32_t;\nusing u32 = std::uint32_t;\nusing i64 = std::int64_t;\nusing u64 = std::uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n#endif\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n// </ints.hpp>\n// <r_hash.hpp>\n#include <chrono>\n#include <functional>\n#include <random>\nstruct r_hash {\n    static u64 splitmix64(u64 x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    template <class T>\n    u64 operator()(const T &x) const {\n        return r_hash{}(std::hash<T>{}(x));\n    }\n    u64 operator()(u64 x) const {\n        static const u64 FIXED_RANDOM = std::mt19937_64(\n            std::chrono::steady_clock::now().time_since_epoch().count())();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n// </r_hash.hpp>\n\nauto pows = std::vector<u64>();\n\nstruct Hashes {\n    std::string _s;\n\n    std::vector<u64> fwd;\n    std::vector<u64> bwd;\n    Hashes() = default;\n    Hashes(const std::string &s) : _s(s) {\n        usize n = s.size();\n        fwd.resize(s.size() + 1);\n        bwd.resize(s.size() + 1);\n        fwd[0] = 0;\n        bwd[n] = 0;\n        for (u64 i = 0; i < s.size(); ++i) {\n            fwd[i + 1] = fwd[i] * pows[1] + (s[i] - 'a' + 1);\n            bwd[n - i - 1] =\n                bwd[n - i] * pows[1] + (s[s.size() - i - 1] - 'a' + 1);\n        }\n    }\n\n    auto operator()(u32 i, u32 j) const -> std::pair<u64, u64> {\n        assert(i <= j);\n        assert(j < fwd.size());\n\n        auto fwd_hash = fwd[j] - fwd[i] * pows[j - i];\n        auto bwd_hash = bwd[i] - bwd[j] * pows[j - i];\n\n        return {fwd_hash, bwd_hash};\n    }\n\n    auto rotated(u32 i, u32 j, u32 amt) const -> u64 {\n        auto [fwd_hash0, bwd_hash0] = (*this)(i + amt, j);\n        auto [fwd_hash1, bwd_hash1] = (*this)(i, i + amt);\n        return fwd_hash0 * pows[amt] + fwd_hash1;\n    }\n\n    auto odd_pal(u32 center) const -> std::pair<u32, u32> {\n        assert(center + 1 < fwd.size());\n        u32 w = 0;\n        u32 max_w = std::min(center, u32(fwd.size()) - center - 2);\n\n        for (u32 jmp = 1 << 17; jmp; jmp >>= 1) {\n            auto nw = w + jmp;\n            if (nw <= max_w) {\n                auto [fwd_hash, bwd_hash] =\n                    (*this)(center - nw, center + nw + 1);\n                if (fwd_hash == bwd_hash) {\n                    w = nw;\n                }\n            }\n        }\n        return {center - w, center + w + 1};\n    }\n\n    auto even_pal(u32 center) const -> std::pair<u32, u32> {\n        assert(center + 2 < fwd.size());\n        u32 w = -1;\n        u32 max_w = std::min(center, u32(fwd.size()) - center - 3);\n        for (u32 jmp = 1 << 17; jmp; jmp >>= 1) {\n            auto nw = w + jmp;\n            if (nw <= max_w) {\n                auto [fwd_hash, bwd_hash] =\n                    (*this)(center - nw, center + nw + 2);\n                if (fwd_hash == bwd_hash) {\n                    w = nw;\n                }\n            }\n        }\n        return {center - w, center + w + 2};\n    }\n\n    auto find_pals() -> std::vector<std::pair<u32, u32>> {\n        auto pals = std::vector<std::pair<u32, u32>>();\n        for (u32 i = 0; i < fwd.size() - 1; ++i) {\n            auto [l, r] = odd_pal(i);\n            pals.emplace_back(l, r);\n        }\n        for (u32 i = 0; i < fwd.size() - 2; ++i) {\n            auto [l, r] = even_pal(i);\n            pals.emplace_back(l, r);\n        }\n        std::stable_sort(pals.begin(), pals.end(), [](auto p0, auto p1) {\n            auto [l0, r0] = p0;\n            auto [l1, r1] = p1;\n            return r0 - l0 > r1 - l1;\n        });\n        return pals;\n    }\n\n    auto find_unique_pals() -> std::vector<std::tuple<u32, u32, u32>> {\n        auto seen = std::unordered_set<u64, r_hash>();\n        auto res = std::vector<std::tuple<u32, u32, u32>>();\n        for (auto [l, r] : find_pals()) {\n            while (l < r) {\n                if (!seen.emplace((*this)(l, r).first).second) break;\n                res.emplace_back(l, r, 0);\n                ++l;\n                --r;\n            }\n        }\n        return res;\n    }\n\n    struct PalGroup {\n        u32 begin = 0;\n        u32 end = 0;\n        u32 w = 0;\n    };\n    auto find_grps(std::vector<std::tuple<u32, u32, u32>> &pals)\n        -> std::unordered_map<u64, PalGroup, r_hash> {\n        auto grps = std::unordered_map<u64, PalGroup, r_hash>();\n\n        for (auto &[l, r, w] : pals) {\n            auto len = r - l;\n\n            // aabbaabbaabbaa\n            // [        ]\n            //     [        ]\n\n            auto check_a = [&](u32 d) -> bool {\n                return (*this)(l, r - d).first == (*this)(l + d, r).first;\n            };\n\n            w = len;\n            for (u32 d = 1; d < len; ++d) {\n                if (check_a(d)) {\n                    w = d;\n                    break;\n                }\n            }\n\n            if (w == len) continue;\n\n            auto hash = (*this)(l, l + w).first;\n            auto &grp = grps[hash];\n            if (len > grp.end - grp.begin) {\n                grp.begin = l;\n                grp.end = r;\n                grp.w = w;\n            }\n        }\n\n        return grps;\n    }\n};\n\nauto main() -> int {\n    std::cin.tie(nullptr)->sync_with_stdio(false);\n\n    pows.resize(200'000 + 1);\n\n    pows[0] = 1;\n    pows[1] = 31;\n\n    for (u64 i = 2; i < pows.size(); ++i) pows[i] = pows[i - 1] * pows[1];\n\n    auto s = std::string();\n    auto t = std::string();\n\n    std::cin >> s >> t;\n\n    auto s_hashes = Hashes(s);\n    auto t_hashes = Hashes(t);\n\n    auto s_uniques = s_hashes.find_unique_pals();\n    auto t_uniques = t_hashes.find_unique_pals();\n\n    auto s_grps = s_hashes.find_grps(s_uniques);\n    auto t_grps = t_hashes.find_grps(t_uniques);\n\n    u64 answer = u64(s_uniques.size()) * u64(t_uniques.size());\n\n    std::cerr << \"s_uniques:\\n\";\n    for (auto [l, r, w] : s_uniques) {\n        std::cerr << l << ' ' << r << ' ' << w << \": \" << s.substr(l, r - l)\n                  << '\\n';\n    }\n\n    std::cerr << \"t_uniques:\\n\";\n    for (auto [l, r, w] : t_uniques) {\n        std::cerr << l << ' ' << r << ' ' << w << \": \" << t.substr(l, r - l)\n                  << '\\n';\n    }\n\n    std::cerr << \"s_grps:\\n\";\n    for (auto [hash, grp] : s_grps) {\n        auto rem = (grp.end - grp.begin) % grp.w;\n        std::cerr << '[';\n        if (rem) std::cerr << s.substr(grp.begin, rem) << '|';\n        std::cerr << s.substr(grp.begin + rem, grp.w - rem) << ']';\n        std::cerr << s.substr(grp.begin + grp.w, grp.end - grp.begin - grp.w)\n                  << '\\n';\n\n        auto flip_hash = s_hashes.rotated(grp.begin, grp.begin + grp.w, rem);\n        auto it = t_grps.find(flip_hash);\n        if (it != t_grps.end()) {\n            auto [ohash, ogrp] = *it;\n\n            std::cerr << \"-> \" << t.substr(ogrp.begin, ogrp.end - ogrp.begin)\n                      << '\\n';\n\n            u64 l_blocks = (grp.end - grp.begin) / grp.w + (rem != 0);\n            u64 l_cuts = l_blocks;\n\n            u64 r_blocks = (ogrp.end - ogrp.begin) / ogrp.w + (rem != 0);\n            u64 r_cuts = r_blocks;\n\n            u64 lr_cuts =\n                (grp.end - grp.begin + ogrp.end - ogrp.begin) / grp.w - 1 +\n                (rem != 0);\n\n            std::cerr << \"l_cuts: \" << l_cuts << '\\n';\n            std::cerr << \"r_cuts: \" << r_cuts << '\\n';\n            std::cerr << \"lr_cuts: \" << lr_cuts << '\\n';\n\n            i64 adjust = lr_cuts - l_cuts * r_cuts;\n            std::cerr << \"adjust: \" << adjust << '\\n';\n\n            answer += adjust;\n        }\n    }\n\n    std::cerr << \"t_grps:\\n\";\n    for (auto [hash, grp] : t_grps) {\n        auto rem = (grp.end - grp.begin) % grp.w;\n        std::cerr << '[';\n        if (rem) std::cerr << t.substr(grp.begin, rem) << '|';\n        std::cerr << t.substr(grp.begin + rem, grp.w - rem) << ']';\n        std::cerr << t.substr(grp.begin + grp.w, grp.end - grp.begin - grp.w)\n                  << '\\n';\n    }\n\n    std::cout << answer << '\\n';\n\n    auto brute_set =\n        std::unordered_map<u64, std::tuple<u32, u32, u32, u32>, r_hash>();\n    for (auto [l0, r0, w0] : s_uniques) {\n        for (auto [l1, r1, w1] : t_uniques) {\n            auto [s_hash, s_hash_rev] = s_hashes(l0, r0);\n            auto [t_hash, t_hash_rev] = t_hashes(l1, r1);\n            auto st_hash = s_hash * pows[r1 - l1] + t_hash;\n            auto [it, placed] =\n                brute_set.emplace(st_hash, std::tuple{l0, r0, l1, r1});\n            if (!placed) {\n                std::cerr << \"already placed \" << s.substr(l0, r0 - l0) << ' '\n                          << t.substr(l1, r1 - l1) << '\\n';\n                auto [s0, s1, t0, t1] = it->second;\n                std::cerr << \"         using \" << s.substr(s0, s1 - s0) << ' '\n                          << t.substr(t0, t1 - t0) << '\\n';\n            }\n        }\n    }\n\n    std::cerr << brute_set.size() << '\\n';\n\n    assert(brute_set.size() == answer);\n}\n"
}