{
    "id": 215351286,
    "contestId": 1081,
    "creationTimeSeconds": 1690200721,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1081,
        "index": "H",
        "name": "Palindromic Magic",
        "type": "PROGRAMMING",
        "points": 4000.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "hashing",
            "strings"
        ]
    },
    "author": {
        "contestId": 1081,
        "members": [
            {
                "handle": "deepaksuthar40128"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1544970900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 77,
    "timeConsumedMillis": 1185,
    "memoryConsumedBytes": 251801600,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 234567;\r\nconst int LOG = 18;\r\nconst int ALPHA = 26;\r\nconst int base = 2333;\r\nconst int md0 = 1e9 + 7;\r\nconst int md1 = 1e9 + 9;\r\n\r\nstruct hash_t {\r\n  int hash0, hash1;\r\n\r\n  hash_t(int hash0 = 0, int hash1 = 0):hash0(hash0), hash1(hash1) {\r\n  }\r\n\r\n  hash_t operator + (const int &x) const {\r\n    return hash_t((hash0 + x) % md0, (hash1 + x) % md1);\r\n  };\r\n\r\n  hash_t operator * (const int &x) const {\r\n    return hash_t((long long)hash0 * x % md0, (long long)hash1 * x % md1);\r\n  }\r\n\r\n  hash_t operator + (const hash_t &x) const {\r\n    return hash_t((hash0 + x.hash0) % md0, (hash1 + x.hash1) % md1);\r\n  };\r\n\r\n  hash_t operator - (const hash_t &x) const {\r\n    return hash_t((hash0 + md0 - x.hash0) % md0, (hash1 + md1 - x.hash1) % md1);\r\n  };\r\n\r\n  hash_t operator * (const hash_t &x) const {\r\n    return hash_t((long long)hash0 * x.hash0 % md0, (long long)hash1 * x.hash1 % md1);\r\n  }\r\n\r\n  long long get() {\r\n    return (long long)hash0 * md1 + hash1;\r\n  }\r\n} ha[N], hb[N], power[N];\r\n\r\nstruct palindrome_tree_t {\r\n  int n, total, p[N], pos[N], value[N], parent[N], go[N][ALPHA], ancestor[LOG][N];\r\n  char s[N];\r\n\r\n  palindrome_tree_t() {\r\n    parent[0] = 1;\r\n    value[1] = -1;\r\n    total = 1;\r\n    p[0] = 1;\r\n  }\r\n\r\n  int extend(int p, int w, int n) {\r\n    while (s[n] != s[n - value[p] - 1]) {\r\n      p = parent[p];\r\n    }\r\n    if (!go[p][w]) {\r\n      int q = ++total, k = parent[p];\r\n      while (s[n] != s[n - value[k] - 1]) {\r\n        k = parent[k];\r\n      }\r\n      value[q] = value[p] + 2;\r\n      parent[q] = go[k][w];\r\n      go[p][w] = q;\r\n      pos[q] = n;\r\n    }\r\n    return go[p][w];\r\n  }\r\n\r\n  void init() {\r\n    for (int i = 1; i <= n; ++i) {\r\n      p[i] = extend(p[i - 1], s[i] - 'a', i);\r\n    }\r\n    for (int i = 0; i <= total; ++i) {\r\n      ancestor[0][i] = parent[i];\r\n    }\r\n    for (int i = 1; i < LOG; ++i) {\r\n      for (int j = 0; j <= total; ++j) {\r\n        ancestor[i][j] = ancestor[i - 1][ancestor[i - 1][j]];\r\n      }\r\n    }\r\n  }\r\n\r\n  int query(int r, int length) {\r\n    r = p[r];\r\n    if (value[r] <= length) {\r\n      return value[r];\r\n    }\r\n    for (int i = LOG - 1; ~i; --i) {\r\n      if (value[ancestor[i][r]] > length) {\r\n        r = ancestor[i][r];\r\n      }\r\n    }\r\n    return value[parent[r]];\r\n  }\r\n\r\n  bool check(int r, int length) {\r\n    r = p[r];\r\n    for (int i = LOG - 1; ~i; --i) {\r\n      if (value[ancestor[i][r]] >= length) {\r\n        r = ancestor[i][r];\r\n      }\r\n    }\r\n    return value[r] == length;\r\n  }\r\n} A, B, RA, RB;\r\n\r\nmap<long long, int> fa, fb, ga, gb;\r\nlong long answer;\r\nchar a[N], b[N];\r\nint n, m;\r\n\r\nhash_t get_hash(hash_t *h, int l, int r) {\r\n  return h[r] - h[l - 1] * power[r - l + 1];\r\n}\r\n\r\nint main() {\r\n#ifdef wxh010910\r\n  freopen(\"input.txt\", \"r\", stdin);\r\n#endif\r\n  scanf(\"%s %s\", a + 1, b + 1);\r\n  n = strlen(a + 1);\r\n  m = strlen(b + 1);\r\n  A.n = RA.n = n;\r\n  B.n = RB.n = m;\r\n  for (int i = 1; i <= n; ++i) {\r\n    A.s[i] = RA.s[n - i + 1] = a[i];\r\n    ha[i] = ha[i - 1] * base + a[i];\r\n  }\r\n  for (int i = 1; i <= m; ++i) {\r\n    B.s[i] = RB.s[m - i + 1] = b[i];\r\n    hb[i] = hb[i - 1] * base + b[i];\r\n  }\r\n  power[0] = hash_t(1, 1);\r\n  for (int i = 1; i <= max(n, m); ++i) {\r\n    power[i] = power[i - 1] * base;\r\n  }\r\n  A.init();\r\n  B.init();\r\n  RA.init();\r\n  RB.init();\r\n  answer = (long long)(A.total - 1) * (B.total - 1);\r\n  for (int i = 2; i <= A.total; ++i) {\r\n    ++fa[get_hash(ha, A.pos[i] - A.value[i] + 1, A.pos[i]).get()];\r\n    int p = A.parent[i];\r\n    if (p < 2) {\r\n      continue;\r\n    }\r\n    int l = A.pos[i] - (A.value[i] - A.value[p]) + 1, r = A.pos[i];\r\n    if (A.value[i] <= A.value[p] << 1) {\r\n      ++ga[get_hash(ha, l, r).get()];\r\n    }\r\n  }\r\n  for (int i = 2; i <= B.total; ++i) {\r\n    ++fb[get_hash(hb, B.pos[i] - B.value[i] + 1, B.pos[i]).get()];\r\n    int p = B.parent[i];\r\n    if (p < 2) {\r\n      continue;\r\n    }\r\n    int l = B.pos[i] - B.value[i] + 1, r = B.pos[i] - B.value[p];\r\n    if (B.value[i] <= B.value[p] << 1) {\r\n      ++gb[get_hash(hb, l, r).get()];\r\n    }\r\n  }\r\n  for (int i = 2; i <= A.total; ++i) {\r\n    int p = A.parent[i];\r\n    if (p < 2) {\r\n      continue;\r\n    }\r\n    int l = A.pos[i] - (A.value[i] - A.value[p]) + 1, r = A.pos[i];\r\n    long long value = get_hash(ha, l, r).get();\r\n    if (gb.count(value)) {\r\n      answer -= gb[value];\r\n    }\r\n    int longest_palindrome_suffix = A.query(r, r - l + 1);\r\n    if (longest_palindrome_suffix == r - l + 1) {\r\n      continue;\r\n    }\r\n    if (RA.check(n - l + 1, r - l + 1 - longest_palindrome_suffix)) {\r\n      int length = r - l + 1 - longest_palindrome_suffix;\r\n      if (fb.count(get_hash(ha, l, l + length - 1).get()) && fb.count((get_hash(ha, l, r) * power[length] + get_hash(ha, l, l + length - 1)).get())) {\r\n        --answer;\r\n      }\r\n      continue;\r\n    }\r\n    int longest_palindrome_prefix = RA.query(n - l + 1, r - l + 1);\r\n    if (A.check(r, r - l + 1 - longest_palindrome_prefix)) {\r\n      int length = longest_palindrome_prefix;\r\n      if (fb.count(get_hash(ha, l, l + length - 1).get()) && fb.count((get_hash(ha, l, r) * power[length] + get_hash(ha, l, l + length - 1)).get())) {\r\n        --answer;\r\n      }\r\n      continue;\r\n    }\r\n  }\r\n  for (int i = 2; i <= B.total; ++i) {\r\n    int p = B.parent[i];\r\n    if (p < 2) {\r\n      continue;\r\n    }\r\n    int l = B.pos[i] - B.value[i] + 1, r = B.pos[i] - B.value[p];\r\n    long long value = get_hash(hb, l, r).get();\r\n    if (ga.count(value)) {\r\n      answer -= ga[value];\r\n    }\r\n    int longest_palindrome_suffix = B.query(r, r - l + 1);\r\n    if (longest_palindrome_suffix == r - l + 1) {\r\n      continue;\r\n    }\r\n    if (RB.check(m - l + 1, r - l + 1 - longest_palindrome_suffix)) {\r\n      int length = longest_palindrome_suffix;\r\n      if (fa.count(get_hash(hb, r - length + 1, r).get()) && fa.count((get_hash(hb, r - length + 1, r) * power[r - l + 1] + get_hash(hb, l, r)).get())) {\r\n        --answer;\r\n      }\r\n      continue;\r\n    }\r\n    int longest_palindrome_prefix = RB.query(m - l + 1, r - l + 1);\r\n    if (B.check(r, r - l + 1 - longest_palindrome_prefix)) {\r\n      int length = r - l + 1 - longest_palindrome_prefix;\r\n      if (fa.count(get_hash(hb, r - length + 1, r).get()) && fa.count((get_hash(hb, r - length + 1, r) * power[r - l + 1] + get_hash(hb, l, r)).get())) {\r\n        --answer;\r\n      }\r\n      continue;\r\n    }\r\n  }\r\n  for (int i = 2; i <= A.total; ++i) {\r\n    int p = A.parent[i];\r\n    if (p < 2) {\r\n      continue;\r\n    }\r\n    int l = A.pos[i] - (A.value[i] - A.value[p]) + 1, r = A.pos[i];\r\n    if (A.value[i] > A.value[p] << 1) {\r\n      ++ga[get_hash(ha, l, r).get()];\r\n    }\r\n  }\r\n  for (int i = 2; i <= B.total; ++i) {\r\n    int p = B.parent[i];\r\n    if (p < 2) {\r\n      continue;\r\n    }\r\n    int l = B.pos[i] - B.value[i] + 1, r = B.pos[i] - B.value[p];\r\n    if (B.value[i] > B.value[p] << 1) {\r\n      ++gb[get_hash(hb, l, r).get()];\r\n    }\r\n  }\r\n  for (auto p : ga) {\r\n    answer += (long long)p.second * gb[p.first];\r\n  }\r\n  printf(\"%lld\\n\", answer);\r\n  return 0;\r\n}"
}