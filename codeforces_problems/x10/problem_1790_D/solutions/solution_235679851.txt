{
    "id": 235679851,
    "contestId": 1790,
    "creationTimeSeconds": 1701680070,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1790,
        "index": "D",
        "name": "Matryoshkas",
        "type": "PROGRAMMING",
        "rating": 1200,
        "tags": [
            "data structures",
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1790,
        "members": [
            {
                "handle": "tuko_tanzwoo"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1674830100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 61,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n/*\r\nchar board[4][4];\r\nint visited[4][4];\r\n string word;\r\n bool an = false;\r\n int row = 1;\r\n int col = 2;\r\n     void backtrack(int i,int j,string &temp){\r\n        //cout<<temp<<endl;\r\n        if(ans) return;\r\n\r\n\r\nif(temp == word) {\r\n            ans = true;\r\n            cout<<\"so the ans is \"<<word<<endl;\r\n            return;\r\n        }\r\n        if(visited[i][j]) return;\r\n        if(i >= row || j >= col || i < 0 || j < 0) return;\r\n        if(!visited[i][j]) temp.push_back(board[i][j]);\r\n        visited[i][j] = 1;\r\n        backtrack(i,j+1,temp);\r\n          if(!visited[i][j]) temp.push_back(board[i][j]);\r\n          visited[i][j] = 1;\r\n        backtrack(i,j-1,temp);\r\n          if(!visited[i][j]) temp.push_back(board[i][j]);\r\n          visited[i][j] = 1;\r\n        backtrack(i+1,j,temp);\r\n          if(!visited[i][j]) temp.push_back(board[i][j]);\r\n          visited[i][j] = 1;\r\n        backtrack(i-1,j,temp);\r\n        temp.pop_back();\r\n        visited[i][j] = 0;\r\n\r\n    }\r\n\r\n    vector<vector<int>>perm(vector<int>&arr,int start,int end){\r\n            if(start == end){\r\n            \tvector<int>temp;\r\n            \ttemp.push_back(arr[start]);\r\n            \tvector<vector<int>>ans;\r\n            \tans.push_back(temp);\r\n            \treturn ans;\r\n            }\r\n            vector<vector<int>>temp = perm(arr,start + 1,end);\r\n\r\n            // for(auto it:temp){\r\n            // \tfor(auto x:it) cout<<x<<\" \";\r\n            // \t\tcout<<endl;\r\n            // }\r\n\r\n            // cout<<\"temp ends here \"<<endl;\r\n            std::set<vector<int>>result;\r\n            for(auto it:temp){\r\n            \tint sz = it.size();\r\n            \tint k = 0;\r\n            \tstd::vector<int>change  = it;;\r\n            \twhile(k <= (sz)){\r\n\r\n\r\n            \t\t\t\tchange.insert(change.begin() + k,arr[start]);\r\n            \t\tresult.insert(change);\r\n\r\n            \t\tchange = it;\r\n            \t\tk+=1;\r\n            \t}\r\n            }\r\n            std::vector<vector<int>>final;\r\n            for(auto it:result) final.push_back(it);\r\n            return final;\r\n    }\r\n\r\nvector<vector<int>>subsets(vector<int>&arr,int i){\r\n      if(i == (arr.size() - 1)){\r\n           std::vector<int>temp;\r\n           temp.push_back(arr[i]);\r\n           std::vector<vector<int>>final;\r\n\r\n           final.push_back(temp);\r\n                      temp.pop_back();\r\n              final.push_back(temp);\r\n           return final;\r\n      }\r\n       std::vector<vector<int>>partial = subsets(arr,i+1);\r\n            //   for(auto it:partial){\r\n            //  \tfor(auto x:it) cout<<x<<\" \";\r\n            //  \t\tcout<<endl;\r\n            //  }\r\n\r\n            // cout<<\"temp ends here \"<<endl;\r\n       std::vector<vector<int>>final;\r\n      for(auto it:partial){\r\n      \tfinal.push_back(it);\r\n      \tit.push_back(arr[i]);\r\n      \tfinal.push_back(it);\r\n      }\r\n      return final;\r\n}\r\nvector<string>mapping = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\r\n\r\nvector<string>lettercombo(string s,int i){\r\n\tif(i == 0){\r\n\t     std::vector<string>temp;\r\n\r\n\t     for(auto it:mapping[s[i] - '0']){\r\n              string res = \"\";\r\n              res.push_back(it);\r\n              temp.push_back(res);\r\n\t     }\r\n\t     return temp;\r\n\t}\r\n\tstd::vector<string>partial = lettercombo(s,i-1);\r\n\r\n\tstd::vector<string> final;\r\n\tfor(auto it:partial){\r\n\r\n\t\tfor(auto x:mapping[s[i] - '0']){\r\n\r\n              string inside = it;\r\n              inside.push_back(x);\r\n              final.push_back(inside);\r\n\t\t}\r\n\t}\r\n\treturn final;\r\n\r\n}\r\n\r\n\r\n\r\n\r\nset<vector<int>>ans;\r\nvector<int>v;\r\n// void prin(int arr[],int i,int n,int target)\r\n\r\n// {\r\n\r\n// if(target == 0){\r\n// \t//cout<<\"HITTED HERE \"<<endl;\r\n//             ans.insert(v);\r\n//             return;\r\n//         }\r\n// \t    if(i >= n) return;\r\n//      if(target < 0) return;\r\n\r\n//     v.push_back(arr[i]);\r\n//    // cout<<\"previous first is \";\r\n//     target -= arr[i];\r\n//    // cout<<target<<endl;\r\n//    // for(auto it:v) cout<<it<<\" \";\r\n//     \t//cout<<endl;\r\n//     print(arr,i+1,n,(target));\r\n\r\n//    target += v.back();\r\n//     v.pop_back();\r\n\r\n//   // cout<<\"next first is \"<<target<<endl;\r\n//           // for(auto it:v) cout<<it<<\" \";\r\n//     \t//cout<<endl;\r\n//     print(arr,i+1,n,target);\r\n// }\r\n\r\n\r\nvoid print(int arr[],int i,int n)\r\n\r\n{\r\n\r\n\r\n\t    if(i >= n) {\r\n           ans.insert(v);\r\n            return;\r\n\t    }\r\n    // if(target < 0) return;\r\n\r\n    v.push_back(arr[i]);\r\n   // cout<<\"previous first is \";\r\n   // cout<<target<<endl;\r\n   // for(auto it:v) cout<<it<<\" \";\r\n    \t//cout<<endl;\r\n    print(arr,i+1,n);\r\n    v.pop_back();\r\n\r\n  // cout<<\"next first is \"<<target<<endl;\r\n          // for(auto it:v) cout<<it<<\" \";\r\n    \t//cout<<endl;\r\n    print(arr,i+1,n);\r\n}\r\nvector<vector<int>>subsets(vector<int>&arr,int i){\r\n      if(i == (arr.size() - 1)){\r\n           std::vector<int>temp;\r\n           temp.push_back(i);\r\n           std::vector<vector<int>>final;\r\n\r\n           final.push_back(temp);\r\n                      temp.pop_back();\r\n              final.push_back(temp);\r\n           return final;\r\n      }\r\n       std::vector<vector<int>>partial = subsets(arr,i+1);\r\n            //   for(auto it:partial){\r\n            //  \tfor(auto x:it) cout<<x<<\" \";\r\n            //  \t\tcout<<endl;\r\n            //  }\r\n\r\n            // cout<<\"temp ends here \"<<endl;\r\n       std::vector<vector<int>>final;\r\n      for(auto it:partial){\r\n      \tfinal.push_back(it);\r\n      \tit.push_back(i);\r\n      \tfinal.push_back(it);\r\n      }\r\n      return final;\r\n}\r\n\r\n\r\nint used[1000];\r\nint n;\r\nint m;\r\nint graph[17][17];\r\nbool coloring(vector<vector<int>>&color,int i,int m){\r\n\r\n\r\n     if(i == n){\r\n     \tint cnt = 0;\r\n     \tfor(auto it:color) cnt+=it.size();\r\n     \tif(cnt == n) return true;\r\n        else return false;\r\n     }\r\n\r\n     for(int j = 0;j<m;j++){\r\n     \tint flag = 0;\r\n     \tfor(auto it:color[j]){\r\n     \t\tif(graph[it][i] == 1){\r\n     \t\t\tflag = 1;\r\n     \t\t\tbreak;\r\n     \t\t}\r\n     \t}\r\n     \tif(flag == 0){\r\n     \t\tcolor[j].push_back(i);\r\n     \t\tif(coloring(color,i+1,m)) return true;\r\n            color[j].pop_back();\r\n     \t}\r\n     }\r\n     return false;\r\n}\r\n\r\n#define ll long long\r\nconst int N = 1000;\r\nvector<int>graph[N];\r\nbool hascycle  = false;\r\nint vis[100];\r\nint inpath[100];\r\nvoid dfs(int root){\r\n\tvis[root] = 1;\r\n\tinpath[root] = 1;\r\n\tfor(auto it:graph[root]){\r\n\t\tif(vis[it] && inpath[it]) hascycle = true;\r\n\t\telse{\r\n\t\t\tdfs(it);\r\n\t\t}\r\n\t}\r\n\tinpath[root] = 0;\r\n}\r\n\r\n*/\r\nint parent[1000];\r\nint sz[1000];\r\nvoid make(int n){\r\n\tparent[n] = n;\r\n\tsz[n] = 1;\r\n}\r\n\r\nint find(int v){\r\n\tif(v == parent[v]) {\r\n\r\n         return parent[v];\r\n\t}\r\n\treturn  parent[v] = find(parent[v]);\r\n}\r\n\r\nvoid Union(int a,int b){\r\n\ta = find(a);\r\n\tb = find(b);\r\n\tif(a == b) return;\r\n\tif(sz[a] < sz[b]) swap(a,b);\r\n\tparent[b] = a;\r\n\tsz[a] += sz[b];\r\n}\r\n\r\n\r\nvoid detach(int a,int sizea,int b,int sizeb){\r\n\tint ta = find(a);\r\n\tint tb = find(b);\r\n\tif(ta != tb) return;\r\n\tparent[a] = a;\r\n\tparent[b] = b;\r\n\tsz[a] = sizea;\r\n\tsz[b] = sizeb;\r\n}\r\n/*\r\nconst int n = 100;\r\n//vector<int>graph[n];\r\nint dist[100];\r\n//int vis[100];\r\nvoid bfs(int root){\r\n  vis[root] = 1;\r\n  queue<int>q;\r\n  q.push(root);\r\n  while(!q.empty()){\r\n  \tint temp = q.front();\r\n  \tq.pop();\r\n  \tfor(auto it:graph[temp]){\r\n  \t\tif(vis[it]) continue;\r\n  \t\tdist[it] =  dist[temp] + 1;\r\n  \t\tvis[it] = 1;\r\n  \t\tq.push(it);\r\n  \t}\r\n  }\r\n}\r\n*/\r\n\r\n // offline 1;\r\n\r\n\r\n\r\n\r\n// void bfs(int root,vector<pair<int,pair<int,int>>>&rm){\r\n// \tvector<int>grap[100];\r\n// \tfor(auto it:rm){\r\n// \t\tgrap[it.second.first].push_back(it.second.second);\r\n// \t\tgrap[it.second.second].push_back(it.second.first);\r\n// \t}\r\n\r\n//   vis[root] = 1;\r\n//   queue<int>q;\r\n//   q.push(root);\r\n//   while(!q.empty()){\r\n//   \tint temp = q.front();\r\n//   \tq.pop();\r\n//   \tfor(auto it:grap[temp]){\r\n//   \t\tif(vis[it]) continue;\r\n//   \t\t//dist[it] =  dist[temp] + 1;\r\n//   \t\tvis[it] = 1;\r\n//   \t\tq.push(it);\r\n//   \t}\r\n//   }\r\n// }\r\n\r\n\r\n\r\n// void clear(){\r\n// \tfor(int i = 1;i<=n;i++) vis[i] = 0;\r\n// }\r\n/*\r\nvector<pair<int,pair<int,int>>>graph;\r\nvector<pair<int,pair<int,int>>>graph2;\r\nvector<vector<pair<int,pair<int,int>>>>ans;\r\nvector<pair<int,pair<int,int>>>rm;\r\n  int n,m;\r\n\r\nint mst = 0;\r\n\r\n\r\n\r\nbool check(vector<pair<int,pair<int,int>>>rm){\r\n\t//sort(rm.begin(),rm.end());\r\n\r\n\r\n\tfor(int i = 1;i<=(n);i++) make(i);\r\n\r\n\t\t//int rslt = 0;\r\n\tfor(int i = 0;i<rm.size();i++){\r\n\tauto it = rm[i];\r\n\tif(find(it.second.first) != find(it.second.second)){\r\n\t\tUnion(it.second.first,it.second.second);\r\n\t\t//rslt+=it.first;\r\n\t}\r\n\telse return false;\r\n     }\r\n     //cnt = rslt;\r\n     int tmp = find(1); // change will occur\r\n\r\n\r\n\r\n   for(int i = 1;i<=n;i++){\r\n        if(find(i) != tmp) {\r\n             for(int i = 1;i<=(n);i++) make(i);\r\n             \treturn false;\r\n        }\r\n   }\r\n\r\n\r\n   \r\nfor(int i = 1;i<=(n);i++) make(i);\r\n return true;\r\n}\r\n\r\nvoid backtrack(int i){\r\n\r\n\tif(i >= graph.size()){\r\n\r\n\r\n\t\tint cnt = 0;\r\n\r\n\r\n\t\t// bfs(rm[0].second.first,rm);\r\n\t\t// for(int j = 0;j<n;j++){\r\n\t\t// \tif(vis[j] == 0) {\r\n  //               clear();\r\n  //               return;\r\n\t\t// \t}\r\n\t\t// }\r\n\t\tbool save = check(rm);\r\n\t\tif(!save) return;\r\n        for(auto it:rm) cnt += it.first;\r\n       //if(rm.size() != (n-1)) return;\r\n         if(cnt == mst) {\r\n           // cout<<\"value of cnt is\"<<cnt<<endl;\r\n         \tans.push_back(rm);\r\n\r\n         }\r\n          return;\r\n\t\t}\r\n        // cout<<\"hitted\"<<endl;\r\n\r\n\r\n\tauto it = graph[i];\r\n\t//int tmp1 = find(it.second.first);\r\n\t//int tmp2 = find(it.second.second);\r\n\t//cout<<\"tmp1 is \"<<tmp1<<\" \"<<\"tmp2 is \"<<tmp2<<endl;\r\n\r\n\t//int flag = 0;\r\n\t//int size1,size2;\r\n\r\n\r\n\t\t//cout<<\"no loop for edge \"<<it.second.first<<\" \"<<it.second.second<<endl;\r\n\t\t//cout<<\"here\"<<endl;\r\n\t\trm.push_back({it.first,{it.second.first,it.second.second}});\r\n\t\t// cout<<\"value of rm is\"<<endl;\r\n\t\t// for(auto x:rm){\r\n\t\t// \tcout<<x.second.first<<\" \"<<x.second.second<<\" \"<<x.first<<endl;\r\n\t\t// }\r\n\t\t//size1 = sz[tmp1];\r\n\t\t//size2 = sz[tmp2];\r\n\r\n\r\n\t\t//Union(it.second.first,it.second.second);\r\n\t\tbacktrack(i+1);\r\n\r\n\t  rm.pop_back();\r\n         // cout<<\" loop for edge \"<<it.second.first<<\" \"<<it.second.second<<endl;\r\n         backtrack(i+1);\r\n\r\n\r\n\t//backtrack\r\n\r\n\r\n\r\n}\r\n\r\nint main()\r\n{\r\n int t = 1;\r\n while(t--){\r\n cin>>n>>m;\r\n   for(int i = 0;i<m;i++){\r\n   \tint a,b,c; cin>>a>>b>>c;\r\n   \tgraph.push_back({c,{a,b}});\r\n   \tgraph2.push_back({c,{a,b}});\r\n  // \tgrap[a].push_back(b);\r\n   //\tgrap[b].push_back(a);\r\n   \t//graph[b].push_back({c,a});\r\n }\r\nsort(graph.begin(),graph.end());\r\n\r\n\r\nfor(int i = 1;i<=(n);i++) make(i);\r\n\r\n\tint cnt = 0;\r\nfor(int i = 0;i<m;i++){\r\n\tauto it = graph[i];\r\n\tif(find(it.second.first) != find(it.second.second)){\r\n\t\tUnion(it.second.first,it.second.second);\r\n\t\tcnt+=it.first;\r\n\t}\r\n}\r\n\r\nmst = cnt;\r\nbacktrack(0);\r\n// cout<<\"Number of mst is \"<<ans.size()<<endl;\r\n// for(auto it:ans){\r\n// \tcout<<\"mst are\"<<endl;\r\n// \tfor(auto x:it){\r\n// \t\tcout<<x.second.first<<\" \"<<x.second.second<<\" \"<<x.first<<endl;\r\n// \t}\r\n// \tcout<<endl<<endl;\r\n//    }\r\n \r\n   map<pair<int,int>,int>mp;\r\nfor(auto it:ans){\r\n\t//cout<<\"mst are\"<<endl;\r\n\tfor(auto x:it){\r\n\t\tmp[{x.second.first,x.second.second}]++;\r\n\t}\r\n\t\r\n   }\r\n   vector<int>critical;\r\n   vector<int>pseudo_critical;\r\n   int i = 0;\r\nfor(auto it:graph2){\r\n\t//cout<<it.second.first<<\" \"<<it.second.second<<\" \"<<it.first<<\" \";\r\n\tif(mp[{it.second.first,it.second.second}] == ans.size()) cout<<\"any\"<<endl;\r\n\telse if(mp[{it.second.first,it.second.second}]>= 1) cout<<\"at least\"<<endl;\r\n\telse cout<<\"NONE\"<<endl;\r\n\ti++;\r\n}\r\n// cout<<\"Critical edges are [ \";\r\n// for(auto it:critical) cout<<it<<\" \";\r\n// \tcout<<\"]\"<<endl;\r\n// cout<<\"Pseudo Critical edges are [ \";\r\n// for(auto it:pseudo_critical) cout<<it<<\" \";\r\n// \tcout<<\"]\"<<endl;\r\n\r\nreturn 0;\r\n\r\n\r\n}\r\n}\r\n\r\n\r\n\r\n\r\n// practice problems\r\n\r\n\r\npair<int,int>ans;\r\nbool has = false;\r\nint vis[100];\r\nvector<int>graph[100];\r\nvoid dfs(int root,int parent){\r\n\tvis[root]  = 1;\r\n\tfor(auto it:graph[root]){\r\n\t\tif(vis[it]){\r\n\t\t\tif(it != parent) {\r\n\r\n\t\t\t\tans = {root,it};\r\n\r\n\t\t\t\thas = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse dfs(it,root);\r\n\t}\r\n}\r\n*/\r\n\r\n\r\n#define ll long long\r\nlong long power[100];\r\nint cnt[100];\r\n\r\nint main()\r\n{    int tc;\r\n\tcin >> tc;\r\n\twhile(tc--){\r\n\t\tll n; cin>>n;\r\n\t\tll arr[n];\r\n\t\tmap<ll,ll>mp;\r\n\t\tll mn = 1e9 + 5;\r\n\t\tll mx = -1;\r\n\t\tfor(int i = 0;i<n;i++) {\r\n\t\t\tcin>>arr[i];\r\n             mp[arr[i]]++;\r\n             mx = max(mx,arr[i]);\r\n             mn = min(mn,arr[i]);\r\n\t\t}\r\n\r\n\t\tll cntopen = 0;\r\n\t\tll cntclosed = 0;\r\n\t\tll serial = -1;\r\n\t\tfor(auto it:mp){\r\n            if(it.first == mn) {\r\n                   cntopen += it.second;\r\n                   serial = it.first;\r\n            }\r\n            else{\r\n                  if(it.first != (serial + 1)){\r\n                  \tcntclosed += cntopen;\r\n                  \tcntopen = it.second;\r\n                  \tserial = it.first;\r\n                  }\r\n                  else{\r\n                  \tif(it.second >= cntopen) {\r\n                           cntopen += (it.second -cntopen);\r\n                           serial = it.first;\r\n\r\n                  \t}\r\n                  \telse{\r\n                              cntclosed += (cntopen - it.second);\r\n                              cntopen -= cntclosed;\r\n                              serial = it.first;\r\n                  \t}\r\n                  }\r\n            }\r\n\t\t}\r\n\r\n        cout<<cntopen + cntclosed<<endl;\r\n \r\n\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n"
}