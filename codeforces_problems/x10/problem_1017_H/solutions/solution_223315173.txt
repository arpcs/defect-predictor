{
    "id": 223315173,
    "contestId": 1017,
    "creationTimeSeconds": 1694678413,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1017,
        "index": "H",
        "name": "The Films",
        "type": "PROGRAMMING",
        "points": 3250.0,
        "rating": 3300,
        "tags": [
            "brute force"
        ]
    },
    "author": {
        "contestId": 1017,
        "members": [
            {
                "handle": "cmk666"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1533737100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 7,
    "timeConsumedMillis": 592,
    "memoryConsumedBytes": 8089600,
    "source": "/*\r\n * @Author:             cmk666\r\n * @Created time:       2023-09-14 15:37:17\r\n * @Last Modified time: 2023-09-14 15:59:59\r\n */\r\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\r\n#include<bits/stdc++.h>\r\n#ifdef LOCAL\r\n#include\"debug.h\"\r\n#else\r\n#define D(...) ((void)0)\r\n#endif\r\nusing namespace std; using ll = long long;\r\n#define For(i, j, k) for ( int i = (j) ; i <= (k) ; i++ )\r\n#define Fol(i, j, k) for ( int i = (j) ; i >= (k) ; i-- )\r\nnamespace FastIO\r\n{\r\n// ------------------------------\r\n// #define IN_HAS_NEG\r\n// #define OUT_HAS_NEG\r\n// #define CHK_EOF\r\n// #define DISABLE_MMAP\r\n// ------------------------------\r\n#if __cplusplus < 201400\r\n#error Please use C++14 or higher.\r\n#endif\r\n#if __cplusplus > 201700\r\n#define INLINE_V inline\r\n#else\r\n#define INLINE_V\r\n#endif\r\n#if ( defined(LOCAL) || defined(_WIN32) ) && !defined(DISABLE_MMAP)\r\n#define DISABLE_MMAP\r\n#endif\r\n#ifndef DISABLE_MMAP\r\n#include<sys/mman.h>\r\n#endif\r\n#ifdef LOCAL\r\n\tinline char gc() { return getchar(); }\r\n\tinline void pc(char c) { putchar(c); }\r\n#else\r\n#ifdef DISABLE_MMAP\r\n\tINLINE_V constexpr int _READ_SIZE = 1 << 18;\r\n\tINLINE_V static char _read_buffer[_READ_SIZE], *_read_ptr = nullptr, *_read_ptr_end = nullptr;\r\n\tinline char gc()\r\n\t{\r\n\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) )\r\n\t\t{\r\n\t\t\t_read_ptr = _read_buffer;\r\n\t\t\t_read_ptr_end = _read_buffer + fread(_read_buffer, 1, _READ_SIZE, stdin);\r\n#ifdef CHK_EOF\r\n\t\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) ) return EOF;\r\n#endif\r\n\t\t}\r\n\t\treturn *_read_ptr++;\r\n\t}\r\n#else\r\n\tINLINE_V static const char *_read_ptr = (const char *)mmap(nullptr, INT_MAX, 1, 2, 0, 0);\r\n\tinline char gc() { return *_read_ptr++; }\r\n#endif\r\n\tINLINE_V constexpr int _WRITE_SIZE = 1 << 18;\r\n\tINLINE_V static char _write_buffer[_WRITE_SIZE], *_write_ptr = _write_buffer;\r\n\tinline void pc(char c)\r\n\t{\r\n\t\t*_write_ptr++ = c;\r\n\t\tif ( __builtin_expect(_write_buffer + _WRITE_SIZE == _write_ptr, false) )\r\n\t\t{\r\n\t\t\tfwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout);\r\n\t\t\t_write_ptr = _write_buffer;\r\n\t\t}\r\n\t}\r\n\tINLINE_V struct _auto_flush\r\n\t{\r\n\t\tinline ~_auto_flush() { fwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout); }\r\n\t}\t_auto_flush;\r\n#endif\r\n#ifdef CHK_EOF\r\n\tinline constexpr bool _isdigit(char c) { return ( c & 16 ) && c != EOF; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32 && c != EOF; }\r\n#else\r\n\tinline constexpr bool _isdigit(char c) { return c & 16; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32; }\r\n#endif\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_integer = numeric_limits < T >::is_integer;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_signed = numeric_limits < T >::is_signed;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_unsigned = _is_integer < T > && !_is_signed < T >;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __uint128_t > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_signed < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_unsigned < __uint128_t > = true;\r\n#undef INLINE_V\r\n\tinline void read(char &c) { do c = gc(); while ( !_isgraph(c) ); }\r\n\tinline void read_cstr(char *s)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) *s++ = c, c = gc();\r\n\t\t*s = 0;\r\n\t}\r\n\tinline void read(string &s)\r\n\t{\r\n\t\tchar c = gc(); s.clear(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) s.push_back(c), c = gc();\r\n\t}\r\n#ifdef IN_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); bool f = true; x = 0;\r\n\t\twhile ( !_isdigit(c) ) { if ( c == 45 ) f = false; c = gc(); }\r\n\t\tif ( f ) while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t\telse     while ( _isdigit(c) ) x = x * 10 - ( c & 15 ), c = gc();\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isdigit(c) ) c = gc();\r\n\t\tx = 0; while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t}\r\n\tinline void write(char c) { pc(c); }\r\n\tinline void write_cstr(const char *s) { while ( *s ) pc(*s++); }\r\n\tinline void write(const string &s) { for ( char c : s ) pc(c); }\r\n#ifdef OUT_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tif ( x >= 0 )  do buffer[digits++] =  ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\telse { pc(45); do buffer[digits++] = -( x % 10 ) | 48, x /= 10; while ( x ); }\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tdo buffer[digits++] = ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < int N > struct _tuple_io_helper\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_read(x), read(get < N - 1 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_write(x), pc(32), write(get < N - 1 > (x)); }\r\n\t};\r\n\ttemplate <> struct _tuple_io_helper < 1 >\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x) { read(get < 0 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x) { write(get < 0 > (x)); }\r\n\t};\r\n\ttemplate < class ...T >\r\n\tinline void read(tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_read(x); }\r\n\ttemplate < class ...T >\r\n\tinline void write(const tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_write(x); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void read(pair < T1, T2 > &x) { read(x.first), read(x.second); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void write(const pair < T1, T2 > &x) { write(x.first), pc(32), write(x.second); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void read(T1 &x, T2 &...y) { read(x), read(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void read_cstr(char *x, T *...y) { read_cstr(x), read_cstr(y...); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void write(const T1 &x, const T2 &...y) { write(x), write(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void write_cstr(const char *x, const T *...y) { write_cstr(x), write_cstr(y...); }\r\n\ttemplate < class T >\r\n\tinline void print(const T &x) { write(x); }\r\n\tinline void print_cstr(const char *x) { write_cstr(x); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void print(const T1 &x, const T2 &...y) { print(x), pc(32), print(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void print_cstr(const char *x, const T *...y) { print_cstr(x), print_cstr(y...); }\r\n\tinline void println() { pc(10); }\r\n\tinline void println_cstr() { pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println(const T &...x) { print(x...), pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println_cstr(const T *...x) { print_cstr(x...), pc(10); }\r\n}\r\nusing namespace FastIO;\r\ntemplate < int P > class Modint\r\n{\r\n\tusing MI = Modint;\r\n\tinline Modint(int x, int) : v(x) {}\r\n\tinline static int add(int x) { return x < P ? x : x - P; }\r\n\tinline static int sub(int x) { return x >= 0 ? x : x + P; }\r\npublic:\r\n\tint v;\r\n\tinline Modint() : v(0) {}\r\n\tinline Modint(const MI &x) : v(x.v) {}\r\n\ttemplate < class T, enable_if_t < numeric_limits < T >::is_integer, int > = 0 >\r\n\tinline Modint(T x) : v(sub(x % P)) {}\r\n\ttemplate < class T, enable_if_t < numeric_limits < T >::is_integer, int > = 0 >\r\n\texplicit inline operator T()const { return v; }\r\n\tinline friend bool operator==(const MI &x, const MI &y) { return x.v == y.v; }\r\n\tinline friend bool operator!=(const MI &x, const MI &y) { return x.v != y.v; }\r\n\tinline MI &operator=(const MI &x) { v = x.v; return *this; }\r\n\tinline MI &operator++() { v < P - 1 ? v++ : v = 0; return *this; }\r\n\tinline MI operator++(int) { MI x = *this; v < P - 1 ? v++ : v = 0; return x; }\r\n\tinline MI &operator--() { v ? v-- : v = P - 1; return *this; }\r\n\tinline MI operator--(int) { MI x = *this; v ? v-- : v = P - 1; return x; }\r\n\tinline MI operator-()const { return MI(v ? P - v : 0, 0); }\r\n\tinline friend MI operator+(const MI &x, const MI &y) { return MI(add(x.v + y.v), 0); }\r\n\tinline friend MI operator-(const MI &x, const MI &y) { return MI(sub(x.v - y.v), 0); }\r\n\tinline friend MI operator*(const MI &x, const MI &y) { return MI(1ll * x.v * y.v % P, 0); }\r\n\tinline friend MI operator/(const MI &x, const MI &y) { return x * y.inv(); }\r\n\tinline MI &operator+=(const MI &x) { v = add(v + x.v); return *this; }\r\n\tinline MI &operator-=(const MI &x) { v = sub(v - x.v); return *this; }\r\n\tinline MI &operator*=(const MI &x) { v = 1ll * v * x.v % P; return *this; }\r\n\tinline MI &operator/=(const MI &x) { return *this *= x.inv(); }\r\n\ttemplate < class T, enable_if_t < numeric_limits < T >::is_integer, int > = 0 >\r\n\tinline MI qpow(T y)const\r\n\t{ MI x = *this, z = 1; for ( ; y ; y >>= 1, x *= x ) if ( y & 1 ) z *= x; return z; }\r\n\ttemplate < class T, enable_if_t < numeric_limits < T >::is_integer, int > = 0 >\r\n\tinline friend MI qpow(const MI &x, T y) { return x.qpow(y); }\r\n\tinline MI inv()const { assert(v); return qpow(P - 2); }\r\n\tinline friend MI inv(const MI &x) { return x.inv(); }\r\n\tinline friend istream &operator>>(istream &is, MI &x) { return is >> x.v; }\r\n\tinline friend ostream &operator<<(ostream &os, const MI &x) { return os << x.v; }\r\n};\r\nusing MI = Modint < 998244353 >;\r\nstruct query\r\n{\r\n\tint l, r, id;\r\n\tinline query(int l, int r, int id) : l(l), r(r), id(id) {}\r\n}; vector < query > qq[100009]; MI nw, wn, ans[100009], coef[100009];\r\nint n, m, q, a[100009], l, r, k, b, bl[100009], cnt[100009], al[100009];\r\nint main()\r\n{\r\n\tread(n, m, q);\r\n\tFor(i, 1, n) read(a[i]);\r\n\tFor(i, 1, q) read(l, r, k), qq[k].emplace_back(l, r, i);\r\n\tFor(i, 0, 100000) if ( qq[i].size() )\r\n\t{\r\n\t\tb = n / sqrtl((int)qq[i].size()), fill(al + 1, al + m + 1, i);\r\n\t\tFor(j, 1, n) bl[j] = ( j - 1 ) / b + 1, al[a[j]]++;\r\n\t\tsort(qq[i].begin(), qq[i].end(), [&](const query &x, const query &y) {\r\n\t\t\treturn bl[x.l] != bl[y.l] ? x.l < y.l : bl[x.l] & 1 ? x.r < y.r : y.r < x.r;\r\n\t\t}), fill(cnt + 1, cnt + m + 1, 0), l = 1, r = 0, nw = wn = *coef = 1;\r\n\t\tFor(j, 1, n) coef[j] = coef[j - 1] * ( (ll)m * i + j );\r\n\t\tfor ( auto [lp, rp, id] : qq[i] )\r\n\t\t{\r\n\t\t\tconst auto add = [&](int x) { nw *= al[a[x]] - cnt[a[x]]++; };\r\n\t\t\tconst auto del = [&](int x) { wn *= al[a[x]] - --cnt[a[x]]; };\r\n\t\t\twhile ( l > lp ) add(--l);\r\n\t\t\twhile ( r < rp ) add(++r);\r\n\t\t\twhile ( l < lp ) del(l++);\r\n\t\t\twhile ( r > rp ) del(r--);\r\n\t\t\tans[id] = nw / wn * coef[n - ( r - l + 1 )];\r\n\t\t}\r\n\t}\r\n\tFor(i, 1, q) println(ans[i].v);\r\n\treturn 0;\r\n}\r\n// \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f \u60f3\u4e0aGM\u634f\r\n// \u4f0a\u5a1c\u53ef\u7231\u634f \u4f0a\u5a1c\u8d34\u8d34\u634f"
}