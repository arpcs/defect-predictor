{
    "id": 219480905,
    "contestId": 1781,
    "creationTimeSeconds": 1692379389,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1781,
        "index": "E",
        "name": "Rectangle Shrinking",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "greedy",
            "implementation",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1781,
        "members": [
            {
                "handle": "FishNotebook"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1673784300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 45,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 16896000,
    "source": "// RADHASOAMI , WITH THE GRACE OF HUZUR I PROMISE TO FIGHT TILL THE LAST SECOND OF EVERY CONTEST AND CODE TO MY FULL POTENTIAL ......\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\n#include <numeric>\n\n#define ll long long int\n#define mod 1000000007\n\nusing namespace std;\n\n// ====================  FUNCTIONS FOR INPUT AND OUTPUT OF VECTORS =======================================================\n\nvoid input(vector < ll > &arr)\n{\n   for(int i = 0;i < arr.size();i++)\n      cin >> arr[i];\n}\n\nvoid output(vector < ll > &arr)\n{\n   for(int i = 0;i < arr.size();i++)\n      cout << arr[i] << \" \";\n\n   cout << \"\\n\";\n}\n\n// ==============================  FOR MATHEMATICAL FUNCTIONS =============================================================\n\nll gcd(ll a,ll b)\n{\n   if(b==0)\n     return a;\n\n   return gcd(b,a%b);\n}\n\nll power(ll a,ll b)\n{\n    if(b==0)\n      return 1;\n\n    if(b==1)\n      return a;\n\n    ll smallans=power(a,b/2);\n    ll myans=(smallans*smallans)%mod;\n\n    if((b&1))\n      myans=(myans*a)%mod;\n\n    return myans;\n}\n\nll multiply(ll a,ll b)\n{\n   ll ans=((a%mod)*(b%mod))%mod;\n\n   return ans;\n}\n\nll divide(ll a,ll b)\n{\n   return multiply(a,power(b,mod-2));\n}\n\n// ============================ SEGMENT TREE FOR DEFAULT MINIMUM QUERY ==================================================\n\nvoid manageLazy(vector < pair < ll, ll> > &tree, vector <ll> &lazy, ll idx)\n{\n  tree[2*idx].first += lazy[idx];\n  lazy[2*idx] += lazy[idx];\n  tree[2*idx + 1].first += lazy[idx]; \n  lazy[2*idx + 1] += lazy[idx];\n\n  lazy[idx] = 0;\n}\n\nvoid merge(vector < pair < ll, ll > > &tree, ll idx) {\n  if(tree[2 * idx].first <= tree[2 * idx + 1].first) {\n    tree[idx] = tree[2 * idx];\n  } else {\n    tree[idx] = tree[2 * idx + 1];\n  }\n}\n\nvoid build(vector <pair < ll, ll> > &tree, ll left, ll right, ll idx)\n{\n  if(left == right)\n  {\n    tree[idx].first = tree[idx].second = left;\n    return;\n  }\n\n  ll mid = (left + right) / 2;\n  build(tree , left, mid , 2 * idx);\n  build(tree , mid + 1 , right , 2 * idx + 1);\n  merge(tree, idx);\n}\n\nvoid update(vector < pair < ll, ll> > &tree, vector <ll> &lazy, ll tl, ll tr, ll l, ll r, ll idx, ll val)\n{\n   if(l > r)\n     return;\n\n   if(l == tl && tr == r)\n   {\n      tree[idx].first += val;\n      lazy[idx] += val;\n      return;\n   }\n\n   manageLazy(tree,lazy,idx);\n   ll mid = (tl + tr) / 2;\n\n   update(tree,lazy,tl,mid,l,min(r,mid),2*idx,val);\n   update(tree,lazy,mid + 1,tr,max(l,mid + 1),r,2*idx + 1,val);\n   merge(tree, idx);\n}\n\npair < ll, ll> query(vector <pair < ll, ll>> &tree,vector<ll> & lazy,ll tl,ll tr,ll l,ll r,ll idx)\n{\n  if(l > r)\n    return {1e18, 1e18};\n\n  if(l <= tl && tr <= r)\n    return tree[idx];\n\n  manageLazy(tree,lazy,idx);\n  ll mid = (tl + tr) / 2;\n\n  pair < ll, ll> a = query(tree,lazy,tl,mid,l,min(r,mid),2*idx);\n  pair < ll, ll> b = query(tree,lazy,mid + 1,tr,max(l,mid + 1),r,2*idx + 1);\n\n  return ((a.first <= b.first) ? a: b);\n}\n\n// ==================================  SPARSE TABLE FOR DEFAULT MINIMUM QUERY ==================================================\n\nvoid precompute_min(vector < vector < ll > > &sparsetable , vector < ll > &a)\n{\n   int n = sparsetable.size();\n   int p = sparsetable[0].size();\n\n   for(int i = 0;i < n;i++)  \n     sparsetable[i][0] = a[i];\n\n   for(int j = 1;j < p;j++)\n   {\n      for(int i = 0;i + (1 << j) <= n;i++)\n        sparsetable[i][j] = min(sparsetable[i][j - 1] , sparsetable[i + (1 << (j - 1))][j - 1]);\n   }\n   \n}\n\nll minquery(vector < vector < ll > > &sparsetable , vector < ll > &log , ll l , ll r)\n{\n   ll range = r - l + 1;\n   if(range == 0)  return sparsetable[l][0];\n   ll j = log[range];\n   return min(sparsetable[l][j] , sparsetable[r - (1 << j) + 1][j]);\n}\n\n//========================== BINARY INDEX TREE =========================================================================\n\nvoid update(vector<ll> &tree,ll index,ll val)\n{\n   index++;\n   while(index < tree.size())\n   {\n      tree[index]=(tree[index] + val) %mod;\n \n      index+=index&(-index);\n   }\n}\n \nll calculate(vector<ll> &tree,ll index)\n{\n   ll sum=0;\n   index++;\n   while(index > 0)\n   {\n      sum=(sum + tree[index])%mod;\n \n      index-=index&(-index);\n   }\n \n   return sum;\n}\n\n//=========================== FOR DISJOINT SET UNION ====================================================================\n\nll findpar(ll p,vector<ll> &parent)\n{\n    if(parent[p]==p)\n     return p;\n\n    parent[p]=findpar(parent[p],parent);\n\n    return parent[p];\n}\n\nvoid merge(ll a, ll b,vector<ll> &parent,vector<ll> &size_) \n{\n    a = findpar(a,parent);\n    b = findpar(b,parent);\n    \n    if (a != b) \n    {\n        if (size_[a] < size_[b])\n             swap(a, b);\n             \n        parent[b] = a;\n        size_[a] += size_[b];\n    }\n}\n\n//   ====================================== FOR STORING AND COUNTING THE PRIMES USING SIEVE ============================\n\nvoid sieve(vector<bool> &primes,vector<ll> &count)\n{\n   for(int i=2;i<primes.size();i++)\n   {\n      if(primes[i])\n      {\n         count.push_back(i);\n         for(int j=i*i;j<primes.size();j+=i)\n           primes[j]=false;\n      }\n   }\n}\n\n// =====================================================================================================================\n\nvoid solve() {\n  int n; cin >> n;\n  vector < ll > r1(n, 0), c1(n, 0), r2(n, 0), c2(n, 0);\n  for(int i = 0;i < n;i++) {\n    cin >> r1[i] >> c1[i] >> r2[i] >> c2[i];\n    c1[i]--;\n  }\n\n  vector < int > order(n, 0);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    return c1[i] < c1[j];\n  });\n\n  set < pair < int, int > > st;\n  ll ans = 0;\n  ll p1 = -1, p2 = -1;\n  for(int i: order) {\n    if(r1[i] == 1 && r2[i] == 2) {\n      if(p1 >= c2[i]) r1[i] = 2;\n      if(p2 >= c2[i]) r2[i] = 1;\n      if(r1[i] > r2[i]) continue;\n    }\n\n    if(r1[i] == 1 && r2[i] == 2) {\n      while(st.size()) {\n        if((*st.begin()).first * -1  >= c1[i]) {\n          c2[(*st.begin()).second] = c1[i];\n          st.erase(st.begin());\n        } else {\n          break;\n        }\n      }\n\n      ans += (c2[i] - max(c1[i], p1)) + (c2[i] - max(c1[i], p2));\n      p1 = p2 = c2[i];\n      st.insert({-1 * c2[i], i});\n      continue;\n    }\n\n    if(r1[i] == 1) {\n      c1[i] = max(c1[i], p1);\n      p1 = max(c2[i], p1);\n    } else {\n      c1[i] = max(c1[i], p2);\n      p2 = max(c2[i], p2);\n    }\n\n    if(c1[i] < c2[i]) {\n      ans += c2[i] - c1[i];\n      st.insert({-1 * c2[i], i});\n    }\n  }\n\n  cout << ans << \"\\n\";\n  for(int i = 0;i < n;i++) {\n    c1[i]++;\n    if(r1[i] <= r2[i] && c1[i] <= c2[i]) {\n      cout << r1[i] << \" \" << c1[i] << \" \" << r2[i] << \" \" << c2[i] << \"\\n\";\n    } else {\n      cout << 0 << \" \" << 0 << \" \" << 0 << \" \" << 0 << \"\\n\";\n    }\n  }\n}\n\nint main()\n{\n   ios_base::sync_with_stdio(false); \n   cin.tie(NULL);\n   cout.tie(NULL);\n   #ifndef ONLINE_JUDGE\n      freopen(\"input2.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n   #endif\n\n   int t;\n   cin >> t;\n\n   while(t--)\n   {\n\n      solve();\n      \n   }\n\n   return 0;\n}"
}