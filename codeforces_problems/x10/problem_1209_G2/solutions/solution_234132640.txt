{
    "id": 234132640,
    "contestId": 1209,
    "creationTimeSeconds": 1700849014,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1209,
        "index": "G2",
        "name": "Into Blocks (hard version)",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 3200,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1209,
        "members": [
            {
                "handle": "null_awe"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1568466300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define pii pair<int, int>\r\n\r\nconst int MAX_N = 200000;\r\n\r\nstruct LazySegtree {\r\n\r\n  int n;\r\n  vector<pii> t;\r\n  stack<pair<int, pii>> revisions;\r\n\r\n  LazySegtree() {}\r\n\r\n  LazySegtree(int n) : n(n), t(4 * n, {-1, -1}) {}\r\n\r\n  void addCheckpoint() {\r\n    revisions.push({-1, {-1, -1}});\r\n  }\r\n\r\n  void push(int v, int tl, int tr) {\r\n    if (t[v].first < 0 || tl == tr) return;\r\n    int l = 2 * v, r = 2 * v + 1;\r\n    if (t[l] != t[v]) revisions.push({l, t[l]});\r\n    if (t[r] != t[v]) revisions.push({r, t[r]});\r\n    t[l] = t[r] = t[v];\r\n  }\r\n\r\n  void upd(int v, int tl, int tr, int l, int r, int xl, int xr) {\r\n    if (l > r) return;\r\n    if (tl == l && tr == r) {\r\n      if (t[v] != {xl, xr}) revisions.push({v, t[v]});\r\n      t[v] = {xl, xr};\r\n      return;\r\n    }\r\n    push(v, tl, tr);\r\n    int m = (tl + tr) / 2;\r\n    upd(2 * v, tl, m, l, min(m, r), xl, xr);\r\n    upd(2 * v + 1, m + 1, tr, max(m + 1, l), r, xl, xr);\r\n  }\r\n\r\n  void upd(int l, int r) {\r\n    upd(1, 0, n - 1, l, r, l, r);\r\n  }\r\n\r\n  pii qry(int v, int tl, int tr, int x) {\r\n    if (tl == tr) return t[v];\r\n    push(v, tl, tr);\r\n    int m = (tl + tr) / 2;\r\n    if (x <= m) return qry(2 * v, tl, m, x);\r\n    return qry(2 * v + 1, m + 1, tr, x);\r\n  }\r\n\r\n  pii qry(int x) {\r\n    return qry(1, 0, n - 1, x);\r\n  }\r\n\r\n  void rollback() {\r\n    while (revisions.size()) {\r\n      pair<int, pii> p = revisions.top(); revisions.pop();\r\n      if (p.first < 0) break;\r\n      t[p.first] = p.second;\r\n    }\r\n  }\r\n};\r\n\r\nstruct LazySumSegtree {\r\n\r\n  int n;\r\n  vector<int> t;\r\n  stack<pii> revisions;\r\n\r\n  LazySumSegtree() {}\r\n\r\n  LazySumSegtree(int n) : n(n), t(4 * n) {}\r\n\r\n  void addCheckpoint() {\r\n    revisions.push({-1, -1});\r\n  }\r\n\r\n  void push(int v, int tl, int tr) {\r\n    if (t[v] || tl == tr) return;\r\n    int l = 2 * v, r = 2 * v + 1;\r\n    if (t[l] != 0) revisions.push({l, t[l]});\r\n    if (t[r] != 0) revisions.push({r, t[r]});\r\n    t[l] = t[r] = 0;\r\n  }\r\n\r\n  void upd(int v, int tl, int tr, int l, int r, int x) {\r\n    if (l > r) return;\r\n    if (tl == l && tr == r) {\r\n      if (t[v] != x) revisions.push({v, t[v]});\r\n      t[v] = x;\r\n      return;\r\n    }\r\n    push(v, tl, tr);\r\n    int m = (tl + tr) / 2;\r\n    upd(2 * v, tl, m, l, min(m, r), x);\r\n    upd(2 * v + 1, m + 1, tr, max(m + 1, l), r, x);\r\n    if (t[v] != t[2 * v] + t[2 * v + 1]) revisions.push({v, t[v]});\r\n    t[v] = t[2 * v] + t[2 * v + 1];\r\n  }\r\n\r\n  void upd(int l, int r, int x) {\r\n    assert(l == r || x == 0);\r\n    upd(1, 0, n - 1, l, r, x);\r\n  }\r\n\r\n  int qry(int v, int tl, int tr, int l, int r) {\r\n    if (l > r || t[v] == 0) return 0;\r\n    if (tl == l && tr == r) return t[v];\r\n    push(v, tl, tr);\r\n    int m = (tl + tr) / 2;\r\n    return qry(2 * v, tl, m, l, min(m, r)) + qry(2 * v + 1, m + 1, tr, max(m + 1, l), r);\r\n  }\r\n\r\n  int qry(int l, int r) {\r\n    return qry(1, 0, n - 1, l, r);\r\n  }\r\n\r\n  void rollback() {\r\n    while (revisions.size()) {\r\n      pii p = revisions.top(); revisions.pop();\r\n      if (p.first < 0) break;\r\n      t[p.first] = p.second;\r\n    }\r\n  }\r\n};\r\n\r\nstruct MaxSegtree {\r\n\r\n  int n;\r\n  vector<int> t;\r\n  stack<pii> revisions;\r\n\r\n  MaxSegtree() {}\r\n\r\n  MaxSegtree(int n) : n(n), t(2 * n) {}\r\n\r\n  void addCheckpoint() {\r\n    revisions.push({-1, -1});\r\n  }\r\n\r\n  void upd(int p, int v) {\r\n    if (t[p + n] != v) revisions.push({p + n, t[p + n]});\r\n    for (t[p += n] = v; p > 1; p >>= 1) {\r\n      if (t[p >> 1] != max(t[p], t[p ^ 1])) revisions.push({p >> 1, t[p >> 1]});\r\n      t[p >> 1] = max(t[p], t[p ^ 1]);\r\n    }\r\n  }\r\n\r\n  int qry(int l, int r) {\r\n    int ans = 0;\r\n    for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\r\n      if (l & 1) ans = max(ans, t[l++]);\r\n      if (r & 1) ans = max(ans, t[--r]);\r\n    }\r\n    return ans;\r\n  }\r\n\r\n  int qry(int p) {\r\n    return t[p + n];\r\n  }\r\n\r\n  void rollback() {\r\n    while (revisions.size()) {\r\n      pii p = revisions.top(); revisions.pop();\r\n      if (p.first < 0) break;\r\n      t[p.first] = p.second;\r\n    }\r\n  }\r\n};\r\n\r\nstruct MagicWithRollback {\r\n\r\n  int n;\r\n  LazySegtree subsections;\r\n  LazySumSegtree ans;\r\n  MaxSegtree maxs;\r\n  vector<int> begin;\r\n  stack<pii> revisions;\r\n\r\n  MagicWithRollback() {}\r\n\r\n  MagicWithRollback(int n) : n(n), subsections(n), ans(n), maxs(n), begin(MAX_N, -1) {\r\n    for (int i = 0; i < n; ++i) subsections.upd(i, i);\r\n  }\r\n\r\n  void addCheckpoint() {\r\n    subsections.addCheckpoint();\r\n    ans.addCheckpoint();\r\n    maxs.addCheckpoint();\r\n    revisions.push({-1, -1});\r\n  }\r\n\r\n  void addAt(int p, int v) {\r\n    // individual stuff\r\n    if (begin[v] < 0) {\r\n      revisions.push({v, begin[v]});\r\n      begin[v] = p;\r\n    }\r\n    int cur = maxs.qry(begin[v]) + 1;\r\n    maxs.upd(begin[v], 0);\r\n    maxs.upd(min(begin[v], p), cur);\r\n    // group stuff\r\n    pii orig = subsections.qry(p), nr = subsections.qry(begin[v]);\r\n    int l = min(orig.first, nr.first), r = max(orig.second, nr.second);\r\n    ans.upd(l, r, 0);\r\n    ans.upd(l, l, maxs.qry(l, r));\r\n    subsections.upd(l, r);\r\n    // finalize\r\n    revisions.push({v, begin[v]});\r\n    begin[v] = min(begin[v], p);\r\n  }\r\n\r\n  void rollback() {\r\n    subsections.rollback();\r\n    ans.rollback();\r\n    maxs.rollback();\r\n    while (revisions.size()) {\r\n      pii p = revisions.top(); revisions.pop();\r\n      if (p.first < 0) break;\r\n      begin[p.first] = p.second;\r\n    }\r\n  }\r\n\r\n  int getAns() {\r\n    return n - ans.qry(0, n - 1);\r\n  }\r\n};\r\n\r\nstruct Dynacon {\r\n\r\n  int n;\r\n  vector<vector<pii>> t;\r\n  MagicWithRollback mwr;\r\n\r\n  Dynacon() {}\r\n\r\n  Dynacon(int n, int q) : n(q), t(4 * q), mwr(n) {}\r\n\r\n  void upd(int v, int tl, int tr, int l, int r, int p, int val) {\r\n    if (l > r) return;\r\n    if (tl == l && tr == r) {\r\n      t[v].push_back({p, val});\r\n      return;\r\n    }\r\n    int m = (tl + tr) / 2;\r\n    upd(2 * v, tl, m, l, min(m, r), p, val);\r\n    upd(2 * v + 1, m + 1, tr, max(m + 1, l), r, p, val);\r\n  }\r\n\r\n  void upd(int l, int r, int p, int v) {\r\n    upd(1, 0, n - 1, l, r, p, v);\r\n  }\r\n\r\n  void dfs(int v, int tl, int tr) {\r\n    mwr.addCheckpoint();\r\n    for (pii p : t[v]) mwr.addAt(p.first, p.second);\r\n    if (tl == tr) {\r\n      cout << mwr.getAns() << '\\n';\r\n    } else {\r\n      int m = (tl + tr) / 2;\r\n      dfs(2 * v, tl, m);\r\n      dfs(2 * v + 1, m + 1, tr);\r\n    }\r\n    mwr.rollback();\r\n  }\r\n\r\n  void dfs() {\r\n    dfs(1, 0, n - 1);\r\n  }\r\n};\r\n\r\nint main() {\r\n  ios_base::sync_with_stdio(false); cin.tie(NULL);\r\n  int n, q; cin >> n >> q;\r\n  Dynacon dynacon(n, q + 1);\r\n  vector<pii> arr(n);\r\n  for (int i = 0; i < n; ++i) cin >> arr[i].first;\r\n  for (int i = 0; i < n; ++i) --arr[i].first;\r\n  for (int t = 1; t <= q; ++t) {\r\n    int p, x; cin >> p >> x; --p, --x;\r\n    if (arr[p].first == x) continue;\r\n    dynacon.upd(arr[p].second, t - 1, p, arr[p].first);\r\n    arr[p] = {x, t};\r\n  }\r\n  for (int i = 0; i < n; ++i) dynacon.upd(arr[i].second, q, i, arr[i].first);\r\n  dynacon.dfs();\r\n  return 0;\r\n}"
}