{
    "id": 213943640,
    "contestId": 1379,
    "creationTimeSeconds": 1689443278,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1379,
        "index": "E",
        "name": "Inverse Genealogy",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2800,
        "tags": [
            "constructive algorithms",
            "divide and conquer",
            "dp",
            "math",
            "trees"
        ]
    },
    "author": {
        "contestId": 1379,
        "members": [
            {
                "handle": "Be_dos"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1595149200
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 120,
    "timeConsumedMillis": 78,
    "memoryConsumedBytes": 5017600,
    "source": "#include <iostream>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <deque>\n#include <stack>\n#include <unordered_set>\n#include <sstream>\n#include <cstring>\n#include <iomanip>\n#include <queue>\n#include <unordered_map>\n#include <random>\n#include <cfloat>\n#include <chrono>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <immintrin.h>\n\nvoid build_tree(int32_t n, int32_t k, std::pair<int32_t, int32_t>** dp, int32_t v, std::vector<int32_t>* children, int32_t& next_node) {\n    if(n == 1)\n        return;\n\n    children[v].push_back(next_node++);\n    children[v].push_back(next_node++);\n    build_tree(dp[n][k].first, dp[n][k].second, dp, children[v][0], children, next_node);\n    if(dp[n][k].first * 2 <= (n - 1 - dp[n][k].first) || (n - 1 - dp[n][k].first) * 2 <= dp[n][k].first)\n        build_tree(n - dp[n][k].first - 1, k - dp[n][k].second - 1, dp, children[v][1], children, next_node);\n    else\n        build_tree(n - dp[n][k].first - 1, k - dp[n][k].second, dp, children[v][1], children, next_node);\n}\n\nvoid solve_dp(int32_t n, int32_t k) {\n    std::pair<int32_t, int32_t>** dp = new std::pair<int32_t, int32_t>*[n + 1];\n    for(int32_t i = 1; i <= n; i+=2) { // size big\n        dp[i] = new std::pair<int32_t, int32_t>[k + 1];\n        if(i == 1) {\n            dp[i][0] = {-2, -2};\n            dp[i][1] = {-1, -1};\n            continue;\n        }\n\n        for(int32_t j = 0; j <= std::min(i, k); j++) { // bad big\n            dp[i][j] = {-1, -1};\n            for(int32_t p = 1; p <= i - 2; p+=2) // size small\n                for(int32_t q = 0; q <= std::min(p, j); q++) { // bad small\n                    if(dp[p][q].first == -1)\n                        continue;\n\n                    if((i - 1 - p) * 2 <= p || p * 2 <= (i - 1 - p)) {\n                        if(j - q - 1 >= 0 && j - q - 1 <= i - p - 1 && dp[i - p - 1][j - q - 1].first != -1)\n                            dp[i][j] = {p, q};\n                    } else {\n                        if(j - q >= 0 && j - q <= i - p - 1 && dp[i - p - 1][j - q].first != -1)\n                            dp[i][j] = {p, q};\n                    }\n                }\n        }\n    }\n\n    if(dp[n][k].first == -1) {\n        std::cout << \"NO\";\n        return;\n    }\n\n    std::cout << \"YES\" << \"\\n\";\n    std::vector<int32_t>* children = new std::vector<int32_t>[n];\n    int32_t next_node = 1;\n    build_tree(n, k, dp, 0, children, next_node);\n\n    int32_t* parents = new int32_t[n];\n    parents[0] = -1;\n    for(int32_t i = 0; i < n; i++)\n        for(int32_t j = 0; j < children[i].size(); j++)\n            parents[children[i][j]] = i;\n\n    for(int32_t i = 0; i < n; i++)\n        std::cout << parents[i] + 1 << \" \";\n}\n\nvoid change_imbal(int32_t v, int32_t* parents, std::vector<int32_t>* children, int32_t* subtree_sizes, int32_t& num_imbalanced, int32_t coeff) {\n    bool imbalanced;\n    if(children[v].size() == 2)\n        imbalanced = subtree_sizes[children[v][0]] * 2 <= subtree_sizes[children[v][1]] || subtree_sizes[children[v][1]] * 2 <= subtree_sizes[children[v][0]];\n    else\n        imbalanced = false;\n    if(imbalanced)\n        num_imbalanced += coeff;\n\n    if(parents[v] != -1)\n        change_imbal(parents[v], parents, children, subtree_sizes, num_imbalanced, coeff);\n}\n\nvoid recalc(int32_t v, int32_t* parents, std::vector<int32_t>* children, int32_t* subtree_sizes) {\n    if(children[v].size() == 2)\n        subtree_sizes[v] = 1 + subtree_sizes[children[v][0]] + subtree_sizes[children[v][1]];\n    else\n        subtree_sizes[v] = 1;\n\n    if(parents[v] != -1)\n        recalc(parents[v], parents, children, subtree_sizes);\n}\n\nvoid add_nodes(int32_t v, std::vector<int32_t>* children, int32_t* parents, std::deque<int32_t>& active, int32_t& next_node,\n               int32_t* subtree_sizes, int32_t& num_imbalanced) {\n    change_imbal(v, parents, children, subtree_sizes, num_imbalanced, -1);\n\n    children[v].push_back(next_node++);\n    children[v].push_back(next_node++);\n    parents[children[v][0]] = v;\n    parents[children[v][1]] = v;\n    active.push_back(children[v][0]);\n    active.push_back(children[v][1]);\n\n    subtree_sizes[children[v][0]] = 1;\n    subtree_sizes[children[v][1]] = 1;\n    recalc(v, parents, children, subtree_sizes);\n    change_imbal(v, parents, children, subtree_sizes, num_imbalanced, 1);\n}\n\nvoid remove_nodes(int32_t v, std::vector<int32_t>* children, int32_t* parents, int32_t& next_node,\n                  int32_t* subtree_sizes, int32_t& num_imbalanced) {\n    change_imbal(v, parents, children, subtree_sizes, num_imbalanced, -1);\n\n    children[v].clear();\n    next_node -= 2;\n\n    recalc(v, parents, children, subtree_sizes);\n    change_imbal(v, parents, children, subtree_sizes, num_imbalanced, 1);\n}\n\nstd::mt19937 rng;\nvoid solve_small(int32_t n, int32_t k) {\n    std::vector<int32_t>* children = new std::vector<int32_t>[n];\n    int32_t* parents = new int32_t[n];\n    parents[0] = -1;\n    std::deque<int32_t> active;\n    active.push_back(0);\n    int32_t next_node = 1;\n\n    int32_t num_imbalanced = 0;\n    int32_t* subtree_sizes = new int32_t[n];\n    subtree_sizes[0] = 1;\n    for(int32_t i = 0; i < n / 2 - 15; i++) {\n        int32_t v = active.front();\n        active.pop_front();\n\n        add_nodes(v, children, parents, active, next_node, subtree_sizes, num_imbalanced);\n    }\n\n    bool* alive_active = new bool[n];\n    for(int32_t i = 0; i < n; i++)\n        alive_active[i] = true;\n    for(int32_t t = 0; t < 10'000; t++) {\n        std::vector<int32_t> added;\n        std::deque<int32_t> new_active;\n\n        int32_t fixed = rng() % 16;\n        for(int32_t i = 0; i < fixed; i++) {\n            int32_t v = active[i];\n            alive_active[v] = false;\n\n            add_nodes(v, children, parents, new_active, next_node, subtree_sizes, num_imbalanced);\n            added.push_back(v);\n        }\n\n        for(int32_t i = 0; i < 15 - fixed; i++) {\n            if(!new_active.empty() && rng() % 5 == 0) {\n                int32_t ind = rng() % new_active.size();\n                int32_t v = new_active[ind];\n                new_active.erase(new_active.begin() + ind);\n\n                add_nodes(v, children, parents, new_active, next_node, subtree_sizes, num_imbalanced);\n                added.push_back(v);\n            } else {\n                int32_t ind = rng() % active.size();\n                while(!alive_active[active[ind]])\n                    ind = rng() % active.size();\n\n                int32_t v = active[ind];\n                alive_active[v] = false;\n\n                add_nodes(v, children, parents, new_active, next_node, subtree_sizes, num_imbalanced);\n                added.push_back(v);\n            }\n        }\n\n        if(num_imbalanced == k) {\n            std::cout << \"YES\" << \"\\n\";\n\n            for(int32_t i = 0; i < n; i++)\n                std::cout << parents[i] + 1 << \" \";\n            return;\n        }\n\n        for(int32_t i = 14; i >= 0; i--) {\n            remove_nodes(added[i], children, parents, next_node, subtree_sizes, num_imbalanced);\n            alive_active[added[i]] = true;\n        }\n    }\n\n    std::cout << \"NO\" << \"\\n\";\n}\n\nvoid build_perfect(std::vector<int32_t>* children, int32_t* parents, int32_t v, int32_t depth_cur, int32_t depth_target, int32_t& next_node) {\n    if(depth_cur == depth_target)\n        return;\n\n    children[v].push_back(next_node++);\n    children[v].push_back(next_node++);\n    parents[children[v][0]] = v;\n    parents[children[v][1]] = v;\n\n    build_perfect(children, parents, children[v][0], depth_cur + 1, depth_target, next_node);\n    build_perfect(children, parents, children[v][1], depth_cur + 1, depth_target, next_node);\n}\n\nvoid solve_large(int32_t n, int32_t k) {\n    if(k >= n / 2) {\n        std::cout << \"NO\" << \"\\n\";\n        return;\n    }\n\n    std::vector<int32_t>* children = new std::vector<int32_t>[n];\n    int32_t* parents = new int32_t[n];\n    parents[0] = -1;\n\n    int32_t last = 0;\n    std::vector<int32_t> roots;\n    int32_t next_node = 1;\n    for(int32_t i = 0; i <= k; i++) {\n        children[last].push_back(next_node++);\n        children[last].push_back(next_node++);\n        parents[children[last][0]] = last;\n        parents[children[last][1]] = last;\n\n        roots.push_back(children[last][0]);\n        last = children[last][1];\n    }\n    roots.push_back(last);\n\n    int32_t to_add = n - next_node;\n    if(to_add < 0) {\n        std::cout << \"NO\" << \"\\n\";\n        return;\n    }\n    if(to_add == 2) {\n        build_perfect(children, parents, roots[0], 1, 2, next_node);\n        std::cout << \"YES\" << \"\\n\";\n        for(int32_t i = 0; i < n; i++)\n            std::cout << parents[i] + 1 << \" \";\n        return;\n    }\n    int32_t next_root_ind = roots.size() - 1;\n    int32_t prev_depth = -1;\n    while(to_add > 0) {\n        if(next_root_ind == roots.size() - 1) {\n            int32_t size = 1, depth = 1;\n            while((size * 2 + 1) * 2 - 2 <= to_add) {\n                size += size + 1;\n                depth++;\n            }\n            prev_depth = depth;\n            build_perfect(children, parents, roots[next_root_ind], 1, depth, next_node);\n            build_perfect(children, parents, roots[next_root_ind - 1], 1, depth, next_node);\n            next_root_ind -= 2;\n            to_add -= (size - 1) * 2;\n        } else {\n            int32_t size = 1, depth = 1;\n            while((size * 2 + 1) - 1 <= to_add && depth + 1 <= prev_depth) {\n                size += size + 1;\n                depth++;\n            }\n            prev_depth = depth;\n            build_perfect(children, parents, roots[next_root_ind], 1, depth, next_node);\n            next_root_ind--;\n            to_add -= size - 1;\n        }\n    }\n\n    std::cout << \"YES\" << \"\\n\";\n    for(int32_t i = 0; i < n; i++)\n        std::cout << parents[i] + 1 << \" \";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int32_t n, k;\n    std::cin >> n >> k;\n\n    if(n % 2 == 0) {\n        std::cout << \"NO\";\n        return 0;\n    }\n\n    if(n <= 400 && k <= 20)\n        solve_dp(n, k);\n    else if(k <= 20)\n        solve_small(n, k);\n    else\n        solve_large(n, k);\n    return 0;\n}\n\n\n\n\n\n\n\n"
}