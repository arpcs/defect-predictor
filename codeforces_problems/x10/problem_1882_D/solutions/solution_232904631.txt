{
    "id": 232904631,
    "contestId": 1882,
    "creationTimeSeconds": 1700082081,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1882,
        "index": "D",
        "name": "Tree XOR",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 1900,
        "tags": [
            "bitmasks",
            "dfs and similar",
            "dp",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1882,
        "members": [
            {
                "handle": "shankarbanerjee63"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1695652500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 30,
    "timeConsumedMillis": 2277,
    "memoryConsumedBytes": 103526400,
    "source": "#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n#define Fo(i,n) for(int i=0;i<n;i++)\r\n#define fo(i,k,n) for(int i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\r\n#define ll long long\r\n#define si(x) scanf(\"%d\",&x)\r\n#define sl(x) scanf(\"%lld\",&x)\r\n#define ss(s) scanf(\"%s\",s)\r\n#define pi(x) printf(\"%d\\n\",x)\r\n#define pl(x) printf(\"%lld\\n\",x)\r\n#define ps(s) printf(\"%s\\n\",s)\r\n#define deb(x) cout << #x << \"=\" << x << endl\r\n#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\r\n#define pb push_back\r\n#define mp make_pair\r\n#define F first\r\n#define S second\r\n#define all(x) x.begin(), x.end()\r\n#define clr(x) memset(x, 0, sizeof(x))\r\n#define sortall(x) sort(all(x))\r\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\r\n#define PI 3.1415926535897932384626\r\ntypedef pair<int, int>  pii;\r\ntypedef pair<ll, ll>  pl;\r\ntypedef vector<int>   vi;\r\ntypedef vector<ll>    vl;\r\ntypedef vector<pii>   vpii;\r\ntypedef vector<pl>    vpl;\r\ntypedef vector<vi>    vvi;\r\ntypedef vector<vl>    vvl;\r\n\r\n// int rng(int lim) {\r\n//   uniform_int_distribution<int> uid(0, lim - 1);\r\n//   return uid(rang);\r\n// }\r\nll mpow(ll base, ll exp);\r\nll mpow(ll base, ll exp, ll m);\r\nll power(ll a, ll b);\r\n\r\n\r\nconst ll mod =  998244353 ;\r\n//const int N = 3e5, M = N;\r\nvi g[1000001];\r\n\r\n\r\n//int cnt[100002];\r\n\r\n// map<pii,int> w;\r\n//int vis[300001];\r\n// ll res[300001];\r\n// ll sum[300001];\r\n\r\n// ll sz[300001];\r\n//int dist[300001];\r\n\r\n//=====================================================================\r\n\r\n// ll fact[200001];\r\n// ll fact_inv[200001];\r\n\r\n// void pre_calc()\r\n// {\r\n//   int maxN=10000;\r\n//   fact[0]=1;\r\n//   fact_inv[0]=mpow(1,mod-2);\r\n\r\n//   for(ll i=1;i<=maxN;i++)\r\n//   {\r\n//     fact[i]=(fact[i-1]*i)%mod;\r\n//     fact_inv[i]=mpow(fact[i],mod-2);\r\n//   }\r\n// }\r\n\r\n// ll ncr(ll n,ll r)\r\n// {\r\n\r\n//   if(r>n)\r\n//     return 0;\r\n//   ll res=fact[n];\r\n//   res=(res*fact_inv[r])%mod;\r\n//   res=(res*fact_inv[n-r])%mod;\r\n//   return res;\r\n// }\r\nstruct node\r\n{\r\n  set<int> s;\r\n};\r\n// struct operatr\r\n// {\r\n//   int a,d;\r\n// };\r\n\r\nstruct resObj {\r\n  ll val, idx;\r\n};\r\nresObj arr[300001];\r\nresObj res[1200003];//{lvl,v}\r\nstruct segTree\r\n{\r\n\r\n  //ll operation_arr[1203];\r\n  void init(int x, int lo, int hi)\r\n  {\r\n    //operation_arr[x]=NO_OPERATION;\r\n\r\n\r\n    if (lo == hi) {\r\n      res[x] = arr[lo];\r\n      return;\r\n\r\n    }\r\n\r\n    int mid = (lo + hi) / 2;\r\n    init(2 * x, lo, mid);\r\n    init(2 * x + 1, mid + 1, hi);\r\n\r\n    //update(x,lo,hi);\r\n\r\n    update_point(x);\r\n  }\r\n\r\n  ll merge_operation(ll a, ll b) //apply operation b to a\r\n  {\r\n    //deb(b);\r\n\r\n    return (a ^ b);\r\n  }\r\n\r\n\r\n  // rs operate(rs a,int o,int lo,int hi)\r\n  // {\r\n  //   rs res;\r\n  //   res.s=0;\r\n\r\n  //   for(int j=0;j<=20;j++)\r\n  //   {\r\n  //     int v=(1<<j);\r\n  //     ll on_cnt=a.cnt[j];\r\n  //     ll off_cnt=(hi-lo+1)-on_cnt;\r\n\r\n  //     if((v&o)!=0)\r\n  //     {\r\n  //       res.s=res.s+v*off_cnt;\r\n  //       res.cnt[j]=off_cnt;\r\n  //     }\r\n  //     else\r\n  //     {\r\n  //       res.s=res.s+v*on_cnt;\r\n  //       res.cnt[j]=on_cnt;\r\n  //     }\r\n\r\n  //   }\r\n\r\n  //   return res;\r\n  // }\r\n\r\n  resObj merge_results(resObj a, resObj b)\r\n  {\r\n    if (a.val < b.val)\r\n      return a;\r\n    return b;\r\n  }\r\n\r\n\r\n  // void modify(int x,int lo, int hi, int l, int r,ll val)\r\n  // {\r\n  //   prop(x,lo,hi);\r\n\r\n  //   if(lo>=l&&hi<=r){\r\n\r\n  //     operation_arr[x]=merge_operation(operation_arr[x],val);\r\n  //     update(x,lo,hi);\r\n\r\n  //     return;\r\n  //   }\r\n\r\n  //   if(hi<l||lo>r)\r\n  //     return;\r\n\r\n  //   int mid=(lo+hi)/2;\r\n  //   modify(2*x,lo,mid,l,r,val);\r\n  //   modify(2*x+1,mid+1,hi,l,r,val);\r\n  //   update(x,lo,hi);\r\n  // }\r\n\r\n\r\n  // ll get_sum(int x,int lo,int hi,int l,int r)\r\n  // {\r\n  //   if(lo>=l&&hi<=r)\r\n  //     return res[x];\r\n\r\n  //   if(lo>r||hi<l)\r\n  //     return 0;\r\n\r\n  //   int mid=(lo+hi)/2;\r\n  //   return get_sum(2*x,lo,mid,l,r)+get_sum(2*x+1,mid+1,hi,l,r);\r\n  // }\r\n\r\n\r\n\r\n  // void point_change(int x,int lo,int hi,int l,int r)\r\n  // {\r\n\r\n\r\n  //   if(lo>r||hi<l)\r\n  //     return;\r\n\r\n  //   if(res[x]<3)\r\n  //     return;\r\n\r\n  //   if(lo==hi)\r\n  //   {\r\n\r\n  //     res[x]=cnt[res[x]];\r\n  //     res1[x]=cnt[res1[x]];\r\n  //     return;\r\n  //   }\r\n\r\n\r\n\r\n  //   int mid=(lo+hi)/2;\r\n\r\n  //   point_change(2*x,lo,mid,l,r);\r\n  //   point_change(2*x+1,mid+1,hi,l,r);\r\n\r\n  //   update_point1(x);\r\n  //   update_point(x);\r\n  // }\r\n\r\n  void point_modify(int x, int lo, int hi, int pos, resObj val)\r\n  {\r\n    if (lo == hi)\r\n    {\r\n      res[x] = val;\r\n      return;\r\n    }\r\n\r\n    int mid = (lo + hi) / 2;\r\n\r\n\r\n    if (pos <= mid)\r\n      point_modify(2 * x, lo, mid, pos, val);\r\n    else\r\n      point_modify(2 * x + 1, mid + 1, hi, pos, val);\r\n    update_point(x);\r\n    //update(x);\r\n  }\r\n\r\n  // ll get_val(int x,int lo,int hi,int pos)\r\n  // {\r\n  //   if(lo==hi)\r\n  //     return res[x];\r\n\r\n  //   int mid=(lo+hi)/2;\r\n\r\n  //   if(pos<=mid)\r\n  //     return get_val(2*x,lo,mid,pos);\r\n  //   else\r\n  //     return get_val(2*x+1,mid+1,hi,pos);\r\n\r\n  // }\r\n\r\n  // ll min_query(int x,int lo,int hi,int l,int r)\r\n  // {\r\n  //   prop(x,lo,hi);\r\n\r\n  //   if(lo>=l&&hi<=r)\r\n  //     return merge_operation(res[x],operation_arr[x]);\r\n\r\n\r\n\r\n  //   int mid=(hi+lo)/2;\r\n  //   ll res;\r\n\r\n  //   if(r<=mid)\r\n  //      res=min_query(2*x,lo,mid,l,r);\r\n  //   else if(l>mid)\r\n  //     res= min_query(2*x+1,mid+1,hi,l,r);\r\n  //   else\r\n  //     res= min(query(2*x,lo,mid,l,r),query(2*x+1,mid+1,hi,l,r));\r\n\r\n\r\n  //   return res;\r\n  // }\r\n\r\n  // ll get_idx(int x,int lo,int hi,ll v)\r\n  // {\r\n  //   if(res[x]<v)\r\n  //     return hi+1;\r\n\r\n  //   if(lo==hi)\r\n  //     return lo;\r\n\r\n  //   int mid=(lo+hi)/2;\r\n\r\n  //   if(res[2*x]>=v)\r\n  //     return get_idx(2*x,lo,mid,v);\r\n  //   else\r\n  //     return get_idx(2*x+1,mid+1,hi,v);\r\n  // }\r\n\r\n\r\n\r\n\r\n  resObj update_point_logic(resObj a, resObj b) {\r\n    if (a.val < b.val)\r\n      return a;\r\n    return b;\r\n  }\r\n\r\n  void update_point(int x)\r\n  {\r\n    res[x] = update_point_logic(res[2 * x], res[2 * x + 1]);\r\n  }\r\n\r\n\r\n  resObj query(int x, int lo, int hi, int l, int r)\r\n  {\r\n    //prop(x,lo,hi);\r\n\r\n    if (lo >= l && hi <= r)\r\n    {\r\n      return res[x];\r\n    }\r\n\r\n\r\n\r\n    int mid = (hi + lo) / 2;\r\n    resObj res;\r\n\r\n    if (r <= mid)\r\n      res = query(2 * x, lo, mid, l, r);\r\n    else if (l > mid)\r\n      res = query(2 * x + 1, mid + 1, hi, l, r);\r\n    else\r\n      res = merge_results(query(2 * x, lo, mid, l, r), query(2 * x + 1, mid + 1, hi, l, r));\r\n\r\n\r\n    return res;\r\n\r\n  }\r\n\r\n  // ll find_pt(int x,int lo,int hi,ll val)\r\n  // {\r\n  //   if(lo==hi)\r\n  //     return lo;\r\n\r\n  //   int mid=(hi+lo)/2;\r\n  //   ll m1,m2;\r\n  //   prop(x,lo,hi);\r\n\r\n  //   m1=merge_operation(res[2*x],operation_arr[2*x]);\r\n  //   m2=merge_operation(res[2*x+1],operation_arr[2*x+1]);\r\n\r\n  //   if(m2==val)\r\n  //     return find_pt(2*x+1,mid+1,hi,val);\r\n  //   else\r\n  //     return find_pt(2*x,lo,mid,val);\r\n  // }\r\n\r\n\r\n  // int kth_one(int x,int lo,int hi,int k)\r\n  // {\r\n  //   if(lo==hi)\r\n  //     return lo;\r\n\r\n  //   int v1=res[2*x];\r\n  //   int mid=(lo+hi)/2;\r\n\r\n  //   if(k<=v1)\r\n  //     return kth_one(2*x,lo,mid,k);\r\n  //   else\r\n  //     return kth_one(2*x+1,mid+1,hi,k-v1);\r\n  // }\r\n\r\n\r\n\r\n\r\n  // ll point_query(int x,int lo, int hi, int p)\r\n  // {\r\n  //   prop(x,lo,hi);\r\n\r\n  //   if(lo==hi)\r\n  //   {\r\n  //     //deb2(arr[lo],operation_arr[x]);\r\n  //     return operate(arr[lo],operation_arr[x],lo,lo);\r\n  //   }\r\n\r\n  //   int mid=(lo+hi)/2;\r\n\r\n\r\n  //   if(p<=mid)\r\n  //     return point_query(2*x,lo,mid,p);\r\n  //   else\r\n  //     return point_query(2*x+1,mid+1,hi,p);\r\n  // }\r\n\r\n\r\n  // void prop(int x,int lo, int hi)\r\n  // {\r\n  //   if(lo==hi)\r\n  //     return;\r\n  //   operation_arr[2*x]=merge_operation(operation_arr[2*x],operation_arr[x]);\r\n  //   operation_arr[2*x+1]=merge_operation(operation_arr[2*x+1],operation_arr[x]);\r\n  //   operation_arr[x]=NO_OPERATION;\r\n\r\n  //   update(x,lo,hi);\r\n  // }\r\n\r\n  // int operate(int val,int operatr,int l,int r)\r\n  // {\r\n  //   if(operatr==NO_OPERATION)\r\n  //     return val;\r\n\r\n\r\n  //   return operatr;\r\n  // }\r\n\r\n\r\n  // void update(int x,int lo,int hi)\r\n  // {\r\n  //   if(lo==hi)\r\n  //     return;\r\n\r\n  //   int mid=(lo+hi)/2;\r\n  //   res[x]=merge_results(operate(res[2*x],operation_arr[2*x],lo,mid),operate(res[2*x+1],operation_arr[2*x+1],mid+1,hi));\r\n  // }\r\n\r\n\r\n};\r\n\r\n\r\n\r\nstruct  FenwickTree\r\n{\r\n  int arr[100];\r\n  int n;\r\n\r\n  void update(int i, int delta)\r\n  {\r\n    while (i <= n)\r\n    {\r\n      arr[i] += delta;\r\n      i = i + (i & (-i));\r\n    }\r\n  }\r\n\r\n  int sum(int i)\r\n  {\r\n    if (i == 0)\r\n      return 0;\r\n    int res = 0;\r\n    while (i > 0)\r\n    {\r\n      res = res + arr[i];\r\n      i -= (i & (-i));\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n};\r\n\r\n\r\n\r\nstruct dsu\r\n{\r\n  int par[200001 + 100];\r\n  int size_set[200001 + 100];\r\n\r\n  void init(int n)\r\n  {\r\n    for (int i = 0; i <= n; i++)\r\n      par[i] = i, size_set[i] = 1;\r\n  }\r\n\r\n  int get_par(int u)\r\n  {\r\n    vi temp;\r\n    while (par[u] != u)\r\n    {\r\n      temp.pb(u);\r\n      u = par[u];\r\n    }\r\n\r\n    for (int i1 = 0;i1<temp.size();i1++) {\r\n        int i=temp[i1];\r\n      par[i] = u;\r\n    }\r\n\r\n    return u;\r\n    \r\n  }\r\n\r\n\r\n  void union_set(int a, int b)\r\n  {\r\n    a = get_par(a);\r\n    b = get_par(b);\r\n\r\n    if (a == b)\r\n      return;\r\n    if (size_set[a] < size_set[b])\r\n    {\r\n      int temp = a;\r\n      a = b;\r\n      b = temp;\r\n    }\r\n\r\n\r\n\r\n    //assuming a to have a larger size\r\n    par[b] = a;\r\n\r\n\r\n    size_set[a] += size_set[b];\r\n    // transfer all elements in b to a\r\n\r\n\r\n  }\r\n\r\n  int get_size(int u)\r\n  {\r\n    u = get_par(u);\r\n    return size_set[u];\r\n  }\r\n\r\n\r\n};\r\n\r\n\r\n\r\nll gcd(ll a, ll b)\r\n{\r\n  if (a == 0)\r\n    return b;\r\n\r\n  if (b == 0)\r\n    return a;\r\n  return gcd(b, a % b);\r\n\r\n}\r\n\r\n\r\n//int a[100002];\r\n// int curr_ans=0;\r\n// map<int,int> coded;\r\n// int code2[100001];\r\n\r\n\r\n// struct queries\r\n// {\r\n//   int l,r,lb,rb,idx;\r\n// };\r\n\r\n// bool cmp(queries a,queries b)\r\n// {\r\n//   if(a.lb!=b.lb)\r\n//     return a.lb<b.lb;\r\n\r\n//   if(a.lb%2==1)\r\n//     return a.r<b.r;\r\n//   else\r\n//     return a.r>b.r;\r\n\r\n// }\r\n\r\n// void add_elememt(int x)\r\n// {\r\n//    if(cnt[code2[x]]==a[x])\r\n//     curr_ans--;\r\n\r\n//   cnt[coded[a[x]]]++;\r\n\r\n//   if(cnt[code2[x]]==a[x])\r\n//     curr_ans++;\r\n// }\r\n\r\n// void remove_element(int x)\r\n// {\r\n//   if(cnt[code2[x]]==a[x])\r\n//     curr_ans--;\r\n\r\n//   cnt[code2[x]]--;\r\n\r\n//   if(cnt[code2[x]]==a[x])\r\n//     curr_ans++;\r\n\r\n// }\r\n\r\nbool contains_dup(string s)\r\n{\r\n  int cnt[26];\r\n  memset(cnt, 0, sizeof(cnt));\r\n\r\n  for (int i = 0; i < s.size(); i++)\r\n  {\r\n    cnt[s[i] - 'a']++;\r\n    if (cnt[s[i] - 'a'] > 1)\r\n      return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\n// ll lim=1000000;\r\n// ll pw1[1000001];\r\n// ll pw2[1000001];\r\n\r\n// ll m1=1e9+7;\r\n// ll m2=1e9+9;\r\n\r\n// ll base=256;\r\n\r\n// void pre_calc()\r\n// {\r\n//   pw1[0]=1;\r\n//   pw2[0]=1;\r\n\r\n//   for(int i=1;i<=lim;i++)\r\n//   {\r\n//     pw1[i]=(pw1[i-1]*base)%m1;\r\n//     pw2[i]=(pw2[i-1]*base)%m2;\r\n//   }\r\n// }\r\n\r\n// pl string_hash(string s)\r\n// {\r\n//   ll res1=0,res2=0;\r\n\r\n//   for(int i=0;i<s.size();i++)\r\n//   {\r\n//     ll v=(ll)s[i];\r\n\r\n//     res1=(res1+v*pw1[i])%m1;\r\n//     res2=(res2+v*pw2[i])%m2;\r\n//   }\r\n\r\n//   return mp(res1,res2);\r\n// }\r\n\r\n\r\nbool isOverflow(long long a, long long b)\r\n{\r\n  // Check if either of them is zero\r\n  if (a == 0 || b == 0)\r\n    return false;\r\n\r\n  //long long result = a * b;\r\n  if (a <= LLONG_MAX / b)\r\n    return false;\r\n  else\r\n    return true;\r\n}\r\nbool isOverflow_add(ll a, ll b)\r\n{\r\n  ll res = a + b;\r\n\r\n  if (res - a == b && res - b == a)\r\n    return 0;\r\n  return 1;\r\n}\r\n\r\n\r\n\r\n// ll fact(ll i)\r\n// {\r\n//   ll res=1;\r\n//   for(int j=1;j<=i;j++)\r\n//     res*=j;\r\n\r\n//   return res;\r\n// }\r\n\r\nll f1[100001];\r\nll f2[100001];\r\n\r\nvoid fct()\r\n{\r\n  f1[0] = 1;\r\n  f2[0] = mpow(1, mod - 2);\r\n\r\n\r\n  for (ll i = 1; i <= 100000; i++)\r\n  {\r\n    f1[i] = (f1[i - 1] * i) % mod;\r\n    f2[i] = mpow(f1[i], mod - 2);\r\n  }\r\n}\r\n\r\nll ncr(int n, int r)\r\n{\r\n  ll res = f1[n];\r\n  res = (res * f2[r]) % mod;\r\n\r\n  res = (res * f2[n - r]) % mod;\r\n\r\n  return res;\r\n}\r\n\r\nint d[1000002];\r\nll N1 = (1000000 + 1);\r\nvl pr;\r\n\r\nvoid seive(int N)\r\n{\r\n  for (int i = 2; i < N; i++)\r\n    d[i] = i;\r\n\r\n\r\n  for (ll i = 2; i < N; i++)\r\n  {\r\n    if (d[i] == i)\r\n      pr.pb(i);\r\n\r\n    for (ll j = 0; j < (ll)pr.size() && pr[j] <= d[i] && i * pr[j] < N; j++)\r\n      d[i * pr[j]] = pr[j];\r\n  }\r\n\r\n}\r\n\r\nbool is_prime(int n)\r\n{\r\n  if (d[n] == n)\r\n    return 1;\r\n  return 0;\r\n\r\n}\r\nvpii fctorize(int n)\r\n{\r\n  vpii res;\r\n\r\n  while (n > 1)\r\n  {\r\n    int k = d[n];\r\n\r\n    int cnt = 0;\r\n    while (n > 1 && k == d[n])\r\n      n /= d[n], cnt++;\r\n\r\n    res.pb(mp(k, cnt));\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n\r\nvpl prime_factorize(ll n) //  o(sqrt(n))\r\n{\r\n  vpl res;\r\n\r\n  for (ll i = 2; i * i <= n; i++)\r\n  {\r\n    if (n % i == 0)\r\n    {\r\n      ll cnt = 0;\r\n      while (n % i == 0)\r\n        n /= i, cnt++;\r\n\r\n      res.pb(mp(i, cnt));\r\n    }\r\n  }\r\n\r\n  if (n > 1)\r\n    res.pb(mp(n, 1));\r\n  return res;\r\n}\r\n\r\nvl get_factors(ll n)\r\n{\r\n\r\n  vl res;\r\n\r\n  for (ll i = 1; i * i <= n; i++)\r\n  {\r\n    if (n % i == 0)\r\n    {\r\n      ll f1 = i;\r\n      ll f2 = n / i;\r\n\r\n      res.pb(f1);\r\n\r\n      if (f1 != f2)\r\n        res.pb(f2);\r\n\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\nclass Node {\r\npublic:\r\n  int val;\r\n  int end_cnt;\r\n  int cnt_wrd_with_pref;\r\n  Node* ptrs[26];\r\n  Node* non_null_node;\r\n\r\npublic:\r\n  Node() {\r\n    val = -1;\r\n    end_cnt = 0;\r\n    cnt_wrd_with_pref = 0;\r\n    non_null_node = NULL;\r\n    // for (int i = 0; i < 26; i++)\r\n    //   ptrs[i] = NULL;\r\n  }\r\n};\r\n\r\nclass Trie {\r\n\r\npublic:\r\n  Node* root;\r\n\r\npublic:\r\n  Trie() {\r\n    root = new Node();\r\n  }\r\n\r\n  void insert(string s) {\r\n\r\n    int n = s.size();\r\n    Node* curr = root;\r\n\r\n    for (int i = 0; i < s.size(); i++) {\r\n      int v = s[i] - 'a';\r\n      if (curr->ptrs[v] == NULL) {\r\n        //create this node\r\n\r\n        Node* new_nd = new Node();\r\n        new_nd->val = v;\r\n        new_nd->cnt_wrd_with_pref++;\r\n\r\n        if (i == s.size() - 1) {\r\n          new_nd->end_cnt++;\r\n\r\n\r\n        }\r\n        curr->ptrs[v] = new_nd;\r\n        curr->non_null_node = new_nd;\r\n        curr = new_nd;\r\n      }\r\n      else {\r\n        curr = curr->ptrs[v];\r\n        curr->non_null_node = curr->ptrs[v];\r\n        if (i == s.size() - 1) {\r\n          curr->end_cnt++;\r\n        }\r\n        curr->cnt_wrd_with_pref++;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  int find(string s) {\r\n\r\n    int n = s.size();\r\n\r\n    Node* curr = root;\r\n    for (int i = 0; i < n; i++) {\r\n      int v = s[i] - 'a';\r\n\r\n      if (curr->ptrs[v] == NULL)\r\n        return 0;\r\n      curr = curr->ptrs[v];\r\n\r\n      if (i == s.size() - 1) {\r\n        if (curr->end_cnt == 0) {\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    return 1;\r\n  }\r\n};\r\n\r\n\r\nvoid map_ins(ll u, map<ll, ll> &cnt)\r\n{\r\n  if (cnt.find(u) == cnt.end())\r\n  {\r\n    cnt[u] = 1;\r\n  }\r\n  else\r\n  {\r\n    cnt[u]++;\r\n  }\r\n}\r\nvoid map_rmv(ll u, map<ll, ll> &cnt)\r\n{\r\n  if (cnt.find(u) == cnt.end())\r\n    return;\r\n  else\r\n  {\r\n    cnt[u]--;\r\n    if (cnt[u] == 0)\r\n      cnt.erase(u);\r\n  }\r\n}\r\n\r\nll get_cnt(ll u, map<ll, ll> &cnt)\r\n{\r\n  if (cnt.find(u) == cnt.end())\r\n    return 0;\r\n  return cnt[u];\r\n\r\n}\r\n\r\nstruct FlowEdge {\r\n    int v, u;\r\n    long long cap, flow = 0;\r\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\r\n};\r\n\r\nstruct Dinic {\r\n    const long long flow_inf = 1e18;\r\n    vector<FlowEdge> edges;\r\n    vector<vector<int>> adj;\r\n    int n, m = 0;\r\n    int s, t;\r\n    vector<int> level, ptr;\r\n    queue<int> q;\r\n\r\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\r\n        adj.resize(n);\r\n        level.resize(n);\r\n        ptr.resize(n);\r\n    }\r\n\r\n    void add_edge(int v, int u, long long cap) {\r\n        edges.emplace_back(v, u, cap);\r\n        edges.emplace_back(u, v, 0);\r\n        adj[v].push_back(m);\r\n        adj[u].push_back(m + 1);\r\n        m += 2;\r\n    }\r\n\r\n    bool bfs() {\r\n        while (!q.empty()) {\r\n            int v = q.front();\r\n            q.pop();\r\n            for (int id : adj[v]) {\r\n                if (edges[id].cap - edges[id].flow < 1)\r\n                    continue;\r\n                if (level[edges[id].u] != -1)\r\n                    continue;\r\n                level[edges[id].u] = level[v] + 1;\r\n                q.push(edges[id].u);\r\n            }\r\n        }\r\n        return level[t] != -1;\r\n    }\r\n\r\n    long long dfs(int v, long long pushed) {\r\n        if (pushed == 0)\r\n            return 0;\r\n        if (v == t)\r\n            return pushed;\r\n        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {\r\n            int id = adj[v][cid];\r\n            int u = edges[id].u;\r\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\r\n                continue;\r\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\r\n            if (tr == 0)\r\n                continue;\r\n            edges[id].flow += tr;\r\n            edges[id ^ 1].flow -= tr;\r\n            return tr;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    long long flow() {\r\n        long long f = 0;\r\n        while (true) {\r\n            fill(level.begin(), level.end(), -1);\r\n            level[s] = 0;\r\n            q.push(s);\r\n            if (!bfs())\r\n                break;\r\n            fill(ptr.begin(), ptr.end(), 0);\r\n            while (long long pushed = dfs(s, flow_inf)) {\r\n                f += pushed;\r\n            }\r\n        }\r\n        return f;\r\n    }\r\n};\r\n\r\nll a[200001];\r\nll res1[200001];\r\nll bit_contri[200001][21];\r\nint parents[200001];\r\nll subtree_sz[200001];\r\nll tree_sz;\r\n\r\nvoid solver(int u, int p, int bit, ll sum) {\r\n    ll msk = (1LL<<bit);\r\n    ll v_root = a[u] & msk;\r\n     \r\n    bit_contri[u][bit] = sum;\r\n\r\n    for(int i: g[u]) {\r\n        if(i!=p) {\r\n            ll v = a[i] & msk;\r\n            \r\n            if(v_root == v) {\r\n                solver(i, u, bit, sum);\r\n            } else {\r\n                solver(i, u, bit, sum + ( - subtree_sz[i] + tree_sz - subtree_sz[i])*msk);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nll get_subtree_sz(int u, int p) {\r\n    ll sz = 1;\r\n    \r\n    \r\n    for(int i: g[u]) {\r\n        if(i!=p) {\r\n            sz += get_subtree_sz(i, u);\r\n        }\r\n    }\r\n    \r\n    subtree_sz[u] = sz;\r\n    //deb2(u, subtree_sz[u]);\r\n    return sz;\r\n}\r\n\r\nvoid ff2(int u, int p, int sum, int bit) {\r\n    \r\n    parents[u] = p;\r\n    \r\n    ll msk = (1LL<<bit);\r\n    ll v_root = a[u] & msk;\r\n    \r\n    bit_contri[1][bit] += sum*msk;\r\n    \r\n    \r\n    for(int i: g[u]) {\r\n        if(i!=p) {\r\n            ll v = a[i] & msk;\r\n            \r\n            if(v_root == v) {\r\n                ff2(i, u, sum, bit);\r\n            } else {\r\n                ff2(i, u, sum + 1, bit);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nll sum_bit_contri(int root) {\r\n    ll sum =0;\r\n    for(int i=0; i<=20 ;i ++ ){\r\n        sum+=bit_contri[root][i];\r\n    }\r\n    \r\n    return sum;\r\n}\r\n\r\nvoid solve(int t1) {\r\n    \r\n    int n;\r\n    cin>>n;\r\n    tree_sz = n;\r\n    \r\n    //memset(bit_contri, 0, sizeof(bit_contri));\r\n    \r\n    for(int i=1;i<=n;i++) {\r\n        cin>>a[i];\r\n        g[i].clear();\r\n        res1[i] = 0;\r\n        \r\n        for(int j=0;j<=20;j++) {\r\n            bit_contri[i][j] = 0;\r\n        }\r\n    }\r\n    \r\n    \r\n    for(int i=1;i<=n-1;i++) {\r\n        int u, v;\r\n        cin>>u>>v;\r\n        g[u].pb(v);\r\n        g[v].pb(u);\r\n    }\r\n    \r\n    get_subtree_sz(1, -1);\r\n   \r\n    for(int i=0; i<=20; i++) {\r\n        ff2(1, -1, 0, i);\r\n    }\r\n    \r\n    ll child = -1;\r\n    \r\n    for(int i: g[1]) {\r\n        child = i;\r\n        break;\r\n    }\r\n    \r\n    ll res_1 = sum_bit_contri(1);\r\n    \r\n    for(int i=0; i<=20; i++) {\r\n        solver(1, -1, i, bit_contri[1][i]);\r\n    }\r\n    \r\n    \r\n    for(int i=1; i<=n; i++) {\r\n        cout<<sum_bit_contri(i)<<\" \";\r\n    }\r\n    \r\n    cout<<\"\\n\";\r\n    \r\n}\r\n\r\n\r\nint main()\r\n{\r\n  //pre_process();\r\n//   int N = 1e6 + 1;\r\n//   seive(N);\r\n\r\n  //int t1=1;\r\n\r\n  int t = 1;\r\n  cin >> t;\r\n\r\n  int t1 = 1;\r\n\r\n  while (t--)\r\n  {\r\n    solve(t1);\r\n    t1++;\r\n  }\r\n\r\n  return 0;\r\n}\r\n//=======================================================================================\r\nll mpow(ll base, ll exp)\r\n{\r\n  base %= mod;\r\n  ll result = 1;\r\n  while (exp > 0)\r\n  {\r\n    if (exp & 1)\r\n      result = ((ll)result * base) % mod;\r\n    base = ((ll)base * base) % mod;\r\n    exp >>= 1;\r\n  }\r\n  return result;\r\n}\r\n\r\nll mpow(ll base, ll exp, ll m)\r\n{\r\n  base %= m;\r\n  ll result = 1;\r\n  while (exp > 0)\r\n  {\r\n    if (exp & 1)\r\n      result = ((ll)result * base) % m;\r\n    base = ((ll)base * base) % m;\r\n    exp >>= 1;\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n\r\nll power(ll a, ll b)\r\n{\r\n  ll res = 1;\r\n  while (b > 0)\r\n  {\r\n    if (b % 2 == 0)\r\n    {\r\n      b /= 2;\r\n\r\n      if (isOverflow(a, a))\r\n        return LLONG_MAX;\r\n      a = a * a;\r\n    }\r\n    else\r\n    {\r\n      if (isOverflow(res, a))\r\n        return LLONG_MAX;\r\n      res = res * a;\r\n      b--;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n"
}