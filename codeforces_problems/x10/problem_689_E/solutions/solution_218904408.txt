{
    "id": 218904408,
    "contestId": 689,
    "creationTimeSeconds": 1692092345,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 689,
        "index": "E",
        "name": "Mike and Geometry Problem",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2000,
        "tags": [
            "combinatorics",
            "data structures",
            "dp",
            "geometry",
            "implementation"
        ]
    },
    "author": {
        "contestId": 689,
        "members": [
            {
                "handle": "..0_0.."
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1467822900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 69,
    "timeConsumedMillis": 592,
    "memoryConsumedBytes": 38809600,
    "source": "#include <bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\n// using namespace chrono;\r\n// using namespace __gnu_pbds;\r\n\r\ntypedef vector<long long> vi;\r\ntypedef pair<int, int> pii;\r\n#define endl \"\\n\"\r\n#define sd(val) scanf(\"%d\", &val)\r\n#define ss(val) scanf(\"%s\", &val)\r\n#define sl(val) scanf(\"%lld\", &val)\r\n#define debug(val) printf(\"check%d\\n\", val)\r\n#define all(v) v.begin(), v.end()\r\n#define sai(a, n) sort(a, a + n);\r\n#define sad(a, n) sort(a, a + n, greater<int>());\r\n#define svi(x) sort(x.begin(), x.end());\r\n#define svd(a) sort(a.begin(), a.end(), greater<int>());\r\n#define fi(i, x, n) for (int i = x; i < n; i++)\r\n#define PB push_back\r\n#define MP make_pair\r\n#define FF first\u1e47\r\n#define SS second\r\n#define ull unsigned long long\r\n#define int long long\r\n#define MOD 1000000007\r\n// #define MOD 998244353\r\n#define clr(val) memset(val, 0, sizeof(val))\r\n#define what_is(x) cerr << #x << \" is \" << x << endl;\r\n\r\n#define OJ                            \\\r\n    freopen(\"input.txt\", \"r\", stdin); \\\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#define FIO                           \\\r\n    ios_base::sync_with_stdio(false); \\\r\n    cin.tie(NULL);                    \\\r\n    cout.tie(NULL);\r\n\r\n// template <class T>\r\n// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\n// Function to find a^b % MOD. Time Complexity : O(log b).\r\nint highPowerMod(int a, int b)\r\n{\r\n    a %= MOD;\r\n    long long res = 1;\r\n    while (b > 0)\r\n    {\r\n        if (b & 1)\r\n            res = res * a % MOD;\r\n        a = a * a % MOD;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\n// Function to find the lcm of a and b. Time Complexity : O(log(min(a, b))).\r\nint lcm(int a, int b)\r\n{\r\n    return a / __gcd(a, b) * b;\r\n}\r\n\r\nvoid bfs(int start, vector<vector<int>> &g2, vector<pair<int, bool>> &dp, int m)\r\n{\r\n    queue<int> q;\r\n    q.push(start);\r\n    int cnt = 0;\r\n    bool flag = false;\r\n    while (!q.empty())\r\n    {\r\n        cnt = q.front();\r\n        if (cnt < m)\r\n            flag = true;\r\n        q.pop();\r\n\r\n        dp[cnt].second = flag;\r\n        for (const auto &nbr : g2[cnt])\r\n        {\r\n            if (dp[nbr].first == -1)\r\n            {\r\n                dp[nbr].first = dp[cnt].first + 1;\r\n                q.push(nbr);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint compliment(int x, int n)\r\n{\r\n    return (x ^ (n - 1));\r\n}\r\n\r\nvoid dfs(int start, vector<vi> &graph, vector<bool> &vis)\r\n{\r\n    vis[start] = true;\r\n\r\n    for (const auto &nbr : graph[start])\r\n    {\r\n        if (!vis[nbr])\r\n        {\r\n            dfs(nbr, graph, vis);\r\n        }\r\n    }\r\n}\r\n\r\npair<int, int> intersection(pair<int, int> a, pair<int, int> b)\r\n{\r\n    if (a.first > b.second || b.first > a.second)\r\n        return {-1, -1};\r\n    return {max(a.first, b.first), min(a.second, b.second)};\r\n}\r\n\r\nint cntDigits(int n)\r\n{\r\n    string t = to_string(n);\r\n    return (int)t.size();\r\n}\r\n\r\nint bs_sqrt(int x)\r\n{\r\n    int left = 0, right = sqrt(x) + 1e7;\r\n    while (right > left)\r\n    {\r\n        int mid = left + (right - left) / 2;\r\n\r\n        if ((mid * mid) > x)\r\n            right = mid;\r\n        else\r\n            left = mid + 1;\r\n    }\r\n    return left - 1;\r\n}\r\nvoid primeFactors(int n, bool &f, int m)\r\n{\r\n    int t = 1e5 + 7;\r\n    fi(i, 1, t)\r\n    {\r\n        if (i * i > n)\r\n            break;\r\n        if (n % i == 0)\r\n        {\r\n            // arr.insert(i);\r\n            // arr.insert(n / i);\r\n            if ((i <= m && i != 1) || ((n / i) <= m && (n / i) != 1))\r\n                f = true;\r\n        }\r\n    }\r\n}\r\n\r\nvoid primeFactors2(int n, vi &arr, vi &fac)\r\n{\r\n    int t = 1e5 + 7;\r\n    for (auto i : fac)\r\n    {\r\n        if (i <= 1)\r\n            continue;\r\n        while (n > 0 && n % i == 0)\r\n        {\r\n            arr.push_back(i);\r\n            n /= i;\r\n        }\r\n        if (n <= 0)\r\n            break;\r\n    }\r\n}\r\n\r\nvoid SieveOfEratosthenes(int n, vi &primess)\r\n{\r\n    bool prime[n + 1];\r\n    memset(prime, true, sizeof(prime));\r\n\r\n    for (int p = 2; p * p <= n; p++)\r\n    {\r\n        if (prime[p] == true)\r\n        {\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n    for (int p = 2; p <= n; p++)\r\n        if (prime[p])\r\n            primess.push_back(p);\r\n}\r\n\r\n// And of a Range of numbers from a to b.\r\nint andOperator(int a, int b)\r\n{\r\n    int shiftcount = 0;\r\n    while (a != b and a > 0)\r\n    {\r\n        shiftcount++;\r\n        a = a >> 1;\r\n        b = b >> 1;\r\n    }\r\n    return int64_t(a << shiftcount);\r\n}\r\n\r\nbool compare(vector<int> &p1, vector<int> &p2)\r\n{\r\n    if (p1[0] == p2[0])\r\n        return p1[1] > p2[1];\r\n    return p1[0] < p2[0];\r\n}\r\n\r\nstring leftrotate(string str1, int n)\r\n{\r\n\r\n    // creating extended string and index for new rotated\r\n    // string\r\n    string temp = str1 + str1;\r\n    int l1 = str1.size();\r\n\r\n    string Lfirst = temp.substr(n, l1);\r\n\r\n    //      now returning  string\r\n    return Lfirst;\r\n}\r\n\r\n// Segment Trees.\r\n// int n, t[4*MAXN];\r\n// void build(int a[], int v, int tl, int tr) {\r\n//     if (tl == tr) {\r\n//         t[v] = a[tl];\r\n//     } else {\r\n//         int tm = (tl + tr) / 2;\r\n//         build(a, v*2, tl, tm);\r\n//         build(a, v*2+1, tm+1, tr);\r\n//         t[v] = t[v*2] + t[v*2+1];\r\n//     }\r\n// }\r\n// int sum(int v, int tl, int tr, int l, int r) {\r\n//     if (l > r)\r\n//         return 0;\r\n//     if (l == tl && r == tr) {\r\n//         return t[v];\r\n//     }\r\n//     int tm = (tl + tr) / 2;\r\n//     return sum(v*2, tl, tm, l, min(r, tm))\r\n//            + sum(v*2+1, tm+1, tr, max(l, tm+1), r);\r\n// }\r\n// void update(int v, int tl, int tr, int pos, int new_val) {\r\n//     if (tl == tr) {\r\n//         t[v] = new_val;\r\n//     } else {\r\n//         int tm = (tl + tr) / 2;\r\n//         if (pos <= tm)\r\n//             update(v*2, tl, tm, pos, new_val);\r\n//         else\r\n//             update(v*2+1, tm+1, tr, pos, new_val);\r\n//         t[v] = t[v*2] + t[v*2+1];\r\n//     }\r\n// }\r\n\r\nvector<int> fact(300005, 1);\r\n\r\nint mod_mul(int a, int b)\r\n{\r\n    a = a % MOD;\r\n    b = b % MOD;\r\n    return (((a * b) % MOD) + MOD) % MOD;\r\n}\r\nint C(int n, int r)\r\n{\r\n    int ans = 1;\r\n    ans = fact[n];\r\n    ans = mod_mul(ans, highPowerMod(fact[r], MOD - 2));\r\n    ans = mod_mul(ans, highPowerMod(fact[n - r], MOD - 2));\r\n    return ans;\r\n}\r\n\r\nvoid solve(int cake)\r\n{\r\n    int n;\r\n    cin >> n;\r\n    int m;\r\n    cin >> m;\r\n    // vector<int> arr(n);\r\n    // fi(i, 0, n) cin >> arr[i];\r\n\r\n    vector<int> left(n), right(n);\r\n    map<int, int> mp;\r\n    fi(i, 0, n)\r\n    {\r\n        cin >> left[i];\r\n        cin >> right[i];\r\n        mp[left[i]]++;\r\n        mp[right[i] + 1]--;\r\n    }\r\n\r\n    vector<int> temp;\r\n    for (auto it : mp)\r\n        temp.push_back(it.first);\r\n\r\n    int ans = 0, curr = 0;\r\n\r\n    for (int i = 0; i < (int)temp.size() - 1; i++)\r\n    {\r\n        curr += mp[temp[i]];\r\n        int x = temp[i + 1] - temp[i];\r\n        if (curr >= m)\r\n        {\r\n            ans += C(curr, m) * x;\r\n        }\r\n        ans = (ans + MOD) % MOD;\r\n    }\r\n\r\n    cout << ans << endl;\r\n}\r\n\r\nint32_t main()\r\n{\r\n    // OJ;\r\n    FIO;\r\n    int t = 1;\r\n    int cake = 1;\r\n    // cin >> t;\r\n    // vi primes;\r\n    // int N = 2e5 + 7;\r\n    // SieveOfEratosthenes(N, primes);\r\n    // cout << primes.size() << endl;\r\n    // int N = 1e5 + 5;\r\n    // vector<vector<int>> factors(N);\r\n    // for (int i = 1; i < N; i++)\r\n    //     for (int j = i; j < N; j += i)\r\n    //         factors[j].push_back(i);\r\n\r\n    // int N = 2e5 + 10;\r\n    // vector<int> fact(N, 0);\r\n    // fact[0] = 1;\r\n    // fi(i, 1, N)\r\n    // {\r\n    //     fact[i] = fact[i - 1] * i;\r\n    //     fact[i] = (fact[i] + MOD) % MOD;\r\n    // }\r\n    fi(i, 2, 300005)\r\n    {\r\n        fact[i] = mod_mul(fact[i - 1], i);\r\n    }\r\n    while (t--)\r\n    {\r\n        solve(cake);\r\n        cake++;\r\n    }\r\n\r\n    return 0;\r\n}"
}