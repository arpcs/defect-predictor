{
    "id": 141837963,
    "contestId": 852,
    "creationTimeSeconds": 1641483071,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 852,
        "index": "G",
        "name": "Bathroom terminal",
        "type": "PROGRAMMING",
        "rating": 1700,
        "tags": [
            "implementation"
        ]
    },
    "author": {
        "contestId": 852,
        "members": [
            {
                "handle": "anshjain"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1504432800
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 171,
    "memoryConsumedBytes": 11878400,
    "source": "\r\n//  \u0936\u094d\u0930\u0940 1008 \u091a\u0902\u0926\u094d\u0930\u092a\u094d\u0930\u092d\u0941 \u091c\u093f\u0928\u0947\u0928\u094d\u0926\u094d\u0930\u0930\u093e\u092f \u0928\u092e\u0903 :\r\n//\u0950 \u0939\u094d\u0930\u0940\u0902 \u0905\u0930\u094d\u0939\u0902 \u092a\u093e\u0930\u094d\u0936\u094d\u0935\u0928\u093e\u0925\u093e\u092f \u0928\u092e\u0903.\r\n//\u0964\u0964\u0936\u094d\u0930\u0940 \u092e\u0939\u093e\u0935\u0940\u0930\u093e\u092f \u0928\u092e\u0903\u0964\u0964\r\n\r\n#include<bits/stdc++.h>\r\n//#include<ext/pb_ds/assoc_container.hpp>\r\n//#include<ext/pb_ds/tree_policy.hpp>\r\n//#include <ext/pb_ds/trie_policy.hpp>\r\n//using namespace __gnu_pbds;\r\nusing namespace std;\r\n#define ll              long long int\r\n#define ld              long double\r\n#define mod             1000000007\r\n#define inf             1e18\r\n#define endl            \"\\n\"\r\n#define pb              push_back\r\n#define vi              vector<ll>\r\n#define vs              vector<string>\r\n#define pii             pair<ll,ll>\r\n#define ump             unordered_map\r\n#define mp              make_pair\r\n#define pq_max          priority_queue<ll>\r\n#define pq_min          priority_queue<ll,vi,greater<ll> >\r\n#define all(n)          n.begin(),n.end()\r\n#define ff              first\r\n#define ss              second\r\n#define mid(l,r)        (l+(r-l)/2)\r\n#define bitc(n)         __builtin_popcount(n)\r\n#define loop(i,a,b)     for(int i=(a);i<=(b);i++)\r\n#define looprev(i,a,b)  for(int i=(a);i>=(b);i--)\r\n#define iter(container, it) for(__typeof(container.begin()) it = container.begin(); it != container.end(); it++)\r\n#define log(args...)    { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\r\n#define logarr(arr,a,b) for(int z=(a);z<=(b);z++) cout<<(arr[z])<<\" \";cout<<endl;    \r\ntemplate <typename T> T gcd(T a, T b){if(a%b) return gcd(b,a%b);return b;}\r\ntemplate <typename T> T lcm(T a, T b){return (a*(b/gcd(a,b)));}\r\nvs tokenizer(string str,char ch) {std::istringstream var((str)); vs v; string t; while(getline((var), t, (ch))) {v.pb(t);} return v;}\r\n\r\n\r\nvoid err(istream_iterator<string> it) {}\r\ntemplate<typename T, typename... Args>\r\nvoid err(istream_iterator<string> it, T a, Args... args) {\r\n    cout << *it << \" = \" << a << endl;\r\n    err(++it, args...);\r\n}\r\n//typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\r\n//typedef trie<string,null_type,trie_string_access_traits<>,pat_trie_tag,trie_prefix_search_node_update> pbtrie;\r\n\r\nvoid file_i_o()\r\n{\r\n    ios_base::sync_with_stdio(0); \r\n    cin.tie(0); \r\n    cout.tie(0);\r\n    #ifndef ONLINE_JUDGE\r\n        freopen(\"input.txt\", \"r\", stdin);\r\n        freopen(\"output.txt\", \"w\", stdout);\r\n    #endif\r\n}\r\nchar arr[5] = {'a', 'b', 'c', 'd', 'e'};  \r\nint main(int argc, char const *argv[]) {\r\n    clock_t begin = clock();\r\n    file_i_o();\r\n    // Write your code here....\r\n    \r\n    ll n, m;\r\n    cin>>n>>m;\r\n\r\n    unordered_map<string, ll> mpp;   \r\n    for(ll i = 0; i < n; i++) {\r\n    \tstring s;\r\n    \tcin>>s;  \r\n    \tmpp[s]++;   \r\n    }\r\n    for(ll i = 0; i < m; i++) {\r\n    \tstring s;\r\n    \tcin>>s;  \r\n    \tll cnt = 0;  \r\n    \tstd::vector<ll> temp;\r\n    \tfor(ll j = 0; j < s.size(); j++) {\r\n    \t\tif(s[j]=='?') temp.pb(j);   \r\n    \t}\r\n    \tif(temp.size() == 0) {\r\n    \t\tif(mpp.find(s) != mpp.end()) {\r\n    \t\t\tcnt += mpp[s]; \r\n    \t\t}\r\n    \t}\r\n    \telse if(temp.size() == 1) {\r\n    \t\t// unordered_map<string, ll> mpp;  \r\n    \t\tunordered_map<string, ll> vis;\r\n    \t\tstring temp1 = \"\";  \r\n    \t\tfor(ll j = 0; j < temp[0]; j++) {\r\n    \t\t\ttemp1 += s[j];  \r\n    \t\t}\r\n    \t\tstring temp2 = \"\";\r\n    \t\tfor(ll j = temp[0]+1; j < s.size(); j++) {\r\n    \t\t\ttemp2 += s[j];   \r\n    \t\t}\r\n    \t\tif(mpp.find(temp1+temp2) != mpp.end() and vis.find(temp1+temp2) == vis.end()) {\r\n    \t\t\tcnt += mpp[temp1+temp2];  \r\n    \t\t\tvis[temp1+temp2]++;  \r\n    \t\t} \r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + arr[j] + temp2;  \r\n    \t\t\tif(mpp.find(tt) != mpp.end() and vis.find(tt) == vis.end()) {\r\n    \t\t\t\tcnt += mpp[tt];   \r\n    \t\t\t\tvis[tt]++;  \r\n    \t\t\t}  \r\n    \t\t} \r\n    \t} else if(temp.size() == 2) {\r\n    \t\t// string ttt = \"\"; \r\n    \t\tunordered_map<string, ll> vis; \r\n    \t\tstring temp1 = \"\";  \r\n    \t\tstring temp2 = \"\";   \r\n    \t\tstring temp3 = \"\";  \r\n    \t\tfor(ll j = 0; j < temp[0]; j++) {\r\n    \t\t\ttemp1 += s[j];   \r\n    \t\t}  \r\n    \t\tfor(ll j = temp[0]+1; j < temp[1]; j++) {\r\n    \t\t\ttemp2 += s[j];   \r\n    \t\t}\r\n    \t\tfor(ll j = temp[1]+1; j < s.size(); j++) {\r\n    \t\t\ttemp3 += s[j];   \r\n    \t\t}\r\n    \t\tif(mpp.find(temp1 + temp2 + temp3) != mpp.end() and vis.find(temp1+temp2+temp3) == vis.end()) {\r\n    \t\t\tcnt += mpp[temp1+temp2+temp3];\r\n    \t\t\tvis[temp1+temp2+temp3]++; \r\n    \t\t}   \r\n    \t\tstring temp4 = temp1+temp2;  \r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp4 + arr[j] + temp3;  \r\n    \t\t\tif(mpp.find(tt) != mpp.end() and vis.find(tt) == vis.end()) {\r\n    \t\t\t\tcnt += mpp[tt];  \r\n    \t\t\t\tvis[tt]++;  \r\n    \t\t\t}    \r\n    \t\t}\r\n    \t\tstring temp5 = temp2+temp3;   \r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + arr[j] + temp5;   \r\n    \t\t\tif(mpp.find(tt) != mpp.end() and vis.find(tt) == vis.end()) {\r\n    \t\t\t\tcnt+=mpp[tt];\r\n    \t\t\t\tvis[tt]++;  \r\n    \t\t\t} \r\n    \t\t}\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + arr[j] + temp2;   \r\n    \t\t\tfor(ll k = 0; k < 5; k++) {\r\n    \t\t\t\tstring ttt = tt + arr[k] + temp3;  \r\n    \t\t\t\tif(mpp.find(ttt) != mpp.end() and vis.find(ttt) == vis.end()) {\r\n    \t\t\t\t\tcnt += mpp[ttt];   \r\n    \t\t\t\t\tvis[ttt]++; \r\n    \t\t\t\t}   \r\n    \t\t\t}\r\n    \t\t}\r\n    \t} else {\r\n    \t\tunordered_map<string, ll> vis;   \r\n    \t\tstring temp1 = \"\", temp2 = \"\", temp3 = \"\", temp4 = \"\";  \r\n    \t\tfor(ll j = 0; j < temp[0]; j++) {\r\n    \t\t\ttemp1 += s[j];   \r\n    \t\t}\r\n    \t\tfor(ll j = temp[0]+1; j < temp[1]; j++) {\r\n    \t\t\ttemp2 += s[j];   \r\n    \t\t}\r\n    \t\tfor(ll j = temp[1]+1; j < temp[2]; j++) {\r\n    \t\t\ttemp3 += s[j];  \r\n    \t\t}\r\n    \t\tfor(ll j = temp[2]+1; j < s.size(); j++) {\r\n    \t\t\ttemp4 += s[j];   \r\n    \t\t}\r\n    \t\tif(mpp.find(temp1+temp2+temp3+temp4) != mpp.end() and vis.find(temp1+temp2+temp3+temp4)==vis.end()) {\r\n    \t\t\tcnt += mpp[temp1+temp2+temp3+temp4];  \r\n    \t\t\tvis[temp1+temp2+temp3+temp4]++; \r\n    \t\t} \r\n    \t\tstring temp5 = temp1 + temp2 + temp3;\r\n    \t\tstring temp6 = temp2 + temp3 + temp4;\r\n    \t\tstring temp7 = temp1 + temp2;\r\n    \t\tstring temp8 = temp2 + temp3;\r\n    \t\tstring temp9 = temp3 + temp4;\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp5 + arr[j] + temp4;\r\n    \t\t\tif(mpp.find(tt) != mpp.end() and vis.find(tt) == vis.end()) {\r\n    \t\t\t\tcnt+=mpp[tt]; \r\n    \t\t\t\tvis[tt]++;  \r\n    \t\t\t} \r\n    \t\t}\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + s[j] + temp6;\r\n    \t\t\tif(mpp.find(tt) != mpp.end() and vis.find(tt) == vis.end()) {\r\n    \t\t\t\tcnt+=mpp[tt];  \r\n    \t\t\t\tvis[tt]++;  \r\n    \t\t\t}  \r\n    \t\t}\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp7 + arr[j] + temp3; \r\n    \t\t\tfor(ll k = 0; k < 5; k++) {\r\n    \t\t\t\tstring ttt = tt + arr[k] + temp4;  \r\n    \t\t\t\tif(mpp.find(ttt) != mpp.end() and vis.find(ttt) == vis.end()) {\r\n    \t\t\t\t\tcnt+=mpp[ttt];  \r\n    \t\t\t\t\tvis[ttt]++;  \r\n    \t\t\t\t}  \r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + arr[j] + temp8;\r\n    \t\t\tfor(ll k = 0; k < 5; k++) {\r\n    \t\t\t\tstring ttt = tt + arr[k] + temp4;  \r\n    \t\t\t\tif(mpp.find(ttt) != mpp.end() and vis.find(ttt) == vis.end()) {\r\n    \t\t\t\t\tcnt+=mpp[ttt];\r\n    \t\t\t\t\tvis[ttt]++;  \r\n    \t\t\t\t}   \r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + arr[j] + temp2;  \r\n    \t\t\tfor(ll k = 0; k < 5; k++) {\r\n    \t\t\t\tstring ttt = tt + arr[k] + temp9;  \r\n    \t\t\t\tif(mpp.find(ttt) != mpp.end() and vis.find(ttt) == vis.end()) {\r\n    \t\t\t\t\tcnt+=mpp[ttt];  \r\n    \t\t\t\t\tvis[ttt]++;  \r\n    \t\t\t\t}  \r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tfor(ll j = 0; j < 5; j++) {\r\n    \t\t\tstring tt = temp1 + arr[j] + temp2;  \r\n    \t\t\tfor(ll k = 0; k < 5; k++) {\r\n    \t\t\t\tstring ttt = tt + arr[k] + temp3;  \r\n    \t\t\t\tfor(ll l = 0; l < 5; l++) {\r\n    \t\t\t\t\tstring tttt = ttt + arr[l] + temp4;  \r\n    \t\t\t\t\tif(mpp.find(tttt) != mpp.end() and vis.find(tttt) == vis.end()) {\r\n    \t\t\t\t\t\tcnt+=mpp[tttt]; \r\n    \t\t\t\t\t\tvis[tttt]++;  \r\n    \t\t\t\t\t}  \r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \tcout<<cnt<<endl;\r\n    }\r\n        \r\n    #ifndef ONLINE_JUDGE \r\n      clock_t end = clock();\r\n      cout<<\"\\n\\nExecuted In: \"<<double(end - begin) / CLOCKS_PER_SEC*1000<<\" ms\";\r\n    #endif \r\n    return 0;\r\n}"
}