{
    "id": 234826592,
    "contestId": 374,
    "creationTimeSeconds": 1701191059,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 374,
        "index": "A",
        "name": "Inna and Pink Pony",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 2000,
        "tags": [
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 374,
        "members": [
            {
                "handle": "bkifhr7"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1387380600
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 204800,
    "source": "// sometimes pragmas don't work, if so, just comment it!\n#pragma GCC optimize(3,\"Ofast\",\"inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\n// building blocks\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n// using u128 = __uint128_t; // for Number Theory related\n// using i128 = __int128;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; // minima\n\n\n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\n#define mp make_pair\n#define f first\n#define s second\n\n\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\n\ntcT> using V = vector<T>;\ntcT, size_t SZ> using AR = array<T,SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n\n\n// using u128 = __uint128_t;\ntcT> using V = vector<T>;\ntcT, size_t SZ> using AR = array<T, SZ>;\n\n\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define ts to_string\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\n\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x))\nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\n\n\n#define tcTUU tcT, class ...U\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n\n\n// for debugging!\n#define MACRO(code) do {code} while (false)\n#define DBG(x) MACRO(cerr << #x << \" = \" << (x) << endl;)\n#define DBGY(x) MACRO(cerr << #x << \" = \" << (x) << \" , \";)\n#define DBG2(x,y) MACRO(DBGY(x); DBG(y);)\n#define DBG3(x,y,z) MACRO(DBGY(x); DBGY(y); DBG(z);)\n#define DBG4(x,y,z,w) MACRO(DBGY(x); DBGY(y); DBGY(z); DBG(w);)\n#define RAYA MACRO(cerr << \" ================ \" << endl;)\n\ntemplate <typename T>\nostream& operator <<(ostream &os, const vector<T>& v) {\n    os << \"[\";\n\n    for(int i = 0; i < int(v.size()); i++) {\n        if (i > 0) os << \" \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate <typename T>\nostream& operator <<(ostream &os, const set<T>& v) {\n    vector<T> tmp;\n    for(auto& e: v) {\n        tmp.emplace_back(e);\n    }\n\n    return os << tmp;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream &os, const pair<T, T>& v) {\n    return os << \"{\" << v.first << \", \" << v.second << \"}\";\n}\n\n\n\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n// Direction vectors\nint dRow[] = { -1, 0, 1,  0 };\nint dCol[] = {  0, 1, 0, -1 };\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst char n_l = '\\n';\n\ntemplate <typename T>\ninline T gcd(T a, T b) { while (b != 0) swap(b, a %= b); return a; }\n\ntemplate<typename T>\nT pot(T a, T b) { // a^b\n    assert(b >= 0);\n\n    T res = 1;\n    for(int _ = 1; _ <= b; _++) res *= a;\n    return res;\n}\n\n// here goes the template!\n\ntypedef long double DOUBLE;\ntypedef vector<DOUBLE> VD;\ntypedef vector<VD> VVD;\ntypedef vector<int> VI;\n\nconst DOUBLE EPS = 1e-12;\n\nstruct LPSolver {\n  int m, n;\n  VI B, N;\n  VVD D;\n\n  LPSolver(const VVD &A, const VD &b, const VD &c) :\n    m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) {\n    for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j];\n    for (int i = 0; i < m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }\n    for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; }\n    N[n] = -1; D[m + 1][n] = 1;\n  }\n\n  void Pivot(int r, int s) {\n    double inv = 1.0 / D[r][s];\n    for (int i = 0; i < m + 2; i++) if (i != r)\n      for (int j = 0; j < n + 2; j++) if (j != s)\n        D[i][j] -= D[r][j] * D[i][s] * inv;\n    for (int j = 0; j < n + 2; j++) if (j != s) D[r][j] *= inv;\n    for (int i = 0; i < m + 2; i++) if (i != r) D[i][s] *= -inv;\n    D[r][s] = inv;\n    swap(B[r], N[s]);\n  }\n\n  bool Simplex(int phase) {\n    int x = phase == 1 ? m + 1 : m;\n    while (true) {\n      int s = -1;\n      for (int j = 0; j <= n; j++) {\n        if (phase == 2 && N[j] == -1) continue;\n        if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j;\n      }\n      if (D[x][s] > -EPS) return true;\n      int r = -1;\n      for (int i = 0; i < m; i++) {\n        if (D[i][s] < EPS) continue;\n        if (r == -1 || D[i][n + 1] / D[i][s] < D[r][n + 1] / D[r][s] ||\n          (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) && B[i] < B[r]) r = i;\n      }\n      if (r == -1) return false;\n      Pivot(r, s);\n    }\n  }\n\n  DOUBLE Solve(VD &x) {\n    int r = 0;\n    for (int i = 1; i < m; i++) if (D[i][n + 1] < D[r][n + 1]) r = i;\n    if (D[r][n + 1] < -EPS) {\n      Pivot(r, n);\n      if (!Simplex(1) || D[m + 1][n + 1] < -EPS) return -numeric_limits<DOUBLE>::infinity();\n      for (int i = 0; i < m; i++) if (B[i] == -1) {\n        int s = -1;\n        for (int j = 0; j <= n; j++)\n          if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j;\n        Pivot(i, s);\n      }\n    }\n    if (!Simplex(2)) return numeric_limits<DOUBLE>::infinity();\n    x = VD(n);\n    for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n + 1];\n    return D[m][n + 1];\n  }\n};\n\n// /here goes the template!\nconst long double EPSS = 1e-9;\n\nbool Equ(long double a, long double b) {\n    return abs(a-b)<EPSS;\n}\n\nbool isInteger(long double k) {\n    return Equ(floor(k), k);\n}\n\n// here goes the work!\nvoid solve() {\n    long double n, m, i, j, offsetx, offsety;\n    cin >> n >> m >> i >> j >> offsetx >> offsety;\n\n    VVD A {\n        {-offsetx, -offsetx,  offsetx,  offsetx},\n        { offsetx,  offsetx, -offsetx, -offsetx},\n        {-offsety,  offsety, -offsety,  offsety},\n        { offsety, -offsety,  offsety, -offsety},\n    };\n\n    vector<pair<long double, long double>> work {\n        mp(1.0,   m),\n        mp(  n, 1.0),\n        mp(  n,   m),\n        mp(1.0, 1.0)\n    };\n\n    long double ans = 1e12;\n    bool global_ok = false;\n    for(auto& e: work) {\n        VD b = {e.first - i, -(e.first - i), e.second - j, -(e.second - j)};\n        VD c = {-1.0, -1.0, -1.0, -1.0};\n\n        LPSolver solver(A, b, c);\n        VD x;\n        long double res = solver.Solve(x) * -1.0;\n        assert(isInteger(res));\n\n        bool local_ok = true;\n        for(auto& ee: x) local_ok &= isInteger(ee);\n        if(local_ok) {\n            assert(res >= 0);\n            ans = min(ans, abs(res));\n            global_ok = true;\n        }\n        RAYA;\n    }\n\n    if(global_ok) cout << ans << n_l;\n    else cout << \"Poor Inna and pony!\\n\";\n}\n\n// https://codeforces.com/contest/1421/problem/D\n// D. Hexagons\nsigned main() {\n    // read read read\n\tsetIO();\n    // cout << fixed << setprecision(12);\n\n    long long t = 1LL;\n    // cin >> t;\n\n    while(t--) {\n        solve();\n    }\n\n    // should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n\n//! ERASE DBGs xd or TLE\n\n\t  \t\t  \t\t\t\t  \t\t   \t \t   \t  \t"
}