{
    "id": 215311593,
    "contestId": 1556,
    "creationTimeSeconds": 1690181228,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1556,
        "index": "H",
        "name": "DIY Tree",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3300,
        "tags": [
            "graphs",
            "greedy",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1556,
        "members": [
            {
                "handle": "bkifhr10"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1630247700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 143,
    "timeConsumedMillis": 5928,
    "memoryConsumedBytes": 102400,
    "source": "\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"arch=skylake\")\n\n\n#include <bits/stdc++.h>\n#define taskname \"\"\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define ll long long\n#define ld long double\n#define pb push_back\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define vi vector<int>\n#define vii vector<pii>\n#define isz(x) (int)x.size()\nusing namespace std;\n\nconst int mxN = 2e5 + 5;\nconst int mod = 1e9 + 7;\nconst ll oo = 1e18;\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nint rand_range(int l, int r) {\n    return rng() % (r - l + 1) + l;\n};\n\ntemplate<bool Enable_small_to_large = true>\nstruct disjoint_set{\n    int n, _classes;\n    vector<int> p;\n    disjoint_set(int n): n(n), _classes(n), p(n, -1){ }\n    int make_set(){\n        p.push_back(-1);\n        ++ _classes;\n        return n ++;\n    }\n    int classes() const{\n        return _classes;\n    }\n    int root(int u){\n        return p[u] < 0 ? u : p[u] = root(p[u]);\n    }\n    bool share(int a, int b){\n        return root(a) == root(b);\n    }\n    int size(int u){\n        return -p[root(u)];\n    }\n    bool merge(int u, int v){\n        u = root(u), v = root(v);\n        if(u == v) return false;\n        -- _classes;\n        if constexpr(Enable_small_to_large) if(p[u] > p[v]) swap(u, v);\n        p[u] += p[v], p[v] = u;\n        return true;\n    }\n    bool merge(int u, int v, auto act){\n        u = root(u), v = root(v);\n        if(u == v) return false;\n        -- _classes;\n        bool swapped = false;\n        if constexpr(Enable_small_to_large) if(p[u] > p[v]) swap(u, v), swapped = true;\n        p[u] += p[v], p[v] = u;\n        act(u, v, swapped);\n        return true;\n    }\n    void clear(){\n        _classes = n;\n        fill(p.begin(), p.end(), -1);\n    }\n    vector<vector<int>> group_up(){\n        vector<vector<int>> g(n);\n        for(auto i = 0; i < n; ++ i) g[root(i)].push_back(i);\n        g.erase(remove_if(g.begin(), g.end(), [&](auto &s){ return s.empty(); }), g.end());\n        return g;\n    }\n};\n\nstruct State {\n    vi d;\n    vii tree;\n    int sum = 0;\n};\n\nvi d;\nvii all_edges;\nint n, k, w[55][55];\n\nint evaluate(State &state) {\n    return state.sum;\n}\n\nState neighboring_state(State state) {\n    disjoint_set dsu(n + 1);\n    int pos = rand_range(0, n - 2);\n    vii tree = state.tree, new_tree;\n\n    int dangcap1, dangcap2;\n    for(int i = 0; i < n - 1; ++i) {\n        if(pos == i) {\n            dangcap1 = tree[i].ff, dangcap2 = tree[i].ss;\n            ++state.d[dangcap1], ++state.d[dangcap2];\n            state.sum -= w[dangcap1][dangcap2];\n            continue;\n        }\n        new_tree.pb(tree[i]);\n        dsu.merge(tree[i].ff, tree[i].ss);\n    }\n    dangcap1 = dsu.root(dangcap1);\n    dangcap2 = dsu.root(dangcap2);\n\n    \n    vi comp1, comp2;\n    for(int i = 1; i <= n; ++i) {\n        if(!state.d[i]) continue;\n        if(dsu.root(i) == dangcap1) comp1.emplace_back(i);\n        else comp2.emplace_back(i);\n    }\n\n    // int miin = mod;\n    // for(int &val1 : comp1) {\n    //     for(int &val2 : comp2) {\n    //         if(miin < )\n    //     }\n    // }\n\n    int pos1 = comp1[rand_range(0, isz(comp1) - 1)];\n    int pos2 = comp2[rand_range(0, isz(comp2) - 1)];\n    new_tree.emplace_back(pos1, pos2); state.sum += w[pos1][pos2];\n    state.tree.swap(new_tree); --state.d[pos1], --state.d[pos2];\n    return state;\n}\n\n// base: starting state\n// neighboring_state(state): returns a random neighbor of state\n// evaluate(state): returns the score of the state\n// Returns the state with maximum score among the searched states\ntemplate<class State>\nState simulated_annealing(State base, auto neighboring_state, auto evaluate, double time_limit) {\n    mt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n    uniform_real_distribution<double> gen(0, 1);\n    State current = base, best = current;\n    auto current_score = evaluate(current), best_score = current_score;\n    auto acceptance_probability = [&](auto current_score, auto next_score, double temperature) -> double {\n        return next_score < current_score ? 1 : exp((current_score - next_score) / temperature);\n    };\n    double temperature = 1e5;\n    for(auto START = chrono::high_resolution_clock::now(); chrono::duration<double>(chrono::high_resolution_clock::now() - START).count() <= time_limit; ) {\n        // double temperature = chrono::duration<double>(chrono::high_resolution_clock::now() - START).count() / time_limit;\n        // cout << temperature << endl;\n        State next = neighboring_state(current);\n        auto next_score = evaluate(next);\n        if(best_score > next_score) {\n            best = next;\n            best_score = next_score;\n        }\n        if(acceptance_probability(current_score, next_score, temperature) >= gen(rng)) {\n            current = next;\n            current_score = next_score;\n        }\n        temperature *= (double)0.99999;\n    }\n    return best;\n}\n\nvoid solve() {\n    cin >> n >> k;\n    d.assign(n + 1, n);\n    for(int i = 1; i <= k; ++i)\n        cin >> d[i];\n    all_edges.clear();\n    for(int i = 1; i <= n; ++i) {\n        for(int j = i + 1; j <= n; ++j) {\n            cin >> w[i][j];\n            w[j][i] = w[i][j];\n            all_edges.emplace_back(i, j);\n        }\n    }\n\n    State base;\n    base.d = d;\n\n    disjoint_set dsu(n + 1);\n    for(int i = 1; i < n; ++i) {\n        vii newedges;\n        int pos = rand_range(0, isz(all_edges) - 1);\n        int u = all_edges[pos].ff, v = all_edges[pos].ss;\n        dsu.merge(u, v); --base.d[u], --base.d[v];\n        base.tree.emplace_back(u, v); base.sum += w[u][v];\n        for(auto &tmp : all_edges) {\n            int u = tmp.ff, v = tmp.ss;\n            if(dsu.share(u, v) || !base.d[u] || !base.d[v])\n                continue;\n            newedges.pb(tmp);\n        }\n        if(i < n - 1) assert(!newedges.empty());\n        all_edges.swap(newedges);\n    }\n\n    auto result = simulated_annealing(base, neighboring_state, evaluate, (double)5.9);\n    // for(pii &tmp : result.tree) {\n    //     cout << tmp.ff << \" \" << tmp.ss << endl;\n    // }\n    cout << evaluate(result) << endl;\n}\n\nsigned main() {\n\n#ifndef CDuongg\n    if(fopen(taskname\".inp\", \"r\"))\n        assert(freopen(taskname\".inp\", \"r\", stdin)), assert(freopen(taskname\".out\", \"w\", stdout));\n#else\n    freopen(\"bai3.inp\", \"r\", stdin);\n    freopen(\"bai3.out\", \"w\", stdout);\n    auto start = chrono::high_resolution_clock::now();\n#endif\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1; //cin >> t;\n    while(t--) solve();\n\n#ifdef CDuongg\n    auto end = chrono::high_resolution_clock::now();\n    cout << \"\\n\"; for(int i = 1; i <= 100; ++i) cout << '=';\n    cout << \"\\nExecution time: \" << chrono::duration_cast<chrono::milliseconds> (end - start).count() << \"[ms]\" << endl;\n#endif\n\n}\n \t \t\t  \t\t  \t \t \t\t \t\t\t\t\t\t\t\t   \t\t"
}