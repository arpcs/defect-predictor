{
    "id": 215309114,
    "contestId": 1556,
    "creationTimeSeconds": 1690179739,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1556,
        "index": "H",
        "name": "DIY Tree",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3300,
        "tags": [
            "graphs",
            "greedy",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1556,
        "members": [
            {
                "handle": "CDuongg"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1630247700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 5974,
    "memoryConsumedBytes": 102400,
    "source": "/*\r\n#pragma GCC optimize(\"Ofast,unroll-loops\")\r\n#pragma GCC target(\"avx2,fma,bmi,bmi2,sse4.2,popcnt,lzcnt\")\r\n*/\r\n\r\n#include <bits/stdc++.h>\r\n#define taskname \"\"\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define ll long long\r\n#define ld long double\r\n#define pb push_back\r\n#define ff first\r\n#define ss second\r\n#define pii pair<int, int>\r\n#define vi vector<int>\r\n#define vii vector<pii>\r\n#define isz(x) (int)x.size()\r\nusing namespace std;\r\n\r\nconst int mxN = 2e5 + 5;\r\nconst int mod = 1e9 + 7;\r\nconst ll oo = 1e18;\r\n\r\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\r\nint rand_range(int l, int r) {\r\n    return rng() % (r - l + 1) + l;\r\n};\r\n\r\ntemplate<bool Enable_small_to_large = true>\r\nstruct disjoint_set{\r\n    int n, _classes;\r\n    vector<int> p;\r\n    disjoint_set(int n): n(n), _classes(n), p(n, -1){ }\r\n    int make_set(){\r\n        p.push_back(-1);\r\n        ++ _classes;\r\n        return n ++;\r\n    }\r\n    int classes() const{\r\n        return _classes;\r\n    }\r\n    int root(int u){\r\n        return p[u] < 0 ? u : p[u] = root(p[u]);\r\n    }\r\n    bool share(int a, int b){\r\n        return root(a) == root(b);\r\n    }\r\n    int size(int u){\r\n        return -p[root(u)];\r\n    }\r\n    bool merge(int u, int v){\r\n        u = root(u), v = root(v);\r\n        if(u == v) return false;\r\n        -- _classes;\r\n        if constexpr(Enable_small_to_large) if(p[u] > p[v]) swap(u, v);\r\n        p[u] += p[v], p[v] = u;\r\n        return true;\r\n    }\r\n    bool merge(int u, int v, auto act){\r\n        u = root(u), v = root(v);\r\n        if(u == v) return false;\r\n        -- _classes;\r\n        bool swapped = false;\r\n        if constexpr(Enable_small_to_large) if(p[u] > p[v]) swap(u, v), swapped = true;\r\n        p[u] += p[v], p[v] = u;\r\n        act(u, v, swapped);\r\n        return true;\r\n    }\r\n    void clear(){\r\n        _classes = n;\r\n        fill(p.begin(), p.end(), -1);\r\n    }\r\n    vector<vector<int>> group_up(){\r\n        vector<vector<int>> g(n);\r\n        for(auto i = 0; i < n; ++ i) g[root(i)].push_back(i);\r\n        g.erase(remove_if(g.begin(), g.end(), [&](auto &s){ return s.empty(); }), g.end());\r\n        return g;\r\n    }\r\n};\r\n\r\nstruct State {\r\n    vi d;\r\n    vii tree;\r\n    int sum = 0;\r\n};\r\n\r\nvi d;\r\nvii all_edges;\r\nint n, k, w[55][55];\r\n\r\nint evaluate(State &state) {\r\n    return state.sum;\r\n}\r\n\r\nState neighboring_state(State state) {\r\n    disjoint_set dsu(n + 1);\r\n    int pos = rand_range(0, n - 2);\r\n    vii tree = state.tree, new_tree;\r\n\r\n    int dangcap1, dangcap2;\r\n    for(int i = 0; i < n - 1; ++i) {\r\n        if(pos == i) {\r\n            dangcap1 = tree[i].ff, dangcap2 = tree[i].ss;\r\n            ++state.d[dangcap1], ++state.d[dangcap2];\r\n            state.sum -= w[dangcap1][dangcap2];\r\n            continue;\r\n        }\r\n        new_tree.pb(tree[i]);\r\n        dsu.merge(tree[i].ff, tree[i].ss);\r\n    }\r\n    dangcap1 = dsu.root(dangcap1);\r\n    dangcap2 = dsu.root(dangcap2);\r\n\r\n    \r\n    vi comp1, comp2;\r\n    for(int i = 1; i <= n; ++i) {\r\n        if(!state.d[i]) continue;\r\n        if(dsu.root(i) == dangcap1) comp1.emplace_back(i);\r\n        else comp2.emplace_back(i);\r\n    }\r\n\r\n    // int miin = mod;\r\n    // for(int &val1 : comp1) {\r\n    //     for(int &val2 : comp2) {\r\n    //         if(miin < )\r\n    //     }\r\n    // }\r\n\r\n    int pos1 = comp1[rand_range(0, isz(comp1) - 1)];\r\n    int pos2 = comp2[rand_range(0, isz(comp2) - 1)];\r\n    new_tree.emplace_back(pos1, pos2); state.sum += w[pos1][pos2];\r\n    state.tree.swap(new_tree); --state.d[pos1], --state.d[pos2];\r\n    return state;\r\n}\r\n\r\n// base: starting state\r\n// neighboring_state(state): returns a random neighbor of state\r\n// evaluate(state): returns the score of the state\r\n// Returns the state with maximum score among the searched states\r\ntemplate<class State>\r\nState simulated_annealing(State base, auto neighboring_state, auto evaluate, double time_limit) {\r\n    mt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\r\n    uniform_real_distribution<double> gen(0, 1);\r\n    State current = base, best = current;\r\n    auto current_score = evaluate(current), best_score = current_score;\r\n    auto acceptance_probability = [&](auto current_score, auto next_score, double temperature) -> double {\r\n        return next_score < current_score ? 1 : exp((current_score - next_score) / temperature);\r\n    };\r\n    double temperature = 1e5;\r\n    for(auto START = chrono::high_resolution_clock::now(); chrono::duration<double>(chrono::high_resolution_clock::now() - START).count() <= time_limit; ) {\r\n        // double temperature = chrono::duration<double>(chrono::high_resolution_clock::now() - START).count() / time_limit;\r\n        State next = neighboring_state(current);\r\n        auto next_score = evaluate(next);\r\n        if(best_score > next_score) {\r\n            best = next;\r\n            best_score = next_score;\r\n        }\r\n        if(acceptance_probability(current_score, next_score, temperature) >= gen(rng)) {\r\n            current = next;\r\n            current_score = next_score;\r\n        }\r\n        temperature *= (double)0.999;\r\n    }\r\n    return best;\r\n}\r\n\r\nvoid solve() {\r\n    cin >> n >> k;\r\n    d.assign(n + 1, n);\r\n    for(int i = 1; i <= k; ++i)\r\n        cin >> d[i];\r\n    all_edges.clear();\r\n    for(int i = 1; i <= n; ++i) {\r\n        for(int j = i + 1; j <= n; ++j) {\r\n            cin >> w[i][j];\r\n            w[j][i] = w[i][j];\r\n            all_edges.emplace_back(i, j);\r\n        }\r\n    }\r\n\r\n    State base;\r\n    base.d = d;\r\n\r\n    disjoint_set dsu(n + 1);\r\n    for(int i = 1; i < n; ++i) {\r\n        vii newedges;\r\n        int pos = rand_range(0, isz(all_edges) - 1);\r\n        int u = all_edges[pos].ff, v = all_edges[pos].ss;\r\n        dsu.merge(u, v); --base.d[u], --base.d[v];\r\n        base.tree.emplace_back(u, v); base.sum += w[u][v];\r\n        for(auto &tmp : all_edges) {\r\n            int u = tmp.ff, v = tmp.ss;\r\n            if(dsu.share(u, v) || !base.d[u] || !base.d[v])\r\n                continue;\r\n            newedges.pb(tmp);\r\n        }\r\n        if(i < n - 1) assert(!newedges.empty());\r\n        all_edges.swap(newedges);\r\n    }\r\n\r\n    auto result = simulated_annealing(base, neighboring_state, evaluate, (double)6);\r\n    // for(pii &tmp : result.tree) {\r\n    //     cout << tmp.ff << \" \" << tmp.ss << endl;\r\n    // }\r\n    cout << evaluate(result) << endl;\r\n}\r\n\r\nsigned main() {\r\n\r\n#ifndef CDuongg\r\n    if(fopen(taskname\".inp\", \"r\"))\r\n        assert(freopen(taskname\".inp\", \"r\", stdin)), assert(freopen(taskname\".out\", \"w\", stdout));\r\n#else\r\n    freopen(\"bai3.inp\", \"r\", stdin);\r\n    freopen(\"bai3.out\", \"w\", stdout);\r\n    auto start = chrono::high_resolution_clock::now();\r\n#endif\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int t = 1; //cin >> t;\r\n    while(t--) solve();\r\n\r\n#ifdef CDuongg\r\n    auto end = chrono::high_resolution_clock::now();\r\n    cout << \"\\n\"; for(int i = 1; i <= 100; ++i) cout << '=';\r\n    cout << \"\\nExecution time: \" << chrono::duration_cast<chrono::milliseconds> (end - start).count() << \"[ms]\" << endl;\r\n#endif\r\n\r\n}"
}