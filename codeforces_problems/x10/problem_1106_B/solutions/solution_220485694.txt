{
    "id": 220485694,
    "contestId": 1106,
    "creationTimeSeconds": 1693040424,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1106,
        "index": "B",
        "name": "Lunar New Year and Food Ordering",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1500,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 1106,
        "members": [
            {
                "handle": "aryankesharwani142004"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1548938100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 64,
    "timeConsumedMillis": 514,
    "memoryConsumedBytes": 6963200,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define MAX 1e6+1\r\nbool cmp(const pair<pair<int,int>,int>& a,const pair<pair<int,int>,int>& b){\r\n    if (a.first.first != b.first.first)\r\n        return (a.first.first > b.first.first);\r\n    else\r\n        return (a.second > b.second);\r\n}\r\nbool cmp1(const pair<pair<int,int>,int>& a,const pair<pair<int,int>,int>& b){\r\n    return (a.first.first > b.first.first);\r\n}\r\n// bool cmp2(const pair<pair<int,int>,int>& a,const pair<pair<int,int>,int>& b){\r\n//     if(a.first.first==b.first.first){\r\n//         return (a.second > b.second);\r\n//     }\r\n//     else{\r\n//         return a.first.first>b.first.first;\r\n//     }\r\n// }\r\nint mod_power(int x,int y,int m){//for calculating inverse through this check that m is prime x is indivisible by m and then a^(m-2)mod m=(a^-1)mod m\r\n    int res=1;//put y=m-2 to get inverse mod\r\n    while(y>0){\r\n        if(y%2==1){\r\n            res=(res*1LL*x)%m;\r\n            y--;\r\n        }\r\n        else{\r\n            x=(x*1LL*x)%m;\r\n            y/=2;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n//vector<int> prime(MAX);\r\n//void SieveOfEratosthenes(){\r\n    //prime[0]=1;\r\n    //for(int i=0;i<MAX;i++){\r\n        //prime[i]=1;\r\n    //}\r\n    //for (int p = 2; p * p <= MAX; p++) {\r\n        //if (prime[p] == true) {\r\n            //for (int i = p * p; i <= MAX; i += p)\r\n                //prime[i] = false;\r\n        //}\r\n    //}\r\n//}\r\n//vector<int> smp(MAX);\r\n//void spf(){\r\n//\tsmp[0]=1;\r\n//\tfor(int i=1;i<MAX;i++){\r\n//\t\tsmp[i]=i;\r\n//\t}\r\n//\tfor(int i=2;i*i<MAX;i++){\r\n//\t\tif(smp[i]==i){\r\n//\t\t\tfor(int k=i*i;k<MAX;k=k+i){\r\n//\t\t\t\tif(smp[k]==k){\r\n//\t\t\t\t\tsmp[k]=i;\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n//\t}\r\n//}\r\nsigned main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int n,m;\r\n    cin>>n>>m;\r\n    vector<pair<int,int>> vec(n);\r\n    for(int i=0;i<n;i++){\r\n        cin>>vec[i].second;\r\n    }\r\n    for(int i=0;i<n;i++){\r\n        cin>>vec[i].first;\r\n    }\r\n    vector<pair<pair<int,int>,int>> temp(n);\r\n    for(int i=0;i<n;i++){\r\n        temp[i].first=vec[i];temp[i].second=i;\r\n    }\r\n    sort(temp.begin(),temp.end(),cmp);\r\n    vector<int> temp11,temp2;\r\n    for(int i=0;i<n;i++){\r\n        temp11.push_back(temp[i].first.first);\r\n        temp2.push_back(temp[i].second);\r\n    }\r\n    for(int q=0;q<m;q++){\r\n        int x,y;cin>>x>>y;int cost=0;\r\n        // int l=lower_bound(temp.begin(),temp.end(),vec[x-1].first)-temp.end();\r\n        // int r=upper_bound(temp.begin(),temp.end(),vec[x-1].first)-temp.end();\r\n        // int ansi=lower_bound(temp.begin()+l,temp.begin()+r,x-1)-temp.end();\r\n        int l=lower_bound(temp11.begin(),temp11.end(),vec[x-1].first,greater<int> ())-temp11.begin();//now we have got the starting index of temp whose cost are equal to this\r\n        int r=upper_bound(temp11.begin(),temp11.end(),vec[x-1].first,greater<int>())-temp11.begin();\r\n        int ansi=lower_bound(temp2.begin()+l,temp2.begin()+r,x-1,greater<int>())-temp2.begin();\r\n        // cout<<n<<endl;\r\n        if(n>0&&ansi<n&&temp[ansi].second==x-1){\r\n            if(y<=temp[ansi].first.second){\r\n                cost+=y*temp[ansi].first.first;\r\n                temp[ansi].first.second-=y;\r\n                y=0;\r\n            }\r\n            else{\r\n                cost+=temp[ansi].first.second*temp[ansi].first.first;\r\n                y-=temp[ansi].first.second;\r\n                temp[ansi].first.second=0;\r\n                int i=n-1;\r\n                while(y>0&&i>=0){\r\n                    if(y<=temp[i].first.second){\r\n                        cost+=y*temp[i].first.first;\r\n                        temp[i].first.second-=y;\r\n                        if(temp[i].first.second==0){\r\n                            temp.pop_back();\r\n                            temp11.pop_back();\r\n                            temp2.pop_back();\r\n                            n--;\r\n                        }\r\n                        y=0;\r\n                        break;\r\n                    }\r\n                    else{\r\n                        cost+=temp[i].first.second*temp[i].first.first;\r\n                        y-=temp[i].first.second;\r\n                        temp.pop_back();\r\n                        temp11.pop_back();\r\n                        temp2.pop_back();\r\n                        i--;n--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            int i=n-1;\r\n            while(y>0&&i>=0){\r\n                if(y<=temp[i].first.second){\r\n                    cost+=y*temp[i].first.first;\r\n                    temp[i].first.second-=y;\r\n                    if(temp[i].first.second==0){\r\n                        temp.pop_back();\r\n                        temp11.pop_back();\r\n                        temp2.pop_back();\r\n                        n--;\r\n                    }\r\n                    y=0;\r\n                    break;\r\n                }\r\n                else{\r\n                    cost+=temp[i].first.second*temp[i].first.first;\r\n                    y-=temp[i].first.second;\r\n                    temp.pop_back();\r\n                    temp11.pop_back();\r\n                    temp2.pop_back();\r\n                    i--;n--;\r\n                }\r\n            }\r\n        }\r\n        if(y>0){\r\n            cost=0;\r\n        }\r\n        cout<<cost<<endl;\r\n    }\r\n    return 0;\r\n}\r\n// if(vec[x-1].second>y){\r\n//             cost+=y*vec[x-1].first;\r\n//             vec[x-1].second-=y;\r\n//             int l=lower_bound(temp.begin(),temp.end(),x-1,cmp1)-temp.end();\r\n//             int r=upper_bound(temp.begin(),temp.end(),x-1,cmp1)-temp.end();\r\n//             int ansi=lower_bound(temp.begin()+l,temp.begin()+r,x-1,cmp2)-temp.end();\r\n//             if(ansi<n){\r\n//                 temp[ansi].second=vec[x-1].second;\r\n//             }  \r\n            \r\n//         }\r\n//         else{\r\n//             cost+=vec[x-1].second*vec[x-1].first;\r\n//             y-=vec[x-1].second;\r\n//             vec[x-1].second=0;\r\n//             int l=lower_bound(temp.begin(),temp.end(),x-1,cmp1)-temp.end();\r\n//             int r=upper_bound(temp.begin(),temp.end(),x-1,cmp1)-temp.end();\r\n//             int ansi=lower_bound(temp.begin()+l,temp.end()+r,x-1,cmp2)-temp.end();\r\n//             if(ansi<n){\r\n//                 temp[ansi].second=0;\r\n//             }   \r\n//             int i=n-1;\r\n//             while(y>0){\r\n//                 if(temp[i].first.second==0){\r\n//                     temp.pop_back();\r\n// temp11.pop_back();\r\n// temp2.pop_back();\r\n// //                     i--,n--;\r\n//                 }\r\n//                 else if(temp[i].first.second<=y){\r\n//                     y-=temp[i].first.second;\r\n//                     cost+=temp[i].first.second*temp[i].first.first;\r\n// //                     temp.pop_back();\r\n// temp11.pop_back();\r\n// temp2.pop_back();\r\n//                     i--,n--;\r\n//                 }\r\n//                 else if(temp[i].first.second>y){\r\n//                     temp[i].first.second-=y;\r\n//                     cost+=y*temp[i].first.first;\r\n//                     y=0;\r\n//                 }\r\n//             }\r\n//         }"
}