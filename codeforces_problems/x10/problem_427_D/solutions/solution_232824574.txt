{
    "id": 232824574,
    "contestId": 427,
    "creationTimeSeconds": 1700033151,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 427,
        "index": "D",
        "name": "Match & Catch",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "dp",
            "string suffix structures",
            "strings"
        ]
    },
    "author": {
        "contestId": 427,
        "members": [
            {
                "handle": "B.White"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1399044600
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 169,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 19148800,
    "source": "#include <random>\r\n#include <bits/stdc++.h>\r\n\r\n#define rep(i, from, to) for(int i=from;i<to;i++)\r\n#define ite(i, arr) for(auto &i:arr)\r\n#define ALL(arr) arr.begin(),arr.end()\r\n#define vc vector\r\n#define vi vector<int>\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\ntypedef long long ll;\r\nusing namespace std;\r\n\r\nconst ll N = (int) 2e4 + 7;\r\nll mod = 998244353;\r\n#define int ll\r\n\r\nnamespace Geo {\r\n\tconst double eps = 1e-9;\r\n\tconst double PI = acos(-1);\r\n\t\r\n\tstruct Point {\r\n\t\tdouble x, y;\r\n\t\t\r\n\t\tPoint() {\r\n\t\t\tx = 0, y = 0;\r\n\t\t}\r\n\t\t\r\n\t\tPoint(double x, double y) {\r\n\t\t\tthis->x = x;\r\n\t\t\tthis->y = y;\r\n\t\t}\r\n\t};\r\n\t\r\n\tbool operator==(Point a, Point b) {\r\n\t\treturn a.x = b.x && a.y == b.y;\r\n\t}\r\n\t\r\n\tbool operator<(Point a, Point b) {\r\n\t\treturn a.y < b.y || a.y == b.y && a.x < b.x;\r\n\t}\r\n\t\r\n\tbool operator>(Point a, Point b) {\r\n\t\treturn !(a < b) && !(a == b);\r\n\t}\r\n\t\r\n\tPoint operator+(Point a, Point b) {\r\n\t\treturn Point(a.x + b.x, a.y + b.y);\r\n\t}\r\n\t\r\n\tPoint operator-(Point a, Point b) {\r\n\t\treturn Point(a.x - b.x, a.y - b.y);\r\n\t}\r\n\t\r\n\tPoint operator*(double a, Point b) {\r\n\t\treturn Point(a * b.x, a * b.y);\r\n\t}\r\n\t\r\n\tPoint operator*(Point b, double a) {\r\n\t\treturn Point(a * b.x, a * b.y);\r\n\t}\r\n\t\r\n\tPoint operator/(Point b, double a) {\r\n\t\treturn Point(b.x / a, b.y / a);\r\n\t}\r\n\t\r\n\tdouble len(Point a) {\r\n\t\treturn sqrt(a.x * a.x + a.y * a.y);\r\n\t}\r\n\t\r\n\tdouble dis(Point a, Point b) {\r\n\t\treturn len(a - b);\r\n\t}\r\n\t\r\n\tbool operator!=(Point a, Point b) {\r\n\t\treturn !(a == b);\r\n\t}\r\n\t\r\n\tdouble operator*(Point a, Point b) {\r\n\t\treturn a.x * b.x + a.y * b.y;\r\n\t}\r\n\t\r\n\tdouble operator^(Point a, Point b) {\r\n\t\treturn a.x * b.y - a.y * b.x;\r\n\t}\r\n\t\r\n\tdouble getAngel(double b, double a, double c) {\r\n\t\treturn acos((a * a + c * c - b * b) / (2 * a * c));\r\n\t}\r\n\t\r\n\tdouble getAngel(Point a, Point b) {\r\n\t\treturn acos(a * b / len(a) / len(b));\r\n\t}\r\n\t\r\n\tPoint inter(Point p, Point v, Point q, Point w) {\r\n\t\tPoint u = p - q;\r\n\t\tdouble t = (w ^ u) / (v ^ w);\r\n\t\treturn p + t * v;\r\n\t}\r\n}\r\n\r\nll ADD(ll a, ll b) {\r\n\tll res = 0;\r\n\tres += a;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\tres += b;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\treturn res;\r\n}\r\n\r\nll ADD(ll a, ll b, ll c) {\r\n\tll res = 0;\r\n\tres += a;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\tres += b;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\tres += c;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\treturn res;\r\n}\r\n\r\nll ADD(ll a, ll b, ll c, ll d) {\r\n\tll res = 0;\r\n\tres += a;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\tres += b;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\tres += c;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\tres += d;\r\n\tif (res >= mod) res -= mod;\r\n\telse if (res < 0) res += mod;\r\n\treturn res;\r\n}\r\n\r\nll lowbit(ll b) { return b & (-b); }\r\n\r\nll qmi(ll a, ll b) {\r\n\tif (b == -1) return qmi(a, mod - 2);\r\n\ta %= mod;\r\n\tll res = 1;\r\n\twhile (b) {\r\n\t\tif (b & 1) res = res * a % mod;\r\n\t\ta = a * a % mod;\r\n\t\tb >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nll inv(ll b) {\r\n\treturn qmi(b, mod - 2);\r\n}\r\n\r\nnamespace NTT {\r\n\tint re[N * 8], w[2][N * 8], t0[N * 8], t1[N * 8], t2[N * 8];\r\n\t\r\n\tint getre(int n) {\r\n\t\tint len = 1, bit = 0;\r\n\t\twhile (len < n)len <<= 1, ++bit;\r\n\t\tfor (int i = 1; i < len; ++i)\r\n\t\t\tre[i] = (re[i >> 1] >> 1) | ((i & 1) << (bit - 1));\r\n\t\tw[0][0] = w[1][0] = 1;\r\n\t\tw[0][1] = qmi(3, (mod - 1) / len);\r\n\t\tw[1][1] = inv(w[0][1]);\r\n\t\tfor (int o = 0; o < 2; ++o)\r\n\t\t\tfor (int i = 2; i < len; ++i)\r\n\t\t\t\tw[o][i] = w[o][i - 1] * w[o][1] % mod;\r\n\t\treturn len;\r\n\t}\r\n\t\r\n\tvoid NTT(int *a, int n, int o = 0) {\r\n\t\t\r\n\t\tfor (int i = 1; i < n; ++i) {\r\n\t\t\tif (i >= N || i < 0 || re[i] >= N || re[i] < 0) {\r\n\t\t\t\tcout << i << endl;\r\n\t\t\t\tcout << re[i] << endl;\r\n\t\t\t\tassert(false);\r\n\t\t\t}\r\n\t\t\tif (i < re[i]) {\r\n\t\t\t\t\r\n\t\t\t\tswap(a[i], a[re[i]]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint R;\r\n\t\tfor (int k = 1; k < n; k <<= 1)\r\n\t\t\tfor (int i = 0, t = k << 1, st = n / t; i < n; i += t)\r\n\t\t\t\tfor (int j = 0, nw = 0; j < k; ++j, nw += st) {\r\n\t\t\t\t\tR = a[i + j + k] * w[o][nw] % mod;\r\n\t\t\t\t\ta[i + j + k] = ADD(a[i + j], -R);\r\n\t\t\t\t\ta[i + j] = ADD(a[i + j], R);\r\n\t\t\t\t}\r\n\t\tif (o) {\r\n\t\t\tR = inv(n);\r\n\t\t\tfor (int i = 0; i < n; ++i)a[i] = a[i] * R % mod;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid multi(const int *a, const int *b, int *c, int n, int m) {\r\n\t\tif (n + m <= 32) {\r\n\t\t\tmemset(c, 0, sizeof(int) * (n + m + 1));\r\n\t\t\tfor (int i = 0; i <= n; ++i)\r\n\t\t\t\tfor (int j = 0; j <= m; ++j)\r\n\t\t\t\t\tc[i + j] = ADD(c[i + j], a[i] * b[j] % mod);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint len = getre(n + m + 1);\r\n\t\tmemset(t0, 0, sizeof(int) * len), memcpy(t0, a, sizeof(int) * (n + 1));\r\n\t\tmemset(t1, 0, sizeof(int) * len), memcpy(t1, b, sizeof(int) * (m + 1));\r\n\t\tNTT(t0, len), NTT(t1, len);\r\n\t\tfor (int i = 0; i < len; ++i)t0[i] = t0[i] * t1[i] % mod;\r\n\t\tNTT(t0, len, 1);\r\n\t\tmemcpy(c, t0, sizeof(int) * (n + m + 1));\r\n\t}\r\n\t\r\n\tvoid inver(const int *a, int *b, int n) {\r\n\t\tint len = 1;\r\n\t\twhile (len <= n)len <<= 1;\r\n\t\tmemset(t0, 0, sizeof(int) * len), memcpy(t0, a, sizeof(int) * (n + 1));\r\n\t\tmemset(t1, 0, sizeof(int) * (len << 1));\r\n\t\tmemset(t2, 0, sizeof(int) * (len << 1));\r\n\t\tt2[0] = inv(t0[0]);\r\n\t\tfor (int k = 1; k <= len; k <<= 1) {\r\n\t\t\tmemcpy(t1, t0, sizeof(int) * k);\r\n\t\t\tgetre(k << 1);\r\n\t\t\tNTT(t1, k << 1), NTT(t2, k << 1);\r\n\t\t\tfor (int i = 0; i < (k << 1); ++i)\r\n\t\t\t\tt2[i] = t2[i] * ADD(2, t1[i] * t2[i] % mod * -1) % mod;\r\n\t\t\tNTT(t2, k << 1, 1);\r\n\t\t\tfor (int i = k; i < (k << 1); ++i)t2[i] = 0;\r\n\t\t}\r\n\t\tmemcpy(b, t2, sizeof(int) * (n + 1));\r\n\t}\r\n} //namespace NTT\r\n\r\nstruct poly : public vector<int> {\r\n\tint time() const { return size() - 1; }\r\n\t\r\n\tpoly(int tim = 0, int c = 0) {\r\n\t\tresize(tim + 1);\r\n\t\tif (tim >= 0)at(0) = c;\r\n\t}\r\n\t\r\n\tpoly operator%(const int &n) const {\r\n\t\tpoly r(*this);\r\n\t\tr.resize(n + 1);\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tpoly operator%=(const int &n) {\r\n\t\tresize(n + 1);\r\n\t\treturn *this;\r\n\t}\r\n\t\r\n\tpoly operator+(const poly &p) const {\r\n\t\tint n = time(), m = p.time();\r\n\t\tpoly r(*this);\r\n\t\tif (n < m)r.resize(m + 1);\r\n\t\tfor (int i = 0; i <= m; ++i)r[i] = ADD(r[i], p[i]);\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tpoly operator-(const poly &p) const {\r\n\t\tint n = time(), m = p.time();\r\n\t\tpoly r(*this);\r\n\t\tif (n < m)r.resize(m + 1);\r\n\t\tfor (int i = 0; i <= m; ++i)r[i] = ADD(r[i], -p[i]);\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tpoly operator*(const poly &p) const {\r\n\t\tpoly r(time() + p.time());\r\n\t\tNTT::multi(&((*this)[0]), &p[0], &r[0], time(), p.time());\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tpoly operator*(const int &k) const {\r\n\t\tpoly r(*this);\r\n\t\tint n = time();\r\n\t\tfor (int i = 0; i <= n; ++i)r[i] = (r[i] * k + mod) % mod;\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tpoly operator~() const {\r\n\t\tpoly r(*this);\r\n\t\treverse(r.begin(), r.end());\r\n\t\treturn r;\r\n\t}\r\n};\r\n\r\npoly inv(const poly &a) {\r\n\tpoly r(a.time());\r\n\tNTT::inver(&a[0], &r[0], a.time());\r\n\treturn r;\r\n}\r\n\r\npoly derive(const poly &a) {\r\n\tint n = a.time();\r\n\tpoly r(n);\r\n\tfor (int i = 1; i <= n; ++i)r[i - 1] = a[i] * i % mod;\r\n\treturn r;\r\n}\r\n\r\nint _[N];\r\n\r\npoly limit(const poly &a) {\r\n\tint n = a.time();\r\n\tpoly r(n + 1);\r\n\t_[1] = 1;\r\n\trep(i, 2, n + 1) {\r\n\t\t_[i] = _[mod % i] * (mod - mod / i) % mod;\r\n\t}\r\n\tfor (int i = 0; i <= n; ++i)r[i + 1] = 1LL * a[i] * _[i + 1] % mod;\r\n\treturn r;\r\n}\r\n\r\npoly ln(const poly &a) {\r\n\treturn limit(derive(a) * inv(a) % a.time());\r\n}\r\n\r\npoly exp(const poly &a) {\r\n\tpoly r(0, 1);\r\n\tint n = a.time(), k = 1;\r\n\twhile (r.time() < n)\r\n\t\tr %= k, r = r * (a % k - ln(r) + poly(0, 1)) % k, k <<= 1;\r\n\treturn r % (n + 1);\r\n}\r\n\r\npoly qmi(const poly &a, int k) {\r\n\treturn exp(ln(a) * k);\r\n}\r\n\r\npoly operator/(const poly &f, const poly &g) {\r\n\tint n = f.time() - g.time() + 1;\r\n\treturn ~((~f) * inv((~g) % n) % n);\r\n}\r\n\r\npoly operator%(const poly &f, const poly &g) {\r\n\tif (f.time() < g.time())return f;\r\n\treturn (f - g * (f / g) % g.time()) % g.time();\r\n}\r\n\r\n//ll invArr[N];\r\n//ll fact[(ll)N + 5];\r\n//ll inv_fact[(ll)N + 5];\r\n//\r\n//int prime[(int)N + 5];\r\n//int valid[(int)N + 5];\r\n//int pn = 0;\r\n//int phi[N];\r\n//int mu[N];\r\n//int sigma0[N];//\u56e0\u5b50\u4e2a\u6570\r\n//int e0[N];//\u6700\u5c0f\u56e0\u5b50\u7684\u4e2a\u6570\r\n////int sigma1[N];//\u7ea6\u6570\u548c\r\n////int e1[N];//g[i] \u8868\u793a i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684 p^0+p^1+p^2+..+p^k.\r\n//void sieve() {\r\n//\t//phi[1] = 1;\r\n//\t//sigma0[1] = 1;\r\n//\t//e0[1] = 1;\r\n//\t//e1[1] = 1;\r\n//\t//sigma1[1]=1;\r\n//\tmu[1] = 1;\r\n//\trep(i, 2, N) {\r\n//\t\tif (!valid[i]) {\r\n//\t\t\tvalid[i] = i;\r\n//\t\t\tprime[pn++] = i;\r\n//\t\t\t//phi[i] = i - 1;\r\n//\r\n//\t\t\t//sigma0[i] = 2;\r\n//\t\t\t//e0[i] = 1;\r\n//\r\n//\t\t\t//e1[i]=i+1;\r\n//\t\t\t//sigma1[i]=i+1;\r\n//\r\n//\t\t\tmu[i] = -1;\r\n//\t\t}\r\n//\t\tfor (int j = 0; j < pn && i * prime[j] < N; j++) {\r\n//\t\t\tvalid[i * prime[j]] = prime[j];\r\n//\t\t\tif (i % prime[j] == 0) {\r\n//\t\t\t\t//phi[i * prime[j]] = phi[i] * prime[j];\r\n//\r\n//\t\t\t\t//e0[i * prime[j]] = e0[i] + 1;\r\n//\t\t\t\t//sigma0[i * prime[j]] = sigma0[i] / (e0[i] + 1) * (e0[i] + 2);\r\n//\r\n//\t\t\t\t//e1[i*prime[j]]=e1[i]*prime[j]+1;\r\n//\t\t\t\t//sigma1[i*prime[j]]=sigma1[i]/e1[i]*e1[i*prime[j]];\r\n//\t\t\t\tmu[i * prime[j]] = 0;\r\n//\t\t\t\tbreak;\r\n//\t\t\t}\r\n//\t\t\telse {\r\n//\t\t\t\t//phi[i * prime[j]] = phi[i] * phi[prime[j]];\r\n//\r\n//\t\t\t\t//e0[i * prime[j]] = 1;\r\n//\t\t\t\t//sigma0[i * prime[j]] = sigma0[i] * sigma0[prime[j]];\r\n//\r\n//\t\t\t\t//e1[i*prime[j]]=prime[j]+1;\r\n//\t\t\t\t//sigma1[i*prime[j]]=sigma1[i]*sigma1[prime[j]];\r\n//\t\t\t\tmu[i * prime[j]] = mu[i] * mu[prime[j]];\r\n//\t\t\t}\r\n//\t\t}\r\n//\t}\r\n//}\r\n//void getInvArr() {\r\n//\tinvArr[1] = 1;\r\n//\trep(i, 2, N) {\r\n//\t\tinvArr[i] = invArr[mod % i] * (mod - mod / i) % mod;\r\n//\t}\r\n//}\r\n//void getFact() {\r\n//\tfact[0] = fact[1] = 1;\r\n//\tfor (ll i = 2; i <= N; i++) {\r\n//\t\tfact[i] = i * fact[i - 1] % mod;\r\n//\t}\r\n//}\r\n//void getInv() {\r\n//\tinv_fact[N] = inv(fact[N]);\r\n//\tfor (ll i = N - 1; i >= 0; i--) {\r\n//\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;\r\n//\t}\r\n//}\r\n//ll C(ll n, ll m) {\r\n//\tif (n < 0 || m < 0 || n < m) {\r\n//\t\treturn 0;\r\n//\t}\r\n//\tif (n == m && n == 0) {\r\n//\t\treturn 1;\r\n//\t}\r\n//\tll res = fact[n] * inv_fact[m] % mod * inv_fact[n - m] % mod;\r\n//\treturn res;\r\n//}\r\nstruct Node {\r\n\t\tint len, fa;\r\n\t\tint next[30];\r\n\t\tint cnt=0;\r\n\t\tNode(){\r\n\t\t\tmemset(next,-1,sizeof next);\r\n\t\t}\r\n};\r\nint cnt1[N*2];\r\nint cnt2[N*2];\r\nstruct Sam :public vector<Node>{\r\n\t#define sam (*this)\r\n\tSam(){\r\n\t\tresize(2*N);\r\n\t\ttot = last = 0;\r\n\t\tsam[0].len = 0;\r\n\t\tsam[0].fa = -1;\r\n\t\ttot++;\r\n\t}\r\n\tint last, tot;\r\n\r\n\tvoid add(int num,int *cnt) {\r\n\t\tint cur = tot++;\r\n\t\tint p = last;\r\n\t\tsam[cur].len = sam[last].len + 1;\r\n\t\tfor (; p != -1 && sam[p].next[num]==-1; p = sam[p].fa) {\r\n\t\t\tsam[p].next[num] = cur;\r\n\t\t}\r\n\t\tif (p == -1) {\r\n\t\t\tsam[cur].fa = 0;\r\n\t\t} else {\r\n\t\t\tint q = sam[p].next[num];\r\n\t\t\tif (sam[p].len + 1 == sam[q].len) sam[cur].fa = q;\r\n\t\t\telse {\r\n\t\t\t\tint clone = tot++;\r\n\t\t\t\t\r\n\t\t\t\tcnt1[clone]=cnt1[q];\r\n\t\t\t\tcnt2[clone]=cnt2[q];\r\n\t\t\t\tmemcpy(sam[clone].next,sam[q].next,sizeof sam[q].next);\r\n\t\t\t\tsam[clone].fa = sam[q].fa;\r\n\t\t\t\t\r\n\t\t\t\tsam[clone].len = sam[p].len + 1;\r\n\t\t\t\tsam[q].fa = sam[cur].fa = clone;\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfor (; p != -1 && sam[p].next[num] == q; p = sam[p].fa) {\r\n\t\t\t\t\tsam[p].next[num] = clone;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlast = cur;\r\n\t\tint tmp=last;\r\n\t\twhile(tmp!=-1&&cnt[tmp]<=1) cnt[tmp]++,tmp=sam[tmp].fa;\r\n//\t\tcnt[cur] = 1;\r\n\t}\r\n\t\r\n\tvoid getCnt(int *cnt) {\r\n\t\tfor(int i=tot-1;i>0;i--){\r\n\t\t\tint fa=sam[i].fa;\r\n\t\t\tcnt[fa]+=cnt[i];\r\n\t\t}\r\n\t}\r\n\t#undef sam\r\n}sam;\r\n\r\nll res = 1e9;\r\n\r\n\r\n\r\n\r\n\r\nsigned main() {\r\n//\trep(i,'a','z'+1) cout<<(char)(i)<<\": \"<<(int)(i-'a')<<endl;\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(nullptr);\r\n\tstring s;\r\n\tstring t;\r\n\tcin >> s >> t;\r\n\t\r\n\tite(c, s) {\r\n\t\tsam.add(c - 'a',cnt1);\r\n\t}\r\n\tsam.last=0;\r\n\tite(c, t) sam.add(c - 'a',cnt2);\r\n//\tsam.getCnt(cnt1);\r\n//\tsam.getCnt(cnt2);\r\n\trep(i,1,sam.tot){\r\n\t\tif(cnt1[i]==cnt2[i]&&cnt1[i]==1)\r\n\t\t\tres=min(res,sam[sam[i].fa].len+1);\r\n\t}\r\n\tif(res==1e9) cout<<\"-1\\n\";\r\n\telse cout << res << endl;\r\n\t\r\n\treturn 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}