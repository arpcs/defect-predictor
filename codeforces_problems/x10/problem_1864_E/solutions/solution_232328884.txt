{
    "id": 232328884,
    "contestId": 1864,
    "creationTimeSeconds": 1699683671,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1864,
        "index": "E",
        "name": "Guess Game",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2100,
        "tags": [
            "bitmasks",
            "data structures",
            "games",
            "math",
            "probabilities",
            "sortings",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 1864,
        "members": [
            {
                "handle": "Scythe"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1693060500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 18,
    "timeConsumedMillis": 561,
    "memoryConsumedBytes": 186675200,
    "source": "#include <bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\n\r\n#define int               long long\r\n#define ld                long double\r\n#define get(T,args...)    T args; read(args);\r\n#define init(a,T,n,s)     vector<T> a((n)+1,s); cin>>a;\r\n#define putn(args...)     { put(args); cout<<\"\\n\"; }\r\n#define pute(args...)     { put(args); cout<<endl; }\r\n#define putr(args...)     { putn(args) return ;}\r\n#define rep(i,a,b)        for(int i=(a); i<(b); i++)\r\n#define repr(i,a,b)       for(int i=(a); i>(b); i--)\r\n#define logarr(arr,f,l)   { auto start=arr.begin(), end=arr.begin(); advance(start,(f)); advance(end,(l)); for(auto it=start; it!=end; it++) cout<<*it<<\" \"; cout<<\"\\n\"; }\r\n#define all(x)            x.begin(), x.end()\r\n#define rall(x)           x.rbegin(), x.rend()\r\n#define sort_by(span,p)   sort(span, [&](const auto &l, const auto &r) { return p; })\r\n#define f(u, args...)     [&](auto &&u) { return args; }\r\n#define g(u, v, args...)  [&](auto &&u, auto &&v) { return args; }\r\n#define uniq(x)           x.erase(unique(all(x)),x.end());\r\n#define sz(x)             (int)(x).size()\r\n#define mid(l,r)          std::midpoint((l),(r))\r\n#define zov(v,z,c)        ((c) ? (v) : (z))\r\n#define pii               pair<int,int>\r\n#define pb                emplace_back\r\n#define pf                push_front\r\n#define fr                first\r\n#define sc                second\r\n#define sumv(v,b,e)       accumulate((v).begin()+b,(v).begin()+e,0LL)\r\n#define minv(v,b,e)       min_element((v).begin()+b,(v).begin()+e)\r\n#define maxv(v,b,e)       max_element((v).begin()+b,(v).begin()+e)\r\n#define precise(n)        cout<<fixed<<setprecision((n))\r\n#define bpc(n)            std::popcount((unsigned long long)(n))\r\n#define hsb(n)            std::has_single_bit((unsigned long long)(n))\r\n#define MSB(n)            std::bit_floor((unsigned long long)(n))\r\n#define ctz(n)            ((n) ? __builtin_ctzll((unsigned long long)(n)) : 0)\r\n#define clz(n)            ((n) ? __builtin_clzll((unsigned long long)(n)) : 64)\r\n#define LSB(n)            ((n)&(-(n)))\r\n#define vec(args...)      std::vector<args>\r\n#define set(args...)      std::set<args,Comp<args> >\r\n#define pqueue(args...)   std::priority_queue<args,vector<args>,Comp<args> > \r\n#define oset(args...)     tree<args, null_type, less<args>, rb_tree_tag, tree_order_statistics_node_update>\r\n\r\nconstexpr int N = 100'001, M = 998'244'353, mod = 1'000'000'007, MX = INT64_MAX, MN = INT64_MIN, oo = 4e18;\r\n\r\n#ifdef DEBUG\r\n#include \"./Debug/debug.hpp\"\r\n#else\r\n#define debug(args...) 0;\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#endif\r\n\r\n// using namespace __gnu_pbds;\r\nusing namespace std;\r\n\r\nvec(string) tokenizer(string str,char ch) {std::istringstream var((str)); vec(string) v; string t; while(getline((var), t, (ch))) {v.pb(t);} return v;}\r\n\r\ntemplate<typename T> struct Comp { bool operator()(const T& l, const T& r) const { return l < r; } };\r\ntemplate<typename T1, typename T2> inline istream& operator >> (istream& in, pair<T1,T2>& a) { in>>a.first>>a.second; return in; }\r\ntemplate<typename T1, typename T2> inline ostream& operator << (ostream& out, pair<T1,T2> a) { out<<a.first<<\" \"<<a.second; return out; }\r\ntemplate<typename T> istream& operator >> (istream& in, vector<T>& v) { rep(i,1,sz(v)) cin>>v[i]; return in; }\r\ntemplate<typename T,typename T1> inline bool amax(T &a,T1 b){ if(b>a) { a=b; return true; } return false; }\r\ntemplate<typename T,typename T1> inline bool amin(T &a,T1 b){ if(b<a) { a=b; return true; } return false; }\r\n\r\nvoid read(auto&... args) { ((cin>>args), ...); }\r\nvoid put(auto&&... args) { ((cout<<args<<\" \"), ...);}\r\n\r\nvoid file_i_o()\r\n{\r\n    freopen(\"./tests/test01.txt\", \"r\", stdin);\r\n    freopen(\"./tests/output01.txt\", \"w\", stdout);\r\n}\r\n\r\ntemplate<uint32_t kMod>\r\nclass Modular {\r\npublic:\r\n    using internal_value_type = int;\r\n    static_assert(int32_t(kMod) >= 1, \"MOD is less than 1\");\r\n    static Modular raw (uint32_t v) { return *reinterpret_cast<Modular*>(&v); }\r\n    constexpr Modular (int64_t v) : val((v %= kMod) < 0 ? v + kMod : v) {}\r\n    constexpr Modular () : val(0) {}\r\n    template<class T> constexpr explicit operator T() const { return val; }\r\n    constexpr int getval () const { return val; };\r\n    constexpr Modular& operator++ () { return val = ++val == kMod ? 0 : val, *this; }\r\n    constexpr Modular& operator-- () { return --(val ? val : val = kMod), *this; }\r\n    constexpr Modular operator+ () const { return *this; }\r\n    constexpr Modular operator- () const { return raw(val ? kMod - val : 0); }\r\n    constexpr Modular& operator+= (const Modular o) { return val = int32_t(val += o.val - kMod) < 0 ? val + kMod : val, *this; }\r\n    constexpr Modular& operator-= (const Modular o) { return val = int32_t(val -= o.val) < 0 ? val + kMod : val, *this; }    \r\n    constexpr Modular& operator*= (const Modular &o) { return val = (static_cast<uint64_t>(val) * o.val) % kMod, *this; }\r\n    constexpr Modular& operator/= (const Modular &o) { return *this *= o.inv(); }\r\n    constexpr friend Modular operator+ (Modular a, Modular b) { return a += b; }\r\n    constexpr friend Modular operator- (Modular a, Modular b) { return a -= b; }\r\n    constexpr friend Modular operator* (Modular a, Modular b) { return a *= b; }\r\n    constexpr friend Modular operator/ (Modular a, Modular b) { return a /= b; }\r\n    constexpr friend Modular operator++ (Modular& a, int32_t) { return std::exchange(a, ++Modular(a)); }\r\n    constexpr friend Modular operator-- (Modular& a, int32_t) { return std::exchange(a, --Modular(a)); }\r\n    constexpr friend bool operator== (Modular a, Modular b) { return a.val == b.val; }\r\n    constexpr friend bool operator!= (Modular a, Modular b) { return a.val != b.val; }\r\n    constexpr Modular inv () const { return extgcd(val, kMod); }\r\n    constexpr Modular pow (uint64_t p) const {\r\n        assert(p >= 0);\r\n        Modular a = *this, res = 1;\r\n        while (p > 0) {\r\n            if (p & 1) res *= a;\r\n            a *= a, p >>= 1;\r\n        }\r\n        return res;\r\n    }\r\n    constexpr friend std::istream& operator>>(std::istream& is, Modular& x) { int64_t v; return is >> v, x = v, is; }\r\n    constexpr friend std::ostream& operator<<(std::ostream& os, Modular x) { return os << x.val; }\r\nprivate:\r\n    int val;\r\n    constexpr static int extgcd (int a, int b) {\r\n        std::array x{1, 0};\r\n        int _x0 {}, _x1{}, _a{}, _b{};\r\n        while (b)\r\n            _x1 = x[0] - a / b * x[1], _x0 = x[1],\r\n            _a = b, _b = a % b,\r\n            a = _a, b = _b, x[0] = _x0, x[1] = _x1;\r\n        return x[0];\r\n    }\r\n};\r\nusing imt = Modular<M>;\r\n\r\nclass Trie{\r\n    array<Trie*,2> child{nullptr,nullptr};\r\n    int count;\r\n \r\n    public:\r\n        Trie()\r\n            :count{0}\r\n        {}\r\n \r\n        void insert(int val)\r\n        {\r\n            Trie* ptr = this;\r\n            for(int bit=29; bit>=0; bit--)\r\n            {\r\n                int c = 0;\r\n                if((val>>bit)&1) c = 1;\r\n                if(!ptr->child[c]) ptr->child[c] = new Trie();\r\n                ptr->child[c]->count++;\r\n                ptr = ptr->child[c];\r\n            }\r\n        }\r\n\r\n        int query(int pattern)\r\n        {\r\n            int ans = 0;\r\n            auto ptr = this;\r\n            for(int bit=29, cur=0; bit>=0 and ptr; bit--){\r\n                if((pattern>>bit)&1){\r\n                    if(ptr->child[0]) ans += (cur+1+((cur&1)^1))*(ptr->child[0]->count);\r\n                    cur++;\r\n                } else {\r\n                    if(ptr->child[1]) ans += (cur+1+(cur&1))*(ptr->child[1]->count);\r\n                }\r\n                ptr = ptr->child[(pattern>>bit)&1];\r\n            }\r\n            return ans;\r\n        }\r\n};\r\n\r\n\r\n// If you win, you live. You cannot win unless you fight.\r\nvoid TATAKAE(int T)\r\n{\r\n    get(int,n)\r\n    Trie* root = new Trie();\r\n    vector<int> a(n);\r\n    map<int,int> cnt;\r\n    for(int i=0; i<n; i++){\r\n        cin>>a[i];\r\n        cnt[a[i]]++;\r\n        root->insert(a[i]);\r\n    }\r\n    imt ans = 0;\r\n    for(int i=0; i<n; i++){\r\n        ans += root->query(a[i]);\r\n        ans += (cnt[a[i]])*(bpc(a[i])+1);\r\n    } \r\n    ans *= imt(n*n).inv();\r\n    cout<<ans<<\"\\n\";\r\n}\r\n\r\nsigned main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    //file_i_o();\r\n\r\n    int t=1;\r\n    cin>>t;\r\n    rep(i,1,t+1)\r\n    {\r\n        //cout<<\"Case #\"<<i<<\": \";\r\n        TATAKAE(i);\r\n    }\r\n\r\n    #ifndef ONLINE_JUDGE\r\n    cerr<<\"\\ntime taken : \"<<(float)clock()/CLOCKS_PER_SEC<<\" secs\"<<\"\\n\";\r\n    #endif\r\n    return 0;\r\n}"
}