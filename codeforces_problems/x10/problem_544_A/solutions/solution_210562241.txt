{
    "id": 210562241,
    "contestId": 544,
    "creationTimeSeconds": 1687360211,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 544,
        "index": "A",
        "name": "Set of Strings",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1100,
        "tags": [
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 544,
        "members": [
            {
                "handle": "sajidrec"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1431016200
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 33,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 102400,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint binpowModular(int base, int power, int Mod)\r\n{\r\n    //** Time complexity O(log(n)) **//\r\n\r\n    // if power is odd then res = res*base and power--\r\n    // if power if even then base = base*base and power = power/2\r\n    // if power is zero then res will be the answer\r\n\r\n    int res = 1;\r\n\r\n    while (power)\r\n    {\r\n        if (power % 2 == 0)\r\n        {\r\n            base = (base * base) % Mod;\r\n            power /= 2;\r\n        }\r\n        else\r\n        {\r\n            res = (res * base) % Mod;\r\n            power--;\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nint binpow(int base, int power)\r\n{\r\n    //** Time complexity O(log(n)) **//\r\n\r\n    // if power is odd then res = res*base and power--\r\n    // if power if even then base = base*base and power = power/2\r\n    // if power is zero then res will be the answer\r\n\r\n    int res = 1;\r\n\r\n    while (power)\r\n    {\r\n        if (power % 2 == 0)\r\n        {\r\n            base *= base;\r\n            power /= 2;\r\n        }\r\n        else\r\n        {\r\n            res *= base;\r\n            power--;\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nbool isPrime(int num)\r\n{\r\n    // Time complexity O(sqrt(n))\r\n\r\n    if (num == 1 || (num % 2 == 0 && num != 2))\r\n    {\r\n        return false;\r\n    }\r\n    for (int i = 2; i * i <= num; i++)\r\n    {\r\n        if (num % i == 0)\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\ntemplate <class T>\r\nint binSearch(vector<T> &vec, int left, int right, T target)\r\n{\r\n    // to call binSearch<data type> (params);\r\n    // time complexity O(log(N))\r\n    if (left > right)\r\n    {\r\n        return -1;\r\n    }\r\n    int mid = (left + right) / 2;\r\n    if (vec[mid] == target)\r\n    {\r\n        return mid;\r\n    }\r\n    else if (vec[mid] > target)\r\n    {\r\n        return binSearch(vec, left, mid - 1, target);\r\n    }\r\n    else\r\n    {\r\n        return binSearch(vec, mid + 1, right, target);\r\n    }\r\n}\r\n\r\nvector<string> subsequenceGenerator(string &str)\r\n{\r\n    // time complexity O(2^n * n)\r\n    // including empty string there can be 2^n subsequences\r\n    vector<string> allSequences;\r\n    int n = str.size();\r\n    for (int i = 0; i < (2 << (n - 1)); i++)\r\n    {\r\n        string res = \"\";\r\n        int trace = 0, temp;\r\n        temp = i;\r\n        while (temp)\r\n        {\r\n            if (temp & 1)\r\n            {\r\n                res.push_back(str[trace]);\r\n            }\r\n            trace++;\r\n            temp >>= 1;\r\n        }\r\n        allSequences.push_back(res);\r\n    }\r\n\r\n    return allSequences;\r\n}\r\n\r\nclass Graph\r\n{\r\npublic:\r\n    int vertices = 0;\r\n    vector<int> *g;\r\n    vector<bool> visitedG;\r\n\r\n    Graph(int vertices)\r\n    {\r\n        this->vertices = vertices;\r\n        visitedG.assign(vertices, false);\r\n        g = new vector<int>[vertices + 1];\r\n        // new keyword used for creating space for the pointer\r\n    }\r\n\r\n    void addEdge(int vertex, int edge)\r\n    {\r\n        g[vertex].push_back(edge);\r\n        g[edge].push_back(vertex);\r\n    }\r\n\r\n    void display()\r\n    {\r\n        for (int i = 1; i <= vertices; i++)\r\n        {\r\n            cout << i << \" : \";\r\n            for (auto val : g[i])\r\n            {\r\n                cout << val << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n\r\n    void dfs(int vertex)\r\n    {\r\n        cout << vertex << \" \";\r\n        visitedG[vertex] = true;\r\n        for (auto v : g[vertex])\r\n        {\r\n            if (!visitedG[v])\r\n            {\r\n                dfs(v);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n// seive generate\r\n\r\n// const int seiveSize = 1000001;\r\n// bool seive[seiveSize]; // by default global array got false value\r\n// void seiveGenerate()\r\n// {\r\n//     seive[0] = true;\r\n//     seive[1] = true;\r\n//     for (int i = 2; i * i < seiveSize; i++)\r\n//     {\r\n//         if (seive[i])\r\n//         {\r\n//             continue;\r\n//         }\r\n//         for (int j = i * i; j < seiveSize; j += i)\r\n//         {\r\n//             seive[j] = true;\r\n//         }\r\n//     }\r\n// }\r\n\r\nclass BinTree\r\n{\r\npublic:\r\n    BinTree *left, *right;\r\n    int val;\r\n\r\n    BinTree()\r\n    {\r\n        left = nullptr;\r\n        right = nullptr;\r\n    }\r\n};\r\nvoid consTructBst(BinTree *root, BinTree *currentNode)\r\n{\r\n    if (currentNode->val <= root->val)\r\n    {\r\n        if (root->left)\r\n        {\r\n            consTructBst(root->left, currentNode);\r\n        }\r\n        else\r\n        {\r\n            root->left = currentNode;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (root->right)\r\n        {\r\n            consTructBst(root->right, currentNode);\r\n        }\r\n        else\r\n        {\r\n            root->right = currentNode;\r\n        }\r\n    }\r\n}\r\nvoid preOrder(BinTree *node)\r\n{\r\n    if (node)\r\n    {\r\n        cout << \" \" << node->val;\r\n        preOrder(node->left);\r\n        preOrder(node->right);\r\n    }\r\n}\r\nvoid inOrder(BinTree *node)\r\n{\r\n    if (node)\r\n    {\r\n        inOrder(node->left);\r\n        cout << \" \" << node->val;\r\n        inOrder(node->right);\r\n    }\r\n}\r\nvoid postOrder(BinTree *node)\r\n{\r\n    if (node)\r\n    {\r\n        postOrder(node->left);\r\n        postOrder(node->right);\r\n        cout << \" \" << node->val;\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n    // freopen(\"input.txt\", \"r\", stdin);\r\n    // freopen(\"output.txt\", \"w\", stdout);\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n\r\n    // seiveGenerate();\r\n\r\n    int diviSionNeeded;\r\n    string str;\r\n    cin >> diviSionNeeded >> str;\r\n\r\n    unordered_map<char, bool> mp;\r\n\r\n    queue<int> distinctCharIndexes;\r\n\r\n    for (int i = 0; i < str.size(); i++)\r\n    {\r\n        if (!mp[str[i]])\r\n        {\r\n            mp[str[i]] = true;\r\n            distinctCharIndexes.push(i);\r\n        }\r\n    }\r\n\r\n    if (diviSionNeeded > distinctCharIndexes.size())\r\n    {\r\n        cout << \"NO\" << endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \"YES\" << endl;\r\n\r\n        // while (!distinctCharIndexes.empty())\r\n        // {\r\n        //     cout << distinctCharIndexes.front() << endl;\r\n        //     distinctCharIndexes.pop();\r\n        // }\r\n\r\n        // int z = distinctCharIndexes.size();\r\n        // int diff = abs((z + 1) - diviSionNeeded);\r\n        diviSionNeeded--;\r\n\r\n        while (diviSionNeeded != distinctCharIndexes.size())\r\n        {\r\n            distinctCharIndexes.pop();\r\n        }\r\n\r\n        // while (diff--)\r\n        // {\r\n        //     distinctCharIndexes.pop();\r\n        // }\r\n\r\n        for (int i = 0; i < str.size(); i++)\r\n        {\r\n            if (distinctCharIndexes.size())\r\n            {\r\n                if (distinctCharIndexes.front() == i)\r\n                {\r\n                    cout << endl;\r\n                    cout << str[i];\r\n                    distinctCharIndexes.pop();\r\n                }\r\n                else\r\n                {\r\n                    cout << str[i];\r\n                }\r\n            }\r\n            else\r\n            {\r\n                cout << str[i];\r\n            }\r\n            if (i + 1 == str.size())\r\n            {\r\n                cout << endl;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
}