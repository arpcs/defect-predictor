{
    "id": 116210314,
    "contestId": 773,
    "creationTimeSeconds": 1621022138,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 773,
        "index": "A",
        "name": "Success Rate",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1700,
        "tags": [
            "binary search",
            "math"
        ]
    },
    "author": {
        "contestId": 773,
        "members": [
            {
                "handle": "naitikvarshney"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1494171900
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 56,
    "timeConsumedMillis": 171,
    "memoryConsumedBytes": 0,
    "source": "/*\r\n *     HI THERE!\r\n * \r\n * CREATED BY : NAITIK V\r\n * \r\n *     JAI HIND\r\n * \r\n */\r\n\r\nimport java.util.*;\r\n\r\n\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\npublic class Main\r\n\r\n{ \r\n\t static FastReader sc=new FastReader(); \r\n\t static long dp[][][];\r\n\t static int mod=1000000007;\r\n\t static int max;\r\n\t  public static void main(String[] args)\r\n{\r\n\t\t   PrintWriter out=new PrintWriter(System.out);\r\n\t\t   StringBuffer sb=new StringBuffer(\"\");\r\n\t\t  int ttt=1;\r\n\t\t   ttt =i();\r\n\t\t \r\n\t        outer :while (ttt-- > 0) \r\n\t\t\t{\r\n\t        \tlong x=i(),y=i();\r\n\t        \tlong p=i(),q=i();\r\n\t        \tlong gcd=gcd(x, y);\r\n\t        \tlong a=x/gcd;\r\n\t        \tlong b=y/gcd;\r\n\t        \tif(a==p && q==b) {\r\n\t        \t\tSystem.out.println(\"0\");\r\n\t        \t\tcontinue;\r\n\t        \t}\r\n\t        \tlong l=1;\r\n\t        \tlong u=(long)1e10;\r\n\t        \tlong ans=-1;\r\n\t        \twhile(l<=u) {\r\n\t        \t\tlong mid=(l+u)/2;\r\n\t        \t\tlong n=p*mid;\r\n\t        \t\tlong m=q*mid;\r\n\t        \t\tif(m>y) {\r\n\t        \t\t\tlong d=m-y;\r\n\t        \t\t\tlong nr=x+d;\r\n\t        \t\t\tif(nr>=n && x<=n) {\r\n\t        \t\t\tans=m-y;\r\n\t        \t\t\tu=mid-1;\r\n\t        \t\t\t}\r\n\t        \t\t\telse {\r\n\t        \t\t\t\tl=mid+1;\r\n\t        \t\t\t}\r\n\t        \t\t}\r\n\t        \t\telse {\r\n\t        \t\t\tl=mid+1;\r\n\t        \t\t}\r\n\t        \t}\r\n\t        \tSystem.out.println(ans);\r\n\t        \t\r\n\t        \t\r\n\t        \t\r\n\t        \t\r\n\t        \t\r\n\t\t        \t\r\n\t\t        \t\r\n\t        \t\r\n\t\t\t}\r\n\r\n\t     //System.out.println(sb.toString());\r\n\t\t     out.close();\r\n\t     \r\n\t     \r\n\t    //CHECK FOR N=1                    //CHECK FOR M=0\r\n        //CHECK FOR N=1                    //CHECK FOR M=0\r\n       \t//CHECK FOR N=1\r\n       \t//CHECK FOR N=1\r\n       \t//CHECK FOR N=1\r\n\t\t        \r\n\t\t     \r\n    }\r\n\t  \r\n\t  static BigInteger go(BigInteger a,BigInteger b,BigInteger c,BigInteger d) {\r\n\t\t  BigInteger p1=(a.multiply(d)).add(b.multiply(c));\r\n\t\t  return p1;\r\n\t  }\r\n\t  static BigInteger go1(BigInteger a,BigInteger b,BigInteger c,BigInteger d) {\r\n\t\t  BigInteger p1=b.multiply(d);\r\n\t\t  return p1;\r\n\t  }\r\n\t  \r\n\t  \r\n\t \r\nstatic class Pair implements Comparable<Pair>\r\n     {\r\n    \t int x;\r\n    \t int y;\r\n    \t Pair(int x,int y){\r\n    \t\t this.x=x;\r\n    \t\t this.y=y;\r\n    \t }\r\n\t\t@Override\r\n\t\tpublic int compareTo(Pair o) {\r\n\t\t\tif(this.x>o.x)\r\n\t\t\t\treturn 1;\r\n\t\t\telse if(this.x<o.x)\r\n\t\t\t\treturn -1;\r\n\t\t\telse {\r\n\t\t\t\tif(this.y>o.y)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\telse if(this.y<o.y)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\telse\r\n\t\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t/* FOR TREE MAP PAIR USE */\r\n\t\t\r\n//\t\tpublic int compareTo(Pair o) {\r\n// \t\t\tif (x > o.x) {\r\n// \t\t\t\treturn 1;\r\n// \t\t\t}\r\n// \t\t\tif (x < o.x) {\r\n// \t\t\t\treturn -1;\r\n// \t\t\t}\r\n// \t\t\tif (y > o.y) {\r\n// \t\t\t\treturn 1;\r\n// \t\t\t}\r\n// \t\t\tif (y < o.y) {\r\n// \t\t\t\treturn -1;\r\n// \t\t\t}\r\n// \t\t\treturn 0;\r\n// \t\t}\r\n\t\r\n\t\t\r\n     }\r\n\r\nstatic int[] input(int n) {\r\n\tint A[]=new int[n];\r\n\t   for(int i=0;i<n;i++) {\r\n\t\t   A[i]=sc.nextInt();\r\n\t   }\r\n\t   return A;\r\n   }\r\nstatic long[] inputL(int n) {\r\n\tlong A[]=new long[n];\r\n\t   for(int i=0;i<n;i++) {\r\n\t\t   A[i]=sc.nextLong();\r\n\t   }\r\n\t   return A;\r\n   }\r\nstatic String[] inputS(int n) {\r\n\tString A[]=new String[n];\r\n\t   for(int i=0;i<n;i++) {\r\n\t\t   A[i]=sc.next();\r\n\t   }\r\n\t   return A;\r\n   }\r\nstatic long sum(int A[]) {\r\n\tlong sum=0;\r\n\tfor(int i : A) {\r\n\t\tsum+=i;\r\n\t}\r\n\treturn sum;\r\n}\r\nstatic long sum(long A[]) {\r\n\tlong sum=0;\r\n\tfor(long i : A) {\r\n\t\tsum+=i;\r\n\t}\r\n\treturn sum;\r\n}\r\nstatic void reverse(long A[]) {\r\n\tint n=A.length;\r\n\tlong B[]=new long[n];\r\n\tfor(int i=0;i<n;i++) {\r\n\t\tB[i]=A[n-i-1];\r\n\t}\r\n\tfor(int i=0;i<n;i++)\r\n\t\tA[i]=B[i];\r\n\t\r\n}\r\nstatic void reverse(int A[]) {\r\n\tint n=A.length;\r\n\tint B[]=new int[n];\r\n\tfor(int i=0;i<n;i++) {\r\n\t\tB[i]=A[n-i-1];\r\n\t}\r\n\tfor(int i=0;i<n;i++)\r\n\t\tA[i]=B[i];\r\n\t\r\n}\r\nstatic void input(int A[],int B[]) {\r\n\t   for(int i=0;i<A.length;i++) {\r\n\t\t   A[i]=sc.nextInt();\r\n\t\t   B[i]=sc.nextInt();\r\n\t   }\r\n}\r\nstatic int[][] input(int n,int m){\r\n\tint A[][]=new int[n][m];\r\n\tfor(int i=0;i<n;i++) {\r\n\t\tfor(int j=0;j<m;j++) {\r\n\t\t\tA[i][j]=i();\r\n\t\t}\r\n\t}\r\n\treturn A;\r\n}\r\nstatic char[][] charinput(int n,int m){\r\n\tchar A[][]=new char[n][m];\r\n\tfor(int i=0;i<n;i++) {\r\n\t\tString s=s();\r\n\t\tfor(int j=0;j<m;j++) {\r\n\t\t\tA[i][j]=s.charAt(j);\r\n\t\t}\r\n\t}\r\n\treturn A;\r\n}\r\nstatic int max(int A[]) {\r\n\tint max=Integer.MIN_VALUE;\r\n\tfor(int i=0;i<A.length;i++) {\r\n\t\tmax=Math.max(max, A[i]);\r\n\t}\r\n\treturn max;\r\n}\r\nstatic int min(int A[]) {\r\n\tint min=Integer.MAX_VALUE;\r\n\tfor(int i=0;i<A.length;i++) {\r\n\t\tmin=Math.min(min, A[i]);\r\n\t}\r\n\treturn min;\r\n}\r\nstatic long max(long A[]) {\r\n\tlong max=Long.MIN_VALUE;\r\n\tfor(int i=0;i<A.length;i++) {\r\n\t\tmax=Math.max(max, A[i]);\r\n\t}\r\n\treturn max;\r\n}\r\nstatic long min(long A[]) {\r\n\tlong min=Long.MAX_VALUE;\r\n\tfor(int i=0;i<A.length;i++) {\r\n\t\tmin=Math.min(min, A[i]);\r\n\t}\r\n\treturn min;\r\n}\r\nstatic long [] prefix(long A[]) {\r\n\tlong p[]=new long[A.length];\r\n\tp[0]=A[0];\r\n\tfor(int i=1;i<A.length;i++)\r\n\t\tp[i]=p[i-1]+A[i];\r\n\treturn p;\r\n}\r\nstatic long [] prefix(int A[]) {\r\n\tlong p[]=new long[A.length];\r\n\tp[0]=A[0];\r\n\tfor(int i=1;i<A.length;i++)\r\n\t\tp[i]=p[i-1]+A[i];\r\n\treturn p;\r\n}\r\nstatic long [] suffix(long A[]) {\r\n\tlong p[]=new long[A.length];\r\n\tp[A.length-1]=A[A.length-1];\r\n\tfor(int i=A.length-2;i>=0;i--)\r\n\t\tp[i]=p[i+1]+A[i];\r\n\treturn p;\r\n}\r\nstatic long [] suffix(int A[]) {\r\n\tlong p[]=new long[A.length];\r\n\tp[A.length-1]=A[A.length-1];\r\n\tfor(int i=A.length-2;i>=0;i--)\r\n\t\tp[i]=p[i+1]+A[i];\r\n\treturn p;\r\n}\r\nstatic long power(long x, long y, long p)\r\n{\r\n\r\n\tif(y==0)\r\n\t\treturn 1;\r\n\tif(x==0)\r\n\t\treturn 0;\r\n    long res = 1;\r\n    x = x % p;\r\n\r\n    while (y > 0) {\r\n\r\n        if (y % 2 == 1)\r\n            res = (res * x) % p;\r\n\r\n        y = y >> 1; \r\n        x = (x * x) % p;\r\n    }\r\n\r\n    return res;\r\n}\r\nstatic void print(int A[]) {\r\n\tfor(int i : A) {\r\n\t\tSystem.out.print(i+\" \");\r\n\t}\r\n\tSystem.out.println();\r\n}\r\nstatic void print(long A[]) {\r\n\tfor(long i : A) {\r\n\t\tSystem.out.print(i+\" \");\r\n\t}\r\n\tSystem.out.println();\r\n}\r\nstatic long mod(long x) {\r\n\t  return ((x%mod + mod)%mod);\r\n}\r\nstatic String reverse(String s) {\r\n\tStringBuffer p=new StringBuffer(s);\r\n\tp.reverse();\r\n\treturn p.toString();\r\n}\r\n\r\n     static int i() {\r\n    \t return sc.nextInt();\r\n     }\r\n     static String s() {\r\n    \t return sc.next();\r\n     }\r\n     static long l() {\r\n    \t return sc.nextLong();\r\n     }  \r\n     static void sort(int[] A){\r\n        int n = A.length;\r\n        Random rnd = new Random();\r\n        for(int i=0; i<n; ++i){\r\n            int tmp = A[i];\r\n            int randomPos = i + rnd.nextInt(n-i);\r\n            A[i] = A[randomPos];\r\n            A[randomPos] = tmp;\r\n        }\r\n        Arrays.sort(A);\r\n     }\r\n     static void sort(long[] A){\r\n\t        int n = A.length;\r\n\t        Random rnd = new Random();\r\n\t        for(int i=0; i<n; ++i){\r\n\t            long tmp = A[i];\r\n\t            int randomPos = i + rnd.nextInt(n-i);\r\n\t            A[i] = A[randomPos];\r\n\t            A[randomPos] = tmp;\r\n\t        }\r\n\t        Arrays.sort(A);\r\n\t     }\r\n  static String sort(String s) {\r\n \t Character ch[]=new Character[s.length()];\r\n \t for(int i=0;i<s.length();i++) {\r\n \t\t ch[i]=s.charAt(i);\r\n \t }\r\n \t Arrays.sort(ch);\r\n \t StringBuffer st=new StringBuffer(\"\");\r\n \t for(int i=0;i<s.length();i++) {\r\n \t\t st.append(ch[i]);\r\n \t }\r\n \t return st.toString();\r\n  }\r\n  static HashMap<Integer,Integer> hash(int A[]){\r\n\t  HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\r\n\t  for(int i : A) {\r\n\t\t  if(map.containsKey(i)) {\r\n\t\t\t  map.put(i, map.get(i)+1);\r\n\t\t  }\r\n\t\t  else {\r\n\t\t\t  map.put(i, 1);\r\n\t\t  }\r\n\t  }\r\n\t  return map;\r\n  }\r\n  static TreeMap<Integer,Integer> tree(int A[]){\r\n\t  TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\r\n\t  for(int i : A) {\r\n\t\t  if(map.containsKey(i)) {\r\n\t\t\t  map.put(i, map.get(i)+1);\r\n\t\t  }\r\n\t\t  else {\r\n\t\t\t  map.put(i, 1);\r\n\t\t  }\r\n\t  }\r\n\t  return map;\r\n  }\r\n     static boolean prime(int n) \r\n\t    { \r\n\t        if (n <= 1) \r\n\t            return false; \r\n\t        if (n <= 3) \r\n\t            return true; \r\n\t        if (n % 2 == 0 || n % 3 == 0) \r\n\t            return false; \r\n\t        double sq=Math.sqrt(n);\r\n\t  \r\n\t        for (int i = 5; i <= sq; i = i + 6) \r\n\t            if (n % i == 0 || n % (i + 2) == 0) \r\n\t                return false; \r\n\t        return true; \r\n\t    } \r\n     static boolean prime(long n) \r\n\t    { \r\n\t        if (n <= 1) \r\n\t            return false; \r\n\t        if (n <= 3) \r\n\t            return true; \r\n\t        if (n % 2 == 0 || n % 3 == 0) \r\n\t            return false; \r\n\t        double sq=Math.sqrt(n);\r\n\t  \r\n\t        for (int i = 5; i <= sq; i = i + 6) \r\n\t            if (n % i == 0 || n % (i + 2) == 0) \r\n\t                return false; \r\n\t        return true; \r\n\t    } \r\n     static int gcd(int a, int b) \r\n     { \r\n         if (a == 0) \r\n             return b; \r\n         return gcd(b % a, a); \r\n     } \r\n     static long gcd(long a, long b) \r\n     { \r\n         if (a == 0) \r\n             return b; \r\n         return gcd(b % a, a); \r\n     } \r\n     \r\n        \r\n    static class FastReader \r\n    { \r\n        BufferedReader br; \r\n        StringTokenizer st; \r\n  \r\n        public FastReader() \r\n        { \r\n            br = new BufferedReader(new\r\n                     InputStreamReader(System.in)); \r\n        } \r\n  \r\n        String next() \r\n        { \r\n            while (st == null || !st.hasMoreElements()) \r\n            { \r\n                try\r\n                { \r\n                    st = new StringTokenizer(br.readLine()); \r\n                } \r\n                catch (IOException  e) \r\n                { \r\n                    e.printStackTrace(); \r\n                } \r\n            } \r\n            return st.nextToken(); \r\n        } \r\n  \r\n        int nextInt() \r\n        { \r\n            return Integer.parseInt(next()); \r\n        } \r\n  \r\n        long nextLong() \r\n        { \r\n            return Long.parseLong(next()); \r\n        } \r\n  \r\n        double nextDouble() \r\n        { \r\n            return Double.parseDouble(next()); \r\n        } \r\n  \r\n        String nextLine() \r\n        { \r\n            String str = \"\"; \r\n            try\r\n            { \r\n                str = br.readLine(); \r\n            } \r\n            catch (IOException e) \r\n            { \r\n                e.printStackTrace(); \r\n            } \r\n            return str; \r\n        } \r\n    } \r\n} \r\n\r\n\r\n\r\n"
}