{
    "id": 232494068,
    "contestId": 1867,
    "creationTimeSeconds": 1699787262,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1867,
        "index": "F",
        "name": "Most Different Tree",
        "type": "PROGRAMMING",
        "points": 4000.0,
        "rating": 2700,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "greedy",
            "hashing"
        ]
    },
    "author": {
        "contestId": 1867,
        "members": [
            {
                "handle": "Venia"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1694442900
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 53,
    "timeConsumedMillis": 842,
    "memoryConsumedBytes": 419225600,
    "source": "use std::collections::hash_map::DefaultHasher;\r\nuse std::collections::HashMap;\r\nuse std::hash::{Hash, Hasher};\r\n\r\nuse std::io::{BufWriter, StdoutLock};\r\nuse std::io::Write;\r\n\r\nmod scanner {\r\n    use std::str::FromStr;\r\n    use std::str::SplitAsciiWhitespace;\r\n    use std::io::Read;\r\n    pub struct Scanner<'a> {\r\n        it: SplitAsciiWhitespace<'a>\r\n    }\r\n    impl<'a> Scanner<'a> {\r\n        pub fn new(s: &'a str) -> Scanner<'a> {\r\n            Scanner {\r\n                it: s.split_ascii_whitespace()\r\n            }\r\n        }\r\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\r\n            std::iter::repeat_with(|| self.next()).take(n).collect()\r\n        }\r\n        pub fn next<T: FromStr>(&mut self) -> T {\r\n            self.it.next().unwrap().parse().ok().unwrap()\r\n        }\r\n    }\r\n \r\n    // Content of whole file\r\n    pub fn read_string() -> String {\r\n        let mut s = String::new();\r\n        std::io::stdin().read_to_string(&mut s).unwrap();\r\n        s\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct Tree {\r\n    kids: Vec<Box<Tree>>,\r\n}\r\n\r\nimpl Tree {\r\n    fn clone_tree(&self) -> Tree {\r\n        Tree {\r\n            kids: self.kids.iter().map(|child|\r\n                                       Box::new(child.clone_tree())).collect(),\r\n        }\r\n    }\r\n\r\n    fn hash_kids(&self) -> Vec<u64> {\r\n        let mut hashes: Vec<u64> = self.kids.iter()\r\n            .map(|kid| {\r\n                let mut hsh = DefaultHasher::new();\r\n                kid.hash(&mut hsh);\r\n                hsh.finish()\r\n            })\r\n            .collect();\r\n        hashes.sort_unstable();\r\n        hashes\r\n    }\r\n}\r\n\r\nimpl Hash for Tree {\r\n    fn hash<H: Hasher>(&self, state: &mut H) {\r\n        self.hash_kids().hash(state);\r\n    }\r\n}\r\n\r\nstruct Coder {\r\n    map: HashMap<Vec<usize>, usize>,\r\n    inv_map: Vec<Vec<usize>>,\r\n\r\n    // HashMap<Vec<usize>, usize>,\r\n}\r\nimpl Coder {\r\n    fn new() -> Self {\r\n        Self {\r\n            map: HashMap::new(),\r\n            inv_map: Vec::new()\r\n        }\r\n    }\r\n    fn code(&mut self, key: &[usize]) -> usize {\r\n        let mut s_key = key.to_vec();\r\n        s_key.sort_unstable(); // or just `sort()`, if you need stable sorting\r\n        match self.map.get(&s_key) {\r\n            Some(&value) => value,\r\n            None => {\r\n                let len = self.map.len();\r\n                self.map.insert(s_key.to_vec(), len);\r\n                self.inv_map.push(s_key.to_vec());\r\n                len\r\n            }\r\n        }\r\n    }\r\n    fn get_kids(&self, t: usize) -> Vec<usize> {\r\n        self.inv_map[t].clone()\r\n    }\r\n}\r\n\r\nfn code_all(adj: &[Vec<usize>], coder: &mut Coder) {\r\n    let mut vis = vec![false; adj.len()];\r\n    fn code_subtree(node: usize, adj: &[Vec<usize>], vis: &mut Vec<bool>, coder: &mut Coder) -> usize {\r\n        vis[node] = true;\r\n        let kids: Vec<usize> = adj[node].iter().filter(\r\n            |&&n| !vis[n]).cloned().collect();\r\n        let codes: Vec<usize> = kids.iter().map(\r\n            |&k| code_subtree(k, adj, vis, coder)).collect();\r\n        coder.code(&codes)\r\n    }\r\n    code_subtree(0, adj, &mut vis, coder);\r\n}\r\n\r\n\r\n\r\nfn partitions(n: i32, max: i32, prefix: &mut Vec<i32>,\r\n              trees: &mut Vec<usize>, coder: &mut Coder) {\r\n    if n == 0 {\r\n        let mut a_combs = Vec::new();\r\n        combine_trees(prefix, 0, &mut Vec::new(), &mut a_combs, coder);\r\n\r\n        for comb in a_combs {\r\n            trees.push(coder.code(comb.as_slice()));\r\n        }\r\n        return;\r\n    }\r\n\r\n    for i in (1..=n).rev() {\r\n        if i > max {\r\n            continue;\r\n        }\r\n        prefix.push(i);\r\n        partitions(n - i, i, prefix, trees, coder);\r\n        prefix.pop();\r\n    }\r\n}\r\n\r\nfn combine_trees(parts: &[i32],\r\n                 idx: usize,\r\n                 c_comb: &mut Vec<usize>,\r\n                 a_combs: &mut Vec<Vec<usize>>,\r\n                 coder: &mut Coder) {\r\n    if idx == parts.len() {\r\n        // Clone each Tree in c_comb and then collect into a new Vec\r\n        let comb_cl = c_comb.clone(); \r\n        a_combs.push(comb_cl);\r\n        return;\r\n    }\r\n\r\n    for tree in build_trees(parts[idx], coder) {\r\n        c_comb.push(tree);\r\n        combine_trees(parts, idx + 1, c_comb, a_combs, coder);\r\n        c_comb.pop();\r\n    }\r\n}\r\n\r\nfn build_trees(n: i32, coder: & mut Coder) -> Vec<usize> {\r\n    if n == 0 {\r\n        return vec![0_usize];\r\n    }\r\n\r\n    let mut trees: Vec<usize>  = Vec::new();\r\n    //let mut coder = Coder::new();\r\n    partitions(n - 1, n - 1, &mut Vec::new(), &mut trees, coder);\r\n\r\n    trees\r\n}\r\n\r\nfn decode2adj(out: &mut BufWriter<StdoutLock>,\r\n              tree: usize, root: usize, coder: & Coder ) -> usize {\r\n    let kids: Vec<usize> = coder.get_kids(tree);\r\n    let mut last_used = root;\r\n    for k in kids {\r\n        writeln!(out, \"{} {}\", root, last_used+1);\r\n        last_used = decode2adj(out, k, last_used+1, &coder);        \r\n    }\r\n    last_used\r\n}\r\n\r\nfn print_sol(out: &mut BufWriter<StdoutLock>,\r\n             tree: usize, coder: & Coder,\r\n             extra: usize) {\r\n    for i in 1..=extra {\r\n        writeln!(out, \"{} {}\", i, i+1);\r\n    }\r\n    decode2adj(out, tree, extra+1, coder);    \r\n}\r\n\r\npub fn solve(sc: & mut scanner::Scanner,\r\n             out: &mut BufWriter<StdoutLock>) {\r\n    let n: usize = sc.next();\r\n    if n == 2 {\r\n        writeln!(out, \"1 2\");\r\n        return;\r\n    }\r\n    let mut adj = vec![Vec::new(); n];\r\n    // : Vec<Vec<usize>> = Vec::with_capacity(n);\r\n    // for _ in 0..n {\r\n    //     adj.push(Vec::new());\r\n    // }\r\n    for _ in 0..(n-1) {\r\n        let a: usize = sc.next::<usize>();\r\n        let b: usize = sc.next::<usize>();\r\n        adj[a-1].push(b-1);\r\n        adj[b-1].push(a-1);\r\n    }\r\n\r\n    \r\n\r\n    let mut coder = Coder::new();\r\n    code_all(&adj, &mut coder);\r\n    let next_tree :usize = coder.map.len();\r\n    for sz in 1.. {\r\n        for tree in build_trees(sz, &mut coder) {\r\n            if tree >= next_tree {\r\n                print_sol(out, tree, &coder, n-sz as usize);\r\n                return                \r\n            }\r\n        }         \r\n    }\r\n}\r\n\r\n\r\nfn main() {\r\n    // let n = 5; // Change this to generate trees with different numbers of nodes\r\n    // let trees = build_trees(n);\r\n    // println!(\"Number of trees: {}\", trees.len());\r\n    // Further processing to display or analyze the trees can be done here\r\n\r\n    let s = scanner::read_string();\r\n    let mut sc = scanner::Scanner::new(&s);\r\n    \r\n    let out = std::io::stdout();\r\n    let mut out = std::io::BufWriter::new(out.lock());\r\n    // read_after_tree(&mut sc, &mut out);\r\n    solve(&mut sc, &mut out);\r\n}\r\n"
}