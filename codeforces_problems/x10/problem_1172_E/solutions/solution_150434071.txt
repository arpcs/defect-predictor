{
    "id": 150434071,
    "contestId": 1172,
    "creationTimeSeconds": 1647939781,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1172,
        "index": "E",
        "name": "Nauuo and ODT",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1172,
        "members": [
            {
                "handle": "mmaxio"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1559909100
    },
    "programmingLanguage": "Java 11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 170,
    "memoryConsumedBytes": 0,
    "source": "import java.io.*;\r\nimport java.math.*;\r\nimport java.util.*;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.IntConsumer;\r\nimport java.util.function.IntFunction;\r\nimport java.util.stream.*;\r\n\r\npublic class cf564E_lazy {\r\n\r\n\t/**\r\n\t * For subtree-aggregates, you need 2 values for each node: <br>\r\n\t * \r\n\t * 1) subtree(v) = {v} + subtree(l/r) + dashed(v) <br>\r\n\t * 2) dashed(v) = sum over {u: LCtree children u of v WITHOUT the \"solid edge\"\r\n\t * child}\r\n\t */\r\n\tstatic class Node {\r\n\t\tNode l, r, up;\r\n\r\n\t\tint subSz;\r\n\t\tint dSubSz;\r\n\t\tlong dSubSz2;\r\n\t\t\r\n\t\tboolean rev = false;\r\n\r\n\t\tprivate static boolean banCtor = false;\r\n\t\tstatic final Node NULL = new Node();\r\n\r\n\t\tprivate Node() {\r\n\t\t\tif (banCtor) {\r\n\t\t\t\tthrow new AssertionError(\"Use static newNode()\");\r\n\t\t\t}\r\n\t\t\tbanCtor = true;\r\n\t\t}\r\n\r\n\t\tstatic Node newNode() {\r\n\t\t\tbanCtor = false;\r\n\t\t\tNode v = new Node();\r\n\t\t\tv.l = v.r = v.up = NULL;\r\n\t\t\tv.update();\r\n\t\t\treturn v;\r\n\t\t}\r\n\r\n\t\tvoid update() {\r\n\t\t\tsubSz = 1 + dSubSz + l.subSz + r.subSz;\r\n\t\t}\r\n\r\n\t\tboolean isRoot() {\r\n\t\t\treturn up == NULL || (up.l != this && up.r != this);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * \"this\" is guaranteed to not be a splay tree root. <br>\r\n\t\t * \r\n\t\t * For optimization reasons doesn't update info for \"this\". <br>\r\n\t\t * \r\n\t\t * Because of that, \"this\" and \"p\"(second rotation during zig-zig) info might be\r\n\t\t * outdated.\r\n\t\t */\r\n\t\tprivate void rotate() {\r\n\t\t\tNode p = up;\r\n\t\t\tNode pp = p.up;\r\n\r\n\t\t\tif (p.l == this) {\r\n\t\t\t\t// p.setLeft(this.r)\r\n\t\t\t\tp.l = r;\r\n\t\t\t\tr.up = p;\r\n\r\n\t\t\t\t// this.setRight(p)\r\n\t\t\t\tr = p;\r\n\t\t\t\t// p.up = this\r\n\t\t\t} else {\r\n\t\t\t\t// p.setRight(this.l)\r\n\t\t\t\tp.r = l;\r\n\t\t\t\tl.up = p;\r\n\r\n\t\t\t\t// this.setLeft(p)\r\n\t\t\t\tl = p;\r\n\t\t\t\t// p.up = this\r\n\t\t\t}\r\n\t\t\tp.up = this;\r\n\t\t\tp.update();\r\n\r\n\t\t\t// pp could be either\r\n\t\t\t// 1) p's splay parent\r\n\t\t\t// 2) p's LC(but not splay!) parent\r\n\t\t\t// 3) NULL\r\n\t\t\t// Because of 2) we have to use \"else if\"\r\n\t\t\tif (pp.l == p) {\r\n\t\t\t\tpp.l = this;\r\n\t\t\t} else if (pp.r == p) {\r\n\t\t\t\tpp.r = this;\r\n\t\t\t}\r\n\t\t\tup = pp;\r\n\t\t}\r\n\r\n\t\tpublic void changeSolidRightTo(Node newR) {\r\n\t\t\tint x = r.subSz;\r\n\t\t\tint y = newR.subSz;\r\n\t\t\tdSubSz += x - y;\r\n\t\t\tdSubSz2 += (long) x * x - (long) y * y;\r\n\t\t\tr = newR;\r\n\t\t\tupdate();\r\n\t\t}\r\n\t}\r\n\r\n\tstatic final Node NULL = Node.NULL;\r\n\r\n\tstatic class LinkCut {\r\n\r\n\t\tpublic static void splay(Node v) {\r\n\t\t\tinternalSplay(v, true);\r\n\t\t}\r\n\r\n\t\tprivate static void internalSplay(Node v, boolean updateAtTheEnd) {\r\n\t\t\tif (v.isRoot()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tdo {\r\n\t\t\t\tNode p = v.up;\r\n\t\t\t\tNode pp = p.up;\r\n\t\t\t\tif (!p.isRoot()) {\r\n\t\t\t\t\t((pp.l == p) == (p.l == v) ? p : v).rotate();\r\n\t\t\t\t}\r\n\t\t\t\tv.rotate();\r\n\t\t\t} while (!v.isRoot());\r\n\t\t\tif (updateAtTheEnd) {\r\n\t\t\t\tv.update();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic static Node expose(Node v) {\r\n\t\t\tNode rest = NULL;\r\n\t\t\tfor (; v != NULL; rest = v, v = v.up) {\r\n\t\t\t\tinternalSplay(v, false);\r\n\t\t\t\tv.changeSolidRightTo(rest);\r\n\t\t\t}\r\n\t\t\treturn rest;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvoid submit() {\r\n\t\tint n = nextInt();\r\n\t\tint qq = nextInt();\r\n\t\tint[] colors = new int[n];\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tcolors[i] = nextInt() - 1;\r\n\t\t}\r\n\r\n\t\tint[] es = new int[2 * n - 2];\r\n\r\n\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\tes[2 * i] = nextInt() - 1;\r\n\t\t\tes[2 * i + 1] = nextInt() - 1;\r\n\t\t}\r\n\r\n\t\tint[][] g = buildUGraph(es, n, n - 1);\r\n\t\tint[] par = new int[n];\r\n\t\tpar[0] = n;\r\n\t\tint[] stack = new int[n];\r\n\t\tint ptr = 0;\r\n\t\tstack[ptr++] = 0;\r\n\r\n\t\twhile (ptr > 0) {\r\n\t\t\tint v = stack[--ptr];\r\n\t\t\tfor (int u : g[v]) {\r\n\t\t\t\tif (par[v] == u) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tpar[u] = v;\r\n\t\t\t\tstack[ptr++] = u;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tNode[] a = new Node[n + 1];\r\n\t\tfor (int i = 0; i < n + 1; i++) {\r\n\t\t\ta[i] = Node.newNode();\r\n\t\t}\r\n\r\n\t\tIntFunction<Long> turnOn = (int idx) -> {\r\n\t\t\tNode c = a[idx];\r\n\t\t\tNode p = a[par[idx]];\r\n\t\t\tLinkCut.splay(c);\r\n\t\t\tlong delta = -c.dSubSz2;\r\n\t\t\tint sumBelow = c.dSubSz;\r\n\r\n\t\t\tLinkCut.expose(p);\r\n\t\t\tLinkCut.splay(p);\r\n\r\n\t\t\tc.up = p;\r\n\r\n\t\t\tp.dSubSz += c.subSz;\r\n\t\t\tp.dSubSz2 += (long) c.subSz * c.subSz;\r\n\t\t\tp.update();\r\n\r\n\t\t\t// ugly stuff below :(\r\n\t\t\t// we need to find the second node on root to \"p\" path\r\n\t\t\tint newSize;\r\n\t\t\tif (p.l == NULL) {\r\n\t\t\t\tnewSize = c.subSz;\r\n\t\t\t} else {\r\n\t\t\t\tNode root = p;\r\n\t\t\t\twhile (root.l != NULL) {\r\n\t\t\t\t\troot = root.l;\r\n\t\t\t\t}\r\n\t\t\t\tLinkCut.splay(root);\r\n\t\t\t\tnewSize = root.r.subSz;\r\n\t\t\t}\r\n\t\t\tint upSize = newSize - 1 - sumBelow;\r\n\t\t\tdelta += (long) newSize * newSize - (long) upSize * upSize;\r\n\t\t\treturn delta;\r\n\t\t};\r\n\r\n\t\tIntFunction<Long> turnOff = (int idx) -> {\r\n\t\t\tNode c = a[idx];\r\n\r\n\t\t\t// first find out what was our size\r\n\t\t\tNode root = LinkCut.expose(c); // not really root yet!\r\n\t\t\twhile (root.l != NULL) {\r\n\t\t\t\troot = root.l;\r\n\t\t\t}\r\n\t\t\tLinkCut.splay(root);\r\n\t\t\tint oldSize = root.r.subSz;\r\n\t\t\tlong delta = -(long) oldSize * oldSize;\r\n\t\t\tLinkCut.splay(c);\r\n\r\n\t\t\tc.l.up = c.up;\r\n\t\t\tc.l = NULL;\r\n\t\t\tc.update();\r\n\r\n\t\t\tdelta += c.dSubSz2;\r\n\t\t\tint oldSizeUp = oldSize - 1 - c.dSubSz;\r\n\t\t\tdelta += (long) oldSizeUp * oldSizeUp;\r\n\t\t\treturn delta;\r\n\t\t};\r\n\r\n\t\tlong[] deltas = new long[qq + 2];\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tturnOn.apply(i);\r\n\t\t}\r\n\r\n\t\tArrayList<Query> qs = new ArrayList<>();\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tqs.add(new Query(i, 0, colors[i], turnOff));\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < qq; i++) {\r\n\t\t\tint node = nextInt() - 1;\r\n\t\t\tint newColor = nextInt() - 1;\r\n\t\t\tif (colors[node] == newColor) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tqs.add(new Query(node, i + 1, colors[node], turnOn));\r\n\t\t\tcolors[node] = newColor;\r\n\t\t\tqs.add(new Query(node, i + 1, colors[node], turnOff));\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tqs.add(new Query(i, qq + 1, colors[i], turnOn));\r\n\t\t}\r\n\r\n\t\tCollections.sort(qs);\r\n\r\n\t\tfor (Query q : qs) {\r\n\t\t\t// System.err.println(q.node + \" \" + q.time + \" \" + tmp);\r\n\t\t\tdeltas[q.time] -= q.action.apply(q.node);\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i <= qq; i++) {\r\n\t\t\tif (i > 0) {\r\n\t\t\t\tdeltas[i] += deltas[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i <= qq; i++) {\r\n\t\t\tout.println(deltas[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class Query implements Comparable<Query> {\r\n\t\tint node;\r\n\t\tint time;\r\n\t\tint color;\r\n\t\tIntFunction<Long> action;\r\n\r\n\t\tpublic Query(int node, int time, int color, IntFunction<Long> action) {\r\n\t\t\tthis.node = node;\r\n\t\t\tthis.time = time;\r\n\t\t\tthis.color = color;\r\n\t\t\tthis.action = action;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int compareTo(Query o) {\r\n\t\t\tif (color != o.color) {\r\n\t\t\t\treturn color < o.color ? -1 : 1;\r\n\t\t\t}\r\n\t\t\treturn Integer.compare(time, o.time);\r\n\t\t}\r\n\t}\r\n\r\n\tint[][] buildUGraph(int[] a, int n, int m) {\r\n\t\tif (m == 0) {\r\n\t\t\tif (a.length == 0) {\r\n\t\t\t\treturn new int[n][0];\r\n\t\t\t} else {\r\n\t\t\t\tthrow new AssertionError();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (a.length % m != 0 || a.length < 2 * m) {\r\n\t\t\tthrow new AssertionError(\"Bad array length\");\r\n\t\t}\r\n\r\n\t\tint[] deg = new int[n];\r\n\t\tint s = a.length / m;\r\n\t\tfor (int i = 0; i < a.length; i += s) {\r\n\t\t\tdeg[a[i]]++;\r\n\t\t\tdeg[a[i + 1]]++;\r\n\t\t}\r\n\r\n\t\tint[][] g = new int[n][];\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tg[i] = new int[deg[i] * (s - 1)];\r\n\t\t}\r\n\r\n\t\tfor (int i = s * (m - 1); i >= 0; i -= s) {\r\n\t\t\tint v = a[i];\r\n\t\t\tint u = a[i + 1];\r\n\t\t\tint pv = (--deg[v]) * (s - 1);\r\n\t\t\tg[v][pv] = u;\r\n\t\t\tSystem.arraycopy(a, i + 2, g[v], pv + 1, s - 2);\r\n\r\n\t\t\tint pu = (--deg[u]) * (s - 1);\r\n\t\t\tg[u][pu] = v;\r\n\t\t\tSystem.arraycopy(a, i + 2, g[u], pu + 1, s - 2);\r\n\t\t}\r\n\r\n\t\treturn g;\r\n\t}\r\n\r\n\tvoid test() {\r\n\r\n\t}\r\n\r\n\tvoid stress() {\r\n\t\tfor (int tst = 0;; tst++) {\r\n\t\t\tif (false) {\r\n\t\t\t\tthrow new AssertionError();\r\n\t\t\t}\r\n\t\t\tSystem.err.println(tst);\r\n\t\t}\r\n\t}\r\n\r\n\tcf564E_lazy() throws IOException {\r\n\t\tif (!\"true\".equals(System.getProperty(\"ONLINE_JUDGE\"))) {\r\n\t\t\tis = new FileInputStream(\"in.txt\");\r\n\t\t} else {\r\n\t\t\tis = System.in;\r\n\t\t}\r\n\t\tout = new PrintWriter(System.out);\r\n\t\tsubmit();\r\n\t\t// stress();\r\n\t\t// test();\r\n\t\tout.close();\r\n\t}\r\n\r\n\tstatic final Random rng = new Random();\r\n\tstatic final int C = 5;\r\n\r\n\tstatic int rand(int l, int r) {\r\n\t\treturn l + rng.nextInt(r - l + 1);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tnew cf564E_lazy();\r\n\t}\r\n\r\n\tprivate InputStream is;\r\n\tPrintWriter out;\r\n\r\n\tprivate byte[] buf = new byte[1 << 14];\r\n\tprivate int bufSz = 0, bufPtr = 0;\r\n\r\n\tprivate int readByte() {\r\n\t\tif (bufSz == -1)\r\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\r\n\t\tif (bufPtr >= bufSz) {\r\n\t\t\tbufPtr = 0;\r\n\t\t\ttry {\r\n\t\t\t\tbufSz = is.read(buf);\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t}\r\n\t\t\tif (bufSz <= 0)\r\n\t\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn buf[bufPtr++];\r\n\t}\r\n\r\n\tprivate boolean isTrash(int c) {\r\n\t\treturn c < 33 || c > 126;\r\n\t}\r\n\r\n\tprivate int skip() {\r\n\t\tint b;\r\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\r\n\t\t\t;\r\n\t\treturn b;\r\n\t}\r\n\r\n\tString nextToken() {\r\n\t\tint b = skip();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\twhile (!isTrash(b)) {\r\n\t\t\tsb.appendCodePoint(b);\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tString nextString() {\r\n\t\tint b = readByte();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\twhile (!isTrash(b) || b == ' ') {\r\n\t\t\tsb.appendCodePoint(b);\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tdouble nextDouble() {\r\n\t\treturn Double.parseDouble(nextToken());\r\n\t}\r\n\r\n\tchar nextChar() {\r\n\t\treturn (char) skip();\r\n\t}\r\n\r\n\tint nextInt() {\r\n\t\tint ret = 0;\r\n\t\tint b = skip();\r\n\t\tif (b != '-' && (b < '0' || b > '9')) {\r\n\t\t\tthrow new InputMismatchException();\r\n\t\t}\r\n\t\tboolean neg = false;\r\n\t\tif (b == '-') {\r\n\t\t\tneg = true;\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\twhile (true) {\r\n\t\t\tif (b >= '0' && b <= '9') {\r\n\t\t\t\tret = ret * 10 + (b - '0');\r\n\t\t\t} else {\r\n\t\t\t\tif (b != -1 && !isTrash(b)) {\r\n\t\t\t\t\tthrow new InputMismatchException();\r\n\t\t\t\t}\r\n\t\t\t\treturn neg ? -ret : ret;\r\n\t\t\t}\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t}\r\n\r\n\tlong nextLong() {\r\n\t\tlong ret = 0;\r\n\t\tint b = skip();\r\n\t\tif (b != '-' && (b < '0' || b > '9')) {\r\n\t\t\tthrow new InputMismatchException();\r\n\t\t}\r\n\t\tboolean neg = false;\r\n\t\tif (b == '-') {\r\n\t\t\tneg = true;\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\twhile (true) {\r\n\t\t\tif (b >= '0' && b <= '9') {\r\n\t\t\t\tret = ret * 10 + (b - '0');\r\n\t\t\t} else {\r\n\t\t\t\tif (b != -1 && !isTrash(b)) {\r\n\t\t\t\t\tthrow new InputMismatchException();\r\n\t\t\t\t}\r\n\t\t\t\treturn neg ? -ret : ret;\r\n\t\t\t}\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t}\r\n}"
}