{
    "id": 161652591,
    "contestId": 1172,
    "creationTimeSeconds": 1656083666,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1172,
        "index": "E",
        "name": "Nauuo and ODT",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1172,
        "members": [
            {
                "handle": "brunovsky"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1559909100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 72,
    "timeConsumedMillis": 5397,
    "memoryConsumedBytes": 121958400,
    "source": "#include <bits/stdc++.h>\r\n#ifdef LOCAL\r\n#include \"code/formatting.hpp\"\r\n#else\r\n#define debug(...) (void)0\r\n#endif\r\n\r\nusing namespace std;\r\n\r\ntemplate <typename Node>\r\nstruct top_tree {\r\n    // Blueprint: pushup(is-node, left-kid, right-kid, other-kid)\r\n    // Blueprint: pushdown(is-node, left-kid, right-kid, other-kid)\r\n    // Kids: {left-heavy, right-heavy, light-kid, mirror-parent, mirror-kid}\r\n    struct TopNode {\r\n        int parent = 0, kids[5] = {};\r\n        int8_t flip = 0;\r\n        Node data;\r\n    };\r\n    static constexpr int8_t LINK = 2, UPPER = 3, LOWER = 4;\r\n\r\n    int N, E = 0;\r\n    vector<TopNode> st;\r\n    vector<int> freelist;\r\n\r\n    explicit top_tree(int N = 0) : N(N), st(2 * N), freelist(N - 1) {\r\n        for (int i = 0; i < N - 1; i++) {\r\n            freelist[i] = N + i + 1;\r\n        }\r\n    }\r\n\r\n    template <typename T>\r\n    explicit top_tree(int N, const vector<T>& arr) : top_tree(N) {\r\n        for (int u = 1; u <= N; u++) {\r\n            st[u].data = Node(true, arr[u]);\r\n        }\r\n    }\r\n\r\n    // ***** Node updates\r\n  private:\r\n    void orient(int e, int p) {\r\n        if (st[e].kids[UPPER] != p) {\r\n            swap(st[e].kids[UPPER], st[e].kids[LOWER]);\r\n        }\r\n    }\r\n\r\n    void flip(int u) {\r\n        if (u == 0) {\r\n            return;\r\n        }\r\n        auto& [l, r, link, a, b] = st[u].kids;\r\n        swap(l, r);\r\n        swap(a, b);\r\n        st[u].flip ^= 1;\r\n        st[u].data.path_flip();\r\n    }\r\n\r\n    void pushdown(int u) {\r\n        if (u == 0) {\r\n            return;\r\n        }\r\n        auto& [l, r, link, a, b] = st[u].kids;\r\n        if (st[u].flip) {\r\n            flip(l);\r\n            flip(r);\r\n            st[u].flip = 0;\r\n        }\r\n        st[u].data.pushdown(u <= N, st[l].data, st[r].data, st[link].data);\r\n    }\r\n\r\n    void pushup(int u) {\r\n        assert(u != 0);\r\n        auto& [l, r, link, a, b] = st[u].kids;\r\n        st[u].data.pushup(u <= N, st[l].data, st[r].data, st[link].data);\r\n    }\r\n\r\n    template <typename... Vs>\r\n    int new_edge(int upper, int lower, Vs&&... args) {\r\n        int e = freelist[E++];\r\n        st[e].data = Node(false, forward<Vs>(args)...);\r\n        st[e].kids[UPPER] = upper;\r\n        st[e].kids[LOWER] = lower;\r\n        return e;\r\n    }\r\n\r\n    void rem_edge(int e) {\r\n        st[e] = TopNode();\r\n        freelist[--E] = e;\r\n    }\r\n\r\n    void fixup(int u, int v) {\r\n        if (int p = st[v].parent; p && u != p) {\r\n            pushdown(p), pushdown(v), rotate(v);\r\n        }\r\n    }\r\n\r\n    int min_node(int u) {\r\n        while (st[u].kids[0]) {\r\n            u = st[u].kids[0];\r\n            pushdown(u);\r\n        }\r\n        return u;\r\n    }\r\n\r\n    // ***** Interface\r\n  public:\r\n    template <typename... Vs>\r\n    bool link(int u, int v, Vs&&... args) {\r\n        reroot(v), access(u);\r\n        if (st[v].parent)\r\n            return false;\r\n\r\n        int e = new_edge(u, v, forward<Vs>(args)...);\r\n        st[v].kids[UPPER] = e;\r\n        adopt(e, v, LINK);\r\n        light_insert(u, e);\r\n        pushup(u);\r\n        return true;\r\n    }\r\n\r\n    bool cut(int u, int v) {\r\n        reroot(v), access(u), fixup(u, v);\r\n        if (!st[v].parent || v != st[u].kids[0] || st[v].kids[1])\r\n            return false; // u and v are not connected by an edge\r\n\r\n        int e = st[u].kids[UPPER];\r\n        assert(st[u].kids[UPPER] == st[v].kids[LOWER]);\r\n        st[u].kids[0] = st[u].kids[UPPER] = 0;\r\n        st[v].parent = st[v].kids[LOWER] = 0;\r\n        rem_edge(e), pushup(u), pushup(v);\r\n        return true;\r\n    }\r\n\r\n    void reroot(int u) {\r\n        access(u);\r\n        flip(u);\r\n        pushdown(u);\r\n    }\r\n\r\n    int findroot(int u) {\r\n        access(u);\r\n        u = min_node(u);\r\n        splay(u);\r\n        return u;\r\n    }\r\n\r\n    int lca(int u, int v) {\r\n        if (u == v)\r\n            return u;\r\n        access(u), v = access(v);\r\n        return st[u].parent ? v : 0;\r\n    }\r\n\r\n    bool conn(int u, int v) { return lca(u, v) != 0; }\r\n\r\n    Node* access_node(int u) {\r\n        access(u);\r\n        return &st[u].data;\r\n    }\r\n\r\n    Node* access_path(int u, int v) {\r\n        reroot(v), access(u);\r\n        return &st[u].data;\r\n    }\r\n\r\n    Node* access_subtree(int u, int v) {\r\n        reroot(v), access(u);\r\n        return &st[u].data;\r\n    }\r\n\r\n    Node* access_tree(int u) {\r\n        reroot(u), pushdown(u), make_right_light(u);\r\n        return &st[u].data;\r\n    }\r\n\r\n    // ***** Implementation\r\n  private:\r\n    bool is_root(int u) const {\r\n        auto [l, r, t, a, b] = st[st[u].parent].kids;\r\n        return u != l && u != r;\r\n    }\r\n\r\n    void adopt(int parent, int child, int8_t side) {\r\n        if (side >= 0)\r\n            st[parent].kids[side] = child;\r\n        if (child)\r\n            st[child].parent = parent;\r\n    }\r\n\r\n    void rotate(int u) {\r\n        int p = st[u].parent, g = st[p].parent;\r\n        bool uside = u == st[p].kids[1];\r\n        adopt(p, st[u].kids[!uside], uside);\r\n        adopt(g, u, !is_root(p) ? p == st[g].kids[1] : -1);\r\n        adopt(u, p, !uside);\r\n        pushup(p);\r\n    }\r\n\r\n    void splay(int u) {\r\n        int p = st[u].parent, g = st[p].parent;\r\n        while (!is_root(u) && !is_root(p)) {\r\n            pushdown(g), pushdown(p), pushdown(u);\r\n            bool zigzig = (u == st[p].kids[1]) == (p == st[g].kids[1]);\r\n            rotate(zigzig ? p : u), rotate(u);\r\n            p = st[u].parent, g = st[p].parent;\r\n        }\r\n        if (!is_root(u)) {\r\n            pushdown(p), pushdown(u), rotate(u), p = g;\r\n        }\r\n        if (p) {\r\n            adopt(p, u, LINK);\r\n            pushdown(p), pushdown(u), pushup(u), pushup(p);\r\n        } else {\r\n            pushdown(u), pushup(u);\r\n        }\r\n    }\r\n\r\n    int access(int u) {\r\n        splay(u);\r\n        make_right_light(u);\r\n        int w = u, e = st[u].parent;\r\n        while (e) {\r\n            assert(e > N);\r\n            splay(e);\r\n            int v = st[e].parent;\r\n            splay(v);\r\n            light_splice(v, e);\r\n            make_right_light(v);\r\n            heavy_attach(v, w, e, 1);\r\n            w = v, e = st[v].parent;\r\n        }\r\n        splay(u);\r\n        return w;\r\n    }\r\n\r\n    void make_right_light(int u) {\r\n        auto& [l, r, link, a, b] = st[u].kids;\r\n        assert((r != 0) == (b != 0));\r\n        if (r != 0) {\r\n            light_attach(u, r, b);\r\n            r = b = 0;\r\n            pushup(u);\r\n        }\r\n    }\r\n\r\n    void heavy_attach(int u, int v, int e, int8_t side) {\r\n        adopt(u, e, LOWER);\r\n        adopt(u, v, side);\r\n        st[e].kids[LINK] = 0;\r\n        pushup(u);\r\n    }\r\n\r\n    void light_attach(int u, int v, int e) {\r\n        orient(e, u);\r\n        adopt(e, v, LINK);\r\n        pushup(e);\r\n        light_insert(u, e);\r\n    }\r\n\r\n    void light_insert(int u, int e) {\r\n        int link = st[u].kids[LINK];\r\n        adopt(e, link, 0);\r\n        adopt(e, 0, 1);\r\n        adopt(u, e, LINK);\r\n        pushup(e);\r\n    }\r\n\r\n    void light_splice(int v, int e) {\r\n        pushdown(e);\r\n        auto& [l, r, link, a, b] = st[e].kids;\r\n        int root = l ? l : r;\r\n        if (l && r) {\r\n            root = min_node(r);\r\n            st[r].parent = 0;\r\n            splay(root);\r\n            adopt(root, l, 0);\r\n            pushup(root);\r\n        }\r\n        adopt(v, root, LINK);\r\n        st[e].parent = l = r = 0;\r\n        pushup(e);\r\n    }\r\n};\r\n\r\nusing i64 = int64_t;\r\n\r\nstruct Data {\r\n    int full = 1;\r\n    int lsum = 0;\r\n    int rsum = 0;\r\n    i64 blob = 0;\r\n    i64 cold = 0;\r\n\r\n    Data() = default;\r\n    Data(int self) : full(self), lsum(self), rsum(self) {}\r\n\r\n    static i64 sq(i64 x) { return x * x; }\r\n\r\n    i64 rblob() const { return full ? blob : blob + sq(lsum); }\r\n    i64 lblob() const { return full ? blob : blob + sq(rsum); }\r\n    i64 query() const { return lblob() + sq(lsum); }\r\n\r\n    void flip() { swap(lsum, rsum); }\r\n\r\n    void add(Data o) {\r\n        blob += o.blob;\r\n        lsum += o.lsum;\r\n        rsum += o.rsum;\r\n        cold += o.cold;\r\n    }\r\n\r\n    void make_edge(Data node) {\r\n        blob = node.lblob();\r\n        lsum = node.lsum;\r\n        rsum = node.lsum;\r\n        cold = sq(node.lsum);\r\n    }\r\n\r\n    void make_node(Data edge) {\r\n        blob = full ? edge.blob : edge.blob + edge.cold;\r\n        lsum = full ? 1 + edge.lsum : 0;\r\n        rsum = full ? 1 + edge.rsum : 0;\r\n        cold = 0;\r\n    }\r\n\r\n    // [la...ra] [lb...rb] to [la...rb]\r\n    static Data merge(Data a, Data b) {\r\n        assert(!a.full || a.lsum == a.rsum);\r\n        assert(!b.full || b.lsum == b.rsum);\r\n        Data c;\r\n        c.full = a.full & b.full;\r\n        c.lsum = a.full ? a.lsum + b.lsum : a.lsum;\r\n        c.rsum = b.full ? a.rsum + b.rsum : b.rsum;\r\n        c.blob = a.blob + b.blob + (a.full || b.full ? 0 : sq(a.rsum + b.lsum));\r\n        assert(!c.full || c.lsum == c.rsum);\r\n        return c;\r\n    }\r\n};\r\n\r\nstruct Node {\r\n    int self = 0;\r\n    Data data;\r\n\r\n    Node() = default;\r\n    Node(bool) {}\r\n\r\n    i64 query() const { return data.query(); }\r\n\r\n    void path_flip() { data.flip(); }\r\n\r\n    void pushup(bool is, const Node& lhs, const Node& rhs, const Node& tree) {\r\n        if (is) {\r\n            data = Data(self);\r\n            data.make_node(tree.data);\r\n            data = Data::merge(lhs.data, data);\r\n            data = Data::merge(data, rhs.data);\r\n        } else {\r\n            data = Data();\r\n            data.make_edge(tree.data);\r\n            data.add(lhs.data);\r\n            data.add(rhs.data);\r\n        }\r\n    }\r\n\r\n    void pushdown(bool, Node&, Node&, Node&) {}\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false), cin.tie(nullptr);\r\n    int N, Q;\r\n    cin >> N >> Q;\r\n    vector<int> color(N + 1);\r\n    top_tree<Node> tree(N);\r\n    for (int u = 1; u <= N; u++) {\r\n        cin >> color[u];\r\n        tree.access_node(u)->self = 1;\r\n    }\r\n    for (int i = 1; i < N; i++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        tree.link(u, v);\r\n    }\r\n    vector<vector<int>> front(N + 1), back(N + 1);\r\n    vector<vector<array<int, 3>>> events(N + 1);\r\n    for (int u = 1; u <= N; u++) {\r\n        front[color[u]].push_back(u);\r\n    }\r\n    for (int q = 0; q < Q; q++) {\r\n        int u, c;\r\n        cin >> u >> c;\r\n        if (c != color[u]) {\r\n            events[color[u]].push_back({u, q, 1});\r\n            color[u] = c;\r\n            events[color[u]].push_back({u, q, 0});\r\n        }\r\n    }\r\n    for (int u = 1; u <= N; u++) {\r\n        back[color[u]].push_back(u);\r\n    }\r\n    i64 ans = 0;\r\n    vector<i64> delta(Q);\r\n    for (int c = 1; c <= N; c++) {\r\n        for (int u : front[c]) {\r\n            tree.access_node(u)->self = 0;\r\n        }\r\n        i64 f = tree.access_tree(1)->query();\r\n        ans += f;\r\n        for (auto [u, q, x] : events[c]) {\r\n            tree.access_node(u)->self = x;\r\n            i64 g = tree.access_tree(1)->query();\r\n            delta[q] += g - f, f = g;\r\n        }\r\n        for (int u : back[c]) {\r\n            tree.access_node(u)->self = 1;\r\n        }\r\n    }\r\n    i64 F = 1LL * N * N * N;\r\n    cout << F - ans << '\\n';\r\n    for (int q = 0; q < Q; q++) {\r\n        ans += delta[q];\r\n        cout << F - ans << '\\n';\r\n    }\r\n    return 0;\r\n}\r\n"
}