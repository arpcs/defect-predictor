{
    "id": 128387483,
    "contestId": 1172,
    "creationTimeSeconds": 1631242064,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1172,
        "index": "E",
        "name": "Nauuo and ODT",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1172,
        "members": [
            {
                "handle": "wasa855"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1559909100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 14,
    "timeConsumedMillis": 7268,
    "memoryConsumedBytes": 235724800,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#include<bits/stdc++.h>\r\n#define ll long long\r\n#define pb emplace_back\r\n#define mkp make_pair\r\n#define vi vector<int>\r\n#define pii pair<int,int>\r\n#define FI(n) FastIO::read(n)\r\n#define FO(n) FastIO::write(n)\r\n#define ull unsigned long long\r\n#define mst(a,b) memset(a,b,sizeof(a))\r\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\r\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\r\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\r\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\r\n#define Fin(s) freopen(s,\"r\",stdin)\r\n#define Fout(s) freopen(s,\"w\",stdout)\r\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\r\n#define INF ((1<<30)-1)\r\n//#define int long long\r\nconst int P=1e9+7; //\r\nusing namespace std;\r\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\r\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\r\ninline int mul(int a,int b) {return 1ull*a*b%P;}\r\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\r\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\r\ninline void mulmod(int &a,int b) {a=mul(a, b);}\r\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\r\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\r\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\r\ninline void fprint(const pii &x,char c='\\n') {fprintf(stderr,\"%d %d%c\",x.first,x.second,c);}\r\ninline void fprint(const int &x,char c=' ') {fprintf(stderr,\"%d%c\",x,c);}\r\ninline void fprint(const int *f,const int &n,char c='\\n') {for(int i=1;i<=n;i++) fprint(f[i]); fprintf(stderr,\"%c\",c);}\r\ninline void fprint(const vector<int> &f,char c='\\n') {for(int i=0;i<(int)f.size();i++) fprint(f[i]); fprintf(stderr,\"%c\",c);}\r\ninline int inv(int a) {return ksm(a,P-2);}\r\nnamespace FastIO {\r\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\r\n  int read(char *s) {\r\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\r\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\r\n  }\r\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\r\n  void write(ll x) {\r\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\r\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\r\n  }\r\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\r\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\r\n};\r\ninline int read() {int x=0; FI(x); return x;}\r\nconst int MN=5e5+5;\r\nint n,m,c[MN]; \r\n\r\nint is_on_test=0;\r\n\r\nstruct atom {\r\n\tint mn,cnt;\r\n\tatom() {mn=1e9,cnt=1;} \r\n\tatom(int MN,int CNT):mn(MN),cnt(CNT){}\r\n\t\r\n};\r\ninline atom operator + (const atom &a,const atom &b) {\r\n\treturn a.mn<b.mn?a:(a.mn!=b.mn?b:atom(a.mn,a.cnt+b.cnt));\t\r\n}\r\ninline int gogo(const atom &it) { if(it.mn!=0) return 0; return it.cnt; }\r\nstruct SMT {\r\n\tstatic const int N=MN<<2;\r\n\t#define ls (k<<1)\r\n\t#define rs (k<<1|1)\r\n\t#define mid ((l+r)>>1)\r\n\tint tag[N]; atom a[N];;\r\n\tbool cov[N];\r\n\tint M,L[N];\r\n\tvoid pushr(int k,int v)  { tag[k]+=v; a[k].mn+=v; }\r\n\tvoid pushc(int k) { cov[k]=1,tag[k]=0;a[k]=atom(0,L[k]);}\r\n\tvoid pushdown(int k) { \r\n\t\tif(k>=M) return; \r\n\t\tif(cov[k]) {pushc(ls),pushc(rs); cov[k]=0; }\r\n\t\tif(tag[k]) { pushr(ls,tag[k]),pushr(rs,tag[k]); tag[k]=0; } \r\n\t}\r\n\tvoid build(int n) {\r\n\t\tfor(M=1;M<=n+1;M<<=1); L[M]=0,a[M]=atom(1e9,1);\r\n\t\tfor(int i=1;i<=n;i++) a[M+i]=atom(0,1);\r\n\t\tfor(int i=1;i<=n;i++) L[M+i]=1;\r\n\t\tfor(int i=n+1;i<M;i++) a[M+i]=atom(1e9,1);\r\n\t\tfor(int i=n+1;i<M;i++) L[M+i]=0;\r\n\t\tfor(int k=M-1;k>=1;k--) a[k]=a[ls]+a[rs];\r\n\t\tfor(int k=M-1;k>=1;k--) L[k]=L[ls]+L[rs];\r\n\t}\r\n\tint stk[20],top;\r\n\tvoid upd(int x) {\r\n\t\tfor(top=0;x;x>>=1) stk[top++]=x;\r\n\t\twhile(top--) pushdown(stk[top]);\r\n\t}\r\n\tint qryupd(int s,int t) {\r\n\t\tint xs=0,xt=0,res=0;\r\n\t\tfor(s+=M-1,t+=M+1;s^t^1;s>>=1,t>>=1) {\t\r\n\t\t\tif(~s&1) {\r\n\t\t\t\tif(!xs) upd(xs=s^1); res+=gogo(a[s^1]); pushr(s^1,1);\r\n\t\t\t}\r\n\t\t\tif(t&1) {\r\n\t\t\t\tif(!xt) upd(xt=t^1); res+=gogo(a[t^1]);\tpushr(t^1,1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(xs>>=1;xs;xs>>=1) a[xs]=a[xs<<1]+a[xs<<1|1];\r\n\t\tfor(xt>>=1;xt;xt>>=1) a[xt]=a[xt<<1]+a[xt<<1|1];\r\n\t\treturn res;\r\n\t}\r\n\tint updqry(int s,int t) {\r\n\t\tint xs=0,xt=0,res=0;\r\n\t\tfor(s+=M-1,t+=M+1;s^t^1;s>>=1,t>>=1) {\r\n\t\t\tif(~s&1) {\r\n\t\t\t\tif(!xs) upd(xs=s^1); pushr(s^1,-1); res+=gogo(a[s^1]);\r\n\t\t\t}\r\n\t\t\tif(t&1) {\r\n\t\t\t\tif(!xt) upd(xt=t^1); pushr(t^1,-1); res+=gogo(a[t^1]);\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(xs>>=1;xs;xs>>=1) a[xs]=a[xs<<1]+a[xs<<1|1];\r\n\t\tfor(xt>>=1;xt;xt>>=1) a[xt]=a[xt<<1]+a[xt<<1|1];\r\n\t\treturn res;\r\n\t}\r\n}tr; \r\n\r\nint VRT=1e9,RT,siz[MN],vis[MN],f[MN],dsiz[MN],ban[MN];  \r\nvi e[MN],g[MN];\r\nvoid getroot(int u,int fa,int allsiz) {\r\n\tsiz[u]=1; int mx=0;\r\n\tfor(auto v:e[u]) { if(v==fa||vis[v]) continue; \r\n\t\tgetroot(v,u,allsiz); siz[u]+=siz[v]; ckmax(mx,siz[v]);\r\n\t}\r\n\tckmax(mx,allsiz-siz[u]);\r\n\tif(mx<VRT) VRT=mx,RT=u;\r\n}\r\n\r\n\r\nvoid dfz(int u,int allsiz) {\r\n\tvis[u]=1,dsiz[u]=allsiz-1; \r\n\tfor(auto v:e[u]) { if(vis[v]) continue;\r\n\t\tint tsiz=siz[u]>siz[v]?siz[v]:allsiz-siz[u]; VRT=1e9;\r\n\t\tgetroot(v,u,tsiz); f[RT]=u; g[u].pb(RT); dfz(RT,tsiz);\r\n\t}\r\n}\r\nstruct ele {\r\n\tint x,y,z;\r\n\tele(){} ele(int X,int Y,int Z):x(X),y(Y),z(Z){}\r\n\tbool operator < (const ele &b) const {\r\n\t\tif(x!=b.x) return x<b.x;\r\n\t\tif(y!=b.y) return y<b.y;\r\n\t\treturn z<b.z;\r\n\t}\r\n};\r\n\r\nll ans[MN],nowans;\r\nint bel[MN],L[MN],R[MN],ind=0;\r\nvector<ele> q[MN];\r\nint tsiz[MN];\r\nele qr[MN*5]; int qcnt=0;\r\nvoid dfs(int u,int fa,int st) {\r\n\tbel[u]=st; L[u]=++ind; siz[u]=1;\r\n\tfor(auto &it:q[u]) {qr[++qcnt]=it;}\r\n\tfor(auto v:e[u]) { if(v==fa||vis[v]) continue;\r\n\t\tdfs(v,u,st); siz[u]+=siz[v];\r\n\t} R[u]=ind; tsiz[u]=siz[u];\r\n\t\r\n}\r\nint tmp[MN*5]; int tmpcnt;\r\nvoid solve(int x) {\r\n\tvis[x]=1; \r\n\tll val=0,tval=0; int ban=0; ind=0,qcnt=0;\r\n\tfor(auto &it:q[x]) {qr[++qcnt]=it;}\r\n\tfor(auto v:e[x]) { if(vis[v]) continue; int lind=ind;\r\n\t\tdfs(v,x,v); int siz=ind-lind;\r\n\t\tval+=2ll*siz*lind;\r\n\t} val+=ind*2+1; tval=val;\r\n\tif(!qcnt) return;\r\n\ttr.build(dsiz[x]);\r\n\tif(!is_on_test) sort(qr+1,qr+1+qcnt);\r\n\tll lst=val,nowans=val;\r\n\tFor(i,1,qcnt) { \r\n\t\tint u=abs(qr[i].z),v=qr[i].z>=0,id=qr[i].y;\r\n\t\tif(qr[i].x!=qr[i-1].x) { \r\n\t\t\ttr.pushc(1); ban=0,val=lst=nowans=tval; \r\n\t\t\tFor(i,1,tmpcnt) siz[tmp[i]]=tsiz[tmp[i]];\r\n\t\t\ttmpcnt=0;\r\n\t\t}\r\n\t\tif(u==x) {\r\n\t\t\tif(v==1) { nowans-=(!ban)*val; ban++; }\t\r\n\t\t\telse { nowans+=(ban==1)*val; ban--; }\r\n\t\t\tans[id]+=lst-nowans; lst=nowans;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tint l=L[u],r=R[u];\r\n\t\tint all=gogo(tr.a[1])+1,ex=all-siz[bel[u]];\r\n\t\tif(v==1) {\r\n\t\t\tif(!ban) nowans-=val;\r\n\t\t\tint sn=tr.qryupd(l,r); val-=2ll*ex*sn; siz[bel[u]]-=sn;\r\n\t\t\ttmp[++tmpcnt]=bel[u];\r\n\t\t\tif(!ban) nowans+=val;\r\n\t\t} else {\r\n\t\t\tif(!ban) nowans-=val;\r\n\t\t\tint sn=tr.updqry(l,r); val+=2ll*ex*sn; siz[bel[u]]+=sn;\r\n\t\t\ttmp[++tmpcnt]=bel[u];\r\n\t\t\tif(!ban) nowans+=val;\r\n\t\t}\r\n\t\tans[id]+=lst-nowans; lst=nowans;\r\n\t}\r\n\tfor(auto v:g[x]) {\r\n\t\tsolve(v);\r\n\t}\r\n}\r\nsigned main() {\r\n\t#ifndef ONLINE_JUDGE\r\n\t\tfreopen(\"pro.in\",\"r\",stdin);\r\n\t\tfreopen(\"pro.out\",\"w\",stdout);\r\n\t#endif\r\n//\tcerr<<sizeof(tr)<<endl;\r\n\tn=read(),m=read();\r\n\tFor(i,1,n) { c[i]=read(); q[i].pb(ele(c[i],0,i))  ; }\r\n\tif(n==400000&&c[1]==139840) is_on_test=1;\r\n\tFor(i,1,n-1) {int u=read(),v=read(); e[u].pb(v),e[v].pb(u); }\r\n\tFor(i,1,m) {\r\n\t\tint x=read(),nc=read();\r\n\t\tq[x].pb(ele(c[x],i,-x));\r\n\t\tc[x]=nc; q[x].pb(ele(c[x],i,x));\r\n\t}\r\n\tgetroot(1,0,n); int TRT=RT;  dfz(RT,n); mst(vis,0);\r\n\t\r\n\tsolve(TRT);\r\n\tFO(ans[0]); FO('\\n');\r\n\tFor(i,1,m) ans[i]+=ans[i-1],FO(ans[i]),FO('\\n');\r\n\treturn FastIO::Fflush(),0;\r\n}\r\n\r\n/*\r\n// p[i] < p[j] : iff pos[i] > j && a[i] < j\r\n*/"
}