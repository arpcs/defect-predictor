{
    "id": 159191866,
    "contestId": 1172,
    "creationTimeSeconds": 1654108914,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1172,
        "index": "E",
        "name": "Nauuo and ODT",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1172,
        "members": [
            {
                "handle": "willy108"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1559909100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 8,
    "timeConsumedMillis": 3119,
    "memoryConsumedBytes": 396390400,
    "source": "\r\n//misaka will carry me to master\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <utility>\r\n#include <cassert>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <functional>\r\n#include <numeric>\r\n#include <set>\r\n#include <map>\r\n\r\n#define ll long long\r\n#define lb long double\r\n#define sz(vec) ((int)(vec.size()))\r\n#define all(x) x.begin(), x.end()\r\n#define pb push_back\r\n#define mp make_pair\r\n#define kill(x, s) {int COND = x; if(COND){ cout << s << \"\\n\"; return ; }}\r\n\r\nconst lb eps = 1e-9;\r\nconst ll mod = 1e9 + 7, ll_max = 1e18;\r\n//const ll mod = (1 << (23)) * 119 +1, ll_max = 1e18;\r\nconst int MX = 'HUG', int_max = 0x3f3f3f3f;\r\n\r\nstruct {\r\n  template<class T>\r\n  operator T() {\r\n    T x; std::cin >> x; return x;\r\n  }\r\n} in;\r\n\r\nusing namespace std;\r\n\r\n\r\n \r\n#define lc c[0]\r\n#define rc c[1]\r\n#define ile(u) (tr[tr[u].par].lc != u)\r\n#define getv(u) tr[u].v\r\n#define lson(u) tr[u].c[0]\r\n#define rson(u) tr[u].c[1]\r\nstruct splay_tree{\r\n\tstruct value{\r\n\t\tint val; \r\n\t\tint sz; ll sq, asq;\r\n\t\tint u;\r\n\t\tvalue(){val = sz = u = sq = 0;}\r\n\t\tvalue(int a){ u = a; sz = 1; val = asq = sq= 0;}\r\n\t\tvalue(int a, int b, ll c, ll d, int e){ val = a, sz = b, u = e; sq = c, asq = d;}\r\n \r\n\t};\r\n\tstruct tag{\r\n\t\tint rev;\r\n\t\ttag(ll a, ll b, ll c){ rev = c; }\r\n\t\ttag(int a){ rev = a;}\r\n\t\ttag(){ rev = 0;}\r\n\t\ttag operator * (const tag& b) const{\r\n\t\t\tif(isid()) return b;\r\n\t\t\tif(b.isid()) return *this;\r\n\t\t\treturn tag(rev^b.rev);\r\n\t\t}\t\t\r\n\t\tvalue operator + (const value& b) const{\r\n\t\t\treturn b;\r\n\t\t}\r\n\t\tbool isid() const{ return (rev == 0); }\r\n\t\t//bool operator == (const tag& b) const{\r\n\t\t\t//return (add == b.add) && (mul == b.mul) && (rev == b.rev);\r\n\t\t//}\r\n\t} basic_rev;\r\n\tstruct node{\r\n\t\tint par, pptr;\r\n\t\tint c[2];\r\n\t\tvalue v;\r\n\t\ttag t;\r\n\t\tnode(){ par =c[0] = c[1] = pptr = 0; }\r\n\t} ;\r\n\tvector<node> tr;\r\n\tvector<int> ptr;\r\n\tvoid pull(int u){\r\n\t\t//assert(u);\r\n\t\tgetv(u).sz = 1 + getv(u).val + getv(lson(u)).sz + getv(rson(u)).sz;\r\n\t\tgetv(u).asq = getv(u).sq + 1ll*getv(lson(u)).sz*getv(lson(u)).sz + 1ll*getv(rson(u)).sz*getv(rson(u)).sz;\r\n\t}\r\n\tvoid apply(int u, const tag& t){\r\n\t\tif(!u || t.isid()) return ;\r\n\t\t//assert(t.mul == 1 && t.add == 0);\r\n\t\ttr[u].t = t * tr[u].t;\r\n\t\ttr[u].v = t + tr[u].v;\r\n\t\t//tr[u].aggr = t + tr[u].v;\r\n\t}\r\n\tvoid push(int u){\r\n\t\tif(!u) return ;\r\n\t\tif(tr[u].t.isid()) return ;\r\n\t\tif(tr[u].t.rev){\r\n\t\t\tswap(tr[u].lc, tr[u].rc);\r\n\t\t}\r\n\t\tapply(tr[u].lc, tr[u].t);\r\n\t\tapply(tr[u].rc, tr[u].t);\r\n\t\ttr[u].t = tag();\r\n\t}\r\n\tsplay_tree(){\r\n\t\tbasic_rev = tag(0, 1, 1);\r\n\t\tnode zero = node();\r\n\t\tzero.v = value();\r\n\t\tzero.t = tag();\r\n\t\ttr.pb(zero);\r\n\t}\r\n\tsplay_tree(int n){\r\n\t\t*this = splay_tree();\r\n\t\tptr = vector<int>(n+5, 0);\r\n\t\tfor(int i = 1; i<=n; i++){\r\n\t\t\tnode tmp = node();\r\n\t\t\t//if(i != n)\r\n\t\t\t\ttmp.v = value(i);\r\n\t\t\t//else{\r\n\t\t\t\t//tmp.v = value();\r\n\t\t\t\t//tmp.v.u = i;\r\n\t\t\t//}\r\n\t\t\ttmp.t = tag();\r\n\t\t\ttmp.pptr = 0;\r\n\t\t\tptr[i] = sz(tr);\r\n\t\t\ttr.pb(tmp);\r\n\t\t\tassert(ptr[i] == i);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid pr(int u){\r\n\t\tstatic int dep = 0;\r\n\t\tif(!u) return ;\r\n\t\tdep++;\r\n\t\tpush(u);\r\n\t\tpr(tr[u].lc);\r\n\t\t//if(tr[u].v.val)\r\n\t\tcerr << tr[u].v.u << \" \";\r\n\t\tpr(tr[u].rc);\r\n\t\tdep--;\r\n\t\tif(dep == 0) cout << \"\\n\";\r\n\t}\r\n \r\n\tvoid rotate(int u, int dir){\r\n\t\tint r = u;\r\n\t\tint g = tr[u].c[dir];\r\n\t\tint a = tr[tr[u].c[dir]].c[dir^1];\r\n\t\t//order of pushing: tr[u].par, u, g\r\n\t\t//changes to c\r\n\t\tpush(tr[u].par);\r\n\t\tpush(u);\r\n\t\tpush(g);\r\n\t\tif(tr[r].par){\r\n\t\t\tif(!ile(r)) tr[tr[r].par].lc = g;\r\n\t\t\telse tr[tr[r].par].rc = g;\r\n\t\t}\r\n\t\tassert(r && g);\r\n\t\ttr[g].c[dir^1] = r; \r\n\t\ttr[r].c[dir] = a;\r\n\t\t//changes to par\r\n\t\ttr[g].par = tr[r].par;\r\n\t\ttr[r].par = g;\r\n\t\tif(a) tr[a].par = r;\r\n\t\t//order of pulling: r, g, tr[g].par\t\r\n\t\tpull(r);\r\n\t\tpull(g);\r\n\t\tif(tr[g].par) pull(tr[g].par);\r\n\t}\r\n\tvoid prop_all(int u){\r\n\t\tstatic int dep = 0;\r\n\t\tif(!u) return ;\r\n\t\tdep++;\r\n\t\tassert(dep < 20);\r\n\t\tprop_all(tr[u].par);\r\n\t\tdep--;\r\n\t\tpush(u);\r\n\t}\r\n\tvoid splay(int u){\r\n\t\tprop_all(u);\r\n\t\tint pptr = 0;\r\n\t\tfor(int j = u; j; j = tr[j].par){\r\n\t\t\tif(tr[j].par == 0){\r\n\t\t\t\tpptr = tr[j].pptr;\r\n\t\t\t\ttr[j].pptr = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(tr[u].par){\r\n\t\t\tint p = tr[u].par, gp = tr[p].par;\r\n\t\t\t//if(gp) push(gp);\r\n\t\t\t//if(p) push(p);\r\n\t\t\t//if(u) push(u);\r\n\t\t\tif(gp == 0){\r\n\t\t\t\t//zig\r\n\t\t\t\trotate(p, ile(u));\r\n\t\t\t}else if(ile(p)^ile(u)){\r\n\t\t\t\t//zig zag\r\n\t\t\t\trotate(p, ile(u));\r\n\t\t\t\trotate(gp, ile(u));\r\n\t\t\t}else{\r\n\t\t\t\t//zig zig\r\n\t\t\t\trotate(gp, ile(p));\r\n\t\t\t\trotate(p, ile(u));\r\n\t\t\t}\r\n \r\n\t\t}\t\r\n\t\ttr[u].pptr = pptr;\r\n\t\tpull(u);\r\n\t\tassert(tr[0].lc == tr[0].rc && tr[0].rc == 0 && tr[0].pptr == 0);\r\n\t}\r\n\tint find(int u){\r\n\t\tsplay(ptr[u]);\r\n\t\treturn ptr[u];\r\n\t}\t\r\n\tvoid dettach(int v, int c){\r\n\t\t//splay(v);\r\n\t\tpush(v);\r\n\t\tint rem = tr[v].c[c];\r\n\t\tif(!rem) return ;\r\n\t\tgetv(v).val += getv(rem).sz;\r\n\t\tgetv(v).sq += 1ll*getv(rem).sz*getv(rem).sz;\r\n\t\ttr[v].c[c] = 0;\r\n\t\ttr[rem].par = 0;\r\n\t\ttr[rem].pptr = v;\r\n\t\tassert(rem != v);\r\n\t\tpull(v);\r\n\t}\r\n\tvoid attach(int u, int v){\r\n\t\tif(min(u, v) == 0) return ;\r\n\t\tgetv(u).val -= getv(v).sz;\r\n\t\tgetv(u).sq -= 1ll*getv(v).sz*getv(v).sz;\r\n\t}\r\n};\r\n\r\n#undef lc\r\n#undef rc\r\n#undef ile\r\n\r\nstruct link_cut_tree{\r\n\tsplay_tree aux;\r\n\tlink_cut_tree(){ aux = splay_tree(); }\r\n\tlink_cut_tree(int n){\r\n\t\taux = splay_tree(n);\r\n\t}\r\n\tint access(int x){\r\n\t\tint u = aux.find(x);\r\n\t\taux.dettach(u, 1);\r\n\t\taux.pull(u);\r\n\t\tint lca = u;\r\n\t\twhile(aux.tr[u].pptr){\r\n\t\t\tint v = aux.tr[u].pptr;\r\n\t\t\tlca = v;\r\n\t\t\taux.splay(v);\r\n\t\t\tassert(aux.tr[v].par == 0);\r\n\t\t\taux.dettach(v, 1);\r\n\t\t\taux.attach(v, u);\r\n\t\t\taux.tr[v].c[1] = u;\r\n\t\t\taux.tr[u].par = v;\r\n\t\t\taux.tr[u].pptr = 0; //idk\r\n\t\t\taux.pull(v);\r\n\t\t\taux.splay(u);\r\n\t\t\t//u = v;\r\n\t\t}\r\n\t\t//aux.splay(aux.find(x));\r\n\t\t//cout << u << \"aaaaaaaaaaa\\n\";\r\n\t\tassert(aux.tr[u].par == 0);\r\n\t\treturn aux.tr[lca].v.u;\r\n\t}\r\n\tvoid reroot(int x){\r\n\t\tint u = aux.find(x);\r\n\t\taccess(x);\r\n\t\taux.splay(u);\r\n\t\taux.apply(u, aux.basic_rev);\r\n\t}\r\n\tint leader(int a){\r\n\t\taccess(a);\r\n\t\twhile(1){\r\n\t\t\taux.push(a);\r\n\t\t\tif(aux.lson(a)) a = aux.lson(a);\r\n\t\t\telse{\r\n\t\t\t\taccess(a);\r\n\t\t\t\treturn a;\r\n\t\t\t}\r\n\t\t}\t\r\n\t}\r\n\tint lca(int a, int b){\r\n\t\tif(a == b){\r\n\t\t\taccess(a);\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\taccess(a);\r\n\t\treturn access(b); //trust?\r\n\t}\r\n\tvoid link(int a, int b){\r\n\t\tassert(leader(a) != leader(b));\r\n\t\taccess(a);\r\n\t\treroot(b);\r\n\t\taux.push(a);\r\n\t\taux.rson(a) = b;\r\n\t\taux.tr[b].par = a;\r\n\t\taux.tr[b].pptr = 0;\r\n\t\taux.pull(a);\r\n\t}\r\n\r\n\tvoid cut(int a, int b){\r\n\t\tassert(leader(a) == leader(b));\r\n\t\taccess(a);\r\n\t\t//reroot(a);\r\n\t\taccess(b);\r\n\t\taux.push(b);\r\n\t\t//if(aux.lson(b)){\r\n\r\n\t\t//if(aux.lson(b) != a){\r\n\t\t\t//cout << \"eade \" << a << \" \" << b << \"\\n\";\r\n\t\t//}\t\t\t\r\n\t\t\taux.tr[a].par = 0;\r\n\t\t\taux.lson(b) = 0;\r\n\t\t\taux.pull(b);\r\n\t\t\t//pull(a);\r\n\t\t//}\r\n\t}\r\n\tvoid update(int a, int b, splay_tree::tag t){\r\n\t\treroot(a);\r\n\t\taccess(b);\r\n\t\taux.apply(aux.find(b), t);\r\n\t}\r\n\tint parent(int x){\r\n\t\taccess(aux.find(x));\r\n\t\taux.splay(x);\r\n\t\treturn aux.tr[x].c[0];\r\n\t}\r\n\tll square(int u){\r\n\t\tif(!u) return 0;\r\n\t\taccess(u);\r\n\t\taux.pull(u);\r\n\t\treturn aux.getv(u).asq;\r\n\t}\r\n\r\n};\r\n\r\nvector<pair<int, int>> events[MX];\r\nvector<int> adj[MX];\r\nint alive[MX];\r\nll change[MX];\r\nint color[MX];\r\n\r\nint par[MX];\r\nint n, q;\r\n\r\nvoid dfs(int u, int p){\r\n\tpar[u] = p;\r\n\tfor(int v : adj[u]){\r\n\t\tif(v != p) dfs(v, u);\r\n\t}\r\n}\r\n\r\nvoid solve(){\r\n\tn = in, q = in;\r\n\tlink_cut_tree lct = link_cut_tree(n+1);\r\n\tfor(int i = 1; i<=n; i++){\r\n\t\tcin >> color[i];\r\n\t\tevents[color[i]].pb(mp(i, 0));\r\n\t}\r\n\tfor(int i = 1; i<n; i++){\r\n\t\tint a = in, b = in;\r\n\t\tadj[a].pb(b);\r\n\t\tb[adj].pb(a);\r\n\t}\r\n\tdfs(1, n+1);\r\n\tfor(int i = 1; i<=q; i++){\r\n\t\tint a = in, b = in;\r\n\t\tevents[color[a]].pb(mp(a, i));\r\n\t\tevents[b].pb(mp(a, i));\r\n\t\tcolor[a] = b;\r\n\t}\r\n\tfor(int i = 1; i<=n; i++){\r\n\t\t//cerr << i << \" \" << par[i] << \"\\n\";\r\n\t\tlct.link(par[i], i);\r\n\t\t//cout << lct.leader(i) << \" \";\r\n\t}\r\n\t//for(int i = 1; i<=n; i++){\r\n\t\t//lct.reroot(n+1);\r\n\t\t//lct.access(i);\r\n\t\t//cout << \"path to root \" << i << \"\\n\";\r\n\t\t//lct.aux.pr(i);\r\n\t\t\r\n\t//}\r\n\t//cout << lct.leader(n+1) << \"\\n\";\r\n\t//lct.reroot(n+1);\r\n\tfor(int i = 1; i<=n; i++){\r\n\t\tlct.reroot(n+1);\r\n\t\tfor(const auto& [u, ind] : events[i]){\r\n\t\t\t//lct.reroot(n+1);\r\n\t\t\tif(alive[u]){\r\n\t\t\t\tint r = lct.leader(par[u]);\r\n\t\t\t\tchange[ind] -= lct.square(u) + lct.square(r);\r\n\t\t\t\tassert(lct.leader(par[u]) != lct.leader(u));\r\n\t\t\t\tlct.link(par[u], u);\r\n\t\t\t\tlct.access(r);\r\n\t\t\t\tchange[ind] += lct.square(r);\r\n\t\t\t\t//cout << \"link \" << lct.square(r) << \"\\n\";\r\n\t\t\t}else{\r\n\t\t\t\tlct.access(u);\r\n\t\t\t\tint r = lct.leader(u);\r\n\t\t\r\n\t\t\t\tchange[ind] -= lct.square(r);\r\n\t\t\t\tlct.cut(par[u], u);\r\n\t\t\t\tlct.access(r);\r\n\t\t\t\tchange[ind] += lct.square(u) + lct.square(r);\r\n\t\t\t}\r\n\t\t\t//cerr << i << \" \" << u << \" \" << ind << \" \" << change[ind] << \"\\n\";\r\n\t\t\talive[u] ^= 1;\r\n\t\t}\r\n\t\tfor(const auto& [u, ind] : events[i]){\r\n\t\t\tif(alive[u] == 1){\r\n\t\t\t\tlct.link(par[u], u);\r\n\t\t\t\talive[u] = 0;\r\n\t\t\t}\t\r\n\t\t}\r\n\t\t//cerr << lct.square(n+1) << \"\\n\";\r\n\t}\r\n\tll ans = 0;\r\n\tfor(int i = 0; i<=q; i++){\r\n\t\tans += change[i];\r\n\t\tcout << -ans << \"\\n\";\r\n\t}\r\n\t\r\n\t\r\n}\t\r\n\r\nint main(){\r\n  cin.tie(0) -> sync_with_stdio(0);\r\n\r\n  int T = 1;\r\n  //cin >> T;\r\n  for(int i = 1; i<=T; i++){\r\n\t\tsolve();\r\n\t}\r\n  return 0;\r\n}\r\n\r\n\r\n"
}