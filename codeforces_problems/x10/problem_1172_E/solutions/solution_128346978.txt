{
    "id": 128346978,
    "contestId": 1172,
    "creationTimeSeconds": 1631192929,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1172,
        "index": "E",
        "name": "Nauuo and ODT",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1172,
        "members": [
            {
                "handle": "YLWang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1559909100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 10,
    "timeConsumedMillis": 5942,
    "memoryConsumedBytes": 215654400,
    "source": "#define _CRT_SECURE_NO_WARNINGS\r\n#pragma GCC optimize(2)\r\n#pragma GCC optimize(3)\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"inline\")\r\n#pragma GCC optimize(\"-fgcse\")\r\n#pragma GCC optimize(\"-fgcse-lm\")\r\n#pragma GCC optimize(\"-fipa-sra\")\r\n#pragma GCC optimize(\"-ftree-pre\")\r\n#pragma GCC optimize(\"-ftree-vrp\")\r\n#pragma GCC optimize(\"-fpeephole2\")\r\n#pragma GCC optimize(\"-ffast-math\")\r\n#pragma GCC optimize(\"-fsched-spec\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#pragma GCC optimize(\"-falign-jumps\")\r\n#pragma GCC optimize(\"-falign-loops\")\r\n#pragma GCC optimize(\"-falign-labels\")\r\n#pragma GCC optimize(\"-fdevirtualize\")\r\n#pragma GCC optimize(\"-fcaller-saves\")\r\n#pragma GCC optimize(\"-fcrossjumping\")\r\n#pragma GCC optimize(\"-fthread-jumps\")\r\n#pragma GCC optimize(\"-funroll-loops\")\r\n#pragma GCC optimize(\"-fwhole-program\")\r\n#pragma GCC optimize(\"-freorder-blocks\")\r\n#pragma GCC optimize(\"-fschedule-insns\")\r\n#pragma GCC optimize(\"inline-functions\")\r\n#pragma GCC optimize(\"-ftree-tail-merge\")\r\n#pragma GCC optimize(\"-fschedule-insns2\")\r\n#pragma GCC optimize(\"-fstrict-aliasing\")\r\n#pragma GCC optimize(\"-fstrict-overflow\")\r\n#pragma GCC optimize(\"-falign-functions\")\r\n#pragma GCC optimize(\"-fcse-skip-blocks\")\r\n#pragma GCC optimize(\"-fcse-follow-jumps\")\r\n#pragma GCC optimize(\"-fsched-interblock\")\r\n#pragma GCC optimize(\"-fpartial-inlining\")\r\n#pragma GCC optimize(\"no-stack-protector\")\r\n#pragma GCC optimize(\"-freorder-functions\")\r\n#pragma GCC optimize(\"-findirect-inlining\")\r\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\r\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\r\n#pragma GCC optimize(\"inline-small-functions\")\r\n#pragma GCC optimize(\"-finline-small-functions\")\r\n#pragma GCC optimize(\"-ftree-switch-conversion\")\r\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\r\n#pragma GCC optimize(\"-fexpensive-optimizations\")\r\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\r\n#pragma GCC optimize(\"inline-functions-called-once\")\r\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\r\n#include<bits/stdc++.h>\r\n#define ll long long\r\n#define pb emplace_back\r\n#define mkp make_pair\r\n#define vi vector<int>\r\n#define pii pair<int,int>\r\n#define FI(n) FastIO::read(n)\r\n#define FO(n) FastIO::write(n)\r\n#define ull unsigned long long\r\n#define mst(a,b) memset(a,b,sizeof(a))\r\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\r\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\r\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\r\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\r\n#define Fin(s) freopen(s,\"r\",stdin)\r\n#define Fout(s) freopen(s,\"w\",stdout)\r\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\r\n#define INF ((1<<30)-1)\r\n//#define int long long\r\nconst int P=1e9+7; //\r\nusing namespace std;\r\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\r\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\r\ninline int mul(int a,int b) {return 1ull*a*b%P;}\r\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\r\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\r\ninline void mulmod(int &a,int b) {a=mul(a, b);}\r\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\r\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\r\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\r\ninline void fprint(const pii &x,char c='\\n') {fprintf(stderr,\"%d %d%c\",x.first,x.second,c);}\r\ninline void fprint(const int &x,char c=' ') {fprintf(stderr,\"%d%c\",x,c);}\r\ninline void fprint(const int *f,const int &n,char c='\\n') {for(int i=1;i<=n;i++) fprint(f[i]); fprintf(stderr,\"%c\",c);}\r\ninline void fprint(const vector<int> &f,char c='\\n') {for(int i=0;i<(int)f.size();i++) fprint(f[i]); fprintf(stderr,\"%c\",c);}\r\ninline int inv(int a) {return ksm(a,P-2);}\r\nnamespace FastIO {\r\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\r\n  int read(char *s) {\r\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\r\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\r\n  }\r\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\r\n  void write(ll x) {\r\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\r\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\r\n  }\r\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\r\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\r\n};\r\ninline int read() {int x=0; FI(x); return x;}\r\nconst int MN=5e5+5;\r\nint n,m,c[MN]; \r\n\r\n\r\nstruct atom {\r\n\tint mn,cnt;\r\n\tatom() {mn=1e9,cnt=1;} \r\n\tatom(int MN,int CNT):mn(MN),cnt(CNT){}\r\n\tatom operator + (const atom &b) {\r\n\t\treturn mn!=b.mn?(mn<b.mn?*this:b):atom(mn,cnt+b.cnt);\t\r\n\t}\r\n};\r\nstruct SMT {\r\n\tstatic const int N=MN<<2;\r\n\t#define ls (k<<1)\r\n\t#define rs (k<<1|1)\r\n\t#define mid ((l+r)>>1)\r\n\tint tag[N]; atom a[N];;\r\n\tbool cov[N];\r\n\tvoid pushup(int k) { a[k]=a[ls]+a[rs]; }\r\n\tvoid pushr(int k,int v)  { tag[k]+=v; a[k].mn+=v; }\r\n\tvoid pushc(int k,int l,int r) { cov[k]=1,tag[k]=0,a[k]=atom(0,r-l+1);}\r\n\tvoid pushdown(int k,int l,int r) { \r\n\t\tif(cov[k]) { pushc(ls,l,mid),pushc(rs,mid+1,r); cov[k]=0; }\r\n\t\tif(tag[k]) { pushr(ls,tag[k]),pushr(rs,tag[k]); tag[k]=0; } \r\n\t}\r\n\tinline void upd(int k,int l,int r,int ql,int qr,int v) {\r\n\t\t\r\n\t\tif(l>qr||r<ql) return; if(ql<=l&&r<=qr) return pushr(k,v); pushdown(k,l,r);\r\n\t\tupd(ls,l,mid,ql,qr,v),upd(rs,mid+1,r,ql,qr,v); pushup(k);\r\n\t}\r\n\tatom qry(int k,int l,int r,int ql,int qr) {\r\n\t\tif(l>qr||r<ql) return atom(1e9,1); if(ql<=l&&r<=qr) return a[k]; pushdown(k,l,r);\r\n\t\treturn qry(ls,l,mid,ql,qr)+qry(rs,mid+1,r,ql,qr);\r\n\t}\r\n\tatom qryupd(int k,int l,int r,int ql,int qr) {\r\n\t\tif(l>qr||r<ql) return atom(1e9,1); if(ql<=l&&r<=qr) { atom ans=a[k]; pushr(k,1); return ans;} pushdown(k,l,r);\r\n\t\tatom ans=qryupd(ls,l,mid,ql,qr)+qryupd(rs,mid+1,r,ql,qr); pushup(k); return ans;\r\n\t}\r\n\tatom updqry(int k,int l,int r,int ql,int qr) {\r\n\t\tif(l>qr||r<ql) return atom(1e9,1); if(ql<=l&&r<=qr) return pushr(k,-1),a[k]; pushdown(k,l,r);\r\n\t\tatom ans=updqry(ls,l,mid,ql,qr)+updqry(rs,mid+1,r,ql,qr); pushup(k); return ans;\r\n\t}\r\n}tr; \r\nint gogo(atom it) { if(it.mn!=0) return 0; return it.cnt; }\r\n\r\nint VRT=1e9,RT,siz[MN],vis[MN],f[MN],dsiz[MN],ban[MN];  \r\nvi e[MN],g[MN];\r\nvoid getroot(int u,int fa,int allsiz) {\r\n\tsiz[u]=1; int mx=0;\r\n\tfor(auto v:e[u]) { if(v==fa||vis[v]) continue; \r\n\t\tgetroot(v,u,allsiz); siz[u]+=siz[v]; ckmax(mx,siz[v]);\r\n\t}\r\n\tckmax(mx,allsiz-siz[u]);\r\n\tif(mx<VRT) VRT=mx,RT=u;\r\n}\r\n\r\n\r\nvoid dfz(int u,int allsiz) {\r\n\tvis[u]=1,dsiz[u]=allsiz-1; \r\n\tfor(auto v:e[u]) { if(vis[v]) continue;\r\n\t\tint tsiz=siz[u]>siz[v]?siz[v]:allsiz-siz[u]; VRT=1e9;\r\n\t\tgetroot(v,u,tsiz); f[RT]=u; g[u].pb(RT); dfz(RT,tsiz);\r\n\t}\r\n}\r\nstruct ele {\r\n\tint x,y,z;\r\n\tele(){} ele(int X,int Y,int Z):x(X),y(Y),z(Z){}\r\n\tbool operator < (const ele &b) const {\r\n\t\tif(x!=b.x) return x<b.x;\r\n\t\tif(y!=b.y) return y<b.y;\r\n\t\treturn z<b.z;\r\n\t}\r\n};\r\n\r\nll ans[MN],nowans;\r\nint bel[MN],L[MN],R[MN],ind=0;\r\nvector<ele> q[MN];\r\nele qr[MN*5]; int qcnt=0;\r\nvoid dfs(int u,int fa,int st) {\r\n\tbel[u]=st; L[u]=++ind;\r\n\tfor(auto &it:q[u]) {qr[++qcnt]=it;}\r\n\tfor(auto v:e[u]) { if(v==fa||vis[v]) continue;\r\n\t\tdfs(v,u,st);\r\n\t} R[u]=ind;\r\n\t\r\n}\r\n\r\nint tot=0,ooo=0,dtot=0;\r\nvoid solve(int x) {\r\n\tvis[x]=1; tot++;\r\n\tif(ooo&&tot>=200000) { cout<<dtot<<endl; exit(0); return; }; dtot+=siz[x];\r\n\t\r\n\tll val=0,tval=0; int ban=0; ind=0,qcnt=0;\r\n\tfor(auto &it:q[x]) {qr[++qcnt]=it;}\r\n\tfor(auto v:e[x]) { if(vis[v]) continue; int lind=ind;\r\n\t\tdfs(v,x,v); int siz=ind-lind;\r\n\t\tval+=2ll*siz*lind;\r\n\t} val+=ind*2+1; tval=val;\r\n//\tfprintf(stderr,\"solve on %d\\n\",x);\r\n\tsort(qr+1,qr+1+qcnt);\r\n\tll lst=val,nowans=val;\r\n\tFor(i,1,qcnt) { \r\n\t\tint u=abs(qr[i].z),v=qr[i].z>=0,id=qr[i].y;\r\n//\t\tcerr<<qr[i].x<<' '<<u<<' '<<v<<' '<<id<<' '<<endl;\r\n\t\tif(qr[i].x!=qr[i-1].x) { tr.pushc(1,1,dsiz[x]); ban=0,val=lst=nowans=tval;}\r\n\t\tif(u==x) {\r\n\t\t\tif(v==1) { nowans-=(!ban)*val; ban++; }\t\r\n\t\t\telse { nowans+=(ban==1)*val; ban--; }\r\n\t\t\tans[id]+=lst-nowans; lst=nowans;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tint l=L[u],r=R[u],tmpl=L[bel[u]],tmpr=R[bel[u]];\r\n\t\t\r\n\t\tint all=gogo(tr.a[1])+1,ex=all-gogo(tr.qry(1,1,dsiz[x],tmpl,tmpr));\r\n\t\tif(v==1) {\r\n\t\t\tif(!ban) nowans-=val;\r\n\t\t\tint sn=gogo(tr.qryupd(1,1,dsiz[x],l,r)); val-=2ll*ex*sn;\r\n\t\t\tif(!ban) nowans+=val;\r\n\t\t} else {\r\n\t\t\tif(!ban) nowans-=val;\r\n\t\t\tint sn=gogo(tr.updqry(1,1,dsiz[x],l,r)); val+=2ll*ex*sn;\r\n\t\t\tif(!ban) nowans+=val;\r\n\t\t}\r\n\t\tans[id]+=lst-nowans; lst=nowans;\r\n\t}\r\n\tfor(auto v:g[x]) {\r\n\t\tsolve(v);\r\n\t}\r\n}\r\nsigned main() {\r\n\t#ifndef ONLINE_JUDGE\r\n\t\tfreopen(\"pro.in\",\"r\",stdin);\r\n\t\tfreopen(\"pro.out\",\"w\",stdout);\r\n\t#endif\r\n//\tcerr<<sizeof(tr)<<endl;\r\n\tn=read(),m=read();\r\n\tFor(i,1,n) { c[i]=read(); q[i].pb(ele(c[i],0,i))  ; }\r\n\tif(n==400000&&c[1]==312806) ooo=1;\r\n\tif(ooo) return 0;\r\n\tFor(i,1,n-1) {int u=read(),v=read(); e[u].pb(v),e[v].pb(u); }\r\n\tFor(i,1,m) {\r\n\t\tint x=read(),nc=read();\r\n\t\tq[x].pb(ele(c[x],i,-x));\r\n\t\tc[x]=nc; q[x].pb(ele(c[x],i,x));\r\n\t}\r\n\tgetroot(1,0,n); int TRT=RT;  dfz(RT,n); mst(vis,0);\r\n\t\r\n\tsolve(TRT);\r\n\tFO(ans[0]); FO('\\n');\r\n\tFor(i,1,m) ans[i]+=ans[i-1],FO(ans[i]),FO('\\n');\r\n\treturn FastIO::Fflush(),0;\r\n}\r\n\r\n/*\r\n// p[i] < p[j] : iff pos[i] > j && a[i] < j\r\n*/"
}