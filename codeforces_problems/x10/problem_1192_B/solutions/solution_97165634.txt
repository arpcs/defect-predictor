{
    "id": 97165634,
    "contestId": 1192,
    "creationTimeSeconds": 1604058977,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "B",
        "name": "Dynamic Diameter",
        "type": "PROGRAMMING",
        "tags": [
            "*special",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "mmaxio"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 102,
    "timeConsumedMillis": 1091,
    "memoryConsumedBytes": 35840000,
    "points": 100.0,
    "source": "import java.io.*;\r\nimport java.math.*;\r\nimport java.util.*;\r\nimport java.util.stream.*;\r\n\r\npublic class cfCEOI2019Day1B {\r\n\r\n\tstatic class HLD {\r\n\t\tint n, root;\r\n\r\n\t\tprivate int[][] g;\r\n\t\tprivate int[] sz;\r\n\t\tprivate int timePtr = 0;\r\n\r\n\t\t// parent of node, time -> time\r\n\t\tpublic int[] par;\r\n\r\n\t\t// tree traversal, time -> node\r\n\t\tint[] time2Node;\r\n\r\n\t\t// time when you get in/out of the node\r\n\t\t// Subtree of v has times [ v; rgh(v) )\r\n\t\tint[] node2Time; // node -> time\r\n\t\tint[] rgh; // time -> time\r\n\r\n\t\t// lft and order are inverse permutations\r\n\r\n\t\t// depth, time -> int\r\n\t\tint[] depth;\r\n\r\n\t\t// if chainInfo[v] < 0 then v is the head of chain with id =\r\n\t\t// (~chainInfo[v]), time->chainId\r\n\t\t// if chainInfo[v] >=0 then chainInfo[v] is the head of chain that v\r\n\t\t// belongs to, time->time\r\n\t\tprivate int[] chainInfo;\r\n\r\n\t\t// top-most node of the corresponding chain, chainId -> time\r\n\t\tint[] chainHead;\r\n\r\n\t\tint chainCnt = 0;\r\n\t\tprivate int[] buf;\r\n\r\n\t\tpublic HLD(int[] vs, int[] us, int root) {\r\n\t\t\tn = vs.length + 1;\r\n\t\t\tthis.root = root;\r\n\t\t\tif (vs.length != us.length) {\r\n\t\t\t\tthrow new AssertionError(\"vs.length != us.length\");\r\n\t\t\t}\r\n\t\t\tif (!(0 <= root && root < n)) {\r\n\t\t\t\tthrow new AssertionError(\"bad root\");\r\n\t\t\t}\r\n\r\n\t\t\t// Building the graph.\r\n\t\t\tint[] deg = new int[n];\r\n\t\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\t\tif (!(0 <= vs[i] && vs[i] < n && 0 <= us[i] && us[i] < n && vs[i] != us[i])) {\r\n\t\t\t\t\tthrow new AssertionError(\"bad node in edge\");\r\n\t\t\t\t}\r\n\t\t\t\tdeg[vs[i]]++;\r\n\t\t\t\tdeg[us[i]]++;\r\n\t\t\t}\r\n\t\t\tg = new int[n][];\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tg[i] = new int[deg[i]];\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\t\tint v = vs[i];\r\n\t\t\t\tint u = us[i];\r\n\t\t\t\tg[v][--deg[v]] = u;\r\n\t\t\t\tg[u][--deg[u]] = v;\r\n\t\t\t}\r\n\r\n\t\t\t// Find sizes/parents and reorder children.\r\n\t\t\tsz = new int[n];\r\n\t\t\tdfsSz(root, -1);\r\n\r\n\t\t\t// Find the chains/subtree ranges.\r\n\t\t\tpar = new int[n];\r\n\t\t\tpar[0] = -1;\r\n\t\t\t\r\n\t\t\tdepth = new int[n];\r\n\t\t\ttime2Node = new int[n];\r\n\t\t\tnode2Time = new int[n];\r\n\t\t\trgh = new int[n];\r\n\t\t\t\r\n\t\t\tchainHead = new int[n];\r\n\t\t\tchainHead[chainCnt] = 0;\r\n\t\t\t\r\n\t\t\tchainInfo = new int[n];\r\n\t\t\tchainInfo[0] = ~(chainCnt++);\r\n\t\t\t\r\n\t\t\tdfsChains(root, -1);\r\n\r\n\t\t\tchainHead = Arrays.copyOf(chainHead, chainCnt);\r\n\t\t\tbuf = new int[3 * chainCnt];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @return list of triplets [chainId; pos1; pos2] in order corresponding\r\n\t\t *         to the path from v to u <br>\r\n\t\t *         pos1 <= pos2 = going down <br>\r\n\t\t *         pos1 > pos2 = going up\r\n\t\t */\r\n\t\tpublic int[] getPath(int v, int u) {\r\n\t\t\tint headPtr = 0, tailPtr = buf.length;\r\n\t\t\tint chV = chainId(v), upV = chainHead[chV], chU = chainId(u), upU = chainHead[chU];\r\n\t\t\twhile (chV != chU) {\r\n\t\t\t\tif (depth[upV] > depth[upU]) {\r\n\t\t\t\t\tbuf[headPtr] = chV;\r\n\t\t\t\t\tbuf[headPtr + 1] = v - upV;\r\n\t\t\t\t\tbuf[headPtr + 2] = 0;\r\n\t\t\t\t\theadPtr += 3;\r\n\t\t\t\t\tv = par[upV];\r\n\t\t\t\t\tchV = chainId(v);\r\n\t\t\t\t\tupV = chainHead[chV];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuf[tailPtr - 3] = chU;\r\n\t\t\t\t\tbuf[tailPtr - 2] = 0;\r\n\t\t\t\t\tbuf[tailPtr - 1] = u - upU;\r\n\t\t\t\t\ttailPtr -= 3;\r\n\t\t\t\t\tu = par[upU];\r\n\t\t\t\t\tchU = chainId(u);\r\n\t\t\t\t\tupU = chainHead[chU];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint base = chainHead[chV];\r\n\t\t\tbuf[headPtr] = chV;\r\n\t\t\tbuf[headPtr + 1] = v - base;\r\n\t\t\tbuf[headPtr + 2] = u - base;\r\n\t\t\theadPtr += 3;\r\n\r\n\t\t\tSystem.arraycopy(buf, tailPtr, buf, headPtr, buf.length - tailPtr);\r\n\t\t\treturn Arrays.copyOf(buf, headPtr + buf.length - tailPtr);\r\n\t\t}\r\n\r\n\t\t// the length of chain #id\r\n\t\t// chainId -> int\r\n\t\tpublic int chainSz(int id) {\r\n\t\t\treturn (id == chainHead.length - 1 ? n : chainHead[id + 1]) - chainHead[id];\r\n\t\t}\r\n\r\n\t\t// the id of chain that node belongs to\r\n\t\t// time -> chainId\r\n\t\tpublic int chainId(int node) {\r\n\t\t\t// if node is not a chain's head, set node to the head\r\n\t\t\tif (chainInfo[node] >= 0) {\r\n\t\t\t\tnode = chainInfo[node];\r\n\t\t\t}\r\n\t\t\treturn ~chainInfo[node];\r\n\t\t}\r\n\r\n\t\t// the position of a node within its chain\r\n\t\t// time -> int\r\n\t\tpublic int chainPos(int t) {\r\n\t\t\tint x = chainInfo[t];\r\n\t\t\treturn x >= 0 ? t - x : 0;\r\n\t\t}\r\n\t\t\r\n\t\t// returns the NODE in the given chain at the given position\r\n\t\t// this is called getTime because you should only care\r\n\t\t// about \"times\" and not original node numbers\r\n\t\tpublic int getTime(int chainId, int chainPos) {\r\n\t\t\treturn chainHead[chainId] + chainPos;\r\n\t\t}\r\n\t\t\r\n\t\t// time -> boolean\r\n\t\tpublic boolean isLeaf(int t) {\r\n\t\t\treturn g[time2Node[t]].length == (t == 0 ? 0 : 1);\r\n\t\t}\r\n\r\n\t\tprivate void dfsSz(int v, int p) {\r\n\t\t\tsz[v] = 1;\r\n\t\t\tint[] adj = g[v];\r\n\t\t\tfor (int i = 0; i < adj.length; i++) {\r\n\t\t\t\tint u = adj[i];\r\n\t\t\t\tif (u == p) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tdfsSz(u, v);\r\n\t\t\t\tsz[v] += sz[u];\r\n\t\t\t\tif (adj[0] == p || sz[u] > sz[adj[0]]) {\r\n\t\t\t\t\tadj[i] = adj[0];\r\n\t\t\t\t\tadj[0] = u;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate void dfsChains(int v, int p) {\r\n\t\t\tint tv = timePtr++;\r\n\t\t\ttime2Node[tv] = v;\r\n\t\t\tnode2Time[v] = tv;\r\n\r\n\t\t\tint[] adj = g[v];\r\n\t\t\tfor (int i = 0; i < adj.length; i++) {\r\n\t\t\t\tint u = adj[i];\r\n\t\t\t\tif (u == p) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tpar[timePtr] = tv;\r\n\t\t\t\tdepth[timePtr] = depth[tv] + 1;\r\n\t\t\t\tif (i == 0) {\r\n\t\t\t\t\tchainInfo[timePtr] = chainInfo[tv] >= 0 ? chainInfo[tv] : tv;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchainHead[chainCnt] = timePtr;\r\n\t\t\t\t\tchainInfo[timePtr] = ~(chainCnt++);\r\n\t\t\t\t}\r\n\t\t\t\tdfsChains(u, v);\r\n\t\t\t}\r\n\r\n\t\t\trgh[tv] = timePtr;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid submit() {\r\n\t\tint n = nextInt();\r\n\t\tint q = nextInt();\r\n\t\tlong w = nextLong();\r\n\t\tint[] vs = new int[n - 1];\r\n\t\tint[] us = new int[n - 1];\r\n\t\tlong[] ws = new long[n - 1];\r\n\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\tvs[i] = nextInt() - 1;\r\n\t\t\tus[i] = nextInt() - 1;\r\n\t\t\tws[i] = nextLong();\r\n\t\t}\r\n\r\n\t\tHLD hld = new HLD(vs, us, 0);\r\n\t\t\r\n\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\tvs[i] = hld.node2Time[vs[i]];\r\n\t\t\tus[i] = hld.node2Time[us[i]];\r\n\t\t}\r\n\r\n\t\tint[] rgh = hld.rgh;\r\n\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\tif (vs[i] > us[i]) {\r\n\t\t\t\tint tmp = vs[i];\r\n\t\t\t\tvs[i] = us[i];\r\n\t\t\t\tus[i] = tmp;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tSegTree depths = new SegTree(n);\r\n\t\tfor (int i = 0; i < n - 1; i++) {\r\n\t\t\tdepths.addSegment(us[i], rgh[us[i]], ws[i]);\r\n\t\t}\r\n\r\n\t\tSegTree[] aux = new SegTree[hld.chainCnt];\r\n\t\tfor (int i = 0; i < aux.length; i++) {\r\n\t\t\taux[i] = new SegTree(hld.chainSz(i));\r\n\t\t}\r\n\r\n\t\tint[] chainHead = hld.chainHead;\r\n\t\tfor (int v = 0; v < n; v++) {\r\n\t\t\tif (hld.isLeaf(v)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint ch = hld.chainId(v);\r\n\t\t\tint pos = hld.chainPos(v);\r\n\t\t\tint head = chainHead[ch];\r\n\r\n\t\t\tlong maxExceptChain = depths.getSegment(rgh[v + 1], rgh[v]);\r\n\t\t\tif (maxExceptChain < 0) {\r\n\t\t\t\taux[ch].addPoint(pos, -INF);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\taux[ch].addPoint(pos, maxExceptChain + depths.getPoint(head) - 2 * depths.getPoint(v));\r\n\t\t}\r\n\r\n\t\tlong last = 0;\r\n\t\twhile (q-- > 0) {\r\n\t\t\tint edgeIdx = nextInt();\r\n\t\t\tlong newW = nextLong();\r\n\t\t\tedgeIdx = (int) ((edgeIdx + last) % (n - 1));\r\n\t\t\tnewW = (newW + last) % w;\r\n\r\n//\t\t\tSystem.err.println(edgeIdx + \" \" + newW);\r\n//\t\t\tSystem.err.println(\"old: \" + Arrays.toString(ws));\r\n\r\n\t\t\tlong oldW = ws[edgeIdx];\r\n\t\t\tlong deltaW = newW - oldW;\r\n\r\n\t\t\tws[edgeIdx] = newW;\r\n\r\n//\t\t\tSystem.err.println(\"new: \" + Arrays.toString(ws));\r\n\r\n\t\t\t// update edge weight\r\n\t\t\t{\r\n\t\t\t\tint v = us[edgeIdx];\r\n\t\t\t\tdepths.addSegment(v, rgh[v], deltaW);\r\n\r\n\t\t\t\t// update relative depth and maxRelExceptChain for nodes below v\r\n\t\t\t\t// on its chain\r\n\t\t\t\tint ch = hld.chainId(v);\r\n\t\t\t\tint pos = hld.chainPos(v);\r\n\t\t\t\tif (pos != 0) {\r\n\t\t\t\t\taux[ch].addSegment(pos, hld.chainSz(ch), -deltaW);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update maxRelExceptChain for last nodes on the chains\r\n\t\t\t\tint[] path = hld.getPath(v, 0);\r\n\t\t\t\tfor (int i = 3; i < path.length; i += 3) {\r\n\t\t\t\t\tint chainId = path[i];\r\n\t\t\t\t\tint headV = chainHead[chainId];\r\n\t\t\t\t\tint vPos = path[i + 1];\r\n\t\t\t\t\tv = hld.getTime(chainId, vPos);\r\n\t\t\t\t\tlong newVal = depths.getSegment(rgh[v + 1], rgh[v]) + depths.getPoint(headV) - 2\r\n\t\t\t\t\t\t\t* depths.getPoint(v);\r\n\r\n\t\t\t\t\taux[chainId].setPoint(vPos, newVal);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlong ans;\r\n\r\n\t\t\t// find diameter\r\n\t\t\t{\r\n\t\t\t\tint deepV = depths.maxPos();\r\n\t\t\t\tif (!hld.isLeaf(deepV)) {\r\n\t\t\t\t\tthrow new AssertionError(\"deepest node must be a leaf!\");\r\n\t\t\t\t}\r\n\t\t\t\tans = depths.getPoint(deepV);\r\n\t\t\t\tlong vDepth = ans;\r\n\r\n\t\t\t\tint[] path = hld.getPath(deepV, 0);\r\n\t\t\t\tfor (int i = 0; i < path.length; i += 3) {\r\n\t\t\t\t\tint chainId = path[i];\r\n\t\t\t\t\tint headV = chainHead[chainId];\r\n\t\t\t\t\t// not last node on a chain, use aux seg tree\r\n\t\t\t\t\tans = Math.max(\r\n\t\t\t\t\t\t\tans,\r\n\t\t\t\t\t\t\taux[chainId].getSegment(0, path[i + 1])\r\n\t\t\t\t\t\t\t\t\t+ (vDepth - depths.getPoint(headV)));\r\n\r\n\t\t\t\t\tif (i == 0) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// last node on a chain\r\n\t\t\t\t\tint lastNode = hld.getTime(chainId, path[i + 1]);\r\n\t\t\t\t\tint nxtNode = chainHead[path[i - 3]];\r\n\t\t\t\t\tlong deepOther = Math.max(depths.getSegment(lastNode, nxtNode),\r\n\t\t\t\t\t\t\tdepths.getSegment(rgh[nxtNode], rgh[lastNode]));\r\n\t\t\t\t\tans = Math.max(ans, deepOther + vDepth - 2 * depths.getPoint(lastNode));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tout.println(ans);\r\n\t\t\tlast = ans;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic final long INF = Long.MAX_VALUE / 3;\r\n\r\n\t// TODO: check with local parameters/without SegTree class at all?\r\n\tstatic class SegTree {\r\n\t\tNode root;\r\n\t\tint n;\r\n\r\n\t\tpublic SegTree(int n) {\r\n\t\t\troot = new Node(0, n);\r\n\t\t\tthis.n = n;\r\n\t\t}\r\n\r\n\t\tpublic void addSegment(int ql, int qr, long delta) {\r\n\t\t\tif (ql == qr) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (ql > qr) {\r\n\t\t\t\tthrow new AssertionError(\"ql > qr\");\r\n\t\t\t}\r\n\t\t\tNode.ql = ql;\r\n\t\t\tNode.qr = qr;\r\n\t\t\tNode.delta = delta;\r\n\t\t\troot.add(0, n);\r\n\t\t}\r\n\r\n\t\tpublic void addPoint(int idx, long delta) {\r\n\t\t\tNode.ql = idx;\r\n\t\t\tNode.delta = delta;\r\n\t\t\troot.addPoint(0, n);\r\n\t\t}\r\n\r\n\t\tpublic long getSegment(int ql, int qr) {\r\n\t\t\tif (ql == qr) {\r\n\t\t\t\treturn -INF;\r\n\t\t\t}\r\n\t\t\tif (ql > qr) {\r\n\t\t\t\tthrow new AssertionError(\"ql > qr\");\r\n\t\t\t}\r\n\t\t\tNode.ql = ql;\r\n\t\t\tNode.qr = qr;\r\n\t\t\treturn root.get(0, n);\r\n\t\t}\r\n\r\n\t\tpublic void setPoint(int idx, long val) {\r\n\t\t\tNode.ql = idx;\r\n\t\t\tNode.delta = val;\r\n\t\t\troot.setPoint(0, n);\r\n\t\t}\r\n\r\n\t\tpublic long getPoint(int idx) {\r\n\t\t\tNode.ql = idx;\r\n\t\t\treturn root.getPoint(0, n);\r\n\t\t}\r\n\r\n\t\tpublic int maxPos() {\r\n\t\t\treturn root.maxPos(0, n);\r\n\t\t}\r\n\r\n\t\tstatic class Node {\r\n\t\t\tstatic int ql, qr;\r\n\t\t\tstatic long delta;\r\n\t\t\t\r\n\t\t\tNode left, right;\r\n\t\t\tlong add, max;\r\n\r\n\t\t\tlong getMax() {\r\n\t\t\t\treturn max + add;\r\n\t\t\t}\r\n\r\n\t\t\tpublic Node(int l, int r) {\r\n\t\t\t\tif (r - l > 1) {\r\n\t\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\t\tleft = new Node(l, m);\r\n\t\t\t\t\tright = new Node(m, r);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvoid add(int l, int r) {\r\n\t\t\t\tif (l >= qr || ql >= r) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (ql <= l && r <= qr) {\r\n\t\t\t\t\tadd += delta;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\tleft.add(l, m);\r\n\t\t\t\tright.add(m, r);\r\n\t\t\t\tmax = Math.max(left.getMax(), right.getMax());\r\n\t\t\t}\r\n\r\n\t\t\tlong get(int l, int r) {\r\n\t\t\t\tif (l >= qr || ql >= r) {\r\n\t\t\t\t\treturn -INF;\r\n\t\t\t\t}\r\n\t\t\t\tif (ql <= l && r <= qr) {\r\n\t\t\t\t\treturn getMax();\r\n\t\t\t\t}\r\n\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\treturn Math.max(left.get(l, m), right.get(m, r)) + add;\r\n\t\t\t}\r\n\r\n\t\t\tint maxPos(int l, int r) {\r\n\t\t\t\tif (r - l == 1) {\r\n\t\t\t\t\treturn l;\r\n\t\t\t\t}\r\n\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\treturn left.getMax() > right.getMax() ? left.maxPos(l, m) : right.maxPos(m, r);\r\n\t\t\t}\r\n\r\n\t\t\tvoid setPoint(int l, int r) {\r\n\t\t\t\tif (r - l == 1) {\r\n\t\t\t\t\tadd = 0;\r\n\t\t\t\t\tmax = delta;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tleft.add += add;\r\n\t\t\t\tright.add += add;\r\n\t\t\t\tadd = 0;\r\n\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\tif (ql < m) {\r\n\t\t\t\t\tleft.setPoint(l, m);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tright.setPoint(m, r);\r\n\t\t\t\t}\r\n\t\t\t\tmax = Math.max(left.getMax(), right.getMax());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvoid addPoint(int l, int r) {\r\n\t\t\t\tif (r - l == 1) {\r\n\t\t\t\t\tadd += delta;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\tif (ql < m) {\r\n\t\t\t\t\tleft.addPoint(l, m);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tright.addPoint(m, r);\r\n\t\t\t\t}\r\n\t\t\t\tmax = Math.max(left.getMax(), right.getMax());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlong getPoint(int l, int r) {\r\n\t\t\t\tif (r - l == 1) {\r\n\t\t\t\t\treturn getMax();\r\n\t\t\t\t}\r\n\t\t\t\tint m = (l + r) >> 1;\r\n\t\t\t\treturn (ql < m ? left.getPoint(l, m) : right.getPoint(m, r)) + add;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid test() {\r\n\r\n\t}\r\n\r\n\tvoid stress() {\r\n\t\tfor (int tst = 0;; tst++) {\r\n\t\t\tif (false) {\r\n\t\t\t\tthrow new AssertionError();\r\n\t\t\t}\r\n\t\t\tSystem.err.println(tst);\r\n\t\t}\r\n\t}\r\n\r\n\tcfCEOI2019Day1B() throws IOException {\r\n\t\tif (System.getProperty(\"ONLINE_JUDGE\") == null) {\r\n\t\t\tis = new FileInputStream(\"in.txt\");\r\n\t\t} else {\r\n\t\t\tis = System.in;\r\n\t\t}\r\n\t\tout = new PrintWriter(System.out);\r\n\t\tsubmit();\r\n\t\t// stress();\r\n\t\t// test();\r\n\t\tout.close();\r\n\t}\r\n\r\n\tstatic final Random rng = new Random();\r\n\tstatic final int C = 5;\r\n\r\n\tstatic int rand(int l, int r) {\r\n\t\treturn l + rng.nextInt(r - l + 1);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tnew cfCEOI2019Day1B();\r\n\t}\r\n\r\n\tprivate InputStream is;\r\n\tPrintWriter out;\r\n\r\n\tprivate byte[] buf = new byte[1 << 14];\r\n\tprivate int bufSz = 0, bufPtr = 0;\r\n\r\n\tprivate int readByte() {\r\n\t\tif (bufSz == -1)\r\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\r\n\t\tif (bufPtr >= bufSz) {\r\n\t\t\tbufPtr = 0;\r\n\t\t\ttry {\r\n\t\t\t\tbufSz = is.read(buf);\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t}\r\n\t\t\tif (bufSz <= 0)\r\n\t\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn buf[bufPtr++];\r\n\t}\r\n\r\n\tprivate boolean isTrash(int c) {\r\n\t\treturn c < 33 || c > 126;\r\n\t}\r\n\r\n\tprivate int skip() {\r\n\t\tint b;\r\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\r\n\t\t\t;\r\n\t\treturn b;\r\n\t}\r\n\r\n\tString nextToken() {\r\n\t\tint b = skip();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\twhile (!isTrash(b)) {\r\n\t\t\tsb.appendCodePoint(b);\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tString nextString() {\r\n\t\tint b = readByte();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\twhile (!isTrash(b) || b == ' ') {\r\n\t\t\tsb.appendCodePoint(b);\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tdouble nextDouble() {\r\n\t\treturn Double.parseDouble(nextToken());\r\n\t}\r\n\r\n\tchar nextChar() {\r\n\t\treturn (char) skip();\r\n\t}\r\n\r\n\tint nextInt() {\r\n\t\tint ret = 0;\r\n\t\tint b = skip();\r\n\t\tif (b != '-' && (b < '0' || b > '9')) {\r\n\t\t\tthrow new InputMismatchException();\r\n\t\t}\r\n\t\tboolean neg = false;\r\n\t\tif (b == '-') {\r\n\t\t\tneg = true;\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\twhile (true) {\r\n\t\t\tif (b >= '0' && b <= '9') {\r\n\t\t\t\tret = ret * 10 + (b - '0');\r\n\t\t\t} else {\r\n\t\t\t\tif (b != -1 && !isTrash(b)) {\r\n\t\t\t\t\tthrow new InputMismatchException();\r\n\t\t\t\t}\r\n\t\t\t\treturn neg ? -ret : ret;\r\n\t\t\t}\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t}\r\n\r\n\tlong nextLong() {\r\n\t\tlong ret = 0;\r\n\t\tint b = skip();\r\n\t\tif (b != '-' && (b < '0' || b > '9')) {\r\n\t\t\tthrow new InputMismatchException();\r\n\t\t}\r\n\t\tboolean neg = false;\r\n\t\tif (b == '-') {\r\n\t\t\tneg = true;\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t\twhile (true) {\r\n\t\t\tif (b >= '0' && b <= '9') {\r\n\t\t\t\tret = ret * 10 + (b - '0');\r\n\t\t\t} else {\r\n\t\t\t\tif (b != -1 && !isTrash(b)) {\r\n\t\t\t\t\tthrow new InputMismatchException();\r\n\t\t\t\t}\r\n\t\t\t\treturn neg ? -ret : ret;\r\n\t\t\t}\r\n\t\t\tb = readByte();\r\n\t\t}\r\n\t}\r\n}"
}