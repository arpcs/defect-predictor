{
    "id": 167515181,
    "contestId": 1192,
    "creationTimeSeconds": 1659962791,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "B",
        "name": "Dynamic Diameter",
        "type": "PROGRAMMING",
        "tags": [
            "*special",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Meteorshower_Y"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "points": 0.0,
    "source": "#include<iostream>\r\n#include<cstdio>\r\n#include<cmath>\r\n#define ls(i) (i<<1)\r\n#define rs(i) (i<<1|1)\r\nusing namespace std;\r\nnamespace fast_IO\r\n{\r\n    #define FAST_IO\r\n    #define IOSIZE 100000\r\n    typedef long long ll;\r\n    typedef double db;\r\n    typedef long double ldb;\r\n    typedef __int128_t i128;\r\n    char ibuf[IOSIZE], obuf[IOSIZE];\r\n    char *p1 = ibuf, *p2 = ibuf, *p3 = obuf;\r\n    #ifdef ONLINE_JUDGE\r\n        #define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))\r\n        #define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)\r\n    #endif//fread in OJ, stdio in local\r\n\r\n    #define isdigit(ch) (ch>47&&ch<58)\r\n    #define isspace(ch) (ch<33&&ch!=EOF)\r\n    \r\n    struct fast_IO_t {\r\n        ~fast_IO_t() {\r\n            fwrite(obuf, p3-obuf, 1, stdout);\r\n        }\r\n        bool flag = false;\r\n        operator bool() {\r\n            return flag;\r\n        }\r\n    }io;\r\n    \r\n    template<typename T> inline T read() {\r\n        T s = 0; int w = 1; char ch;\r\n        while(ch=getchar(), !isdigit(ch)&&(ch!=EOF))\r\n            if(ch == '-') w = -1;\r\n        if(ch == EOF) return 0;\r\n        while(isdigit(ch))\r\n            s = s*10+ch-48, ch=getchar();\r\n        if(ch == '.') {\r\n            ll flt = 0; int cnt = 0;\r\n            while(ch=getchar(), isdigit(ch))\r\n                if(cnt < 18) flt=flt*10+ch-48, cnt++;\r\n            s += (db)flt/pow(10,cnt);\r\n        }\r\n        return s *= w;\r\n    }\r\n    template<typename T> inline bool read(T &s) {\r\n        s = 0; int w = 1; char ch;\r\n        while(ch=getchar(), !isdigit(ch)&&(ch!=EOF))\r\n            if(ch == '-') w = -1;\r\n        if(ch == EOF) return false;\r\n        while(isdigit(ch))\r\n            s = s*10+ch-48, ch=getchar();\r\n        if(ch == '.') {\r\n            ll flt = 0; int cnt = 0;\r\n            while(ch=getchar(), isdigit(ch))\r\n                if(cnt < 18) flt=flt*10+ch-48, cnt++;\r\n            s += (db)flt/pow(10,cnt);\r\n        }\r\n        return s *= w, true;\r\n    }\r\n    inline bool read(char &s) {\r\n        while(s = getchar(), isspace(s));\r\n        return s != EOF;\r\n    }\r\n    inline bool read(char *s) {\r\n        char ch;\r\n        while(ch=getchar(), isspace(ch));\r\n        if(ch == EOF) return false;\r\n        while(!isspace(ch))\r\n            *s++ = ch, ch=getchar();\r\n        *s = '\\000';\r\n        return true;\r\n    } \r\n    template<typename T> void print(T x) {\r\n        static int t[20]; int top = 0;\r\n        if(x < 0) putchar('-'), x = -x;\r\n        do { t[++top] = x%10; x /= 10; } while(x);\r\n        while(top) putchar(t[top--]+48);\r\n    }\r\n    struct empty_type{}; int pcs = 8;\r\n    empty_type setpcs(int cnt) {\r\n        return pcs = cnt, empty_type();\r\n    }\r\n    inline void print(empty_type x){}\r\n    inline void print(double x) {\r\n        if(x < 0) putchar('-'), x = -x;\r\n        x += 5.0 / pow(10,pcs+1);\r\n        print((ll)(x)); x -= (ll)(x);\r\n        if(pcs != 0) putchar('.');\r\n        for(int i = 1; i <= pcs; i++)\r\n        x *= 10, putchar((int)x+'0'), x -= (int)x;\r\n    }\r\n    inline void print(float x) {\r\n        if(x < 0) putchar('-'), x = -x;\r\n        x += 5.0 / pow(10,pcs+1);\r\n        print((ll)(x)); x -= (ll)(x);\r\n        if(pcs != 0) putchar('.');\r\n        for(int i = 1; i <= pcs; i++)\r\n        x *= 10, putchar((int)x+'0'), x -= (int)x;\r\n    }\r\n    inline void print(long double x) {\r\n        if(x < 0) putchar('-'), x = -x;\r\n        x += 5.0 / pow(10,pcs+1);\r\n        print((i128)(x)); x -= (i128)(x);\r\n        if(pcs != 0) putchar('.');\r\n        for(int i = 1; i <= pcs; i++)\r\n        x *= 10, putchar((int)x+'0'), x -= (int)x;\r\n    }\r\n    inline void print(char x) {\r\n        putchar(x);\r\n    }\r\n    inline void print(char *x) {\r\n        for(int i = 0; x[i]; i++)\r\n            putchar(x[i]);\r\n    }\r\n    inline void print(const char *x) {\r\n        for(int i = 0; x[i]; i++)\r\n            putchar(x[i]);\r\n    }\r\n    #ifdef _GLIBCXX_STRING//string\r\n        inline bool read(std::string& s) {\r\n            s = \"\"; char ch;\r\n            while(ch=getchar(), isspace(ch));\r\n            if(ch == EOF) return false;\r\n            while(!isspace(ch))\r\n                s += ch, ch = getchar();\r\n            return true;\r\n        }\r\n        inline void print(std::string x) {\r\n            for(string::iterator i = x.begin(); i != x.end(); i++)\r\n                putchar(*i);\r\n        }\r\n        inline bool getline(fast_IO_t &io, string s) {\r\n            s = \"\"; char ch = getchar();\r\n            if(ch == EOF) return false;\r\n            while(ch != '\\n' and ch != EOF)\r\n                s += ch, ch = getchar();\r\n            return true;\r\n        }\r\n    #endif\r\n    #if __cplusplus >= 201103L\r\n        template<typename T, typename... T1>\r\n        inline int read(T& a, T1& ...other) {\r\n            return read(a)+read(other...);\r\n        }\r\n        template<typename T, typename... T1>\r\n        inline void print(T a, T1... other) {\r\n            print(a); print(other...);\r\n        }\r\n    #endif\r\n    template<typename T>\r\n    fast_IO_t& operator >> (fast_IO_t &io, T &b) {\r\n        return io.flag=read(b), io;\r\n    }\r\n    fast_IO_t& operator >> (fast_IO_t &io, char *b) {\r\n        return io.flag=read(b), io;\r\n    }\r\n    template<typename T>\r\n    fast_IO_t& operator << (fast_IO_t &io, T b) {\r\n        return print(b), io;\r\n    }\r\n    #define cout io\r\n    #define cin io\r\n    #define endl '\\n'\r\n}\r\nusing namespace fast_IO;\r\nconst int MAXN = 1e5+10;\r\n#define long long long\r\nstruct tree1{int l, r, u, v; long val;} dr[MAXN<<2];  // Built on dfs-order\r\nstruct tree2{int l, r; long val;} tr[MAXN<<2];        // Build on tree\r\nstruct edge1{int to, next;} a[MAXN<<1];\r\nint n, q, head[MAXN], cnt, tim;\r\nint f[MAXN], siz[MAXN], son[MAXN];\r\nint id[MAXN], top[MAXN], dep[MAXN];\r\nint u[MAXN], v[MAXN], d[MAXN], beg[MAXN], end[MAXN], ct;\r\nlong w, lst, c[MAXN], E;\r\nauto add_edge(int from, int to) -> void;\r\nauto dfs1(int x, int fa) -> void;\r\nauto dfs2(int x, int tp) -> void;\r\nauto dfsx(int x) -> void;\r\nauto build_1(int l, int r, int i) -> void;\r\nauto build_2(int l, int r, int i) -> void;\r\nauto change_1(int l, int r, int i) -> void;\r\nauto change_2(int x, long k, int i) -> void;\r\nauto query_2(int l, int r, int i) -> long;\r\nauto calc(int x, int y) -> long;\r\nauto LCA(int x, int y) -> int;\r\nauto pushup(int i) -> void;\r\nauto qlink(int x) -> long;\r\nauto main() -> signed\r\n{\r\n    read(n, q, w);\r\n    for(int i = 1; i < n; i += 1)\r\n    {\r\n        read(u[i], v[i], c[i]);\r\n        add_edge(u[i], v[i]);\r\n        add_edge(v[i], u[i]);\r\n    }\r\n    dfs1(1, 0); dfs2(1, 1);\r\n    build_2(1, n, 1);\r\n    for(int i = 1; i < n; i += 1)\r\n    {\r\n        if(dep[u[i]] > dep[v[i]]) change_2(id[u[i]], c[i], 1);\r\n        else change_2(id[v[i]], c[i], 1);\r\n    }\r\n    dfsx(1); \r\n    build_1(1, n, 1);\r\n    for(int i = 1, D; i <= q; i += 1)\r\n    {\r\n        read(D, E);\r\n        D = (D+lst)%(n-1)+1;\r\n        E = (E+lst)%w;\r\n        if(dep[u[D]] > dep[v[D]])  \r\n        {\r\n            change_2(id[u[D]], E, 1);\r\n            change_1(beg[u[D]], ::end[u[D]], 1);\r\n        }\r\n        else \r\n        {\r\n            change_2(id[v[D]], E, 1);\r\n            change_1(beg[v[D]], ::end[v[D]], 1);\r\n        }\r\n        lst = dr[1].val;\r\n        print(lst, '\\n');\r\n    }\r\n    return 0;\r\n}\r\nauto add_edge(int from, int to) -> void\r\n{\r\n    cnt += 1;\r\n    a[cnt].to = to;\r\n    a[cnt].next = head[from];\r\n    head[from] = cnt;\r\n}\r\nauto dfs1(int x, int fa) -> void\r\n{\r\n    f[x] = fa; siz[x] = 1;\r\n    int maxson = 0, y;\r\n    for(int i = head[x]; i; i = a[i].next)\r\n    {\r\n        y = a[i].to; if(y == fa) continue;\r\n        dfs1(y, x); siz[x] += siz[y];\r\n        if(siz[y] > siz[maxson]) maxson = y;\r\n    }\r\n    son[x] = maxson;\r\n}\r\nauto dfs2(int x, int tp) -> void\r\n{\r\n    id[x] = ++tim; top[x] = tp;\r\n    dep[x] = dep[f[x]]+1; int y;\r\n    if(son[x]) dfs2(son[x], tp);\r\n    for(int i = head[x]; i; i = a[i].next)\r\n    {\r\n        y = a[i].to;\r\n        if(y == f[x] or y == son[x]) continue;\r\n        dfs2(y, y);\r\n    }\r\n}\r\nauto dfsx(int x) -> void\r\n{\r\n    d[++ct] = x;\r\n    beg[x] = ct;\r\n    for(int i = head[x], y; i; i = a[i].next)\r\n    {\r\n        y = a[i].to; if(y == f[x]) continue;\r\n        dfsx(y);\r\n    }\r\n    ::end[x] = ct;\r\n}\r\nauto build_1(int l, int r, int i) -> void\r\n{\r\n    dr[i].l = l;\r\n    dr[i].r = r;\r\n    if(l == r) return (void)(dr[i].u = dr[i].v = d[l]);\r\n    int mid = (l+r)>>1;\r\n    build_1(l, mid, ls(i));\r\n    build_1(mid+1, r, rs(i));\r\n    pushup(i);\r\n}\r\nauto build_2(int l, int r, int i) -> void\r\n{\r\n    tr[i].l = l;\r\n    tr[i].r = r;\r\n    if(l == r) return ;\r\n    int mid = (l+r)>>1;\r\n    build_2(l, mid, ls(i));\r\n    build_2(mid+1, r, rs(i));\r\n}\r\nauto change_1(int l, int r, int i) -> void\r\n{\r\n    if(dr[i].l > r or dr[i].r < l) return ;\r\n    if(dr[i].l >= l and dr[i].r <= r) return ;\r\n    change_1(l, r, ls(i));\r\n    change_1(l, r, rs(i));\r\n    pushup(i);\r\n}\r\nauto change_2(int x, long k, int i) -> void\r\n{\r\n    if(tr[i].l > x or tr[i].r < x) return ;\r\n    if(tr[i].l == x and tr[i].r == x) return (void)(tr[i].val = k);\r\n    change_2(x, k, ls(i));\r\n    change_2(x, k, rs(i));\r\n    tr[i].val = tr[ls(i)].val+tr[rs(i)].val;\r\n}\r\nauto query_2(int l, int r, int i) -> long\r\n{\r\n    if(tr[i].l > r or tr[i].r < l) return 0;\r\n    if(tr[i].l >= l and tr[i].r <= r) return tr[i].val;\r\n    return query_2(l, r, ls(i))+query_2(l, r, rs(i));\r\n}\r\nauto LCA(int x, int y) -> int\r\n{\r\n    while(top[x] != top[y])\r\n    {\r\n        if(dep[top[x]] < dep[top[y]]) swap(x, y); \r\n        x = f[top[x]];\r\n    }\r\n    if(id[x] > id[y]) return y;\r\n    return x;\r\n}\r\nauto pushup(int i) -> void\r\n{\r\n    int ls = ls(i),    rs = rs(i);\r\n    int lu = dr[ls].u, lv = dr[ls].v;\r\n    int ru = dr[rs].u, rv = dr[rs].v;\r\n    if(dr[ls].val > dr[rs].val) dr[i].u = dr[ls].u, dr[i].v = dr[ls].v, dr[i].val = dr[ls].val; \r\n    else dr[i].u = dr[rs].u, dr[i].v = dr[rs].v, dr[i].val = dr[rs].val; \r\n    int u = lu, v = ru; long len = calc(u, v), len2;\r\n    len2 = calc(lu, rv); if(len2 > len) u = lu, v = rv, len = len2;\r\n    len2 = calc(lv, ru); if(len2 > len) u = lv, v = ru, len = len2;\r\n    len2 = calc(lv, rv); if(len2 > len) u = lv, v = rv, len = len2;\r\n    if(len > dr[i].val) dr[i].val = len, dr[i].u = u, dr[i].v = v;\r\n}\r\nauto calc(int x, int y) -> long\r\n{\r\n    int lca = LCA(x, y);\r\n    return qlink(x)+qlink(y)-2*qlink(lca);\r\n}\r\nauto qlink(int x) -> long\r\n{\r\n    long ans = 0;\r\n    while(x)\r\n    {\r\n        ans += query_2(id[top[x]], id[x], 1);\r\n        x = f[top[x]];\r\n    }\r\n    return ans;\r\n}"
}