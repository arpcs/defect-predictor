{
    "id": 144334067,
    "contestId": 1192,
    "creationTimeSeconds": 1643381364,
    "relativeTimeSeconds": 17364,
    "problem": {
        "contestId": 1192,
        "index": "B",
        "name": "Dynamic Diameter",
        "type": "PROGRAMMING",
        "tags": [
            "*special",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "michao"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1643364000
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "PARTIAL",
    "testset": "TESTS",
    "passedTestCount": 74,
    "timeConsumedMillis": 6000,
    "memoryConsumedBytes": 63897600,
    "points": 55.0,
    "source": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define mp make_pair\r\n#define pb push_back\r\n#define ld long double\r\n#define pii pair<int,int>\r\n#define sz(x) (int)x.size()\r\n#define piii pair<pii,pii>\r\n#define precise cout<<fixed<<setprecision(10)\r\n#define st first\r\n#define nd second\r\n#define ins insert\r\n#define vi vector<int>\r\n#define BOOST ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\r\nusing namespace std;\r\nconst int MAX=1<<17;\r\nbool czystar=true,czybalanced=true,czymalen=true;\r\nint from[MAX],to[MAX],cost[MAX];\r\nvector<pii>P[MAX];\r\nint n,q,w;\r\nint dist[MAX];\r\nvoid star(){\r\n\tmultiset<int>ws;\r\n\tfor (int i=1;i<=n-1;i++){\r\n\t\tws.ins(cost[i]);\r\n\t}\r\n\tint last=0;\r\n\tfor (int z=0;z<q;z++){\r\n\t  int d,e;\r\n\t  cin>>d>>e;\r\n\t\td=(last+d)%(n-1)+1;\r\n\t\te=(last+e)%w;\r\n\t\tws.erase(ws.find(cost[d]));\r\n\t\tcost[d]=e;\r\n\t\tws.ins(cost[d]);\r\n\t\tint ans=*ws.rbegin();\r\n\t\tif (sz(ws)>1)ans+=*(++ws.rbegin());\r\n\t\tcout<<ans<<\"\\n\";\r\n\t\tlast=ans;\r\n\t}\r\n}\t\r\n\r\nvoid dfs(int u,int fa){\r\n\tfor (auto it:P[u]){\r\n\t\tif (it.st==fa)continue;\r\n\t\tdist[it.st]=dist[u]+cost[it.nd];\r\n\t\tdfs(it.st,u);\r\n\t}\r\n}\r\n\r\nvoid brut(){\r\n  int last=0;\r\n\tfor (int z=0;z<q;z++){\r\n\t\tint d,e;\r\n\t\tcin>>d>>e;\r\n\t\td=(last+d)%(n-1)+1;\r\n\t\te=(last+e)%w;\r\n\t\tcost[d]=e;\r\n\t\tfor (int i=1;i<=n;i++)dist[i]=0;\r\n\t\tdist[1]=0;\r\n\t\tdfs(1,-1);\r\n\t\tint maxi=0,wsk=0;\r\n\t\tfor (int i=1;i<=n;i++){\r\n\t\t\tif (dist[i]>=maxi)maxi=dist[i],wsk=i;\r\n\t\t}\r\n\t\tfor (int i=1;i<=n;i++)dist[i]=0;\r\n\t  dfs(wsk,-1);\r\n\t  maxi=0;\r\n\t  for (int i=1;i<=n;i++){\r\n\t\t\tmaxi=max(maxi,dist[i]);\r\n\t  }\r\n\t  int ans=maxi;\r\n\t  cout<<ans<<\"\\n\";\r\n\t  last=ans;\r\n\t}\r\n}\r\nconst int STALA=18;\r\nint pre[MAX];\r\nint czas=1;\r\nint sub[MAX];\r\nint A[MAX][STALA];\r\nint edge[MAX];\r\nint gle[MAX];\r\nconst int inf=(int)1e18+9;\r\nint LAZY[MAX*4],MAXI[MAX*4];\r\n \r\nvoid push(int u){\r\n  LAZY[2*u]+=LAZY[u];\r\n  LAZY[2*u+1]+=LAZY[u];\r\n  MAXI[u]+=LAZY[u];\r\n  LAZY[u]=0;\r\n}\r\n \r\nvoid update(int a,int b,int u,int lo,int hi,int c){\r\n  if (b<lo || a>hi)return;\r\n  if (a<=lo && b>=hi){\r\n    LAZY[u]+=c;\r\n    return;\r\n  }\r\n  int mid=(lo+hi)>>1;\r\n  update(a,b,2*u,lo,mid,c);\r\n  update(a,b,2*u+1,mid+1,hi,c);\r\n  MAXI[u]=max(MAXI[2*u]+LAZY[2*u],MAXI[2*u+1]+LAZY[2*u+1]);\r\n}\r\n \r\nint getmax(int a,int b,int u,int lo,int hi){\r\n  if (b<lo || a>hi)return -inf;\r\n  push(u);\r\n  if (a<=lo && b>=hi)\r\n    return MAXI[u];\r\n  int mid=(lo+hi)>>1;\r\n  int L=getmax(a,b,2*u,lo,mid);\r\n  int R=getmax(a,b,2*u+1,mid+1,hi);\r\n  return max(L,R);\r\n}\r\n\r\nint jump(int x,int ile){\r\n\tfor (int i=STALA-1;i>=0;i--){\r\n\t\tif (ile-(1<<i)>=0)ile-=(1<<i),x=A[x][i];\r\n\t}\r\n\treturn x;\r\n}\r\n\r\nint tab[MAX];\r\n\r\nvoid dfs2(int u,int fa,int kr){\r\n  pre[u]=czas++;\r\n  A[u][0]=fa;\r\n  edge[u]=kr;\r\n  sub[u]++;\r\n\tfor (auto it:P[u]){\r\n\t\tif (it.st==fa)continue;\r\n\t\tgle[it.st]=gle[u]+1;\r\n\t\tdist[it.st]=dist[u]+cost[it.nd];\r\n\t\tdfs2(it.st,u,it.nd);\r\n\t\tsub[u]+=sub[it.st];\r\n\t}\r\n}\t\r\nset<int>checker;\r\nmultiset<int>odl[MAX];\r\nmultiset<int>ogol;\r\n\r\nint func(int u){\r\n\tif (odl[u].empty())return 0;\r\n\tint ans=0;\r\n\tans+=*odl[u].rbegin();\r\n\tif (sz(odl[u])>1)ans+=*(++odl[u].rbegin());\r\n\treturn ans;\r\n}\r\n\r\nvoid balanced(){\r\n  while(true){\r\n\t\tchecker.ins(1);\r\n  }\r\n\tdfs2(1,1,-1);\r\n\tint last=0;\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tupdate(pre[i],pre[i],1,1,MAX,dist[i]);\r\n\t}\r\n\tfor (int i=1;i<STALA;i++){\r\n\t\tfor (int j=1;j<=n;j++){\r\n\t\t\tA[j][i]=A[A[j][i-1]][i-1];\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tfor (auto it:P[i]){\r\n\t\t\tif (it.st<i)continue;\r\n\t\t\todl[i].ins(getmax(pre[it.st],pre[it.st]+sub[it.st]-1,1,1,MAX)-getmax(pre[i],pre[i],1,1,MAX));\r\n\t\t}\r\n\t\togol.ins(func(i));\r\n\t}\r\n\tfor (int z=0;z<q;z++){\r\n\t  int d,e;\r\n\t  cin>>d>>e;\r\n\t\td=(last+d)%(n-1)+1;\r\n\t\te=(last+e)%w;\r\n\t  int diff=e-cost[d];\r\n\t  int u=from[d],v=to[d];\r\n\t  if (gle[u]>gle[v])swap(u,v);\r\n\t  \r\n\t  int i=u,it=v;\r\n\t  while (i){\r\n\t\t  ogol.erase(ogol.find(func(i)));\r\n\t\t  odl[i].erase(odl[i].find(getmax(pre[it],pre[it]+sub[it]-1,1,1,MAX)-getmax(pre[i],pre[i],1,1,MAX)));\r\n\t\t\ti/=2;\r\n\t\t\tit/=2;\r\n\t  }\r\n\t  update(pre[v],pre[v]+sub[v]-1,1,1,MAX,diff);\r\n\t  i=u,it=v;\r\n\t\twhile (i){\r\n\t\t  ogol.ins(func(i));\r\n\t\t  odl[i].ins(getmax(pre[it],pre[it]+sub[i]-1,1,1,MAX)-getmax(i,i,1,1,MAX));\r\n\t\t\ti/=2;\r\n\t\t\tit/=2;\r\n\t  }\r\n\t  int ans=*ogol.rbegin();\r\n\t  cost[d]=e;\r\n\t  last=ans;\r\n\t  cout<<ans<<\"\\n\";\r\n\t}\r\n}\r\n\r\nvoid goesthrough1(){\r\n\tdfs2(1,1,-1);\r\n\tmultiset<int>vals;\r\n\tvals.clear();\r\n\tint last=0;\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tupdate(pre[i],pre[i],1,1,MAX,dist[i]);\r\n\t}\r\n\tfor (int i=1;i<STALA;i++){\r\n\t\tfor (int j=1;j<=n;j++){\r\n\t\t\tA[j][i]=A[A[j][i-1]][i-1];\r\n\t\t}\r\n\t}\r\n\tfor (auto it:P[1]){\r\n\t  int rak=getmax(pre[it.st],pre[it.st]+sub[it.st]-1,1,1,MAX);\r\n\t\tvals.ins(rak);\r\n\t\tchecker.ins(it.st);\r\n\t\ttab[it.st]=rak;\r\n\t}\r\n\tassert(sub[1]==n);\r\n\t\r\n\tfor (int z=0;z<q;z++){\r\n\t  int d,e;\r\n\t  cin>>d>>e;\r\n\t\td=(last+d)%(n-1)+1;\r\n\t\te=(last+e)%w;\r\n\t  int diff=e-cost[d];\r\n\t  int u=from[d],v=to[d];\r\n\t  if (gle[u]>gle[v])swap(u,v);\r\n\t  update(pre[v],pre[v]+sub[v]-1,1,1,MAX,diff);\r\n\t  int wier=jump(v,gle[v]-1);\r\n\t  vals.erase(vals.find(tab[wier]));\r\n\t  int rak=getmax(pre[wier],pre[wier]+sub[wier]-1,1,1,MAX);\r\n\t  vals.ins(rak);\r\n\t  assert(sz(vals));\r\n\t  int ans=*vals.rbegin();\r\n\t  if (sz(vals)>=2)ans+=*(++vals.rbegin());\r\n\t  assert(checker.find(wier)!=checker.end());\r\n\t\tcost[d]=e;\r\n\t\ttab[wier]=rak;\r\n\t\tlast=ans;\r\n\t\tcout<<ans<<\"\\n\";\r\n\t}\r\n}\r\n\r\nint32_t main(){\r\n  BOOST;\r\n  cin>>n>>q>>w;\r\n  if (n>5000 || q>5000)czymalen=false;\r\n  for (int i=1;i<=n-1;i++){\r\n\t\tint a,b,c;\r\n\t\tcin>>a>>b>>c;\r\n\t\tif (a>b)swap(a,b);\r\n\t\tif (a!=1)czystar=false;\r\n\t\tif (b!=2*a && b!=2*a+1)czybalanced=false;\r\n\t\tfrom[i]=a;\r\n\t\tto[i]=b;\r\n\t\tcost[i]=c;\r\n\t\tP[a].pb(mp(b,i));\r\n\t\tP[b].pb(mp(a,i));\r\n  }\r\n  //czymalen=false;\r\n  if (czymalen){\r\n\t\tbrut();\r\n\t\treturn 0;\r\n  }\r\n  if (czystar){\r\n\t\tstar();\r\n\t\treturn 0;\r\n  }\r\n  \r\n  if (czybalanced){\r\n\t\tbalanced();\r\n  }\t\r\n\t//cout<<\"XD\\n\";\r\n\tgoesthrough1();\r\n  \r\n  return 0; \r\n}\r\n\r\n"
}