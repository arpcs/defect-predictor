{
    "id": 231486630,
    "contestId": 1348,
    "creationTimeSeconds": 1699200302,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1348,
        "index": "F",
        "name": "Phoenix and Memory",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2600,
        "tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1348,
        "members": [
            {
                "handle": "ytkn"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1588343700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 109,
    "timeConsumedMillis": 202,
    "memoryConsumedBytes": 18636800,
    "source": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <tuple>\n#include <cmath>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\nconstexpr int bsf_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) const {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) const {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() const { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) const {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) const {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#define debug_value(x) cerr << \"line\" << __LINE__ << \":<\" << __func__ << \">:\" << #x << \"=\" << x << endl;\n#define debug(x) cerr << \"line\" << __LINE__ << \":<\" << __func__ << \">:\" << x << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\nvector<vector<T>> vec2d(int n, int m, T v){\n    return vector<vector<T>>(n, vector<T>(m, v));\n}\n\ntemplate<typename T>\nvector<vector<vector<T>>> vec3d(int n, int m, int k, T v){\n    return vector<vector<vector<T>>>(n, vector<vector<T>>(m, vector<T>(k, v)));\n}\n\ntemplate<typename T>\nvoid print_vector(vector<T> v, char delimiter=' '){\n    if(v.empty()) {\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i+1 < v.size(); i++) cout << v[i] << delimiter;\n    cout << v.back() << endl;\n}\n\nusing P = pair<int, int>;\n\nvector<int> make_inv(vector<int> p){\n    int n = p.size();\n    vector<int> ans(n);\n    for(int i = 0; i < n; i++){\n        ans[p[i]] = i;\n    }\n    return ans;\n}\n\nint e(){\n    return 1e9;\n}\n\nint op(int x, int y){\n    return min(x, y);\n}\n\nusing Seg = atcoder::segtree<int, op, e>;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int n; cin >> n;\n    vector<int> a(n), b(n);\n    vector<vector<P>> r(n);\n    for(int i = 0; i < n; i++){\n        cin >> a[i] >> b[i]; a[i]--; b[i]--;\n        r[a[i]].push_back({b[i], i});\n    }\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> indices(n);\n    for(int l = 0; l < n; l++){\n        for(auto p: r[l]) que.push(p);\n        auto [x, i] = que.top(); que.pop();\n        indices[l] = i;\n    }\n    vector<int> margin(n);\n    Seg seg(margin);\n    for(int i = 0; i < n; i++){\n        margin[i] = b[indices[i]]-i;\n    }\n    auto pos = make_inv(indices);\n    // \u3082\u3046\u4e00\u3064\u4f5c\u308c\u308b\u304b\u3092\u691c\u8a3c\n    for(int l = 0; l < n; l++){\n        for(auto p: r[l]) que.push(p);\n        if(que.size() == 1){\n            que.pop();\n            continue;\n        }\n        auto [x, i] = que.top(); que.pop();\n        auto [y, j] = que.top(); que.pop();\n        bool ok = false;\n        if(pos[j] <= x){\n            ok = true;\n        }else{\n            if(seg.prod(x, pos[j]) >= 1) ok = true;\n        }\n        if(x == l) ok = false;\n        if(!ok) {\n            que.push({y, j});\n            continue;\n        }\n        auto indices1 = indices;\n        indices1[l] = j;\n        que.push({x, i});\n        for(int l0 = l+1; l0 < n; l0++){\n            for(auto p: r[l0]) que.push(p);\n            auto [x, i] = que.top(); que.pop();\n            indices1[l0] = i;\n            assert(b[i] >= l0);\n        }\n        cout << \"NO\" << endl;\n        for(int x: make_inv(indices)) cout << x+1 << ' ';\n        cout << endl;\n        for(int x: make_inv(indices1)) cout << x+1 << ' ';\n        cout << endl;    \n        return 0;\n    }\n    cout << \"YES\" << endl;\n    for(int x: make_inv(indices)) cout << x+1 << ' ';\n    cout << endl;\n}"
}