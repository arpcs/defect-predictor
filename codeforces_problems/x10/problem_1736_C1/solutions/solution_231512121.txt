{
    "id": 231512121,
    "contestId": 1736,
    "creationTimeSeconds": 1699215063,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1736,
        "index": "C1",
        "name": "Good Subarrays (Easy Version)",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1300,
        "tags": [
            "binary search",
            "data structures",
            "schedules",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1736,
        "members": [
            {
                "handle": "ash_79"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1665412500
    },
    "programmingLanguage": "Java 11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 186,
    "memoryConsumedBytes": 0,
    "source": "import java.util.*;\r\nimport java.io.*;\r\nimport static java.lang.Math.*;\r\n\r\n\r\npublic class Main{\r\n  static class Pair{\r\n    long key,value;\r\n    \r\n    public Pair(long k,long v){\r\n      this.key = k;\r\n      this.value = v;\r\n    }\r\n    \r\n  }\r\n    public static void main(String args[]) throws IOException{\r\n        FastReader sc=new FastReader();\r\n        PrintWriter pw = new PrintWriter(System.out);\r\n        int testcase=sc.nextInt();\r\n        for(int tc=1;tc<=testcase;tc++){\r\n          //pw.print(\"Case #\"+tc+\": \");\r\n          int n = sc.nextInt();\r\n          int a[] = new int[n];\r\n          for(int i=0;i<n;i++)\r\n            a[i] = sc.nextInt();\r\n          int s = 1;\r\n          long ans = 0;\r\n          for(int i=0;i<n;i++){\r\n            if(a[i] >= s)\r\n              s++;\r\n            else{\r\n              long x = s - a[i];\r\n              ans += (long)(x*(x+1))/2;\r\n              ans += (long)x*(s-1-x);\r\n              s = a[i]+1;\r\n            }\r\n          }\r\n          ans += (long)(s*(s-1))/2;\r\n          pw.println(ans);\r\n        }\r\n        //System.out.flush();\r\n        pw.close();\r\n    }\r\n    static int bs(List<Integer> list, int x){\r\n      int i = 0, j = list.size()-1;\r\n      int ans = -1;\r\n      while(i <= j){\r\n        int mid = i + (j-i)/2;\r\n        if(list.get(mid) < x){\r\n          ans = mid;\r\n          i = mid+1;\r\n        }\r\n        else  \r\n          j = mid-1;\r\n      }\r\n      return ans;\r\n    }\r\n    // static long modPow(long base, int exp) {\r\n    //   long ans = 1;\r\n    //   while(exp > 0) {\r\n    //     if((exp & 1) == 1) {\r\n    //       ans = (ans * base) % MOD;\r\n    //     }\r\n    //     base = (base * base) % MOD;\r\n    //     exp >>= 1;\r\n    //   }\r\n    //   return ans;\r\n    // }\r\n    // static void permute(String str, int l, int r)\r\n    // {\r\n    //     if (l == r)\r\n    //         System.out.println(str);\r\n    //     else {\r\n    //         for (int i = l; i <= r; i++) {\r\n    //             str = swap(str, l, i);\r\n    //             permute(str, l + 1, r);\r\n    //             str = swap(str, l, i);\r\n    //         }\r\n    //     }\r\n    // }\r\n    static String swap(String a, int i, int j)\r\n    {\r\n        char temp;\r\n        char[] charArray = a.toCharArray();\r\n        temp = charArray[i];\r\n        charArray[i] = charArray[j];\r\n        charArray[j] = temp;\r\n        return String.valueOf(charArray);\r\n    }\r\n\r\n  //   static long myPow(long x, int pw)\r\n\t// {\r\n\t// \tlong res = 1;\r\n\t// \tfor(int i=0;i<pw;i++)\r\n\t// \t\tres=res*x;\r\n\t// \treturn res;\r\n\t// }\r\n    \r\n    static long lcm(long a, long b)\r\n    {\r\n        return (a / gcd(a, b)) * b;\r\n    }\r\n    static boolean subarraySum(int[] nums, int k) {\r\n      int sum = 0;\r\n      boolean result = false;\r\n      Map<Integer, Integer> preSum = new HashMap<>();\r\n      preSum.put(0, 1);\r\n      \r\n      for (int i = 0; i < nums.length; i++) {\r\n          sum += nums[i];\r\n          if (preSum.containsKey(sum - k)) {\r\n              result = true;\r\n              break;\r\n          }\r\n          preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);\r\n      }\r\n      \r\n      return result;\r\n  }\r\n    public static long nc2(long n){\r\n      if(n==1){\r\n        return 0;\r\n      }\r\n      n*=(n-1);\r\n      n/=2;\r\n      return n;\r\n    }\r\n    static boolean valid(int i, int j, int n){\r\n      return i>=0 && i<n && j>=0 && j<n;\r\n    }\r\n    static int sumDigits(int no)\r\n    {\r\n        return no == 0 ? 0 : no%10 +\r\n                  sumDigits(no/10) ;\r\n    }\r\n    static int len(int x) {\r\n      String n=\"\"+x;\r\n      return n.length();\r\n    }\r\n    static long ncr(long n, long r, long p){\r\n      if (n<r) return 0;\r\n      if (r == 0) return 1;\r\n      long[] fac = new long[(int)n + 1];\r\n      fac[0] = 1;\r\n      for (int i = 1; i <= n; i++) fac[i] = (fac[i-1]*i)% p;\r\n      return (fac[(int)n] * modInverse(fac[(int)r], p) % p * modInverse(fac[(int)(n - r)], p) % p) % p;\r\n    }\r\n    static long modInverse(long n, long p){\r\n      return power(n, p - 2, p);\r\n    }\r\n    static long maxSubArraySum(int a[])\r\n    {\r\n        int size = a.length;\r\n        long max_so_far = Long.MIN_VALUE, max_ending_here\r\n                                            = 0;\r\n \r\n        for (int i = 0; i < size; i++) {\r\n            max_ending_here = max_ending_here + a[i];\r\n            if (max_so_far < max_ending_here)\r\n                max_so_far = max_ending_here;\r\n            if (max_ending_here < 0)\r\n                max_ending_here = 0;\r\n        }\r\n        return max_so_far;\r\n    }\r\n    static long fact(long n)\r\n    {\r\n    \r\n    // single line to find factorial\r\n    return (n == 1 || n == 0) ? 1 : n * fact(n - 1);\r\n    \r\n    }\r\n    static boolean isSorted(int a[]){\r\n      for(int i=1;i<a.length;i++){\r\n        if(a[i] < a[i-1])\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    static long gcd(long a, long b)\r\n    {\r\n        if (a == 0)\r\n            return b;\r\n        return gcd(b % a, a);\r\n    }\r\n    // static int lcm(int a, int b)\r\n    // {\r\n    //     return (a / gcd(a, b)) * b;\r\n    // }\r\n    static int upper_bound(List<Integer> arr, int key, int i)\r\n    {\r\n      if(Collections.binarySearch(arr, key) >= 0)\r\n        return Collections.binarySearch(arr, key);\r\n      int mid, N = arr.size();\r\n      \r\n        // Initialise starting index and\r\n        // ending index\r\n        int low = i;\r\n        int high = arr.size()-1;\r\n  \r\n        // Till low is less than high\r\n        while (low < high && low != N) {\r\n            // Find the index of the middle element\r\n            mid = low + (high - low) / 2;\r\n  \r\n            // If key is greater than or equal\r\n            // to arr[mid], then find in\r\n            // right subarray\r\n            if (key >= arr.get(mid)) {\r\n                low = mid + 1;\r\n            }\r\n  \r\n            // If key is less than arr[mid]\r\n            // then find in left subarray\r\n            else {\r\n                high = mid;\r\n            }\r\n        }\r\n  \r\n        return arr.get(low) > key? low : -1;\r\n    }\r\n    static int lower_bound(List<Integer> arr, int key, int i)\r\n    {\r\n      // if(Arrays.binarySearch(arr, key) >= 0)\r\n      // return Arrays.binarySearch(arr, key);\r\n        // Initialize starting index and\r\n        // ending index\r\n        int low = 0, high = i;\r\n        int mid;\r\n \r\n        // Till high does not crosses low\r\n        while (low < high) {\r\n \r\n            // Find the index of the middle element\r\n            mid = low + (high - low) / 2;\r\n \r\n            // If key is less than or equal\r\n            // to array[mid], then find in\r\n            // left subarray\r\n            if (key <= arr.get(mid)) {\r\n                high = mid;\r\n            }\r\n \r\n            // If key is greater than array[mid],\r\n            // then find in right subarray\r\n            else {\r\n \r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n    static boolean palin(int arr[], int i, int j){\r\n      while(i < j){\r\n        if(arr[i] != arr[j])\r\n          return false;\r\n        i++;\r\n        j--;\r\n      }\r\n      return true;\r\n    }\r\n    static boolean palin(String s){\r\n      int i=0,j=s.length()-1;\r\n      while(i<j){\r\n        if(s.charAt(i)!=s.charAt(j))\r\n          return false;\r\n        i++;\r\n        j--;\r\n      }\r\n      return true;\r\n    }\r\n    static long minSum(int arr[], int n, int k)\r\n    {\r\n        // k must be smaller than n\r\n        if (n < k)\r\n        {\r\n          // System.out.println(\"Invalid\");\r\n           return -1;\r\n        }\r\n      \r\n        // Compute sum of first window of size k\r\n        long res = 0;\r\n        for (int i=0; i<k; i++)\r\n           res += arr[i];\r\n      \r\n        // Compute sums of remaining windows by\r\n        // removing first element of previous\r\n        // window and adding last element of\r\n        // current window.\r\n        long curr_sum = res;\r\n        for (int i=k; i<n; i++)\r\n        {\r\n           curr_sum += arr[i] - arr[i-k];\r\n           res = Math.min(res, curr_sum);\r\n        }\r\n      \r\n        return res;\r\n    }\r\n    static int nextIndex(int a[], int x){\r\n      int n=a.length;\r\n      for(int i=x;i<n-1;i++){\r\n        if(a[i]>a[i+1]){\r\n          return i;\r\n        }\r\n      }\r\n      return n;\r\n    }\r\n    static void rev(int a[], int i, int j){\r\n      while(i<j){\r\n        int t=a[i];\r\n        a[i]=a[j];\r\n        a[j]=t;\r\n        i++;\r\n        j--;\r\n      }\r\n    }\r\n    static int sorted(int arr[], int n)\r\n    {\r\n        // Array has one or no element or the\r\n        // rest are already checked and approved.\r\n        if (n == 1 || n == 0)\r\n            return 1;\r\n \r\n        // Unsorted pair found (Equal values allowed)\r\n        if (arr[n - 1] < arr[n - 2])\r\n            return 0;\r\n \r\n        // Last pair was sorted\r\n        // Keep on checking\r\n        return sorted(arr, n - 1);\r\n    }\r\n    static List<Integer> sieveOfEratosthenes(int n, int a[])\r\n    {\r\n      for(int i=2;i<=n;i++){\r\n        a[i]=1;\r\n      }\r\n      for(int i=2;i<=1000;i++){\r\n        for(int j=2*i;j<=n;j+=i){\r\n          a[j]=0;\r\n        }\r\n      }\r\n      List<Integer> list = new ArrayList<>();\r\n      for(int i=2;i<=n;i++){\r\n        if(a[i]==1){\r\n          list.add(i);\r\n        }\r\n      }\r\n      return list;\r\n    }\r\n    static boolean isPowerOfTwo(int n)\r\n    {\r\n        return (int)(Math.ceil((Math.log(n) / Math.log(2))))\r\n            == (int)(Math.floor(((Math.log(n) / Math.log(2)))));\r\n    }\r\n    static int countSetBits(long n)\r\n    {\r\n        int count = 0;\r\n        while (n > 0) {\r\n            count += n & 1;\r\n            n >>= 1;\r\n        }\r\n        return count;\r\n    }\r\n    static int countBits(int number)\r\n    {\r\n         \r\n        // log function in base 2\r\n        // take only integer part\r\n        return (int)(Math.log(number) /\r\n                     Math.log(2) + 1);\r\n    }\r\n    public static void swap(int ans[], int i, int j) {\r\n        int temp=ans[i];\r\n        ans[i]=ans[j];\r\n        ans[j]=temp;\r\n    }\r\n\r\n    static long power(long x, long y, long p)\r\n  {\r\n    long res = 1; // Initialize result\r\n \r\n    x = x % p; // Update x if it is more than or\r\n    // equal to p\r\n \r\n    if (x == 0)\r\n      return 0; // In case x is divisible by p;\r\n \r\n    while (y > 0)\r\n    {\r\n \r\n      // If y is odd, multiply x with result\r\n      if ((y & 1) != 0)\r\n        res = (res * x) % p;\r\n \r\n      // y must be even now\r\n      y = y >> 1; // y = y/2\r\n      x = (x * x) % p;\r\n    }\r\n    return res;\r\n  }\r\n  static class FastReader {\r\n    BufferedReader br;\r\n    StringTokenizer st;\r\n\r\n    public FastReader()\r\n    {\r\n        br = new BufferedReader(\r\n            new InputStreamReader(System.in));\r\n    }\r\n\r\n    String next()\r\n    {\r\n        while (st == null || !st.hasMoreElements()) {\r\n            try {\r\n                st = new StringTokenizer(br.readLine());\r\n            }\r\n            catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return st.nextToken();\r\n    }\r\n\r\n    int nextInt() { return Integer.parseInt(next()); }\r\n\r\n    long nextLong() { return Long.parseLong(next()); }\r\n\r\n    double nextDouble()\r\n    {\r\n        return Double.parseDouble(next());\r\n    }\r\n\r\n    String nextLine()\r\n    {\r\n        String str = \"\";\r\n        try {\r\n            if(st.hasMoreTokens()){\r\n                str = st.nextToken(\"\\n\");\r\n            }\r\n            else{\r\n                str = br.readLine();\r\n            }\r\n        }\r\n        catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return str;\r\n    }\r\n}\r\n}"
}