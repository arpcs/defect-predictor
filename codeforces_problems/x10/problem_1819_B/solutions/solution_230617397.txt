{
    "id": 230617397,
    "contestId": 1819,
    "creationTimeSeconds": 1698717355,
    "relativeTimeSeconds": 1855,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "lzoilxy"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1698715500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 0,
    "source": "//#pragma GCC optimize(2)\r\n//#pragma GCC optimize(3)\r\n#include<bits/stdc++.h>\r\n#define db double\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define eb emplace_back\r\n#define pf push_front\r\n#define ppf pop_front\r\n#define LL long long\r\n#define i128 __int128\r\n#define ldb long double\r\n#define ull unsigned long long\r\n#define mkt make_tuple\r\n#define pdd pair<db,db>\r\n#define pll pair<LL,LL>\r\n#define pil pair<int,LL>\r\n#define pli pair<LL,int>\r\n#define pii pair<int,int>\r\n#define pip pair<int,pii>\r\n#define ppi pair<pii,int>\r\n#define ppp pair<pii,pii>\r\n#define pss pair<pair<char,char>,pair<char,char>>\r\n#define fr first\r\n#define sc second\r\n#define mp make_pair\r\nusing namespace std;\r\nconst int mxn=1e6+10,mxm=5010,N=1e6,infi=1e9,mod=1e9+7,inv2=(mod+1)/2,inv3=(mod+1)/3;\r\nconst int v1=37,v2=53,M1=323323323,M2=998244353;\r\nconst int dx[]={0,1,0,-1},\r\n\tdy[]={1,0,-1,0};\r\nconst db PI=acos(-1),eps=1e-10;\r\nconst LL infl=1e18;\r\nint DB_cmp(db x,db y) {if(fabs(x-y)<eps) return 0; if(x<y) return -1; return 1;}\r\ntemplate<class T> inline void chkmax(T &x,const T y) {if(y>x) x=y;}\r\ntemplate<class T> inline void chkmin(T &x,const T y) {if(y<x) x=y;}\r\ntemplate<class T> inline void upd(T &x,const T y) {if((x+=y)>=mod) x-=mod;}\r\ntemplate<class T> inline int Add(const T x,const T y) {if(x+y>=mod) return x+y-mod; return x+y;}\r\ntemplate<class T> inline T my_gcd(T a,T b) {if(!a||!b) return a|b; for(T c=a%b;c;a=b,b=c,c=a%b); return b;}\r\ninline int _pow(int k,int i)\r\n{\r\n\tint t=1;\r\n\tfor(;i;i>>=1,k=1ll*k*k%mod)\r\n\t\tif(i&1)\r\n\t\t\tt=1ll*t*k%mod;\r\n\treturn t;\r\n}\r\ninline int _pow(int k,int i,int M)\r\n{\r\n\tint t=1;\r\n\tfor(;i;i>>=1,k=1ll*k*k%M)\r\n\t\tif(i&1)\r\n\t\t\tt=1ll*t*k%M;\r\n\treturn t;\r\n}\r\ninline int my_gcd(int a,int b) {if(!a||!b) return a|b; for(int c=a%b;c;a=b,b=c,c=a%b); return b;}\r\nLL rd()\r\n{\r\n\tstatic LL sl,fh,ch;\r\n\tsl=0;fh=1;ch=getchar();\r\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\r\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\r\n\treturn sl*fh;\r\n}\r\nstruct BIT\r\n{\r\n\tint n,cnt;\r\n\tvector<int> tr;\r\n\tBIT(int _n) {cnt=0; tr.resize((n=_n)+1,0);}\r\n\tvoid upd(int i,int v) {for(;i;i-=(i&-i)) tr[i]+=v;}\r\n\tvoid upd(int l,int r,int v) {upd(l,v); upd(r+1,-v);}\r\n\tint qry(int i) {int res=0; for(;i<=n;i+=(i&-i)) res+=tr[i]; return res;}\r\n};\r\nstruct Trie\r\n{\r\n\tstruct Tree\r\n\t{\r\n\t\tint sn[2];\r\n\t\tTree() {sn[0]=sn[1]=0;}\r\n\t};\r\n\tint rt_num;\r\n\tvector<Tree> tr;\r\n\tTrie() {rt_num=1; tr.eb(Tree());}\r\n\tint newnode() {tr.eb(Tree()); return rt_num++;}\r\n\tvoid insert(int x)\r\n\t{\r\n\t\tint d,u=0;\r\n\t\tfor(int i=7;~i;--i)\r\n\t\t{\r\n\t\t\td=x>>i&1;\r\n\t\t\tif(!tr[u].sn[d]) tr[u].sn[d]=newnode();\r\n\t\t\tu=tr[u].sn[d];\r\n\t\t}\r\n\t}\r\n\tint query(int x)\r\n\t{\r\n\t\tint d,u=0,res=0;;\r\n\t\tfor(int i=7;~i;--i)\r\n\t\t{\r\n\t\t\td=x>>i&1;\r\n\t\t\tif(tr[u].sn[d^1])\r\n\t\t\t{\r\n\t\t\t\td^=1;\r\n\t\t\t\tres|=1<<i;\r\n\t\t\t}\r\n\t\t\tu=tr[u].sn[d];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n};\r\nstruct Seg_Tree\r\n{\r\n\tstruct Tree\r\n\t{\r\n\t\tLL v;\r\n\t\tTree() {v=0;}\r\n\t};\r\n\tint n;\r\n\tvector<Tree> tr;\r\n\tSeg_Tree() {}\r\n\tSeg_Tree(int n): n(n) {tr.resize(n*4+10);}\r\n\tvoid init(int _n)\r\n\t{\r\n\t\tn=_n;\r\n\t\ttr.resize(4*n+10,Tree());\r\n\t}\r\n\t#define mid ((l+r)>>1)\r\n\tvoid update(int x,int l,int r,int p,int v)\r\n\t{\r\n\t\ttr[x].v+=v;\r\n\t\tif(l==r) return void();\r\n\t\tif(p<=mid) update(x<<1,l,mid,p,v);\r\n\t\telse update(x<<1|1,mid+1,r,p,v);\r\n\t}\r\n\tLL query(int x,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R) return tr[x].v;\r\n\t\tLL res=0;\r\n\t\tif(L<=mid) res=query(x<<1,l,mid,L,R);\r\n\t\tif(R>mid) res+=query(x<<1|1,mid+1,r,L,R);\r\n\t\treturn res;\r\n\t}\r\n\t#undef mid \r\n\tvoid upd(int p,int v) {update(1,1,n,p,v);}\r\n\tLL qry(int l,int r) {if(l>r) return 0; return query(1,1,n,l,r);}\r\n};\r\nstruct ST_Table\r\n{\r\n\tvector<vector<int>> f;\r\n\tvector<int> lg;\r\n\tvoid build(const vector<int> &vt,int n)\r\n\t{\r\n\t\tlg.resize(n+2,0);\r\n\t\tfor(int i=2;i<=n+1;++i) lg[i]=lg[i>>1]+1;\r\n\t\tf.pb(vt);\r\n\t\tfor(int i=1;1<<i<=n+1;++i)\r\n\t\t{\r\n\t\t\tf.pb(vector<int>());\r\n\t\t\tfor(int j=0;j+(1<<i)-1<=n;++j)\r\n\t\t\t\tf[i].pb(max(f[i-1][j],f[i-1][j+(1<<(i-1))]));\r\n\t\t}\r\n\t}\r\n\tint qry(int l,int r)\r\n\t{\r\n\t\tint k=lg[r-l+1];\r\n\t\treturn max(f[k][l],f[k][r-(1<<k)+1]);\r\n\t}\r\n};\r\n//#define DEBUG\r\ntypedef tuple<int,int,int> tup;\r\nSeg_Tree T;\r\nint n,m;\r\nvector<LL> ans;\r\nvector<int> tim;\r\nvector<vector<int>> G;\r\nvector<vector<pii>> opt;\r\nvoid dfs(int u)\r\n{\r\n\tfor(auto [t,v]:opt[u]) T.upd(t,v);\r\n\tans[u]=T.qry(tim[u],m);\r\n\tfor(auto v:G[u])\r\n\t\tdfs(v);\r\n\tfor(auto [t,v]:opt[u]) T.upd(t,-v);\r\n}\r\nint main()\r\n{\r\n//\tfreopen(\"10.in\",\"r\",stdin);\r\n//\tfreopen(\"my.out\",\"w\",stdout);\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n//\tprime_init();\r\n//\tfor(int i=2;i<=N;++i) lg[i]=lg[i>>1]+1;\r\n\tint TT=1;\r\n\tcin>>TT;\r\n\tfor(;TT;--TT)\r\n//\tfor(int ii=1;ii<=TT;++ii)\r\n//\tfor(int TT=rd();TT;--TT)\r\n\t{\r\n\t\tcin>>n;vector<pii> a(n+1,mp(0,0));\r\n\t\tfor(int i=1;i<=n;++i) cin>>a[i].fr>>a[i].sc;\r\n\t\tvector<pii> vt;\r\n\t\t{\r\n\t\t\tmap<int,multiset<int>> exh,exw;\r\n\t\t\tint H=infi,W=infi;\r\n\t\t\tfor(int i=1;i<=n;++i)\r\n\t\t\t{\r\n\t\t\t\texh[a[i].fr].insert(a[i].sc);\r\n\t\t\t\texw[a[i].sc].insert(a[i].fr);\r\n\t\t\t\tif(a[i].fr+a[i].sc<H+W) H=a[i].fr,W=a[i].sc;\r\n\t\t\t}\r\n\t\t\texh[H].erase(exh[H].find(W));\r\n\t\t\texw[W].erase(exw[W].find(H));\r\n\t\t\tfor(int i=1;i<n;++i)\r\n\t\t\t{\r\n\t\t\t\tif(!exh[H].empty())\r\n\t\t\t\t{\r\n\t\t\t\t\tint _W=*exh[H].begin();\r\n\t\t\t\t\texh[H].erase(exh[H].begin());\r\n\t\t\t\t\tW+=_W;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(!exw[W].empty())\r\n\t\t\t\t{\r\n\t\t\t\t\tint _H=*exw[W].begin();\r\n\t\t\t\t\texw[W].erase(exw[W].begin());\r\n\t\t\t\t\tH+=_H;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tH=W=infi;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif(mp(H,W)!=mp(infi,infi)) vt.eb(H,W);\r\n\t\t}\r\n\t\t{\r\n\t\t\tmap<int,multiset<int>> exh,exw;\r\n\t\t\tint H=infi,W=infi;\r\n\t\t\tfor(int i=1;i<=n;++i)\r\n\t\t\t{\r\n\t\t\t\texh[a[i].fr].insert(a[i].sc);\r\n\t\t\t\texw[a[i].sc].insert(a[i].fr);\r\n\t\t\t\tif(a[i].fr+a[i].sc<H+W) H=a[i].fr,W=a[i].sc;\r\n\t\t\t}\r\n\t\t\texh[H].erase(exh[H].find(W));\r\n\t\t\texw[W].erase(exw[W].find(H));\r\n\t\t\tfor(int i=1;i<n;++i)\r\n\t\t\t{\r\n\t\t\t\tif(!exw[W].empty())\r\n\t\t\t\t{\r\n\t\t\t\t\tint _H=*exw[W].begin();\r\n\t\t\t\t\texw[W].erase(exw[W].begin());\r\n\t\t\t\t\tH+=_H;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(!exh[H].empty())\r\n\t\t\t\t{\r\n\t\t\t\t\tint _W=*exh[H].begin();\r\n\t\t\t\t\texh[H].erase(exh[H].begin());\r\n\t\t\t\t\tW+=_W;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tH=W=infi;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif(mp(H,W)!=mp(infi,infi)) vt.eb(H,W);\r\n\t\t}\r\n\t\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\r\n\t\tcout<<vt.size()<<'\\n';\r\n\t\tfor(auto [x,y]:vt) cout<<x<<' '<<y<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}"
}