{
    "id": 213956117,
    "contestId": 1569,
    "creationTimeSeconds": 1689450978,
    "relativeTimeSeconds": 6978,
    "problem": {
        "contestId": 1569,
        "index": "E",
        "name": "Playoff Restoration",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "bitmasks",
            "brute force",
            "hashing",
            "implementation",
            "meet-in-the-middle"
        ]
    },
    "author": {
        "contestId": 1569,
        "members": [
            {
                "handle": "silxi"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1689444000
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 2457600,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n\r\n// Template {{{\r\n#define REP(n) for (int _=0; _<(n); _++)\r\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\r\n#define F0R(i, a) for (int i=0; i<(a); i++)\r\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\r\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\r\n \r\n#define sz(x) (int)(x).size()\r\n#define all(x) x.begin(), x.end()\r\n \r\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\r\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\r\n\r\nnamespace std {\r\n  template<class Fun>\r\n  class y_combinator_result {\r\n    Fun fun_;\r\n  public:\r\n    template<class T>\r\n    explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\r\n   \r\n    template<class ...Args>\r\n    decltype(auto) operator()(Args &&...args) {\r\n      return fun_(std::ref(*this), std::forward<Args>(args)...);\r\n    }\r\n  };\r\n   \r\n  template<class Fun>\r\n  decltype(auto) y_combinator(Fun &&fun) {\r\n    return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\r\n  }\r\n} // namespace std\r\n\r\n#define DEBUG(x) cerr << #x << \": \" << x << '\\n'\r\ntemplate<typename A, typename B> \r\nostream& operator<<(ostream &os, const pair<A, B> &p) { \r\n  return os << '(' << p.first << \", \" << p.second << ')'; \r\n}\r\ntemplate<typename T_container, \r\n  typename T = typename enable_if<!is_same<T_container, string>::value, \r\n  typename T_container::value_type>::type> \r\nostream& operator<<(ostream &os, const T_container &v) { \r\n  os << '['; string sep; \r\n  for (const T &x : v) \r\n    os << sep << x, sep = \", \"; \r\n  return os << ']'; \r\n}\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n// }}}\r\n\r\nnamespace ModInt {\r\n  template<int MOD>\r\n  struct mod_int {\r\n    int val;\r\n\r\n    operator int() const { return val; }\r\n    mod_int() : val(0) {}\r\n    mod_int(ll _val) : val((_val + MOD) % MOD) {}\r\n\r\n    mod_int operator+() const {\r\n      return mod_int(val);\r\n    }\r\n    mod_int operator-() const {\r\n      return mod_int(MOD-val);\r\n    }\r\n    mod_int inverse() const {\r\n      assert(val != 0);\r\n      return *this ^ (MOD - 2);\r\n    }\r\n\r\n    mod_int& operator+=(const mod_int& b) {\r\n      val += b.val;\r\n      if (val >= MOD) val -= MOD;\r\n      return *this;\r\n    }\r\n    mod_int& operator-=(const mod_int& b) {\r\n      return *this += -b;\r\n    }\r\n    mod_int& operator*=(const mod_int& b) {\r\n      val = (1LL*val*b.val) % MOD;\r\n      return *this;\r\n    }\r\n    mod_int& operator/=(const mod_int& b) {\r\n      val = (1LL*val*b.inverse().val) % MOD;\r\n      return *this;\r\n    }\r\n\r\n    mod_int& operator+=(int b) {\r\n      return *this += mod_int(b);\r\n    }\r\n    mod_int& operator-=(int b) {\r\n      return *this -= mod_int(b);\r\n    }\r\n    mod_int& operator*=(int b) {\r\n      return *this *= mod_int(b);\r\n    }\r\n    mod_int& operator/=(int b) {\r\n      return *this /= mod_int(b);\r\n    }\r\n\r\n    friend mod_int operator+(const mod_int& a, const mod_int& b) {\r\n      mod_int c = a; c += b;\r\n      return c;\r\n    }\r\n    friend mod_int operator-(const mod_int& a, const mod_int& b) {\r\n      mod_int c = a; c -= b;\r\n      return c;\r\n    }\r\n    friend mod_int operator*(const mod_int& a, const mod_int& b) {\r\n      mod_int c = a; c *= b;\r\n      return c;\r\n    }\r\n    friend mod_int operator/(const mod_int& a, const mod_int& b) {\r\n      mod_int c = a; c /= b;\r\n      return c;\r\n    }\r\n\r\n    friend mod_int operator+(const mod_int& a, int b) {\r\n      return a + mod_int(b);\r\n    }\r\n    friend mod_int operator-(const mod_int& a, int b) {\r\n      return a - mod_int(b);\r\n    }\r\n    friend mod_int operator*(const mod_int& a, int b) {\r\n      return a * mod_int(b);\r\n    }\r\n    friend mod_int operator/(const mod_int& a, int b) {\r\n      return a / mod_int(b);\r\n    }\r\n    friend mod_int operator+(int a, const mod_int& b) {\r\n      return mod_int(a) + b;\r\n    }\r\n    friend mod_int operator-(int a, const mod_int& b) {\r\n      return mod_int(a) - b;\r\n    }\r\n    friend mod_int operator*(int a, const mod_int& b) {\r\n      return mod_int(a) * b;\r\n    }\r\n    friend mod_int operator/(int a, const mod_int& b) {\r\n      return mod_int(a) / b;\r\n    }\r\n\r\n    friend mod_int operator^(mod_int a, int b) {\r\n      mod_int res(1);\r\n      while (b > 0) {\r\n        if (b&1) res *= a;\r\n        a *= a;\r\n        b >>= 1;\r\n      }\r\n      return res;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& o, const mod_int& x) {\r\n      return o << x.val;\r\n    };\r\n    friend istream& operator>>(istream& i, mod_int& x) {\r\n      return i >> x.val;\r\n    }\r\n  };\r\n}\r\nconst int MOD = 998244353;\r\nusing mint = ModInt::mod_int<MOD>;\r\n\r\nint k, A, H;\r\n\r\nmint powA[35];\r\n\r\n// winner, hash w/o winner, has w/ winner, place\r\nusing T = tuple<int, mint, mint, vector<int>>;\r\nT eval(vector<int> v, int mask, int p) {\r\n  mint res = 0;\r\n  int j = 0;\r\n  vector<int> place(1 << k);\r\n  while (sz(v) > 1) {\r\n    vector<int> nv;\r\n    for (int i = 0; i < sz(v); i += 2) {\r\n      if (mask & (1 << j)) {\r\n        nv.push_back(v[i]);\r\n        res += v[i+1] * powA[p];\r\n        place[v[i+1]-1] = p;\r\n      }\r\n      else {\r\n        assert(i + 1 < sz(v));\r\n        nv.push_back(v[i+1]);\r\n        res += v[i] * powA[p];\r\n        place[v[i]-1] = p;\r\n      }\r\n      j++;\r\n    }\r\n    p = (p - 1) / 2 + 1;\r\n    v = nv;\r\n  }\r\n  place[v[0]-1] = p;\r\n  return {v[0], res, res + v[0] * powA[p], place};\r\n}\r\n\r\nint main() {\r\n  ios_base::sync_with_stdio(false); cin.tie(NULL);\r\n  cin >> k >> A >> H;\r\n  powA[0] = 1;\r\n  for (int i = 1; i < 35; i++) {\r\n    powA[i] = mint(A) * powA[i-1];\r\n  }\r\n  if (k < 5) {\r\n    vector<int> v(1 << k); iota(all(v), 1);\r\n    int p = (1 << (k-1)) + 1;\r\n    F0R(mask, 1 << ((1 << k) - 1)) {\r\n      auto [winner, _, h, place] = eval(v, mask, p);\r\n      // cout << mask << ' ' << place << \": \" << h << endl;\r\n      if (h == H) {\r\n        for (auto x: place) {\r\n          cout << x << ' ';\r\n        }\r\n        cout << '\\n';\r\n        return 0;\r\n      }\r\n    }\r\n    cout << -1 << '\\n';\r\n  }\r\n  else {\r\n    vector<int> v1(1 << (k-1)); iota(all(v1), 1);\r\n    vector<int> v2(1 << (k-1)); iota(all(v2), (1 << (k-1)) + 1);\r\n    map<int, T> m1, m2;\r\n    int p = (1 << (k-1)) + 1;\r\n    F0R(mask, 1 << ((1 << (k-1)) - 1)) {\r\n      auto [winner, h1, h2, place] = eval(v1, mask, p);\r\n      m1[h1.val] = {winner, h1, h2, place};\r\n    }\r\n    F0R(mask, 1 << ((1 << (k-1)) - 1)) {\r\n      auto [winner, h1, h2, place] = eval(v2, mask, p);\r\n      m2[h1.val] = {winner, h1, h2, place};\r\n    }\r\n    for (auto [h, t]: m1) {\r\n      auto [winner, h1, h2, place] = t;\r\n      mint target = H - h2;\r\n      if (m2.count(target)) {\r\n        auto [a, b, c, place2] = m2[target];\r\n        vector<int> ans(1 << k);\r\n        F0R(i, 1 << k) ans[i] = place[i] + place2[i];\r\n        ans[winner-1] = 1;\r\n        ans[a-1] = 2;\r\n        for (auto x: ans) {\r\n          cout << x << ' ';\r\n        }\r\n        cout << '\\n';\r\n        return 0;\r\n      }\r\n    }\r\n    for (auto [h, t]: m2) {\r\n      auto [winner, h1, h2, place] = t;\r\n      mint target = H - h2;\r\n      if (m1.count(target)) {\r\n        auto [a, b, c, place2] = m1[target];\r\n        vector<int> ans(1 << k);\r\n        F0R(i, 1 << k) ans[i] = place[i] + place2[i];\r\n        ans[winner-1] = 1;\r\n        ans[a-1] = 2;\r\n        for (auto x: ans) {\r\n          cout << x << ' ';\r\n        }\r\n        cout << '\\n';\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n"
}