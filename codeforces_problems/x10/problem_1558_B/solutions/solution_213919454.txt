{
    "id": 213919454,
    "contestId": 1558,
    "creationTimeSeconds": 1689431557,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1558,
        "index": "B",
        "name": "Up the Strip",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "brute force",
            "dp",
            "math",
            "number theory",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1558,
        "members": [
            {
                "handle": "leodicaprio4791"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1629815700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 17,
    "timeConsumedMillis": 2838,
    "memoryConsumedBytes": 96153600,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n// #pragma GCC optimize(\"O1\")\r\n// #pragma GCC optimize(\"O2\")\r\n// #pragma GCC optimize(\"Ofast\")\r\n// #pragma GCC target(\"avx,avx2,fma\")\r\n\r\n/*----------------------------------------PBDS-----------------------------------------*/\r\n//order_of_key (k) : Number of items strictly smaller than k .\r\n//find_by_order(k) : K-th element in a set (counting from zero)//#include <ext/pb_ds/assoc_container.hpp>\r\n//#include <ext/pb_ds/tree_policy.hpp>\r\n//using namespace __gnu_pbds;\r\n//template<typename T> using indexed_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n//template<typename T> using indexed_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n/*-------------------------------------------------------------------------------------\r\n*/\r\n/*----------------------------------------MACROS---------------------------------------*/\r\n#define fs                      first\r\n#define se                      second\r\n#define ll                      long long\r\n#define pb                      push_back\r\n#define ppb                     pop_back\r\n#define nl                      (string)\"\\n\"\r\n#define sz(x)                   (int)x.size()\r\n#define all(x)                  x.begin(), x.end()\r\n#define rall(x)                 x.rbegin(), x.rend()\r\n#define prec(n)                 fixed<<setprecision(n)\r\n#define fra(i, x)               for (auto &i : x)\r\n#define fr(i, x, y)             for (int i = (int)x; i < (int)y; ++i)\r\n#define fr1(i, x, y)            for (int i = (int)x; i <= (int)y; ++i)\r\n#define frr(i, x, y)            for (int i = (int)x; i >= (int)y; --i)\r\n\r\ntypedef pair<ll, ll>            pll;\r\ntypedef pair<int, int>          pii;\r\ntypedef vector<ll>              vl;\r\ntypedef vector<int>             vi;\r\ntypedef vector<vi>              vvi;\r\ntypedef vector<vl>              vvl;\r\ntypedef vector<pii>             vpi;\r\ntypedef vector<pll>             vpl;\r\ntypedef vector<bool>            vb;\r\ntypedef vector<string>          vs;\r\n/*-------------------------------------------------------------------------------------*/\r\n\r\n/*--------------------------------------DEGUG------------------------------------------*/\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x...) cout << #x<<\" = \"; wrt(x); wrt();\r\n#define ____divider____ cout << \"-------output-------\\n\"\r\n#else\r\n#define debug(x...)\r\n#define ____divider____\r\n#endif\r\n/*-------------------------------------------------------------------------------------*/\r\n\r\n/*---------------------------------------I/O-------------------------------------------*/\r\nvoid read() { return; }\r\nvoid wrt() { cout << nl; }\r\nvoid wrt(ll t) {cout << t ;}\r\nvoid wrt(int t) {cout << t ;}\r\nvoid wrt(char t) {cout << t ;}\r\nvoid wrt(string t) {cout << t ;}\r\nvoid wrt(double t) {cout << t ;}\r\ntemplate <class T> void wrt(set <T> v);\r\ntemplate <class T> void wrt(vector <T> v);\r\ntemplate <class T> void wrt(multiset <T> v);\r\ntemplate <class T, class V> void wrt(map <T, V> v);\r\ntemplate <class T, class V> void wrt(pair <T, V> p);\r\ntemplate <size_t T> void wrt(const char (&a)[T]) { string s=a; wrt(s); wrt(); }\r\ntemplate <class T> void wrt(set <T> v) { for (T i : v) {wrt(i); wrt(' ');} wrt(); }\r\ntemplate <class T> void wrt(vector <T> v) { for (T i : v) {wrt(i); wrt(' ');} wrt(); }\r\ntemplate <class T> void wrt(multiset <T> v) { for (T i : v) {wrt(i); wrt(' ');} wrt(); }\r\ntemplate <class T, class V> void wrt(map <T, V> v){for(auto i:v){wrt(i);wrt(' ');}wrt();}\r\ntemplate <class T, class V> void wrt(pair <T, V> p){wrt(p.fs); wrt(' ');wrt(p.se);wrt();}\r\ntemplate <class T, class... V> void wrt(T x, V... args){(wrt(x), wrt(' '),wrt(args...));}\r\ntemplate <class T, class... V> void read(T &x, V &...args) { ((cin >> x),read(args...));}\r\ntemplate <class T> void readArr(T &arr, int x, int y) { fr(i, x, y) cin >> arr[i]; }\r\ntemplate <class T> void wrtArr(T &arr, int x, int y){fr(i, x, y)cout<<arr[i]<<' ';wrt();}\r\n/*-------------------------------------------------------------------------------------*/\r\n\r\n/*----------------------------------------CONST----------------------------------------*/\r\n//int MOD = 0;\r\nconst int N = 1e5+7;\r\nconst int INF = 1e9;\r\nconst ll neg = -100000000000;\r\n// const ll INF = 2e15;\r\nconst ll MOD = 998244353;\r\nconst ll m =  998244353;\r\n// const int MOD = 998244353;\r\nconst double PI = 3.14159265358979312;\r\nconst int dir[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};     // {x, y}\r\n/*-------------------------------------------------------------------------------------*/\r\n\r\n/*----------------------------------------FUNCT----------------------------------------*/\r\ntemplate<class T> ll _sum(vector<T>& arr) { return accumulate(all(arr), 0ll); }\r\ntemplate<class T> bool _min(T &a, T b) { return a > b ? (a = b, true) : false; }\r\ntemplate<class T> bool _max(T &a, T b) { return a < b ? (a = b, true) : false; }\r\ntemplate<class T> T _bits(T x) { T cnt = 0; while(x>0) { cnt++; x>>=1; } return cnt; }\r\ntemplate<class T> T _setbits(T x) { T cnt = 0; while(x>0) { if(x&1) cnt++; x>>=1; } return cnt;}\r\ntemplate<class T> T _ceil(T a, T b) { return (a+b-1)/b; }\r\ntemplate<class T> T _gcd(T a, T b) { return (b == 0) ? (a) : (_gcd(b, a %= b)); }\r\ntemplate<class T> T _lcm(T a, T b) { if (a < b) swap(a, b); return a / _gcd(a, b) * b; }\r\ntemplate<class T> T _add(T x, T y) { x %= MOD; y %= MOD; return (x + y) % MOD; }\r\ntemplate<class T> T _sub(T x, T y) { x %= MOD; y %= MOD; return (x - y + MOD) % MOD; }\r\ntemplate<class T> T _mul(T x, T y) { x %= MOD; y %= MOD; return (x * 1ll * y) % MOD; }\r\ntemplate<class T> T _pow(T x, T y) { if (y == 0) return 1; T _tmp=_pow(x, y / 2); _tmp = _mul(_tmp, _tmp); return (y&1 ? _mul(x, _tmp) : _tmp); }\r\ntemplate<class T> T _inv(T p) { return _pow(p, MOD - 2); }\r\ntemplate<class T> T _div(T x, T y) { x %= MOD, y %= MOD; return _mul(x, _inv(y)); }\r\ntemplate<class T> T _nCr(T n, T r, vector<T> & fact){ return _mul(fact[n], _inv(_mul(fact[r], fact[n - r])));}\r\n/*--------------------------------DSU Algo-----------------------------------------------*/\r\n\r\n// C++ implementation of disjoint set\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// class DisjSet {\r\n// \tll *rank, *parent, *count, n;\r\n\r\n// public:\r\n// \tDisjSet(ll n)\r\n// \t{\r\n// \t\trank = new ll[n];\r\n// \t\tparent = new ll[n];\r\n// \t\tcount = new ll[n];\r\n// \t\tthis->n = n;\r\n// \t\tmakeSet();\r\n// \t}\r\n// \tvoid makeSet()\r\n// \t{\r\n// \t\tfor (ll i = 0; i < n; i++) {\r\n// \t\t\tparent[i] = i;\r\n// \t\t}\r\n// \t}\r\n\t\r\n// \tll count(ll x) {\r\n// \t    ll ct=0;\r\n// \t    for(i,0,n) {if(parent[i]==x) ct++;};\r\n// \t    return ct;\r\n// \t}\r\n\t\r\n// \tll find(ll x)\r\n// \t{\r\n// \t\tif (parent[x] != x) {\r\n// \t\t\tparent[x] = find(parent[x]);\r\n// \t\t}\r\n// \t\treturn parent[x];\r\n// \t}\r\n\r\n// \tvoid Union(ll x, ll y)\r\n// \t{\r\n// \t\tll xset = find(x);\r\n// \t\tll yset = find(y);\r\n// \t\tif (xset == yset)\r\n// \t\t\treturn;\r\n// \t\tif (rank[xset] < rank[yset]) {\r\n// \t\t\tparent[xset] = yset;\r\n// \t\t}\r\n// \t\telse if (rank[xset] > rank[yset]) {\r\n// \t\t\tparent[yset] = xset;\r\n// \t\t}\r\n// \t\telse {\r\n// \t\t\tparent[yset] = xset;\r\n// \t\t\trank[xset] = rank[xset] + 1;\r\n// \t\t}\r\n// \t}\r\n// };\r\n\r\n/*---------------------------------------------------------------------------------------*/\r\nll fast_pow(ll b, ll e){\r\n\tll res = 1;\r\n\twhile(e > 0){\r\n\t\tif(e % 2 == 1){\r\n\t\t\tres = res * b % MOD;\r\n\t\t}\r\n\t\tb = b * b % MOD;\r\n\t\te /= 2;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nll fact(ll n,ll m) {\r\n    ll p = 1;\r\n    while(n) {\r\n        p = (p*n)%m;\r\n        n--;\r\n    }\r\n    return p;\r\n}\r\n\r\nll gcdExtended(ll a, ll b, ll *x, ll *y);\r\n \r\nll modInverse(ll b, ll m)\r\n{\r\n    ll x, y; \r\n    ll g = gcdExtended(b, m, &x, &y);\r\n \r\n    if (g != 1)\r\n        return -1;\r\n \r\n    return (x%m + m) % m;\r\n}\r\n \r\nll modDivide(ll a, ll b, ll m)\r\n{\r\n    a = a % m;\r\n    ll inv = modInverse(b, m);\r\n    return (inv * a) % m;\r\n}\r\n \r\nll gcdExtended(ll a, ll b, ll *x, ll *y)\r\n{\r\n    if (a == 0)\r\n    {\r\n        *x = 0, *y = 1;\r\n        return b;\r\n    }\r\n \r\n    ll x1, y1; \r\n    ll gcd = gcdExtended(b%a, a, &x1, &y1);\r\n    *x = y1 - (b/a) * x1;\r\n    *y = x1;\r\n \r\n    return gcd;\r\n}\r\n\r\nll count_bits(ll num){\r\n    ll a=0;\r\n    while(num>0) {\r\n     //   cout<<num<<endl;\r\n        if((1&num) == 1) {a++;}\r\n        num=num>>1;\r\n    }\r\n    return a;\r\n}\r\n\r\nll cout_dig(ll num) {\r\n    ll ct = 0;\r\n    while(num > 0) {\r\n        ct++;\r\n        num /= 10;\r\n    }\r\n    ct--;\r\n    return ct;\r\n}\r\n\r\n/*----------------------------------------MAIN-CODE------------------------------------*/\r\n\r\nvl find_dia(vvl &adj,ll node,ll pre,vl &diameter) {\r\n    vvl diameters;\r\n    for(auto x:adj[node]) {\r\n        if(x==pre) continue;\r\n        vl r = find_dia(adj,x,node,diameter);\r\n        diameters.pb(r);\r\n    }\r\n    \r\n    sort(diameters.begin(),diameters.end());\r\n\r\n    ll n = diameters.size();\r\n    if(n == 1) {\r\n        if((diameters[n-1][0]) > diameter[0]) {\r\n            diameter[0] = diameters[n-1][0];\r\n            diameter[1] = diameters[n-1][1];\r\n            diameter[2] = node;\r\n        }\r\n    } else if(n > 1) {\r\n        if((diameters[n-1][0] + diameters[n-2][0]) > diameter[0]) {\r\n            diameter[0] = diameters[n-1][0] + diameters[n-2][0];\r\n            diameter[1] = diameters[n-1][1];\r\n            diameter[2] = diameters[n-2][1];\r\n        }\r\n    }\r\n    \r\n    if(n) {\r\n        return {diameters[n-1][0]+1,diameters[n-1][1]};\r\n    } else {\r\n        return {1,node};\r\n    }\r\n}\r\n\r\nvoid recur(vvl &adj,ll node,ll pre,ll h,vl &dis) {\r\n  dis[node]=max(dis[node],h);\r\n  \r\n  for(auto x:adj[node]) {\r\n      if(x==pre) continue;\r\n      recur(adj,x,node,h+1,dis);\r\n  }\r\n  \r\n}\r\n\r\n// const int nn = 500000+1;\r\n// int arr[nn];\r\n// int minP[nn+1];\r\n// bool prime[nn+1];\r\n\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0), cout.tie(0);\r\n    ____divider____;\r\n    \r\n    // memset(prime, true, sizeof(prime));\r\n    // memset(minP, 0, sizeof(minP));\r\n    // prime[1] = false;\r\n    // for (int p = 2; p * p <= nn; p++) {\r\n        \r\n    //     if (prime[p] == true) {\r\n    //         minP[p]=p;\r\n    //         for (int i = p * p; i <= nn; i += p){\r\n    //             prime[i] = false;\r\n    //             if(minP[i]==0) minP[i]=p;\r\n    //         }    \r\n    //     }\r\n    // }\r\n    \r\n    ll n,m;\r\n    cin>>n>>m;\r\n    \r\n    vl dp(n+2,0ll);\r\n\r\n    vl pref_sum(n+2,0ll);pref_sum[0ll]=1ll;\r\n    vl pref(n+2ll,0ll);\r\n    \r\n    fr(i,1,n+1) {\r\n        if(i > 1) {\r\n           pref[i]=(pref[i-1]+pref[i]+m)%m;\r\n           dp[i] = (pref[i]+pref_sum[i-1])%m;\r\n           pref_sum[i] = (pref_sum[i-1]+dp[i])%m;\r\n        } else {\r\n            dp[i]=1ll;\r\n            pref_sum[i]=1ll;\r\n        }\r\n       // cout<<i<<\" \"<<dp[i]<<\" \"<<pref_sum[i]<<endl;\r\n        for(ll j=2;i*j<=n;j++) {\r\n            ll f = i*j;\r\n            ll s = min(n+1ll,(i+1ll)*j);\r\n            pref[f] += dp[i]%m;\r\n            pref[s] -= dp[i]%m;\r\n        }\r\n    }\r\n    \r\n    // fr(i,1,n+1) {\r\n    //     cout<<pref_sum[i]<<endl;\r\n    // }\r\n    \r\n    cout<<dp[n]%m<<endl;\r\n}"
}