{
    "id": 216919111,
    "contestId": 441,
    "creationTimeSeconds": 1691027819,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 441,
        "index": "D",
        "name": "Valera and Swaps",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2100,
        "tags": [
            "constructive algorithms",
            "dsu",
            "graphs",
            "implementation",
            "math",
            "string suffix structures"
        ]
    },
    "author": {
        "contestId": 441,
        "members": [
            {
                "handle": "longcheng_x"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1402241400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h> \r\ntypedef long long ll;\r\nusing namespace std;\r\n#define ull unsigned long long\r\n#define pii pair<int,int>\r\n#define pll pair<ll,ll>\r\n#define pi acos(-1)\r\n#define endl '\\n'\r\n#define yes cout<<\"YES\\n\"\r\n#define no cout<<\"NO\\n\"\r\n#define pikapika return 0\r\n#define int long long\r\nconst ll INF=0x3f3f3f3f,mod=1e9+7;\r\nll pow(ll a,ll b,ll c)\r\n{\r\n    ll x=1;\r\n    while(b)\r\n    {\r\n        if(b&1)x=(x*a)%c;\r\n        a=(a*a)%c;\r\n        b>>=1;\r\n    }\r\n    return x;\r\n}\r\nll ppp(ll a,ll b)\r\n{\r\n    ll x=1;\r\n    while(b)\r\n    {\r\n        if(b&1)x=x*a;\r\n        a=a*a;\r\n        b>>=1;\r\n    }\r\n    return x;\r\n}\r\n//ll fact[500001],invfact[500001],N=500000;\r\n//void init()\r\n//{\r\n//  fact[0]=1;\r\n//  for(ll i=1;i<=N;i++)\r\n//      fact[i]=fact[i-1]*i%mod;\r\n//  invfact[N]=pow(fact[N],mod-2,mod);\r\n//  for(ll i=N-1;i>=0;i--)\r\n//      invfact[i]=invfact[i+1]*(i+1)%mod;\r\n//}\r\n//ll C(ll n,ll m)\r\n//{\r\n//  if(n<m)return 0;\r\n//  return ((fact[n]*invfact[m])%mod)*invfact[n-m]%mod;\r\n//}\r\n//int a[200010];\r\n//struct SegmentTree{\r\n//  int ma;\r\n//}t[400040];\r\n//void update(int o)\r\n//{\r\n//  t[o].ma=max(t[o<<1].ma,t[o<<1|1].ma);\r\n//}\r\n//void build(int o,int l,int r)\r\n//{\r\n//  if(l==r)\r\n//  {\r\n//      t[o].ma=a[l];\r\n//      return;\r\n//  }\r\n//  int mid=(l+r)>>1;\r\n//  build(o<<1,l,mid),build(o<<1|1,mid+1,r);\r\n//  update(o);\r\n//}\r\n//int query(int o,int l,int r,int ql,int qr)\r\n//{\r\n//  if(l==ql&&r==qr)return t[o].ma;\r\n//  int mid=(l+r)>>1;\r\n//  if(qr<=mid)return query(o<<1,l,mid,ql,qr);\r\n//  else if(ql>mid)return query(o<<1|1,mid+1,r,ql,qr);\r\n//  else return max(query(o<<1,l,mid,ql,mid),query(o<<1|1,mid+1,r,mid+1,qr));\r\n//}\r\n//int get(vector<int>&a,int n) \r\n//{\r\n//    int res=0;\r\n//    int z=n;\r\n//    int m=a.size();\r\n//    for(int i=1;i<1<<m;i++)\r\n//    {\r\n//        int s=0,t=1;\r\n//        for(int j=0;j<m;j++)\r\n//        {\r\n//            if(i>>j&1)\r\n//            {\r\n//                if((long long)t*a[j]>n) \r\n//                {\r\n//                    t=-1;\r\n//                    break;\r\n//                }\r\n//                s++;\r\n//                t*=a[j];\r\n//            }\r\n//        }\r\n//        if(t!=-1)\r\n//        {\r\n//            if(s&1)res+=n/t;\r\n//            else res-=n/t;\r\n//        }\r\n//    }\r\n//    return z-res;\r\n//}\r\nll sqrtx(ll n) {\r\n  ll x=sqrt(n)+0.5;\r\n  while (x*x>n) x--;\r\n  return x;\r\n}\r\nvoid read(ll &a)\r\n{\r\n    char s[10000];\r\n    cin>>s;\r\n    a=0;\r\n    int l=strlen(s);\r\n    for(int i=0;i<l;i++)\r\n    {\r\n        a=a*10+s[i]-'0';\r\n    }\r\n}\r\nusing i64 = long long;\r\ntemplate<class T>\r\nconstexpr T power(T a, i64 b) {\r\n    T res = 1;\r\n    for (; b; b /= 2, a *= a) {\r\n        if (b % 2) {\r\n            res *= a;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n \r\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\r\n    i64 res = a * b - i64(1.L * a * b / p) * p;\r\n    res %= p;\r\n    if (res < 0) {\r\n        res += p;\r\n    }\r\n    return res;\r\n}\r\ntemplate<i64 P>\r\nstruct MLong {\r\n    i64 x;\r\n    constexpr MLong() : x{} {}\r\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\r\n    \r\n    static i64 Mod;\r\n    constexpr static i64 getMod() {\r\n        if (P > 0) {\r\n            return P;\r\n        } else {\r\n            return Mod;\r\n        }\r\n    }\r\n    constexpr static void setMod(i64 Mod_) {\r\n        Mod = Mod_;\r\n    }\r\n    constexpr i64 norm(i64 x) const {\r\n        if (x < 0) {\r\n            x += getMod();\r\n        }\r\n        if (x >= getMod()) {\r\n            x -= getMod();\r\n        }\r\n        return x;\r\n    }\r\n    constexpr i64 val() const {\r\n        return x;\r\n    }\r\n    explicit constexpr operator i64() const {\r\n        return x;\r\n    }\r\n    constexpr MLong operator-() const {\r\n        MLong res;\r\n        res.x = norm(getMod() - x);\r\n        return res;\r\n    }\r\n    constexpr MLong inv() const {\r\n        assert(x != 0);\r\n        return power(*this, getMod() - 2);\r\n    }\r\n    constexpr MLong &operator*=(MLong rhs) & {\r\n        x = mul(x, rhs.x, getMod());\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator+=(MLong rhs) & {\r\n        x = norm(x + rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator-=(MLong rhs) & {\r\n        x = norm(x - rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator/=(MLong rhs) & {\r\n        return *this *= rhs.inv();\r\n    }\r\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res *= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res += rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res -= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res /= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\r\n        i64 v;\r\n        is >> v;\r\n        a = MLong(v);\r\n        return is;\r\n    }\r\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\r\n        return os << a.val();\r\n    }\r\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\r\n        return lhs.val() == rhs.val();\r\n    }\r\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\r\n        return lhs.val() != rhs.val();\r\n    }\r\n};\r\n \r\ntemplate<>\r\ni64 MLong<0LL>::Mod = 1;\r\n \r\ntemplate<int P>\r\nstruct MInt {\r\n    int x;\r\n    constexpr MInt() : x{} {}\r\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\r\n    \r\n    static int Mod;\r\n    constexpr static int getMod() {\r\n        if (P > 0) {\r\n            return P;\r\n        } else {\r\n            return Mod;\r\n        }\r\n    }\r\n    constexpr static void setMod(int Mod_) {\r\n        Mod = Mod_;\r\n    }\r\n    constexpr int norm(int x) const {\r\n        if (x < 0) {\r\n            x += getMod();\r\n        }\r\n        if (x >= getMod()) {\r\n            x -= getMod();\r\n        }\r\n        return x;\r\n    }\r\n    constexpr int val() const {\r\n        return x;\r\n    }\r\n    explicit constexpr operator int() const {\r\n        return x;\r\n    }\r\n    constexpr MInt operator-() const {\r\n        MInt res;\r\n        res.x = norm(getMod() - x);\r\n        return res;\r\n    }\r\n    constexpr MInt inv() const {\r\n        assert(x != 0);\r\n        return power(*this, getMod() - 2);\r\n    }\r\n    constexpr MInt &operator*=(MInt rhs) & {\r\n        x = 1LL * x * rhs.x % getMod();\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator+=(MInt rhs) & {\r\n        x = norm(x + rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator-=(MInt rhs) & {\r\n        x = norm(x - rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator/=(MInt rhs) & {\r\n        return *this *= rhs.inv();\r\n    }\r\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res *= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res += rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res -= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res /= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\r\n        i64 v;\r\n        is >> v;\r\n        a = MInt(v);\r\n        return is;\r\n    }\r\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\r\n        return os << a.val();\r\n    }\r\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\r\n        return lhs.val() == rhs.val();\r\n    }\r\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\r\n        return lhs.val() != rhs.val();\r\n    }\r\n};\r\n \r\ntemplate<>\r\nint MInt<0>::Mod = 1;\r\n \r\ntemplate<int V, int P>\r\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\r\n \r\nconstexpr int P = 998244353;\r\nusing Z = MInt<P>;\r\n\r\nstruct DSU {\r\n    std::vector<int> f, siz;\r\n    \r\n    DSU() {}\r\n    DSU(int n) {\r\n        init(n);\r\n    }\r\n    \r\n    void init(int n) {\r\n        f.resize(n);\r\n        std::iota(f.begin(), f.end(), 0);\r\n        siz.assign(n, 1);\r\n    }\r\n    \r\n    int find(int x) {\r\n        while (x != f[x]) {\r\n            x = f[x] = f[f[x]];\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    bool same(int x, int y) {\r\n        return find(x) == find(y);\r\n    }\r\n    \r\n    bool merge(int x, int y) {\r\n        x = find(x);\r\n        y = find(y);\r\n        if (x == y) {\r\n            return false;\r\n        }\r\n        siz[x] += siz[y];\r\n        f[y] = x;\r\n        return true;\r\n    }\r\n    \r\n    int size(int x) {\r\n        return siz[find(x)];\r\n    }\r\n};\r\n\r\n\r\nvoid solve()\r\n{\r\n    int n;cin>>n;vector<int>a(n),pos(n);\r\n    DSU dsu(n);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>a[i];a[i]--;\r\n        dsu.merge(i,a[i]);pos[a[i]]=i;\r\n    }\r\n    int m;cin>>m;\r\n    int now=0;\r\n    vector<int>p,f(n);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        int t=dsu.find(i);\r\n        if(!f[t])p.push_back(i),f[t]=1;\r\n    }\r\n    now=n-p.size();\r\n    vector<pii>ans;\r\n    if(now==m)cout<<\"0\\n\";\r\n    else if(now<m)\r\n    {\r\n        for(int i=0;i<m-now;i++)\r\n        {\r\n            ans.push_back({p[i],p[i+1]});\r\n        }\r\n        cout<<ans.size()<<\"\\n\";\r\n        for(auto [x,y]:ans)cout<<x+1<<\" \"<<y+1<<\" \";cout<<\"\\n\";\r\n    }\r\n    else\r\n    {\r\n        int need=now-m;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(pos[i]!=i)\r\n            {\r\n                ans.push_back({i,pos[i]});\r\n                swap(pos[a[i]],pos[i]);\r\n                swap(a[i],i);\r\n            }\r\n        }\r\n        cout<<ans.size()<<\"\\n\";\r\n        for(auto [x,y]:ans)cout<<x+1<<\" \"<<y+1<<\" \";cout<<\"\\n\";\r\n    }\r\n}\r\nsigned main()\r\n{\r\n    ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);\r\n    int T=1;\r\n    // cin>>T;\r\n//  init();\r\n    while(T--)\r\n    {\r\n        solve();\r\n    }\r\n    pikapika;\r\n}"
}