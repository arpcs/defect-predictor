{
    "id": 226533515,
    "contestId": 1213,
    "creationTimeSeconds": 1696393904,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1213,
        "index": "F",
        "name": "Unstable String Sort",
        "type": "PROGRAMMING",
        "rating": 2100,
        "tags": [
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "greedy",
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 1213,
        "members": [
            {
                "handle": "oneeye"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1567175700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 66,
    "timeConsumedMillis": 764,
    "memoryConsumedBytes": 45670400,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nlong long counter;\r\n\r\n\r\nstruct myComp {\r\n    constexpr bool operator()(\r\n        pair<int, int> const& a,\r\n        pair<int, int> const& b)\r\n        const noexcept\r\n    {\r\n        if (a.first==b.first) return a.second>b.second;\r\n        else return a.first<b.first;\r\n    }\r\n};\r\n#define INF 10000000000000\r\n\r\nvector<long long> adj[200001];\r\nvector<long long> radj[200001];\r\nvector<bool> vis1(200001,false),vis2(200001,false);\r\nstack<long long> timer;\r\nchar arr[100005];\r\nlong long seg[4*100005],lazy[4*100005];\r\nvector<int> res(2,0);\r\n// long long lower[4*200005];\r\n\r\n void build(long long ind,long long low,long long high){\r\n    lazy[ind]=0;\r\n    if (low==high){\r\n        seg[ind]=arr[low];\r\n        // lower[ind ] =arr[low];\r\n\r\n\r\n\r\n        return;\r\n    }\r\n    \r\n\r\n    long long mid=(low+high)/2;\r\n    build(2*ind+1,low,mid);\r\n    build(2*ind+2,mid+1,high);\r\n    seg[ind]=max(seg[2*ind+1],seg[2*ind+2]);\r\n    // lower[ind]=min()\r\n\r\n\r\n\r\n }\r\n\r\n long long query(long long ind,long long low,long long high,long long l,long long r){\r\n    if (low>=l && high<=r){\r\n        return seg[ind];\r\n    }\r\n    if (high<l ||low>r) return 0;\r\n    long long mid=(low+high)/2;\r\n\r\n    long long  left=query(2*ind+1,low,mid,l,r);\r\n    long long  right=query(2*ind+2,mid+1,high,l,r);\r\n    return left+right;\r\n }\r\n long long find(long long ind,long long low ,long long high,long long val){\r\n    if (low==high){\r\n        if (arr[low]>=val) return low;\r\n        return -1;\r\n    }\r\n    int mid=(low+high)/2;\r\n    if(seg[2*ind+1]>=val){\r\n        return find(2*ind+1,low,mid,val);\r\n    }\r\n    else return find(2*ind+2,mid+1,high,val);\r\n\r\n\r\n }\r\n void update(long long ind,long long low,long long high,long long node,long long val){\r\n   if (low==high){\r\n        seg[ind]-=val;\r\n        arr[node]-=val;\r\n        // return;\r\n    }\r\n    else{\r\n    long long mid=(low+high)>>1;\r\n     if (node>=low && node<=mid) update(2*ind+1,low,mid,node,val);\r\n    else update(2*ind+2,mid+1,high,node,val);\r\n    seg[ind]=max(seg[2*ind+1],seg[2*ind+2]);\r\n    }\r\n\r\n }\r\n long long range_query(long long ind,long long low,long long high,long long l,long long r){\r\n    if (lazy[ind]!=0){\r\n        seg[ind]+=(high-low+1)*lazy[ind];\r\n        if (low!=high){\r\n            lazy[2*ind+1]+=lazy[ind];\r\n            lazy[2*ind+2]+=lazy[ind];\r\n            \r\n        }\r\n        lazy[ind]=0;\r\n\r\n      }\r\n\r\n      if (r<low || l>high ) return 0;\r\n      if (low>=l && high<=r){\r\n        // seg[ind]=(high-low+1)*val;\r\n        // if (low!=high){\r\n        //     lazy[2*ind+1]+=lazy[ind];\r\n        //     lazy[2*ind+1]+=lazy[ind];\r\n            \r\n        // }\r\n        return seg[ind];\r\n      }\r\n      long long mid=(low+high)/2;\r\n      return range_query(2*ind+1,low,mid,l,r)+range_query(2*ind+2,mid+1,high,l,r);\r\n\r\n }\r\n void range_update(long long ind,long long low,long long high,long long st,long long end,long long val){\r\n    //   if (low==high){\r\n    //     seg[ind]=lazy[ind]+val;\r\n    //     lazy[ind]=0;\r\n    //     return ;\r\n    //   }\r\n      if (lazy[ind]!=0){\r\n        seg[ind]+=(high-low+1)*lazy[ind];\r\n    \r\n        if (low!=high){\r\n            lazy[2*ind+1]+=lazy[ind];\r\n            lazy[2*ind+2]+=lazy[ind];\r\n            \r\n        }\r\n        lazy[ind]=0;\r\n\r\n      }\r\n\r\n      if (end<low || st>high ) return;\r\n      if (low>=st && high<=end){\r\n        // seg[ind]+=(high-low+1)*val;\r\n        if (low!=high){\r\n            lazy[2*ind+1]-=val;\r\n            lazy[2*ind+2]-=val;\r\n            \r\n        }\r\n        return;\r\n      }\r\n      long long mid=(low+high)/2;\r\n      range_update(2*ind+1,low,mid,st,end,val);\r\n    range_update(2*ind+2,mid+1,high,st,end,val);\r\n    seg[ind]=seg[2*ind+1]+seg[2*ind+2];\r\n\r\n }\r\n//  void dfs(int s,vector<vector<int>>& adj,vector<bool>& vis,vector<int>& dist){\r\n//       vis[s]=true;\r\n//       for(auto child:adj[s]){\r\n//         if (!vis[child]){\r\n//             dist[child]=dist[s]+1;\r\n//             dfs(child,adj,vis,dist);\r\n//         }\r\n//       }\r\n//  }\r\n int solve(string s1,string s2,string s3){\r\n    bool A=false,B=false,C=false;\r\n    int  res=0;\r\n    for(int i=0;i<s1.length();i++){\r\n            if (s1[i]=='A') A=true;\r\n            if (s1[i]=='B') B=true;\r\n            if (s1[i]=='C') C=true;\r\n    }\r\n    for(int i=0;i<s2.length();i++){\r\n            if (s2[i]=='A') A=true;\r\n            if (s2[i]=='B') B=true;\r\n            if (s2[i]=='C') C=true;\r\n    }\r\n    for(int i=0;i<s3.length();i++){\r\n            if (s3[i]=='A') A=true;\r\n            if (s3[i]=='B') B=true;\r\n            if (s3[i]=='C') C=true;\r\n    }\r\n    if(A) res++;\r\n    if (B) res++;\r\n    if (C) res++;\r\n    return res;\r\n\r\n }\r\n//  void dfs(int s,vector<vector<int>>& adj,vector<int>& par,vector<bool>& vis){\r\n//     vis[s]=true;\r\n//     for(auto child:adj[s]){\r\n//         if (!vis[child]){\r\n//             par[child]=s;\r\n//             dfs(child,adj,par,vis);\r\n//         }\r\n//     }\r\n\r\n//  }\r\n int find_leaf(int a,vector<int>& par){\r\n    if (adj[a].size()==1) return a;\r\n    if (adj[a][0]==par[a]){\r\n        par[adj[a][1]]=a;\r\n        return find_leaf(adj[a][1],par);\r\n    }\r\n    else{\r\n        par[adj[a][0]]=a;\r\n        return find_leaf(adj[a][0],par);\r\n\r\n    }\r\n }\r\n\r\n//  void dfs(int s, vector<vector<int>>& adj,vector<int>& dist,vector<bool>& vis){\r\n//     vis[s]=true;\r\n//     for( auto child:adj[s]){\r\n//         if (!vis[child]){\r\n//         dist[child]=dist[s]+1;\r\n//         dfs(child,adj,dist,vis);\r\n//         }\r\n//     }\r\n//  }\r\n//  void dfs(int s,vector<vector<int>>& adj,vector<bool>& vis,int mx,int curr,int m,int& res,vector<int>& cats){\r\n//     vis[s]=true;\r\n//     int count=0;\r\n//     // cout<<s<<\" \"<<mx<<\" check\"<<endl;\r\n//     for(auto child:adj[s]){\r\n//         if (!vis[child]){\r\n//             int n_mx,n_curr;\r\n//             count++;\r\n//             if (cats[child]==1){\r\n//                 n_curr=curr+1;\r\n//                 n_mx=max(mx,n_curr);\r\n//             }\r\n//             else{\r\n//                 n_curr=0;\r\n//                 n_mx=max(n_curr,mx);\r\n//             }\r\n//             dfs(child,adj,vis,n_mx,n_curr,m,res,cats);\r\n//         }\r\n//     }\r\n//     if (count==0 && mx<=m) res++; \r\n//  }\r\n// void dfs(int s,vector<vector<int>>& adj,vector<bool>& vis,vector<int>& comp){\r\n//     vis[s]=true;\r\n//     for(auto child:adj[s]){\r\n//         if (!vis[child]){\r\n//             comp.push_back(child);\r\n//             dfs(child,adj,vis,comp);\r\n//         }\r\n//     }\r\n// }\r\n\r\n// void dfs(int s,vector<vector<int>>& adj,vector<bool>& vis,vector<int>& color,bool& valid,vector<int>& par){\r\n//         vis[s]=true;\r\n//         for(auto child:adj[s]){\r\n//             if (!vis[child]){\r\n//                 par[child]=s;\r\n//                 if (color[s]==0){\r\n//                     color[child]=1;\r\n//                     dfs(child,adj,vis,color,valid,par);\r\n//                 }\r\n//                 else{\r\n//                     color[child]=0;\r\n//                     dfs(child,adj,vis,color,valid,par);\r\n//                 }\r\n//             }\r\n//             else{\r\n//                 if (par[s]!=child && color[child]==color[s]) valid=false;\r\n//                 // if(!valid ) break;\r\n//             }\r\n//         }\r\n\r\n// }\r\n// int diff(string a,string b){\r\n//     int i=0,j=0;\r\n//     while(i<a.length() && j<b.length() && a[i]==b[j]){\r\n//         i++;\r\n//         j++;\r\n//     }\r\n//      return j;\r\n    \r\n// }\r\n\r\n// void dfs(pair<int,int> s,vector<string>& grid,set<pair<int,int>>& vis){\r\n//     vis.insert(s);\r\n//     int xc=s.first,yc=s.second;\r\n//     vector<pair<int,int>> moves={{xc-1,yc-1},{xc-1,yc+1},{xc+1,yc-1},{xc+1,yc+1}};\r\n//     for(auto move:moves){\r\n//         int xn=move.first,yn=move.second;\r\n//         if (xn>=0 && xn<grid.size() && yn>=0 && yn<grid[0].length()){\r\n//             if (!vis.count({xn,yn}) && grid[xn][yn]=='#'){\r\n//                 dfs(move,grid,vis);\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\nvoid dfs(int a,vector<bool>& vis1,stack<int>& timer,vector<vector<int>>& adj){\r\n    vis1[a]=true;\r\n    for(int b:adj[a]){\r\n        if (!vis1[b]) dfs(b,vis1,timer,adj);\r\n    }\r\n    timer.push(a);\r\n    // cout<<a<<endl;\r\n \r\n}\r\n\r\nvoid dfs2(int a,vector<int>& scc,vector<bool>& vis2,vector<vector<int>>& radj,int count,vector<int>& mp){\r\n    scc.push_back(a);\r\n    mp[a]=count;\r\n    vis2[a]=true;\r\n    for(int b:radj[a]){\r\n        if (!vis2[b])\r\n        dfs2(b,scc,vis2,radj,count,mp);\r\n    }\r\n}\r\n\r\n\r\n\r\nint main(){\r\n    int n,k;\r\n    cin>> n>>k;\r\n    vector<vector<int>> adj(n+1),radj(n+1);\r\n    vector<int> p(n),q(n);\r\n    string res=\"\";\r\n    for(int i=0;i<n;i++){\r\n        cin>>p[i];\r\n        res+=\"a\";\r\n\r\n\r\n    }\r\n    for(int i=0;i<n;i++){\r\n        cin>>q[i];\r\n    }\r\n    for(int i=1;i<n;i++){\r\n        adj[p[i-1]].push_back(p[i]);\r\n        radj[p[i]].push_back(p[i-1]);\r\n        adj[q[i-1]].push_back(q[i]);\r\n        radj[q[i]].push_back(q[i-1]);\r\n\r\n    }\r\n    // for(int i=1;i<=n;i++){\r\n    //     cout<<\"adj to \"<<i<<endl;\r\n    //     for(int j=0;j<adj[i].size();j++){\r\n    //         cout<<adj[i][j]<<\" \";\r\n\r\n    //     }\r\n    //     cout<<endl;\r\n    //     cout<<\"radj to \"<<i<<endl;\r\n    //     for(int j=0;j<radj[i].size();j++){\r\n    //         cout<<radj[i][j]<<\" \";\r\n\r\n    //     }\r\n    //     cout<<endl;\r\n    // }\r\n    vector<bool> vis1(n+1,false);\r\n    stack<int> timer;\r\n    for(int i=1;i<=n;i++){\r\n          if (!vis1[i]) dfs(i,vis1,timer,adj);\r\n    }\r\n    // cout<<timer.size()<<endl;\r\n    vector<vector<int>> sccs;\r\n    int count=0;\r\n    vector<int> mp(n+1,-1);\r\n    vector<bool> vis2(n+1,false);\r\n        while(!timer.empty()){\r\n        int node=timer.top();\r\n        timer.pop();\r\n        vector<int> scc;\r\n        if (!vis2[node]){\r\n            dfs2(node,scc,vis2,radj,count,mp);\r\n            sccs.push_back(scc);\r\n            count++;\r\n        }\r\n        // cout<<count<<endl;\r\n        \r\n \r\n \r\n        }\r\n        if (count<k) cout<<\"NO\"<<endl;\r\n        else{\r\n        vector<bool> vis(n+1,false);\r\n        string check=\"abcdefghijklmnopqrstuvwxyz\";\r\n        int counter=0;\r\n        for(int i=1;i<=n;i++){\r\n            // if (!vis[i]){\r\n            //     vis[i]=true;\r\n            //     for(int j=0;j<sccs[mp[i]].size();j++){\r\n            //         if (counter<26) res[sccs[mp[i]][j]-1]=check[counter];\r\n            //         else{\r\n            //             res[j]='z';\r\n            //         }\r\n            //         vis[sccs[mp[i]][j]]=true;\r\n            //     }\r\n            //     counter++;\r\n            // }\r\n            if (mp[i]<26) res[i-1]=check[mp[i]];\r\n            else{\r\n                res[i-1]='z';\r\n            }\r\n\r\n        }\r\n        cout<<\"YES\"<<endl;\r\n        cout<<res<<endl;\r\n        }\r\n\r\n        \r\n\r\n\r\n  \r\n      \r\n         \r\n    \r\n\r\n\r\n        \r\n    \r\n    \r\n \r\n    \r\n \r\n   \r\n    return 0;\r\n}"
}