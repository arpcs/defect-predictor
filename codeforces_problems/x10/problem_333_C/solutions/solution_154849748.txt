{
    "id": 154849748,
    "contestId": 333,
    "creationTimeSeconds": 1650803053,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 333,
        "index": "C",
        "name": "Lucky Tickets",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2700,
        "tags": [
            "brute force",
            "constructive algorithms"
        ]
    },
    "author": {
        "contestId": 333,
        "members": [
            {
                "handle": "crowdforces"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1374913800
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <experimental/random>\n\nclass EmptyList { };\nclass EmptyDict { };\n\ntemplate <class T, class S>\nstruct CommonType { };\n\nstruct String;\n\ntemplate <class T>\nstruct List {\n    std::shared_ptr<std::vector<T>> inner;\n\n    List() : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>())) {}\n    List(std::vector<T> a) : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>(a))) {}\n    template <class S>\n    List(List<S> a) : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>(a.inner->begin(), a.inner->end()))) {}\n    List(EmptyList) : inner(std::shared_ptr<std::vector<T>>(new std::vector<T>())) {}\n    T &operator[](size_t index) { return (*inner)[index]; }\n    const T &operator[](size_t index) const { return (*inner)[index]; }\n    void push(T value) { inner->push_back(value); }\n    void pop() { inner->pop_back(); }\n    int64_t length() const { return inner->size(); }\n\n    template <class SortFn>\n    void sort(SortFn sortFn) { std::sort(inner->begin(), inner->end(), sortFn); }\n\n    template <class S>\n    List<typename CommonType<T, S>::inner> concat(List<S> other) { List<typename CommonType<T, S>::inner> ret = EmptyList(); ret.inner->insert(ret.inner->end(), inner->begin(), inner->end()); ret.inner->insert(ret.inner->end(), other.inner->begin(), other.inner->end()); return ret; }\n    String join(String delim);\n};\n\nstruct String {\n    std::shared_ptr<std::string> inner;\n\n    String() : inner(std::shared_ptr<std::string>(new std::string())) {}\n    String(const char* a) : inner(std::shared_ptr<std::string>(new std::string(a))) {}\n    String(std::string a) : inner(std::shared_ptr<std::string>(new std::string(a))) {}\n    String operator +(String other) { return String(*inner + *other.inner); }\n    operator std::string() { return *inner; }\n    String operator[](size_t index) const { return String(std::string({(*inner)[index]})); }\n    int64_t charCodeAt(size_t index) const { return (*inner)[index]; }\n    String operator+(String &other) const { return String(*inner + *other.inner); }\n    String& operator+=(const String &other) { *inner += *other.inner; return *this; }\n    char operator <(const String &other) const { return *inner < *other.inner; }\n    char operator >(const String &other) const { return *inner > *other.inner; }\n    char operator <=(const String &other) const { return *inner <= *other.inner; }\n    char operator >=(const String &other) const { return *inner >= *other.inner; }\n    char operator ==(const String &other) const { return *inner == *other.inner; }\n    char operator !=(const String &other) const { return *inner != *other.inner; }\n    int64_t length() const { return inner->size(); }\n\n    String trim() {\n        std::string s = *inner;\n        const char* ws = \" \\t\\n\\r\\f\\v\";\n        s.erase(s.find_last_not_of(ws) + 1);\n        s.erase(0, s.find_first_not_of(ws));\n        return String(s);\n    }\n    List<String> split(String delim) { std::vector<String> ret; size_t last = 0; size_t next = 0; while ((next = inner->find(*delim.inner, last)) != std::string::npos) {   ret.push_back(String(inner->substr(last, next-last)));   last = next + delim.length(); } ret.push_back(String(inner->substr(last))); return ret; }\n};\n\ntemplate<> String List<String>::join(String delim) {\n    std::string ret; bool first = true; for (const auto& it: *inner) { if (!first) ret += *delim.inner; first = false; ret += *it.inner; } return ret;\n}\n\ntemplate <class K, class V> \nstruct Dict {\n    using Inner = __gnu_pbds::tree<K, V, std::less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n    std::shared_ptr<Inner> inner;\n\n    Dict() : inner(std::shared_ptr<Inner>(new Inner())) {}\n    Dict(std::vector<std::pair<K, V>> a) : inner(std::shared_ptr<Inner>(new Inner(a.begin(), a.end()))) {}\n    template <class K2, class V2>\n    Dict(Dict<K2, V2> a) : inner(std::shared_ptr<Inner>(new Inner(a.inner->begin(), a.inner->end()))) {}\n    Dict(EmptyDict) : inner(std::shared_ptr<Inner>(new Inner())) {}\n    V &operator[](K key) { return (*inner)[key]; }\n    const V &operator[](K key) const { return (*inner)[key]; }\n    int64_t length() const { return inner->size(); }\n    bool contains(const K& k) const { return inner->find(k) != inner->end(); }\n    void remove(const K& k) const { inner->erase(k); }\n    K keyAt(int64_t pos) const { return inner->find_by_order(pos)->first; }\n    int64_t bisect(const K& value) const { return inner->order_of_key(value); }\n\n    List<K> keys() const { std::vector<K> ret; for (auto const& it: *inner) { ret.push_back(it.first); }; return List<K>(ret); }\n};\n\ntemplate <class T> struct CommonType<List<T>, EmptyList> { using inner = List<T>; };\ntemplate <class T> struct CommonType<EmptyList, List<T>> { using inner = List<T>; };\ntemplate <class T, class S> struct CommonType<List<T>, List<S>> { using inner = List<typename CommonType<T, S>::inner>; };\n\ntemplate <class T> struct CommonType<std::nullptr_t, std::shared_ptr<T>> { using inner = std::shared_ptr<T>; };\ntemplate <class T> struct CommonType<std::shared_ptr<T>, std::nullptr_t> { using inner = std::shared_ptr<T>; };\n\ntemplate <class K, class V> struct CommonType<Dict<K, V>, EmptyDict> { using inner = Dict<K, V>; };\ntemplate <class K, class V> struct CommonType<EmptyDict, Dict<K, V>> { using inner = Dict<K, V>; };\ntemplate <class K, class V, class K2, class V2> struct CommonType<Dict<K, V>, Dict<K2, V2>> { using inner = Dict<typename CommonType<K, K2>::inner, typename CommonType<V, V2>::inner>; };\n\ntemplate <> struct CommonType<int64_t, int64_t> { using inner = int64_t; };\ntemplate <> struct CommonType<EmptyList, EmptyList> { using inner = EmptyList; };\ntemplate <> struct CommonType<EmptyDict, EmptyDict> { using inner = EmptyDict; };\ntemplate <> struct CommonType<std::nullptr_t, std::nullptr_t> { using inner = std::nullptr_t; };\ntemplate <> struct CommonType<char, char> { using inner = char; };\ntemplate <> struct CommonType<String, String> { using inner = String; };\n\nint64_t cast_int(int64_t x) { return x; }\nint64_t cast_int(double x) { return x; }\nint64_t cast_int(String x) { return std::strtoll(x.inner->c_str(), NULL, 10); }\n\ndouble cast_float(int64_t x) { return x; }\ndouble cast_float(double x) { return x; }\ndouble cast_float(String x) { return std::strtod(x.inner->c_str(), NULL); }\n\nString cast_str(int64_t x) { return String(std::to_string(x)); }\nString cast_str(double x) { return String(std::to_string(x)); }\nString cast_str(bool x) { return String(std::to_string(x)); }\nString cast_str(String x) { return x; }\n\nbool rand_bool() { return rand() % 100 < 50; }\nint64_t rand_int(int64_t upper) { return std::experimental::randint(int64_t(0), upper); }\nString chr(int64_t x) { return String(std::string({(char)x})); }\n\ntemplate <class T>\nstruct TypeHolder { };\n\ntemplate <class T, class S, class Filter, class Mapper>\nList<T> linq(const List<S> &input, Filter filter, Mapper mapper, TypeHolder<T> type_holder) {\n    List<T> ret;\n    for (const auto &it: *input.inner) {\n        if (filter(it)) {\n            ret.push(mapper(it));\n        }\n    }\n    return ret;\n}\n\n\nint64_t abs(int64_t a);\nvoid generate(int64_t v, int64_t rem, int64_t k, int64_t head, Dict<int64_t,char> q);\nString solve(String input);\nint64_t abs(int64_t a) {\nif ((a>=0ll)) {\nreturn a;\n}\nreturn (- a);\n}\nvoid generate(int64_t v, int64_t rem, int64_t k, int64_t head, Dict<int64_t,char> q) {\nif ((rem==0ll)) {\nint64_t dif = (abs)(((abs)(v)-k));\nif ((dif<10000ll)) {\n(q)[(dif+(head*10000ll))] = true;\n(q)[((dif*10000ll)+head)] = true;\n}\nreturn;\n}\n(generate)((v+(rem%10ll)), (rem/10ll), k, head, q);\n(generate)((v-(rem%10ll)), (rem/10ll), k, head, q);\n(generate)((v*((rem%10ll))), (rem/10ll), k, head, q);\n}\nString solve(String input) {\nList<String> lines = (input).split(String(\"\\n\"));\nList<int64_t> km = linq(((lines)[0ll]).split(String(\" \")), [=](String x) { return true;  }, [=](String x) { return cast_int(x); }, TypeHolder<int64_t>());\nint64_t k = (km)[0ll];\nint64_t m = (km)[1ll];\nDict<int64_t,char> q = Dict<int64_t,char>(std::vector<std::pair<int64_t, char>>({{0ll,false}}));\n(q).remove(0ll);\nfor (int64_t i = 0ll; (i<10000ll); i+=1ll) {\n(generate)((i%10ll), (i/10ll), k, i, q);\n\n}\nString ans = String(\"\");\nList<int64_t> qq = (q).keys();\nfor (int64_t i = 0ll; (i<m); i+=1ll) {\nString now = cast_str((qq)[i]);\nint64_t t = (8ll-(int64_t)((now).length()));\nfor (int64_t j = 0ll; (j<t); j+=1ll) {\nans+=String(\"0\");\n\n}\nans+=(now+String(\"\\n\"));\n\n}\nreturn ans;\n}\nint main() { std::ios::sync_with_stdio(false) ; std::cin.tie(0) ; std::cout.tie(0) ; std::string line, input; while (std::getline(std::cin, line)) { input += line + \"\\n\"; } std::cout << *solve(String(input)).inner; return 0; }/*1650803052.368876*/"
}