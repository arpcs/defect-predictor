{
    "id": 219792848,
    "contestId": 79,
    "creationTimeSeconds": 1692622498,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 79,
        "index": "C",
        "name": "Beaver",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1800,
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "hashing",
            "strings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 79,
        "members": [
            {
                "handle": "Code_Hard10"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1304175600
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 80,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 63897600,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#include <x86intrin.h>\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define Int(...)   \\\r\n  int __VA_ARGS__; \\\r\n  read(__VA_ARGS__)\r\n#define Ll(...)   \\\r\n  long long __VA_ARGS__; \\\r\n  read(__VA_ARGS__)\r\n#define Dbl(...)   \\\r\n  double __VA_ARGS__; \\\r\n  read(__VA_ARGS__)\r\n#define Chr(...)      \\\r\n  char __VA_ARGS__; \\\r\n  read(__VA_ARGS__)\r\n#define Str(...)      \\\r\n  string __VA_ARGS__; \\\r\n  read(__VA_ARGS__)\r\n#define Vt(type, name, size) \\\r\n  vector<type> name(size);    \\\r\n  read(name)\r\n#define Vvt(type, name, h, w)                     \\\r\n  vector<vector<type>> name(h, vector<type>(w)); \\\r\n  read(name)\r\n#define Die(...)             \\\r\n  do {                       \\\r\n    print(__VA_ARGS__); \\\r\n    return 0;                  \\\r\n  } while (0)\r\n\r\n#define vv(type, name, h, ...) \\\r\n  vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\r\n#define vvv(type, name, h, w, ...)   \\\r\n  vector<vector<vector<type>>> name( \\\r\n      h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\r\n#define vvvv(type, name, a, b, c, ...)       \\\r\n  vector<vector<vector<vector<type>>>> name( \\\r\n      a, vector<vector<vector<type>>>(       \\\r\n             b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\r\n\r\n#define DETAIL_OVERLOAD2(_1,_2,name,...) name\r\n#define DETAIL_OVERLOAD3(_1,_2,_3,name,...) name\r\n#define DETAIL_OVERLOAD4(_1,_2,_3,_4,name,...) name\r\n\r\n#define DETAIL_REP4(i,l,r,s)  for(std::remove_reference_t<std::remove_const_t<decltype(r)>>i=(l);i<(r);i+=(s))\r\n#define DETAIL_REP3(i,l,r)    DETAIL_REP4(i,l,r,1)\r\n#define DETAIL_REP2(i,n)      DETAIL_REP3(i,0,n)\r\n#define DETAIL_RREP4(i,l,r,s) for(std::remove_reference_t<std::remove_const_t<decltype(r)>>i=(l)+floor((r)-(l)-1,s)*(s);i>=(l);i-=(s))\r\n#define DETAIL_RREP3(i,l,r)   DETAIL_RREP4(i,l,r,1)\r\n#define DETAIL_RREP2(i,n)     DETAIL_RREP3(i,0,n)\r\n\r\n#define DETAIL_CAT_I(a, b) a##b\r\n#define DETAIL_CAT(a, b) DETAIL_CAT_I(a, b)\r\n#define DETAIL_UNIQVAR(tag) DETAIL_CAT(tag, __LINE__)\r\n\r\n#define For(...)    DETAIL_OVERLOAD4(__VA_ARGS__, DETAIL_REP4   , DETAIL_REP3   , DETAIL_REP2   )(__VA_ARGS__)\r\n#define Frr(...)   DETAIL_OVERLOAD4(__VA_ARGS__, DETAIL_RREP4  , DETAIL_RREP3  , DETAIL_RREP2  )(__VA_ARGS__)\r\n#define Loop(n) for (std::remove_reference_t<std::remove_const_t<decltype(n)>> DETAIL_UNIQVAR(loop_variable) = n; DETAIL_UNIQVAR(loop_variable) --> 0;)\r\n#define Each(x, iterable) for (auto &&x: iterable)\r\n\r\n#define All(iterable) std::begin(iterable), std::end(iterable)\r\n#define len(iterable) (long long) iterable.size()\r\n#define elif else if\r\n\r\nusing str = string;\r\n\r\nnamespace Trait_Base {\r\n    template <typename ...Constraints> using constraints_t = std::enable_if_t<std::conjunction_v<Constraints...>, std::nullptr_t>;\r\n\r\n    template <typename T, typename = std::nullptr_t> struct bitnum { static constexpr int value = 0; };\r\n    template <typename T> struct bitnum<T, constraints_t<std::is_integral<T>>> { static constexpr int value = std::numeric_limits<std::make_unsigned_t<T>>::digits; };\r\n    template <typename T> static constexpr int bitnum_v = bitnum<T>::value;\r\n    template <typename T, size_t n> struct is_nbit { static constexpr bool value = bitnum_v<T> == n; };\r\n    template <typename T, size_t n> static constexpr bool is_nbit_v = is_nbit<T, n>::value;\r\n\r\n    template <typename T, typename = std::nullptr_t> struct safely_multipliable { using type = T; };\r\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_signed<T>, is_nbit<T, 32>>> { using type = long long; };\r\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_signed<T>, is_nbit<T, 64>>> { using type = __int128_t; };\r\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_unsigned<T>, is_nbit<T, 32>>> { using type = unsigned long long; };\r\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_unsigned<T>, is_nbit<T, 64>>> { using type = __uint128_t; };\r\n    template <typename T> using safely_multipliable_t = typename safely_multipliable<T>::type;\r\n\r\n    template <typename T, typename = void> struct rec_value_type { using type = T; };\r\n    template <typename T> struct rec_value_type<T, std::void_t<typename T::value_type>> {\r\n        using type = typename rec_value_type<typename T::value_type>::type;\r\n    };\r\n    template <typename T> using rec_value_type_t = typename rec_value_type<T>::type;\r\n\r\n    template <typename T> class is_iterable {\r\n        template <typename T_> static auto test(T_ e) -> decltype(e.begin(), e.end(), std::true_type{});\r\n        static std::false_type test(...);\r\n    public:\r\n        static constexpr bool value = decltype(test(std::declval<T>()))::value;\r\n    };\r\n    template <typename T> static constexpr bool is_iterable_v = is_iterable<T>::value;\r\n    template <typename T> class is_writable {\r\n        template <typename T_> static auto test(T_ e) -> decltype(std::declval<std::ostream&>() << e, std::true_type{});\r\n        static std::false_type test(...);\r\n    public:\r\n        static constexpr bool value = decltype(test(std::declval<T>()))::value;\r\n    };\r\n    template <typename T> static constexpr bool is_writable_v = is_writable<T>::value;\r\n    template <typename T> class is_readable {\r\n        template <typename T_> static auto test(T_ e) -> decltype(std::declval<std::istream&>() >> e, std::true_type{});\r\n        static std::false_type test(...);\r\n    public:\r\n        static constexpr bool value = decltype(test(std::declval<T>()))::value;\r\n    };\r\n    template <typename T> static constexpr bool is_readable_v = is_readable<T>::value;\r\n}\r\n\r\nnamespace Fast::io {\r\n    template <typename IStream, std::enable_if_t<std::conjunction_v<std::is_base_of<std::istream, std::remove_reference_t<IStream>>, std::negation<std::is_const<std::remove_reference_t<IStream>>>>, std::nullptr_t> = nullptr>\r\n    struct InputStream {\r\n    private:\r\n        using istream_type = std::remove_reference_t<IStream>;\r\n        IStream is;\r\n        struct { InputStream* is; template <typename T> operator T() { T e; *is >> e; return e; } } _reader{ this };\r\n    public:\r\n        template <typename IStream_> InputStream(IStream_ &&is) : is(std::move(is)) {}\r\n        template <typename IStream_> InputStream(IStream_ &is) : is(is) {}\r\n        template <typename T> InputStream& operator>>(T& e) {\r\n            if constexpr (Trait_Base::is_readable_v<T>) is >> e; else _read(e);\r\n            return *this;\r\n        }\r\n        auto read() { return _reader; }\r\n        template <typename Head, typename... Tail>\r\n        void read(Head& head, Tail &...tails) { ((*this >> head) >> ... >> tails); }\r\n        istream_type& get_stream() { return is; }\r\n    private:\r\n        static __uint128_t _stou128(const std::string& s) {\r\n            __uint128_t ret = 0;\r\n            for (char c : s) if ('0' <= c and c <= '9') ret = 10 * ret + c - '0';\r\n            return ret;\r\n        }\r\n        static __int128_t _stoi128(const std::string& s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }\r\n\r\n        void _read(__uint128_t& v) { v = _stou128(std::string(_reader)); }\r\n        void _read(__int128_t& v) { v = _stoi128(std::string(_reader)); }\r\n        template <typename T, typename U>\r\n        void _read(std::pair<T, U>& a) { *this >> a.first >> a.second; }\r\n        template <size_t N = 0, typename ...Args>\r\n        void _read(std::tuple<Args...>& a) { if constexpr (N < sizeof...(Args)) *this >> std::get<N>(a), _read<N + 1>(a); }\r\n        template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\r\n        void _read(Iterable& a) { for (auto& e : a) *this >> e; }\r\n    };\r\n    template <typename IStream>\r\n    InputStream(IStream &&) -> InputStream<IStream>;\r\n    template <typename IStream>\r\n    InputStream(IStream &) -> InputStream<IStream&>;\r\n\r\n    InputStream cin{ std::cin };\r\n\r\n    auto read() { return cin.read(); }\r\n    template <typename Head, typename... Tail>\r\n    void read(Head& head, Tail &...tails) { cin.read(head, tails...); }\r\n}\r\n\r\nnamespace Fast::io {\r\n    template <typename OStream, std::enable_if_t<std::conjunction_v<std::is_base_of<std::ostream, std::remove_reference_t<OStream>>, std::negation<std::is_const<std::remove_reference_t<OStream>>>>, std::nullptr_t> = nullptr>\r\n    struct OutputStream {\r\n    private:\r\n        using ostream_type = std::remove_reference_t<OStream>;\r\n        OStream os;\r\n    public:\r\n        template <typename OStream_> OutputStream(OStream_ &&os) : os(std::move(os)) {}\r\n        template <typename OStream_> OutputStream(OStream_ &os) : os(os) {}\r\n        template <typename T> OutputStream& operator<<(const T& e) {\r\n            if constexpr (Trait_Base::is_writable_v<T>) os << e; else _print(e);\r\n            return *this;\r\n        }\r\n        void print() { *this << '\\n'; }\r\n        template <typename Head, typename... Tail>\r\n        void print(const Head& head, const Tail &...tails) { *this << head, ((*this << ' ' << tails), ...), *this << '\\n'; }\r\n        template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\r\n        void print_all(const Iterable& v, std::string sep = \" \", std::string end = \"\\n\") {\r\n            for (auto it = v.begin(); it != v.end();) if (*this << *it; ++it != v.end()) *this << sep;\r\n            *this << end;\r\n        }\r\n        ostream_type& get_stream() { return os; }\r\n    private:\r\n        void _print(__uint128_t value) {\r\n            char buffer[41], *d = std::end(buffer);\r\n            do *--d = '0' + (value % 10), value /= 10; while (value);\r\n            os.rdbuf()->sputn(d, std::end(buffer) - d);\r\n        }\r\n        void _print(__int128_t value) {\r\n            if (value < 0) *this << '-';\r\n            _print(__uint128_t(value < 0 ? -value : value));\r\n        }\r\n        template <typename T, typename U>\r\n        void _print(const std::pair<T, U>& a) { *this << a.first << ' ' << a.second; }\r\n        template <size_t N = 0, typename ...Args>\r\n        void _print(const std::tuple<Args...>& a) {\r\n            if constexpr (N < std::tuple_size_v<std::tuple<Args...>>) {\r\n                if constexpr (N) *this << ' ';\r\n                *this << std::get<N>(a), _print<N + 1>(a);\r\n            }\r\n        }\r\n        template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\r\n        void _print(const Iterable& a) { print_all(a, \" \", \"\"); }\r\n    };\r\n    template <typename OStream_>\r\n    OutputStream(OStream_ &&) -> OutputStream<OStream_>;\r\n    template <typename OStream_>\r\n    OutputStream(OStream_ &) -> OutputStream<OStream_&>;\r\n\r\n    OutputStream cout{ std::cout }, cerr{ std::cerr };\r\n\r\n    template <typename... Args>\r\n    void print(const Args &... args) { cout.print(args...); }\r\n    template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\r\n    void print_all(const Iterable& v, const std::string& sep = \" \", const std::string& end = \"\\n\") { cout.print_all(v, sep, end); }\r\n}\r\nusing Fast::io::read;\r\nusing Fast::io::print;\r\nusing Fast::io::print_all;\r\n\r\nnamespace Helpers {\r\n    template <class T, class ToKey, class CompKey = std::less<>, std::enable_if_t<std::conjunction_v<std::is_invocable<ToKey, T>, std::is_invocable_r<bool, CompKey, std::invoke_result_t<ToKey, T>, std::invoke_result_t<ToKey, T>>>, std::nullptr_t> = nullptr>\r\n    auto comparator(const ToKey& to_key, const CompKey& comp_key = std::less<>()) {\r\n        return [=](const T& x, const T& y) { return comp_key(to_key(x), to_key(y)); };\r\n    }\r\n    template <class Compare, std::enable_if_t<std::is_invocable_r_v<bool, Compare, int, int>, std::nullptr_t> = nullptr>\r\n    std::vector<int> sorted_indices(int n, const Compare& compare) {\r\n        std::vector<int> p(n);\r\n        return std::iota(p.begin(), p.end(), 0), std::sort(p.begin(), p.end(), compare), p;\r\n    }\r\n    template <class ToKey, std::enable_if_t<std::is_invocable_v<ToKey, int>, std::nullptr_t> = nullptr>\r\n    std::vector<int> sorted_indices(int n, const ToKey& to_key) { return sorted_indices(n, comparator<int>(to_key)); }\r\n    template <class T, class Comparator>\r\n    auto priority_queue_with_comparator(const Comparator& comparator) { return std::priority_queue<T, std::vector<T>, Comparator>{ comparator }; }\r\n    template <class Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\r\n    void sort_unique_erase(Iterable& a) { std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); }\r\n} using namespace Helpers;\r\n\r\ntemplate <class T>\r\nconstexpr T inf = 0;\r\ntemplate <>\r\nconstexpr int inf<int> = 1000000005;\r\ntemplate <>\r\nconstexpr long long inf<long long> = (long long)(inf<int>) * inf<int> * 2;\r\ntemplate <>\r\nconstexpr unsigned int inf<unsigned int> = inf<int>;\r\ntemplate <>\r\nconstexpr unsigned long long inf<unsigned long long> = inf<long long>;\r\ntemplate <>\r\nconstexpr __int128 inf<__int128> = __int128(inf<long long>) * inf<long long>;\r\ntemplate <>\r\nconstexpr double inf<double> = inf<long long>;\r\ntemplate <>\r\nconstexpr long double inf<long double> = inf<long long>;\r\n\r\nnamespace Utils {\r\n    template<typename T>\r\n    inline bool chmin(T &x, const T &y) { return y >= x ? false : (x = y, true); }\r\n    template<typename T>\r\n    inline bool chmax(T &x, const T &y) { return y <= x ? false : (x = y, true); }\r\n    template<typename T, typename U>\r\n    T ceil(T x, U y) { return (x > 0 ? (x + y - 1) / y : x / y); }\r\n    template<typename T, typename U>\r\n    T floor(T x, U y) { return (x > 0 ? x / y : (x - y + 1) / y); }\r\n\r\n    __attribute__((target(\"popcnt\"))) inline int popcnt(const unsigned long long &a) { return _mm_popcnt_u64(a); }\r\n    inline int lsb(const unsigned long long &a) { return a ? __builtin_ctzll(a) : 64; }\r\n    inline int msb(const unsigned long long &a) { return a ? 63 - __builtin_clzll(a) : -1; }\r\n    constexpr long long Pw(int n) { return ((long long) 1) << n; }\r\n    constexpr long long Msk(int n) { return (((long long) 1) << n) - 1; }\r\n} using namespace Utils;\r\n\r\ntemplate <typename STRING>  // string, vector \u3069\u3061\u3089\u3067\u3082\r\nvector<int> zalgorithm(const STRING& s) {\r\n    int n = int(s.size());\r\n    if (n == 0) return {};\r\n    vector<int> z(n);\r\n    z[0] = 0;\r\n    for (int i = 1, j = 0; i < n; i++) {\r\n        int& k = z[i];\r\n        k = (j + z[j] <= i) ? 0 : min(j + z[j] - i, z[i - j]);\r\n        while (i + k < n && s[k] == s[i + k]) k++;\r\n        if (j + z[j] < i + z[i]) j = i;\r\n    }\r\n    z[0] = n;\r\n    return z;\r\n}\r\n\r\n// \u51aa\u7b49\u306a\u30e2\u30ce\u30a4\u30c9\u3067\u3042\u308b\u3053\u3068\u3092\u4eee\u5b9a\u3002disjoint sparse table \u3088\u308a x \u500d\u9ad8\u901f\r\ntemplate <class Monoid>\r\nstruct Sparse_Table {\r\n    using MX = Monoid;\r\n    using X = typename MX::value_type;\r\n    int n, log;\r\n    vector<vector<X>> dat;\r\n\r\n    Sparse_Table() {}\r\n    Sparse_Table(int n) { build(n); }\r\n    template <typename F>\r\n    Sparse_Table(int n, F f) {\r\n        build(n, f);\r\n    }\r\n    Sparse_Table(const vector<X>& v) { build(v); }\r\n\r\n    void build(int m) {\r\n        build(m, [](int i) -> X { return MX::unit(); });\r\n    }\r\n    void build(const vector<X>& v) {\r\n        build(len(v), [&](int i) -> X { return v[i]; });\r\n    }\r\n    template <typename F>\r\n    void build(int m, F f) {\r\n        n = m, log = 1;\r\n        while ((1 << log) < n) ++log;\r\n        dat.resize(log);\r\n        dat[0].resize(n);\r\n        for(int i = 0; i < n; i++) dat[0][i] = f(i);\r\n\r\n        for(int i = 0; i < log - 1; i++) {\r\n            dat[i + 1].resize(len(dat[i]) - (1 << i));\r\n            for(int j = 0; j < len(dat[i]) - (1 << i); j++) {\r\n                dat[i + 1][j] = MX::op(dat[i][j], dat[i][j + (1 << i)]);\r\n            }\r\n        }\r\n    }\r\n\r\n    X prod(int L, int R) {\r\n        if (L == R) return MX::unit();\r\n        if (R == L + 1) return dat[0][L];\r\n        int k = (R - L - 1 == 0 ? -1 : 31 - __builtin_clz(R - L - 1));\r\n        return MX::op(dat[k][L], dat[k][R - (1 << k)]);\r\n    }\r\n\r\n    template <class F>\r\n    int max_right(const F check, int L) {\r\n        assert(0 <= L && L <= n && check(MX::unit()));\r\n        if (L == n) return n;\r\n        int ok = L, ng = n + 1;\r\n        while (ok + 1 < ng) {\r\n            int k = (ok + ng) / 2;\r\n            bool bl = check(prod(L, k));\r\n            if (bl) ok = k;\r\n            if (!bl) ng = k;\r\n        }\r\n        return ok;\r\n    }\r\n\r\n    template <class F>\r\n    int min_left(const F check, int R) {\r\n        assert(0 <= R && R <= n && check(MX::unit()));\r\n        if (R == 0) return 0;\r\n        int ok = R, ng = -1;\r\n        while (ng + 1 < ok) {\r\n            int k = (ok + ng) / 2;\r\n            bool bl = check(prod(k, R));\r\n            if (bl) ok = k;\r\n            if (!bl) ng = k;\r\n        }\r\n        return ok;\r\n    }\r\n};\r\n\r\ntemplate <typename E>\r\nstruct Monoid_Max {\r\n    using X = E;\r\n    using value_type = X;\r\n    static constexpr X op(const X &x, const X &y) noexcept { return max(x, y); }\r\n    static constexpr X unit() { return -inf<E>; }\r\n    static constexpr bool commute = true;\r\n};\r\n\r\nsigned main(){\r\n    cin.tie(0)->sync_with_stdio(0);\r\n    cin.exceptions(ios::badbit | ios::failbit);\r\n    Str(s);\r\n    Int(n);\r\n    Vt(str, a, n);\r\n    vector<Sparse_Table<Monoid_Max<int>>> Lp(n);\r\n\r\n    For(x, n){\r\n        str f = a[x] + s;\r\n        auto Z = zalgorithm<str>(f);\r\n        Lp[x] = Sparse_Table<Monoid_Max<int>>(len(s), [&](int i){ return Z[len(a[x]) + i]; });\r\n    }\r\n\r\n    vector<int> if_ans(len(s) + 1);\r\n    int ret = *ranges::partition_point(ranges::iota_view(0, len(s) + 1), [&](int p){\r\n        if (not p) return true;\r\n        For(x, len(s) - p + 1) {\r\n            bool now = true;\r\n            For(y, n) {\r\n                if (len(a[y]) > p) continue;\r\n                if (Lp[y].prod(x, x + p - len(a[y]) + 1) >= len(a[y])){\r\n                    now = false;\r\n                    break;\r\n                }\r\n            }\r\n            if_ans[p] = x;\r\n            if (now) return true;\r\n        }\r\n        return false;\r\n    });\r\n    print(ret - 1, if_ans[ret - 1]);\r\n}"
}