{
    "id": 209683519,
    "contestId": 402,
    "creationTimeSeconds": 1686758295,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 402,
        "index": "A",
        "name": "Nuts",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1100,
        "tags": [
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 402,
        "members": [
            {
                "handle": "_andyli"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1394983800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 36,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 2355200,
    "source": "// LUOGU_RID: 112712382\n#include <bits/stdc++.h>\r\n\r\n#ifndef LX_DEBUG\r\n// #define LX_DEBUG\r\n#endif\r\n\r\n#define CHECK_EOF 0\r\n#if CHECK_EOF\r\n#define ECHK0 *ptr ? *ptr++ : -1\r\n#define ECHK1     \\\r\n    if (ch == -1) \\\r\n        return set(false), *this;\r\n#define ECHK2  \\\r\n    if (!*ptr) \\\r\n        return set(false), *this;\r\n#define ECHK3 &&ch != -1\r\n#define ECHK4 &&*ptr\r\n#else\r\n#define ECHK0 *ptr++\r\n#define ECHK1\r\n#define ECHK2\r\n#define ECHK3\r\n#define ECHK4\r\n#endif\r\n\r\n#if defined(__unix__) && !defined(LX_DEBUG) && !defined(LX_LOCAL)\r\n#define USE_MMAP\r\n#include <sys/mman.h>\r\n#include <sys/stat.h>\r\n#endif\r\n\r\n#if CHECK_EOF || !defined(USE_MMAP)\r\n#define EV -1\r\n#else\r\n#define EV 0\r\n#endif\r\n\r\n#define Vec std::vector\r\nusing u8 = unsigned char;\r\nusing u16 = unsigned short;\r\nusing u32 = unsigned int;\r\nusing u64 = unsigned long long;\r\nusing u128 = unsigned __int128;\r\nusing usize = std::size_t;\r\nusing i8 = signed char;\r\nusing i16 = short;\r\nusing i64 = long long;\r\nusing i128 = __int128;\r\nusing ld = long double;\r\nusing vi = Vec<int>;\r\nusing pi = std::pair<int, int>;\r\n\r\n#ifdef LX_LOCAL\r\nnamespace {\r\n    struct Timer {\r\n        clock_t begin;\r\n        Timer(): begin(clock()) {}\r\n        ~Timer() {\r\n            double t = (clock() - begin) * 1000. / CLOCKS_PER_SEC;\r\n            fprintf(stderr, \"\\033[1;32m\");\r\n            if (t >= 60000)\r\n                fprintf(stderr, \"%.2lfmin\\n\", t / 60000.);\r\n            else if (t >= 1000)\r\n                fprintf(stderr, \"%.2lfs\\n\", t / 1000.);\r\n            else\r\n                fprintf(stderr, \"%.0lfms\\n\", t);\r\n            fprintf(stderr, \"\\033[0m\");\r\n        }\r\n    } _;\r\n} // namespace\r\n#endif\r\n\r\n// NOLINTBEGIN\r\n#define FOR1(a) for (std::decay_t<decltype(a)> _ = 0; _ < (a); _++)\r\n#define FOR2(i, a) for (std::decay_t<decltype(a)> i = 0; i < (a); i++)\r\n#define FOR3(i, a, b) for (auto i = a; i < (b); i++)\r\n#define FOR4(i, a, b, c) for (auto i = a; i < (b); i += (c))\r\n#define FOR1_R(a) for (auto i = (a)-1; i >= 0; i--)\r\n#define FOR2_R(i, a) for (auto i = (a)-1; i >= 0; i--)\r\n#define FOR3_R(i, a, b) for (auto i = (b)-1; i >= (a); i--)\r\n#define overload4(a, b, c, d, e, ...) e\r\n#define overload3(a, b, c, d, ...) d\r\n#define _for(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\r\n#define _for_r(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)\r\n#define foreach(x, a) for (auto&& x: a)\r\n#define loop while (true)\r\n// NOLINTEND\r\n\r\ntemplate <typename T>\r\nstruct make_unsigned: public std::make_unsigned<T> {};\r\ntemplate <>\r\nstruct make_unsigned<i128> {\r\n    using type = u128;\r\n};\r\ntemplate <typename T>\r\nconcept tupleLike = requires { typename std::tuple_element_t<0, std::decay_t<T>>; } && !requires (T t) { t[0]; };\r\n\r\ntemplate <typename T, typename U>\r\nconstexpr auto ceil(T&& x, U&& y) { return x > 0 ? (x + y - 1) / y : x / y; }\r\ntemplate <typename T, typename U>\r\nconstexpr auto floor(T&& x, U&& y) { return x > 0 ? x / y : (x - y + 1) / y; }\r\ntemplate <typename T, typename U>\r\nconstexpr auto divmod(T&& x, U&& y) {\r\n    auto&& q = floor(x, y);\r\n    return std::pair{q, x - q * y};\r\n}\r\nconstexpr u64 ten(int t) { return t == 0 ? 1 : ten(t - 1) * 10; }\r\ntemplate <typename T, typename U>\r\nconstexpr std::common_type_t<T, U> max(const T& x, const U& y) { return x < y ? y : x; }\r\ntemplate <typename T, typename U>\r\nconstexpr std::common_type_t<T, U> min(const T& x, const U& y) { return x < y ? x : y; }\r\ntemplate <typename T, typename... Args>\r\nconstexpr std::common_type_t<T, Args...> max(const T& x, const Args&... args) { return max(x, max(args...)); }\r\ntemplate <typename T, typename... Args>\r\nconstexpr std::common_type_t<T, Args...> min(const T& x, const Args&... args) { return min(x, min(args...)); }\r\ntemplate <typename T, typename... Args>\r\nconstexpr void chkmax(T& d, const Args&... args) { d = max(d, args...); }\r\ntemplate <typename T, typename... Args>\r\nconstexpr void chkmin(T& d, const Args&... args) { d = min(d, args...); }\r\ntemplate <std::ranges::forward_range R>\r\nconstexpr auto max(R&& r) { return *std::ranges::max_element(std::forward<R>(r)); }\r\ntemplate <std::ranges::forward_range R>\r\nconstexpr auto min(R&& r) { return *std::ranges::min_element(std::forward<R>(r)); }\r\n\r\ntemplate <std::ranges::forward_range R>\r\nconstexpr auto sum(R&& r) { return std::accumulate(std::ranges::begin(r), std::ranges::end(r), 0); }\r\ntemplate <std::ranges::forward_range R, typename T>\r\nconstexpr auto sum(R&& r, T init) { return std::accumulate(std::ranges::begin(r), std::ranges::end(r), init); }\r\nconstexpr int len(auto&& x) { return std::size(x); }\r\n\r\ntemplate <typename T>\r\nauto psum(const Vec<T>& a) {\r\n    int n = len(a);\r\n    Vec<T> b(len(a) + 1);\r\n    _for (i, n)\r\n        b[i + 1] = b[i] + a[i];\r\n    return b;\r\n}\r\ntemplate <typename T>\r\nauto psum(auto&& a) {\r\n    int n = len(a);\r\n    Vec<T> b(len(a) + 1);\r\n    _for (i, n)\r\n        b[i + 1] = b[i] + a[i];\r\n    return b;\r\n}\r\n\r\ntemplate <typename T, typename... Args>\r\nauto vec(usize n, Args&&... s) {\r\n    if constexpr (!sizeof...(s))\r\n        return Vec<T>(n);\r\n    else\r\n        return Vec(n, vec<T>(s...));\r\n}\r\ntemplate <typename... Args>\r\nauto veci(usize n, Args&&... s) {\r\n    if constexpr (sizeof...(s) == 1)\r\n        return Vec(n, s...);\r\n    else\r\n        return Vec(n, veci(s...));\r\n}\r\n\r\n#define lc (o << 1)\r\n#define rc (o << 1 | 1)\r\n#define lowbit(x) ((x) & (-(x)))\r\n#define all(x) std::begin(x), std::end(x)\r\n#define rall(x) std::rbegin(x), std::rend(x)\r\n#define LB(c, x) std::distance(std::begin(c), std::lower_bound(all(c), (x)))\r\n#define UB(c, x) std::distance(std::begin(c), std::upper_bound(all(c), (x)))\r\n#define UNIQUE(c) std::sort(all(c)), (c).erase(std::unique(all(c)), std::end(c))\r\n#define VEC(type, a, ...) auto a = vec<type>(__VA_ARGS__)\r\n#define VECI(a, ...) auto a = veci(__VA_ARGS__)\r\n#define dR(type, ...) \\\r\n    type __VA_ARGS__; \\\r\n    io.read(__VA_ARGS__)\r\n#define dRV(type, a, ...)      \\\r\n    VEC(type, a, __VA_ARGS__); \\\r\n    io.read(a)\r\n\r\ntemplate <typename T>\r\nvi argsort(Vec<T>& a) {\r\n    vi p(len(a));\r\n    std::iota(all(p), 0);\r\n    std::sort(all(p), [&](int i, int j) { return std::pair{a[i], i} < std::pair{a[j], j}; });\r\n    return p;\r\n}\r\n\r\nstd::mt19937 mrand(std::random_device{}());\r\nstd::mt19937_64 mrand64(std::random_device{}());\r\n\r\nconstexpr usize bufSize = 1 << 20;\r\n\r\nclass IO;\r\nclass In {\r\n    friend class IO;\r\n\r\nprivate:\r\n    FILE* inFile;\r\n    bool status = true;\r\n#ifdef USE_MMAP\r\n    struct stat st;\r\n    char* ptr;\r\n    int fd;\r\n#elif !defined(LX_DEBUG)\r\n    char buf[bufSize], *p1, *p2;\r\n#endif\r\n\r\npublic:\r\n#ifdef LX_DEBUG\r\n    int getch() { return fgetc_unlocked(inFile); }\r\n    void input(FILE* f) { inFile = f, set(); }\r\n#elif defined(USE_MMAP)\r\n    int getch() { return ECHK0; }\r\n    void input(FILE* f) {\r\n        inFile = f;\r\n        if (inFile)\r\n            fd = fileno(inFile), fstat(fd, &st), ptr = (char*)mmap(nullptr, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0), set();\r\n    }\r\n    static constexpr auto n = []() {\r\n        std::array<u32, 0x10000> n{};\r\n        std::fill(all(n), -1);\r\n        constexpr u32 e0 = 0x01, e1 = 0x100;\r\n        int x = 0;\r\n        for (u32 i = 0, c0 = 0x3030; i != 10; i++, c0 += e0)\r\n            for (u32 j = 0, c1 = c0; j != 10; j++, c1 += e1)\r\n                n[c1] = x++;\r\n        return n;\r\n    }();\r\n#else\r\n    int getch() { return (p1 == p2 ? (p2 = (p1 = buf) + fread(buf, 1, bufSize, inFile)) : 0), p1 == p2 ? -1 : *p1++; }\r\n    void input(FILE* f) { inFile = f, p1 = p2 = buf, set(); }\r\n#endif\r\n    void input(const char* s) { input(fopen(s, \"rb\")); }\r\n    void set(bool s = true) { status = s; }\r\n    bool get() const { return status; }\r\n};\r\nclass Out {\r\n    friend class IO;\r\n\r\nprivate:\r\n    FILE* outFile;\r\n#ifndef LX_DEBUG\r\n    char pbuf[bufSize], *pp;\r\n#endif\r\n\r\npublic:\r\n#ifdef LX_DEBUG\r\n    void flush() { outFile ? fflush(outFile) : 0; }\r\n    void putch(char c) { fputc_unlocked(c, outFile); }\r\n#else\r\n    void flush() { (outFile ? fwrite(pbuf, 1, pp - pbuf, outFile), fflush(outFile) : 0), pp = pbuf; }\r\n    void putch(char c) { ((pp - pbuf == bufSize) ? fwrite(pbuf, 1, bufSize, outFile), pp = pbuf : 0), *pp++ = c; }\r\n#endif\r\n    void output(const char* s) { flush(), outFile = fopen(s, \"wb\"); }\r\n    void output(FILE* f) { flush(), outFile = f; }\r\n};\r\nclass IO: public In, public Out {\r\nprivate:\r\n    u32 precision = 12;\r\n\r\npublic:\r\n    IO(FILE* = nullptr, FILE* = nullptr);\r\n    ~IO() { flush(); }\r\n    static constexpr bool blank(char);\r\n    template <typename... Args>\r\n        requires (sizeof...(Args) > 1)\r\n    IO& read(Args&...);\r\n    template <typename T>\r\n        requires std::signed_integral<T> || std::is_same_v<T, i128>\r\n    IO& read(T&);\r\n    template <typename T>\r\n        requires std::unsigned_integral<T> || std::is_same_v<T, u128>\r\n    IO& read(T&);\r\n    template <typename T>\r\n        requires std::floating_point<T>\r\n    IO& read(T&);\r\n    template <typename T>\r\n    T read();\r\n    IO& read(char&);\r\n    IO& read(char*);\r\n    IO& read(std::string&);\r\n    IO& readline(char*);\r\n    IO& readline(std::string&);\r\n    template <tupleLike T>\r\n    IO& read(T&&);\r\n    template <std::ranges::input_range R>\r\n    IO& read(R&& r) { return readArray(std::forward<R>(r)); }\r\n    template <typename T>\r\n        requires requires (T t, IO& io) { t.read(io); }\r\n    IO& read(T& t) { return t.read(*this), *this; }\r\n    void setprecision(u32 n = 6) { precision = n; }\r\n    template <typename... Args>\r\n        requires (sizeof...(Args) > 1)\r\n    void write(Args&&...);\r\n    void write() const {}\r\n    template <typename T>\r\n        requires std::signed_integral<T> || std::is_same_v<T, i128>\r\n    void write(T);\r\n    template <typename T>\r\n        requires std::unsigned_integral<T>\r\n    void write(T);\r\n    void write(u128);\r\n    void write(char c) { putch(c); }\r\n    template <typename T>\r\n        requires std::floating_point<T>\r\n    void write(T);\r\n    void write(bool x) { putch(x ^ 48); }\r\n    void write(char*);\r\n    void write(const char*);\r\n    void write(const std::string&);\r\n    template <typename T>\r\n    void write(std::initializer_list<T>);\r\n    template <tupleLike T>\r\n    void write(T&&);\r\n    template <std::ranges::input_range R>\r\n    void write(R&&);\r\n    template <typename T>\r\n        requires requires (T t, IO& io) { t.write(io); }\r\n    void write(T&& t) { t.write(*this); }\r\n    template <typename... Args>\r\n    void writeln(Args&&...);\r\n    template <std::input_iterator I>\r\n    IO& readArray(I, I);\r\n    template <std::ranges::input_range R>\r\n    IO& readArray(R&&);\r\n    template <std::input_iterator I>\r\n    void displayArray(I, I, char = ' ');\r\n    template <std::ranges::input_range R>\r\n    void displayArray(R&&, char = ' ');\r\n    operator bool() const { return get(); }\r\n} io(stdin, stdout);\r\n#ifdef LX_LOCAL\r\nIO err(nullptr, stderr);\r\n#define dbg(x) err.write(#x \" = \"), err.writeln(x)\r\n#else\r\n#define dbg(x) \\\r\n    do {       \\\r\n    } while (false)\r\n#endif\r\ntemplate <typename F>\r\nvoid multipleTests(F&&, IO& = io);\r\ntemplate <typename... Args>\r\nvoid writeln(Args&&... x) { io.writeln(std::forward<Args>(x)...); }\r\ntemplate <typename T>\r\nvoid writeln(std::initializer_list<T> x) { io.writeln(x); }\r\nvoid YN(bool value, bool cap = true) {\r\n    if (cap)\r\n        return writeln(value ? \"YES\" : \"NO\");\r\n    return writeln(value ? \"Yes\" : \"No\");\r\n}\r\n#pragma endregion\r\n\r\nint main() {\r\n    dR(int, k, a, b, v);\r\n    a = ceil(a, v);\r\n    writeln(max(1, a - b, ceil(a, k)));\r\n    return 0;\r\n}\r\n\r\n#define isdigit(x) ((x) >= '0' && (x) <= '9')\r\nIO::IO(FILE* in, FILE* out) { input(in), output(out); }\r\nconstexpr bool IO::blank(char c) { return c == ' ' || c == '\\n' || c == '\\r'; }\r\ntemplate <typename... Args>\r\n    requires (sizeof...(Args) > 1)\r\nIO& IO::read(Args&... args) {\r\n    if constexpr (CHECK_EOF)\r\n        (read(args) && ...);\r\n    else\r\n        (read(args), ...);\r\n    return *this;\r\n}\r\ntemplate <typename T>\r\n    requires std::signed_integral<T> || std::is_same_v<T, i128>\r\nIO& IO::read(T& x) {\r\n    x = 0;\r\n    static typename make_unsigned<T>::type t;\r\n    bool sign = false;\r\n#ifndef USE_MMAP\r\n    int ch = getch();\r\n    while (!isdigit(ch) ECHK3)\r\n        sign = (ch == '-'), ch = getch();\r\n    ECHK1\r\n    t = 0;\r\n    while (isdigit(ch))\r\n        t = t * 10 + (ch ^ 48), ch = getch();\r\n#else\r\n    while (!isdigit(*ptr) ECHK4)\r\n        sign = *ptr++ == '-';\r\n    ECHK2\r\n    t = *ptr++ ^ 48;\r\n    while (~n[*reinterpret_cast<u16*&>(ptr)])\r\n        t = t * 100 + n[*reinterpret_cast<u16*&>(ptr)++];\r\n    if (isdigit(*ptr))\r\n        t = t * 10 + (*ptr++ ^ 48);\r\n#endif\r\n    x = sign ? (~t + 1) : t;\r\n    return *this;\r\n}\r\ntemplate <typename T>\r\n    requires std::unsigned_integral<T> || std::is_same_v<T, u128>\r\nIO& IO::read(T& x) {\r\n    x = 0;\r\n#ifndef USE_MMAP\r\n    int ch = getch();\r\n    while (!isdigit(ch) ECHK3)\r\n        ch = getch();\r\n    ECHK1\r\n    while (isdigit(ch))\r\n        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getch();\r\n#else\r\n    while (!isdigit(*ptr) ECHK4)\r\n        ptr++;\r\n    ECHK2\r\n    x = *ptr++ ^ 48;\r\n    while (~n[*reinterpret_cast<u16*&>(ptr)])\r\n        x = x * 100 + n[*reinterpret_cast<u16*&>(ptr)++];\r\n    if (isdigit(*ptr))\r\n        x = x * 10 + (*ptr++ ^ 48);\r\n#endif\r\n    return *this;\r\n}\r\ntemplate <typename T>\r\n    requires std::floating_point<T>\r\nIO& IO::read(T& x) {\r\n    x = 0;\r\n    T t = 1;\r\n    bool sign = false;\r\n    int ch = getch();\r\n    while (!isdigit(ch) ECHK3)\r\n        sign = (ch == '-'), ch = getch();\r\n    ECHK1\r\n    while (isdigit(ch))\r\n        x = x * 10 + (ch ^ 48), ch = getch();\r\n    if (ch == '.')\r\n        for (ch = getch(); isdigit(ch); ch = getch())\r\n            x += (t /= 10) * (ch ^ 48);\r\n    x = sign ? -x : x;\r\n    return *this;\r\n}\r\ntemplate <typename T>\r\nT IO::read() {\r\n    static std::decay_t<T> x;\r\n    return read(x), x;\r\n}\r\nIO& IO::read(char& ch) {\r\n    do\r\n        ch = getch();\r\n    while (blank(ch));\r\n    ECHK1\r\n    return *this;\r\n}\r\nIO& IO::read(char* s) {\r\n    int ch = getch();\r\n    while (blank(ch))\r\n        ch = getch();\r\n    ECHK1\r\n    while (!blank(ch) && ch != EV)\r\n        *s++ = ch, ch = getch();\r\n    *s = 0;\r\n    return *this;\r\n}\r\nIO& IO::read(std::string& s) {\r\n    int ch = getch();\r\n    while (blank(ch))\r\n        ch = getch();\r\n    ECHK1\r\n    s.erase();\r\n    while (!blank(ch) && ch != EV)\r\n        s.append(1, ch), ch = getch();\r\n    return *this;\r\n}\r\nIO& IO::readline(char* s) {\r\n    char* t = s;\r\n    int ch = getch();\r\n    while (ch != '\\n' && ch != EV)\r\n        *s++ = ch, ch = getch();\r\n    *s = 0;\r\n    if (s == t && ch != '\\n')\r\n        set(false);\r\n    return *this;\r\n}\r\nIO& IO::readline(std::string& s) {\r\n    s.erase();\r\n    int ch = getch();\r\n    while (ch != '\\n' && ch != EV)\r\n        s.append(1, ch), ch = getch();\r\n    if (s.empty() && ch != '\\n')\r\n        set(false);\r\n    return *this;\r\n}\r\ntemplate <tupleLike T>\r\nIO& IO::read(T&& t) {\r\n    std::apply([&](auto&... t) { (read(t), ...); }, t);\r\n    return *this;\r\n}\r\ntemplate <typename... Args>\r\n    requires (sizeof...(Args) > 1)\r\nvoid IO::write(Args&&... args) {\r\n    (write(std::forward<Args>(args)), ...);\r\n}\r\ntemplate <typename T>\r\n    requires std::signed_integral<T> || std::is_same_v<T, i128>\r\nvoid IO::write(T x) {\r\n    static typename make_unsigned<T>::type y;\r\n    y = x;\r\n    if (x < 0)\r\n        putch('-'), write(~y + 1);\r\n    else\r\n        write(y);\r\n}\r\nconstexpr auto D = []() {\r\n    constexpr u32 e0 = 0x1, e1 = 0x100, e2 = 0x10000, e3 = 0x1000000;\r\n    std::array<u32, 10000> m{};\r\n    int x = 0;\r\n    for (u32 i = 0, c0 = 0x30303030; i != 10; i++, c0 += e0)\r\n        for (u32 j = 0, c1 = c0; j != 10; j++, c1 += e1)\r\n            for (u32 k = 0, c2 = c1; k != 10; k++, c2 += e2)\r\n                for (u32 l = 0, c3 = c2; l != 10; l++, c3 += e3)\r\n                    m[x++] = c3;\r\n    return m;\r\n}();\r\ntemplate <typename T>\r\n    requires std::unsigned_integral<T>\r\nvoid IO::write(T x) {\r\n#ifndef LX_DEBUG\r\n    if (std::end(pbuf) - pp < 64)\r\n        flush();\r\n\r\n    auto L = [&](int x) { return x == 1 ? 0 : ten(x - 1); };\r\n    auto R = [&](int x) { return ten(x) - 1; };\r\n\r\n#define de(t)                            \\\r\n    case L(t)... R(t):                   \\\r\n        *(u32*)(pp) = D[x / ten((t)-4)]; \\\r\n        pp += 4;                         \\\r\n        x %= ten((t)-4);\r\n\r\n    u64 y = x;\r\n    switch (y) {\r\n        de(18);\r\n        de(14);\r\n        de(10);\r\n        de(6);\r\n    case L(2)... R(2):\r\n        *(u32*)(pp) = D[x * 100];\r\n        pp += 2;\r\n        break;\r\n\r\n        de(17);\r\n        de(13);\r\n        de(9);\r\n        de(5);\r\n    case L(1)... R(1):\r\n        *pp = x ^ 48;\r\n        pp += 1;\r\n        break;\r\n\r\n    default:\r\n        *(u32*)(pp) = D[x / ten(16)];\r\n        pp += 4;\r\n        x %= ten(16);\r\n        de(16);\r\n        de(12);\r\n        de(8);\r\n    case L(4)... R(4):\r\n        *(u32*)pp = D[x];\r\n        pp += 4;\r\n        break;\r\n\r\n        de(19);\r\n        de(15);\r\n        de(11);\r\n        de(7);\r\n    case L(3)... R(3):\r\n        *(u32*)(pp) = D[x * 10];\r\n        pp += 3;\r\n        break;\r\n    }\r\n#else\r\n    write(u128(x));\r\n#endif\r\n}\r\nvoid IO::write(u128 x) {\r\n    static int s[40], t = 0;\r\n    do\r\n        s[t++] = x % 10, x /= 10;\r\n    while (x);\r\n    while (t)\r\n        putch(s[--t] ^ 48);\r\n}\r\ntemplate <typename T>\r\n    requires std::floating_point<T>\r\nvoid IO::write(T x) {\r\n    static char buf[512];\r\n    *std::to_chars(buf, buf + 512, x, std::chars_format::fixed, precision).ptr = 0;\r\n    write(buf);\r\n}\r\nvoid IO::write(char* s) {\r\n    while (*s)\r\n        putch(*s++);\r\n}\r\nvoid IO::write(const char* s) {\r\n    while (*s)\r\n        putch(*s++);\r\n}\r\nvoid IO::write(const std::string& s) { write(s.data()); }\r\ntemplate <typename T>\r\nvoid IO::write(std::initializer_list<T> t) {\r\n    auto f = std::begin(t), l = std::end(t);\r\n    if (f != l)\r\n        for (write(*f++); f != l; ++f) {\r\n            putch(' ');\r\n            write(*f);\r\n        }\r\n}\r\ntemplate <tupleLike T>\r\nvoid IO::write(T&& t) {\r\n    [&]<auto... I>(std::index_sequence<I...>) {\r\n        (..., (I == 0 ? void(0) : putch(' '), write(std::get<I>(t))));\r\n    }(std::make_index_sequence<std::tuple_size_v<std::decay_t<T>>>());\r\n}\r\ntemplate <std::ranges::input_range R>\r\nvoid IO::write(R&& r) {\r\n    if constexpr (std::is_same_v<std::decay_t<R>, std::string>)\r\n        return write(r.data());\r\n    auto f = std::ranges::begin(r), l = std::ranges::end(r);\r\n    if (f != l)\r\n        for (write(*f++); f != l; ++f) {\r\n            putch(' ');\r\n            write(*f);\r\n        }\r\n}\r\ntemplate <typename... Args>\r\nvoid IO::writeln(Args&&... x) { write(std::forward<Args>(x)...), putch('\\n'); }\r\ntemplate <std::input_iterator I>\r\nIO& IO::readArray(I f, I l) {\r\n#if CHECK_EOF\r\n    bool t = true;\r\n    for (; f != l && t; ++f)\r\n        t &= read(*f);\r\n    if (!t)\r\n        set(false);\r\n#else\r\n    for (; f != l; ++f)\r\n        read(*f);\r\n#endif\r\n    return *this;\r\n}\r\ntemplate <std::ranges::input_range R>\r\nIO& IO::readArray(R&& r) { return readArray(std::ranges::begin(r), std::ranges::end(r)); }\r\ntemplate <std::input_iterator I>\r\nvoid IO::displayArray(I f, I l, char d) {\r\n    if (f != l)\r\n        for (write(*f++); f != l; ++f) {\r\n            putch(d);\r\n            write(*f);\r\n        }\r\n    putch('\\n');\r\n}\r\ntemplate <std::ranges::input_range R>\r\nvoid IO::displayArray(R&& r, char d) { return displayArray(std::ranges::begin(r), std::ranges::end(r), d); }\r\ntemplate <typename F>\r\nvoid multipleTests(F&& f, IO& io) {\r\n    dR(u32, q);\r\n    _for (q)\r\n        f();\r\n}"
}