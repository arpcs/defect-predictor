{
    "id": 212092613,
    "contestId": 873,
    "creationTimeSeconds": 1688479536,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 873,
        "index": "F",
        "name": "Forbidden Indices",
        "type": "PROGRAMMING",
        "rating": 2400,
        "tags": [
            "dsu",
            "string suffix structures",
            "strings"
        ]
    },
    "author": {
        "contestId": 873,
        "members": [
            {
                "handle": "cebolinha"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1507817100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 81,
    "timeConsumedMillis": 373,
    "memoryConsumedBytes": 17203200,
    "source": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template (v1.4.3 - 2023-04-22) (codeforces:cebolinha, atcoder:edu) {{{\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n\n#define int long long\n#define fastio ios::sync_with_stdio(false); cin.tie(nullptr)\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nusing ii = pair<int, int>;\nusing iii = array<int, 3>;\n\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define eb emplace_back\n#define ff first\n#define ss second\n#define nemo ><>\n#define loop(ii, n) for (int ii = 0; ii < (n); ii++)\n#define cond(c, t, f) ((c) ? (t) : (f))\n#define mem(a, b) memset((a), (b), sizeof(a))\n#define inbounds(x, l, r) ((l) <= (x) && (x) <= (r))\n#define L1(res...) [&](auto x){ return res; }\n#define L2(res...) [&](auto x, auto y){ return res; }\n\ntemplate<class T, class U> inline void miq(T& a, U b){ if (a > b) a = b; }\ntemplate<class T, class U> inline void maq(T& a, U b){ if (a < b) a = b; }\n\ntemplate<class T, class U> auto &operator>>(istream &is, pair<T, U> &p) { return is >> p.ff >> p.ss; }\ntemplate<class T, class U> auto &operator<<(ostream &os, pair<T, U> const& p) { return os << '(' << p.first << ' ' << p.second << ')'; }\n\nconst auto EMPTY_STRING = \"\", SEPARATOR = \" \";\ntemplate<class T> auto &operator>>(istream& is, vector<T> &c) { for (auto &x : c) is >> x; return is; }\ntemplate<class T> auto &operator<<(ostream& os, vector<T> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class T> auto &operator<<(ostream& os, set<T> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class T> auto &operator<<(ostream& os, multiset<T> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class T> auto &operator<<(ostream& os, unordered_set<T> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class T> auto &operator<<(ostream& os, ordered_set<T> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class T> auto &operator<<(ostream& os, deque<T> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class K, class V> auto &operator<<(ostream& os, map<K,V> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\ntemplate<class K, class V> auto &operator<<(ostream& os, unordered_map<K,V> const &c) { auto sep = EMPTY_STRING; for (auto x : c) os << sep << x, sep = SEPARATOR; return os; }\n\ntemplate<class... A> void in(A &...a) { ((cin >> a), ...); }\ntemplate<class... A> void out(A const&... a) { auto sep = EMPTY_STRING; ((cout << sep << a, sep = SEPARATOR), ...); cout << '\\n'; }\ntemplate<class... A> void print(A const&... a) { ((cout << a), ...); }\n#define var(x) \"[\", #x, \" \", x, \"] \"\ntemplate<class... A> void db(A const&... a) { ((cout << (a)), ...); cout << endl; }\n//}}}\n\nvector<int> sort_cyclic_shifts(string const& s) {/*{{{*/\n  int N = s.size();\n\n  vector<int> p(N);\n  iota(begin(p), end(p), 0);\n  sort(begin(p), end(p), [&](int x, int y) {\n    return s[x] < s[y];\n  });\n\n  vector<int> eq(N);\n  eq[p[0]] = 0;\n  for (int i = 1; i < N; i++)\n    eq[p[i]] = eq[p[i - 1]] + (s[p[i]] != s[p[i - 1]]);\n\n  for (int shift = 1; shift < N; shift *= 2) {\n    vector<int> cnt(N);\n    for (int i = 0; i < N; i++)\n      cnt[eq[i]]++;\n    partial_sum(begin(cnt), end(cnt), begin(cnt));\n\n    vector<int> tmp(N);\n    for (int i = 0; i < N; i++)\n      tmp[N - 1 - i] = (p[i] - shift + N) % N;\n    for (auto i : tmp)\n      p[--cnt[eq[i]]] = i;\n\n    auto key = [&](int x) {\n      return pair(eq[x], eq[(x + shift) % N]);\n    };\n\n    tmp[p[0]] = 0;\n    for (int i = 1; i < N; i++)\n      tmp[p[i]] = tmp[p[i - 1]] + (key(p[i]) != key(p[i - 1]));\n    swap(tmp, eq);\n  }\n\n  return p;\n}\n\nvector<int> kasai(string const& s, vector<int> const& p) {\n  int N = size(s);\n  vector<int> rank(N);\n  for (int i = 0; i < N; i++)\n    rank[p[i]] = i;\n\n  int k = 0;\n  vector<int> lcp(N-1);\n  for (int i = 0; i < N; i++) {\n    if (rank[i] == N-1) {\n      k = 0;\n      continue;\n    }\n    int j = p[rank[i] + 1];\n    while (i + k < N && j + k < N && s[i+k] == s[j+k]) k++;\n    lcp[rank[i]] = k;\n    if (k) k--;\n  }\n\n  return lcp;\n}/*}}}*/\n\nstruct DSU {/*{{{*/\n  vector<int> p, s;\n  vector<int> small, big;\n  DSU (int n) : p(n, -1), s(n, 1), small(n), big(n) {\n    iota(all(small), 0);\n    iota(all(big), 0);\n  };\n  int find(int v) {\n    if (p[v] == -1) return v;\n    return p[v] = find(p[v]);\n  }\n  void join(int a, int b) {\n    a = find(a), b = find(b);\n    if (a != b) {\n      if (s[a] < s[b]) swap(a, b);\n      p[b] = a, s[a] += s[b];\n      miq(small[a], small[b]);\n      maq(big[a], big[b]);\n    }\n  }\n};/*}}}*/\n\nauto main() -> signed {\n  fastio;\n\n  int n;\n  in(n);\n\n  string s, t;\n  in(s, t);\n\n  // by reversing we change the requirement\n  //  from 'not ending at a 1'\n  //  to 'not starting at a 1'\n  reverse(all(s));\n  reverse(all(t));\n\n  s += '$';\n  t += '1';\n\n  auto p = sort_cyclic_shifts(s);\n  auto lcp = kasai(s, p);\n\n  V<int> valid(sz(s));\n  loop (i, sz(s)) valid[i] = t[p[i]] == '0';\n  partial_sum(all(valid), begin(valid));\n  auto valid_count = [&](int l, int r) {\n    return valid[r] - cond(l, valid[l-1], 0);\n  };\n\n  int ans = 0;\n  loop (i, n) if (t[i] == '0') maq(ans, n-i);\n\n  priority_queue<ii> Q;\n  loop (i, sz(lcp)) Q.push({lcp[i], i});\n  DSU d(sz(lcp)+1);\n\n  while (!Q.empty()) {\n    auto [val, idx] = Q.top(); Q.pop();\n    d.join(idx, idx+1);\n    auto l = d.find(idx);\n    int v = valid_count(d.small[l], d.big[l]);\n    maq(ans, v * val);\n  }\n\n  out(ans);\n}\n"
}