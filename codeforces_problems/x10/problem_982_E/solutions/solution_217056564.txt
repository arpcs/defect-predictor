{
    "id": 217056564,
    "contestId": 982,
    "creationTimeSeconds": 1691111363,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 982,
        "index": "E",
        "name": "Billiard",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2600,
        "tags": [
            "geometry",
            "number theory"
        ]
    },
    "author": {
        "contestId": 982,
        "members": [
            {
                "handle": "NK_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1526574900
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 21,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n/////////////////////// MACROS ////////////////////////////////////////////\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing db = double;\r\nusing str = string;\r\n\r\nusing pi = pair<int,int>;\r\nusing pl = pair<ll,ll>;\r\n\r\nusing vi = vector<int>;\r\nusing vl = vector<ll>;\r\nusing vs = vector<str>;\r\nusing vc = vector<char>;\r\nusing vpi = vector<pi>;\r\nusing vpl = vector<pl>;\r\n\r\n#define tcT template<class T\r\n#define tcTU tcT, class U\r\ntcT> using V = vector<T>;\r\ntcT, size_t SZ> using AR = array<T,SZ>;\r\ntcTU> using PR = pair<T,U>;\r\ntcTU> using umap = unordered_map<T, U>;\r\ntcT> using uset = unordered_set<T>;\r\ntcT> using mset = multiset<T>;\r\n\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n\r\n#define sz(x) int((x).size())\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define rsz resize\r\n#define ins insert\r\n#define ft front()\r\n#define bk back()\r\n#define ppb pop_back()\r\n#define ppf pop_front()\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define pf push_front\r\n\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n\r\n// LOOPS\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define rep(a) F0R(_, a)\r\n#define each(a,x) for (auto& a: x)\r\n\r\n/////////////////////// IMPORANT VARS /////////////////////////////////////\r\n\r\nconst int MOD = 1e9+7; // 998244353;\r\nconst int MX = 2e5+5;\r\nconst ll INFL = ll(3e18)+10;\r\nconst int INF = int(1e9)+10;\r\nconst ld PI = acos((ld)-1);\r\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\r\ntcT> using pqg = priority_queue<T,vector<T>,greater<T>>;\r\ntcT> using pql = priority_queue<T,vector<T>,less<T>>;\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n#define nl '\\n'\r\n\r\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\r\nconstexpr int bits(int x) { \r\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); }\r\nconstexpr int p2(int x) { return 1<<x; }\r\nconstexpr int msk2(int x) { return p2(x)-1; }\r\n \r\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\r\n \r\ntcT> bool ckmin(T& a, const T& b) {\r\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\r\ntcT> bool ckmax(T& a, const T& b) {\r\n\treturn a < b ? a = b, 1 : 0; }\r\n \r\ntcTU> T fstTrue(T lo, T hi, U f) {\r\n\thi ++; assert(lo <= hi); // assuming f is increasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo)/2;\r\n\t\tf(mid) ? hi = mid : lo = mid+1; \r\n\t} \r\n\treturn lo;\r\n}\r\ntcTU> T lstTrue(T lo, T hi, U f) {\r\n\tlo --; assert(lo <= hi); // assuming f is decreasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo+1)/2;\r\n\t\tf(mid) ? lo = mid : hi = mid-1;\r\n\t} \r\n\treturn lo;\r\n}\r\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\r\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\r\ntcTU> void erase(T& t, const U& u) { // don't erase\r\n\tauto it = t.find(u); assert(it != end(t));\r\n\tt.erase(it); } // element that doesn't exist from (multi)set\r\n\r\n\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// using namespace __gnu_pbds;\r\n\r\n// tcT> using iset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; \r\n// #define ook order_of_key\r\n// #define fbo find_by_order\r\n\r\n// struct chash { \r\n// \tconst uint64_t C = ll(2e18*PI)+71;\r\n// \tconst int RANDOM = rng();\r\n// \tll operator()(ll x) const {\r\n// \t\treturn __builtin_bswap64((x^RANDOM)*C); }\r\n// };\r\n// template<class K,class V> using um = unordered_map<K,V,chash>;\r\n// template<class K,class V> using ht = gp_hash_table<K,V,chash>;\r\n// template<class K,class V> V get(ht<K,V>& u, K x) {\r\n// \tauto it = u.find(x); return it == end(u) ? 0 : it->s; }\r\n\r\n/////////////////////// OUPUT /////////////////////////////////////////////\r\n#define ts to_string\r\nstr ts(char c) { return str(1,c); }\r\nstr ts(const char* s) { return (str)s; }\r\nstr ts(str s) { return s; }\r\nstr ts(bool b) {\r\n\t#ifdef LOCAL\r\n\t\treturn b ? \"true\" : \"false\";\r\n\t#else\r\n\t\treturn ts((int)b);\r\n\t#endif\r\n}\r\ntcTU> str ts(pair<T,U> p) {\r\n\t#ifdef LOCAL\r\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\";\r\n\t#else\r\n\t\treturn ts(p.f)+\" \"+ts(p.s);\r\n\t#endif\r\n}\r\n\r\ntcTU> str ts(V<pair<T, U>> v) {\r\n\t#ifdef LOCAL\r\n\t\tbool fst = 1; str res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\t#endif\r\n}\r\n\r\ntcT> str ts(T v) {\r\n\t#ifdef LOCAL\r\n\t\tbool fst = 1; str res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\r\n\t#endif\r\n}\r\n\r\n///////////////////////// DEBUG ///////////////////////////////////////////\r\n#define tcTUU tcT, class ...U\r\nvoid DBG() { cerr << \"]\" << \"\\e[0m\" << endl; }\r\ntcTUU> void DBG(const T& t, const U&... u) {\r\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\r\n\tDBG(u...); }\r\n#ifdef LOCAL\r\n\t#define dbg(...) cerr << \"\\e[1m\" << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__);\r\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\r\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\r\n#else\r\n\t#define dbg(...) 0\r\n\t#define chk(...) 0\r\n#endif\t\r\n\r\n///////////////////////// FILE I/O ////////////////////////////////////////\r\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\r\nvoid setPrec() { cout << fixed << setprecision(15); }\r\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\r\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\nvoid setIO(str s = \"\") {\r\n\tunsyncIO(); setPrec();\r\n\t#ifndef LOCAL\t\r\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for USACO\r\n\t#endif\r\n}\r\n\r\n///////////////////////// TEMPLATE ABOVE //////////////////////////////////\r\n\r\n// REMEMBER\r\n// - Don't Focus On Only One Approach\r\n// - Read And Understand Problem Fully\r\n// - Think Of Edges Cases\r\n// - Implement Carefully\r\n// - Always Check For Overflows\r\n// - Reset Global Variables\r\n// - Look At The Bigger Picture\r\n// - Don't Get Discouraged, You Can Pull It Back\r\n\r\npl euclid(ll A, ll B) { // For A,B>=0, finds (x,y) s.t.\r\n\t// Ax+By=gcd(A,B), |Ax|,|By|<=AB/gcd(A,B)\r\n\tif (!B) return {1,0};\r\n\tpl p = euclid(B,A%B); return {p.s,p.f-A/B*p.s}; }\r\nll invGeneral(ll A, ll B) { // find x in [0,B) such that Ax=1 mod B\r\n\tpl p = euclid(A,B); assert(p.f*A+p.s*B == 1);\r\n\treturn p.f+(p.f<0)*B; } // must have gcd(A,B)=1\r\n\r\npl CRT(pl a, pl b) { assert(0 <= a.f && a.f < a.s && 0 <= b.f && b.f < b.s);\r\n\tif (a.s < b.s) swap(a,b); // will overflow if b.s^2 > 2^{62}\r\n\tll x,y; tie(x,y) = euclid(a.s,b.s); \r\n\tll g = a.s*x+b.s*y, l = a.s/g*b.s;\r\n\tif ((b.f-a.f)%g) return {-1,-1}; // no solution\r\n\t// ?*a.s+a.f \\equiv b.f \\pmod{b.s}\r\n\t// ?=(b.f-a.f)/g*(a.s/g)^{-1} \\pmod{b.s/g}\r\n\tx = (b.f-a.f)%b.s*x%b.s/g*a.s+a.f; \r\n\treturn {x+(x<0)*l,l};\r\n}\r\n\r\nvoid solve() {\r\n\tint N, M, X, Y, VX, VY; cin >> N >> M >> X >> Y >> VX >> VY;\r\n\r\n\tif (X == 0 && VX == -1) VX *= -1;\r\n\tif (Y == 0 && VY == -1) VY *= -1;\r\n\r\n\tif (X == N && VX == 1) VX *= -1;\r\n\tif (Y == M && VY == 1) VY *= -1;\r\n\r\n\r\n\tif (min(abs(VX), abs(VY)) == 0) {\r\n\t\tif (VX == 0) {\r\n\t\t\tif (X == 0 || X == N) {\r\n\t\t\t\tcout << X << \" \" << (VY == -1 ? 0 : M) << nl;\r\n\t\t\t\treturn;\r\n\t\t\t} else {\r\n\t\t\t\tcout << -1 << nl;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (VY == 0) {\r\n\t\t\tif (Y == 0 || Y == M) {\r\n\t\t\t\tcout << Y << \" \" << (VX == -1 ? 0 : N) << nl;\r\n\t\t\t\treturn;\r\n\t\t\t} else {\r\n\t\t\t\tcout << -1 << nl;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tll best = INFL; pi ans = mp(-1, -1);\r\n\tF0R(v, 2) {\r\n\t\tF0R(h, 2) {\r\n\t\t\tint CX = v ? N : 0, CY = h ? M : 0;\r\n\t\t\tdbg(X, Y);\r\n\t\t\tif ((X + Y) % 2 == 0) {\r\n\t\t\t\tint x = X, y = Y;\r\n\t\t\t\tdbg(x, CX, VX);\r\n\t\t\t\tdbg(y, CY, VY);\r\n\r\n\t\t\t\tint tm = 0, tn = 0;\r\n\t\t\t\tif (VX == 1) x = N - x, tn = 1;\r\n\t\t\t\tif (VY == 1) y = M - y, tm = 1;\r\n\r\n\t\t\t\tdbg(x, N, y, M);\r\n\t\t\t\tpl t = CRT(pl(x % N, N), pl(y % M, M));\r\n\t\t\t\tdbg(t);\r\n\r\n\r\n\t\t\t\tll T = t.f; int time = 0;\r\n\t\t\t\tif (T == -1) goto END;\r\n\t\t\t\tdbg(T, tn, tm);\r\n\t\t\t\twhile(((T - 1) / N) % 2 != tn || ((T - 1) / M) % 2 != tm) {\r\n\t\t\t\t\tdbg(T, (T - 1) / N, (T - 1) / M);\r\n\t\t\t\t\tT += t.s; time++;\r\n\t\t\t\t\tif (time > 10) break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (time > 10) goto END;\r\n\r\n\t\t\t\tdbg(T);\r\n\t\t\t\tif (ckmin(best, T)) ans = pi(CX, CY);\r\n\t\t\t}\r\n\r\n\t\t\tEND:;\r\n\r\n\t\t\tY = M - Y; VY *= -1;\r\n\t\t}\r\n\r\n\t\tX = N - X; VX *= -1;\r\n\t}\r\n\r\n\tif (best == INFL) cout << -1 << nl;\r\n\telse cout << ts(ans) << nl;\r\n}\r\n\r\nint main() {\r\n\tsetIO(); \r\n\r\n\tint TT = 1;\r\n\t// cin >> TT;\r\n\r\n\trep(TT) solve();\r\n\t\r\n\texit(0-0);\r\n}\r\n"
}