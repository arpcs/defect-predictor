{
    "id": 167782954,
    "contestId": 288,
    "creationTimeSeconds": 1660150824,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 288,
        "index": "A",
        "name": "Polo the Penguin and Strings",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1300,
        "tags": [
            "greedy"
        ]
    },
    "author": {
        "contestId": 288,
        "members": [
            {
                "handle": "BhargavModha"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1364916600
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 32,
    "timeConsumedMillis": 248,
    "memoryConsumedBytes": 0,
    "source": "import java.io.*;\r\nimport java.util.*;\r\n\r\n@SuppressWarnings(\"unused\")\r\npublic class A_Polo_the_Penguin_and_Strings {\r\n\tpublic static void main(String[] args) {\r\n\t\tMyScanner sc = new MyScanner();\r\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\r\n\t\tint n = sc.nextInt(), k = sc.nextInt();\r\n\t\tif (n < k || (k == 1 && n > 1))\r\n\t\t\tout.println(-1);\r\n\t\telse if (k == 2) {\r\n\t\t\tboolean flag = true;\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tout.print(flag?'a':'b');\r\n\t\t\t\tflag = !flag;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tboolean flag = true;\r\n\t\t\tfor (int i = 0; i < min(n,n - (k - 2)); i++) {\r\n\t\t\t\tout.print(flag?'a':'b');\r\n\t\t\t\tflag = !flag;\r\n\t\t\t}\r\n\t\t\tfor (int i = n - (k - 2), l = 2; i < n; i++, l++) \r\n\t\t\t\tout.print((char) (l + 'a'));\r\n\t\t}\r\n\t\tout.close();\r\n\t}\r\n\r\n\tpublic static PrintWriter out;\r\n\tpublic static long mod = (long) 1e9 + 7;\r\n\tpublic static int[] parent = new int[101];\r\n\tpublic static int[] rank = new int[101];\r\n\r\n\tpublic static class MyScanner {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic MyScanner() {\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t}\r\n\r\n\t\tString next() {\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n\r\n\t\tlong nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\r\n\t\tdouble nextDouble() {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tint[] readArray(int n) {\r\n\t\t\tint a[] = new int[n];\r\n\t\t\tfor (int i = 0; i < n; i++)\r\n\t\t\t\ta[i] = nextInt();\r\n\t\t\treturn a;\r\n\t\t}\r\n\r\n\t\tlong[] readLongArray(int n) {\r\n\t\t\tlong a[] = new long[n];\r\n\t\t\tfor (int i = 0; i < n; i++)\r\n\t\t\t\ta[i] = nextLong();\r\n\t\t\treturn a;\r\n\t\t}\r\n\r\n\t\tint[][] readArrayMatrix(int N, int M, int Index) {\r\n\t\t\tif (Index == 0) {\r\n\t\t\t\tint[][] res = new int[N][M];\r\n\t\t\t\tfor (int i = 0; i < N; i++) {\r\n\t\t\t\t\tfor (int j = 0; j < M; j++)\r\n\t\t\t\t\t\tres[i][j] = (int) nextLong();\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t}\r\n\t\t\tint[][] res = new int[N][M];\r\n\t\t\tfor (int i = 1; i <= N; i++) {\r\n\t\t\t\tfor (int j = 1; j <= M; j++)\r\n\t\t\t\t\tres[i][j] = (int) nextLong();\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\r\n\r\n\t\tlong[][] readArrayMatrixLong(int N, int M, int Index) {\r\n\t\t\tif (Index == 0) {\r\n\t\t\t\tlong[][] res = new long[N][M];\r\n\t\t\t\tfor (int i = 0; i < N; i++) {\r\n\t\t\t\t\tfor (int j = 0; j < M; j++)\r\n\t\t\t\t\t\tres[i][j] = nextLong();\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t}\r\n\t\t\tlong[][] res = new long[N][M];\r\n\t\t\tfor (int i = 1; i <= N; i++) {\r\n\t\t\t\tfor (int j = 1; j <= M; j++)\r\n\t\t\t\t\tres[i][j] = nextLong();\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\r\n\r\n\t\tString nextLine() {\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate static boolean nextPerm(int[] p) {\r\n\t\tfor (int a = p.length - 2; a >= 0; --a)\r\n\t\t\tif (p[a] < p[a + 1])\r\n\t\t\t\tfor (int b = p.length - 1;; --b)\r\n\t\t\t\t\tif (p[b] > p[a]) {\r\n\t\t\t\t\t\tint t = p[a];\r\n\t\t\t\t\t\tp[a] = p[b];\r\n\t\t\t\t\t\tp[b] = t;\r\n\t\t\t\t\t\tfor (++a, b = p.length - 1; a < b; ++a, --b) {\r\n\t\t\t\t\t\t\tt = p[a];\r\n\t\t\t\t\t\t\tp[a] = p[b];\r\n\t\t\t\t\t\t\tp[b] = t;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate static void google(int tt) {\r\n\t\tout.print(\"Case #\" + (tt) + \": \");\r\n\t}\r\n\r\n\tpublic static int lower_bound(int[] arr, int x) {\r\n\t\tint low = 0, high = arr.length - 1, mid = -1;\r\n\t\tint ans = -1;\r\n\t\twhile (low <= high) {\r\n\t\t\tmid = (low + high) / 2;\r\n\t\t\tif (arr[mid] > x) {\r\n\t\t\t\thigh = mid - 1;\r\n\t\t\t} else {\r\n\t\t\t\tans = mid;\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tpublic static int upper_bound(int[] arr, int x) {\r\n\t\tint low = 0, high = arr.length - 1, mid = -1;\r\n\t\tint ans = arr.length;\r\n\t\twhile (low < high) {\r\n\t\t\tmid = (low + high) / 2;\r\n\t\t\tif (arr[mid] >= x) {\r\n\t\t\t\tans = mid;\r\n\t\t\t\thigh = mid - 1;\r\n\t\t\t} else {\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tstatic void reverseArray(int[] a) {\r\n\t\tint n = a.length;\r\n\t\tint arr[] = new int[n];\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t\tarr[i] = a[n - i - 1];\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t\ta[i] = arr[i];\r\n\t}\r\n\r\n\tstatic void reverseArray(long[] a) {\r\n\t\tint n = a.length;\r\n\t\tlong arr[] = new long[n];\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t\tarr[i] = a[n - i - 1];\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t\ta[i] = arr[i];\r\n\t}\r\n\r\n\tpublic static void push(TreeMap<Integer, Integer> map, int k, int v) {\r\n\t\tif (!map.containsKey(k))\r\n\t\t\tmap.put(k, v);\r\n\t\telse\r\n\t\t\tmap.put(k, map.get(k) + v);\r\n\t}\r\n\r\n\tpublic static void pull(TreeMap<Integer, Integer> map, int k, int v) {\r\n\t\tint lol = map.get(k);\r\n\t\tif (lol == v)\r\n\t\t\tmap.remove(k);\r\n\t\telse\r\n\t\t\tmap.put(k, lol - v);\r\n\t}\r\n\r\n\tstatic int[][] matrixMul(int[][] a, int[][] m) {\r\n\t\tif (a[0].length == m.length) {\r\n\t\t\tint[][] b = new int[a.length][m.length];\r\n\t\t\tfor (int i = 0; i < m.length; i++) {\r\n\t\t\t\tfor (int j = 0; j < m.length; j++) {\r\n\t\t\t\t\tint sum = 0;\r\n\t\t\t\t\tfor (int k = 0; k < m.length; k++) {\r\n\t\t\t\t\t\tsum += m[i][k] * m[k][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tb[i][j] = sum;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn b;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstatic void swap(int[] a, int l, int r) {\r\n\t\tint temp = a[l];\r\n\t\ta[l] = a[r];\r\n\t\ta[r] = temp;\r\n\t}\r\n\r\n\tstatic void SieveOfEratosthenes(int n, boolean prime[]) {\r\n\t\tprime[0] = false;\r\n\t\tprime[1] = false;\r\n\t\tfor (int p = 2; p * p <= n; p++) {\r\n\t\t\tif (prime[p] == true)\r\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\r\n\t\t\t\t\tprime[i] = false;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void dfs(int root, boolean[] vis, int[] value, ArrayList[] gr, int prev) {\r\n\t\tvis[root] = true;\r\n\t\tvalue[root] = 3 - prev;\r\n\t\tprev = 3 - prev;\r\n\t\tfor (int i = 0; i < gr[root].size(); i++) {\r\n\t\t\tint next = (int) gr[root].get(i);\r\n\t\t\tif (!vis[next])\r\n\t\t\t\tdfs(next, vis, value, gr, prev);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic boolean isPrime(int n) {\r\n\t\tfor (int i = 2; i <= Math.sqrt(n); i++)\r\n\t\t\tif (n % i == 0)\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstatic boolean isPrime(long n) {\r\n\t\tfor (long i = 2; i <= Math.sqrt(n); i++)\r\n\t\t\tif (n % i == 0)\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstatic int abs(int a) {\r\n\t\treturn a > 0 ? a : -a;\r\n\t}\r\n\r\n\tstatic int max(int a, int b) {\r\n\t\treturn a > b ? a : b;\r\n\t}\r\n\r\n\tstatic int min(int a, int b) {\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\tstatic int ceil(int x, int y) {\r\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\r\n\t}\r\n\r\n\tstatic long ceil(long x, long y) {\r\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\r\n\t}\r\n\r\n\tstatic boolean isSquare(double a) {\r\n\t\tboolean isSq = false;\r\n\t\tdouble b = Math.sqrt(a);\r\n\t\tdouble c = Math.sqrt(a) - Math.floor(b);\r\n\r\n\t\tif (c == 0)\r\n\t\t\tisSq = true;\r\n\r\n\t\treturn isSq;\r\n\t}\r\n\r\n\tstatic long sqrt(long z) {\r\n\t\tlong sqz = (long) Math.sqrt(z);\r\n\t\twhile (sqz * 1L * sqz < z) {\r\n\t\t\tsqz++;\r\n\t\t}\r\n\t\twhile (sqz * 1L * sqz > z) {\r\n\t\t\tsqz--;\r\n\t\t}\r\n\t\treturn sqz;\r\n\t}\r\n\r\n\tstatic int log2(int N) {\r\n\t\tint result = (int) (Math.log(N) / Math.log(2));\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic long pow(long n, long m) {\r\n\t\tif (m == 0)\r\n\t\t\treturn 1;\r\n\t\tlong temp = pow(n, m / 2);\r\n\t\tlong res = ((temp * temp) % mod);\r\n\t\tif (m % 2 == 0)\r\n\t\t\treturn res;\r\n\t\treturn (res * n) % mod;\r\n\t}\r\n\r\n\tstatic long modular_add(long a, long b) {\r\n\t\treturn ((a % mod) + (b % mod)) % mod;\r\n\t}\r\n\r\n\tstatic long modular_sub(long a, long b) {\r\n\t\treturn ((a % mod) - (b % mod) + mod) % mod;\r\n\t}\r\n\r\n\tstatic long modular_mult(long a, long b) {\r\n\t\treturn ((a % mod) * (b % mod)) % mod;\r\n\t}\r\n\r\n\tpublic static long gcd(long a, long b) {\r\n\t\tif (a > b)\r\n\t\t\ta = (a + b) - (b = a);\r\n\t\tif (a == 0L)\r\n\t\t\treturn b;\r\n\t\treturn gcd(b % a, a);\r\n\t}\r\n\r\n\tpublic static long lcm(long a, long b) {\r\n\t\treturn (a * b) / gcd(a, b);\r\n\t}\r\n\r\n\tstatic int gcd(int n1, int n2) {\r\n\t\tif (n2 != 0)\r\n\t\t\treturn gcd(n2, n1 % n2);\r\n\t\telse\r\n\t\t\treturn n1;\r\n\t}\r\n\r\n\tstatic int find(int u) {\r\n\t\tif (u == parent[u])\r\n\t\t\treturn u;\r\n\t\treturn parent[u] = find(parent[u]);\r\n\t}\r\n\r\n\tstatic void union(int u, int v) {\r\n\t\tint a = find(u), b = find(v);\r\n\r\n\t\tif (a == b)\r\n\t\t\treturn;\r\n\r\n\t\tif (rank[a] > rank[b]) {\r\n\t\t\tparent[b] = a;\r\n\t\t\trank[a] += rank[b];\r\n\t\t} else {\r\n\t\t\tparent[a] = b;\r\n\t\t\trank[b] += rank[a];\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void dsu() {\r\n\t\tfor (int i = 0; i < 101; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t\trank[i] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class Pair {\r\n\t\tint x, y;\r\n\r\n\t\tPair(int x, int y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\r\n\t\tstatic void sortbyx(Pair[] coll) {\r\n\t\t\tList<Pair> al = new ArrayList<>(Arrays.asList(coll));\r\n\t\t\tCollections.sort(al, new Comparator<Pair>() {\r\n\t\t\t\tpublic int compare(Pair p1, Pair p2) {\r\n\t\t\t\t\treturn p1.x - p2.x;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tfor (int i = 0; i < al.size(); i++) {\r\n\t\t\t\tcoll[i] = al.get(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstatic void sortbyy(Pair[] coll) {\r\n\t\t\tList<Pair> al = new ArrayList<>(Arrays.asList(coll));\r\n\t\t\tCollections.sort(al, new Comparator<Pair>() {\r\n\t\t\t\tpublic int compare(Pair p1, Pair p2) {\r\n\t\t\t\t\treturn p1.y - p2.y;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tfor (int i = 0; i < al.size(); i++) {\r\n\t\t\t\tcoll[i] = al.get(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstatic void sortbyx(ArrayList<Pair> al) {\r\n\t\t\tCollections.sort(al, new Comparator<Pair>() {\r\n\t\t\t\tpublic int compare(Pair p1, Pair p2) {\r\n\t\t\t\t\treturn Integer.compare(p1.x, p2.x);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tstatic void sortbyy(ArrayList<Pair> al) {\r\n\t\t\tCollections.sort(al, new Comparator<Pair>() {\r\n\t\t\t\tpublic int compare(Pair p1, Pair p2) {\r\n\t\t\t\t\treturn Integer.compare(p1.y, p2.y);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tpublic String toString() {\r\n\t\t\treturn String.format(\"(%s, %s)\", String.valueOf(x), String.valueOf(y));\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void sort(int[] a) {\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\tfor (int i : a)\r\n\t\t\tlist.add(i);\r\n\t\tCollections.sort(list);\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t\ta[i] = list.get(i);\r\n\t}\r\n\r\n\tstatic void sort(long a[]) {\r\n\t\tArrayList<Long> list = new ArrayList<>();\r\n\t\tfor (long i : a)\r\n\t\t\tlist.add(i);\r\n\t\tCollections.sort(list);\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t\ta[i] = list.get(i);\r\n\t}\r\n\r\n\tstatic int[] array(int n, int value) {\r\n\t\tint a[] = new int[n];\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t\ta[i] = value;\r\n\t\treturn a;\r\n\t}\r\n\r\n\tstatic long sum(long a[]) {\r\n\t\tlong sum = 0;\r\n\t\tfor (long i : a)\r\n\t\t\tsum += i;\r\n\t\treturn (sum);\r\n\t}\r\n\r\n\tstatic long count(long a[], long x) {\r\n\t\tlong c = 0;\r\n\t\tfor (long i : a)\r\n\t\t\tif (i == x)\r\n\t\t\t\tc++;\r\n\t\treturn (c);\r\n\t}\r\n\r\n\tstatic int sum(int a[]) {\r\n\t\tint sum = 0;\r\n\t\tfor (int i : a)\r\n\t\t\tsum += i;\r\n\t\treturn (sum);\r\n\t}\r\n\r\n\tstatic int count(int a[], int x) {\r\n\t\tint c = 0;\r\n\t\tfor (int i : a)\r\n\t\t\tif (i == x)\r\n\t\t\t\tc++;\r\n\t\treturn (c);\r\n\t}\r\n\r\n\tstatic int count(String s, char ch) {\r\n\t\tint c = 0;\r\n\t\tchar x[] = s.toCharArray();\r\n\t\tfor (char i : x)\r\n\t\t\tif (ch == i)\r\n\t\t\t\tc++;\r\n\t\treturn (c);\r\n\t}\r\n\r\n\tstatic int[] freq(int a[], int n) {\r\n\t\tint f[] = new int[n + 1];\r\n\t\tfor (int i : a)\r\n\t\t\tf[i]++;\r\n\t\treturn f;\r\n\t}\r\n\r\n\tstatic int[] pos(int a[], int n) {\r\n\t\tint f[] = new int[n + 1];\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t\tf[a[i]] = i;\r\n\t\treturn f;\r\n\t}\r\n\r\n\tstatic boolean isPalindrome(String s) {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tsb.append(s);\r\n\t\tString str = String.valueOf(sb.reverse());\r\n\t\tif (s.equals(str))\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n}"
}