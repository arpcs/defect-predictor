{
    "id": 236241511,
    "contestId": 1901,
    "creationTimeSeconds": 1701968855,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1901,
        "index": "C",
        "name": "Add, Divide and Floor",
        "type": "PROGRAMMING",
        "rating": 1400,
        "tags": [
            "constructive algorithms",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1901,
        "members": [
            {
                "handle": "NoisyBooyyyy"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1700836500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 11,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 1638400,
    "source": "/*\r\n    This snippet is created by NoisyBooyyyy(Md. Nazmus Sakib)\r\n    on 7th February of 2023\r\n \r\n \r\n    People worry that computers will get too smart and take over the world, \r\n    but the real problem is that \r\n    they're too stupid and they've already taken over the world.\r\n                                                \u2014 Pedro Domingos\r\n                                                \r\n*/\r\n \r\n#include<bits/stdc++.h>\r\n// #include \"algo/debug.h\"\r\n\r\nusing namespace std;\r\n \r\n#define int         long long\r\n#define double      long double\r\n#define pb          push_back\r\n#define sz(x)       ((int)x.size())\r\n#define vi          vector<int>\r\n#define all(p)      p.begin(),p.end()\r\n#define endl        \"\\n\"\r\n#define print(a)    for(auto v:a)cout<<v<<\" \";cout<<\"\\n\";\r\n#define boro(a)     *max_element (all(a))\r\n#define choto(a)    *min_element (all(a))\r\n#define faster_io   ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define vecin(a,n)  vi a(n);for(int i=0;i<n;i++)cin>>a[i];\r\n#define CY          cout<<\"YES\\n\";\r\n#define CN          cout<<\"NO\\n\";\r\n#define CYR         cout<<\"YES\\n\";return;\r\n#define CNR         cout<<\"NO\\n\";return;\r\n#define bp(n)       __builtin_popcountll(n)\r\n#define sp(n,m)     cout<<fixed<<setprecision(n)<<m<<endl;\r\n#define li \t\t\tlist<int>\r\n#define licin(a,n)\tli a;for(int i=0;i<n;i++){int x; cin >>x ; a.pb(x);}\r\n\r\n\r\n//algo/debug.h na dile nicher line uncomment krte hbe----->\r\n\r\ntemplate <typename A>\r\nstring to_string(A v) {\r\n  bool first = true;\r\n  string res = \"{\";\r\n  for (const auto &x : v) {\r\n    if (!first) {\r\n      res += \", \";\r\n    }\r\n    first = false;\r\n    res += to_string(x);\r\n  }\r\n  res += \"}\";\r\n  return res;\r\n}\r\n\r\nvoid debug_out() { cerr << endl; }\r\n \r\ntemplate <typename Head, typename... Tail>\r\nvoid debug_out(Head H, Tail... T) {\r\n  cerr << \" \" << to_string(H);\r\n  debug_out(T...);\r\n}\r\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\r\n\r\nvoid dbg_out(){cerr<<endl;}\r\ntemplate <typename Head, typename... Tail>\r\nvoid dbg_out(Head H,Tail... T){cerr<<' '<<H; dbg_out(T...); }\r\n#define dbg(...) cerr<<\"(\"<<#__VA_ARGS__<<\"):\",dbg_out(__VA_ARGS__);\r\n \r\n \r\nconst int N= 1e5+10;\r\nconst int sgTree_N = 2e5+10;\r\n \r\nint GCD(int x,int y){\r\n    if(y==0) \r\n        return x;\r\n    else \r\n        return GCD(y,x%y);\r\n}\r\n \r\nint LCM(int x,int y)\r\n{\r\n    return (x*y/(GCD(x,y)));\r\n}\r\n \r\nbool cmp(pair<int,int>&a,pair<int,int>&b)\r\n{\r\n    if(a.first<b.first)\r\n        return 1;\r\n    else if(a.first==b.first)\r\n        return(a.second<b.second);\r\n    return 0;\r\n}\r\n \r\nvoid print_binary(int n)\r\n{\r\n    for(int i=10;i>=0;i--){\r\n        cout<<((n>>i)&1);\r\n    }\r\n    cout<<endl;\r\n}\r\nint mod=1e9+7;\r\nint eps=1e-12;\r\n\r\n//nCr vector initialization--->\r\n\r\n// vi fact(N);\r\n\r\n\r\n//modular arithmatic\r\n\r\nint mod_add(int a,int b,int m){\r\n\treturn (a%m+b%m)%m;\r\n}\r\n\r\nint mod_sub(int a,int b,int m){\r\n\treturn (a%m-b%m+m)%m;\r\n}\r\n\r\nint mod_mul(int a,int b,int m){\r\n\treturn (a%m*b%m)%m;\r\n}\r\n\r\nint mod_expo(int a,int b,int m){\r\n\tif(b==0) return 1;\r\n\tint res=mod_expo(a,b/2,m);\r\n\tres=mod_mul(res,res,m);\r\n\tif(b%2==1) res=mod_mul(res,a,m);\r\n\treturn res;\r\n}\r\n\r\nint mod_inv(int a,int m){\r\n\treturn mod_expo(a,m-2,m);\r\n}\r\n\r\nint mod_div(int a,int b,int m){\r\n\treturn mod_mul(a,mod_inv(b,m),m);\r\n}\r\n\r\n\r\n// ax+by=gcd(a,b) to find out the value of x and y---->\r\n//here x and y unknown variable...we wont assingn value of x and y in the main function\r\n\r\nint gcd(int a,int b,int &x,int &y){\r\n\tif(a==0){\r\n\t\tx=0;\r\n\t\ty=1;\r\n\t\treturn b;\r\n\t}\t\r\n\tint x1,y1;\r\n\tint g=gcd(b%a,a,x1,y1);\r\n\tx=y1-(b/a)*x1;\r\n\ty=x1;\r\n\treturn g;\r\n}\r\n\r\n//nCr is here--->\r\n\r\n// int ncr(int n,int r,int m){\r\n// \tif(r<0 || r>n) return 0;\r\n// \treturn mod_div(fact[n],mod_mul(fact[r],fact[n-r],m),m);\r\n// }\r\n\r\n//number to binary array(for xor or this type of question)--->\r\n\r\n// for(int i=0;i<=32;i++)\r\n// \tif(((int)1<<i)&n) a[i]=1;\r\n\r\n//Segment Tree Implementation---->\r\n\r\n// int a[sgTree_N], tree[4*sgTree_N];\r\n\r\n// int n,l,k;\r\n\r\n// void build(int node,int st,int en){\r\n//     if(st==en){\r\n//         tree[node]=a[st];\r\n//         return;\r\n//     }\r\n//     int mid=(st+en)>>1;\r\n//     build(2*node,st,mid);\r\n//     build(2*node+1,mid+1,en);\r\n\r\n//     tree[node]=max(tree[2*node],tree[2*node+1]);\r\n// }\r\n\r\n\r\n// int query(int node,int st,int en,int l,int r){\r\n//     if(st>r||en<l)\r\n//         return -1;\r\n//     if(st>=l&&en<=r)\r\n//         return tree[node];\r\n//     int mid=(st+en)>>1;\r\n//     int q1=query(2*node,st,mid,l,r);\r\n//     int q2=query(2*node+1,mid+1,en,l,r);\r\n\r\n//     //return q1+q2;\r\n\r\n//     if(q1==-1&&q2==-1)\r\n//         return 0;\r\n//     else if(q1==-1||q2==-1)\r\n//         return max(q1,q2);\r\n//     return q1&q2;\r\n// }\r\n\r\n// void update(int node,int st,int en,int idx,int val){\r\n//     if(st==en){\r\n//         a[st]=val;\r\n//         tree[node]=val;\r\n//         return;\r\n//     }\r\n//     int mid=(st+en)>>1;\r\n//     if(idx<=mid)\r\n//         update(2*node,st,mid,idx,val);\r\n//     else\r\n//         update(2*node+1,mid+1,en,idx,val);\r\n\r\n//     tree[node]=max(tree[2*node],tree[2*node+1]);\r\n// }\r\n\r\n// Binary Search --->\r\n\r\n// int p,q,r;\r\n// vi a;\r\n \r\n// string s,s1;\r\n// // vector<double>a;\r\n// vi a;\r\n// // double n;\r\n\r\n\r\n// int n,m;\r\n// int p;\r\n// vi a;\r\n// vector<pair<int,int>>a;\r\n\r\n// bool ok(int x)\r\n// {\r\n//     int p=0,q=0;\r\n// \tfor(int i=0;i<n;i++){\r\n//         if(p<a[i].first){\r\n//             if(q+x<a[i].first){\r\n//                 return false;\r\n//             }\r\n//             else{\r\n//                 p=a[i].first;\r\n//                 q=min(q+x,a[i].second);\r\n//             }\r\n//         }\r\n//         else if(p>a[i].first){\r\n//             if(p-x>a[i].second)\r\n//                 return false;\r\n//             else{\r\n//                 q=min(q+x,a[i].second);\r\n//                 p=max(p-x,a[i].first);\r\n//             }\r\n//         }\r\n//         else{\r\n//             p=a[i].first;\r\n//             q=min(q+x,a[i].second);\r\n//         }\r\n\r\n//     }\r\n//     return true;\r\n// }\r\n\r\n\r\n// Dp part--->\r\n\r\n// int dp[N]; // here N is ---->1e7+10;\r\n// int m,v;\r\n// void gold(int x)\r\n// {\r\n//  // dp[x]=1;\r\n//  if(x==m){\r\n//      v=1;\r\n//      return;\r\n//  }\r\n//  if(x%3!=0)\r\n//      return;\r\n    \r\n//  gold(x/3);\r\n//  gold(x-(x/3));\r\n\r\n// }\r\n\r\n// vector initialization for sieve and nCr\r\n// vi pr;\r\n// vi lp(N,0) ,hp(N,0);\r\n// vector<bool> prime(N,0);\r\n\r\n\r\n\r\n// int cse=1; \r\n\r\n\r\n// vector<vector<int>>andd(2*1e5+10,vector<int>(20,0));\r\n\r\n// void bfs(queue<int>&q,vector<pair<int,int>>&a,vector<int>&vis,string s){\r\n//     while(!q.empty()){\r\n//         int x=q.front();\r\n//         q.pop();\r\n//         int l=a[x-1].first;\r\n//         int r=a[x-1].second;\r\n//         if(l!=0){\r\n//             q.push(l);\r\n//             vis[l-1]=vis[x-1];\r\n//             if(s[x-1]!='L')\r\n//                 vis[l-1]+=1;\r\n//         }\r\n//         if(r!=0){\r\n//             q.push(r);\r\n//             vis[r-1]=vis[x-1];\r\n//             if(s[x-1]!='R')\r\n//                 vis[r-1]+=1;\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n\r\nvoid solve()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    vecin(a,n);\r\n    int x=boro(a);\r\n    int y=choto(a);\r\n    int q=(x-y);\r\n    int ans=0;\r\n    if(q==0){\r\n        cout<<ans<<endl;\r\n    }\r\n    else{\r\n        int p=__lg(q);\r\n        ans+=(p+1);\r\n        cout<<ans<<endl;\r\n        if(ans<=n){\r\n            for(int i=0;i<ans;i++){\r\n                cout<<y<<\" \";\r\n            }\r\n            cout<<endl;\r\n        }\r\n    }\r\n   \r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n \r\n \r\nint32_t main()\r\n{\r\n    faster_io\r\n    #ifndef ONLINE_JUDGE\r\n        freopen(\"input.txt\",\"r\",stdin); \r\n        freopen(\"output.txt\",\"w\",stdout);\r\n    #endif\r\n    \r\n    clock_t q= clock();\r\n\r\n    // for(int i=1;i<=2*1e5;i++){\r\n    //     for(int j=0;j<20;j++){\r\n    //         if((i&((int)1<<j)))\r\n    //         {\r\n    //             andd[i][j]=andd[i-1][j]+1;\r\n    //         }\r\n    //         else{\r\n    //             andd[i][j]=andd[i-1][j];\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n\t//sieve with lower prime--->    \r\n\r\n    // prime[0]=1;\r\n    // prime[1]=1;\r\n    // for(int i=2;i<=N;i++)\r\n    // {\r\n    //     if(prime[i]==0)\r\n    //     {\r\n    //         // lp[i]=i;\r\n    //         // hp[i]=i;\r\n    //         for(int j=2*i;j<=N;j+=i){\r\n    //             prime[j]=1;\r\n    //             // if(lp[j]==0)\r\n    //             //     lp[j]=i;\r\n    //             // hp[j]=i;\r\n    //         }\r\n    //     }\r\n    // }\r\n    // for(int i=0;i<=N;i++)\r\n    // {\r\n\t   //  if(prime[i]==0){\r\n\t   //      pr.pb(i);\r\n\t   //  }\r\n    // }\r\n\r\n    //for nCr -->\r\n\r\n\r\n    // fact[0]=1;\r\n    // for(int i=1;i<N;i++)\r\n    // \tfact[i]=mod_mul(fact[i-1],i,mod);\r\n\r\n\r\n    //for icpc type contest where case is need to write\r\n    //uncomment the cse value first\r\n\r\n    // cout<<\"Case #\"<<cse<<\":\"<<endl;\r\n    // cse++;\r\n\r\n\r\n    int t=1;\r\n    cin>>t;\r\n    while(t--) solve();\r\n\r\n\r\n    \r\n \r\n    cerr << \"Run Time : \" <<((double)(clock() - q) / CLOCKS_PER_SEC);\r\n \r\n}\r\n"
}