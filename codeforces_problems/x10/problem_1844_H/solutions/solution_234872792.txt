{
    "id": 234872792,
    "contestId": 1844,
    "creationTimeSeconds": 1701235116,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1844,
        "index": "H",
        "name": "Multiple of Three Cycles",
        "type": "PROGRAMMING",
        "points": 4000.0,
        "rating": 3400,
        "tags": [
            "combinatorics",
            "data structures",
            "dp",
            "dsu",
            "math"
        ]
    },
    "author": {
        "contestId": 1844,
        "members": [
            {
                "handle": "hos.lyric"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1689086100
    },
    "programmingLanguage": "D",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 34,
    "timeConsumedMillis": 530,
    "memoryConsumedBytes": 27545600,
    "source": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\n\nstring COLOR(string s = \"\") { return \"\\x1b[\" ~ s ~ \"m\"; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(uint M_) {\n  import std.conv : to;\n  alias M = M_;\n  uint x;\n  this(ModInt a) { x = a.x; }\n  this(uint x_) { x = x_ % M; }\n  this(ulong x_) { x = cast(uint)(x_ % M); }\n  this(int x_) { x = ((x_ %= cast(int)(M)) < 0) ? (x_ + cast(int)(M)) : x_; }\n  this(long x_) { x = cast(uint)(((x_ %= cast(long)(M)) < 0) ? (x_ + cast(long)(M)) : x_); }\n  ref ModInt opAssign(T)(inout(T) a) if (is(T == uint) || is(T == ulong) || is(T == int) || is(T == long)) { return this = ModInt(a); }\n  ref ModInt opOpAssign(string op, T)(T a) {\n    static if (is(T == ModInt)) {\n      static if (op == \"+\") { x = ((x += a.x) >= M) ? (x - M) : x; }\n      else static if (op == \"-\") { x = ((x -= a.x) >= M) ? (x + M) : x; }\n      else static if (op == \"*\") { x = cast(uint)((cast(ulong)(x) * a.x) % M); }\n      else static if (op == \"/\") { this *= a.inv(); }\n      else static assert(false);\n      return this;\n    } else static if (op == \"^^\") {\n      if (a < 0) return this = inv()^^(-a);\n      ModInt b = this, c = 1U;\n      for (long e = a; e; e >>= 1) { if (e & 1) c *= b; b *= b; }\n      return this = c;\n    } else {\n      return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n    }\n  }\n  ModInt inv() const {\n    uint a = M, b = x; int y = 0, z = 1;\n    for (; b; ) { const q = a / b; const c = a - q * b; a = b; b = c; const w = y - cast(int)(q) * z; y = z; z = w; }\n    assert(a == 1); return ModInt(y);\n  }\n  ModInt opUnary(string op)() const {\n    static if (op == \"+\") { return this; }\n    else static if (op == \"-\") { ModInt a; a.x = x ? (M - x) : 0U; return a; }\n    else static assert(false);\n  }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op, T)(T a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  bool opCast(T: bool)() const { return (x != 0U); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\nenum LIM_INV = 6 * 10^^5 + 10;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM_INV];\n  fac = new Mint[LIM_INV];\n  invFac = new Mint[LIM_INV];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM_INV) {\n    inv[i] = -((Mint.M / i) * inv[cast(size_t)(Mint.M % i)]);\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM_INV) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (n < 0) {\n    if (k >= 0) {\n      return (-1)^^(k & 1) * binom(-n + k - 1, k);\n    } else if (n - k >= 0) {\n      return (-1)^^((n - k) & 1) * binom(-k - 1, n - k);\n    } else {\n      return Mint(0);\n    }\n  } else {\n    if (0 <= k && k <= n) {\n      assert(n < LIM_INV);\n      return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n    } else {\n      return Mint(0);\n    }\n  }\n}\n\nint root(int[] uf, int u) {\n  return (uf[u] < 0) ? u : (uf[u] = uf.root(uf[u]));\n}\nbool connect(int[] uf, int u, int v) {\n  u = uf.root(u);\n  v = uf.root(v);\n  if (u == v) return false;\n  if (uf[u] > uf[v]) swap(u, v);\n  uf[u] += uf[v];\n  uf[v] = u;\n  return true;\n}\n\n\n/*\n  EGF; x: 1-path, y: 2-path\n  cycle: -log(1-x-y)\n  good cycle: (-1/3)(log(1-x-y) + log(1-wx-w^2y) + log(1-w^2x-wy))  (w = 1^(1/3))\n  perm: (1-x^3-3xy-y^3)^(-1/3)\n  ?\n  \n  combinatorial\n  casework 1-path of min ID: f[a][b] = (a-1) f[a-2][b+1] + b(a+b-1) f[a-1][b-1]  (a >= 1)\n  casework 2-path of min ID: f[a][b] = a(a+b-1) f[a-1][b-1] + (b-1) f[a+1][b-2]  (b >= 1)\n  \n     1\n   g  \n    f \n  2   \n*/\n\nMint F(int a, int b) {\n  Mint ret;\n  if (a >= 0 && b >= 0 && (a - b) % 3 == 0) {\n    int k = (a + b + a % 3) / 3;\n    Mint t = 1;\n    foreach (i; 0 .. k) t *= (1 + 3 * i);\n    t *= invFac[k];\n    t *= Mint(3)^^(-k + a % 3);\n    for (int l = a % 3; l <= a && l <= b; l += 3) {\n      // binom(-1/3, k) (-1)^k (x^3)^((a-l)/3) (3xy)^l (y^3)^((b-l)/3)\n      ret += t * fac[k] * invFac[(a-l)/3] * invFac[l] * invFac[(b-l)/3];\n      t *= (1 + 3 * k);\n      t *= inv[k + 1];\n      t *= 3^^2;\n      ++k;\n    }\n    ret *= fac[a] * fac[b];\n  }\n  return ret;\n}\n\nvoid main() {\n  prepare;\n  \n  debug {{\n    enum lim = 10;\n    foreach (a; 0 .. lim) writeln(iota(lim).map!(b => F(a, b)));\n    foreach (a; 0 .. lim) foreach (b; 0 .. lim) {\n      if (a) assert(F(a, b) == (a-1) * F(a-2, b+1) + b*(a+b-1) * F(a-1, b-1));\n      if (b) assert(F(a, b) == a*(a+b-1) * F(a-1, b-1) + (b-1) * F(a+1, b-2));\n    }\n  }}\n  \n  try {\n    for (; ; ) {\n      const N = readInt;\n      auto X = new int[N];\n      auto Y = new int[N];\n      foreach (i; 0 .. N) {\n        X[i] = readInt - 1;\n        Y[i] = readInt - 1;\n      }\n      \n      int a = N, b = 0;\n      Mint f = F(a, b);\n      Mint g = F(a-1, b-1);\n      void go1() {\n        // f[a][b] = (a-1) f[a-2][b+1] + b(a+b-1) f[a-1][b-1]\n        const ff = (a >= 2) ? (inv[a-1] * (f - 1L*b*(a+b-1) * g)) : Mint(0);\n        // f[a][b] = a(a+b-1) f[a-1][b-1] + (b-1) f[a+1][b-2]\n        // f[a-2][b+1] = (a-2)(a+b-2) f[a-2-1][b+1-1] + b f[a-1][b-1]\n        const gg = (a >= 3) ? (inv[a-2] * inv[a+b-2] * (ff - b * g)) : Mint(0);\n        a -= 2;\n        b += 1;\n        f = ff;\n        g = gg;\n        assert(f == F(a, b));\n        assert(g == F(a-1, b-1));\n      }\n      void go2() {\n        const ff = (b >= 2) ? (inv[b-1] * (f - 1L*a*(a+b-1) * g)) : Mint(0);\n        const gg = (b >= 3) ? (inv[b-2] * inv[a+b-2] * (ff - a * g)) : Mint(0);\n        a += 1;\n        b -= 2;\n        f = ff;\n        g = gg;\n        assert(f == F(a, b));\n        assert(g == F(a-1, b-1));\n      }\n      \n      auto uf = new int[N];\n      uf[] = -1;\n      int[3] cnt;\n      cnt[1] += N;\n      bool valid = true;\n      foreach (i; 0 .. N) {\n        debug {\n          writeln(cnt, \" \", [a, b], \" \", [f, g]);\n        }\n        const rx = uf.root(X[i]);\n        const ry = uf.root(Y[i]);\n        if (rx != ry) {\n          --cnt[(-uf[rx]) % 3];\n          --cnt[(-uf[ry]) % 3];\n          uf.connect(rx, ry);\n          const r = uf.root(rx);\n          ++cnt[(-uf[r]) % 3];\n          if (valid) {\n            if (cnt[1] == a - 2 && cnt[2] == b + 1) {\n              go1;\n            } else if (cnt[1] == a + 1 && cnt[2] == b - 2) {\n              go2;\n            } else if (cnt[1] == a - 1 && cnt[2] == b - 1) {\n              if (cnt[1] - 2 >= 0 && cnt[2] + 1 >= 0) {\n                go1;\n                go2;\n              } else if (cnt[1] + 1 >= 0 && cnt[2] - 2 >= 0) {\n                go2;\n                go1;\n              } else {\n                --a;\n                --b;\n                f = g;\n                g = F(a, b);\n              }\n            }\n            assert(cnt[1] == a);\n            assert(cnt[2] == b);\n          }\n        } else {\n          valid = valid && ((-uf[rx]) % 3 == 0);\n          --cnt[(-uf[rx]) % 3];\n        }\n        Mint ans;\n        if (valid) {\n          ans = f;\n          // 0: insert or start cycle\n          ans *= (fac[cnt[0] + a + b] * invFac[a + b]);\n        }\n        writeln(ans);\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
}