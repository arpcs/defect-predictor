{
    "id": 202610022,
    "contestId": 220,
    "creationTimeSeconds": 1681824527,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 220,
        "index": "D",
        "name": "Little Elephant and Triangle",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2500,
        "tags": [
            "geometry",
            "math"
        ]
    },
    "author": {
        "contestId": 220,
        "members": [
            {
                "handle": "cuiaoxiang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1346427000
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 204800,
    "source": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntemplate <class T> auto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D> auto vect(const T& v, int n, D... m) {\n  return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\nusing int64 = long long;\nusing int128 = __int128_t;\nusing ii = pair<int, int>;\n#define SZ(x) (int)((x).size())\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nmt19937_64 mrand(random_device{}());\nint64 rnd(int64 x) { return mrand() % x; }\nconstexpr inline int lg2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }\nconstexpr inline int p2ceil(int64 x) { return 1 << (lg2(x - 1) + 1); }\ntemplate <class T> void out(const vector<T>& a) { for (int i = 0; i < SZ(a); ++i) cout << a[i] << \" \\n\"[i + 1 == SZ(a)]; }\ntemplate <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate <class T> void dedup(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\ninline int mod(int x) { return x >= MOD ? x - MOD : x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\n private:\n  int v;\n  static int minv(int a, int m) {\n    a %= m; assert(a);\n    return a == 1 ? 1 : int(m - int64(minv(m, a)) * int64(m) / a);\n  }\n\n public:\n  modnum() : v(0) {}\n  modnum(int64 v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { int64 v_; in >> v_; n = modnum(v_); return in; }\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const { modnum res; res.v = minv(v, MOD); return res; }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const { modnum res; res.v = v ? MOD-v : 0; return res; }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const { return neg(); }\n  modnum operator+ () const { return modnum(*this); }\n\n  modnum& operator ++ () { ++v; if (v == MOD) v = 0; return *this; }\n  modnum& operator -- () { if (v == 0) v = MOD; --v; return *this; }\n  modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n  modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n  modnum& operator *= (const modnum& o) { v = int(int64(v) * int64(o.v) % MOD); return *this; }\n  modnum& operator /= (const modnum& o) { return *this *= o.inv(); }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n  friend modnum power(modnum a, int64 n) {\n    modnum ret = 1;\n    for (; n; n >>= 1) {\n      if (n & 1) ret *= a;\n      a *= a;\n    }\n    return ret;\n  }\n};\n\nusing mint = modnum<MOD>;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  n += 1; m += 1;\n  vector<mint> cnt(4);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cnt[(i % 2) * 2 + j % 2]++;\n    }\n  }\n  mint ret = n * m;\n  ret = ret * (ret - 1) * (ret - 2);\n  ret -= cnt[0] * cnt[1] * cnt[2] * 6;\n  ret -= cnt[0] * cnt[1] * cnt[3] * 6;\n  ret -= cnt[0] * cnt[2] * cnt[3] * 6;\n  ret -= cnt[1] * cnt[2] * cnt[3] * 6;\n  trace(ret);\n  for (int x = 1; x <= n; ++x) {\n    for (int y = 1; y <= m; ++y) {\n      mint cnt = mint(n - x + 1) * (m - y + 1);\n      mint len = gcd(x, y) + 1;\n      cnt *= len * (len - 1) * (len - 2);\n      ret -= cnt;\n    }\n  }\n  cout << ret << '\\n';\n\n  return 0;\n}\n"
}