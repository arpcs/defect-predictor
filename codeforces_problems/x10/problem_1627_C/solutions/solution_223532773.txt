{
    "id": 223532773,
    "contestId": 1627,
    "creationTimeSeconds": 1694807196,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1627,
        "index": "C",
        "name": "Not Assigning",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1400,
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "number theory",
            "trees"
        ]
    },
    "author": {
        "contestId": 1627,
        "members": [
            {
                "handle": "arodnap33"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1642257300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 30,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 18124800,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing i64 = long long;\r\nusing namespace std;\r\n\r\n// constexpr int inf32 = 1E9;\r\n// constexpr int mod32 = 1E9 + 7;\r\n// constexpr i64 inf64 = 1E9 * 1E9 + 100;\r\n// constexpr i64 mod64 = 1E9 + 7;\r\n// constexpr int MAX = 1E6;\r\n// constexpr int NMAX = 1e6 + 7;\r\n// constexpr i64 mod998 = 998244353;\r\n\r\nmt19937_64 gen64(chrono::steady_clock::now().time_since_epoch().count());\r\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\r\nuniform_int_distribution<i64> distrib(1, LLONG_MAX);\r\n\r\nvoid sieve() {\r\n    int n;\r\n    vector<int> minp(n + 1);\r\n    vector<int> primes;\r\n    minp[1] = 1;\r\n    for (int i = 2; i <= n; i++) {\r\n        if (minp[i] == 0) {\r\n            minp[i] = i;\r\n            primes.push_back(i);\r\n        }\r\n        for (auto& j : primes) {\r\n            if (i * j > n) {\r\n                break;\r\n            }\r\n            minp[i * j] = j;\r\n            if (j == minp[i]) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// const int N = 5050;\r\n// vector<i64> fac(5050);\r\n// vector<i64> invfac(5050);\r\n\r\n// vector<pair<i64, i64>> primes;\r\n\r\n// i64 dp[N][N];\r\n\r\n// i64 inv(i64 x) { return binPow(x, mod64 - 2LL); }\r\n\r\n// i64 C(i64 n, i64 x) {\r\n//     return fac[n] * invfac[n - x] % mod64 * invfac[x] % mod64;\r\n// }\r\n\r\n// i64 f(i64 x, i64 y) {\r\n//     i64& res = dp[x][y];\r\n//     if (res >= 0) {\r\n//         return res;\r\n//     }\r\n//     if (x == (int)primes.size()) {\r\n//         return res = (y == 0);\r\n//     }\r\n//     res = invfac[primes[x].second] * f(x + 1, y) % mod998;\r\n\r\n//     if (y > 0) {\r\n//         res = (res + invfac[primes[x].second - 1] * f(x + 1, y - 1)) %\r\n//         mod998;\r\n//     }\r\n//     return res;\r\n// }\r\n\r\n// bool is_prime(i64 n) {\r\n//     if (n == 1) {\r\n//         return false;\r\n//     }\r\n//     for (i64 i = 2; i * i <= n; i++) {\r\n//         if (n % i == 0) {\r\n//             return false;\r\n//         }\r\n//     }\r\n//     return true;\r\n// }\r\n\r\nvector<vector<i64>> matrixMul(vector<vector<i64>>& a, vector<vector<i64>>& b,\r\n                              i64 mod) {\r\n    int n = (int)a.size();\r\n    int m = (int)b[0].size();\r\n    vector<vector<i64>> c(n, vector<i64>(m));\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            for (int k = 0; k < (int)b.size(); k++) {\r\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j] % mod) % mod;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\n// struct fenwick {\r\n//     vector<int> fenw;\r\n//     int n;\r\n\r\n//     fenwick(int _n) : n(_n + 1) { fenw.resize(n); }\r\n\r\n//     void add(int x, int v) {\r\n//         for (int i = x + 1; i < n; i += (i & (-i))) {\r\n//             fenw[i] += v;\r\n//         }\r\n//     }\r\n//     int sum(int x) {\r\n//         int y = 0;\r\n//         for (int i = x + 1; i > 0; i -= (i & (-i))) {\r\n//             y += fenw[i];\r\n//         }\r\n//         return y;\r\n//     }\r\n// };\r\n\r\n// const int d = 30;\r\n\r\n// struct XorBasis {\r\n//     int basis[d];\r\n\r\n//     void init() {\r\n//         for (int i = 0; i < d; i++) basis[i] = 0;\r\n//     }\r\n\r\n//     void insert(int mask) {\r\n//         for (int i = d - 1; i >= 0; i--) {\r\n//             if (((mask >> i) & 1) == 0) continue;\r\n\r\n//             if (!basis[i]) {\r\n//                 basis[i] = mask;\r\n//                 return;\r\n//             }\r\n//             mask ^= basis[i];\r\n//         }\r\n//     }\r\n\r\n//     void merge(const XorBasis& from) {\r\n//         for (int i = d - 1; i >= 0; i--) {\r\n//             if (!from.basis[i]) continue;\r\n\r\n//             insert(from.basis[i]);\r\n//         }\r\n//     }\r\n\r\n//     int findMax() {\r\n//         int ret = 0;\r\n//         for (int i = d - 1; i >= 0; i--) {\r\n//             if (!basis[i] || (ret >> i & 1)) continue;\r\n\r\n//             ret ^= basis[i];\r\n//         }\r\n//         return ret;\r\n//     }\r\n// };\r\n\r\nstruct DSU {\r\n    vector<int> f, siz;\r\n    DSU() {}\r\n    DSU(int n) { init(n); }\r\n    void init(int n) {\r\n        f.resize(n);\r\n        iota(f.begin(), f.end(), 0);\r\n        siz.assign(n, 1);\r\n    }\r\n\r\n    int find(int x) {\r\n        while (x != f[x]) {\r\n            x = f[x] = f[f[x]];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    bool same(int x, int y) { return find(x) == find(y); }\r\n\r\n    bool merge(int x, int y) {\r\n        x = find(x), y = find(y);\r\n        if (x == y) {\r\n            return false;\r\n        }\r\n        siz[x] += siz[y];\r\n        f[y] = x;\r\n        return true;\r\n    }\r\n\r\n    int size(int x) { return siz[find(x)]; }\r\n};\r\n\r\ni64 ceil(i64 a, i64 b) { return (a + b - 1) / b; }\r\n\r\nint ceil(int a, int b) { return (a + b - 1) / b; }\r\n\r\n// https://codeforces.com/problemset/problem/1725/C\r\n// https://codeforces.com/contest/1863/problem/E\r\n// https://codeforces.com/contest/1691/problem/D\r\n// https://codeforces.com/problemset/problem/1712/D\r\n// https://codeforces.com/problemset/problem/1696/E\r\n// https://codeforces.com/contest/1678/problem/C\r\n// https://codeforces.com/problemset/problem/1666/C\r\n// https://codeforces.com/problemset/problem/1682/D\r\n// https://codeforces.com/contest/1674/problem/E\r\n\r\n// https://codeforces.com/contest/1624/problem/F\r\n// https://codeforces.com/problemset/problem/1630/B\r\n// https://codeforces.com/problemset/problem/1632/D\r\n\r\nvoid solve() {\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> adj(n);\r\n    vector<int> ans(n - 1);\r\n    vector<pair<int, int>> edges(n - 1);\r\n    for (int i = 0; i < n - 1; i++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        --u, --v;\r\n        edges[i] = {u, v};\r\n        adj[u].push_back(i);\r\n        adj[v].push_back(i);\r\n    }\r\n\r\n    if (n == 2) {\r\n        cout << 2 << \"\\n\";\r\n        return;\r\n    }\r\n\r\n    int start = -1;\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        if (adj[i].size() > 2) {\r\n            cout << -1 << \"\\n\";\r\n            return;\r\n        }\r\n        if (adj[i].size() == 1) {\r\n            start = i;\r\n        }\r\n    }\r\n\r\n    function<void(int, int, int)> dfs = [&](int u, int p, int w) {\r\n        for (auto e : adj[u]) {\r\n            int v = edges[e].first ^ edges[e].second ^ u;\r\n            if (v == p) {\r\n                continue;\r\n            }\r\n            ans[e] = w;\r\n            dfs(v, u, 5 - w);\r\n        }\r\n    };\r\n\r\n    dfs(start, -1, 2);\r\n\r\n    for (int i = 0; i < n - 1; i++) {\r\n        cout << ans[i] << \" \\n\"[i == n - 2];\r\n    }\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int tt;\r\n    cin >> tt;\r\n    while (tt--) {\r\n        solve();\r\n    }\r\n}\r\n"
}