{
    "id": 235845764,
    "contestId": 1898,
    "creationTimeSeconds": 1701780022,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1898,
        "index": "A",
        "name": "Milica and String",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "brute force",
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 1898,
        "members": [
            {
                "handle": "Cheggg"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1700404500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 8,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define endl \"\\n\"\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define mp make_pair\r\n#define ff first\r\n#define ss second\r\n#define PI 3.141592653589793238462\r\n#define set_bits __builtin_popcountll\r\n#define sz(x) ((int)(x).size())\r\n#define GCD(x,y) __gcd(x,y)\r\n#define all(v) v.begin(),v.end()\r\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\r\n#define M 998244353\r\n#define mod 1000000007\r\n#define inf 1e18\r\n#define prDouble(x) cout << fixed << setprecision(10)<<x\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n\r\n//-------------------------------------------------------FOR DEBUGGING---------------------------------------------------------//\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\n// void _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\n//-----------------------------------------------------DEBUGGING CODE ENDS------------------------------------------------------//\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\nint isSquare(int n){ int k = sqrt(n); return (k * k == n);}\r\nint power(int x, int y){int temp;if( y == 0)return 1;temp = power(x, y / 2)%mod;if (y % 2 == 0)    return (temp * temp)%mod;else return (x * temp * temp)%mod;}\r\nvector<ll> primes_till_n(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\r\nll expo(ll a, ll b, ll MOD) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % MOD; a = (a * a) % MOD; b = b >> 1;} return res;}\r\n//ll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\r\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\r\nll combination(ll n, ll r, ll m, ll *fact, ll *ifact) {ll val1 = fact[n]; ll val2 = ifact[n - r]; ll val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}\r\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\r\nll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))\r\n//phin gives no. of co-prime numbers, co-prime to n and  smaller than n\r\n/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\nclass my_ds{\r\n    public:\r\n    int idx,score,penalty;\r\n    my_ds(int _idx,int _score,int _penalty){\r\n        idx=_idx;\r\n        score=_score;\r\n        penalty=_penalty;\r\n    }\r\n};\r\n\r\nbool isPowerOfTwo(int n){\r\n    return !(n&(n-1));\r\n}\r\nbool cmp(my_ds&a,my_ds&b){\r\n    if(a.score==b.score){\r\n        if(a.penalty==b.penalty){\r\n            return a.idx<b.idx;\r\n        }\r\n        \r\n        return a.penalty<b.penalty;\r\n        \r\n    }\r\n    return a.score>b.score;\r\n}\r\n\r\n//-----------------------------------------------------DISJOINT SET CODE STARTS------------------------------------------------------//\r\n\r\nclass DisjointSet {\r\npublic:\r\n    vector<int> rank, parent, size;\r\n    DisjointSet(int n) {\r\n        rank.resize(n + 1, 0);\r\n        parent.resize(n + 1);\r\n        size.resize(n + 1);\r\n        for (int i = 0; i <= n; i++) {\r\n            parent[i] = i;\r\n            size[i] = 1;\r\n        }\r\n    }\r\n    \r\n    //Find Ultimate Parent\r\n    int findUPar(int node) {\r\n        if (node == parent[node])\r\n            //It means that node is the ultimate parent\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionByRank(int u, int v) {\r\n        //Find Ultimate parent of u and v\r\n        int ulp_u = findUPar(u);\r\n        int ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v) return;\r\n        //Check the rank of both parent add the parent of lower rank node in higher rank node\r\n        if (rank[ulp_u] < rank[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n        }\r\n        else if (rank[ulp_v] < rank[ulp_u]) {\r\n            parent[ulp_v] = ulp_u;\r\n        }\r\n        else {\r\n            parent[ulp_v] = ulp_u;\r\n            rank[ulp_u]++;\r\n        }\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int ulp_u = findUPar(u);\r\n        int ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v) return;\r\n        if (size[ulp_u] < size[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n            size[ulp_v] += size[ulp_u];\r\n        }\r\n        else {\r\n            parent[ulp_v] = ulp_u;\r\n            size[ulp_u] += size[ulp_v];\r\n        }\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int makeConnected(int n, vector<vector<int>>& edge) {\r\n        //Find the number of connected components \r\n        //We need connected components-1 edges to connect all elements\r\n        //Find the number of extra edges in the graph\r\n        DisjointSet ds(n);\r\n        int cntExtras = 0;\r\n        //Check number of extraedges\r\n        for (auto it : edge) {\r\n            int u = it[0];\r\n            int v = it[1];\r\n            //If ultimate Parent of both nodes is same then it is a extra node\r\n            if (ds.findUPar(u) == ds.findUPar(v)) {\r\n                cntExtras++;\r\n            }\r\n            else {\r\n                ds.unionByRank(u,v);\r\n            }\r\n        }\r\n\r\n        //Check number of connected components\r\n        int cntC = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (ds.parent[i] == i){\r\n                cntC++;\r\n            }\r\n        }\r\n        int ans = cntC - 1;\r\n        if (cntExtras >= ans) return ans;\r\n        return -1;\r\n     \r\n    }\r\n};\r\n\r\n//-----------------------------------------------------DIJISTRA ALGO CODE ------------------------------------------------------//\r\n\r\nclass Dijistra{\r\npublic:\r\n    Dijistra(vector<vector<int>>& grid,int n,int u,int v){\r\n    vector<pair<int,int>> adj[n+1]; \r\n        \r\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater <pair<int,int>>> pq;\r\n\r\n    for(auto it:grid){\r\n        adj[it[0]].push_back({it[1],it[2]});\r\n    }\r\n\r\n    vector<int> dist(n+1,1e9);\r\n\r\n    dist[u]=0;\r\n    pq.push({0,u});\r\n\r\n    while(!pq.empty()){\r\n        auto it=pq.top();\r\n        pq.pop();\r\n        int dis=it.first;\r\n        int node=it.second;\r\n\r\n        for(auto it:adj[node]){\r\n            int adjnode=it.first;\r\n            int wt=it.second;\r\n\r\n            if(dist[adjnode]>dis+wt){\r\n                dist[adjnode]=wt+dis;\r\n                pq.push({dis+wt,adjnode});\r\n            }\r\n        }\r\n    }\r\n\r\n    if(dist[v]==1e9){\r\n        cout<<\"NO\"<<endl;\r\n    } \r\n    else{\r\n        cout<<dist[v]<<endl;\r\n    }\r\n    }\r\n};\r\n\r\nclass LowestCommonAncestor{\r\npublic:\r\n    vector<vector<int>>up;\r\n    vector<int>level;\r\n    LowestCommonAncestor(int n,int max_bits){\r\n        up.resize(n+1,vector<int>(max_bits,-1));\r\n        level.resize(n+1,0);\r\n    }\r\n\r\n    void preCompute(vector<int>adj[], int node, int par){\r\n        for(int i=1;i<20;i++){\r\n            if(up[node][i-1]!=-1){\r\n                up[node][i]=up[up[node][i-1]][i-1];\r\n            }\r\n            else{\r\n                up[node][i]=-1;\r\n            }\r\n        }\r\n        for(auto child:adj[node]){\r\n            if(child==par)continue;\r\n            up[child][0]=node;\r\n            level[child]=level[node]+1;\r\n            preCompute(adj,child,node);\r\n        }\r\n    }\r\n    int lift(int node,int k){\r\n        if(k==0)return node;\r\n        int p=log2(k);\r\n        // cout<<node<<\" \"<<k<<\" \"<<p<<\" \"<<up[node][p]<<endl;\r\n        int parent=up[node][p];\r\n        if(parent==-1)return -1;\r\n        return lift(parent,k-(1<<p));\r\n    }\r\n\r\n    int LCA(int u, int v){\r\n        if(level[u]<level[v])swap(u,v);\r\n\r\n        int diff=level[u]-level[v];\r\n        u=lift(u,diff);\r\n        \r\n        if(u==v){\r\n            return u;\r\n        }\r\n        for(int i=19;i>=0;i--){\r\n            if(up[u][i]!=up[v][i]){\r\n                u=up[u][i];\r\n                v=up[v][i];\r\n            }\r\n        }\r\n        return up[u][0];\r\n    }\r\n\r\n};\r\n\r\nclass SparseMinimum{\r\n    int max_bits;\r\npublic:\r\n    vector<vector<int>>sparse;\r\n    SparseMinimum(vector<int>&v, int bits){\r\n        max_bits=bits;\r\n        int N=v.size();\r\n        sparse.resize(N,vector<int>(bits,0));\r\n        buildSparseTable(v);\r\n    }\r\n\r\n    void buildSparseTable(vector<int>&v){\r\n        int n=v.size();\r\n        for(int L=n-1;L>=0;L--){\r\n            sparse[L][0]=v[L];\r\n            for(int w=1;w<max_bits;w++){\r\n                int R= L+(1<<w)-1;\r\n                if(R>=n)break;\r\n                sparse[L][w]=min(sparse[L][w-1],sparse[L+(1<<(w-1))][w-1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    int minQuery(int L, int R){\r\n        int w=log2(R-L+1)+0.00001;\r\n        return min(sparse[L][w],sparse[R-(1<<w)+1][w]);\r\n    }\r\n};\r\n\r\nclass ST{\r\n    vector<int>seg,lazy;\r\n    int N;\r\n    bool orr;\r\n    void build(vector<int>&arr,int low,int high, int idx){\r\n        if(low==high){\r\n            seg[idx]=arr[low];\r\n            return ;\r\n        }\r\n        int mid=low+(high-low)/2;\r\n        build(arr,low,mid,2*idx+1);\r\n        build(arr,mid+1,high,2*idx+2);\r\n        seg[idx]=min(seg[2*idx+1],seg[2*idx+2]);\r\n    }\r\n\r\n    void update(int idx, int low, int high,int l, int r, int val){\r\n        if(lazy[idx]!=0){\r\n            seg[idx]+=lazy[idx];\r\n            if(low!=high){\r\n                lazy[2*idx+1]+=lazy[idx];\r\n                lazy[2*idx+2]+=lazy[idx];\r\n            }\r\n            lazy[idx]=0;\r\n        }\r\n        if(low>r || high<l || low>high)return;\r\n        if(low>=l && high<=r){\r\n            if(low!=high){\r\n                lazy[2*idx+1]+=val;\r\n                lazy[2*idx+2]+=val;\r\n            }\r\n            seg[idx]+=val;\r\n            return;\r\n        }\r\n        int mid=low+(high-low)/2;\r\n        update(idx*2+1,low,mid,l,r,val);\r\n        update(idx*2+2,mid+1,high,l,r,val);\r\n        seg[idx]=min(seg[2*idx+1],seg[2*idx+2]);    \r\n\r\n    }\r\n\r\n    int query(int idx, int low,int high, int left,int right){\r\n        if(lazy[idx]!=0){\r\n            seg[idx]+=lazy[idx];\r\n            if(low!=high){\r\n                lazy[2*idx+1]+=lazy[idx];\r\n                lazy[2*idx+2]+=lazy[idx];\r\n            }\r\n            lazy[idx]=0;\r\n        }\r\n        if(high<left || low>right || low>high)return INT_MAX;\r\n        if(low>=left && high<=right)return seg[idx];\r\n        int mid=low+(high-low)/2;\r\n        int l=query(idx*2+1,low,mid,left,right);\r\n        int r=query(idx*2+2,mid+1,high,left,right);\r\n        return min(l,r);\r\n    }\r\npublic:\r\n    ST(vector<int>&v){\r\n        N=v.size();\r\n        seg.resize(4*N);\r\n        lazy.resize(4*N,0);\r\n        build(v,0,N-1,0);\r\n    }\r\n\r\n    void update(int l, int r, int val){\r\n        update(0,0,N-1,l,r,val);\r\n    }\r\n\r\n    int query(int L,int R){\r\n        return query(0,0,N-1,L,R);\r\n    }   \r\n};\r\n\r\n//-------------------------------------------------------MAIN FUNCTION----------------------------------------------------------//\r\nsigned main(){\r\n    fast_io;\r\n    #ifndef ONLINE_JUDGE\r\n        freopen(\"Error.txt\", \"w\", stderr);\r\n        freopen(\"input.txt\", \"r\", stdin);\r\n        freopen(\"output.txt\",  \"w\", stdout);\r\n    #endif\r\n    ll t=1;\r\n    cin>>t;\r\n    while(t--){\r\n        ll n,k;\r\n        cin>>n>>k;\r\n        string s;cin>>s;\r\n\r\n        ll count=0;\r\n        for(ll i=0;i<n;i++){\r\n            if(s[i]=='B'){\r\n                count++;\r\n            }\r\n        }\r\n\r\n        if(count==k){\r\n            cout<<0;\r\n        }\r\n        else if(count<k){\r\n            ll ind=-1;\r\n            for(ll i=0;i<n;i++){\r\n                if(s[i]=='A'){\r\n                    count++;\r\n                }\r\n\r\n                if(count==k){\r\n                    ind=i+1;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            cout<<1<<endl;\r\n            cout<<ind<<\" \"<<'B';\r\n        }\r\n        else{\r\n            ll ind1=-1;\r\n            for(ll i=0;i<n;i++){\r\n                if(s[i]=='B'){\r\n                    count--;\r\n                }\r\n\r\n                if(count==k){\r\n                    ind1=i+1;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            cout<<1<<endl;\r\n            cout<<ind1<<\" \"<<'A';\r\n        }\r\n\r\n        cout<<endl;\r\n    } \r\n    return 0;\r\n}"
}