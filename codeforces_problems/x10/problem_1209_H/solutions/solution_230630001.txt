{
    "id": 230630001,
    "contestId": 1209,
    "creationTimeSeconds": 1698733188,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1209,
        "index": "H",
        "name": "Moving Walkways",
        "type": "PROGRAMMING",
        "points": 4000.0,
        "rating": 3300,
        "tags": [
            "data structures",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1209,
        "members": [
            {
                "handle": "galen_colin"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1568466300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 63,
    "timeConsumedMillis": 1341,
    "memoryConsumedBytes": 76800000,
    "source": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n \r\n// #pragma GCC optimize(\"O3,unroll-loops\")\r\n// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n \r\n/* \r\nfind my code templates at https://github.com/galencolin/cp-templates\r\nalso maybe subscribe please thanks \r\n*/\r\n \r\n#define send {ios_base::sync_with_stdio(false);}\r\n#define help {cin.tie(NULL);}\r\n#define f first\r\n#define s second\r\n#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}\r\n \r\nusing ll = long long;\r\n// using ll = int;\r\n// #pragma warning(\"int\")\r\n//\r\nusing vl = vector<ll>;\r\nusing pl = pair<ll, ll>;\r\n \r\ntypedef long double ld;\r\ntypedef unsigned long long ull;\r\n \r\n#include <ext/pb_ds/assoc_container.hpp> \r\n#include <ext/pb_ds/tree_policy.hpp>\r\n \r\nusing namespace std;\r\nusing namespace __gnu_pbds; \r\n \r\ntemplate <typename num_t>\r\nusing ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;\r\n \r\n// benq - print any container + pair\r\ntemplate<typename T, typename = void> struct is_iterable : false_type {};\r\ntemplate<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};\r\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);\r\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\r\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {\r\n    cout << \"[\"; \r\n    for (auto it = v.begin(); it != v.end();) {\r\n        cout << *it;\r\n        if (++it != v.end()) cout << \", \";\r\n    }\r\n    return cout << \"]\";\r\n}\r\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\r\n    cin >> p.first;\r\n    return cin >> p.second;\r\n}\r\n\r\ntemplate<typename T> void debug(string s, T x) {cerr << \"\\033[1;34m\" << s << \"\\033[0;32m = \\033[35m\" << x << \"\\033[0m\\n\";}\r\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) {for (int i=0, b=0; i<(int)s.size(); i++) if (s[i] == '(' || s[i] == '{') b++; else\r\n        if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {cerr << \"\\033[1;34m\" << s.substr(0, i) << \"\\033[0;32m = \\033[35m\" << x << \"\\033[31m | \"; debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}\r\ntemplate<typename T> void debug_nameless(T x) {cerr << \"\\033[35m\" << x << \"\\033[0m\\n\";}\r\ntemplate<typename T, typename... Args> void debug_nameless(T x, Args... args) {cerr << \"\\033[35m\" << x << \"\\033[31m | \"; debug_nameless(args...);}\r\n\r\n#ifdef galen_colin_local\r\n#define pr(...) debug(#__VA_ARGS__, __VA_ARGS__)\r\n#define prs(...) debug_nameless(__VA_ARGS__)\r\nconst bool local_ = true;\r\n#else\r\n#define pr(...) 135\r\n#define prs(...) 135\r\nconst bool local_ = false;\r\n#endif\r\n \r\nmt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\r\n// mt19937_64 rng(61378913);\r\n/* usage - just do rng() */\r\n \r\nvoid usaco(string filename) {\r\n  // #pragma message(\"be careful, freopen may be wrong\")\r\n    freopen((filename + \".in\").c_str(), \"r\", stdin);\r\n    freopen((filename + \".out\").c_str(), \"w\", stdout);\r\n}\r\n \r\n// #include <atcoder/all>\r\n// using namespace atcoder;\r\n \r\nconst ld pi = 3.14159265358979323846;\r\nconst ll mod = 1000000007;\r\n// const ll mod = 998244353;\r\n// ll mod;\r\n\r\n\r\n\r\nll n, m, q, k, l, r, x, y, z;\r\nconst ll template_array_size = 1e6 + 121532;\r\nll a[template_array_size];\r\nll b[template_array_size];\r\nll c[template_array_size];\r\nstring s, t;\r\n\r\nconst ld eps = 1e-12;\r\nstruct line {\r\n    ll l, r;\r\n    ld x;\r\n\r\n    bool operator <(const line other) const {\r\n        return x < other.x - eps;\r\n    }\r\n};\r\nvector<line> v;\r\nvector<ld> ps;\r\n\r\nld gs(ll l, ll r) {\r\n    if (l > r) return 0;\r\n    r = min(r, n - 1);\r\n    ld v = ps[r];\r\n    if (l > 0) v -= ps[l - 1];\r\n    return v;\r\n}\r\n\r\nstruct seg {\r\n    ll l, r, i;\r\n    ld e;\r\n\r\n    bool operator <(const seg& other) const {\r\n        if (r != other.r) return r < other.r;\r\n        return i < other.i;\r\n    }\r\n};\r\n\r\nostream &operator <<(ostream &cout, line l) {\r\n    return cout << \"(\" << l.l << \", \" << l.r << \", \" << l.x << \")\";\r\n}\r\nostream &operator <<(ostream &cout, seg l) {\r\n    return cout << \"(\" << l.l << \", \" << l.r << \", \" << l.i << \", \" << l.e << \")\";\r\n}\r\n\r\nvector<pair<line, ll>> st;\r\nset<seg> segs;\r\n\r\n// find last reached seg\r\nll reach(ll p, ld e) {\r\n    ll l = p + 1, r = n;\r\n    while (l < r) {\r\n        ll m = (l + r) / 2;\r\n        if (gs(p + 1, m) <= e + eps) l = m + 1;\r\n        else r = m;\r\n    }\r\n    return l;\r\n}\r\n\r\npair<ll, ld> ext(ll i) {\r\n    auto [l, r, x] = v[i];\r\n    if (x < eps) return {0, 0};\r\n    ld e = (r - l) / x;\r\n\r\n    auto it = segs.lower_bound({i, i, -1, 0});\r\n\r\n    if (it != segs.end() && it->l <= i && it->r == n) return {2, 0};\r\n\r\n    vector<seg> bad;\r\n\r\n    ll p = i;\r\n\r\n    ll st = i;\r\n\r\n    ld w = e;\r\n\r\n    if (it != segs.end()) {\r\n        pr(l, r, x, *it);\r\n        if (it->l <= i) {\r\n            st = min(st, it->l);\r\n            if (it->i >= i) {\r\n                e += (r - l) / (x + 2);\r\n            }\r\n            if (it->i < i) {\r\n                e -= gs(it->i + 1, i - 1);\r\n            }\r\n            p = max(p, it->i);\r\n            e += it->e;\r\n            w = e;\r\n            bad.push_back(*it);\r\n            ++it;\r\n        }\r\n    }\r\n\r\n    ld ct = 0;\r\n    while (e > -eps) {\r\n        if (it == segs.end()) {\r\n            ld rest = gs(p + 1, n - 1);\r\n            for (auto x: bad) segs.erase(x);\r\n            pr(e, rest);\r\n            if (e < rest - eps) {\r\n                segs.insert({st, reach(p, e), p, e});\r\n                return {0, 0};\r\n            }\r\n            e -= rest;\r\n            w = min(w, e);\r\n            break;\r\n        }\r\n        if (it != segs.end()) {\r\n            ld take = gs(p + 1, it->l - 1);\r\n            if (e < take - eps) {\r\n                for (auto x: bad) segs.erase(x);\r\n                segs.insert({st, reach(p, e), p, e});\r\n                return {0, 0};\r\n            }\r\n            e -= take;\r\n            w = min(w, e);\r\n        }\r\n        e += it->e;\r\n        st = min(st, it->l);\r\n        p = it->i;\r\n        bad.push_back(*it);\r\n        ++it;\r\n    }\r\n\r\n    segs.insert({st, n, n - 1, 0});\r\n\r\n    e = (r - l) / x - w;\r\n\r\n    return {1, e};\r\n}\r\n\r\nvoid solve(int tc = 0) {\r\n    ll last = 0;\r\n    cin >> n >> k;\r\n    for (ll i = 0; i < n; i++) {\r\n        ll x, y;\r\n        ld z;\r\n        cin >> x >> y >> z;\r\n        if (x != last) v.push_back({last, x, 0});\r\n        v.push_back({x, y, z});\r\n        last = y;\r\n    }\r\n    if (last != k) v.push_back({last, k, 0});\r\n\r\n    n = v.size();\r\n\r\n    st = vector<pair<line, ll>>(n);\r\n    \r\n    for (ll i = 0; i < n; i++) st[i] = {v[i], i};\r\n    sort(st.begin(), st.end());\r\n    reverse(st.begin(), st.end());\r\n\r\n    ps = vector<ld>(n);\r\n\r\n    {\r\n        ld s = 0;\r\n        for (ll i = 0; i < n; i++) {\r\n            auto [l, r, x] = v[i];\r\n            s += (r - l) / (x + 2);\r\n            ps[i] = s;\r\n        }\r\n    }\r\n\r\n    pr(ps);\r\n\r\n    ld ans = 0;\r\n\r\n    for (auto [v, i]: st) {\r\n        auto [l, r, x] = v;\r\n        \r\n        auto ret = ext(i);\r\n\r\n        pr(ret);\r\n        pr(segs);\r\n\r\n        if (ret.f == 2) {\r\n            ans += (r - l) / (x + 2);\r\n        } else if (ret.f == 1) {\r\n            ld e = ret.s;\r\n\r\n            // p: (r - l) * p / x - (r - l) * (1 - p) / (x + 2) = e\r\n            // p * (r - l) * (1 / x + 1 / (x + 2)) = e + (r - l) / (x + 2)\r\n\r\n            ld p = (e + (r - l) / (x + 2)) / ((r - l) * (1 / x + 1 / (x + 2)));\r\n            ans += (r - l) * p / x + (r - l) * (1 - p) / (x + 2);\r\n            pr(p);\r\n\r\n        } else {\r\n            if (x >= eps) {\r\n                ans += (r - l) / x;\r\n            }\r\n        }\r\n        pr(ans);\r\n    }\r\n\r\n    pr(ans);\r\n\r\n    vector<ld> ev(n);\r\n\r\n    pr(\"EV\", segs);\r\n\r\n    for (auto [l, r, i, e]: segs) {\r\n        for (ll j = l; j <= i; j++) ev[j] = 1e15;\r\n        for (ll j = i + 1; j <= min(n - 1, r); j++) {\r\n            if (v[j].x < eps) {\r\n                ld c = (v[j].r - v[j].l) / (v[j].x + 2);\r\n                ev[j] = min(e, c);\r\n                e -= min(e, c);\r\n            }\r\n        }\r\n    }\r\n\r\n    pr(ev);\r\n\r\n    for (ll i = 0; i < n; i++) if (v[i].x < eps) {\r\n        auto [l, r, x] = v[i];\r\n        if (ev[i] > 1e14) {\r\n            ans += (r - l) / (x + 2);\r\n        } else {\r\n            ld e = ev[i];\r\n            ans += e + (r - l - (x + 2) * e) / (x + 1);\r\n        }\r\n    }\r\n\r\n    cout << ans << '\\n';\r\n}\r\n\r\nint main() {\r\n    #ifdef galen_colin_local\r\n        auto begin = std::chrono::high_resolution_clock::now();\r\n    #endif\r\n    \r\n    send help\r\n \r\n    #ifndef galen_colin_local\r\n        // usaco(\"evacuation\");\r\n    #endif\r\n    \r\n    // usaco(\"cowland\");\r\n    \r\n    // freopen(\"tc.cpp\", \"r\", stdin);\r\n    // freopen(\"tc.cpp\", \"w\", stdout);\r\n    // freopen(\"tc2.cpp\", \"w\", stdout);\r\n    // freopen(\"in.txt\", \"r\", stdin);\r\n    // freopen(\"out.txt\", \"w\", stdout);\r\n\r\n\r\n        \r\n    cout << setprecision(15) << fixed;\r\n    cerr << setprecision(4) << fixed;\r\n            \r\n    int tc = 1;\r\n    // cin >> tc;\r\n    for (int t = 0; t < tc; t++) {\r\n        pr(t); prs(string(50, '-'));\r\n        solve(t);\r\n        prs(string(50, '-') + \"\\n\");\r\n    }\r\n    \r\n    #ifdef galen_colin_local\r\n        auto end = std::chrono::high_resolution_clock::now();\r\n        cerr << setprecision(4) << fixed;\r\n        cerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;\r\n    #endif\r\n}"
}