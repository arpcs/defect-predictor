{
    "id": 211936072,
    "contestId": 487,
    "creationTimeSeconds": 1688382434,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 487,
        "index": "E",
        "name": "Tourists",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3200,
        "tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "trees"
        ]
    },
    "author": {
        "contestId": 487,
        "members": [
            {
                "handle": "INF_512"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1416590400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 20,
    "timeConsumedMillis": 280,
    "memoryConsumedBytes": 47923200,
    "source": "// # [\u9898\u76ee\u5927\u610f](https://codeforc.es/problemset/problem/487/E)\r\n\r\n// \u7ed9\u5b9a\u4e00\u5f20\u56fe\uff08\u4fdd\u8bc1\u8fde\u901a\uff09\uff0c\u6bcf\u4e2a\u70b9\u6709\u70b9\u6743\u3002\u73b0\u5728\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a\r\n\r\n// - $C$ $a$ $w$ :\u628a $a$ \u7684\u70b9\u6743\u6539\u4e3a $w$\r\n\r\n// - $A$ $a$ $b$ :\u8be2\u95ee\u4ece $a$ \u5230 $b$ \u7684\u6240\u6709\u7b80\u5355\u8def\u5f84\uff08\u4e0d\u7ecf\u8fc7\u91cd\u590d\u70b9\uff09\u4e2d\uff0c\u70b9\u6743\u6700\u5c0f\u7684\u70b9\u7684\u70b9\u6743\r\n\r\n// # \u89e3\u9898\u601d\u8def\r\n\r\n// targan \u6c42\u51fa\u6240\u6709\"\u70b9-\u53cc\u8fde\u901a\u5206\u91cf\"\r\n\r\n// \u5c06\u539f\u56fe\u7684\u8282\u70b9\u770b\u4f5c\u5706\u70b9\uff0c\"\u70b9-\u53cc\u8fde\u901a\u5206\u91cf\"\u770b\u4f5c\u65b9\u70b9\uff0c\u6bcf\u4e2a\"\u70b9-\u53cc\u8fde\u901a\u5206\u91cf\"\u5411\u5b83\u6240\u5305\u542b\u7684\u8282\u70b9\u8fde\u4e00\u6761\u8fb9\uff0c\u5efa\u7acb\u5706\u65b9\u6811\uff0c\u4efb\u9009\u4e00\u4e2a\u6839\u8282\u70b9\r\n\r\n// \u5706\u70b9\u7684\u6743\u503c\u4e3a\u81ea\u8eab\uff0c\u65b9\u70b9\u7684\u6743\u503c\u4e3a\u6240\u6709\u513f\u5b50\u6743\u503c\u7684\u6700\u5c0f\u503c\uff0c\u7528multset\u7ef4\u62a4\u5355\u4e2a\u65b9\u70b9\u7684\u6240\u6709\u513f\u5b50\u8282\u70b9\u7684\u6743\u503c\uff0c\u6bcf\u4e2a\u65b9\u70b9\u7684\u5b9e\u9645\u6743\u503c\u4e3a min(\u6240\u6709\u513f\u5b50\u8282\u70b9\u7684\u6743\u503c,\u7236\u8282\u70b9\u7684\u6743\u503c)\r\n\r\n// \u7528\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u6811\u4e0a\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\r\n\r\n// \u64cd\u4f5c 1 \u8868\u793a\u6539\u53d8\u4e00\u4e2a\u5706\u70b9\u7684\u6743\u503c\uff0c\u66f4\u65b0\u5b83\u7684\u7236\u4eb2\u8282\u70b9\u7684 multiset \uff0c\u518d\u7528\u7236\u4eb2\u8282\u70b9\u7684\u5b9e\u9645\u6743\u503c\u66f4\u65b0\u7ebf\u6bb5\u6811\r\n\r\n// \u64cd\u4f5c 2 \u8868\u793a\u6c42 a \u5230 b \u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u6700\u5c0f\u503c\r\n\r\n// \u7efc\u4e0a\uff0c\u5c06\u56fe\u8f6c\u6362\u6210\u6811\uff0c\u5c06\u6240\u6709\u8def\u5f84\u8f6c\u6362\u4e3a\u552f\u4e00\u8def\u5f84\uff0c\u89e3\u51fa\u7b54\u6848\r\n\r\n// # \u4ee3\u7801\u5b9e\u73b0\r\n\r\n// tarjan \u7f29\u70b9\r\n// #include <bits/stdc++.h>\r\n// using namespace std;\r\n// #define int long long\r\n// #define endl '\\n'\r\n// const int N = 1e5 + 5;\r\n// int n, m, a[N];\r\n// array<int, 2> ed[N];\r\n// vector<vector<int>> g;\r\n// int dfn[N], low[N], vis[N], tim, fa[N], sz[N], cnt, dp[N];\r\n// vector<int> ver;\r\n// void tarjan(int u) {\r\n//   dfn[u] = low[u] = ++tim;\r\n//   ver.push_back(u);\r\n//   vis[u] = 1;\r\n//   for (auto&& v : g[u]) {\r\n//     if (vis[v] == 0) {\r\n//       tarjan(v);\r\n//       low[u] = min(low[u], low[v]);\r\n//     }\r\n//     else if (vis[v] == 1)\r\n//       low[u] = min(low[u], dfn[v]);\r\n//   }\r\n//   if (low[u] == dfn[u]) {\r\n//     sz[++cnt] = 0;\r\n//     while (1) {\r\n//       int v = ver.back();\r\n//       ver.pop_back();\r\n//       sz[cnt] += a[v];\r\n//       fa[v] = cnt;\r\n//       vis[v] = 2;\r\n//       if (v == u) break;\r\n//     }\r\n//   }\r\n//   // vis[u] = 2;\r\n// }\r\n// int dfs(int u) {\r\n//   if (dp[u] != -1)\r\n//     return dp[u];\r\n//   dp[u] = sz[u];\r\n//   for (auto&& v : g[u])\r\n//     dp[u] = max(dp[u], dfs(v) + sz[u]);\r\n//   return dp[u];\r\n// }\r\n// void test() {\r\n//   cin >> n >> m;\r\n//   g.assign(n + 1, {});\r\n//   for (int i = 1; i <= n; i++)\r\n//     cin >> a[i];\r\n//   for (int i = 1; i <= m; i++) {\r\n//     int x, y;\r\n//     cin >> x >> y;\r\n//     ed[i] = { x, y };\r\n//     g[x].push_back(y);\r\n//   }\r\n//  for (int i = 1; i <= n; i++)\r\n//    if (vis[i] == 0)\r\n//      tarjan(i);\r\n//   for (int i = 1; i <= n; i++)\r\n//     cout << fa[i] << ' ';\r\n//   cout << endl;\r\n//   g.assign(cnt + 1, {});\r\n//   for (int i = 1; i <= m; i++) {\r\n//     auto [x, y] = ed[i];\r\n//     if (fa[x] != fa[y])\r\n//       g[fa[x]].push_back(fa[y]);\r\n//   }\r\n//   memset(dp, -1, sizeof(dp));\r\n//   int ans = -1;\r\n//   for (int i = 1; i <= cnt; i++)\r\n//     ans = max(ans, dfs(i));\r\n//   cout << ans << endl;\r\n// }\r\n// signed main() {\r\n//   ios::sync_with_stdio(0);\r\n//   cin.tie(0);\r\n//   test();\r\n//   return 0;\r\n// }\r\n\r\n// tarjan \u5272\u70b9\r\n// #include <bits/stdc++.h>\r\n// using namespace std;\r\n// #define int long long\r\n// #define endl '\\n'\r\n// const int N = 1e5 + 5;\r\n// int n, m;\r\n// vector<vector<int>> g;\r\n// int dfn[N], low[N], vis[N], tim;\r\n// vector<int> ver, ans;\r\n// void tarjan(int u, int f) {\r\n//   dfn[u] = low[u] = ++tim;\r\n//   ver.push_back(u);\r\n//   vis[u] = 1;\r\n//   int son = 0;\r\n//   for (auto&& v : g[u]) {\r\n//     if (v != f) {\r\n//       if (vis[v] == 0) {\r\n//         tarjan(v, u);\r\n//         low[u] = min(low[u], low[v]);\r\n//         son++;\r\n//         if (f != -1 && low[v] >= dfn[u])\r\n//           ans.push_back(u);\r\n//       }\r\n//       else if (vis[v] == 1)\r\n//         low[u] = min(low[u], dfn[v]);\r\n//     }\r\n//   }\r\n//   if (f == -1 && son >= 2)\r\n//     ans.push_back(u);\r\n//   if (low[u] == dfn[u]) {\r\n//     while (1) {\r\n//       int v = ver.back();\r\n//       ver.pop_back();\r\n//       vis[v] = 2;\r\n//       if (v == u) break;\r\n//     }\r\n//   }\r\n// }\r\n// void test() {\r\n//   cin >> n >> m;\r\n//   g.assign(n + 1, {});\r\n//   for (int i = 1; i <= m; i++) {\r\n//     int x, y;\r\n//     cin >> x >> y;\r\n//     g[x].push_back(y);\r\n//     g[y].push_back(x);\r\n//   }\r\n//   for (int i = 1; i <= n; i++)\r\n//     if (vis[i] == 0)\r\n//       tarjan(i, -1);\r\n//   sort(ans.begin(), ans.end());\r\n//   ans.erase(unique(ans.begin(), ans.end()), ans.end());\r\n//   cout << ans.size() << endl;\r\n//   for (auto&& v : ans)\r\n//     cout << v << ' ';\r\n//   cout << endl;\r\n// }\r\n// signed main() {\r\n//   ios::sync_with_stdio(0);\r\n//   cin.tie(0);\r\n//   test();\r\n//   return 0;\r\n// }\r\n\r\n// tarjan \u70b9\u53cc\u8fde\u901a\u5206\u91cf\uff08\u4e0d\u5305\u542b\u5272\u70b9\u7684\u6781\u5927\u5f3a\u8fde\u901a\u5b50\u56fe\uff09\r\n// #include <bits/stdc++.h>\r\n// using namespace std;\r\n// #define int long long\r\n// // #define endl \" line in \" << __LINE__ << endl\r\n// const int N = 2e6 + 5;\r\n// int n, m;\r\n// vector<vector<int>> g, ans;\r\n// int dfn[N], low[N], vis[N], tim;\r\n// vector<int> ver;\r\n// void tarjan(int u, int f) {\r\n//   if (f == -1 && g[u].size() == 0) {\r\n//     ans.push_back({ u });\r\n//     return;\r\n//   }\r\n//   dfn[u] = low[u] = ++tim;\r\n//   ver.push_back(u);\r\n//   vis[u] = 1;\r\n//   for (auto&& v : g[u]) {\r\n//     if (vis[v] == 0) {\r\n//       tarjan(v, u);\r\n//       low[u] = min(low[u], low[v]);\r\n//       if (low[v] == dfn[u]) {\r\n//         vector<int> tmp;\r\n//         while (1) {\r\n//           int x = ver.back();\r\n//           vis[x] = 2;\r\n//           tmp.push_back(x);\r\n//           ver.pop_back();\r\n//           if (x == v) break;\r\n//         }\r\n//         tmp.push_back(u);\r\n//         ans.push_back(tmp);\r\n//       }\r\n//     }\r\n//     else if (vis[v] == 1)\r\n//       low[u] = min(low[u], dfn[v]);\r\n//   }\r\n// }\r\n// void test() {\r\n//   cin >> n >> m;\r\n//   g.assign(n + 1, {});\r\n//   for (int i = 1; i <= m; i++) {\r\n//     int u, v;\r\n//     cin >> u >> v;\r\n//     if (u == v)\r\n//       continue;\r\n//     g[u].push_back(v);\r\n//     g[v].push_back(u);\r\n//   }\r\n//   for (int i = 1; i <= n; i++)\r\n//     if (vis[i] == 0)\r\n//       tarjan(i, -1);\r\n//   cout << ans.size() << endl;\r\n//   for (auto&& vec : ans) {\r\n//     cout << vec.size() << ' ';\r\n//     for (auto&& x : vec)\r\n//       cout << x << ' ';\r\n//     cout << endl;\r\n//   }\r\n// }\r\n// signed main() {\r\n//   ios::sync_with_stdio(0);\r\n//   cin.tie(0);\r\n//   test();\r\n//   return 0;\r\n// }\r\n\r\n// #include <bits/stdc++.h>\r\n// using namespace std;\r\n// #define int long long\r\n// #define endl '\\n'\r\n// #define vct vector<int>\r\n// const int N = 1e5 + 5; int P;\r\n// struct SegTree {\r\n//   int n;\r\n//   vct val, add;\r\n//   void build(int x, int l, int r, int *a) {\r\n//     if (l == r) {\r\n//       val[x] = a[l];\r\n//       return;\r\n//     }\r\n//     int mid = (l + r) >> 1;\r\n//     build(x << 1, l, mid, a);\r\n//     build(x << 1 | 1, mid + 1, r, a);\r\n//     val[x] = (val[x << 1] + val[x << 1 | 1]) % P;\r\n//   }\r\n//   SegTree() {}\r\n//   SegTree(int *a, int _n) {\r\n//     n = _n;\r\n//     val.assign(n * 4 + 5, 0);\r\n//     add.assign(n * 4 + 5, 0);\r\n//     build(1, 1, n, a);\r\n//   }\r\n//   void pushdown(int x, int l, int r, int mid) {\r\n//     if (add[x]) {\r\n//       val[x << 1] = (val[x << 1] + add[x] * (mid - l + 1)) % P;\r\n//       add[x << 1] = (add[x << 1] + add[x]) % P;\r\n//       val[x << 1 | 1] = (val[x << 1 | 1] + add[x] * (r - (mid + 1) + 1)) % P;\r\n//       add[x << 1 | 1] = (add[x << 1 | 1] + add[x]) % P;\r\n//       add[x] = 0;\r\n//     }\r\n//   }\r\n//   void modify(int x, int l, int r, int L, int R, int V) {\r\n//     if (L <= l && r <= R) {\r\n//       val[x] = (val[x] + V * (r - l + 1)) % P;\r\n//       add[x] = (add[x] + V) % P;\r\n//       return;\r\n//     }\r\n//     int mid = (l + r) >> 1;\r\n//     pushdown(x, l, r, mid);\r\n//     if (L <= mid) modify(x << 1, l, mid, L, R, V);\r\n//     if (R > mid) modify(x << 1 | 1, mid + 1, r, L, R, V);\r\n//     val[x] = (val[x << 1] + val[x << 1 | 1]) % P;\r\n//   }\r\n//   void modify(int L, int R, int V) { modify(1, 1, n, L, R, V); }\r\n//   int query(int x, int l, int r, int L, int R) {\r\n//     if (L <= l && r <= R)\r\n//       return val[x];\r\n//     int mid = (l + r) >> 1;\r\n//     pushdown(x, l, r, mid);\r\n//     int res = 0;\r\n//     if (L <= mid) res = (res + query(x << 1, l, mid, L, R)) % P;\r\n//     if (R > mid) res = (res + query(x << 1 | 1, mid + 1, r, L, R)) % P;\r\n//     return res;\r\n//   }\r\n//   int query(int L, int R) { return query(1, 1, n, L, R); }\r\n// };\r\n// int dep[N], fa[N], sz[N], son[N], top[N], dfn[N], tim, val[N];\r\n// SegTree tre;\r\n// int n, m, R, a[N];\r\n// vector<vector<int>> g;\r\n// void dfs1(int u, int d, int f) {\r\n//   dep[u] = d, fa[u] = f, sz[u] = 1, son[u] = 0;\r\n//   for (auto&& v : g[u])\r\n//     if (v != f) {\r\n//       dfs1(v, d + 1, u);\r\n//       sz[u] += sz[v];\r\n//       if (sz[v] > sz[son[u]])\r\n//         son[u] = v;\r\n//     }\r\n// }\r\n// void dfs2(int u, int tp) {\r\n//   top[u] = tp, dfn[u] = ++tim, val[tim] = a[u];\r\n//   if (son[u])\r\n//     dfs2(son[u], tp);\r\n//   for (auto&& v : g[u])\r\n//     if (v != fa[u] && v != son[u])\r\n//       dfs2(v, v);\r\n// }\r\n// void addpath(int x, int y, int z) {\r\n//   while (1) {\r\n//     if (dep[top[x]] > dep[top[y]])\r\n//       swap(x, y);\r\n//     if (top[x] == top[y]) {\r\n//       if (dep[x] > dep[y])\r\n//         swap(x, y);\r\n//       tre.modify(dfn[x], dfn[y], z);\r\n//       return;\r\n//     }\r\n//     tre.modify(dfn[top[y]], dfn[y], z);\r\n//     y = fa[top[y]];\r\n//   }\r\n// }\r\n// int querypath(int x, int y) {\r\n//   int res = 0;\r\n//   while (1) {\r\n//     if (dep[top[x]] > dep[top[y]])\r\n//       swap(x, y);\r\n//     if (top[x] == top[y]) {\r\n//       if (dep[x] > dep[y])\r\n//         swap(x, y);\r\n//       res = (res + tre.query(dfn[x], dfn[y])) % P;\r\n//       return res;\r\n//     }\r\n//     res = (res + tre.query(dfn[top[y]], dfn[y])) % P;\r\n//     y = fa[top[y]];\r\n//   }\r\n// }\r\n// void addsubtree(int x, int z) {\r\n//   tre.modify(dfn[x], dfn[x] + sz[x] - 1, z);\r\n// }\r\n// int querysubtree(int x) {\r\n//   return tre.query(dfn[x], dfn[x] + sz[x] - 1);\r\n// }\r\n// void test() {\r\n//   cin >> n >> m >> R >> P;\r\n//   for (int i = 1; i <= n; i++)\r\n//     cin >> a[i], a[i] %= P;\r\n//   g.assign(n + 1, {});\r\n//   for (int i = 1; i < n; i++) {\r\n//     int x, y;\r\n//     cin >> x >> y;\r\n//     g[x].push_back(y);\r\n//     g[y].push_back(x);\r\n//   }\r\n//   dfs1(R, 1, -1);\r\n//   dfs2(R, R);\r\n//   tre = SegTree(val, n);\r\n//   for (int i = 1; i <= m; i++) {\r\n//     int op; cin >> op;\r\n//     if (op == 1) {\r\n//       int x, y, z;\r\n//       cin >> x >> y >> z;\r\n//       addpath(x, y, z);\r\n//     }\r\n//     else if (op == 2) {\r\n//       int x, y;\r\n//       cin >> x >> y;\r\n//       cout << querypath(x, y) << endl;\r\n//     }\r\n//     else if (op == 3) {\r\n//       int x, z;\r\n//       cin >> x >> z;\r\n//       addsubtree(x, z);\r\n//     }\r\n//     else {\r\n//       int x; cin >> x;\r\n//       cout << querysubtree(x) << endl;\r\n//     }\r\n//   }\r\n// }\r\n// signed main() {\r\n//   ios::sync_with_stdio(0);\r\n//   cin.tie(0);\r\n//   test();\r\n//   return 0;\r\n// }\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl '\\n'\r\n#define vct vector<int>\r\nconst int N = 1e5 + 5;\r\nstruct SegTree {\r\n  int n, v;\r\n  function<int(int, int)> f;\r\n  vct val, laz;\r\n  void build(int x, int l, int r, int *a) {\r\n    if (l == r) {\r\n      val[x] = a[l];\r\n      return;\r\n    }\r\n    int mid = (l + r) >> 1;\r\n    build(x << 1, l, mid, a);\r\n    build(x << 1 | 1, mid + 1, r, a);\r\n    val[x] = f(val[x << 1], val[x << 1 | 1]);\r\n  }\r\n  SegTree() {}\r\n  SegTree(int *a, int _n, int _v, function<int(int, int)> _f)\r\n  : n(_n), v(_v), f(_f) {\r\n    val.assign(n * 4 + 5, 0);\r\n    // laz.assign(n * 4 + 5, 0);\r\n    build(1, 1, n, a);\r\n  }\r\n  // void pushdown(int x) {\r\n  //   if (laz[x] != v) {\r\n  //     val[x << 1] = f(val[x << 1], laz[x]);\r\n  //     laz[x << 1] = f(laz[x << 1], laz[x]);\r\n  //     val[x << 1 | 1] = f(val[x << 1 | 1], laz[x]);\r\n  //     laz[x << 1 | 1] = f(laz[x << 1 | 1], laz[x]);\r\n  //     laz[x] = v;\r\n  //   }\r\n  // }\r\n  void modify(int L, int R, int V) {\r\n    modify(L, R, V, 1, 1, n);\r\n  }\r\n  void modify(int L, int R, int V, int x, int l, int r) {\r\n    if (L <= l && r <= R) {\r\n      val[x] = V;\r\n      // laz[x] = f(laz[x], V);\r\n      return;\r\n    }\r\n    // pushdown(x);\r\n    int mid = (l + r) >> 1;\r\n    if (L <= mid) modify(L, R, V, x << 1, l, mid);\r\n    if (R > mid) modify(L, R, V, x << 1 | 1, mid + 1, r);\r\n    val[x] = f(val[x << 1], val[x << 1 | 1]);\r\n  }\r\n  int query(int L, int R) {\r\n    return query(L, R, 1, 1, n);\r\n  }\r\n  int query(int L, int R, int x, int l, int r) {\r\n    if (L <= l && r <= R)\r\n      return val[x];\r\n    // pushdown(x);\r\n    int mid = (l + r) >> 1, res = v;\r\n    if (L <= mid) res = f(res, query(L, R, x << 1, l, mid));\r\n    if (R > mid) res = f(res, query(L, R, x << 1 | 1, mid + 1, r));\r\n    return res;\r\n  }\r\n};\r\nint n, m, q, w[N];\r\nvector<vector<int>> g, ds;\r\nint dep[N], fa[N], sz[N], son[N], top[N], dfn[N], tim, val[N];\r\nSegTree tre;\r\nmultiset<int> s[N*2];\r\nvoid dfs1(int u, int d, int f) {\r\n  dep[u] = d, fa[u] = f, sz[u] = 1, son[u] = 0;\r\n  for (auto&& v : g[u])\r\n    if (v != f) {\r\n      dfs1(v, d + 1, u);\r\n      sz[u] += sz[v];\r\n      if (sz[v] > sz[son[u]])\r\n        son[u] = v;\r\n    }\r\n}\r\nvoid dfs2(int u, int tp) {\r\n  top[u] = tp, dfn[u] = ++tim;\r\n  if (son[u]) {\r\n    dfs2(son[u], tp);\r\n    if (u > n) s[u].insert(w[son[u]]);\r\n  }\r\n  for (auto&& v : g[u])\r\n    if (v != fa[u] && v != son[u]) {\r\n      dfs2(v, v);\r\n      if (u > n) s[u].insert(w[v]);\r\n    }\r\n  val[dfn[u]] = u <= n ? w[u] : *s[u].begin();\r\n}\r\nint querypath(int x, int y) {\r\n  int res = 1e18;\r\n  while (1) {\r\n    if (dep[top[x]] > dep[top[y]])\r\n      swap(x, y);\r\n    if (top[x] == top[y]) {\r\n      if (dep[x] > dep[y])\r\n        swap(x, y);\r\n      res = min(res, tre.query(dfn[x], dfn[y]));\r\n      if (x > n)\r\n        res = min(res, w[fa[x]]);\r\n      return res;\r\n    }\r\n    res = min(res, tre.query(dfn[top[y]], dfn[y]));\r\n    y = fa[top[y]];\r\n  }\r\n}\r\nint dfn2[N], low[N], vis[N], tim2;\r\nvector<int> ver;\r\nvoid tarjan(int u, int f) {\r\n  dfn2[u] = low[u] = ++tim2;\r\n  ver.push_back(u);\r\n  vis[u] = 1;\r\n  for (auto&& v : g[u]) {\r\n    if (vis[v] == 0) {\r\n      tarjan(v, u);\r\n      low[u] = min(low[u], low[v]);\r\n      if (low[v] == dfn2[u]) {\r\n        vector<int> tmp;\r\n        while (1) {\r\n          int x = ver.back();\r\n          vis[x] = 2;\r\n          tmp.push_back(x);\r\n          ver.pop_back();\r\n          if (x == v) break;\r\n        }\r\n        tmp.push_back(u);\r\n        ds.push_back(tmp);\r\n      }\r\n    }\r\n    else if (vis[v] == 1)\r\n      low[u] = min(low[u], dfn2[v]);\r\n  }\r\n}\r\nvoid test() {\r\n  cin >> n >> m >> q;\r\n  for (int i = 1; i <= n; i++)\r\n    cin >> w[i];\r\n  g.assign(n + 1, {});\r\n  for (int i = 1; i <= m; i++) {\r\n    int a, b;\r\n    cin >> a >> b;\r\n    g[a].push_back(b);\r\n    g[b].push_back(a);\r\n  }\r\n  tarjan(1, -1);\r\n  g.assign(n + ds.size() + 1, {});\r\n  for (int i = 0; i < ds.size(); i++) {\r\n    for (auto&& v : ds[i]) {\r\n      g[i + n + 1].push_back(v);\r\n      g[v].push_back(i + n + 1);\r\n    }\r\n  }\r\n  dfs1(1, 1, -1);\r\n  dfs2(1, 1);\r\n  tre = SegTree(val, n + ds.size(), 1e18, [](int x, int y) {return min(x, y);});\r\n  while (q--) {\r\n    string op;\r\n    cin >> op;\r\n    if (op[0] == 'C') {\r\n      int a, b;\r\n      cin >> a >> b;\r\n      if (a == 1) {\r\n        tre.modify(dfn[a], dfn[a], b);\r\n        w[a] = b;\r\n      }\r\n      else {\r\n        int f = fa[a];\r\n        s[f].erase(w[a]);\r\n        s[f].insert(b);\r\n        w[a] = b;\r\n        tre.modify(dfn[a], dfn[a], b);\r\n        tre.modify(dfn[f], dfn[f], *s[f].begin());\r\n      }\r\n    }\r\n    else {\r\n      int a, b;\r\n      cin >> a >> b;\r\n      cout << querypath(a, b) << endl;\r\n    }\r\n  }\r\n}\r\nsigned main() {\r\n  ios::sync_with_stdio(0);\r\n  cin.tie(0);\r\n  test();\r\n  return 0;\r\n}\r\n// 3 2 ?\r\n// 4 4 4\r\n// 1 2\r\n// 2 3\r\n// C 2 2\r\n// A 2 3"
}