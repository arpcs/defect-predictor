{
    "id": 211370215,
    "contestId": 1192,
    "creationTimeSeconds": 1687982719,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "C",
        "name": "Cubeword",
        "type": "PROGRAMMING",
        "tags": [
            "*special",
            "brute force",
            "dp",
            "meet-in-the-middle"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "JakobZ"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 90,
    "timeConsumedMillis": 187,
    "memoryConsumedBytes": 48537600,
    "points": 100.0,
    "source": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <limits.h>\n#include <math.h>\n#include <iomanip>\n#include <bitset>\n#include <unordered_map>\n#include <map>\n#include <cstring>\n#include <sstream>\n \n#pragma GCC target(\"popcnt\")\n \ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nconst int MOD = 1e9+7;\ntypedef pair<ld,ld> point;\n#define x first\n#define y second\n\n//#define SEGTREE\n//#define TREE\n//#define DSU\n#define MATH\n \n#ifdef SEGTREE\ntemplate<class Type>\nclass SegmentTree {\n    Type (*func)(Type a, Type b);\n    vector<Type> nodes;\n    vector<int> l;\n    vector<int> r;\n    int size_log2;\n    Type neutral;\n    \n    void init_node(int node) {\n        if(node >= (1 << size_log2))\n            return;\n        \n        l[2 * node] = l[node];\n        r[2 * node] = (l[node] + r[node]) / 2;\n        init_node(2 * node);\n        \n        l[2 * node + 1] = (l[node] + r[node]) / 2;\n        r[2 * node + 1] = r[node];\n        init_node(2 * node + 1);\n        \n        nodes[node] = func(nodes[2 * node], nodes[2 * node + 1]);\n    }\n    \n    void update_node(int node) {\n        if(node < (1 << size_log2))\n            nodes[node] = func(nodes[2 * node], nodes[2 * node + 1]);\n        \n        if(node != 1)\n            update_node(node / 2);\n    }\n    \n    Type get(int node, int ll_, int rr) {\n        if(rr <= l[node] || ll_ >= r[node])\n            return neutral;\n        \n        if(ll_ <= l[node] && rr >= r[node])\n            return nodes[node];\n        \n        Type left = get(2 * node, ll_, rr);\n        Type right = get(2 * node + 1, ll_, rr);\n        \n        return func(left, right);\n    }\n    \npublic:\n    SegmentTree(Type (*func)(Type a, Type b), vector<Type> vector, Type neutral) : func(func), neutral(neutral) {\n        size_log2 = 0;\n        while((1 << size_log2) < vector.size())\n            size_log2++;\n        \n        nodes.resize((1 << size_log2) * 2);\n        l.resize((1 << size_log2) * 2);\n        r.resize((1 << size_log2) * 2);\n        \n        for(int i = 0; i < vector.size(); i++)\n            nodes[(1 << size_log2) + i] = vector[i];\n        \n        l[1] = 0;\n        r[1] = 1 << size_log2;\n        init_node(1);\n    }\n    \n    void set(int idx, Type el) {\n        nodes[(1 << size_log2) + idx] = el;\n        update_node((1 << size_log2) + idx);\n    }\n    \n    Type get(int l, int r) {\n        return get(1, l, r);\n    }\n    \n    Type get(int idx) {\n        return nodes[(1 << size_log2) + idx];\n    }\n    \n    Type get() {\n        return nodes[1];\n    }\n    \n    int get_first_larger_or_eq_than(int bound) {\n        return get_first_larger_or_eq_than(1, bound);\n    }\n    \n    int get_first_larger_or_eq_than(int node, int bound) {\n        if(node >= (1 << size_log2)) {\n            return node - (1 << size_log2);\n        }\n        \n        if(nodes[node * 2] > bound)\n            return get_first_larger_or_eq_than(node * 2, bound);\n        else\n            return get_first_larger_or_eq_than(node * 2 + 1, bound - nodes[node * 2]);\n    }\n};\n \n#endif\n \n#ifdef TREE\n#define POW 18\n \nstruct Node {\n    int parents[POW];\n    vector<int> conns;\n    int depth;\n    int value;\n    int subtree_depth;\n    int subtree_size;\n    int euler;\n    int val;\n    int res;\n};\n \nll add(ll a, ll b) {\n    return a + b;\n}\n \nNode nodes[200000];\nint n;\n \nint setup(int node, int depth, int euler, ll dist) {\n    dist += nodes[node].value;\n    nodes[node].depth = depth;\n    nodes[node].euler = euler++;\n    \n    \n    for(int i = 1; i < POW; i++) {\n        nodes[node].parents[i] = nodes[nodes[node].parents[i - 1]].parents[i - 1];\n    }\n    \n    int size = 1;\n    \n    for(int i = 0; i < nodes[node].conns.size(); i++) {\n        int child = nodes[node].conns[i];\n        if(child != nodes[node].parents[0]) {\n            nodes[child].parents[0] = node;\n            euler = setup(child, depth + 1, euler, dist);\n            size += nodes[child].subtree_size;\n        }\n    }\n    nodes[node].subtree_size = size;\n    return euler;\n}\n \nvoid setup_tree(int root) {\n    nodes[root].parents[0] = root;\n    setup(root, 0, 0, 0);\n}\n \nint get_subtree_depth(int node) {\n    if(nodes[node].subtree_depth)\n        return nodes[node].subtree_depth;\n    \n    int max_depth = 1;\n    for(int child : nodes[node].conns) {\n        if(child == nodes[node].parents[0])\n            continue;\n        max_depth = max(max_depth, get_subtree_depth(child) + 1);\n    }\n    nodes[node].subtree_depth = max_depth;\n    return max_depth;\n}\n \nint get_parent(int node, int depth) {\n    if(depth > nodes[node].depth)\n        return -1;\n    \n    int climber = node;\n    for(int i = 0; i < POW; i++) {\n        if(depth & (1 << i) && climber != -1)\n            climber = nodes[climber].parents[i];\n    }\n    \n    return climber;\n}\n\nbool is_sub(int a,int b){\n    return get_parent(a,nodes[a].depth-nodes[b].depth)==b;\n}\n \nint lca(int a, int b) {\n    if(nodes[a].depth < nodes[b].depth)\n        swap(a, b);\n    \n    a = get_parent(a, nodes[a].depth - nodes[b].depth);\n    \n    if(a == b)\n        return a;\n    \n    for(int i = POW - 1; i >= 0; i--) {\n        if(nodes[a].parents[i] != nodes[b].parents[i]) {\n            a = nodes[a].parents[i];\n            b = nodes[b].parents[i];\n        }\n    }\n    \n    return nodes[a].parents[0];\n}\n \n#endif\n \n#ifdef DSU\n \nclass Dsu {\n    vector<int> arr;\n    int num_sets;\n    \npublic:\n    Dsu(int size) {\n        arr = vector<int>(size, -1);\n        num_sets = size;\n    }\n    \n    int merge(int a, int b) {\n        a = get(a);\n        b = get(b);\n        \n        if(a == b)\n            return a;\n        \n        if(arr[a] > arr[b])\n            swap(a, b);\n        \n        arr[a] += arr[b];\n        arr[b] = a;\n        num_sets--;\n        return a;\n    }\n    \n    int get(int a) {\n        if(arr[a] < 0)\n            return a;\n        arr[a] = get(arr[a]);\n        return get(arr[a]);\n    }\n    \n    int get_size(int a) {\n        return -arr[get(a)];\n    }\n    \n    int get_num_sets() {\n        return num_sets;\n    }\n};\n \n#endif\n \n#ifdef MATH\n \nll dpf[2000001];\nll factorial(ll n) {\n    if(n == 0)\n        return 1;\n    \n    if(dpf[n])\n        return dpf[n];\n    \n    ll result = factorial(n - 1) * n;\n    result %= MOD;\n    dpf[n] = result;\n    return result;\n}\n \nll powm(ll base, ll exp) {\n    ll result = 1;\n    \n    for(int i = 0; i < 64; i++) {\n        if((exp >> i) % 2 == 1) {\n            result *= base;\n            result %= MOD;\n        }\n        base *= base;\n        base %= MOD;\n    }\n    \n    return result;\n}\n \nll inverse(ll n) {\n    return powm(n, MOD - 2);\n}\n \nll dpif[2000001];\nll inverse_factorial(ll n) {\n    if(dpif[n])\n        return dpif[n];\n    \n    ll result = inverse(factorial(n));\n    dpif[n] = result;\n    return result;\n}\n \nll choose(ll n, ll k) {\n    return (((factorial(n)*inverse_factorial(n-k))%MOD)*inverse_factorial(k))%MOD;\n}\n \nll gcd(ll a, ll b){\n    if(a==b)\n        return a;\n    if(a<b)\n        swap(a,b);\n    if(b==0)\n        return a;\n    return gcd(b, a%b);\n}\n \n#endif\n\nconst ll MOD2=998244353;\nconst int NUM_SYMBOLS=62;\nint char_to_int(char c){\n    if('a'<=c&&c<='z')\n        return c-'a';\n    if('A'<=c&&c<='Z')\n        return c-'A'+('z'-'a'+1);\n    return c-'0'+('z'-'a'+1)+('Z'-'A'+1);\n}\n\nbool is_pal(string str){\n    string rstr=str;\n    reverse(rstr.begin(),rstr.end());\n    return str==rstr;\n}\n\nll counts[NUM_SYMBOLS][NUM_SYMBOLS];\nll dp[NUM_SYMBOLS][NUM_SYMBOLS][NUM_SYMBOLS];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cout.tie(NULL);\n    cin.tie(NULL);\n    \n    //freopen(\"speeding.in\",\"r\",stdin);\n    //freopen(\"speeding.out\",\"w\",stdout);\n    \n    int n;\n    cin>>n;\n    vector<string>strs(n);\n    for(int i=0;i<n;i++){\n        cin>>strs[i];\n        string rev=strs[i];\n        reverse(rev.begin(),rev.end());\n        if(strs[i]>rev)\n            strs[i]=rev;\n    }\n    set<string>s(strs.begin(),strs.end());\n    strs={s.begin(),s.end()};\n    vector<pair<char,char>>arr[11];\n    for(string str:strs){\n        int l=(int)str.size();\n        if(is_pal(str)){\n            arr[l].emplace_back(str[0],str[0]);\n        }else{\n            arr[l].emplace_back(str[0],str.back());\n            if(str[0]==str.back())\n                arr[l].emplace_back(str[0],str.back());\n        }\n    }\n    \n    ll res=0;\n    for(int i=3;i<=10;i++){\n        memset(counts,0,NUM_SYMBOLS*NUM_SYMBOLS*sizeof(ll));\n        for(auto p:arr[i]){\n            char c1=p.first;\n            char c2=p.second;\n            counts[char_to_int(c1)][char_to_int(c2)]++;\n            if(c1!=c2)\n                counts[char_to_int(c2)][char_to_int(c1)]++;\n        }\n        \n#define ITER(c,to) for(int c=0;c<to;c++)\n        \n        memset(dp,0,sizeof(dp));\n        \n        ITER(c1,NUM_SYMBOLS){\n            ITER(c2,c1+1){\n                ITER(c3,c2+1){\n                    ITER(c4,NUM_SYMBOLS){\n                        dp[c1][c2][c3]+=(counts[c1][c4]*counts[c2][c4])%MOD2*counts[c3][c4];\n                        dp[c1][c2][c3]%=MOD2;\n                    }\n                }\n            }\n        }\n        \n        ITER(c1,NUM_SYMBOLS){\n            ITER(c2,c1+1){\n                ITER(c3,c2+1){\n                    ITER(c4,c3+1){\n                        ll mul=0;\n                        int s=(c1==c2)+(c2==c3)+(c3==c4);\n                        if(s==0){\n                            mul=24;\n                        }else if(s==1){\n                            mul=12;\n                        }else if(s==2&&c2!=c3){\n                            mul=6;\n                        }else if(s==2){\n                            mul=4;\n                        }else if(s==3){\n                            mul=1;\n                        }\n                        \n                        res+=(((mul*dp[c1][c2][c3])%MOD2*dp[c1][c2][c4]%MOD2)*dp[c1][c3][c4]%MOD2)*dp[c2][c3][c4];\n                        res%=MOD2;\n                    }\n                }\n            }\n        }\n    }\n    \n    cout<<res<<\"\\n\";\n    \n    return 0;\n}\n\n/*\n \n \n3\nbac\nbad\ncad\n \n */\n"
}