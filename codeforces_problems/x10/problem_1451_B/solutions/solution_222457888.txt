{
    "id": 222457888,
    "contestId": 1451,
    "creationTimeSeconds": 1694178000,
    "relativeTimeSeconds": 720,
    "problem": {
        "contestId": 1451,
        "index": "B",
        "name": "Non-Substring Subsequence",
        "type": "PROGRAMMING",
        "points": 750.0,
        "rating": 900,
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 1451,
        "members": [
            {
                "handle": "1lu3ch4"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1694177280
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 64102400,
    "source": "#include <bits/stdc++.h>\r\n#include <unordered_set>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\r\n#pragma GCC optimize (\"Ofast\")\r\n#pragma GCC optimize (\"unroll-loops\")\r\n\r\ntypedef long long ll;\r\ntypedef vector<long long> vll;\r\ntypedef pair<long long,long long> pll;\r\ntypedef vector<int> vi;\r\ntypedef pair<int,int> pii;\r\n\r\n#define prec(x,y) std::fixed<<std::setprecision(y)<<x\r\n#define rep(i,a,b) for(ll i=a;i<b;i++)\r\n#define rrep(i,a,b) for(ll i=a;i>=b;i--)\r\n#define trav(it,a) for(auto it=a.begin();it!=a.end();it++)\r\n#define all(cont) cont.begin(), cont.end()\r\n\r\nconst long long inf=1e18;\r\nconst double pi=3.14159265358979323846264338327950288419716939937510;\r\nconst string ppi = \"314159265358979323846264338327950288419716939937510\";\r\nconst ll mod=1e9 + 7;\r\nconst ll mod2=998244353; //FOR EDUCATIONAL ROUNDS\r\nconst double eps=(0.00000000001);\r\n\r\nvoid out_vec(vll v){\r\n    ll n=v.size();\r\n    rep(i,0,n){\r\n        if(v[i]==inf){\r\n            cout<<\"inf\"<< \" \";\r\n            continue;\r\n        }\r\n        cout<<v[i]<<\" \";\r\n    }\r\n    cout<<\"\\n\";\r\n}\r\nstring itos(ll n){\r\n    ostringstream os;\r\n    os<<n;\r\n    return os.str();\r\n}\r\nll sti(string s){\r\n    stringstream st(s);\r\n    ll x=0;st>>x;\r\n    return x;\r\n}\r\nll gcd(ll a, ll b) {\r\n    if (!a || !b)\r\n        return a | b;\r\n    unsigned shift = __builtin_ctz(a | b);\r\n    a >>= __builtin_ctz(a);\r\n    do {\r\n        b >>= __builtin_ctz(b);\r\n        if (a > b)\r\n            swap(a, b);\r\n        b -= a;\r\n    } while (b);\r\n    return a << shift;\r\n}\r\nll gcdar(vll v){\r\n    ll n=v.size();\r\n    ll r=v[0];\r\n    rep(i,0,n){\r\n        r=gcd(v[i], r);\r\n        if(r==1)return 1;\r\n    }\r\n    return r;\r\n}\r\nll lcm(ll a, ll b){\r\n    return (a*b)/gcd(a,b);\r\n}\r\nll lcmar(vll v){\r\n    ll n=v.size();\r\n    ll r=v[0];\r\n    rep(i,1,n){\r\n        r=(r*v[i])/gcd(r,v[i]);\r\n    }\r\n    return r;\r\n}\r\nll min(ll a, ll b){\r\n    if(a<b)return a;\r\n    return b;\r\n}\r\nll max(ll a, ll b){\r\n    if(a>b)return a;\r\n    return b;\r\n}\r\nll powMod(ll n, ll m, ll md){\r\n    ll ret = 1;\r\n    while(m){\r\n        if(m&1)ret=ret*n%md;\r\n        n=n*n%md;m>>=1;\r\n    }\r\n    return (ret%md+md)%md;\r\n}\r\n/*Fenwick Tree**/ \r\nstruct FenwickTree{\r\n    ll n;vll t;\r\n    FenwickTree(ll n){\r\n        this->n=n;\r\n        t.assign(n+1, 0);\r\n    }\r\n    FenwickTree(vll a):FenwickTree(a.size()){\r\n        rep(i,0,a.size()){\r\n            add(i, a[i]);\r\n        }\r\n    }\r\n    ll sum(ll r){\r\n        ll ret = 0;\r\n        while(r>=0){\r\n            ret+=t[r];\r\n            r=r&(r+1);r--;\r\n        }\r\n        return ret;\r\n    }\r\n    ll sum(ll l, ll r){\r\n        return sum(r)-sum(l-1);\r\n    }\r\n    void add(ll i, ll d){\r\n        while(i<=n){\r\n            t[i]+=d;\r\n            i=i|(i+1);\r\n        }\r\n    }\r\n};\r\n\r\n/*Segment Tree**/\r\nconst int MAXN = 1e6+5;\r\n\r\nll t[4*MAXN+5];\r\nll lv[4*MAXN+5];\r\n\r\nvoid build(ll a[], ll v, ll tl, ll tr) {\r\n    if (tl == tr) {\r\n        t[v] = a[tl];\r\n        lv[v] = 0;\r\n    } else {\r\n        ll tm = (tl + tr) / 2;\r\n        build(a, v*2, tl, tm);\r\n        build(a, v*2+1, tm+1, tr);\r\n        lv[v] = lv[v*2] + 1;\r\n        if(lv[v]&2)t[v] = t[v*2] ^ t[v*2+1];\r\n        else t[v] = t[v*2] | t[v*2+1];\r\n    }\r\n}\r\n\r\nll sum(ll v, ll tl, ll tr, ll l, ll r) {\r\n    if (l > r) \r\n        return 0;\r\n    if (l == tl && r == tr) {\r\n        return t[v];\r\n    }\r\n    ll tm = (tl + tr) / 2;\r\n    return sum(v*2, tl, tm, l, min(r, tm))\r\n           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);\r\n}\r\n\r\n\r\n// int minQuery(int v, int tl, int tr, int l, int r){\r\n//     if(l>r)return inf;\r\n//     if(l==tl&&r==tr)return t[v];\r\n//     int tm = (tl+tr)/2;\r\n//     return min(minQuery(v*2, tl, tm, l, min(r, tm)), minQuery(v*2+1, tm+1, tr, max(l, tm+1), r));\r\n// }\r\n\r\n// update SUM\r\nvoid update(ll v, ll tl, ll tr, ll pos, ll new_val) {\r\n    if (tl == tr) {\r\n        t[v] = new_val;\r\n    } else {\r\n        ll tm = (tl + tr) / 2;\r\n        if (pos <= tm)\r\n            update(v*2, tl, tm, pos, new_val);\r\n        else\r\n            update(v*2+1, tm+1, tr, pos, new_val);\r\n        if(lv[v]&2)t[v] = t[v*2] ^ t[v*2+1];\r\n        else t[v] = t[v*2] | t[v*2+1];\r\n    }\r\n}\r\n\r\n// update MIN\r\n// void update(int v, int tl, int tr, int pos, int new_val) {\r\n//     if (tl == tr) {\r\n//         t[v] = new_val;\r\n//     } else {\r\n//         int tm = (tl + tr) / 2;\r\n//         if (pos <= tm)\r\n//             update(v*2, tl, tm, pos, new_val);\r\n//         else\r\n//             update(v*2+1, tm+1, tr, pos, new_val);\r\n//         t[v] = min(t[v*2], t[v*2+1]);\r\n//     }\r\n// }\r\n/*Segment Tree end*/\r\n\r\n// from cp algo\r\nstruct matrix {\r\n    long long mat[2][2];\r\n    matrix friend operator *(const matrix &a, const matrix &b){\r\n        matrix c;\r\n        for (int i = 0; i < 2; i++) {\r\n          for (int j = 0; j < 2; j++) {\r\n              c.mat[i][j] = 0;\r\n              for (int k = 0; k < 2; k++) {\r\n                  c.mat[i][j] += a.mat[i][k] * b.mat[k][j];\r\n              }\r\n          }\r\n        }\r\n        return c;\r\n    }\r\n};\r\n\r\nmatrix matpow(matrix base, long long n) {\r\n    matrix ans{ {\r\n      {1, 0},\r\n      {0, 1}\r\n    } };\r\n    while (n) {\r\n        if(n&1)\r\n            ans = ans*base;\r\n        base = base*base;\r\n        n >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nlong long fib(int n) {\r\n    matrix base{ {\r\n      {1, 1},\r\n      {1, 0}\r\n    } };\r\n    return matpow(base, n).mat[0][1];\r\n}\r\n\r\nvoid dfs(ll v, vector<vll> &adj, vll &d, ll &ps, vll &clr, vll &vis){\r\n    vis[v]=1;\r\n    if(d[v]>=ps)return;\r\n    for(auto u: adj[v]){\r\n        if(vis[u])continue;\r\n        if(d[u]>d[v]+1){\r\n            d[u] = d[v]+1;\r\n            dfs(u, adj, d, ps, clr, vis);\r\n        }else\r\n            ps = min(ps, d[u]+d[v]+1);\r\n    }\r\n}\r\n\r\nvoid solve(){\r\n    ll n, q;cin>>n>>q;\r\n    string s;cin>>s;\r\n    while(q--){\r\n        ll l, r;cin>>l>>r;\r\n        l--;r--;\r\n        string chk = \"\";\r\n        rep(i,l,r+1)chk+=s[i];\r\n        // cout<<chk<<\"\\n\";\r\n        bool f = false;\r\n        rep(i,0,l){\r\n            if(s[i]==s[l]){\r\n                cout<<\"YES\\n\";\r\n                f = true;\r\n            }\r\n        }\r\n        if(f)continue;\r\n        rep(i,r+1,n){\r\n            if(s[i]==s[r]){\r\n                cout<<\"YES\\n\";\r\n                f = true;\r\n            }\r\n        }\r\n        if(f)continue;\r\n        cout<<\"NO\\n\";\r\n    }\r\n    return;\r\n}\r\n \r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);cout<<setprecision(7);\r\n\tcout.tie(NULL);\r\n    ll t=1;\r\n    cin>>t;\r\n    while(t--){\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n// alway pass arrays by reference, unless you really need a copy"
}