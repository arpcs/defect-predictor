{
    "id": 226770056,
    "contestId": 1511,
    "creationTimeSeconds": 1696523887,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1511,
        "index": "E",
        "name": "Colorings and Dominoes",
        "type": "PROGRAMMING",
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1511,
        "members": [
            {
                "handle": "shmax_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1618238100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 56,
    "timeConsumedMillis": 139,
    "memoryConsumedBytes": 16896000,
    "source": "/*\r\n* powered by ANDRIY POPYK\r\n* in honor of MYSELF and SEGMENT DECOMPOSITION and N^(log(N)) and (Harry Potter and the Methods of Rationality) and Monkie D. Luffy\r\n*/\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n\r\n//#pragma GCC optimize(\"O3\")\r\n//#pragma GCC target(\"avx,avx2,fma\")\r\n//#pragma GCC optimization (\"unroll-loops\")\r\n//#pragma GCC target(\"avx,avx2,sse,sse2,sse3,sse4,popcnt\")\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define float long double\r\n#define elif else if\r\n#define endl \"\\n\"\r\n//#define mod 1000000007\r\n#define pi acos(-1)\r\n#define eps 0.000000001\r\n#define inf 1000000000000\r\n#define FIXED(a) cout << fixed << setprecision(a)\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define time_init auto start = std::chrono::high_resolution_clock::now()\r\n#define time_report                                       \\\r\n    auto end = std::chrono::high_resolution_clock::now(); \\\r\n    std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << \" ms\" << endl\r\n#define debug(x) \\\r\n    { cerr << #x << \" = \" << x << endl; }\r\n#define len(x) (int) x.size()\r\n#define sqr(x) ((x) * (x))\r\n#define cube(x) ((x) * (x) * (x))\r\n#define bit(x, i) (((x) >> (i)) & 1)\r\n#define set_bit(x, i) ((x) | (1LL << (i)))\r\n#define clear_bit(x, i) ((x) & (~(1LL << (i))))\r\n#define toggle_bit(x, i) ((x) ^ (1LL << (i)))\r\n#define low_bit(x) ((x) & (-(x)))\r\n#define count_bit(x) __builtin_popcountll(x)\r\n#define srt(x) sort(all(x))\r\n#define rsrt(x) sort(rall(x))\r\n#define mp make_pair\r\n#define maxel(x) (*max_element(all(x)))\r\n#define minel(x) (*min_element(all(x)))\r\n#define maxelpos(x) (max_element(all(x)) - x.begin())\r\n#define minelpos(x) (min_element(all(x)) - x.begin())\r\n#define sum(x) (accumulate(all(x), 0LL))\r\n#define product(x) (accumulate(all(x), 1LL, multiplies<int>()))\r\n#define gcd __gcd\r\n#define lcm(a, b) ((a) / gcd(a, b) * (b))\r\n#define rev(x) (reverse(all(x)))\r\n#define shift_left(x, k) (rotate(x.begin(), x.begin() + k, x.end()))\r\n#define shift_right(x, k) (rotate(x.rbegin(), x.rbegin() + k, x.rend()))\r\n#define is_sorted(x) (is_sorted_until(all(x)) == x.end())\r\n#define is_even(x) (((x) &1) == 0)\r\n#define is_odd(x) (((x) &1) == 1)\r\n#define pow2(x) (1LL << (x))\r\n\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\ntemplate<typename T>\r\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate<typename T>\r\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\r\ntemplate<typename T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate<typename T>\r\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\nusing hashmap = gp_hash_table<int, int, custom_hash>;\r\ntemplate<typename T>\r\nusing matrix = vector<vector<T>>;\r\ntemplate<typename T>\r\nusing graph = vector<vector<T>>;\r\n\r\n\r\nnamespace internal {\r\n\r\n#ifndef _MSC_VER\r\n    template<class T>\r\n    using is_signed_int128 =\r\n            typename std::conditional<std::is_same<T, __int128_t>::value ||\r\n                                              std::is_same<T, __int128>::value,\r\n                                      std::true_type,\r\n                                      std::false_type>::type;\r\n\r\n    template<class T>\r\n    using is_unsigned_int128 =\r\n            typename std::conditional<std::is_same<T, __uint128_t>::value ||\r\n                                              std::is_same<T, unsigned __int128>::value,\r\n                                      std::true_type,\r\n                                      std::false_type>::type;\r\n\r\n    template<class T>\r\n    using make_unsigned_int128 =\r\n            typename std::conditional<std::is_same<T, __int128_t>::value,\r\n                                      __uint128_t,\r\n                                      unsigned __int128>;\r\n\r\n    template<class T>\r\n    using is_integral = typename std::conditional<std::is_integral<T>::value ||\r\n                                                          is_signed_int128<T>::value ||\r\n                                                          is_unsigned_int128<T>::value,\r\n                                                  std::true_type,\r\n                                                  std::false_type>::type;\r\n\r\n    template<class T>\r\n    using is_signed_int = typename std::conditional<(is_integral<T>::value &&\r\n                                                     std::is_signed<T>::value) ||\r\n                                                            is_signed_int128<T>::value,\r\n                                                    std::true_type,\r\n                                                    std::false_type>::type;\r\n\r\n    template<class T>\r\n    using is_unsigned_int =\r\n            typename std::conditional<(is_integral<T>::value &&\r\n                                       std::is_unsigned<T>::value) ||\r\n                                              is_unsigned_int128<T>::value,\r\n                                      std::true_type,\r\n                                      std::false_type>::type;\r\n\r\n    template<class T>\r\n    using to_unsigned = typename std::conditional<\r\n            is_signed_int128<T>::value,\r\n            make_unsigned_int128<T>,\r\n            typename std::conditional<std::is_signed<T>::value,\r\n                                      std::make_unsigned<T>,\r\n                                      std::common_type<T>>::type>::type;\r\n\r\n#else\r\n\r\n    template<class T>\r\n    using is_integral = typename std::is_integral<T>;\r\n\r\n    template<class T>\r\n    using is_signed_int =\r\n            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\r\n                                      std::true_type,\r\n                                      std::false_type>::type;\r\n\r\n    template<class T>\r\n    using is_unsigned_int =\r\n            typename std::conditional<is_integral<T>::value &&\r\n                                              std::is_unsigned<T>::value,\r\n                                      std::true_type,\r\n                                      std::false_type>::type;\r\n\r\n    template<class T>\r\n    using to_unsigned = typename std::conditional<is_signed_int<T>::value,\r\n                                                  std::make_unsigned<T>,\r\n                                                  std::common_type<T>>::type;\r\n\r\n#endif\r\n\r\n    template<class T>\r\n    using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\r\n\r\n    template<class T>\r\n    using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\r\n\r\n    template<class T>\r\n    using to_unsigned_t = typename to_unsigned<T>::type;\r\n\r\n}// namespace internal\r\n\r\n\r\nnamespace internal {\r\n\r\n    // @param m `1 <= m`\r\n    // @return x mod m\r\n    constexpr long long safe_mod(long long x, long long m) {\r\n        x %= m;\r\n        if (x < 0) x += m;\r\n        return x;\r\n    }\r\n\r\n    // Fast modular multiplication by barrett reduction\r\n    // Reference: https://en.wikipedia.org/wiki/Barrett_reduction\r\n    // NOTE: reconsider after Ice Lake\r\n    struct barrett {\r\n        unsigned int _m;\r\n        unsigned long long im;\r\n\r\n        // @param m `1 <= m`\r\n        explicit barrett(unsigned int m) : _m(m), im((unsigned long long) (-1) / m + 1) {}\r\n\r\n        // @return m\r\n        unsigned int umod() const { return _m; }\r\n\r\n        // @param a `0 <= a < m`\r\n        // @param b `0 <= b < m`\r\n        // @return `a * b % m`\r\n        unsigned int mul(unsigned int a, unsigned int b) const {\r\n            // [1] m = 1\r\n            // a = b = im = 0, so okay\r\n\r\n            // [2] m >= 2\r\n            // im = ceil(2^64 / m)\r\n            // -> im * m = 2^64 + r (0 <= r < m)\r\n            // let z = a*b = c*m + d (0 <= c, d < m)\r\n            // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\r\n            // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\r\n            // ((ab * im) >> 64) == c or c + 1\r\n            unsigned long long z = a;\r\n            z *= b;\r\n#ifdef _MSC_VER\r\n            unsigned long long x;\r\n            _umul128(z, im, &x);\r\n#else\r\n            unsigned long long x =\r\n                    (unsigned long long) (((unsigned __int128) (z) *im) >> 64);\r\n#endif\r\n            unsigned long long y = x * _m;\r\n            return (unsigned int) (z - y + (z < y ? _m : 0));\r\n        }\r\n    };\r\n\r\n    // @param n `0 <= n`\r\n    // @param m `1 <= m`\r\n    // @return `(x ** n) % m`\r\n    constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\r\n        if (m == 1) return 0;\r\n        unsigned int _m = (unsigned int) (m);\r\n        unsigned long long r = 1;\r\n        unsigned long long y = safe_mod(x, m);\r\n        while (n) {\r\n            if (n & 1) r = (r * y) % _m;\r\n            y = (y * y) % _m;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    // Reference:\r\n    // M. Forisek and J. Jancina,\r\n    // Fast Primality Testing for Integers That Fit into a Machine Word\r\n    // @param n `0 <= n`\r\n    constexpr bool is_prime_constexpr(int n) {\r\n        if (n <= 1) return false;\r\n        if (n == 2 || n == 7 || n == 61) return true;\r\n        if (n % 2 == 0) return false;\r\n        long long d = n - 1;\r\n        while (d % 2 == 0) d /= 2;\r\n        constexpr long long bases[3] = {2, 7, 61};\r\n        for (long long a: bases) {\r\n            long long t = d;\r\n            long long y = pow_mod_constexpr(a, t, n);\r\n            while (t != n - 1 && y != 1 && y != n - 1) {\r\n                y = y * y % n;\r\n                t <<= 1;\r\n            }\r\n            if (y != n - 1 && t % 2 == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    template<int n>\r\n    constexpr bool is_prime = is_prime_constexpr(n);\r\n\r\n    // @param b `1 <= b`\r\n    // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\r\n    constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\r\n        a = safe_mod(a, b);\r\n        if (a == 0) return {b, 0};\r\n\r\n        // Contracts:\r\n        // [1] s - m0 * a = 0 (mod b)\r\n        // [2] t - m1 * a = 0 (mod b)\r\n        // [3] s * |m1| + t * |m0| <= b\r\n        long long s = b, t = a;\r\n        long long m0 = 0, m1 = 1;\r\n\r\n        while (t) {\r\n            long long u = s / t;\r\n            s -= t * u;\r\n            m0 -= m1 * u;// |m1 * u| <= |m1| * s <= b\r\n\r\n            // [3]:\r\n            // (s - t * u) * |m1| + t * |m0 - m1 * u|\r\n            // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\r\n            // = s * |m1| + t * |m0| <= b\r\n\r\n            auto tmp = s;\r\n            s = t;\r\n            t = tmp;\r\n            tmp = m0;\r\n            m0 = m1;\r\n            m1 = tmp;\r\n        }\r\n        // by [3]: |m0| <= b/g\r\n        // by g != b: |m0| < b/g\r\n        if (m0 < 0) m0 += b / s;\r\n        return {s, m0};\r\n    }\r\n\r\n    // Compile time primitive root\r\n    // @param m must be prime\r\n    // @return primitive root (and minimum in now)\r\n    constexpr int primitive_root_constexpr(int m) {\r\n        if (m == 2) return 1;\r\n        if (m == 167772161) return 3;\r\n        if (m == 469762049) return 3;\r\n        if (m == 754974721) return 11;\r\n        if (m == 998244353) return 3;\r\n        int divs[20] = {};\r\n        divs[0] = 2;\r\n        int cnt = 1;\r\n        int x = (m - 1) / 2;\r\n        while (x % 2 == 0) x /= 2;\r\n        for (int i = 3; (long long) (i) *i <= x; i += 2) {\r\n            if (x % i == 0) {\r\n                divs[cnt++] = i;\r\n                while (x % i == 0) {\r\n                    x /= i;\r\n                }\r\n            }\r\n        }\r\n        if (x > 1) {\r\n            divs[cnt++] = x;\r\n        }\r\n        for (int g = 2;; g++) {\r\n            bool ok = true;\r\n            for (int i = 0; i < cnt; i++) {\r\n                if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\r\n                    ok = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (ok) return g;\r\n        }\r\n    }\r\n    template<int m>\r\n    constexpr int primitive_root = primitive_root_constexpr(m);\r\n\r\n    // @param n `n < 2^32`\r\n    // @param m `1 <= m < 2^32`\r\n    // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)\r\n    unsigned long long floor_sum_unsigned(unsigned long long n,\r\n                                          unsigned long long m,\r\n                                          unsigned long long a,\r\n                                          unsigned long long b) {\r\n        unsigned long long ans = 0;\r\n        while (true) {\r\n            if (a >= m) {\r\n                ans += n * (n - 1) / 2 * (a / m);\r\n                a %= m;\r\n            }\r\n            if (b >= m) {\r\n                ans += n * (b / m);\r\n                b %= m;\r\n            }\r\n\r\n            unsigned long long y_max = a * n + b;\r\n            if (y_max < m) break;\r\n            // y_max < m * (n + 1)\r\n            // floor(y_max / m) <= n\r\n            n = (unsigned long long) (y_max / m);\r\n            b = (unsigned long long) (y_max % m);\r\n            std::swap(m, a);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n}// namespace internal\r\n\r\n\r\nnamespace internal {\r\n\r\n    struct modint_base {};\r\n    struct static_modint_base : modint_base {};\r\n\r\n    template<class T>\r\n    using is_modint = std::is_base_of<modint_base, T>;\r\n    template<class T>\r\n    using is_modint_t = std::enable_if_t<is_modint<T>::value>;\r\n\r\n}// namespace internal\r\n\r\ntemplate<int m, std::enable_if_t<(1 <= m)> * = nullptr>\r\nstruct static_modint : internal::static_modint_base {\r\n    using mint = static_modint;\r\n\r\npublic:\r\n    static constexpr int mod() { return m; }\r\n    static mint raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\n\r\n    static_modint() : _v(0) {}\r\n    template<class T, internal::is_signed_int_t<T> * = nullptr>\r\n    static_modint(T v) {\r\n        long long x = (long long) (v % (long long) (umod()));\r\n        if (x < 0) x += umod();\r\n        _v = (unsigned int) (x);\r\n    }\r\n    template<class T, internal::is_unsigned_int_t<T> * = nullptr>\r\n    static_modint(T v) {\r\n        _v = (unsigned int) (v % umod());\r\n    }\r\n\r\n    unsigned int val() const { return _v; }\r\n\r\n    mint &operator++() {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\n    }\r\n    mint &operator--() {\r\n        if (_v == 0) _v = umod();\r\n        _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n        --*this;\r\n        return result;\r\n    }\r\n\r\n    mint &operator+=(const mint &rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint &operator-=(const mint &rhs) {\r\n        _v -= rhs._v;\r\n        if (_v >= umod()) _v += umod();\r\n        return *this;\r\n    }\r\n    mint &operator*=(const mint &rhs) {\r\n        unsigned long long z = _v;\r\n        z *= rhs._v;\r\n        _v = (unsigned int) (z % umod());\r\n        return *this;\r\n    }\r\n    mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\r\n\r\n    mint operator+() const { return *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n\r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n    mint inv() const {\r\n        if (prime) {\r\n            assert(_v);\r\n            return pow(umod() - 2);\r\n        } else {\r\n            auto eg = internal::inv_gcd(_v, m);\r\n            assert(eg.first == 1);\r\n            return eg.second;\r\n        }\r\n    }\r\n\r\n    friend mint operator+(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool operator==(const mint &lhs, const mint &rhs) {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const mint &lhs, const mint &rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\n\r\nprivate:\r\n    unsigned int _v;\r\n    static constexpr unsigned int umod() { return m; }\r\n    static constexpr bool prime = internal::is_prime<m>;\r\n};\r\n\r\ntemplate<int id>\r\nstruct dynamic_modint : internal::modint_base {\r\n    using mint = dynamic_modint;\r\n\r\npublic:\r\n    static int mod() { return (int) (bt.umod()); }\r\n    static void set_mod(int m) {\r\n        assert(1 <= m);\r\n        bt = internal::barrett(m);\r\n    }\r\n    static mint raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\n\r\n    dynamic_modint() : _v(0) {}\r\n    template<class T, internal::is_signed_int_t<T> * = nullptr>\r\n    dynamic_modint(T v) {\r\n        long long x = (long long) (v % (long long) (mod()));\r\n        if (x < 0) x += mod();\r\n        _v = (unsigned int) (x);\r\n    }\r\n    template<class T, internal::is_unsigned_int_t<T> * = nullptr>\r\n    dynamic_modint(T v) {\r\n        _v = (unsigned int) (v % mod());\r\n    }\r\n\r\n    unsigned int val() const { return _v; }\r\n\r\n    mint &operator++() {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\n    }\r\n    mint &operator--() {\r\n        if (_v == 0) _v = umod();\r\n        _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n        --*this;\r\n        return result;\r\n    }\r\n\r\n    mint &operator+=(const mint &rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint &operator-=(const mint &rhs) {\r\n        _v += mod() - rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n        return *this;\r\n    }\r\n    mint &operator*=(const mint &rhs) {\r\n        _v = bt.mul(_v, rhs._v);\r\n        return *this;\r\n    }\r\n    mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\r\n\r\n    mint operator+() const { return *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n\r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n    }\r\n    mint inv() const {\r\n        auto eg = internal::inv_gcd(_v, mod());\r\n        assert(eg.first == 1);\r\n        return eg.second;\r\n    }\r\n\r\n    friend mint operator+(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint &lhs, const mint &rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool operator==(const mint &lhs, const mint &rhs) {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const mint &lhs, const mint &rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\n\r\nprivate:\r\n    unsigned int _v;\r\n    static internal::barrett bt;\r\n    static unsigned int umod() { return bt.umod(); }\r\n};\r\ntemplate<int id>\r\ninternal::barrett dynamic_modint<id>::bt(998244353);\r\n\r\nusing modint998244353 = static_modint<998244353>;\r\nusing modint1000000007 = static_modint<1000000007>;\r\nusing modint = dynamic_modint<-1>;\r\n\r\nnamespace internal {\r\n\r\n    template<class T>\r\n    using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\r\n\r\n    template<class T>\r\n    using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\r\n\r\n    template<class>\r\n    struct is_dynamic_modint : public std::false_type {};\r\n    template<int id>\r\n    struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\r\n\r\n    template<class T>\r\n    using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\r\n\r\n}// namespace internal\r\n\r\n\r\nusing mint = modint998244353;\r\n\r\n#define int long long\r\ntemplate<typename T>\r\nvector<T> vect(int n, T val) {\r\n    return vector<T>(n, val);\r\n}\r\n\r\ntemplate<typename T>\r\nvector<vector<T>> vect(int n, int m, T val) {\r\n    return vector<vector<T>>(n, vector<T>(m, val));\r\n}\r\n\r\ntemplate<typename T>\r\nvector<vector<vector<T>>> vect(int n, int m, int k, T val) {\r\n    return vector<vector<vector<T>>>(n, vector<vector<T>>(m, vector<T>(k, val)));\r\n}\r\n\r\ntemplate<typename T>\r\nvector<vector<vector<vector<T>>>> vect(int n, int m, int k, int l, T val) {\r\n    return vector<vector<vector<vector<T>>>>(n, vector<vector<vector<T>>>(m, vector<vector<T>>(k, vector<T>(l, val))));\r\n}\r\n\r\ntemplate<typename T>\r\nmatrix<T> new_matrix(int n, int m, T val) {\r\n    return matrix<T>(n, vector<T>(m, val));\r\n}\r\n\r\ntemplate<typename T>\r\ngraph<T> new_graph(int n) {\r\n    return graph<T>(n);\r\n}\r\ntemplate<class T, class S>\r\ninline bool chmax(T &a, const S &b) {\r\n    return (a < b ? a = b, 1 : 0);\r\n}\r\ntemplate<class T, class S>\r\ninline bool chmin(T &a, const S &b) {\r\n    return (a > b ? a = b, 1 : 0);\r\n}\r\n\r\nusing i8 = int8_t;\r\nusing i16 = int16_t;\r\nusing i32 = int32_t;\r\nusing i64 = int64_t;\r\nusing u8 = uint8_t;\r\nusing u16 = uint16_t;\r\nusing u32 = uint32_t;\r\nusing u64 = uint64_t;\r\n\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n    int n, m;\r\n    cin >> n >> m;\r\n    matrix<bool> mtr;\r\n    mtr = new_matrix(n, m, false);\r\n    int w = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        for (int j = 0; j < m; ++j) {\r\n            mtr[i][j] = (s[j] == 'o');\r\n            w += (s[j] == 'o');\r\n        }\r\n    }\r\n    if(w < 2){\r\n        cout << 0 << endl;\r\n        return 0;\r\n    }\r\n    mint ans = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        int cnt = 0;\r\n        mint toAdd[2] = {mint(2).pow(w - cnt - 2), mint(2).pow(w - cnt - 3)};\r\n        mint lastPow[2] = {mint(2).pow(w - cnt - 2), mint(2).pow(w - cnt - 3)};\r\n        for (int j = 0; j < m - 1; j++) {\r\n            if (mtr[i][j]) {\r\n                if (mtr[i][j + 1]) {\r\n                    if (cnt % 2 == 0) {\r\n                        ans += toAdd[0];\r\n                        lastPow[0] /= 4;\r\n                        toAdd[0] -= lastPow[0];\r\n                    } else {\r\n                        ans += toAdd[1];\r\n                        lastPow[1] /= 4;\r\n                        toAdd[1] += lastPow[1];\r\n                    }\r\n                }\r\n                cnt++;\r\n            } else {\r\n                cnt = 0;\r\n                toAdd[0] = mint(2).pow(w - cnt - 2);\r\n                toAdd[1] = mint(2).pow(w - cnt - 3);\r\n                lastPow[0] = mint(2).pow(w - cnt - 2);\r\n                lastPow[1] = mint(2).pow(w - cnt - 3);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < m; i++) {\r\n        int cnt = 0;\r\n        mint toAdd[2] = {mint(2).pow(w - cnt - 2), mint(2).pow(w - cnt - 3)};\r\n        mint lastPow[2] = {mint(2).pow(w - cnt - 2), mint(2).pow(w - cnt - 3)};\r\n        for (int j = 0; j < n - 1; j++) {\r\n            if (mtr[j][i]) {\r\n                if (mtr[j + 1][i]) {\r\n                    if (cnt % 2 == 0) {\r\n                        ans += toAdd[0];\r\n                        lastPow[0] /= 4;\r\n                        toAdd[0] -= lastPow[0];\r\n                    } else {\r\n                        ans += toAdd[1];\r\n                        lastPow[1] /= 4;\r\n                        toAdd[1] += lastPow[1];\r\n                    }\r\n                }\r\n                cnt++;\r\n            } else {\r\n                cnt = 0;\r\n                toAdd[0] = mint(2).pow(w - cnt - 2);\r\n                toAdd[1] = mint(2).pow(w - cnt - 3);\r\n                lastPow[0] = mint(2).pow(w - cnt - 2);\r\n                lastPow[1] = mint(2).pow(w - cnt - 3);\r\n            }\r\n        }\r\n    }\r\n\r\n    cout << ans.val() << endl;\r\n}"
}