{
    "id": 221500503,
    "contestId": 1684,
    "creationTimeSeconds": 1693604156,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1684,
        "index": "F",
        "name": "Diverse Segments",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2600,
        "tags": [
            "data structures",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1684,
        "members": [
            {
                "handle": "Perpetually_Purple"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1652970900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 327,
    "memoryConsumedBytes": 16998400,
    "source": "// uncomment if you need to cheese\r\n//#pragma GCC target (\"avx2\")\r\n//#pragma GCC optimize (\"O3\")\r\n//#pragma GCC optimize(\"Ofast\")\r\n//#pragma GCC optimize (\"unroll-loops\")\r\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL) \r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define endl '\\n'\r\ntypedef long long ll;\r\n#define mod1 (ll)1000000007\r\n#define mod2 (ll)998244353\r\n#define pll pair<ll,ll>\r\ntypedef long double lb;\r\ntypedef tree<\r\npair<ll, ll>,\r\nnull_type,\r\nless<pair<ll, ll>>,\r\nrb_tree_tag,\r\ntree_order_statistics_node_update> ordered_set;\r\n#define eps (lb)(1e-9)\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n// Operator overloads\r\ntemplate<typename T1, typename T2> // cin >> pair<T1, T2>\r\nistream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); }\r\n\r\ntemplate<typename T> // cin >> vector<T>\r\nistream& operator>>(istream &istream, vector<T> &v)\r\n{\r\n    for (auto &it : v)\r\n        cin >> it;\r\n    return istream;\r\n}\r\n\r\ntemplate<typename T1, typename T2> // cout << pair<T1, T2>\r\nostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }\r\ntemplate<typename T> // cout << vector<T>\r\nostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }\r\n\r\n// Utility functions\r\ntemplate <typename T>\r\nvoid print(T &&t)  { cout << t << \"\\n\"; }\r\ntemplate <typename T, typename... Args>\r\nvoid print(T &&t, Args &&... args)\r\n{\r\n    cout << t << \" \";\r\n    print(forward<Args>(args)...);\r\n}\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nll random(ll p){ // gives random number in [0,p]\r\n\r\n return uniform_int_distribution<ll>(0, p)(rng);\r\n}\r\nll solve();\r\nint main() {\r\nio;\r\nll t=1,n=1;\r\ncin>>t;\r\nwhile (t--){\r\n     cout<<solve()<<endl;;\r\n    }\r\n     return 0;\r\n}\r\nll solve(){\r\n    ll n,q;\r\n    cin>>n>>q;;\r\n    vector<ll>v(n);\r\n    vector<pll>p(q); \r\n    cin>>v>>p;\r\n    for(auto &i:p){i.first--,i.second--;}\r\n    // return 0;\r\n    {\r\n        map<ll,ll>m;\r\n        auto p=v;\r\n        sort(all(p));\r\n        for(ll i(0);i<n;++i){\r\n            m[p[i]]=i;\r\n        }\r\n        for(auto &i:v){\r\n            i=m[i];\r\n        }\r\n    }\r\n    // return 0;\r\n    {\r\n        sort(all(p));\r\n        vector<pll>pp;\r\n        for(ll i(0);i<q;++i){\r\n            ll j=i;\r\n            while (j<q and p[j].first==p[i].first)\r\n            {\r\n                ++j;\r\n            }\r\n            --j;\r\n            pp.push_back(p[j]);\r\n            i=j;\r\n            \r\n        }\r\n        p=pp;\r\n        pp.clear();\r\n        pp.push_back({-1,-1});\r\n        for(auto i:p){\r\n            if(i.second>pp.back().second){\r\n                pp.push_back(i);\r\n            }\r\n        }\r\n        pp.erase(begin(pp));\r\n        p=pp;\r\n        if(p.back().second!=(n-1)){\r\n            p.push_back({n-1,n-1});\r\n        }\r\n    }\r\n    // return 0;\r\n    vector<ll>nex(n,n); // next with same value;\r\n    {\r\n        map<ll,ll>m;\r\n        for(auto i:v){m[i]=n;}\r\n        for(ll i(n-1);i>-1;--i){\r\n            nex[i]=m[v[i]];\r\n            m[v[i]]=i;\r\n        }\r\n    }\r\n    \r\n    ll cur=p[0].first;\r\n    ll ptr=0;\r\n    vector<pll>ranges;\r\n    for(ll i(cur);i<n;++i){\r\n        ll nx=nex[i];\r\n        if(nx<=p[ptr].second){ // if its in the range\r\n            ranges.push_back({i,nx});\r\n        }\r\n        if(i==p.back().second){break;} \r\n        if(p[ptr+1].first==(i+1)){\r\n            ptr++;\r\n        }\r\n    }\r\n    // return 0;\r\n    sort(all(ranges));\r\n    // cout<<ranges<<endl;\r\n    \r\n    if(ranges.size()==0){\r\n        // cout<<ranges.size()<<endl;\r\n        return ranges.size();\r\n    }\r\n    ll r=n,l=-1;\r\n    l=ranges.back().first;\r\n    for(auto i:ranges){\r\n        r=min(r,i.second);\r\n    }\r\n    // cout<<ranges<<endl;\r\n    ll ans=max(0ll,l-r+1);\r\n    // cout<<ans<<endl;\r\n    // cout<<r<<\" \"<<l<<endl;\r\n    if(r>l){\r\n        l=r=-1;\r\n    }\r\n    if(l>=r){\r\n        ll ans1=n;\r\n        // do the whole thing again\r\n        vector<ll>v1;\r\n        for(ll i(0);i<n;++i){\r\n            if( (i>l) or(i<r)){\r\n                v1.push_back(v[i]);\r\n                \r\n            }\r\n        }\r\n        vector<pll>p1;\r\n        for(auto i:p){\r\n\r\n            if( (r>=0) and  ((i.first<r) and (i.second>l))){\r\n                i.second-=((l-r)+1);\r\n                p1.push_back(i);\r\n            }\r\n            else if(r<0){\r\n                p1.push_back(i);\r\n            }\r\n        }\r\n        if(p1.back().second!=(n-1)){\r\n            p1.push_back({n-1,n-1});\r\n        }\r\n        // new array new queries\r\n        ll n=v1.size();\r\n        ans1=n;\r\n        {\r\n            map<ll,ll>m;\r\n            auto p1=v1;\r\n            sort(all(p1));\r\n            for(ll i(0);i<n;++i){\r\n                m[p1[i]]=i;\r\n            }\r\n            for(auto &i:v1){\r\n                i=m[i];\r\n            }\r\n        }\r\n        \r\n        // cout<<v1<<\"->\"<<p1<<endl;\r\n        vector<ll>nex1(n,n); // next with same value;\r\n        {\r\n            map<ll,ll>m;\r\n            for(auto i:v1){m[i]=n;}\r\n            for(ll i(n-1);i>-1;--i){\r\n                nex1[i]=m[v1[i]];\r\n                m[v1[i]]=i;\r\n            }\r\n        }\r\n        // vector<pll>ranges1;\r\n        ll cur=p1[0].first;\r\n        ll ptr=0;\r\n        vector<pll>ranges1;\r\n        for(ll i(cur);i<n;++i){\r\n            ll nx=nex1[i];\r\n            if(nx<=p1[ptr].second){ // if its in the range\r\n                ranges1.push_back({i,nx});\r\n            }\r\n            if(i==p1.back().second){break;} \r\n            if(p1[ptr+1].first==(i+1)){\r\n                ptr++;\r\n            }\r\n        }\r\n        // cout<<ranges1<<endl;\r\n        if(ranges1.size()==0){\r\n            ans1=0;\r\n        }\r\n        else {\r\n            ll r=n;\r\n            set<ll>endpoints;\r\n            for(auto i:ranges1){\r\n                endpoints.insert(i.first);\r\n                r=min(r,i.second);\r\n            }\r\n            \r\n\r\n            for(ll i(0);i<=r;++i){\r\n                auto j=*rbegin(endpoints);\r\n                ans1=min(ans1,j-i+1);\r\n                // we increment i\r\n                if(endpoints.count(i)){\r\n                    endpoints.erase(i);\r\n                    ll ind=lower_bound(all(ranges1),pair(i,i))-begin(ranges1);\r\n                    endpoints.insert(ranges1[ind].second);\r\n                }\r\n            }\r\n            // cout<<ans<<endl;\r\n        }\r\n        ans+=ans1;\r\n\r\n    }\r\n    \r\n    \r\n    return ans;\r\n\r\n\r\n\r\n\r\n\r\n}\r\n// Do not get stuck on a single approach for long, think of multiple ways"
}