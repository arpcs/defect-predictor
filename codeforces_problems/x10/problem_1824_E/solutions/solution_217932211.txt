{
    "id": 217932211,
    "contestId": 1824,
    "creationTimeSeconds": 1691531849,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1824,
        "index": "E",
        "name": "LuoTianyi and Cartridge",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1824,
        "members": [
            {
                "handle": "shaban2022"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1683547500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 59,
    "timeConsumedMillis": 1777,
    "memoryConsumedBytes": 79564800,
    "source": "#include <iostream>\r\n#include <algorithm>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<cstdlib>\r\n#include<vector>\r\n#include<iomanip>\r\n#include<ctime>\r\n#include<set>\r\n#include<map>\r\n#include<queue>\r\n#include<stack>\r\n#include<bitset>\r\n#include<cassert>\r\n#define sqr(x) ((x)*(x))\r\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\r\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\r\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\r\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\r\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\r\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\r\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\r\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\r\n#define fzin fz1(i,n)\r\n#define fzim fz1(i,m)\r\n#define fzjn fz1(j,n)\r\n#define fzjm fz1(j,m)\r\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\r\n#define pb push_back\r\n#define mk make_pair\r\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\r\n#define spln(i,n) (i==n?'\\n':' ')\r\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\r\nusing namespace std;\r\ntypedef long long i64;\r\ntypedef long double f80;\r\ntypedef unsigned int u32;\r\ntypedef unsigned long long u64;\r\n//typedef __int128 i128;\r\n//typedef unsigned __int128 u128;\r\n/*#ifndef ONLINE_JUDGE\r\n\tFILE *___=freopen(\"1.in\",\"r\",stdin);\r\n#endif*/\r\ninline void read(int &x)\r\n{\r\n\tchar c;int f=1;\r\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\r\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\r\n\tx*=f;\r\n}\r\ni64 ans=0,cs=0;\r\nint n,m,i,j,a[400005],b[200005],fa[200005],fid[200005],rt,vis[200005],cur,lim,lc,typ=0,av;\r\nnamespace slpf\r\n{\r\n\tint fa[500005],sz[500005],tp[500005],son[500005],dfn[500005],ti,mp[500005],dep[500005];\r\n\tvector<int> bi[500005];\r\n\tvoid dfs1(int x,int fa){slpf::fa[x]=fa;sz[x]=1;ff(bi[x],it)if(*it!=fa){dep[*it]=dep[x]+1;dfs1(*it,x);sz[x]+=sz[*it];if(!son[x]||sz[son[x]]<sz[*it]){son[x]=*it;}}}\t\r\n\tvoid dfs2(int x,int t){mp[dfn[x]=++ti]=x;tp[x]=t;if(son[x])dfs2(son[x],t);ff(bi[x],it)if(*it!=fa[x]&&*it!=son[x]){dfs2(*it,*it);} }\r\n\tint lca(int x,int y)\r\n\t{\r\n\t\twhile(tp[x]!=tp[y]){if(dep[tp[x]]<dep[tp[y]])swap(x,y);x=fa[tp[x]];}\r\n\t\treturn mp[min(dfn[x],dfn[y])];\r\n\t}\r\n}\r\nint px[200005],py[200005],pz[200005],pa[200005],ve[200005];\r\nint dfn[200005],dfe[200005],mp[200005],ti;\r\nvector<int> bi[200005];\r\nvector<int> v;\r\nvoid dfs0(int x)\r\n{\r\n\tmp[dfn[x]=++ti]=x;\r\n\tff(bi[x],it)if(*it!=fid[x]){\r\n\t\tint y=px[*it]^py[*it]^x;\r\n\t\tfa[y]=x;fid[y]=*it;\r\n\t\tdfs0(y);\r\n\t}\r\n\tdfe[x]=ti;\r\n}\r\nstruct seg1\r\n{\r\n\tpair<int,int> mx[800005];\r\n\tint cnt[800005];\r\n\tint tag[800005],hv[800005];\r\n\tvoid pushup(int x)\r\n\t{\r\n\t\tmx[x]=max(mx[x+x],mx[x+x+1]);\r\n\t\tcnt[x]=cnt[x+x]+cnt[x+x+1];\r\n\t\thv[x]=hv[x+x]|hv[x+x+1];\r\n\t}\r\n\tvoid build(int x,int l,int r)\r\n\t{\r\n\t\ttag[x]=-1;\r\n\t\tif(l==r){\r\n\t\t\tmx[x]=make_pair(-1,mp[l]);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint mid=(l+r)/2;build(x+x,l,mid);build(x+x+1,mid+1,r);\r\n\t\tpushup(x);\r\n\t}\r\n\tvoid upd2(int x,int c)\r\n\t{\r\n\t\ttag[x]=hv[x]=c;\r\n\t}\r\n\tvoid pushdo(int x)\r\n\t{\r\n\t\tif(tag[x]!=-1){\r\n\t\t\tupd2(x+x,tag[x]);\r\n\t\t\tupd2(x+x+1,tag[x]);\r\n\t\t\ttag[x]=-1;\r\n\t\t}\r\n\t}\r\n\tvoid update1(int x,int l,int r,int y,int c)\r\n\t{\r\n\t\tif(l==r){mx[x].first=c;return;}int mid=(l+r)/2;pushdo(x);\r\n\t\tif(y<=mid)update1(x+x,l,mid,y,c);else update1(x+x+1,mid+1,r,y,c);\r\n\t\tpushup(x);\r\n\t}\r\n\tpair<int,int> query1(int x,int l,int r,int ql,int qr)\r\n\t{\r\n\t\tif(ql>qr) return make_pair(-1,-1);\r\n\t\tif(ql<=l&&r<=qr) return mx[x];int mid=(l+r)/2;pushdo(x);\r\n\t\tpair<int,int> res=make_pair(-1,-1);\r\n\t\tif(ql<=mid)res=max(res,query1(x+x,l,mid,ql,qr));\r\n\t\tif(qr>mid)res=max(res,query1(x+x+1,mid+1,r,ql,qr));\r\n\t\treturn res;\r\n\t}\r\n\tvoid update2(int x,int l,int r,int ql,int qr,int c)\r\n\t{\r\n\t\tif(ql<=l&&r<=qr){upd2(x,c);return;}int mid=(l+r)/2;pushdo(x);\r\n\t\tif(ql<=mid)update2(x+x,l,mid,ql,qr,c);\r\n\t\tif(qr>mid)update2(x+x+1,mid+1,r,ql,qr,c);\r\n\t\tpushup(x);\r\n\t}\r\n\tint query2(int x,int l,int r,int ql,int qr)\r\n\t{\r\n\t\tif(ql<=l&&r<=qr)return hv[x];int mid=(l+r)/2;pushdo(x);int s=0;\r\n\t\tif(ql<=mid)s|=query2(x+x,l,mid,ql,qr);\r\n\t\tif(qr>mid)s|=query2(x+x+1,mid+1,r,ql,qr);\r\n\t\treturn s;\r\n\t}\r\n\tvoid update3(int x,int l,int r,int y,int c)\r\n\t{\r\n\t\tif(l==r){cnt[x]=c;return;}int mid=(l+r)/2;pushdo(x);\r\n\t\tif(y<=mid)update3(x+x,l,mid,y,c);else update3(x+x+1,mid+1,r,y,c);\r\n\t\tpushup(x);\r\n\t}\r\n\tint query3(int x,int l,int r,int ql,int qr)\r\n\t{\r\n\t\tif(ql>qr) return 0;\r\n\t\tif(ql<=l&&r<=qr)return cnt[x];int mid=(l+r)/2;pushdo(x);int s=0;\r\n\t\tif(ql<=mid)s+=query3(x+x,l,mid,ql,qr);\r\n\t\tif(qr>mid)s+=query3(x+x+1,mid+1,r,ql,qr);\r\n\t\treturn s;\r\n\t}\r\n\tvoid print2(int x,int l,int r)\r\n\t{\r\n\t\tif(l==r){cerr<<hv[x]<<' ';return;}int mid=(l+r)/2;pushdo(x);\r\n\t\tprint2(x+x,l,mid);print2(x+x+1,mid+1,r);\r\n\t}\r\n\tvoid print3(int x,int l,int r)\r\n\t{\r\n\t\tif(l==r){cerr<<cnt[x]<<' ';return;}int mid=(l+r)/2;pushdo(x);\r\n\t\tprint3(x+x,l,mid);print3(x+x+1,mid+1,r);\r\n\t}\r\n}tr1;\r\nint prot[800005];\r\nset<pair<int,int> > cv;\r\nvoid merge(int x)\r\n{\r\n\tif(!lc){\r\n\t\tlc=x;typ=1;\r\n\t\treturn;\r\n\t}\r\n\tint z=slpf::lca(lc,x);\r\n\tif(z==x) lc=x,typ=1;\r\n\tif(z==lc) return;\r\n\telse lc=z,typ=0;\r\n}\r\nint gtf(int x) // mp\r\n{\r\n\tif(dfn[x]<dfn[lc]||dfn[x]>dfe[lc]) return typ==1?0:-1;\r\n\tint t=tr1.query2(1,1,n,dfn[x],dfn[x]);\r\n\tif(t==0) return -1;\r\n\treturn t;\r\n}\r\npriority_queue<int> e0;\r\npriority_queue<int,vector<int>,greater<int> > e1;\r\nvoid flush0(int x)\r\n{\r\n\tint f=gtf(x);\r\n\tif(f!=-1){\r\n\t\tif(prot[f]){\r\n\t\t\tcv.insert(make_pair(b[prot[f]],prot[f]));\r\n\t\t\tprot[f]=0;\r\n\t\t}\r\n\t}\r\n}\r\nvoid reduce()\r\n{\r\n\twhile(cur<lim&&cur<av){\r\n\t\tpair<int,int> tmp=tr1.mx[1];\r\n\t\tcur++;cs+=tmp.first;\r\n\t\tcv.insert(make_pair(b[tmp.second],tmp.second));\r\n\t\ttr1.update1(1,1,n,dfn[tmp.second],-1);\r\n\t\ttr1.update3(1,1,n,dfn[tmp.second],1);\r\n\t\tflush0(tmp.second);\r\n\t}\r\n\twhile(!cv.empty()&&cur>=lim){\r\n//\t\ttr1.print3(1,1,n);cerr<<endl;\r\n\t\tpair<int,int> tmp=*cv.begin();\r\n\t\tcv.erase(cv.begin());\r\n\t\tif(lc){\r\n\t\t\tint f=gtf(tmp.second);\r\n\t\t\tif(f!=-1){\r\n\t\t\t\tint cnt=(f==0?tr1.query3(1,1,n,1,dfn[lc]-1)+tr1.query3(1,1,n,dfe[lc]+1,n):tr1.query3(1,1,n,dfn[f],dfe[f]));\r\n\t\t\t\tif(cnt==1){\r\n\t\t\t\t\tassert(!prot[f]);prot[f]=tmp.second;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(cur==lim){\r\n\t\t\tpair<int,int> tmp2=tr1.mx[1];\r\n\t\t\tif(tmp2.first<=tmp.first){cv.insert(tmp);break;}\r\n\t\t\tcur++;cs+=tmp2.first;\r\n\t\t\tcv.insert(make_pair(b[tmp2.second],tmp2.second));\r\n\t\t\ttr1.update1(1,1,n,dfn[tmp2.second],-1);\r\n\t\t\ttr1.update3(1,1,n,dfn[tmp2.second],1);\r\n\t\t\tflush0(tmp2.second);\r\n\t\t}\r\n\t\tcur--;cs-=tmp.first;\r\n\t\ttr1.update1(1,1,n,dfn[tmp.second],b[tmp.second]);\r\n\t\ttr1.update3(1,1,n,dfn[tmp.second],0);\r\n\t}\r\n\tif(cur>=1){\r\n\t\twhile(e1.size()<cur-1){\r\n\t\t\tcs+=e0.top();e1.push(e0.top());e0.pop();\r\n\t\t}\r\n\t\twhile(e1.size()>cur-1){\r\n\t\t\tcs-=e1.top();e0.push(e1.top());e1.pop();\r\n\t\t}\r\n\t\twhile(!e1.empty()&&!e0.empty()&&e0.top()>e1.top()){\r\n\t\t\tcs+=e0.top();e1.push(e0.top());e0.pop();\r\n\t\t\tcs-=e1.top();e0.push(e1.top());e1.pop();\r\n\t\t}\r\n\t}\r\n}\r\nvoid flush(int x)\r\n{\r\n\tint f=gtf(x);\r\n\tif(f!=-1){\r\n\t\tint cnt=(f==0?tr1.query3(1,1,n,1,dfn[lc]-1)+tr1.query3(1,1,n,dfe[lc]+1,n):tr1.query3(1,1,n,dfn[f],dfe[f]));\r\n\t\tif(!cnt){\r\n\t\t\tpair<int,int> tmp=(f==0?max(tr1.query1(1,1,n,1,dfn[lc]-1),tr1.query1(1,1,n,dfe[lc]+1,n)):tr1.query1(1,1,n,dfn[f],dfe[f]));\r\n\t\t\tif(tmp.first>-1){\r\n\t\t\t\tcur++;cs+=tmp.first;\r\n\t\t\t\tcv.insert(make_pair(b[tmp.second],tmp.second));\r\n\t\t\t\ttr1.update3(1,1,n,dfn[tmp.second],1);\r\n\t\t\t\ttr1.update1(1,1,n,dfn[tmp.second],-1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(prot[f]){\r\n\t\t\tcv.insert(make_pair(b[prot[f]],prot[f]));\r\n\t\t\tprot[f]=0;\r\n\t\t}\r\n\t}\r\n}\r\nvoid remake()\r\n{\r\n\twhile(tr1.mx[1].first>-1){\r\n\t\tpair<int,int> tmp=tr1.mx[1];\r\n\t\tcur++;cs+=tmp.first;\r\n\t\tcv.insert(make_pair(b[tmp.second],tmp.second));\r\n\t\ttr1.update1(1,1,n,dfn[tmp.second],-1);\r\n\t\ttr1.update3(1,1,n,dfn[tmp.second],1);\r\n\t}\r\n}\r\nvoid inse(int x)\r\n{\r\n\tlim++;cs+=pz[x];e1.push(pz[x]);\r\n\tif(lc) flush(px[x]); else remake();\r\n\tif(lc&&dfn[lc]<=dfn[px[x]]&&dfn[px[x]]<=dfe[lc]){\r\n\t\tint f=gtf(px[x]);\r\n\t\tif(f!=-1) tr1.update2(1,1,n,dfn[f],dfe[f],0);\r\n\t}\r\n\tif(!tr1.query2(1,1,n,dfn[px[x]],dfe[px[x]])) tr1.update2(1,1,n,dfn[px[x]],dfe[px[x]],px[x]);\r\n\tmerge(px[x]);\r\n\tflush(rt);flush(px[x]);\r\n//\ttr1.print2(1,1,n);cerr<<endl;\r\n}\r\nint main()\r\n{\r\n\tread(n);fz1(i,n)read(a[i]);fz1(i,n)read(b[i]);\r\n\tfz1(i,n-1){\r\n\t\tread(px[i]);read(py[i]);read(a[i+n]);read(pz[i]);pa[i]=a[i+n];\r\n\t\tslpf::bi[px[i]].push_back(py[i]);\r\n\t\tslpf::bi[py[i]].push_back(px[i]);\r\n\t\tbi[px[i]].push_back(i);bi[py[i]].push_back(i);\r\n\t}\r\n\tfz1(i,n+n-1)v.push_back(i);\r\n\tsort(v.begin(),v.end(),[&](int x,int y){return a[x]>a[y];});\r\n\trt=0;while(v[rt]>n)rt++;rt=v[rt];\r\n\tdfs0(rt);\r\n\tslpf::dfs1(rt,0);slpf::dfs2(rt,rt);\r\n\ttr1.build(1,1,n);\r\n\tfz1(i,n-1)if(fa[py[i]]==px[i]) swap(px[i],py[i]);\r\n\tff(v,it){\r\n\t\tif(*it<=n){\r\n\t\t\tint x=*it;av++;\r\n\t\t\tif(x==rt){\r\n\t\t\t\tlim=cur=1;cs+=b[x];cv.insert(make_pair(b[x],x));\r\n\t\t\t\ttr1.update3(1,1,n,dfn[x],1);\r\n\t\t\t\tvis[x]=1;ans=max(ans,1ll*a[x]*cs);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tcur++;cs+=b[x];cv.insert(make_pair(b[x],x));\r\n\t\t\ttr1.update3(1,1,n,dfn[x],1);\r\n\t\t\tif(lc){\r\n\t\t\t\tflush(x);\r\n\t\t\t}\r\n\t\t\twhile(!vis[x]){\r\n\t\t\t\tvis[x]=1;\r\n\t\t\t\tif(ve[x]) inse(ve[x]);\r\n\t\t\t\tx=fa[x];\r\n\t\t\t}\r\n\t\t\treduce();ans=max(ans,1ll*a[*it]*cs);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint x=*it-n;\r\n\t\t\tve[px[x]]=x;\r\n\t\t\tif(!lim) continue;\r\n\t\t\tif(vis[px[x]]) inse(x);\r\n\t\t\treduce();ans=max(ans,1ll*a[*it]*cs);\r\n\t\t}\r\n\t}\r\n\tcout<<ans<<endl;\r\n\treturn 0;\r\n}"
}