{
    "id": 227813328,
    "contestId": 1824,
    "creationTimeSeconds": 1697115233,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1824,
        "index": "E",
        "name": "LuoTianyi and Cartridge",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1824,
        "members": [
            {
                "handle": "DitaMirika"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1683547500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 52121600,
    "source": "// LUOGU_RID: 128990607\n// 2024 HOPE IN VALUABLE\n/*\n\u679a\u4e3e x=min(A,C)\n\u8003\u8651\u6240\u6709\u6ee1\u8db3 Ai/Ci >= x \u7684\u70b9/\u8fb9\uff0c\u5f97\u5230\u70b9\u96c6\u548c\u8fb9\u96c6 V/E\n\u5148\u53bb\u6389 E \u4e2d\u4e00\u5b9a\u6ca1\u7528\u7684\u8fb9\uff08\u6709\u4e00\u7aef\u6ca1\u6709 V \u5185\u7684\u70b9\uff09\n\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u8bc1\u660e\u7684\u662f ansV=V / ansE=E\n\u82e5 E>=V-1 \u76f4\u63a5\u6c42 V-1 \u5927\u7684 E \u5c31\u597d\n\u82e5 E<V-1 \u5219\u9650\u5236 E \u4e2a dfn \u533a\u95f4\u5185/\u5916\u90fd\u5f97\u6709\u70b9\n\u6211\u4eec\u8fd8\u77e5\u9053 dfn \u533a\u95f4\u4e00\u5b9a\u662f\u4e24\u4e24\u4e0d\u4ea4\u7684\n\u5148\u628a\u6240\u6709\u6781\u5c0f\u9650\u5236 dfn \u533a\u95f4\u5185\u7684\u6700\u5927\u503c\u9009\u51fa\u6765\n\u5982\u679c\u6709\u4e00\u4e2a\u6781\u5927\u9650\u5236\u533a\u95f4\u5305\u542b\u6240\u6709\u5176\u4ed6\u533a\u95f4\uff0c\u90a3\u5b83\u5916\u9762\u4e5f\u8981\u9009\u4e00\u4e2a\u6700\u5927\u503c\n\u5269\u4e0b\u7684\u5c31\u968f\u4fbf\u9009\u4e86\n*/\n#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define ls(x) (x<<1)\n#define rs(x) (x<<1|1)\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint n,m,nn,a[N],b[N],c[N],d[N],x[N],y[N]; vector<int>e[N];\nint E,V,idx,fa[N],dfn[N],siz[N],submx[N],outmx[N]; ll sumE,sumV,ans;\nstruct EV{\n\tint op,k,val,id;\n\tbool operator < (const EV &a) const{ return k>a.k; }\n}o[N<<1];\ninline void dfs1(int u){\n\tdfn[u]=++idx; siz[u]=1; submx[u]=a[u];\n\tfor(int v:e[u]){\n\t\tif(v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tdfs1(v); siz[u]+=siz[v];\n\t\tsubmx[u]=max(submx[u],submx[v]);\n\t}\n}\ninline void dfs2(int u){\n\tint fi=0,id=0,se=0;\n\tfor(int v:e[u]) if(v!=fa[u]){\n\t\tif(submx[v]>fi) se=fi,id=v,fi=submx[v];\n\t\telse if(submx[v]>se) se=submx[v];\n\t}\n\tfor(int v:e[u]) if(v!=fa[u]){\n\t\toutmx[v]=max(outmx[u],a[u]);\n\t\tif(id==v) outmx[v]=max(outmx[v],se);\n\t\telse outmx[v]=max(outmx[v],fi);\n\t\tdfs2(v);\n\t}\n}\nstruct SegTreeA{\n\tstruct Node{ ll sum; int cnt; }t[N<<2];\n\tinline void pushup(int u){\n\t\tt[u].cnt=t[ls(u)].cnt+t[rs(u)].cnt;\n\t\tt[u].sum=t[ls(u)].sum+t[rs(u)].sum;\n\t}\n\tinline void update(int u,int l,int r,int x,int y){\n\t\tif(l==r) return t[u].cnt+=y,t[u].sum+=x*y,void();\n\t\tint mid=l+r>>1;\n\t\tif(x<=mid) update(ls(u),l,mid,x,y);\n\t\telse update(rs(u),mid+1,r,x,y);\n\t\tpushup(u);\n\t}\n\tinline ll query(int u,int l,int r,int x){\n\t\tif(l==r) return 1ll*x*l;\n\t\tint mid=l+r>>1;\n\t\tif(t[rs(u)].cnt>=x) return query(rs(u),mid+1,r,x);\n\t\treturn t[rs(u)].sum+query(ls(u),l,mid,x-t[rs(u)].cnt);\n\t}\n}sgt0,sgt1;\nstruct SegTreeB{\n\tpii t[N<<2];\n\tinline pii pushup(pii a,pii b){ return a.first>=b.first?a:b; }\n\tinline void update(int u,int l,int r,int x,int y){\n\t\tif(l==r) return t[u]={y,l},void();\n\t\tint mid=l+r>>1;\n\t\tif(x<=mid) update(ls(u),l,mid,x,y);\n\t\telse update(rs(u),mid+1,r,x,y);\n\t\tt[u]=pushup(t[ls(u)],t[rs(u)]);\n\t}\n\tinline pii query(int u,int l,int r,int ql,int qr){\n\t\tif(l>=ql&&r<=qr) return t[u];\n\t\tint mid=l+r>>1;\n\t\tif(qr<=mid) return query(ls(u),l,mid,ql,qr);\n\t\tif(ql>mid) return query(rs(u),mid+1,r,ql,qr);\n\t\treturn pushup(query(ls(u),l,mid,ql,qr),query(rs(u),mid+1,r,ql,qr));\n\t}\n}sgt2;\nnamespace ds0{\n\tinline void ins(int x){ sgt0.update(1,1,m,x,1); }\n\tinline int query(int x){ return sgt0.query(1,1,m,x); }\n}\nnamespace ds1{\n\tstruct seg{\n\t\tint l,r,v,id;\n\t\tbool operator < (const seg &a) const { return l!=a.l?l<a.l:r<a.r; }\n\t}; set<seg>s; ll cur; int sl,sr,mxr;\n\tinline void ins_p(int x,int val){\n\t\tauto it=s.upper_bound(seg{x,n+1,0,0});\n\t\tif(it!=s.begin()){\n\t\t\tit--;\n\t\t\tif(it->r>=x&&it->v<val){\n\t\t\t\tcur+=val-it->v;\n\t\t\t\tsgt1.update(1,1,m,it->v,1);\n\t\t\t\tsgt2.update(1,1,n,it->id,it->v);\n\t\t\t\tint l=it->l,r=it->r; s.erase(it);\n\t\t\t\ts.insert(seg{l,r,val,x});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsgt1.update(1,1,m,val,1);\n\t\t\t\tsgt2.update(1,1,n,x,val);\n\t\t\t}\t\n\t\t}\n\t\telse{\n\t\t\tsgt1.update(1,1,m,val,1);\n\t\t\tsgt2.update(1,1,n,x,val);\n\t\t}\n\t}\n\tinline void ins_i(int u){\n\t\tif(!sl||dfn[u]<sl) sl=dfn[u],sr=dfn[u]+siz[u]-1;\n\t\tmxr=max(mxr,dfn[u]+siz[u]-1);\n\t\tauto it=s.lower_bound(seg{dfn[u],dfn[u]+siz[u],0,0});\n\t\tif(it!=s.end()&&it->r<=dfn[u]+siz[u]-1) return;\n\t\tif(it!=s.begin()){\n\t\t\tit--;\n\t\t\tif(it->r>=dfn[u]){\n\t\t\t\tcur-=it->v;\n\t\t\t\tsgt1.update(1,1,m,it->v,1); sgt2.update(1,1,n,it->id,it->v);\n\t\t\t\ts.erase(it); pii le=sgt2.query(1,1,n,dfn[u],dfn[u]+siz[u]-1);\n\t\t\t\tcur+=le.first;\n\t\t\t\ts.insert(seg{dfn[u],dfn[u]+siz[u]-1,le.first,le.second});\n\t\t\t\tsgt1.update(1,1,m,le.first,-1); sgt2.update(1,1,n,le.second,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpii le=sgt2.query(1,1,n,dfn[u],dfn[u]+siz[u]-1);\n\t\t\t\tcur+=le.first;\n\t\t\t\ts.insert(seg{dfn[u],dfn[u]+siz[u]-1,le.first,le.second});\n\t\t\t\tsgt1.update(1,1,m,le.first,-1); sgt2.update(1,1,n,le.second,0);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpii le=sgt2.query(1,1,n,dfn[u],dfn[u]+siz[u]-1);\n\t\t\tcur+=le.first;\n\t\t\ts.insert(seg{dfn[u],dfn[u]+siz[u]-1,le.first,le.second});\n\t\t\tsgt1.update(1,1,m,le.first,-1); sgt2.update(1,1,n,le.second,0);\n\t\t}\n\t}\n\tinline ll query(int k){\n\t\tll ans=cur; pii le={0,0},ri={0,0}; k-=s.size();\n\t\tif(sl&&sr==mxr){\n\t\t\tif(sl>1) le=sgt2.query(1,1,n,1,sl-1);\n\t\t\tif(sr<n) ri=sgt2.query(1,1,n,sr+1,n);\n\t\t\tif(ri.first>le.first) swap(le,ri);\n\t\t\tsgt1.update(1,1,m,le.first,-1);\n\t\t\tk--; ans+=sgt1.query(1,1,m,k);\n\t\t\tsgt1.update(1,1,m,le.first,1);\n\t\t\treturn ans;\n\t\t}\tans+=sgt1.query(1,1,m,k);\n\t\treturn ans;\n\t}\n}\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) cin>>b[i];\n\tfor(int i=1;i<n;i++) cin>>x[i]>>y[i]>>c[i]>>d[i],e[x[i]].emplace_back(y[i]),e[y[i]].emplace_back(x[i]);\n\tdfs1(1); dfs2(1);\n\tfor(int i=1;i<=n;i++) o[++nn]={0,a[i],b[i],i};\n\tfor(int i=1;i<n;i++){\n\t\tint u=x[i],v=y[i]; if(fa[u]==v) swap(u,v);\n\t\to[++nn]={1,min({c[i],outmx[v],submx[v]}),d[i],v};\n\t}\n\tsort(o+1,o+nn+1);\n\tfor(int i=1;i<=nn;i++) m=max(m,o[i].val);\n\tfor(int i=1;i<=nn;i++){\n\t\tif(!o[i].op){\n\t\t\tV++; sumV+=o[i].val;\n\t\t\tds1::ins_p(dfn[o[i].id],o[i].val);\n\t\t}\n\t\telse{\n\t\t\tE++; sumE+=o[i].val;\n\t\t\tds0::ins(o[i].val); ds1::ins_i(o[i].id);\n\t\t}\n\t\tif(i<nn&&o[i+1].k==o[i].k) continue;\n\t\tif(E>=V-1) ans=max(ans,o[i].k*(sumV+ds0::query(V-1)));\n\t\telse ans=max(ans,o[i].k*(sumE+ds1::query(E+1)));\n\t}\tcout<<ans<<'\\n';\n\treturn 0;\n}"
}