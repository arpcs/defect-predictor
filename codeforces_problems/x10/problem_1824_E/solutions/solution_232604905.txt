{
    "id": 232604905,
    "contestId": 1824,
    "creationTimeSeconds": 1699871288,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1824,
        "index": "E",
        "name": "LuoTianyi and Cartridge",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3500,
        "tags": [
            "data structures",
            "trees"
        ]
    },
    "author": {
        "contestId": 1824,
        "members": [
            {
                "handle": "luogu_bot1"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1683547500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 59,
    "timeConsumedMillis": 1450,
    "memoryConsumedBytes": 90931200,
    "source": "// LUOGU_RID: 134915158\n #include <bits/stdc++.h>\r\n\r\nnamespace std {\r\n\r\ntemplate<class Fun>\r\nclass y_combinator_result {\r\n\tFun fun_;\r\npublic:\r\n\ttemplate<class T>\r\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\r\n\r\n\ttemplate<class ...Args>\r\n\tdecltype(auto) operator()(Args &&...args) {\r\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\r\n\t}\r\n};\r\n\r\ntemplate<class Fun>\r\ndecltype(auto) y_combinator(Fun &&fun) {\r\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\r\n}\r\n\r\n} // namespace std\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\r\n\r\n\tint N; cin >> N;\r\n\tstd::vector<int> A(N);\r\n\tfor (auto& a : A) cin >> a;\r\n\tstd::vector<int> B(N);\r\n\tfor (auto& b : B) cin >> b;\r\n\r\n\tstd::vector<std::array<int, 2>> edges(N-1);\r\n\tstd::vector<int> C(N-1);\r\n\tstd::vector<int> D(N-1);\r\n\tstd::vector<std::vector<std::pair<int, int>>> adj(N);\r\n\tfor (int e = 0; e < N-1; e++) {\r\n\t\tauto& [u, v] = edges[e];\r\n\t\tcin >> u >> v; u--, v--;\r\n\t\tcin >> C[e] >> D[e];\r\n\t\tadj[u].push_back({v, e});\r\n\t\tadj[v].push_back({u, e});\r\n\t}\r\n\r\n\tstd::vector<int> dp_down(N);\r\n\tstd::y_combinator([&](auto self, int cur, int prv) -> void {\r\n\t\tdp_down[cur] = A[cur];\r\n\t\tfor (auto [nxt, e] : adj[cur]) {\r\n\t\t\tif (nxt == prv) continue;\r\n\t\t\tself(nxt, cur);\r\n\t\t\tdp_down[cur] = std::max(dp_down[cur], dp_down[nxt]);\r\n\t\t}\r\n\t})(0, -1);\r\n\tstd::vector<int> dp_up(N);\r\n\tstd::y_combinator([&](auto self, int cur, int prv) -> void {\r\n\t\tint v = A[cur];\r\n\t\tif (prv != -1) v = std::max(v, dp_up[cur]);\r\n\t\tint c1 = -1;\r\n\t\tint c2 = -1;\r\n\t\tfor (auto [nxt, e] : adj[cur]) {\r\n\t\t\tif (nxt == prv) continue;\r\n\t\t\tif (dp_down[nxt] > c1) {\r\n\t\t\t\tc2 = c1;\r\n\t\t\t\tc1 = dp_down[nxt];\r\n\t\t\t} else if (dp_down[nxt] > c2) {\r\n\t\t\t\tc2 = dp_down[nxt];\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (auto [nxt, e] : adj[cur]) {\r\n\t\t\tif (nxt == prv) continue;\r\n\t\t\tdp_up[nxt] = std::max(v, dp_down[nxt] == c1 ? c2 : c1);\r\n\t\t\tC[e] = std::min(C[e], std::min(dp_up[nxt], dp_down[nxt]));\r\n\t\t\tself(nxt, cur);\r\n\t\t}\r\n\t})(0, -1);\r\n\r\n\tstd::vector<std::pair<int, int>> evts; evts.reserve(2*N-1);\r\n\r\n\tfor (int i = 0; i < N; i++) {\r\n\t\tevts.push_back({A[i], i});\r\n\t}\r\n\t// edges come first\r\n\tfor (int e = 0; e < N-1; e++) {\r\n\t\tevts.push_back({C[e], ~e});\r\n\t}\r\n\r\n\tstd::sort(evts.begin(), evts.end());\r\n\r\n\tstd::vector<int> par(N, -1);\r\n\r\n\tint num_edges = N-1;\r\n\tint num_verts = N;\r\n\r\n\tstd::set<std::pair<int, int>> small_edges;\r\n\tstd::set<std::pair<int, int>> big_edges;\r\n\tint64_t big_edges_tot = 0;\r\n\r\n\tstd::set<std::pair<int, int>> small_verts;\r\n\tstd::set<std::pair<int, int>> big_verts;\r\n\tint64_t big_verts_tot = 0;\r\n\t\r\n\tint64_t leaf_cnt = 0;\r\n\tint64_t leaf_tot = 0;\r\n\tauto mark_leaf = [&](std::pair<int, int> l) {\r\n\t\tleaf_cnt++;\r\n\t\tleaf_tot += l.first;\r\n\t\tif (big_verts.count(l)) {\r\n\t\t\tbig_verts_tot -= l.first;\r\n\t\t\tbig_verts.erase(l);\r\n\t\t} else {\r\n\t\t\tsmall_verts.erase(l);\r\n\t\t}\r\n\t};\r\n\tauto unmark_leaf = [&](std::pair<int, int> l) {\r\n\t\tleaf_cnt--;\r\n\t\tleaf_tot -= l.first;\r\n\t\t// insert l in the right place\r\n\t\tif (big_verts.empty() || l < *big_verts.begin()) {\r\n\t\t\tsmall_verts.insert(l);\r\n\t\t} else {\r\n\t\t\tbig_verts.insert(l);\r\n\t\t\tbig_verts_tot += l.first;\r\n\t\t}\r\n\t};\r\n\r\n\tauto get_best = [&]() -> int64_t {\r\n\t\tint tgt_verts = std::min(num_edges+1, num_verts);\r\n\t\tassert(tgt_verts >= 1);\r\n\r\n\t\tint tgt_edges = tgt_verts - 1;\r\n\r\n\t\tassert(tgt_verts >= leaf_cnt);\r\n\t\twhile (int(big_verts.size()) > tgt_verts - leaf_cnt) {\r\n\t\t\tauto it = big_verts.begin();\r\n\t\t\tsmall_verts.insert(*it);\r\n\t\t\tbig_verts_tot -= it->first;\r\n\t\t\tbig_verts.erase(it);\r\n\t\t}\r\n\t\twhile (int(big_verts.size()) < tgt_verts - leaf_cnt) {\r\n\t\t\tauto it = std::prev(small_verts.end());\r\n\t\t\tbig_verts_tot += it->first;\r\n\t\t\tbig_verts.insert(*it);\r\n\t\t\tsmall_verts.erase(it);\r\n\t\t}\r\n\r\n\t\twhile (int(big_edges.size()) > tgt_edges) {\r\n\t\t\tauto it = big_edges.begin();\r\n\t\t\tsmall_edges.insert(*it);\r\n\t\t\tbig_edges_tot -= it->first;\r\n\t\t\tbig_edges.erase(it);\r\n\t\t}\r\n\t\twhile (int(big_edges.size()) < tgt_edges) {\r\n\t\t\tauto it = std::prev(small_edges.end());\r\n\t\t\tbig_edges_tot += it->first;\r\n\t\t\tbig_edges.insert(*it);\r\n\t\t\tsmall_edges.erase(it);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\tcerr << \"tgt_verts \" << tgt_verts << '\\n';\r\n\t\tcerr << \"tgt_edges \" << tgt_verts << '\\n';\r\n\t\tcerr << \"leaf_cnt \" << leaf_cnt << '\\n';\r\n\t\tcerr << \"leaf_tot \" << leaf_tot << '\\n';\r\n\t\tcerr << \"big_verts_tot \" << big_verts_tot << '\\n';\r\n\t\tcerr << \"big_edges_tot \" << big_edges_tot << '\\n';\r\n\t\t*/\r\n\t\treturn leaf_tot + big_verts_tot + big_edges_tot;\r\n\t};\r\n\r\n\r\n\tstd::vector<int> cur_deg(N);\r\n\tstd::vector<std::set<std::pair<int, int>>> comp_verts(N);\r\n\tfor (int i = 0; i < N; i++) {\r\n\t\tcur_deg[i] = int(adj[i].size());\r\n\t\tcomp_verts[i].insert({B[i], i});\r\n\t\tbig_verts.insert({B[i], i});\r\n\t\tbig_verts_tot += B[i];\r\n\t\tif (cur_deg[i] == 1) {\r\n\t\t\tmark_leaf(*comp_verts[i].rbegin());\r\n\t\t}\r\n\t}\r\n\tfor (int e = 0; e < N-1; e++) {\r\n\t\tbig_edges.insert({D[e], e});\r\n\t\tbig_edges_tot += D[e];\r\n\t}\r\n\r\n\tauto get_par = [&](int a) -> int {\r\n\t\twhile (par[a] >= 0) {\r\n\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\r\n\t\t\ta = par[a];\r\n\t\t}\r\n\t\treturn a;\r\n\t};\r\n\r\n\tauto merge = [&](int a, int b) {\r\n\t\ta = get_par(a), b = get_par(b);\r\n\t\tassert(a != b);\r\n\t\tif (par[a] > par[b]) std::swap(a, b);\r\n\t\tpar[a] += par[b];\r\n\t\tpar[b] = a;\r\n\r\n\t\tif (cur_deg[a] == 1) {\r\n\t\t\tassert(!comp_verts[a].empty());\r\n\t\t\tauto it = *comp_verts[a].rbegin();\r\n\t\t\tunmark_leaf(it);\r\n\t\t}\r\n\t\tif (cur_deg[b] == 1) {\r\n\t\t\tassert(!comp_verts[b].empty());\r\n\t\t\tauto it = *comp_verts[b].rbegin();\r\n\t\t\tunmark_leaf(it);\r\n\t\t}\r\n\r\n\t\tcur_deg[a] += cur_deg[b] - 2;\r\n\t\tfor (auto it : comp_verts[b]) {\r\n\t\t\tcomp_verts[a].insert(it);\r\n\t\t}\r\n\t\tcomp_verts[b] = {};\r\n\r\n\t\tif (cur_deg[a] == 1) {\r\n\t\t\tassert(!comp_verts[a].empty());\r\n\t\t\tauto it = *comp_verts[a].rbegin();\r\n\t\t\tmark_leaf(it);\r\n\t\t}\r\n\t};\r\n\r\n\tint64_t ans = 0;\r\n\tfor (auto [t, id] : evts) {\r\n\t\t//cerr << \"t = \" << t << '\\n';\r\n\t\tint64_t r = get_best();\r\n\t\t//cerr << \"r = \" << r << ' ' << \"cnd = \" << t * r << '\\n';\r\n\t\tans = std::max(ans, int64_t(t) * r);\r\n\r\n\t\tif (id >= 0) {\r\n\t\t\tint i = id;\r\n\t\t\t//cerr << \"erase vert \" << i << '\\n';\r\n\r\n\t\t\tnum_verts--;\r\n\r\n\t\t\tint p = get_par(i);\r\n\r\n\t\t\tif (cur_deg[p] == 1) {\r\n\t\t\t\tassert(!comp_verts[p].empty());\r\n\t\t\t\tauto it = *comp_verts[p].rbegin();\r\n\t\t\t\tunmark_leaf(it);\r\n\t\t\t}\r\n\r\n\t\t\tcomp_verts[p].erase({B[i], i});\r\n\t\t\tif (small_verts.count({B[i], i})) {\r\n\t\t\t\tsmall_verts.erase({B[i], i});\r\n\t\t\t} else {\r\n\t\t\t\tbig_verts.erase({B[i], i});\r\n\t\t\t\tbig_verts_tot -= B[i];\r\n\t\t\t}\r\n\r\n\t\t\tif (cur_deg[p] == 1) {\r\n\t\t\t\tassert(!comp_verts[p].empty());\r\n\t\t\t\tauto it = *comp_verts[p].rbegin();\r\n\t\t\t\tmark_leaf(it);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tint e = ~id;\r\n\t\t\t//cerr << \"erase edge \" << e << '\\n';\r\n\t\t\tnum_edges--;\r\n\t\t\tmerge(edges[e][0], edges[e][1]);\r\n\t\t\tif (small_edges.count({D[e], e})) {\r\n\t\t\t\tsmall_edges.erase({D[e], e});\r\n\t\t\t} else {\r\n\t\t\t\tbig_edges.erase({D[e], e});\r\n\t\t\t\tbig_edges_tot -= D[e];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << ans << '\\n';\r\n\r\n\treturn 0;\r\n}\r\n"
}