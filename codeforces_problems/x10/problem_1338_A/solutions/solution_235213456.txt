{
    "id": 235213456,
    "contestId": 1338,
    "creationTimeSeconds": 1701432001,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1338,
        "index": "A",
        "name": "Powered Addition",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1500,
        "tags": [
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1338,
        "members": [
            {
                "handle": "Rawan_Almashad"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1586700300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 27,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 409600,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define PI acos(-1)\r\n#define  ll long long\r\n#define mod 1000000007\r\n const int N = 1e5 + 5;\r\nlong long gcd(long long a,long long b)\r\n{\r\n    if(b==0)\r\n        return a;\r\n    return gcd(b,a%b);\r\n}\r\nlong long lcm(long long a,long long b)\r\n{\r\n    return a/(gcd(a,b))*b;\r\n}\r\nint checkBit(int rkm, int idx) {\r\n\treturn (rkm & (1 << idx));\r\n}\r\nint setBitOff(int rkm, int idx) {\r\n\treturn (rkm & (~(1 << idx)));\r\n}\r\nint setBitOn(int rkm, int idx) {\r\n\treturn (rkm | (1 << idx));\r\n}\r\n\r\nint flipBit(int rkm, int idx) {\r\n\treturn (rkm ^ (1 << idx));\r\n}\r\nint ok(long long arr[],int n,long long h,long long mid)\r\n{\r\n    int t=0;\r\n    long long sum=0;\r\n   for(int i=0;i<n;i++)\r\n   {\r\n       if(i!=n-1)\r\n       {\r\n           long long res=min(arr[i]+mid-1,arr[i+1]-1);\r\n           sum+=(res-arr[i]+1);\r\n       }\r\n       else\r\n       {\r\n           sum+=mid;\r\n       }\r\n   }\r\n    if(sum>=h)\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\nlong long bin(long long arr[],int n,long long h)\r\n{\r\n    long long l=0,r=1e8;\r\n    while(l<r-1)\r\n    {\r\n        long long mid=l+(r-l)/2;\r\n        if(mid*n>=h)\r\n            r=mid;\r\n        else\r\n            l=mid;\r\n    }\r\n    return r;\r\n}\r\nint lower(long long arr[],int n,long long x)\r\n{\r\n    int l=-1,r=n;\r\n    while(l<r-1)\r\n    {\r\n        int mid=l+(r-l)/2;\r\n        if(arr[mid]<=x)\r\n            l=mid;\r\n        else\r\n            r=mid;\r\n    }\r\n    return l;\r\n}\r\nint upper(long long arr[],int n,long long x)\r\n{\r\n    int l=-1,r=n;\r\n    while(l<r-1)\r\n    {\r\n        int mid=l+(r-l)/2;\r\n        if(arr[mid]>=x)\r\n            r=mid;\r\n        else\r\n            l=mid;\r\n    }\r\n    return r;\r\n}\r\nll fastPow(ll base, ll power /*, ll m*/) { // O(log[power])\r\n  ll ans = 1;\r\n  while (power) {\r\n    if (power & 1)\r\n      ans = (ans * base); // if we have mod => ans = (ans * base) % m\r\n    base = (base * base); // base = (base * base) % m\r\n    power >>= 1;\r\n  }\r\n  return ans;\r\n}\r\nlong long  addmod(long long a,long long b)\r\n{\r\n    return (a%mod + b%mod)%mod;\r\n}\r\n/*bool isprime(long long n)\r\n{\r\n    for(long long i=2;i*i<=n;i++)\r\n    {\r\n        if(n%i==0)\r\n            return 0;\r\n    }\r\n    return 1;\r\n}*/\r\n\r\nint isprime(int n)\r\n{\r\n    if(n==0||n==1)\r\n        return 0;\r\n    for(int i=2;i*i<=n;i++)\r\n    {\r\n           if(n%i==0)\r\n            return 0;\r\n    }\r\n    return 1;\r\n}\r\n//\r\nint MOD(int a)\r\n{\r\n    int res = a % mod;\r\n    if(res < 0) {\r\n        return res + mod;\r\n    }\r\n    return res;\r\n}\r\nint mul_mod(int a, int b)\r\n{\r\n    ll res = ((ll)a * (ll)b) % mod;\r\n    return MOD((int)res);\r\n}\r\nint pow_mod(int a, int b)\r\n{\r\n    ll res = 1;\r\n    while (b > 0) {\r\n        if(b & 1) {\r\n            res = res*(ll)a%(ll)mod;\r\n        }\r\n        a=mul_mod(a, a);\r\n        b>>=1;\r\n    }\r\n    return (int)res;\r\n}\r\nint inv_mod(int a)\r\n{\r\n    return pow_mod(a, mod-2);\r\n}\r\nint div_mod(int a, int b)\r\n{\r\n    return mul_mod(a, inv_mod(b));\r\n}\r\n//   a = (a%n + n)%n ==>positive\r\nint power(int x, int y, int p)\r\n{\r\n\r\n    // Initialize answer\r\n    int res = 1;\r\n\r\n    // Check till the number becomes zero\r\n    while (y > 0) {\r\n\r\n        // If y is odd, multiply x with result\r\n        if (y % 2 == 1)\r\n            res = (res * x);\r\n\r\n        // y = y/2\r\n        y = y >> 1;\r\n\r\n        // Change x to x^2\r\n        x = (x * x);\r\n    }\r\n    return res % p;\r\n}\r\nint binarysearch(int arr[],int l,int r,int x)\r\n{\r\n    if(l>r)\r\n        return -1;\r\n    int mid=l+(r-l)/2;\r\n    if(arr[mid]==x)\r\n        return mid+1;\r\n    else if(arr[mid]>x)\r\n        return binarysearch(arr,l,mid-1,x);\r\n    else\r\n        return binarysearch(arr,mid+1,r,x);\r\n}\r\nint fact(int n)\r\n{\r\n    int f;\r\n    if(n>1)\r\n        f=n*fact(n-1);\r\n    else\r\n        f=1;\r\n    return f;\r\n}\r\n int searcho(int target, int first, int last,int a[])\r\n {\r\n int location = -1; // not found\r\n if (first <= last) // range is not empty\r\n {\r\n int mid = (first + last)/2;\r\n if (target == a[mid])\r\n location = mid;\r\n else if (target < a[mid]) // first half\r\n location = searcho(target, first, mid - 1,a);\r\n else //(target > a[mid]) second half\r\n location = searcho(target, mid + 1, last,a);\r\n }\r\n\r\n return location;\r\n }\r\n /*int solve(int idx)\r\n {\r\n     if(idx==n-1)\r\n        return 0;\r\n       if(idx>n-1)\r\n        return 3e9;\r\n       ll &ret=dp[idx];\r\n       if(ret!=1e15)\r\n        return ret;\r\n      for(int i=idx+1;i<=idx+k;i++)\r\n      {\r\n          ret=min(ret,abs(arr[idx]-arr[i])+solve(i));\r\n          cout<<idx<<\" \";\r\n          cout<<abs(arr[idx]-arr[i])+solve(i)<<\" \";\r\n          cout<<\"\\n\";\r\n      }\r\n      return ret;\r\n}*/\r\n/*int rawan(int cur,int idx)\r\n{\r\n    if(idx==n)\r\n    {\r\n    if(cur==0)\r\n    return 1;\r\n    else\r\n    return 0;\r\n    }\r\n    int &ret=dp[cur][idx];\r\n    if(~ret)\r\n        return ret;\r\n    return ret=rawan(((cur+arr[idx]%k+k)%k),idx+1)|rawan(((cur-arr[idx]%k+k)%k),idx+1);\r\n}*/\r\n\r\n /*\r\n\r\nll solve(int i,int pre)\r\n{\r\n if(i==n)\r\n    return 0;\r\n ll &ret=dp[i][pre];\r\n if(~ret)\r\n    return ret;\r\nif(arr[i]==0||arr[i]==pre)\r\n return ret=solve(i+1,0)+1;\r\nelse if(arr[i]!=3)\r\n{\r\n   return ret=solve(i+1,arr[i]);\r\n}\r\nelse\r\n{\r\n  if(pre==2)\r\n      return ret=solve(i+1,1);\r\n  else if(pre==1)\r\n   return ret=solve(i+1,2);\r\n  else\r\n    return ret=min(solve(i,1),solve(i,2));\r\n}\r\n}\r\n*//*\r\nll solve(int idx,int right)\r\n{\r\n   if(idx==n)\r\n        return 0;\r\n        ll &ret=dp[idx][right];\r\n        if(~ret)\r\n            return ret;\r\n    int prepos=x[idx-1]+(right*h[idx-1]);\r\n    if(x[idx]-h[idx]>prepos)\r\n        ret=max(ret,solve(idx+1,0)+1);\r\n    if(x[idx]+h[idx]<x[idx+1])\r\n        ret=max(ret,solve(idx+1,1)+1);\r\n    return ret=max(ret,solve(idx+1,0));\r\n\r\n}\r\nint rawan(int idx,int s,int arr[])\r\n{\r\n    if(idx==n)\r\n    {\r\n        if(s==m)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n    if(s>m)\r\n        return 0;\r\n    return(rawan(idx,s+arr[idx],arr)+rawan(idx+1,s,arr));\r\n}\r\nint rawoona(int idx,int pre)\r\n{\r\n    if(idx==n)\r\n        return 0;\r\n        ll &ret=dp[idx][pre];\r\n        if(~ret)\r\n            return ret;\r\n        int pick=rawoona(idx+1,pre);\r\n        int leave=0;\r\n        if(arr[pre]<=arr[idx])\r\n            leave=rawoona(idx+1,idx)+1;\r\n        return ret=max(pick,leave);\r\n\r\n}\r\nvoid maxi(int idx,string temp)\r\n{\r\n    cout<<temp<<\"\\n\";\r\n    if(idx==n)\r\n    {\r\n        for(int i=0;i<temp.size()/2;i++)\r\n        {\r\n            if(temp[i]!=temp[n-i-1]);\r\n            return ;\r\n        }\r\n        if(temp.size()!=0)\r\n        cout<<\"YES\"<<\"\\n\";\r\n        else\r\n            return ;\r\n    }\r\n    maxi(idx+1,temp);\r\n    maxi(idx+1,temp+s[idx]);\r\n}\r\nbool cmp(pair<ll,ll> a, pair<ll,ll> b) { return a.second < b.second; }\r\n*/\r\n/*\r\nint lcs(int i,int j)\r\n{\r\n    if(i==0||j==0){\r\n        return 0;\r\n    }\r\n        int &ret=dp[i][j];\r\n        if(~ret)\r\n            return ret;\r\n    if(s[i-1]==t[j-1])\r\n    {\r\n        return dp[i][j]=1+lcs(i-1,j-1);\r\n    }\r\n    else\r\n    {\r\n        return dp[i][j]=max(lcs(i-1,j),lcs(i,j-1));\r\n    }\r\n}\r\nvoid print(int i,int j)\r\n{\r\n     if(i<=0||j<=0){\r\n        return ;\r\n    }\r\n    int ret=dp[i][j];\r\n    if(s[i-1]==t[j-1])\r\n    {\r\n       ans+=s[i-1];\r\n        print(i-1,j-1);\r\n        return ;\r\n    }\r\n     if(ret==lcs(i,j-1))\r\n    {\r\n    print(i,j-1);\r\n    return;\r\n    }\r\n  if(ret==lcs(i-1,j)){\r\n        print(i-1,j);\r\n   return ;\r\n  }\r\n}*//*\r\nint dp[51][4][51][3][2006];\r\nint n,s,k;\r\nint a[57];\r\nint c[57];\r\nint solve(ll idx,ll precol,ll prenum,ll left,ll sum)\r\n{\r\n  if(idx==n||idx<0)\r\n    return 1e9;\r\n  int &ret=dp[idx][precol][prenum][left][sum];\r\n   if(~ret)\r\n    return ret;\r\n    ret=1e9;\r\n   if(left)\r\n   {\r\n      ret=min(ret,solve(idx-1,precol,prenum,1,sum)+1);\r\n   }\r\n   if(left!=1)\r\n   {\r\n       ret=min(ret,solve(idx+1,precol,prenum,0,sum)+1);\r\n   }\r\n   if(a[idx]>prenum&&precol!=c[idx])\r\n   {\r\n       ll t=a[idx]+sum;\r\n       if(t>=k)\r\n        return ret=0;\r\n       ret=min(ret,solve(idx-1,c[idx],a[idx],1,sum+a[idx])+1);\r\n       ret=min(ret,solve(idx+1,c[idx],a[idx],0,sum+a[idx])+1);\r\n   }\r\n   return ret;\r\n}*//*\r\nint n,m;\r\nll dp[305][10005]={0};\r\nint arr[305];\r\nll solve(int i,int s)\r\n{\r\nif(i==n)\r\n    return 0;\r\n    ll &ret=dp[i][s];\r\n    if(~ret)\r\n        return ret;\r\n    if(s-arr[i]>=0)\r\n ret=max(solve(i+1,s-arr[i])+arr[i],ret);\r\nret=max(solve(i+1,s),ret);\r\nreturn ret;\r\n}*/\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\r\n // freopen(\"king2.in\", \"r\", stdin);\r\n // freopen(\"king2.out\", \"w\", stdout);\r\nint t;\r\ncin>>t;\r\nwhile(t--)\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    int maxi=-2e9;\r\n    int maxdif=-2e9;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n        maxi=max(maxi,arr[i]);\r\n        if(arr[i]<maxi)\r\n        {\r\n            maxdif=max(maxdif,maxi-arr[i]);\r\n        }\r\n    }\r\n    ll sum=0;\r\n    if(maxdif==-2e9)\r\n    {\r\n        cout<<\"0\"<<\"\\n\";\r\n        continue;\r\n    }\r\n    for(int i=0;i<=31;i++)\r\n    {\r\n        sum+=(1<<i);\r\n        if(sum>=maxdif)\r\n        {\r\n            cout<<i+1<<\"\\n\";\r\n            break;\r\n        }\r\n    }\r\n}\r\n}\r\n"
}