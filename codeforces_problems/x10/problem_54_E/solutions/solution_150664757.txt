{
    "id": 150664757,
    "contestId": 54,
    "creationTimeSeconds": 1648093519,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 54,
        "index": "E",
        "name": "Vacuum \u0421leaner",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2700,
        "tags": [
            "geometry"
        ]
    },
    "author": {
        "contestId": 54,
        "members": [
            {
                "handle": "marx97"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1294733700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 104,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 1638400,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nusing _T=double; //long long\r\n\r\nconstexpr _T eps=1e-8;\r\nconstexpr long double PI=3.1415926535897932384l;\r\n\r\ntemplate<typename T> struct point\r\n{\r\n    T x,y;\r\n\r\n    point()=default;\r\n    point(double x,double y): x(x),y(y) {}\r\n    bool operator==(const point &a) const {return (abs(x-a.x)<=eps && abs(y-a.y)<=eps);}\r\n    bool operator<(const point &a) const {if (abs(x-a.x)<=eps) return y<a.y-eps; return x<a.x-eps;}\r\n    bool operator>(const point &a) const {return !(*this<a || *this==a);}\r\n    point operator+(const point &a) const {return {x+a.x,y+a.y};}\r\n    point operator-(const point &a) const {return {x-a.x,y-a.y};}\r\n    point operator-() const {return {-x,-y};}\r\n    point operator*(const T k) const {return {k*x,k*y};}\r\n    point operator/(const T k) const {return {x/k,y/k};}\r\n    T operator*(const point &a) const {return x*a.x+y*a.y;}\r\n    T operator^(const point &a) const {return x*a.y-y*a.x;}\r\n    int toleft(const point &a) const {const auto t=(*this)^a; return (t>eps)-(t<-eps);}\r\n    T len2() const {return (*this)*(*this);}\r\n    T dis2(const point &a) const {return (a-(*this)).len2();}\r\n    double len() const {return sqrt(len2());}\r\n    double dis(const point &a) const {return sqrt(dis2(a));}\r\n    double ang(const point &a) const {return acos(max(-1.0,min(1.0,((*this)*a)/(len()*a.len()))));}\r\n    point rot(const double rad) const {return {x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)};}\r\n    point rot(const double cosr,const double sinr) const {return {x*cosr-y*sinr,x*sinr+y*cosr};}\r\n};\r\n\r\nusing Point=point<_T>;\r\n\r\nstruct argcmp\r\n{\r\n    bool operator()(const Point &a,const Point &b) const\r\n    {\r\n        const auto quad=[](const Point &a)\r\n        {\r\n            if (a.y<-eps) return 1;\r\n            if (a.y>eps) return 4;\r\n            if (a.x<-eps) return 5;\r\n            if (a.x>eps) return 3;\r\n            return 2;\r\n        };\r\n        const int qa=quad(a),qb=quad(b);\r\n        if (qa!=qb) return qa<qb;\r\n        const auto t=a^b;\r\n        //if (abs(t)<=eps) return a*a<b*b-eps;\r\n        return t>eps;\r\n    }\r\n};\r\n\r\ntemplate<typename T> struct line\r\n{\r\n    point<T> p,v;\r\n\r\n    bool operator==(const line &a) const {return v.toleft(a.v)==0 && v.toleft(p-a.p)==0;}\r\n    int toleft(const point<T> &a) const {return v.toleft(a-p);}\r\n    point<T> inter(const line &a) const {return p+v*((a.v^(p-a.p))/(v^a.v));}\r\n    double dis(const point<T> &a) const {return abs(v^(a-p))/v.len();}\r\n    point<T> proj(const point<T> &a) const {return p+v*((v*(a-p))/(v*v));}\r\n    bool operator<(const line &a) const\r\n    {\r\n        if (abs(v^a.v)<=eps && v*a.v>=-eps) return toleft(a.p)==-1;\r\n        return argcmp()(v,a.v);\r\n    }\r\n};\r\n\r\nusing Line=line<_T>;\r\n\r\ntemplate<typename T> struct segment\r\n{\r\n    point<T> a,b;\r\n\r\n    int is_on(const point<T> &p) const\r\n    {\r\n        if (p==a || p==b) return -1;\r\n        return (p-a).toleft(p-b)==0 && (p-a)*(p-b)<-eps;\r\n    }\r\n\r\n    int is_inter(const line<T> &l) const\r\n    {\r\n        if (l.toleft(a)==0 || l.toleft(b)==0) return -1;\r\n        return l.toleft(a)!=l.toleft(b);\r\n    }\r\n    \r\n    int is_inter(const segment<T> &s) const\r\n    {\r\n        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;\r\n        const line<T> l{a,b-a},ls{s.a,s.b-s.a};\r\n        return l.toleft(s.a)*l.toleft(s.b)==-1 && ls.toleft(a)*ls.toleft(b)==-1;\r\n    }\r\n\r\n    double dis(const point<T> &p) const\r\n    {\r\n        if ((p-a)*(b-a)<-eps || (p-b)*(a-b)<-eps) return min(p.dis(a),p.dis(b));\r\n        const line<T> l{a,b-a};\r\n        return l.dis(p);\r\n    }\r\n\r\n    double dis(const segment<T> &s) const\r\n    {\r\n        if (is_inter(s)) return 0;\r\n        return min({dis(s.a),dis(s.b),s.dis(a),s.dis(b)});\r\n    }\r\n};\r\n\r\nusing Segment=segment<_T>;\r\n\r\ntemplate<typename T> struct polygon\r\n{\r\n    vector<point<T>> p;\r\n    \r\n    size_t nxt(const size_t i) const {return i==p.size()-1?0:i+1;}\r\n    size_t pre(const size_t i) const {return i==0?p.size()-1:i-1;}\r\n\r\n    pair<bool,int> winding(const point<T> &a) const\r\n    {\r\n        int cnt=0;\r\n        for (size_t i=0;i<p.size();i++)\r\n        {\r\n            point<T> u=p[i],v=p[nxt(i)];\r\n            if (abs((a-u)^(a-v))<=eps && (a-u)*(a-v)<=eps) return {true,0};\r\n            if (abs(u.y-v.y)<=eps) continue;\r\n            const Line uv={u,v-u};\r\n            if (u.y<v.y-eps && uv.toleft(a)<=0) continue;\r\n            if (u.y>v.y+eps && uv.toleft(a)>=0) continue;\r\n            if (u.y<a.y-eps && v.y>=a.y-eps) cnt++;\r\n            if (u.y>=a.y-eps && v.y<a.y-eps) cnt--;\r\n        }\r\n        return {false,cnt};\r\n    }\r\n\r\n    double circ() const\r\n    {\r\n        double sum=0;\r\n        for (size_t i=0;i<p.size();i++) sum+=p[i].dis(p[nxt(i)]);\r\n        return sum;\r\n    }\r\n\r\n    T area() const\r\n    {\r\n        T sum=0;\r\n        for (size_t i=0;i<p.size();i++) sum+=p[i]^p[nxt(i)];\r\n        return sum;\r\n    }\r\n};\r\n\r\nusing Polygon=polygon<_T>;\r\n\r\ntemplate<typename T> struct convex: polygon<T>\r\n{\r\n    convex operator+(const convex &c) const\r\n    {\r\n        const auto &p=this->p;\r\n        vector<Segment> e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());\r\n        vector<point<T>> res; res.reserve(p.size()+c.p.size());\r\n        const auto cmp=[](const Segment &u,const Segment &v) {return argcmp()(u.b-u.a,v.b-v.a);};\r\n        for (size_t i=0;i<p.size();i++) e1[i]={p[i],p[this->nxt(i)]};\r\n        for (size_t i=0;i<c.p.size();i++) e2[i]={c.p[i],c.p[c.nxt(i)]};\r\n        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());\r\n        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());\r\n        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);\r\n        const auto check=[](const vector<point<T>> &res,const point<T> &u)\r\n        {\r\n            const auto back1=res.back(),back2=*prev(res.end(),2);\r\n            return (back1-back2).toleft(u-back1)==0 && (back1-back2)*(u-back1)>=-eps;\r\n        };\r\n        auto u=e1[0].a+e2[0].a;\r\n        for (const auto &v:edge)\r\n        {\r\n            while (res.size()>1 && check(res,u)) res.pop_back();\r\n            res.push_back(u);\r\n            u=u+v.b-v.a;\r\n        }\r\n        if (res.size()>1 && check(res,res[0])) res.pop_back();\r\n        convex ans;\r\n        ans.p = res;\r\n        return ans;\r\n    }\r\n\r\n    template<typename F> void rotcaliper(const F &func) const\r\n    {\r\n        const auto &p=this->p;\r\n        const auto area=[](const point<T> &u,const point<T> &v,const point<T> &w){return abs((w-u)^(w-v));};\r\n        for (size_t i=0,j=1;i<p.size();i++)\r\n        {\r\n            const auto nxti=this->nxt(i);\r\n            func(p[i],p[nxti],p[j]);\r\n            while (area(p[this->nxt(j)],p[i],p[nxti])>=area(p[j],p[i],p[nxti]))\r\n            {\r\n                j=this->nxt(j);\r\n                func(p[i],p[nxti],p[j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    T diameter2() const\r\n    {\r\n        const auto &p=this->p;\r\n        if (p.size()==1) return 0;\r\n        if (p.size()==2) return p[0].dis2(p[1]);\r\n        T ans=0;\r\n        auto func=[&](const point<T> &u,const point<T> &v,const point<T> &w){ans=max({ans,w.dis2(u),w.dis2(v)});};\r\n        rotcaliper(func);\r\n        return ans;\r\n    }\r\n\r\n    vector<T> sum;\r\n\r\n    void get_sum()\r\n    {\r\n        const auto &p=this->p;\r\n        vector<T> a(p.size());\r\n        for (size_t i=0;i<p.size();i++) a[i]=p[this->pre(i)]^p[i];\r\n        sum.resize(p.size());\r\n        partial_sum(a.begin(),a.end(),sum.begin());\r\n    }\r\n\r\n    T query_sum(const size_t l,const size_t r) const\r\n    {\r\n        const auto &p=this->p;\r\n        if (l<=r) return sum[r]-sum[l]+(p[r]^p[l]);\r\n        return sum[p.size()-1]-sum[l]+sum[r]+(p[r]^p[l]);\r\n    }\r\n    T query_sum() const {return sum.back();}\r\n    \r\n    int is_in(const point<T> &a) const\r\n    {\r\n        const auto &p=this->p;\r\n        if (p.size()==1) return a==p[0]?-1:0;\r\n        if (p.size()==2) return segment<T>{p[0],p[1]}.is_on(a)?-1:0; \r\n        if (a==p[0]) return -1;\r\n        if ((p[1]-p[0]).toleft(a-p[0])==-1 || (p.back()-p[0]).toleft(a-p[0])==1) return 0;\r\n        const auto cmp=[&](const Point &u,const Point &v){return (u-p[0]).toleft(v-p[0])==1;};\r\n        const size_t i=lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();\r\n        if (i==1) return segment<T>{p[0],p[i]}.is_on(a)?-1:0;\r\n        if (i==p.size()-1 && segment<T>{p[0],p[i]}.is_on(a)) return -1;\r\n        if (segment<T>{p[i-1],p[i]}.is_on(a)) return -1;\r\n        return (p[i]-p[i-1]).toleft(a-p[i-1])>0;\r\n    }\r\n\r\n    template<typename F> size_t extreme(const F &dir) const\r\n    {\r\n        const auto &p=this->p;\r\n        const auto check=[&](const size_t i){return dir(p[i]).toleft(p[this->nxt(i)]-p[i])>=0;};\r\n        const auto dir0=dir(p[0]); const auto check0=check(0);\r\n        if (!check0 && check(p.size()-1)) return 0;\r\n        const auto cmp=[&](const Point &v)\r\n        {\r\n            const size_t vi=&v-p.data();\r\n            const auto checkv=check(vi);\r\n            const auto t=dir0.toleft(v-p[0]);\r\n            return checkv^(checkv==check0 && ((!check0 && t<=0) || (check0 && t<0)));\r\n        };\r\n        return partition_point(p.begin(),p.end(),cmp)-p.begin();\r\n    }\r\n\r\n    pair<size_t,size_t> tangent(const point<T> &a) const //!is_in(a)\r\n    {\r\n        const size_t i=extreme([&](const point<T> &u){return u-a;});\r\n        const size_t j=extreme([&](const point<T> &u){return a-u;});\r\n        return {i,j};\r\n    }\r\n\r\n    pair<size_t,size_t> tangent(const line<T> &a) const\r\n    {\r\n        const size_t i=extreme([&](...){return a.v;});\r\n        const size_t j=extreme([&](...){return -a.v;});\r\n        return {i,j};\r\n    }\r\n};\r\n\r\nusing Convex=convex<_T>;\r\n\r\nConvex convexhull(vector<Point> p)\r\n{\r\n    vector<Point> st;\r\n    sort(p.begin(),p.end());\r\n    const auto check=[](const vector<Point> &st,const Point &u)\r\n    {\r\n        const auto back1=st.back(),back2=*prev(st.end(),2);\r\n        return (back1-back2).toleft(u-back2)<=0;\r\n    };\r\n    for (const Point &u:p)\r\n    {\r\n        while (st.size()>1 && check(st,u)) st.pop_back();\r\n        st.push_back(u);\r\n    }\r\n    size_t k=st.size();\r\n    p.pop_back(); reverse(p.begin(),p.end());\r\n    for (const Point &u:p)\r\n    {\r\n        while (st.size()>k && check(st,u)) st.pop_back();\r\n        st.push_back(u);\r\n    }\r\n    st.pop_back();\r\n    Convex ans;\r\n    ans.p = st;\r\n    return ans;\r\n}\r\n\r\nvector<Line> _halfinter(vector<Line> l, const _T lim)\r\n{\r\n    const auto check=[](const Line &a,const Line &b,const Line &c){return a.toleft(b.inter(c))<0;};\r\n    /*const auto check=[](const Line &a,const Line &b,const Line &c)\r\n    {\r\n        const Point p=a.v*(b.v^c.v),q=b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);\r\n        return p.toleft(q)<0;\r\n    };*/\r\n    l.push_back({{-lim,0},{0,-1}}); l.push_back({{0,-lim},{1,0}});\r\n    l.push_back({{lim,0},{0,1}}); l.push_back({{0,lim},{-1,0}});\r\n    sort(l.begin(),l.end());\r\n    deque<Line> q;\r\n    for (size_t i=0;i<l.size();i++)\r\n    {\r\n        if (i>0 && l[i-1].v.toleft(l[i].v)==0 && l[i-1].v*l[i].v>eps) continue;\r\n        while (q.size()>1 && check(l[i],q.back(),q[q.size()-2])) q.pop_back();\r\n        while (q.size()>1 && check(l[i],q[0],q[1])) q.pop_front();\r\n        if (!q.empty() && q.back().v.toleft(l[i].v)<=0) return vector<Line>();\r\n        q.push_back(l[i]);\r\n    }\r\n    while (q.size()>1 && check(q[0],q.back(),q[q.size()-2])) q.pop_back();\r\n    while (q.size()>1 && check(q.back(),q[0],q[1])) q.pop_front();\r\n    return vector<Line>(q.begin(),q.end());\r\n}\r\n\r\nConvex halfinter(const vector<Line> &l, const _T lim)\r\n{\r\n    const auto lines=_halfinter(l,lim);\r\n    Convex poly; poly.p.resize(lines.size());\r\n    if (lines.empty()) return poly;\r\n    for (size_t i=0;i<lines.size();i++)\r\n    {\r\n        const size_t j=(i==lines.size()-1?0:i+1);\r\n        poly.p[i]=lines[i].inter(lines[j]);\r\n    }   \r\n    poly.p.erase(unique(poly.p.begin(),poly.p.end()),poly.p.end());\r\n    if (poly.p.front()==poly.p.back()) poly.p.pop_back();\r\n    return poly;\r\n}\r\n\r\nint n;\r\ndouble ans = 1e12;\r\nvoid rotcaliper(Convex &a)\r\n{\r\n    for (int i=0,j=1,l=-1,r=-1;i<(int)a.p.size();i++)\r\n    {\r\n        while (((a.p[a.nxt(j)]-a.p[i])^(a.p[a.nxt(j)]-a.p[a.nxt(i)]))\r\n        >((a.p[j]-a.p[i])^(a.p[j]-a.p[a.nxt(i)]))) j=a.nxt(j);\r\n        if (l==-1) l=i,r=j;\r\n        Point v(a.p[a.nxt(i)]-a.p[i]);\r\n        v=Point(-v.y,v.x);\r\n        while (v.toleft(a.p[a.nxt(l)]-a.p[l])<=0) l=a.nxt(l);\r\n        while (v.toleft(a.p[a.nxt(r)]-a.p[r])>=0) r=a.nxt(r);\r\n        Line li{a.p[i],a.p[a.nxt(i)]-a.p[i]},lj{a.p[j],a.p[i]-a.p[a.nxt(i)]};\r\n        Line ll{a.p[l],v},lr{a.p[r],v};\r\n        vector<Point> t={li.inter(ll),ll.inter(lj),lj.inter(lr),lr.inter(li)};\r\n        ans = min(ans, fabs((a.p[i]-t[0])^(a.p[l]-t[0]))-a.query_sum(i, l));\r\n        ans = min(ans, fabs((a.p[r]-t[3])^(a.p[i]-t[3]))-a.query_sum(r, i));\r\n        ans = min(ans, fabs((a.p[j]-t[2])^(a.p[r]-t[2]))-a.query_sum(j, r));\r\n        ans = min(ans, fabs((a.p[l]-t[1])^(a.p[j]-t[1]))-a.query_sum(l, j));\r\n    }\r\n}\r\nint main(){\r\n    cin >> n;\r\n    vector<Point> p(n);\r\n    for(int i = 0;i < n;i ++) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\r\n    Line v = {p[0], p[1]-p[0]};\r\n    if(v.toleft(p[2]) == -1) reverse(p.begin(), p.end());\r\n    Convex poly;\r\n    poly.p = p;\r\n    poly.get_sum();\r\n    rotcaliper(poly);\r\n    cout << fixed << setprecision(12) << ans/2 << '\\n';\r\n    return 0;\r\n}"
}