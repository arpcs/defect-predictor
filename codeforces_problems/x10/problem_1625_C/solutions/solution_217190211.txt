{
    "id": 217190211,
    "contestId": 1625,
    "creationTimeSeconds": 1691203606,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1625,
        "index": "C",
        "name": "Road Optimization",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "dp"
        ]
    },
    "author": {
        "contestId": 1625,
        "members": [
            {
                "handle": "aureliony"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1641989100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 36,
    "timeConsumedMillis": 249,
    "memoryConsumedBytes": 2048000,
    "source": "// #define ONLINE_JUDGE 1\r\n#ifdef ONLINE_JUDGE\r\n#pragma GCC optimize(\"O3\")\r\n#pragma GCC target(\"avx2\")\r\n#endif\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n// template<class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n// #define endl '\\n'\r\n#define INF32 (0x3f3f3f3f)\r\n#define INF64 (0x3f3f3f3f3f3f3f3fLL)\r\n#define INF (INF32)\r\n#define PI (3.14159265358979323846)\r\n#define EPS (1e-11)\r\n#define typeof(x) remove_reference<decltype(x)>::type\r\n#define _picktype(a,b) common_type<typeof(a),typeof(b)>::type\r\n#define rep(i,a,b) for(_picktype((a),(b)) i=(a); (a)<(b) ? i<(b) : i>(b); (a)<(b) ? i++:i--)\r\n#define fori(a,b) rep(i,(a),(b))\r\n#define forj(a,b) rep(j,(a),(b))\r\n#define fork(a,b) rep(k,(a),(b))\r\n#define forl(a,b) rep(l,(a),(b))\r\n#define forit(a,b) for(auto it=(a); it!=(b); it++)\r\n#define rforit(a,b) for(auto it=(a); it!=(b); it--)\r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define mset(a,b) memset(a,b,sizeof(a))\r\n#define fi first\r\n#define se second\r\n#define mp make_pair\r\n#define pb push_back\r\n#define pf push_front\r\nusing uint = unsigned int;\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing vi = vector<int>;\r\nusing vii = vector<pii>;\r\nusing vll = vector<ll>;\r\nusing vpll = vector<pll>;\r\n#ifdef _WIN32\r\n#define getchar _getchar_nolock\r\n#define putchar _putchar_nolock\r\n#else\r\n#define getchar getchar_unlocked\r\n#define putchar putchar_unlocked\r\n#endif\r\ntemplate<class T> void getInteger(T& x) { int ch; do { ch = getchar(); } while (ch != '-' && (ch < '0' || ch > '9')); bool neg = ch == '-'; if (neg) ch = getchar(); while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); if (neg) x = -x; }\r\nint getint() { int x = 0; getInteger(x); return x; }\r\nll getll() { ll x = 0; getInteger(x); return x; }\r\nint gi() { return getint(); }\r\nll gll() { return getll(); }\r\nstring getstr() { string s; int ch; do { ch = getchar(); } while (ch < '!' || ch > '~'); while (ch >= '!' && ch <= '~') s.pb(ch), ch = getchar(); return s; }\r\nstring getline() { string s; int ch; do { ch = getchar(); } while (ch < ' ' || ch > '~'); while (ch >= ' ' && ch <= '~') s.pb(ch), ch = getchar(); return s; }\r\ndouble getdouble() { return stod(getstr()); }\r\nvoid put(string s, bool nl = true) { for (char c : s) putchar(c); if (nl) putchar('\\n'); }\r\nvoid put(char c, bool nl = true) { putchar(c); if (nl) putchar('\\n'); }\r\nchar _digits[20];\r\nvoid put(int n, bool nl = true) {\r\n    if (n < 0) putchar('-'), n = -n;\r\n    int i=0;\r\n    do _digits[i++] = n%10; while(n/=10);\r\n    while (i--) putchar(_digits[i] + 48);\r\n    if (nl) putchar('\\n');\r\n}\r\nvoid put(size_t n, bool nl = true) {\r\n    put((int)n, nl);\r\n}\r\nvoid put(ll n, bool nl = true) {\r\n    if (n < 0) putchar('-'), n = -n;\r\n    int i=0;\r\n    do _digits[i++] = n%10; while(n/=10);\r\n    while (i--) putchar(_digits[i] + 48);\r\n    if (nl) putchar('\\n');\r\n}\r\nvoid put(vector<int>& v) { \r\n    fori(0, v.size()-1){put(v[i],false);putchar(' ');}\r\n    put(v.back());\r\n}\r\nvoid put(vector<ll>& v) { \r\n    fori(0, v.size()-1){put(v[i],false);putchar(' ');}\r\n    put(v.back());\r\n}\r\nbool eq(double a, double b) {\r\n    return abs(a-b) <= (1e-9);\r\n}\r\nstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\nstruct CustomHash { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } size_t operator()(uint64_t x) const { return splitmix64(x + FIXED_RANDOM); } size_t operator()(pair<uint64_t,uint64_t> x) const { return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1); } };\r\nstruct DSU {\r\n    vector<int> par;\r\n    DSU(int n) { par.resize(n, -1); }\r\n    int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\r\n    int root(int x) { return find(x); }\r\n    bool conn(int x, int y) { return find(x) == find(y); }\r\n    void merge(int x, int y)\r\n    {\r\n        if ((x = find(x)) == (y = find(y)))\r\n            return;\r\n        if (par[y] < par[x])\r\n            swap(x, y);\r\n        par[x] += par[y];\r\n        par[y] = x;\r\n    }\r\n    void setpar(int x, int y) {\r\n        // set parent of x to y\r\n        if ((x = find(x)) == (y = find(y)))\r\n            return;\r\n        par[y] += par[x];\r\n        par[x] = y;\r\n    }\r\n};\r\n// vector<bool> sieve(ll maxprime) {\r\n//     if (maxprime == 1) return vector<bool>(2,0);\r\n//     vector<bool> prime(maxprime+1, 1);\r\n//     prime[0] = 0;\r\n//     prime[1] = 0;\r\n//     ll p = 2;\r\n//     prime[p] = 1;\r\n//     while (p*p <= maxprime) {\r\n//         if (prime[p]) {\r\n//             for (ll e = p+p; e <= maxprime; e += p) {\r\n//                 prime[e] = 0;\r\n//             }\r\n//         }\r\n//         p++;\r\n//     }\r\n//     return prime;\r\n// }\r\n \r\n// vector<bool> segmented_sieve(ll l, ll r) {\r\n//     ll n = (ll)(sqrt((ll)(r+1)))+1;\r\n//     vector<bool> prime = sieve(n);\r\n//     vector<bool> isPrime(r-l+1, 1);\r\n//     if (l == 0) {\r\n//         isPrime[0] = 0;\r\n//         isPrime[1] = 0;\r\n//     }\r\n//     if (l == 1) isPrime[0] = 0;\r\n//     fori(0,prime.size()) {\r\n//         if (!prime[i]) continue;\r\n//         for (ll j = max(i*i, (l+i-1)/i*i); j <= r; j += i)\r\n//             isPrime[j-l] = 0;\r\n//     }\r\n//     return isPrime;\r\n// }\r\n// struct Node {\r\n//     int a, b, c;\r\n//     Node(int a, int b, int c) : a(a), b(b), c(c) {}\r\n//     bool operator<(const Node& node) const {\r\n//         if (a != node.a) return a < node.a;\r\n//         if (b != node.b) return b < node.b;\r\n//         return c < node.c;\r\n//     }\r\n \r\n//     friend ostream& operator<<(ostream& out, const Node& node);\r\n// };\r\n// ostream& operator<<(ostream& out, const Node& node) {\r\n//     out << node.a << \" \" << node.b << \" \" << node.c << endl;\r\n//     return out;\r\n// }\r\nvoid impossible() { put(\"rehash necessary\"); exit(0); }\r\n \r\nstruct BIT {\r\n    int n;\r\n    vll B1, B2;\r\n    BIT(int n) {\r\n        this->n = n;\r\n        B1.resize(n+1, 0);\r\n        B2.resize(n+1, 0);\r\n    }\r\n    BIT(vll v) {\r\n        int n = v.size();\r\n        this->n = n;\r\n        B1.resize(n+1, 0);\r\n        B2.resize(n+1, 0);\r\n        fori(0,n) update(i, v[i]);\r\n    }\r\n    void _add(vll& B, int idx, ll x) {\r\n        for(++idx; idx <= n; idx += idx & -idx) B[idx] += x;\r\n    }\r\n    void update(int i, ll x) {\r\n        update(i, i, x);\r\n    }\r\n    void update(int l, int r, ll x) {\r\n        if (l > r || l > n-1 || r < 0) return;\r\n        if (l < 0) l = 0;\r\n        if (r > n-1) r = n-1;\r\n        _add(B1, l, x);\r\n        _add(B1, r+1, -x);\r\n        _add(B2, l, x*(l-1));\r\n        _add(B2, r+1, -x*r);\r\n    }\r\n    ll _sum(vll& B, int idx) {\r\n        ll res = 0;\r\n        for(++idx; idx > 0; idx -= idx & -idx) res += B[idx];\r\n        return res;\r\n    }\r\n    ll _prefix_sum(int idx) {\r\n        return _sum(B1, idx)*idx - _sum(B2, idx);\r\n    }\r\n    ll query(int idx) {\r\n        return query(idx, idx);\r\n    }\r\n    ll query(int l, int r) {\r\n        if (l > r || l > n-1 || r < 0) return 0;\r\n        if (l < 0) l = 0;\r\n        if (r > n-1) r = n-1;\r\n        return _prefix_sum(r) - _prefix_sum(l-1);\r\n    }\r\n};\r\nll dp[505][505];\r\nvoid solve() {\r\n    ll n = gi(),l = gi(),k = gi();\r\n    vector<ll> A(n),B(n);\r\n    fori(0,n) A[i] = gi();\r\n    A.pb(l);\r\n    fori(0,n) B[i] = gi();\r\n    fori(0,n+1) {\r\n        forj(0,k+1) {\r\n            dp[i][j] = INF64;\r\n        }\r\n    }\r\n    dp[0][0] = 0;\r\n    fori(1,n+1) {\r\n        forj(0,k+1) {\r\n            for(int p = i-1; p >= 0; p--) {\r\n                int old_j = j - (i-p-1);\r\n                if (old_j >= 0)\r\n                    dp[i][j] = min(dp[i][j], dp[p][old_j] + (A[i]-A[p])*B[p]);\r\n            }\r\n        }\r\n    }\r\n    ll ans = INF64;\r\n    fori(0,k+1) {\r\n        ans = min(ans, dp[n][i]);\r\n    }\r\n    put(ans);\r\n}\r\n \r\nsigned main()\r\n{\r\n    // ios::sync_with_stdio(0); cin.tie(0);\r\n    cout.precision(16); cout << fixed;\r\n    int t = 1;\r\n    // int t = getint();\r\n    while (t--) {\r\n        solve();\r\n    }\r\n}"
}