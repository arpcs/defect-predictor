{
    "id": 229520642,
    "contestId": 1353,
    "creationTimeSeconds": 1698131312,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1353,
        "index": "D",
        "name": "Constructing the Array",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "constructive algorithms",
            "data structures",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1353,
        "members": [
            {
                "handle": "prashantdhaka666"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1589466900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 21,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 4812800,
    "source": "\r\n/*\r\n\r\n****************************************************************************************\r\n*                                Jai Bajrangbali                                       *\r\n*                             codechef-prashantdhaka                                   *\r\n*                             cf-dhakaprashant666                                      *\r\n*                         email-:[email\u00a0protected]                            *\r\n****************************************************************************************                                                                         \r\n\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n#define prashant ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\r\n\r\n// Debug Template, copied from Mikel_Arteta_8 (https://codeforces.com/blog/entry/68809)\r\nvoid __print(int x) {cerr << x;}\r\nvoid __print(long x) {cerr << x;}\r\nvoid __print(long long x) {cerr << x;}\r\nvoid __print(unsigned x) {cerr << x;}\r\nvoid __print(unsigned long x) {cerr << x;}\r\nvoid __print(unsigned long long x) {cerr << x;}\r\nvoid __print(float x) {cerr << x;}\r\nvoid __print(double x) {cerr << x;}\r\nvoid __print(long double x) {cerr << x;}\r\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\r\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\r\ntemplate<typename T, typename V>\r\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\r\ntemplate<typename T>\r\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\r\nvoid _print() {cerr << \"]\\n\";}\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\r\n#ifdef prashant\r\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\r\n#else\r\n#define debug(x...)\r\n#endif\r\n// End of debugging template\r\n\r\n#define db(...)                 __f(#__VA_ARGS__, __VA_ARGS__)\r\ntemplate <typename Arg1>\r\nvoid __f(const char* name, Arg1&& arg1) { cerr << \" \"<< name << \" : \" << arg1 <<'\\n'; }\r\ntemplate <typename Arg1, typename... Args>\r\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\r\n    const char* comma = strchr(names + 1, ',');\r\n    cerr.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma + 1, args...);\r\n}\r\n \r\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\r\n        //  shuffle(arr.begin(), arr.end(), rng); \r\n        //  or rng() to generate random number\r\n \r\n       \r\n \r\n#define endl                                \"\\n\"\r\n#define int                                 long long    //in case of mle ,tle high constraints\r\n#define ll                                  long long\r\n#define umap                                unordered_map\r\n#define uset                                unordered_set\r\n#define lb                                  lower_bound\r\n#define ub                                  upper_bound\r\n#define fo(i,a,b)                           for(i=a;i<=b;i++)\r\n#define all(v)                              (v).begin(),(v).end()\r\n#define all1(v)                             (v).begin()+1,(v).end()\r\n#define allr(v)                             (v).rbegin(),(v).rend()\r\n#define allr1(v)                            (v).rbegin()+1,(v).rend()\r\n#define sort0(v)                            sort(all(v))\r\ntypedef pair<int,int>                       pii;\r\ntypedef pair<char,int>                      pci;\r\ntypedef vector<int>                         vi;\r\ntypedef vector<ll>                          vll;\r\ntypedef pair<ll, ll>                        pll;\r\n#define sz(x)                               (ll)x.size()\r\n#define sp                                  <<\" \"<<\r\n#define max3(a,b,c)                         max(max((a),(b)),(c))\r\n#define max4(a,b,c,d)                       max(max((a),(b)),max((c),(d)))\r\n#define pb                                  push_back\r\n#define ppb                                 pop_back\r\n#define fi                                  first\r\n#define se                                  second\r\n#define mkp                                 make_pair\r\n#define py                                  cout<<\"Yes\"<<endl;\r\n#define pn                                  cout<<\"No\"<<endl;\r\n#define inf                                 1000000000000000005    //2e18+5\r\n\r\n\r\nconst ll mod = 1e9+7 ;//998244353;\r\nconst int N=2e5+5;\r\n \r\nll inv(ll i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}\r\n \r\nll mod_mul(ll a, ll b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}\r\n \r\nll mod_add(ll a, ll b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}\r\n \r\nll gcd(ll a, ll b) { if (b == 0) return a; return gcd(b, a % b);}\r\n\r\nll lcm(ll a, ll b) { return (a / gcd(a, b)) * b;}\r\n \r\nll ceil_div(ll a, ll b) {return a % b == 0 ? a / b : a / b + 1;}\r\n \r\nll pwr(ll a, ll b) {a %= mod; ll res = 1; while (b > 0) {if (b & 1) res = res * a % mod; a = a * a % mod; b >>= 1;} return res;}\r\n\r\nll pwrl(ll a, ll b) { ll res = 1; while (b > 0) {if (b & 1) res = res * a ; a = a * a ; b >>= 1;} return res;}\r\n\r\n//****************************Template Ends*******************************//\r\n \r\n\r\n\r\n//****** graph ajaency input******//\r\n\r\n//  int n, m; cin >> n >> m;vector<vector<int>> adj(n);for (int i = 0; i < m; i++){ int u, v; cin >> u >> v;  adj[u].pb(v);adj[v].pb(u); }\r\n\r\n//****** graph ajaency input end ******//\r\n\r\n//******matrix input *******//\r\n\r\n// int n,m;cin>>n>>m; vector<vector<int>> arr(n,vector<int> (m,0));for(int i=0;i<n;i++){ for(int j=0;j<m;j++){  cin>>arr[i][j]; } }\r\n\r\n//******matrix input end ********//\r\n\r\n//******string input**********//\r\n\r\n// int n; cin>>n; string s; cin>>s;\r\n\r\n// string s; cin>>s;\r\n\r\n// int k; cin>>k; string k ; cin>>k ;\r\n\r\n// string s1; cin>>s1;\r\n\r\n\r\n//****string input end ************//\r\n\r\n//*** double array input *******//\r\n\r\n// int n,m; cin>>n>>m; vector<int> v1(n);  vector<int> v2(m); for(int i=0;i<n;i++){  cin>>v1[i];} for(int i=0;i<m;i++){  cin>>v2[i];}\r\n\r\n//*** double array input *******//\r\n\r\n\r\n//****** vector input start ******//\r\n\r\n// int n; cin>>n; vector<int> v(n);  for(int i=0;i<n;i++){       cin>>v[i];    }\r\n\r\n//****** vector input end ******//\r\n\r\nvoid solve(){\r\n    //check for testcase;\r\nint x=0,y=0,z=0,k=0,ans=0;\r\nvector<int> ar;\r\nstring res=\"YES\";\r\n\r\nint n;\r\ncin>>n;\r\nvector<int> v(n+1,0);\r\npriority_queue<pii> pq;\r\n\r\npq.push({n,-n});\r\nint i=1;\r\nwhile(pq.size()){\r\n  int sz=pq.top().fi;\r\n  int r=-pq.top().se;\r\n  int l=r-sz+1;\r\n  int mid=(l+r)/2;\r\n  v[mid]=i;\r\n  pq.pop();\r\n  if(mid-1>=l){\r\n    pq.push({mid-l,-mid+1});\r\n  }\r\n  if(r>=mid+1){\r\n    pq.push({r-mid,-r});\r\n  }\r\n\r\n   i++;\r\n}\r\n\r\nfor(int i=1;i<=n;i++)cout<<v[i]<<\" \";\r\ncout<<endl;\r\n\r\n}\r\n\r\nint32_t main(){\r\n    prashant;\r\nint t=1;\r\ncin>>t;\r\nwhile(t--){\r\nsolve();\r\n\r\n}\r\nreturn 0;\r\n}\r\n\r\n\r\n\r\n//******************* sieve start **********************************//\r\n// vector<bool> is_prime;\r\n// void sieve_eth(int n){\r\n// is_prime.resize(n+1,1);\r\n// is_prime[0] = is_prime[1] = false;\r\n// for (int i = 2; i * i <= n; i++) {\r\n//     if (is_prime[i]) {\r\n//         for (int j = i * i; j <= n; j += i)\r\n//             is_prime[j] = false;\r\n//     }\r\n// }\r\n// }\r\n\r\n\r\n// ll spf[1000001];\r\n \r\n// vector<ll> primes;\r\n// void sieve() {\r\n//  spf[1] = 1;\r\n//  for (ll i = 2; i < 1000001; i++) {\r\n//      spf[i] = i;\r\n//  }\r\n \r\n//  for (ll i = 4; i < 1000001; i += 2) {\r\n//      spf[i] = 2;\r\n//  }\r\n \r\n//  for (ll i = 3; i * i < 1000001; i++) {\r\n//      if (spf[i] == i) {\r\n//          for (ll j = i * i; j < 1000001; j += i) {\r\n//              if (spf[j] == j)\r\n//                  spf[j] = i;\r\n//          }\r\n \r\n//      }\r\n//  }\r\n//  for (ll i = 2; i < 1000001; i++) {\r\n//      if (spf[i] == i) {\r\n//          primes.push_back(i);\r\n//      }\r\n//  }\r\n// }\r\n \r\n// vector<ll> getFactorization(ll x) {\r\n//  vector<ll> ret;\r\n//  while (x != 1) {\r\n \r\n//      ret.push_back(spf[x]);\r\n//      x = x / spf[x];\r\n//  }\r\n//  return ret;\r\n// }\r\n//******************* sieve ends **********************************//\r\n\r\n//******************* ncr starts **********************************//\r\n\r\n \r\n// ll power(ll x, ll i, ll p) {\r\n//  ll ans = 1;\r\n//  while (i > 0) {\r\n//      if (i & 1)ans = (ans * x) % p;\r\n//      i >>= 1;\r\n//      x = (x * x) % p;\r\n//  }\r\n//  return ans;\r\n// }\r\n \r\n// ll modular_inverse(ll n, ll p) {\r\n//  return power(n, p - 2, p);\r\n// }\r\n \r\n \r\n// long long fac[200000 + 1];\r\n// void factorial() {\r\n \r\n//  fac[0] = 1;\r\n//  for (int i = 1 ; i <= 200000; i++) {\r\n \r\n//      fac[i] = fac[i - 1] * i % mod;\r\n//  }\r\n// }\r\n// ll ncr(ll n, ll r, ll p) {\r\n//  if (r > n)   {\r\n//      return 0;\r\n//  }\r\n//  if (n < 0 || r < 0)  {\r\n//      return 0;\r\n//  }\r\n//  if (r == 0)\r\n//      return 1;\r\n \r\n//  return (fac[n] * power(fac[r], p - 2, p) % p * power(fac[n - r], p - 2, p) % p) % p;\r\n// }\r\n//******************* ncr starts **********************************//\r\n//******************* dsu  ends **********************************//\r\n\r\n// struct dsu{\r\n//     vector<int> parent;\r\n//     vector<int> st ;\r\n//     int n ;\r\n//     void setparent(){\r\n//         for(int i = 0 ; i < n+1 ; i++){\r\n//             parent[i] = i ;\r\n//             st[i] = 1;\r\n//         }\r\n        \r\n//     }\r\n//     int findparent(int v){\r\n//         if(parent[v] == v) return v ;\r\n//         else return parent[v] = findparent(parent[v]);\r\n//     }\r\n   \r\n//      bool unionset(int a , int b){\r\n//         a = findparent(a);\r\n//         b = findparent(b);\r\n//         if(a == b) return false;\r\n//         if(st[a] < st[b]) swap(a , b);\r\n//         parent[b] = a ;\r\n//         st[a] +=st[b]; \r\n//         return true;\r\n//     }\r\n// };\r\n//******************* dsu ends  **********************************//\r\n\r\n\r\n\r\n// const int Max = 2e5 +1;\r\n// ll fact[Max];\r\n// ll inv_fact[Max];\r\n\r\n// void preSolveFact(ll n){\r\n//     ll ans = 1;\r\n//     fact[0] = 1;\r\n//     for(int i = 1; i<=n; i++){\r\n//         ans *=i;\r\n//         ans %= mod;\r\n//         fact[i] = ans;\r\n//     }\r\n//     inv_fact[n] = binpow(fact[n], mod-2);\r\n\r\n//     for(int i = n-1; i>=0; i--){\r\n//         inv_fact[i] = inv_fact[i+1] * (i+1) %mod;\r\n//     }\r\n// }\r\n// ll nCr_pre(ll n, ll r){\r\n//     if(n>=r && n>=0 && r>=0)\r\n//     return fact[n] * inv_fact[r] %mod * inv_fact[n-r]%mod;\r\n//     else return 0;\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}