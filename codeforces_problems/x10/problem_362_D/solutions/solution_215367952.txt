{
    "id": 215367952,
    "contestId": 362,
    "creationTimeSeconds": 1690207900,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 362,
        "index": "D",
        "name": "Fools and Foolproof Roads",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2100,
        "tags": [
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "greedy"
        ]
    },
    "author": {
        "contestId": 362,
        "members": [
            {
                "handle": "Kirkon"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1384443000
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 10,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 3686400,
    "source": "// #\r\n#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n\r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n\r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n\r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <type_traits>\r\n#include <typeindex>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing db = long double;// or double, if TL is tight\r\nusing str = string;    // yay python!\r\n\r\n// pairs\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing pd = pair<db, db>;\r\n#define pb push_back\r\n#define mp make_pair\r\n#define fi first\r\n#define se second\r\n\r\ntemplate<class T>\r\nusing V = vector<T>;\r\ntemplate<class T, size_t SZ>\r\nusing AR = array<T, SZ>;\r\nusing vi = V<int>;\r\nusing vvi = V<vi>;\r\nusing vb = V<bool>;\r\nusing vll = V<ll>;\r\nusing vd = V<db>;\r\nusing vs = V<str>;\r\nusing vpii = V<pii>;\r\nusing vpll = V<pll>;\r\nusing vpd = V<pd>;\r\n\r\ntemplate<class T>\r\nusing pair2 = pair<T, T>;\r\n\r\n// vectors\r\n// oops size(x), rbegin(x), rend(x) need C++17\r\n\r\ntemplate<class T>\r\nint sz(const T &a) { return a.size(); }\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define sor(x) sort(all(x))\r\n\r\ntemplate<class T>\r\nint lwb(V<T> &a, const T &b) {\r\n  return int(lower_bound(all(a), b) - bg(a));\r\n}\r\ntemplate<class T>\r\nint upb(V<T> &a, const T &b) {\r\n  return int(upper_bound(all(a), b) - bg(a));\r\n}\r\n\r\ntemplate<class T>\r\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate<class T>\r\nusing pql = priority_queue<T, vector<T>, less<T>>;\r\n\r\n// loops\r\n#define rep(a) for (int _ = 0; _ < (a); ++_)\r\n#define each(a, x) for (auto &a: x)\r\n\r\nconst int MOD = 998244353;\r\nconst int MX = 2e5 + 5;\r\nconst ll BIG = 1e18;// not too close to LLONG_MAX\r\nconst db PI = acos((db) -1);\r\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};// for every grid problem!!\r\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nnamespace kirkon {}\r\nusing namespace kirkon;\r\n\r\nnamespace kirkon_helpers {\r\n  // bitwise ops\r\n  // also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\r\n  constexpr long long pct(long long x) {\r\n    return __builtin_popcount(x);\r\n  }                                      // # of bits set\r\n  constexpr long long bits(long long x) {// assert(x >= 0); // make C++11\r\n                                         // compatible until USACO updates ...\r\n    return x == 0 ? 0 : 31 - __builtin_clz(x);\r\n  }// floor(log2(x))\r\n  constexpr long long p2(long long x) { return 1 << x; }\r\n  constexpr long long msk2(long long x) { return p2(x) - 1; }\r\n\r\n  ll cdiv(ll a, ll b) {\r\n    return a / b + ((a ^ b) > 0 && a % b);\r\n  }// divide a by b rounded up\r\n  ll fdiv(ll a, ll b) {\r\n    return a / b - ((a ^ b) < 0 && a % b);\r\n  }// divide a by b rounded down\r\n\r\n  template<class T>\r\n  bool ckmin(T &a, const T &b) {\r\n    return b < a ? a = b, 1 : 0;\r\n  }// set a = min(a,b)\r\n  template<class T>\r\n  bool ckmax(T &a, const T &b) {\r\n    return a < b ? a = b, 1 : 0;\r\n  }// set a = max(a,b)\r\n\r\n  template<class T, class U>\r\n  bool ckmin(T &a, const U &b) {\r\n    return b < a ? a = b, 1 : 0;\r\n  }// set a = min(a,b)\r\n  template<class T, class U>\r\n  bool ckmax(T &a, const U &b) {\r\n    return a < b ? a = b, 1 : 0;\r\n  }// set a = max(a,b)\r\n\r\n  template<class T, class U>\r\n  T fstTrue(T lo, T hi, U f) {\r\n    ++hi;\r\n    assert(lo <= hi);// assuming f is increasing\r\n    while (lo < hi) {// find first index such that f is true\r\n      T mid = lo + (hi - lo) / 2;\r\n      f(mid) ? hi = mid : lo = mid + 1;\r\n    }\r\n    return lo;\r\n  }\r\n  template<class T, class U>\r\n  T lstTrue(T lo, T hi, U f) {\r\n    --lo;\r\n    assert(lo <= hi);// assuming f is decreasing\r\n    while (lo < hi) {// find first index such that f is true\r\n      T mid = lo + (hi - lo + 1) / 2;\r\n      f(mid) ? lo = mid : hi = mid - 1;\r\n    }\r\n    return lo;\r\n  }\r\n\r\n  template<class T>\r\n  void remDup(vector<T> &v) {// sort and remove duplicates\r\n    sort(all(v));\r\n    v.erase(unique(all(v)), end(v));\r\n  }\r\n  template<class T, class U>\r\n  void erase(T &t, const U &u) {// don't erase\r\n    auto it = t.find(u);\r\n    assert(it != end(t));\r\n    t.erase(it);\r\n  }// element that doesn't exist from (multi)set\r\n\r\n  ll myRand(ll B) { return (unsigned long long) rng() % B; }\r\n\r\n  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\r\n  template<class Fun>\r\n  class y_combinator_result {\r\n    Fun fun_;\r\n\r\npublic:\r\n    template<class T>\r\n    explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\r\n    template<class... Args>\r\n    decltype(auto) operator()(Args &&...args) {\r\n      return fun_(std::ref(*this), std::forward<Args>(args)...);\r\n    }\r\n  };\r\n\r\n  template<class Fun>\r\n  decltype(auto) y_combinator(Fun &&fun) {\r\n    return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\r\n  }\r\n\r\n  template<class T, class U>\r\n  istream &operator>>(istream &in, pair<T, U> &a) {\r\n    in >> a.first >> a.second;\r\n    return in;\r\n  }\r\n\r\n  template<class T, class U>\r\n  ostream &operator<<(ostream &out, pair<T, U> &a) {\r\n    out << a.first << ' ' << a.second << '\\n';\r\n    return out;\r\n  }\r\n\r\n  template<class T>\r\n  istream &operator>>(istream &in, vector<T> &a) {\r\n    each(i, a) { in >> i; }\r\n    return in;\r\n  }\r\n\r\n  template<class T>\r\n  ostream &operator<<(ostream &out, vector<T> &a) {\r\n    each(i, a) { out << i << ' '; }\r\n    out << '\\n';\r\n    return out;\r\n  }\r\n\r\n}// namespace kirkon_helpers\r\n\r\nusing namespace kirkon_helpers;\r\n\r\nvector<vector<pii>> gr;\r\nvector<int> used;\r\n\r\n\r\nvector<ll> costs;\r\nvector<int> comps;\r\nvector<int> senior;\r\nint timer = 1;\r\n\r\n\r\nvoid dfs(int v) {\r\n  used[v] = timer;\r\n  comps[timer]++;\r\n  for (auto [u, w]: gr[v]) {\r\n    costs[timer] += w;\r\n    if (!used[u]) {\r\n      dfs(u);\r\n    }\r\n  }\r\n}\r\n\r\nvoid solve() {\r\n  int n;\r\n  cin >> n;\r\n  gr.resize(n);\r\n  used.assign(n, false);\r\n  int m, p, q;\r\n  cin >> m >> p >> q;\r\n  rep(m) {\r\n    int u, v, w;\r\n    cin >> u >> v >> w;\r\n    --u;\r\n    --v;\r\n    gr[u].pb({v, w});\r\n    gr[v].pb({u, w});\r\n  }\r\n  comps.pb(-1);\r\n  costs.pb(-1LL);\r\n  senior.pb(-1);\r\n  for (int i = 0; i < n; ++i) {\r\n    if (!used[i]) {\r\n      comps.pb(0);\r\n      costs.pb(0LL);\r\n      senior.pb(i);\r\n      dfs(i);\r\n      timer++;\r\n    }\r\n  }\r\n\r\n  bool flag = false;\r\n  if (*max_element(all(comps)) > 1) {\r\n    flag = true;\r\n  }\r\n\r\n  multiset<pair<ll, int>> kek;\r\n  for (int i = 1; i < timer; ++i) {\r\n    kek.insert({costs[i] / 2, senior[i]});\r\n  }\r\n\r\n  if (q >= timer) {\r\n    cout << \"NO\\n\";\r\n    return;\r\n  }\r\n\r\n  if (p == 0) {\r\n    cout << (q == timer - 1 ? \"YES\" : \"NO\");\r\n    return;\r\n  }\r\n\r\n  if (m == 0) {\r\n    if (q == timer - 1) {\r\n      cout << \"NO\";\r\n      return;\r\n    }\r\n  }\r\n\r\n  int v = 0;\r\n  for (; v < n; ++v) {\r\n    if (gr[v].size() > 0) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  pii any_edge = {v, gr[v][0].first};\r\n\r\n  if (q == timer - 1) {\r\n    cout << \"YES\\n\";\r\n    for (int i = 0; i < p; ++i) {\r\n      cout << any_edge.first + 1 << ' ' << any_edge.second + 1 << '\\n';\r\n    }\r\n    return;\r\n  }\r\n\r\n\r\n  cout << \"YES\\n\";\r\n  for (int i = 0; i < p; ++i) {\r\n    if (kek.size() == q) {\r\n      cout << any_edge.first + 1 << ' ' << any_edge.second + 1 << '\\n';\r\n    } else {\r\n      auto [cost1, comp1] = *kek.begin();\r\n      kek.erase(kek.begin());\r\n      auto [cost2, comp2] = *kek.begin();\r\n      kek.erase(kek.begin());\r\n      kek.insert({cost1 + cost2 + 1, comp1});\r\n      cout << comp1 + 1 << ' ' << comp2 + 1 << '\\n';\r\n    }\r\n  }\r\n}\r\n\r\nsigned main() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  cout.precision(30);\r\n  // setIO();\r\n  int tt = 1;\r\n  // cin >> tt;\r\n  rep(tt) solve();\r\n  // you should actually read the stuff at the bottom\r\n}\r\n\r\n/* stuff you should look for\r\n * long long overflow, array bounds\r\n * special cases (n=1?)\r\n * do smth instead of nothing and stay organized\r\n * WRITE STUFF DOWN\r\n * DON'T GET STUCK ON ONE APPROACH\r\n */\r\n"
}