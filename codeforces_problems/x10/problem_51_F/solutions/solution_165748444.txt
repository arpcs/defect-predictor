{
    "id": 165748444,
    "contestId": 51,
    "creationTimeSeconds": 1658817844,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 51,
        "index": "F",
        "name": "Caterpillar",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2800,
        "tags": [
            "dfs and similar",
            "dp",
            "graphs",
            "trees"
        ]
    },
    "author": {
        "contestId": 51,
        "members": [
            {
                "handle": "Refined_heart"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1293552000
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 39,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 36966400,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef double db;\r\n//#define int long long\r\n#define fi first\r\n#define se second\r\n#define mk make_pair\r\n#define pb emplace_back\r\n#define poly vector<int>\r\n#define Bt(a) bitset<a>\r\n#define bc __builtin_popcount\r\n#define pc putchar\r\n#define ci const int&\r\nconst int mod = 1e9+7;\r\nconst db eps = 1e-10;\r\ninline int Max(ci x, ci y) {return x > y ? x : y;}\r\ninline int Min(ci x, ci y) {return x < y ? x : y;}\r\ninline db Max(db x, db y) {return x - y > eps ? x : y;}\r\ninline db Min(db x, db y) {return x - y < eps ? x : y;}\r\ninline int Add(ci x, ci y, ci M = mod) {return (x + y) % M;}\r\ninline int Mul(ci x, ci y, ci M = mod) {return 1ll * x * y % M;}\r\ninline int Dec(ci x, ci y, ci M = mod) {return (x - y + M) % M;}\r\ntypedef pair<int, int> pii;\r\ninline int Abs(int x) {return x < 0 ? -x : x;}\r\n//char buf[1<<21],*p1=buf,*p2=buf;\r\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\r\nchar Obuf[105000],*O=Obuf;//Siz shoule be the size of Out File\r\nint pst[30],ptop;\r\ninline void Fprint(){fwrite(Obuf,1,O-Obuf,stdout);}\r\ninline void Fwrite(int x){\r\n  if(x==0){*O++='0';if(O-Obuf>100000)Fprint(),O=Obuf;return;}\r\n  if(x<0)*O++='-',x=-x;ptop=0;\r\n  while(x)pst[++ptop]=x%10,x/=10;\r\n  while(ptop)*O++=pst[ptop--]+'0';\r\n  if(O-Obuf>100000)Fprint(),O=Obuf;\r\n}\r\ninline int read() {\r\n    int s = 0, w = 1;\r\n    char ch = getchar();\r\n    while (!isdigit(ch)) {if (ch == '-') w = -1;ch = getchar();}\r\n    while (isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}\r\n    return s * w;\r\n}\r\ninline void write(int x) {\r\n    if (x < 0)putchar('-'), x = -x;\r\n    if (x > 9)write(x / 10);\r\n\tpc(x % 10 + '0');\r\n}\r\ninline int qpow(int x, int y) {\r\n    int res = 1;\r\n    while (y) {if (y & 1)res = Mul(res, x);x = Mul(x, x);y >>= 1;}\r\n    return res;\r\n}\r\ninline void cadd(int &x, int y) {x += y;}\r\ninline void cmul(int &x, int y) {x *= y;}\r\ninline void cmax(int &x, int y) {x = Max(x, y);}\r\ninline void cmin(int &x, int y) {x = Min(x, y);}\r\nconst int N = 4e5 + 10;\r\nnamespace CG{\r\n\r\n\tstruct P{\r\n\t\tdb x, y;\r\n\t\tP(db x_ = 0, db y_ = 0){\r\n\t\t\tx = x_; y = y_;\r\n\t\t}\r\n\t\tdb len() {\r\n\t\t\treturn sqrt(x * x + y * y);\r\n\t\t}\r\n\t\tP mid() {\r\n\t\t\treturn P(x / 2.0, y / 2.0);\r\n\t\t}\r\n\t\tdb theta() {\r\n\t\t\treturn atan2(y, x);\r\n\t\t}\r\n\t};\r\n\tP operator + (P x, P y) {return P(x.x + y.x, x.y + y.y);}\r\n\tP operator - (P x, P y) {return P(x.x - y.x, x.y - y.y);}\r\n\tP operator * (P x, db y) {return P(x.x * y, x.y * y);}\r\n\tP operator * (db y, P x) {return P(x.x * y, x.y * y);}\r\n\tdb operator * (P x, P y) {return x.x * y.x + x.y * y.y;}\r\n\tdb operator ^ (P a, P b) {return a.x * b.y - a.y * b.x;}\r\n\tstruct Line {\r\n\t\tP x, y; db k;\r\n\t\tLine (P _x = P(0, 0), P _y = P(0, 0)) {\r\n\t\t\tx = _x; y = _y - _x; k = _y.theta();\r\n\t\t}\r\n\t};\r\n\r\n\tinline db sq(db x) {return x * x;}\r\n\tinline db dis(P x, P y) {return sqrt(sq(x.x - y.x) + sq(x.y - y.y));}\r\n\tinline db fdis(P x, P y) {return sq(x.x - y.x) + sq(x.y - y.y);}\r\n\tP crossover(Line x, Line y) {\r\n\t\tP C = x.x - y.x;\r\n\t\tdb t = (y.y ^ C) / (x.y ^ y.y);\r\n\t\treturn x.x + x.y * t;\r\n\t}\r\n}\r\nnamespace Refined_heart{\r\n\tint n, m;\r\n\tint head[N], tot = 1, siz[N]; \r\n\tstruct E {int nxt, to;} e[N];\r\n\tinline void link(int x, int y) {\r\n\t\te[++tot] = (E){head[x], y};\r\n\t\thead[x] = tot;\r\n\t}\r\n\tint dfstime, dfn[N], low[N], vis[N], cnt;\r\n\tvoid Tarjan(int x, int ine) {\r\n\t\tdfn[x] = low[x] = ++dfstime;\r\n\t\tfor(int i = head[x]; i; i = e[i].nxt) {\r\n\t\t\tint j = e[i].to;\r\n\t\t\tif((i ^ 1) == ine) continue;\r\n\t\t\tif(!dfn[j]) {\r\n\t\t\t\tTarjan(j, i);\r\n\t\t\t\tlow[x] = Min(low[x], low[j]);\r\n\t\t\t\tif(low[j] > dfn[x]) {\r\n\t\t\t\t\tvis[i] = vis[i ^ 1] = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlow[x] = Min(low[x], dfn[j]);\r\n\t\t}\r\n\t}\r\n\tpoly vec[N];\r\n\tvoid dfs(int x) {\r\n\t\tdfn[x] = cnt; ++siz[cnt]; vec[cnt].pb(x);\r\n\t\tfor(int i = head[x]; i; i = e[i].nxt) {\r\n\t\t\tint j = e[i].to;\r\n\t\t\tif(vis[i]) continue;\r\n\t\t\tif(dfn[j]) continue;\r\n\t\t\tdfs(j);\r\n\t\t}\r\n\t}\r\n\tpoly G[N];\r\n\tint f[N];\r\n\tinline int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);}\r\n\tinline void link_g(int x, int y) {G[x].pb(y);}\r\n\tinline void merge(int x, int y) {\r\n\t\tx = find(x); y = find(y);\r\n\t\tif(x == y) return ;\r\n\t\tf[x] = y;\r\n\t}\r\n\tint g[N], h[N], og[N], Z;\r\n\tpoly VV;\r\n\tvoid dfs1(int x, int fa) {\r\n\t\tvis[x] = 1;\r\n\t\tVV.pb(x);\r\n\t\t++Z;\r\n\t\tint son = 0;\r\n\t\tfor(auto v : G[x]) {\r\n\t\t\tif(v == fa) continue;\r\n\t\t\tdfs1(v, x); ++son;\r\n\t\t}\r\n\t\tif(son == 0) g[x] = 1;\r\n\t\telse {\r\n\t\t\tg[x] = son;\r\n\t\t\tint kv = -1, ps = 0;\r\n\t\t\tfor(auto v : G[x]) {\r\n\t\t\t\tif(v == fa) continue;\r\n\t\t\t\tif(g[v] > kv) {\r\n\t\t\t\t\tps = v; \r\n\t\t\t\t\tkv = g[v];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tg[x] += kv; og[x] = ps;\r\n\t\t}\r\n\t\th[x] = g[x] + (fa != 0);\r\n\t\tif(son > 1) {\r\n\t\t\tint res = 0;\r\n\t\t\tfor(auto v : G[x]) {\r\n\t\t\t\tif(v == fa) continue;\r\n\t\t\t\tif(v == og[x]) continue;\r\n\t\t\t\tres = Max(res, g[v]);\r\n\t\t\t}\r\n\t\t\tres = res - 1;\r\n\t\t\th[x] += res;\r\n\t\t}\r\n\t}\r\n//\tvoid dfs2(int x, int fa) {\r\n//\t\tif(fa == 0) {\r\n//\t\t\th[x] = g[x];\r\n//\t\t}\r\n//\t\telse {\r\n//\t\t\t\r\n//\t\t}\r\n//\t\tfor(auto v : G[x]) {\r\n//\t\t\tif(v == fa) continue;\r\n//\t\t\tdfs2(v, x);\r\n//\t\t}\r\n//\t}\r\n\tvoid solve(){\r\n\t\tn = read(); m = read();\r\n\t\tfor(int i = 1; i <= m; ++i) {\r\n\t\t\tint u = read(), v = read(); \r\n\t\t\tlink(u, v); link(v, u);\r\n\t\t}\r\n\t\tfor(int i = 1; i <= n; ++i) if(!dfn[i]) Tarjan(i, 0);\r\n\t\tfor(int i = 1; i <= n; ++i) dfn[i] = 0;\r\n\t\tfor(int i = 1; i <= n; ++i) if(!dfn[i]) ++cnt, dfs(i);\r\n\t\tint ans = 0;\r\n\t\tfor(int i = 1; i <= cnt; ++i) ans += siz[i] - 1, f[i] = i;\r\n\t\tfor(int i = 1; i <= cnt; ++i) {\r\n\t\t\tfor(auto v : vec[i]) {\r\n\t\t\t\tfor(int k = head[v]; k; k = e[k].nxt) {\r\n\t\t\t\t\tint nv = e[k].to;\r\n\t\t\t\t\tnv = dfn[nv];\r\n\t\t\t\t\tif(find(nv) == find(i)) continue;\r\n\t\t\t\t\tlink_g(i, nv); link_g(nv, i);\r\n\t\t\t\t\tmerge(i, nv);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i = 1; i <= cnt; ++i) vis[i] = 0;\r\n//\t\tcout << \"ans = \" << ans << '\\n';\r\n\t\tans = ans - 1;\r\n\t\tfor(int i = 1; i <= cnt; ++i) if(!vis[i]) {\r\n\t\t\tans = ans + 1; Z = 0; VV.clear();\r\n\t\t\tdfs1(i, 0); \r\n\t\t\tint res = 0;\r\n\t\t\tfor(auto v : VV) {cmax(res, h[v]);}\r\n//\t\t\tcout << \"res = \" << res << '\\n';\r\n\t\t\tans += Z - res;\r\n\t\t}\r\n//\t\tfor(int i = 1; i <= cnt; ++i) cout << \"now = \" << i << \" h = \" << h[i] << '\\n';\r\n\t\tcout << ans << '\\n';\r\n\t}\r\n}\r\nsigned main(){\r\n//   \tfreopen(\"in.txt\",\"r\",stdin);\r\n\tRefined_heart::solve();\r\n\treturn 0;\r\n}\r\n"
}