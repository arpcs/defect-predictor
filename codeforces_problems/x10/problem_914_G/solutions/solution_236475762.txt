{
    "id": 236475762,
    "contestId": 914,
    "creationTimeSeconds": 1702113470,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 914,
        "index": "G",
        "name": "Sum the Fibonacci",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 2600,
        "tags": [
            "bitmasks",
            "divide and conquer",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 914,
        "members": [
            {
                "handle": "Ash_Dr"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1516462500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 170,
    "timeConsumedMillis": 452,
    "memoryConsumedBytes": 21708800,
    "source": "// LUOGU_RID: 138917682\n/*\r\n           \u2583\u2586\u2588\u2587\u2584\u2596\r\n       \u259f\u25e4\u2596\u3000\u3000\u3000  \u25e5\u2588  \r\n   \u25e2\u25e4 \u3000  \u25e2\u2590\u3000\u3000     \u2590\u2589\r\n \u2597\u25e4\u3000  \u3000   \u2582 \u2597\u2596\u3000 \u2595 \u2588\u258e\r\n \u25e4\u3000\u2597\u2585\u2596 \u25e5\u2584\u3000 \u2580\u2580\u2580\u25e3\u3000\u2588\u258a\r\n\u2590\u3000\u2595\u258e  \u25e5\u2596\u25e3\u25e4\u3000 \u3000\u3000\u25e2\u2588\u2588\r\n\u2588\u25e3\u3000\u25e5\u2585\u2588\u2580\u3000     \u3000\u2590\u2588\u2588\u2588\u25e4\r\n\u2590\u2588\u2599\u2582\u3000\u3000\u3000      \u25e2\u2588\u2588\u2588\u25e4\r\n\u3000\u25e5\u2588\u2588\u25e3\u3000\u3000\u3000\u3000 \u25e2\u2584\u25e4\r\n\u3000\u3000\u3000\u2580\u2588\u2588\u2585\u2587\u2580\u258e\u2587\r\n\r\n*/\r\n#include <bits/stdc++.h>\r\n#include <functional>\r\n#include <random>\r\n#define LOG(FMT...) fprintf(stderr, FMT)\r\n#define sz(x) (int)x.size()\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<int,int> pii;\r\ntypedef pair<ll,ll> pll;\r\ntypedef unsigned int ui;\r\ntypedef unsigned long long ull;\r\ntypedef pair<double,double> pdd;\r\ntemplate <class T>\r\nistream& operator>>(istream& is, vector<T>& v) {\r\n  for (T& x : v)\r\n    is >> x;\r\n  return is;\r\n}\r\ntemplate <class T>\r\nostream& operator<<(ostream& os, const vector<T>& v) {\r\n  if (!v.empty()) {\r\n    os << v.front();\r\n    for (int i = 1; i < (int)v.size(); ++i)\r\n    os << ' ' << v[i];\r\n  }\r\n  return os;\r\n}\r\nvoid dbg_out() { cerr << \"\\b\\b )\" << endl; }\r\ntemplate <typename Head, typename... Tail>\r\nvoid dbg_out(Head H, Tail... T){cerr << H << \", \";dbg_out(T...);}\r\n#define debug(...) cerr << \"( \" << #__VA_ARGS__ << \" ) = ( \", dbg_out(__VA_ARGS__)\r\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nll myRand(ll B) {return (ull)rng()%B;}\r\nll gcd(ll x, ll y) {return y == 0 ? x : gcd(y, x % y);}\r\nll qpow(ll base, ll x, ll mod) {\r\n    ll res = 1;\r\n    base %= mod;\r\n    while(x) {\r\n       if(x & 1) res = (res * base) % mod;\r\n       base = (base * base) % mod;\r\n       x >>= 1;\r\n    } \r\n    return res;\r\n}\r\nll exgcd(ll a,ll b,ll &x,ll &y) {\r\n    if(b == 0) {\r\n        x = 1;\r\n        y = 0;\r\n        return a;\r\n    }\r\n    ll d = exgcd(b,a % b,y,x);\r\n    y -= a / b * x;\r\n    return d;\r\n}// (get inv) gcd(a,p) = 1 \r\n\r\nconst int N = 1e6 + 10;\r\nconst int M = 1e5 + 10;\r\nconst int INF = 2147483647;\r\nconst ll MOD = 1e9 + 9;\r\nint TT = 1;\r\nusing ll = long long;\r\ntemplate<class T>\r\nconstexpr T power(T a, ll b) {\r\n    T res = 1;\r\n    for (; b; b /= 2, a *= a) {\r\n        if (b % 2) {\r\n            res *= a;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n \r\nconstexpr ll mul(ll a, ll b, ll p) {\r\n    ll res = a * b - ll(1.L * a * b / p) * p;\r\n    res %= p;\r\n    if (res < 0) {\r\n        res += p;\r\n    }\r\n    return res;\r\n}\r\ntemplate<ll P>\r\nstruct MLong {\r\n    ll x;\r\n    constexpr MLong() : x{} {}\r\n    constexpr MLong(ll x) : x{norm(x % getMod())} {}\r\n    \r\n    static ll Mod;\r\n    constexpr static ll getMod() {\r\n        if (P > 0) {\r\n            return P;\r\n        } else {\r\n            return Mod;\r\n        }\r\n    }\r\n    constexpr static void setMod(ll Mod_) {\r\n        Mod = Mod_;\r\n    }\r\n    constexpr ll norm(ll x) const {\r\n        if (x < 0) {\r\n            x += getMod();\r\n        }\r\n        if (x >= getMod()) {\r\n            x -= getMod();\r\n        }\r\n        return x;\r\n    }\r\n    constexpr ll val() const {\r\n        return x;\r\n    }\r\n    explicit constexpr operator ll() const {\r\n        return x;\r\n    }\r\n    constexpr MLong operator-() const {\r\n        MLong res;\r\n        res.x = norm(getMod() - x);\r\n        return res;\r\n    }\r\n    constexpr MLong inv() const {\r\n        assert(x != 0);\r\n        return power(*this, getMod() - 2);\r\n    }\r\n    constexpr MLong &operator*=(MLong rhs) & {\r\n        x = mul(x, rhs.x, getMod());\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator+=(MLong rhs) & {\r\n        x = norm(x + rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator-=(MLong rhs) & {\r\n        x = norm(x - rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator/=(MLong rhs) & {\r\n        return *this *= rhs.inv();\r\n    }\r\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res *= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res += rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res -= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res /= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\r\n        ll v;\r\n        is >> v;\r\n        a = MLong(v);\r\n        return is;\r\n    }\r\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\r\n        return os << a.val();\r\n    }\r\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\r\n        return lhs.val() == rhs.val();\r\n    }\r\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\r\n        return lhs.val() != rhs.val();\r\n    }\r\n};\r\n \r\ntemplate<>\r\nll MLong<0LL>::Mod = ll(1E18) + 9;\r\n \r\ntemplate<int P>\r\nstruct MInt {\r\n    int x;\r\n    constexpr MInt() : x{} {}\r\n    constexpr MInt(ll x) : x{norm(x % getMod())} {}\r\n    \r\n    static int Mod;\r\n    constexpr static int getMod() {\r\n        if (P > 0) {\r\n            return P;\r\n        } else {\r\n            return Mod;\r\n        }\r\n    }\r\n    constexpr static void setMod(int Mod_) {\r\n        Mod = Mod_;\r\n    }\r\n    constexpr int norm(int x) const {\r\n        if (x < 0) {\r\n            x += getMod();\r\n        }\r\n        if (x >= getMod()) {\r\n            x -= getMod();\r\n        }\r\n        return x;\r\n    }\r\n    constexpr int val() const {\r\n        return x;\r\n    }\r\n    explicit constexpr operator int() const {\r\n        return x;\r\n    }\r\n    constexpr MInt operator-() const {\r\n        MInt res;\r\n        res.x = norm(getMod() - x);\r\n        return res;\r\n    }\r\n    constexpr MInt inv() const {\r\n        assert(x != 0);\r\n        return power(*this, getMod() - 2);\r\n    }\r\n    constexpr MInt &operator*=(MInt rhs) & {\r\n        x = 1LL * x * rhs.x % getMod();\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator+=(MInt rhs) & {\r\n        x = norm(x + rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator-=(MInt rhs) & {\r\n        x = norm(x - rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator/=(MInt rhs) & {\r\n        return *this *= rhs.inv();\r\n    }\r\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res *= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res += rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res -= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res /= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\r\n        ll v;\r\n        is >> v;\r\n        a = MInt(v);\r\n        return is;\r\n    }\r\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\r\n        return os << a.val();\r\n    }\r\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\r\n        return lhs.val() == rhs.val();\r\n    }\r\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\r\n        return lhs.val() != rhs.val();\r\n    }\r\n};\r\n \r\ntemplate<>\r\nint MInt<0>::Mod = 998244353;\r\ntemplate<int V, int P>\r\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\r\nconstexpr int P = 1e9+7;\r\nusing mint = MInt<P>;\r\nint LIM = (1 << 17), n = 17;\r\nmint inv2;\r\nvoid ORFMT(vector<mint>& a,int tp){\r\n    for(int i = 0; i < n; i++)\r\n        for(int j = 0;j < LIM; j++)\r\n            if(j >> i & 1) a[j] += tp * a[j ^ (1 << i)];\r\n}\r\nvoid ANDFMT(vector<mint>& a, int tp) {\r\n    for(int i = 0; i < n; i++) {\r\n        for(int j = LIM - 1; j >= 0; j--) {\r\n            if(j >> i & 1) a[j ^ (1 << i)] += tp * a[j];\r\n        }\r\n    }\r\n}\r\nvoid FWT_xor(vector<mint>& a,int opt)\r\n{\r\n    for(int i=1;i<LIM;i<<=1)\r\n        for(int p=i<<1,j=0;j<LIM;j+=p)\r\n            for(int k=0;k<i;++k)\r\n            {\r\n                mint X=a[j+k],Y=a[i+j+k];\r\n                a[j+k]=(X+Y);a[i+j+k]=(X-Y);\r\n                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2,a[i+j+k]=1ll*a[i+j+k]*inv2;\r\n            }\r\n}\r\nint m;\r\nvoid solve() {\r\n    cin >> m;\r\n    LIM = (1 << n);\r\n    inv2 = mint(2).inv();   \r\n    vector<vector<mint>> a(n + 1,vector<mint>(LIM)),aa(n + 1,vector<mint>(LIM));\r\n    vector<mint> b(LIM), c(LIM),d(LIM),ans(LIM),fib(LIM);\r\n    for(int i = 0; i < m; i++) {\r\n        int x;\r\n        cin >> x;\r\n        a[__builtin_popcount(x)][x] += 1;\r\n        c[x] += 1;\r\n        d[x] += 1;\r\n    }\r\n    for(int i = 0; i <= n; i++) ORFMT(a[i], 1);\r\n    for(int i = n; i >= 0; i--) {\r\n        for(int k = 0; k <= i; k++) {\r\n            for(int j = 0; j < LIM; j++) {\r\n                aa[i][j] += a[k][j] * a[i - k][j];\r\n            }\r\n        }\r\n        \r\n    }\r\n    a = aa;\r\n    //\u5b50\u96c6\u81ea\u5377\u79ef\r\n    for(int i = 0; i <= n; i++) ORFMT(a[i], -1);\r\n\r\n    for(int i = 0; i < LIM; i++) b[i] = a[__builtin_popcount(i)][i];\r\n    FWT_xor(c, 1);\r\n    for(int i = 0; i < LIM; i++) c[i] = c[i] * c[i];\r\n    FWT_xor(c, -1);\r\n    \r\n    // c b d\r\n    fib[0] = 0;fib[1] = 1;\r\n    for(int i = 2; i < LIM; i++) fib[i] = fib[i - 1] + fib[i - 2];\r\n    for(int i = 0; i < LIM; i++) {\r\n        b[i] *= fib[i];\r\n        c[i] *= fib[i];\r\n        d[i] *= fib[i];\r\n    }\r\n    ANDFMT(b, 1);ANDFMT(c, 1);ANDFMT(d, 1);\r\n    for(int i = 0; i < LIM; i++) ans[i] = b[i] * c[i] * d[i];\r\n    ANDFMT(ans, -1);\r\n    mint res = 0;\r\n    for(int i = 0; i < n; i++) res += ans[1 << i];\r\n    cout << res << \"\\n\";\r\n}\r\nint main() {\r\n    #ifdef ASHDR\r\n    freopen(\"data.in\",\"r\",stdin);\r\n    freopen(\"data.out\",\"w\",stdout);\r\n    int nol_cl = clock();\r\n    #endif\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(nullptr);\r\n    cout<<fixed<<setprecision(8);\r\n    //cin>>TT;\r\n    while(TT--) solve();\r\n    #ifdef ASHDR\r\n    LOG(\"Time: %dms\\n\", int ((clock()\r\n            -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\r\n    #endif\r\n    return 0;\r\n}"
}