{
    "id": 203726040,
    "contestId": 436,
    "creationTimeSeconds": 1682619061,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 436,
        "index": "A",
        "name": "Feed with Candy",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1500,
        "tags": [
            "greedy"
        ]
    },
    "author": {
        "contestId": 436,
        "members": [
            {
                "handle": "anu18dec"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1402673400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 7,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 307200,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long \r\n#define ld long double\r\n#define ull unsigned long long\r\n#define F first\r\n#define S second\r\n#define pb push_back\r\n#define cy cout << \"YES\\n\"\r\n#define cn cout << \"NO\\n\"\r\n#define mod 1000000007\r\n#define mod2 1000000009\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n\r\ntypedef vector<ll> vl ;\r\ntypedef vector<char> vc ;\r\ntypedef vector<string> vs ;\r\ntypedef vector<double> vd ;\r\ntypedef vector<bool> vb ;\r\ntypedef pair<ll,ll> pl;\r\ntypedef vector<vector<ll>> vvl ;\r\ntypedef vector<vector<char>> vvc ;\r\ntypedef vector<pair<ll,ll>> vpl ;\r\ntypedef vector<vector<pair<ll,ll>>> vvpl;\r\n\r\n// -------------------------------------------------------------------------------//\r\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); /* exchanging a and b coz of we are assuming a always > b */ }\r\nll binexpo(ll a, ll b, ll m){ ll ans = 1; while(b>0){ if(b&1){ ans = (ans * a)%m; } a = (a*a)%m; b>>=1; } return ans; }\r\nll binexporec(ll a, ll b, ll m) { if (b == 0) return 1; ll res = binexporec(a, b / 2, m); if (b&1) return (((res * res)%m) * a)%m ; else return (res * res)%m ; }\r\nll mminvprime(ll a, ll m){ return binexpo(a,m-2,m); }\r\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}//when m is prime\r\nbool isPowerOfTwo(int n) { return n > 0 && not (n & n - 1); }\r\nvector<ll> c_div;/*clear c_div after using it*/\r\nvoid common_div(ll a, ll b){ ll g = gcd(a,b); for (ll i = 1; i*i <= g; ++i){ if(g%i==0){ if(g/i==i){ c_div.pb(i); } else { c_div.pb(i); c_div.pb(g/i); } } } }\r\nvector<ll>  prime_factors(ll num){    vector<ll> pfactors; for (ll i = 2; i*i <= num ; ++i) { while(num%i==0) { pfactors.pb(i); num/=i; } } if(num>1) { pfactors.pb(num); } return pfactors; }\r\nvector<ll> factorial; void fact_mod(ll n,ll m) { factorial.resize(n+1); factorial[0]=1; for (ll i = 1; i <= n; ++i) { factorial[i] = factorial[i-1]*i%m; }}\r\n// -------------------------------------------------------------------------------//\r\n\r\n\r\n//Trie Implementation\r\nclass node{\r\npublic:\r\n\tnode * arr[26];\r\n\tll prefix = 0;\r\n\tll complete = 0;\r\n};\r\n\r\nclass Trie{\r\nprivate:\r\n\tnode * root;\r\npublic:\r\n\tTrie(){\r\n\t\troot = new node();\r\n\r\n\t}\r\n\r\n\tvoid insert(string &s){\r\n\r\n\t\tll len = s.length();\r\n\t\tnode * temp = root;\r\n\r\n\t\tfor (int i = 0; i < len; ++i)\r\n\t\t{\r\n\t\t\tif( !temp->arr[s[i]-'a'] ){\r\n\t\t\t\ttemp->arr[s[i]-'a'] = new node();\r\n\t\t\t}\r\n\t\t\ttemp = temp->arr[s[i]-'a'];\r\n\t\t\ttemp->prefix++;\r\n\r\n\t\t}\r\n\t\ttemp->complete++;\r\n\t}\r\n\r\n\tint searchPrefix(string &s){\r\n\r\n\t\tll len = s.length();\r\n\t\tnode * temp = root;\r\n\r\n\t\tfor (int i = 0; i < len; ++i)\r\n\t\t{\r\n\t\t\tif( !temp->arr[s[i]-'a'] ){\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\ttemp = temp->arr[s[i]-'a'];\r\n\t\t}\r\n\t\treturn temp->prefix;\r\n\t}\r\n\r\n\tint searchString(string &s){\r\n\r\n\t\tll len = s.length();\r\n\t\tnode * temp = root;\r\n\r\n\t\tfor (int i = 0; i < len; ++i)\r\n\t\t{\r\n\t\t\tif( !temp->arr[s[i]-'a'] ){\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\ttemp = temp->arr[s[i]-'a'];\r\n\t\t}\r\n\t\treturn temp->complete;\r\n\t}\r\n};\r\n\r\nll arr[26];\r\n\r\nbool check(char ch){\r\n\r\n\tfor (int i = 0; i < 26; ++i)\r\n\t{\r\n\t\tif(arr[ch-97] > 0){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nll calMul(vl &vec,ll lim){\r\n\tll res = 1;\r\n\tll i = 1;\r\n\twhile(i <= lim){\r\n\t\tres *= vec[vec.size()-i];\r\n\t}\r\n\r\n\treturn res;\r\n}\r\n\r\nll check(ll num){\r\n\r\n\tll i = 1;\r\n\tll tmp = 0;\r\n\twhile( tmp < num){\r\n\r\n\t\ttmp += i;\r\n\t\ti++;\r\n\t}\r\n\tif(tmp == num)\r\n\t\treturn --i;\r\n\telse\r\n\t\treturn -1;\r\n}\r\n\r\n\r\n\r\nvoid solve()\r\n{\r\n\tll n,x; cin >> n >> x;\r\n\r\n\tvpl firstType, secondType;\r\n\r\n\tll num,a,b;\r\n\tfor (int i = 0; i < n; ++i){\r\n\r\n\t\tcin >> num >> a >> b;\r\n\r\n\t\tif( num == 0 ){\r\n\r\n\t\t\tfirstType.pb(make_pair(a,b));\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\tsecondType.pb(make_pair(a,b));\r\n\t\t}\r\n\t}\r\n\r\n\tif( firstType.size() == 0 ){\r\n\r\n\t\tif( x >= secondType[0].F){\r\n\t\t\tcout << 1;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << 0;\r\n\t\t}\r\n\t\treturn;\t\t\r\n\t}\r\n\r\n\tif( secondType.size() == 0 ){\r\n\t\t\r\n\t\tif( x >= firstType[0].F){\r\n\t\t\tcout << 1;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << 0;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor( int i = 0; i < firstType.size(); i++)\r\n\t\tfirstType[i].S *= -1;\r\n\tfor( int i = 0; i < secondType.size(); i++)\r\n\t\tsecondType[i].S *= -1;\r\n\r\n\tsort(all(firstType));\r\n\tsort(all(secondType));\r\n\r\n\tfor( int i = 0; i < firstType.size(); i++)\r\n\t\tfirstType[i].S *= -1;\r\n\tfor( int i = 0; i < secondType.size(); i++)\r\n\t\tsecondType[i].S *= -1;\r\n\r\n\t// for( auto i : firstType )\r\n\t// \tcout<<i.F<<\" \"<<i.S<<endl;\r\n\t// cout<<endl;\r\n\t// for( auto i : secondType )\r\n\t// \tcout<<i.F<<\" \"<<i.S<<endl;\r\n\t// cout<<endl;\r\n\r\n\tll j=0,k=0;\r\n\tll cnt = 0;\r\n\tll flip = 0;\r\n\tif(firstType[0].F <= secondType[0].F  && x >= firstType[0].F ){\r\n\r\n\t\tflip = 1;\r\n\t}\r\n\r\n\twhile( j < firstType.size() && k < secondType.size() ){\r\n\r\n\t\tif( flip == 1 ){\r\n\r\n\t\t\tif( x >= firstType[j].F ){\r\n\r\n\t\t\t\tflip = 0;\r\n\t\t\t\tx += firstType[j].S;\r\n\t\t\t\tj++;\r\n\r\n\t\t\t}\r\n\t\t\telse{\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcnt++;\r\n\r\n\t\t}\r\n\t\tif( flip == 0){\r\n\r\n\t\t\tif( x >= secondType[k].F ){\r\n\r\n\t\t\t\tflip = 1;\r\n\t\t\t\tx += secondType[k].S;\r\n\t\t\t\tk++;\r\n\r\n\t\t\t}\r\n\t\t\telse{\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcnt++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif( j < firstType.size() && x >= firstType[j].F && flip == 1){\r\n\t\tx += firstType[j].S;\r\n\t\tcnt++;\r\n\t}\r\n\tif( k < secondType.size() && x >= secondType[k].F && flip == 0)\r\n\t\tcnt++;\r\n\r\n\r\n\tcout<< cnt << endl;\r\n\r\n\t\r\n}\r\n\r\nint main()\r\n{\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n \r\n\t#ifndef ONLINE_JUDGE\r\n\t\tfreopen(\"input.txt\",\"r\",stdin);\r\n\t\tfreopen(\"output.txt\",\"w\",stdout);\r\n\t#endif\r\n\tclock_t z_clock = clock();\r\n\r\n\tll t = 1;\r\n\twhile(t--)\r\n\t{\r\n\t\tsolve();\r\n\t}\r\n\tcerr << \"Run Time : \" << ((double)(clock() - z_clock) / CLOCKS_PER_SEC)<<\" \";\r\n\r\n\treturn 0;\r\n}"
}