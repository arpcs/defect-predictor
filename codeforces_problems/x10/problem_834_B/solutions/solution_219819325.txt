{
    "id": 219819325,
    "contestId": 834,
    "creationTimeSeconds": 1692635838,
    "relativeTimeSeconds": 2238,
    "problem": {
        "contestId": 834,
        "index": "B",
        "name": "The Festive Evening",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1100,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 834,
        "members": [
            {
                "handle": "swami59"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1692633600
    },
    "programmingLanguage": "Java 17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 34,
    "timeConsumedMillis": 249,
    "memoryConsumedBytes": 3584000,
    "source": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.sql.Array;\r\nimport java.util.*;\r\nimport java.io.*;\r\n\r\npublic class bcf{\r\n\r\n\r\n\r\n\r\n    //functions to reduce time\r\n\r\n    public static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\r\n\r\n\r\n\r\n    public static int max=Integer.MAX_VALUE, min=Integer.MIN_VALUE;\r\n    public static long maxl=Long.MAX_VALUE, minl=Long.MIN_VALUE;\r\n    public static long mod=1000000007;\r\n    public static void main(String[] swami) throws FileNotFoundException {\r\n\r\n//        File file = new File(\"/home/swamikedari/Documents/IdeaProjects/cpContests/src/testcases.txt\");\r\n//\r\n//        // Check if the file exists\r\n//        if (file.exists() && !file.isDirectory()) {\r\n//            br= new BufferedReader(new FileReader(file));\r\n//        }\r\n        int t=1;\r\n\r\n\r\n        while(t-->0) {\r\n            int n=getint(), k=getint();\r\n            String val=getstr();\r\n            int[] fr=new int[26];\r\n            char[] ch=val.toCharArray();\r\n            for(int i=0;i<n;i++){\r\n                int ind=ch[i]-'A';\r\n                fr[ind]++;\r\n            }\r\n\r\n            HashMap<Character,Integer> map=new HashMap<>();\r\n            boolean istrue=false;\r\n            for(int i=0;i<n;i++){\r\n                map.put(ch[i],map.getOrDefault(ch[i],0)+1);\r\n\r\n\r\n                if(map.size()>k){\r\n                    istrue=true;\r\n                    break;\r\n                }\r\n                if(map.get(ch[i])==fr[(int)ch[i]-'A']){\r\n                    map.remove(ch[i]);\r\n                }\r\n            }\r\n\r\n            if(istrue){\r\n                println(\"YES\");\r\n            }\r\n            else{\r\n                println(\"NO\");\r\n            }\r\n\r\n\r\n\r\n        }\r\n    }\r\n\r\n\r\n    static StringTokenizer st=new StringTokenizer(\"\");\r\n    static String next() {\r\n        while (!st.hasMoreTokens())\r\n            try {\r\n                st=new StringTokenizer(br.readLine());\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        return st.nextToken();\r\n    }\r\n\r\n\r\n\r\n\r\n    public static int[] getarr(int n){\r\n        int[] a=new int[n];\r\n        for(int i=0;i<n;i++){\r\n            a[i]=getint();\r\n        }\r\n        return a;\r\n    }\r\n\r\n    public static long[] getarrl(int n){\r\n        long[] a=new long[n];\r\n        for(int i=0;i<n;i++){\r\n            a[i]=getlong();\r\n        }\r\n        return a;\r\n    }\r\n    public  static int getint(){\r\n        return Integer.parseInt(next());\r\n    }\r\n\r\n    public  static long getlong(){\r\n        return Long.parseLong(next());\r\n    }\r\n\r\n    public static String getstr(){\r\n        return next();\r\n    }\r\n\r\n    // print statements\r\n\r\n    public static void println(int i){\r\n        System.out.println(i);\r\n    }\r\n    public static void println(String k){\r\n        System.out.println(k);\r\n    }\r\n\r\n    public static void println(long k){\r\n        System.out.println(k);\r\n    }\r\n    public static void println(float k){\r\n        System.out.println(k);\r\n    }\r\n    public static void println(char k){\r\n        System.out.println(k);\r\n    }\r\n    public static void println(double k){System.out.println(k); }\r\n    public static void println(){System.out.println();}\r\n    public static void println(int[] a){\r\n        System.out.println(Arrays.toString(a));\r\n    }\r\n    public static void println(long[] a){\r\n        System.out.println(Arrays.toString(a));\r\n    }\r\n    public static void println(char[] a){\r\n        System.out.println(Arrays.toString(a));\r\n    }\r\n    public static void println(float[] a){\r\n        System.out.println(Arrays.toString(a));\r\n    }\r\n    public static void println(double[] a){\r\n        System.out.println(Arrays.toString(a));\r\n    }\r\n    public static void print(int[] A) {\r\n        for(int i : A) {\r\n            System.out.print(i+\" \");\r\n        }\r\n        System.out.println();\r\n    }\r\n    public static void print(long[] A) {\r\n        for(long i : A) {\r\n            System.out.print(i+\" \");\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n    public static void print(int i){\r\n        System.out.print(i);\r\n    }\r\n    public static void print(String k){\r\n        System.out.print(k);\r\n    }\r\n    public static void print(double k){System.out.print(k); }\r\n    public static void print(long k){\r\n        System.out.print(k);\r\n    }\r\n    public static void print(float k){\r\n        System.out.print(k);\r\n    }\r\n    public static void print(char k){\r\n        System.out.print(k);\r\n    }\r\n\r\n\r\n    // mod by the number\r\n    static long mod(long x) {\r\n        return ((x%mod + mod)%mod);\r\n    }\r\n\r\n    // gcd\r\n    public static long gcd(long i,long j){\r\n        if(i==0){\r\n            return j;\r\n        }\r\n        return gcd(j%i,i);\r\n    }\r\n\r\n    // lcm\r\n    public static long lcm(long i,long j){\r\n        return i*j/gcd(i,j);\r\n    }\r\n\r\n\r\n    public static int gcd(int i,int j){\r\n        if(i==0){\r\n            return j;\r\n        }\r\n        return gcd(j%i,i);\r\n    }\r\n\r\n    // lcm\r\n    public static int lcm(int i,int j){\r\n        return i*j/gcd(i,j);\r\n    }\r\n\r\n    // quick sort\r\n\r\n    public static void quicksort(int[] a,int l,int h){\r\n        if(l<h){\r\n            int pivot=partition(a,l,h);\r\n            quicksort(a,l,pivot-1);\r\n            quicksort(a,pivot+1,h);\r\n        }\r\n    }\r\n\r\n    public static int partition(int[] a,int l,int h){\r\n        int i=l-1;\r\n        int piv=a[h];\r\n        for(int j=l;j<h;j++){\r\n            if(a[j]<piv){\r\n                i++;\r\n                swap(a,i,j);\r\n            }\r\n        }\r\n        swap(a,i+1,h);\r\n        return i+1;\r\n    }\r\n\r\n    public static void quicksortrev(int[] a,int l,int h){\r\n        if(l<h){\r\n            int pivot=partitionrev(a,l,h);\r\n            quicksortrev(a,l,pivot-1);\r\n            quicksortrev(a,pivot+1,h);\r\n        }\r\n    }\r\n\r\n    public static int partitionrev(int[] a,int l,int h){\r\n        int i=l-1;\r\n        int piv=a[h];\r\n        for(int j=l;j<h;j++){\r\n            if(a[j]>piv){\r\n                i++;\r\n                swap(a,i,j);\r\n            }\r\n        }\r\n        swap(a,i+1,h);\r\n        return i+1;\r\n    }\r\n\r\n    public static void swap(int[] a,int i,int j){\r\n        int temp=a[i];\r\n        a[i]=a[j];\r\n        a[j]=temp;\r\n\r\n    }\r\n\r\n\r\n\r\n    // binarysearch for the input and between the input\r\n\r\n    public static int bs(int[] a,int i,int j,int k,int n){\r\n        if(i<=j){\r\n            int mid=mid(i,j);\r\n            if(mid+1<n && a[mid]<=k && a[mid+1]>k){\r\n                return mid;\r\n            }\r\n            else if(a[mid]<=k && mid==n-1){\r\n                return mid;\r\n            }\r\n            else if(a[mid]>k && mid==0){\r\n                return mid;\r\n            }\r\n            else if(a[mid]<k){\r\n                return  bs(a,mid+1,j,k,n);\r\n            }\r\n            else{\r\n                return bs(a,i,mid-1,k,n);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public static int mid(int i,int j){\r\n        return (i+j)/2;\r\n    }\r\n\r\n    public static int bs(long[] a,int i,int j,long  k,int n){\r\n        if(i<=j){\r\n            int mid=mid(i,j);\r\n            if(mid+1<n && a[mid]<=k && a[mid+1]>k){\r\n                return mid;\r\n            }\r\n            else if(a[mid]<=k && mid==n-1){\r\n                return mid;\r\n            }\r\n            else if(a[mid]<k){\r\n                return  bs(a,mid+1,j,k,n);\r\n            }\r\n            else{\r\n                return bs(a,i,mid-1,k,n);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public static long mid(long i,long j){\r\n        return (i+j)/2;\r\n    }\r\n\r\n    // converting the int value to the char value and vice versa\r\n    public static int toint(char a){\r\n        return (int)a-48;\r\n    }\r\n\r\n    public static int tochar(int a){\r\n        return (char)(a+48);\r\n    }\r\n\r\n    // converting the small alphabet characters to index and vice-versa\r\n    public static int chartoint(char a){\r\n        return (int)a-97;\r\n    }\r\n\r\n    public static char inttochar(int a){\r\n        return (char)(a+97);\r\n    }\r\n\r\n\r\n    // important dp problems memoization solutions\r\n\r\n    public static int lcs(String a,String b,int i,int j,int[][] dp){\r\n        if(i<0 || j<0){\r\n            return 0;\r\n        }\r\n        if(dp[i][j]>0){\r\n            return dp[i][j];\r\n        }\r\n        if(a.charAt(i)==b.charAt(j)){\r\n            return dp[i][j]=lcs(a,b,i-1,j-1,dp)+1;\r\n        }\r\n        else{\r\n            return dp[i][j]=Math.max(lcs(a,b,i-1,j,dp),lcs(a,b,i,j-1,dp));\r\n        }\r\n    }\r\n\r\n    // power functions\r\n\r\n    public static long pow(long a,long b){\r\n        long ans=1;\r\n        while(b!=0){\r\n            if(b%2==1){\r\n                ans=(ans*a)%1000000007;\r\n            }\r\n            a=a*a;\r\n            a=a%1000000007;\r\n            b/=2;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n    // min and max functions\r\n\r\n    public static int max(int a, int b){\r\n        return Math.max(a, b);\r\n    }\r\n\r\n    public static int min(int a, int b){\r\n        return Math.min(a, b);\r\n    }\r\n\r\n\r\n    static int max(int[] A) {\r\n        int max=Integer.MIN_VALUE;\r\n        for (int j : A) {\r\n            max = Math.max(max, j);\r\n        }\r\n        return max;\r\n    }\r\n    static int min(int[] A) {\r\n        int min=Integer.MAX_VALUE;\r\n        for (int j : A) {\r\n            min = Math.min(min, j);\r\n        }\r\n        return min;\r\n    }\r\n    static long max(long[] A) {\r\n        long max=Long.MIN_VALUE;\r\n        for (long l : A) {\r\n            max = Math.max(max, l);\r\n        }\r\n        return max;\r\n    }\r\n    static long min(long[] A) {\r\n        long min=Long.MAX_VALUE;\r\n        for (long l : A) {\r\n            min = Math.min(min, l);\r\n        }\r\n        return min;\r\n    }\r\n\r\n    // prime numbers related functions\r\n    public static ArrayList<Integer> sieveOfEratosthenes(int n)\r\n    {\r\n        ArrayList<Integer> primes = new ArrayList<>();\r\n        boolean[] prime = new boolean[n+1];\r\n        for(int i=0;i<=n;i++)\r\n            prime[i] = true;\r\n\r\n        for(int p = 2; p*p <=n; p++)\r\n        {\r\n\r\n            if(prime[p])\r\n            {\r\n\r\n                for(int i = p*p; i <= n; i += p)\r\n                    prime[i] = false;\r\n            }\r\n        }\r\n\r\n\r\n        for(int i = 2; i <= n; i++)\r\n        {\r\n            if(prime[i])\r\n                primes.add(i);\r\n        }\r\n        return primes;\r\n    }\r\n\r\n\r\n    // prefix sum arrays and suffix sum array\r\n\r\n    public static long [] prefix(long [] A) {\r\n        long[] p=new long[A.length];\r\n        p[0]=A[0];\r\n        for(int i=1;i<A.length;i++)\r\n            p[i]=p[i-1]+A[i];\r\n        return p;\r\n    }\r\n    public static long [] prefix(int [] A) {\r\n        long[] p=new long[A.length];\r\n        p[0]=A[0];\r\n        for(int i=1;i<A.length;i++)\r\n            p[i]=p[i-1]+A[i];\r\n        return p;\r\n    }\r\n    public static long [] suffix(long [] A) {\r\n        long[] p=new long[A.length];\r\n        p[A.length-1]=A[A.length-1];\r\n        for(int i=A.length-2;i>=0;i--)\r\n            p[i]=p[i+1]+A[i];\r\n        return p;\r\n    }\r\n    public static long [] suffix(int [] A) {\r\n        long[] p=new long[A.length];\r\n        p[A.length-1]=A[A.length-1];\r\n        for(int i=A.length-2;i>=0;i--)\r\n            p[i]=p[i+1]+A[i];\r\n        return p;\r\n    }\r\n\r\n\r\n    // hash map direct storage using the arrays\r\n\r\n    public static HashMap<Long,Long> hash(long [] A){\r\n        HashMap<Long,Long> map=new HashMap<Long, Long>();\r\n        for(long i : A) {\r\n            if(map.containsKey(i)) {\r\n                map.put(i, map.get(i)+(long)1);\r\n            }\r\n            else {\r\n                map.put(i, (long)1);\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n\r\n    public static HashMap<Integer,Long> hash(int[] A){\r\n        HashMap<Integer,Long> map=new HashMap<Integer, Long>();\r\n        for(int i : A) {\r\n            if(map.containsKey(i)) {\r\n                map.put(i, map.get(i)+(long)1);\r\n            }\r\n            else {\r\n                map.put(i, (long)1);\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n\r\n\r\n    public static HashMap<Character,Long> hash(char [] A){\r\n        HashMap<Character,Long> map=new HashMap<Character,Long>();\r\n        for(char i : A) {\r\n            if(map.containsKey(i)) {\r\n                map.put(i, map.get(i)+(long)1);\r\n            }\r\n            else {\r\n                map.put(i, (long)1);\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n\r\n    // segment tree implementation\r\n    public static int[] array=new int[100005];\r\n    public static int[] segarray=new int[4*100005];\r\n\r\n    public static void buildmax(int ind,int low,int high){\r\n        int mid=mid(low,high);\r\n        if(low==high){\r\n            segarray[ind]=array[low];\r\n        }\r\n        buildmax(2*ind+1,low,mid);\r\n        buildmax(2*ind+2,mid+1,high);\r\n        segarray[ind]=max(array[2*ind+1],array[2*ind+2]);\r\n\r\n    }\r\n\r\n    public static int querymax(int ind,int low,int high,int l,int r){\r\n        if(low>=l && high<=r){\r\n            return segarray[ind];\r\n        }\r\n        if(high<l || low>r){\r\n            return min;\r\n        }\r\n        int mid=mid(low,high);\r\n        int left=querymax(2*ind+1,low,mid,l,r);\r\n        int right=querymax(2*ind+2,mid+1,high,l,r);\r\n        return max(left,right);\r\n    }\r\n\r\n\r\n    public static void buildsum(int ind,int low,int high){\r\n        int mid=mid(low,high);\r\n        if(low==high){\r\n            segarray[ind]=array[low];\r\n        }\r\n        buildsum(2*ind+1,low,high);\r\n        buildsum(2*ind+2,low,high);\r\n        segarray[ind]=segarray[2*ind+1]+segarray[2*ind+2];\r\n    }\r\n\r\n    public static int querysum(int ind,int low,int high,int l,int r){\r\n        if (low >= l && high <= r) {\r\n            return segarray[ind];\r\n        }\r\n        if(high<l || low>r){\r\n            return 0;\r\n        }\r\n        int mid=mid(low,high);\r\n        int left=querysum(2*ind+1,low,mid,l,r);\r\n        int right=querysum(2*ind+2,mid+1,high,l,r);\r\n        return left+right;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}"
}