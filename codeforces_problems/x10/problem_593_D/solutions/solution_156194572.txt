{
    "id": 156194572,
    "contestId": 593,
    "creationTimeSeconds": 1651925343,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 593,
        "index": "D",
        "name": "Happy Tree Party",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2400,
        "tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "math",
            "trees"
        ]
    },
    "author": {
        "contestId": 593,
        "members": [
            {
                "handle": "ProtectEMmm"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1446655500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 58,
    "timeConsumedMillis": 2869,
    "memoryConsumedBytes": 72089600,
    "source": "#pragma GCC optimize(2)\r\n#include<map>\r\n#include<cmath>\r\n#include<ctime>\r\n#include<queue>\r\n#include<cstdio>\r\n#include<vector>\r\n#include<string>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<algorithm>\r\nnamespace IO\r\n{\r\n\tstruct ENDL\r\n\t{\r\n\t\t//By ProtectEMmm\r\n\t}endl;\r\n\tclass IStream\r\n\t{\r\n\tpublic:\r\n\t\tIStream& operator >>(int& temp)\r\n\t\t{\r\n\t\t\ttemp = 0; char c = GetChar(); bool flag = false;\r\n\t\t\twhile (isdigit(c) != true) { if (c == '-')flag = true; c = GetChar(); }\r\n\t\t\twhile (isdigit(c) == true) { temp = temp * 10 + c - '0', c = GetChar(); }\r\n\t\t\t/*========================================*/temp = flag ? -temp : temp; return *this;\r\n\t\t}\r\n\t\tIStream& operator >>(char& temp)\r\n\t\t{\r\n\t\t\ttemp = ' '; char c = GetChar();\r\n\t\t\twhile (ischar(c) != true)c = GetChar();\r\n\t\t\t/*====================*/temp = c; return *this;\r\n\t\t}\r\n\t\tIStream& operator >>(double& temp)\r\n\t\t{\r\n\t\t\ttemp = 0; char c = GetChar(); bool flag = false;\r\n\t\t\twhile (isdigit(c) != true) { if (c == '-')flag = true; c = GetChar(); }\r\n\t\t\twhile (isdigit(c) == true) { temp = temp * 10 + c - '0', c = GetChar(); }\r\n\t\t\tif (c == '.')\r\n\t\t\t{\r\n\t\t\t\tc = GetChar();\r\n\t\t\t\tdouble point = 0.1;\r\n\t\t\t\twhile (isdigit(c) == true)\r\n\t\t\t\t{\r\n\t\t\t\t\ttemp += point * (c - '0');\r\n\t\t\t\t\tpoint *= 0.1; c = GetChar();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttemp = flag ? -temp : temp;\r\n\t\t\t/*==========*/return *this;\r\n\t\t}\r\n\t\tIStream& operator >>(long long& temp)\r\n\t\t{\r\n\t\t\ttemp = 0; char c = GetChar(); bool flag = false;\r\n\t\t\twhile (isdigit(c) != true) { if (c == '-')flag = true; c = GetChar(); }\r\n\t\t\twhile (isdigit(c) == true) { temp = temp * 10 + c - '0', c = GetChar(); }\r\n\t\t\t/*========================================*/temp = flag ? -temp : temp; return *this;\r\n\t\t}\r\n\t\tIStream& operator >>(std::string& temp)\r\n\t\t{\r\n\t\t\ttemp.clear(); char c = GetChar();\r\n\t\t\twhile (ischar(c) != true)c = GetChar();\r\n\t\t\twhile (ischar(c) == true)temp += c, c = GetChar();\r\n\t\t\t/*========================================*/return *this;\r\n\t\t}\r\n\t\tIStream& operator >>(unsigned int& temp)\r\n\t\t{\r\n\t\t\ttemp = 0; char c = GetChar();\r\n\t\t\twhile (isdigit(c) != true)c = GetChar();\r\n\t\t\twhile (isdigit(c) == true)temp = temp * 10 + c - '0', c = GetChar();\r\n\t\t\t/*============================================================*/return *this;\r\n\t\t}\r\n\t\tIStream& operator >>(unsigned long long& temp)\r\n\t\t{\r\n\t\t\ttemp = 0; char c = GetChar();\r\n\t\t\twhile (isdigit(c) != true)c = GetChar();\r\n\t\t\twhile (isdigit(c) == true)temp = temp * 10 + c - '0', c = GetChar();\r\n\t\t\t/*============================================================*/return *this;\r\n\t\t}\r\n\t\tIStream(void)\r\n\t\t{\r\n\t\t\tmemset(BUF, 0, sizeof(BUF));\r\n\t\t\tPOS = BUF, END = BUF;\r\n\t\t}\r\n\tprivate:\r\n\t\tchar BUF[1 << 20];\r\n\t\tchar* POS, * END;\r\n\t\t/*====================*/\r\n\t\tinline char GetChar(void)\r\n\t\t{\r\n\t\t\tif (POS == END)\r\n\t\t\t{\r\n\t\t\t\tEND = (POS = BUF) + fread(BUF, 1, 1 << 20, stdin);\r\n\t\t\t}\r\n\t\t\treturn POS == END ? EOF : *POS++;\r\n\t\t}\r\n\t\tinline bool ischar(const char& c)\r\n\t\t{\r\n\t\t\treturn c != ' ' && c != '\\n';\r\n\t\t}\r\n\t\tinline bool isdigit(const char& c)\r\n\t\t{\r\n\t\t\treturn '0' <= c && c <= '9';\r\n\t\t}\r\n\t}cin;\r\n\tclass OStream\r\n\t{\r\n\tpublic:\r\n\t\t~OStream(void)\r\n\t\t{\r\n\t\t\tFlush();\r\n\t\t}\r\n\t\tinline void Flush(void)\r\n\t\t{\r\n\t\t\tfwrite(BUF, 1, POS - BUF, stdout); POS = BUF;\r\n\t\t}\r\n\t\tinline void SetPoint(int x)\r\n\t\t{\r\n\t\t\tpoint = x;\r\n\t\t}\r\n\t\tOStream& operator <<(int temp)\r\n\t\t{\r\n\t\t\tint Top = 0; static int Stack[64];\r\n\t\t\tif (temp < 0) { PutChar('-'); temp = -temp; }\r\n\t\t\tdo { Stack[Top++] = temp % 10; temp /= 10; } while (temp);\r\n\t\t\twhile (Top) { PutChar(Stack[--Top] + '0'); } return *this;\r\n\t\t}\r\n\t\tOStream& operator <<(char temp)\r\n\t\t{\r\n\t\t\tPutChar(temp); return *this;\r\n\t\t}\r\n\t\tOStream& operator <<(ENDL temp)\r\n\t\t{\r\n\t\t\tPutChar('\\n'); Flush(); return *this;\r\n\t\t}\r\n\t\tOStream& operator <<(double temp)\r\n\t\t{\r\n\t\t\tif (temp < 0)\r\n\t\t\t{\r\n\t\t\t\tPutChar('-');\r\n\t\t\t\ttemp = -temp;\r\n\t\t\t}\r\n\t\t\tlong long integer = temp;\r\n\t\t\t*this << integer;\r\n\t\t\ttemp -= integer;\r\n\t\t\tPutChar('.');\r\n\t\t\tfor (int i = 1; i <= point; ++i)\r\n\t\t\t{\r\n\t\t\t\ttemp *= 10;\r\n\t\t\t\tPutChar(int(temp) + '0');\r\n\t\t\t\ttemp -= int(temp);\r\n\t\t\t}\r\n\t\t\treturn *this;\r\n\t\t}\r\n\t\tOStream& operator <<(long long temp)\r\n\t\t{\r\n\t\t\tint Top = 0; static int Stack[64];\r\n\t\t\tif (temp < 0) { PutChar('-'); temp = -temp; }\r\n\t\t\tdo { Stack[Top++] = temp % 10; temp /= 10; } while (temp);\r\n\t\t\twhile (Top) { PutChar(Stack[--Top] + '0'); } return *this;\r\n\t\t}\r\n\t\tOStream& operator <<(std::string temp)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < temp.size(); ++i)\r\n\t\t\t{\r\n\t\t\t\tPutChar(temp[i]);\r\n\t\t\t}\r\n\t\t\treturn *this;\r\n\t\t}\r\n\t\tOStream& operator <<(const char temp[])\r\n\t\t{\r\n\t\t\tint p = 0;\r\n\t\t\twhile (temp[p] != '\\0')\r\n\t\t\t{\r\n\t\t\t\tPutChar(temp[p++]);\r\n\t\t\t}\r\n\t\t\treturn *this;\r\n\t\t}\r\n\t\tOStream& operator <<(unsigned int temp)\r\n\t\t{\r\n\t\t\tint Top = 0; static int Stack[64];\r\n\t\t\tdo { Stack[Top++] = temp % 10; temp /= 10; } while (temp);\r\n\t\t\twhile (Top) { PutChar(Stack[--Top] + '0'); } return *this;\r\n\t\t}\r\n\t\tOStream& operator <<(unsigned long long temp)\r\n\t\t{\r\n\t\t\tint Top = 0; static int Stack[64];\r\n\t\t\tdo { Stack[Top++] = temp % 10; temp /= 10; } while (temp);\r\n\t\t\twhile (Top) { PutChar(Stack[--Top] + '0'); } return *this;\r\n\t\t}\r\n\t\tOStream(void)\r\n\t\t{\r\n\t\t\tpoint = 6;\r\n\t\t\tmemset(BUF, 0, sizeof(BUF));\r\n\t\t\tPOS = BUF; END = BUF + (1 << 20);\r\n\t\t}\r\n\tprivate:\r\n\t\tint point; char BUF[1 << 20];\r\n\t\tchar* POS, * END;\r\n\t\t/*====================*/\r\n\t\tinline void PutChar(char temp)\r\n\t\t{\r\n\t\t\tif (POS == END)\r\n\t\t\t{\r\n\t\t\t\tFlush();\r\n\t\t\t}\r\n\t\t\t*POS++ = temp;\r\n\t\t}\r\n\t}cout;\r\n}\r\nusing namespace IO;\r\nusing namespace std;\r\n/*====================*/\r\ntypedef long long ll;\r\ntypedef long long lnt;\r\n/*====================*/\r\nconst int N = 2e5 + 10;\r\nconst int M = 2e5 + 10;\r\nconst int INF = 0X7FFFFFFF;\r\n/*====================*/\r\nint n, m;\r\n/*====================*/\r\nvector<int>G[N];\r\nvector<lnt>W[N];\r\n/*====================*/\r\nstruct Edge\r\n{\r\n\tint u, v;\r\n\tEdge(int _u = 0, int _v = 0)\r\n\t{\r\n\t\tu = _u, v = _v;\r\n\t}\r\n};\r\n/*====================*/\r\nEdge edge[N];\r\n/*====================*/\r\nvoid Init(void)\r\n{\r\n\tcin >> n >> m;\r\n\tfor (int i = 2; i <= n; ++i)\r\n\t{\r\n\t\tint u, v; lnt w; \r\n\t\tcin >> u >> v >> w;\r\n\t\tedge[i - 1] = Edge(u, v);\r\n\t\tG[u].push_back(v); G[v].push_back(u);\r\n\t\tW[u].push_back(w); W[v].push_back(w);\r\n\t}\r\n}\r\n/*====================*/\r\nstruct Node\r\n{\r\n\tint pre, dep, siz, son;\r\n\tint top, dfn, idx;\r\n\tlnt val;\r\n\tNode(void)\r\n\t{\r\n\t\tpre = -1; dep = +0;\r\n\t\tsiz = +1; son = -1;\r\n\t\ttop = -1; dfn = +0;\r\n\t\tidx = +0; val = +1;\r\n\t}\r\n};\r\n/*====================*/\r\nNode node[N];\r\n/*====================*/\r\nclass Cut\r\n{\r\npublic:\r\n\tCut(void)\r\n\t{\r\n\t\tcnt = 0;\r\n\t\tDFS1(1, 1); DFS2(1, 1);\r\n\t}\r\nprivate:\r\n\tint cnt;\r\n\t/*====================*/\r\n\tvoid DFS1(int pre, int cur)\r\n\t{\r\n\t\tnode[cur].pre = pre;\r\n\t\tnode[cur].dep = node[pre].dep + 1;\r\n\t\tfor (int i = 0; i < G[cur].size(); ++i)\r\n\t\t{\r\n\t\t\tint nxt = G[cur][i];\r\n\t\t\tif (nxt != pre)\r\n\t\t\t{\r\n\t\t\t\tnode[nxt].val = W[cur][i];\r\n\t\t\t\tDFS1(cur, nxt); node[cur].siz += node[nxt].siz;\r\n\t\t\t\tif (node[cur].son == -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tnode[cur].son = nxt;\r\n\t\t\t\t}\r\n\t\t\t\telse if (node[nxt].siz > node[node[cur].son].siz)\r\n\t\t\t\t{\r\n\t\t\t\t\tnode[cur].son = nxt;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvoid DFS2(int cur, int top)\r\n\t{\r\n\t\tnode[cur].top = top;\r\n\t\tnode[cur].dfn = ++cnt;\r\n\t\tnode[cnt].idx = cur;\r\n\t\tif (node[cur].son != -1)\r\n\t\t{\r\n\t\t\tDFS2(node[cur].son, top);\r\n\t\t\tfor (int i = 0; i < G[cur].size(); ++i)\r\n\t\t\t{\r\n\t\t\t\tint nxt = G[cur][i];\r\n\t\t\t\tif (nxt == node[cur].pre)continue;\r\n\t\t\t\tif (nxt == node[cur].son)continue;\r\n\t\t\t\tDFS2(nxt, nxt);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n/*====================*/\r\nstruct Tree\r\n{\r\n\tint l, r;\r\n\tvector<int>pos;\r\n};\r\n/*====================*/\r\nTree tree[N << 2];\r\n/*====================*/\r\nint ls(int p)\r\n{\r\n\treturn p << 1;\r\n}\r\nint rs(int p)\r\n{\r\n\treturn p << 1 | 1;\r\n}\r\nvoid Build(int p, int l, int r)\r\n{\r\n\ttree[p].l = l, tree[p].r = r;\r\n\tfor (int i = l; i <= r; ++i)\r\n\t{\r\n\t\tint x = node[i].idx;\r\n\t\tif (node[x].val != 1)\r\n\t\t{\r\n\t\t\ttree[p].pos.push_back(x);\r\n\t\t}\r\n\t}\r\n\tsort(tree[p].pos.begin(), tree[p].pos.end());\r\n\tif (tree[p].l != tree[p].r)\r\n\t{\r\n\t\tint mid = (tree[p].l + tree[p].r) >> 1;\r\n\t\tBuild(ls(p), l, mid + 0);\r\n\t\tBuild(rs(p), mid + 1, r);\r\n\t}\r\n}\r\nvoid Delete(int p, int x)\r\n{\r\n\tvector<int>& bst = tree[p].pos;\r\n\tbst.erase(lower_bound(bst.begin(), bst.end(), x));\r\n\tif (tree[p].l != tree[p].r)\r\n\t{\r\n\t\tint mid = (tree[p].l + tree[p].r) >> 1;\r\n\t\tif (node[x].dfn <= mid)Delete(ls(p), x);\r\n\t\tif (mid < node[x].dfn) Delete(rs(p), x);\r\n\t}\r\n}\r\nvoid Ask(int p, int l, int r, vector<int>& pos)\r\n{\r\n\tif (l > r)return;\r\n\tif (l <= tree[p].l && tree[p].r <= r)\r\n\t{\r\n\t\tpos.push_back(p);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint mid = (tree[p].l + tree[p].r) >> 1;\r\n\t\tif (mid < r) Ask(rs(p), l, r, pos);\r\n\t\tif (l <= mid)Ask(ls(p), l, r, pos);\r\n\t}\r\n}\r\n/*====================*/\r\nlnt Ask(int u, int v, lnt val)\r\n{\r\n\tvector<int>uv, vu;\r\n\twhile (node[u].top != node[v].top)\r\n\t{\r\n\t\tint topu = node[u].top;\r\n\t\tint topv = node[v].top;\r\n\t\tif (node[topu].dep > node[topv].dep)\r\n\t\t{\r\n\t\t\tint l = node[topu].dfn;\r\n\t\t\tint r = node[u].dfn;\r\n\t\t\tAsk(1, l, r, uv);\r\n\t\t\tu = node[topu].pre;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint l = node[topv].dfn;\r\n\t\t\tint r = node[v].dfn;\r\n\t\t\tAsk(1, l, r, vu);\r\n\t\t\tv = node[topv].pre;\r\n\t\t}\r\n\t}\r\n\tif (node[u].dep > node[v].dep)\r\n\t{\r\n\t\tint l = node[v].dfn + 1;\r\n\t\tint r = node[u].dfn;\r\n\t\tAsk(1, l, r, uv);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint l = node[u].dfn + 1;\r\n\t\tint r = node[v].dfn;\r\n\t\tAsk(1, l, r, vu);\r\n\t}\r\n\tif (!vu.empty())\r\n\t{\r\n\t\treverse(vu.begin(), vu.end());\r\n\t}\r\n\tfor (int i = 0; i < uv.size() && val; ++i)\r\n\t{\r\n\t\tvector<int>& pos = tree[uv[i]].pos;\r\n\t\tfor (int j = 0; j < pos.size() && val; ++j)\r\n\t\t{\r\n\t\t\tint x = pos[j];\r\n\t\t\tval /= node[x].val;\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i < vu.size() && val; ++i)\r\n\t{\r\n\t\tvector<int>& pos = tree[vu[i]].pos;\r\n\t\tfor (int j = 0; j < pos.size() && val; ++j)\r\n\t\t{\r\n\t\t\tint x = pos[j];\r\n\t\t\tval /= node[x].val;\r\n\t\t}\r\n\t}\r\n\treturn val;\r\n}\r\n/*====================*/\r\nint main()\r\n{\r\n\tInit();\r\n\tCut();\r\n\tBuild(1, 1, n);\r\n\tfor (int i = 1; i <= m; ++i)\r\n\t{\r\n\t\tint op; cin >> op;\r\n\t\tif (op == 1)\r\n\t\t{\r\n\t\t\tint u, v; lnt val;\r\n\t\t\tcin >> u >> v >> val;\r\n\t\t\tcout << Ask(u, v, val) << endl;\r\n\t\t}\r\n\t\tif (op == 2)\r\n\t\t{\r\n\t\t\tint p; lnt val;\r\n\t\t\tcin >> p >> val;\r\n\t\t\tint u = edge[p].u;\r\n\t\t\tint v = edge[p].v;\r\n\t\t\tif (node[u].pre == v)\r\n\t\t\t{\r\n\t\t\t\tif (node[u].val != 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tnode[u].val = val;\r\n\t\t\t\t\tif (node[u].val == 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tDelete(1, u);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (node[v].val != 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tnode[v].val = val;\r\n\t\t\t\t\tif (node[v].val == 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tDelete(1, v);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
}