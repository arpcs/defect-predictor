{
    "id": 211809036,
    "contestId": 765,
    "creationTimeSeconds": 1688290147,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 765,
        "index": "F",
        "name": "Souvenirs",
        "type": "PROGRAMMING",
        "points": 3250.0,
        "rating": 3100,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 765,
        "members": [
            {
                "handle": "ziche"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1487059500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 51,
    "timeConsumedMillis": 1638,
    "memoryConsumedBytes": 47616000,
    "source": "#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <bits/stdc++.h>\n#include <stdio.h>\n#define DESTRUCT2(p, a, b)                                                     \\\n  auto a = get<0>(p);                                                          \\\n  auto b = get<1>(p);\n#define DESTRUCT3(p, a, b, c)                                                  \\\n  auto a = get<0>(p);                                                          \\\n  auto b = get<1>(p);                                                          \\\n  auto c = get<2>(p);\n#define DESTRUCT4(p, a, b, c, d)                                               \\\n  auto a = get<0>(p);                                                          \\\n  auto b = get<1>(p);                                                          \\\n  auto c = get<2>(p);                                                          \\\n  auto d = get<3>(p);\n#define FOR(i, n) for (lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for (lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for (lli i = (j); i >= (lli)(k); --i)\n#define SQ(x) ((x) * (x))\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\nusing namespace std;\ntemplate <typename... As> struct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  template <typename T = tuple<As...>>\n  typename tuple_element<0, T>::type const &x() const {\n    return get<0>(*this);\n  }\n  template <typename T = tuple<As...>> typename tuple_element<0, T>::type &x() {\n    return get<0>(*this);\n  }\n  template <typename T = tuple<As...>>\n  typename tuple_element<1, T>::type const &y() const {\n    return get<1>(*this);\n  }\n  template <typename T = tuple<As...>> typename tuple_element<1, T>::type &y() {\n    return get<1>(*this);\n  }\n  template <typename T = tuple<As...>>\n  typename tuple_element<2, T>::type const &z() const {\n    return get<2>(*this);\n  }\n  template <typename T = tuple<As...>> typename tuple_element<2, T>::type &z() {\n    return get<2>(*this);\n  }\n  template <typename T = tuple<As...>>\n  typename tuple_element<3, T>::type const &w() const {\n    return get<3>(*this);\n  }\n  template <typename T = tuple<As...>> typename tuple_element<3, T>::type &w() {\n    return get<3>(*this);\n  }\n};\nusing lli = int;\nusing llu = long long unsigned;\nusing pii = tpl<lli, lli>;\nusing piii = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi = vector<lli>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\ntemplate <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using max_queue = priority_queue<T>;\ntemplate <size_t... I> struct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = {{I...}};\n};\nnamespace my_index_sequence_detail {\ntemplate <typename I, typename J> struct concat;\ntemplate <size_t... I, size_t... J>\nstruct concat<my_index_sequence<I...>, my_index_sequence<J...>>\n    : my_index_sequence<I..., (sizeof...(I) + J)...> {};\ntemplate <size_t N>\nstruct make_index_sequence\n    : concat<typename make_index_sequence<N / 2>::type,\n             typename make_index_sequence<N - N / 2>::type>::type {};\ntemplate <> struct make_index_sequence<0> : my_index_sequence<> {};\ntemplate <> struct make_index_sequence<1> : my_index_sequence<0> {};\n} // namespace my_index_sequence_detail\ntemplate <class... A>\nusing my_index_sequence_for =\n    typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\ntemplate <class T, size_t... I>\nvoid print_tuple(ostream &s, T const &a, my_index_sequence<I...>) {\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0 ? \"\" : \", \") << get<I>(a)), 0)...};\n}\ntemplate <class T> ostream &print_collection(ostream &s, T const &a);\ntemplate <class... A> ostream &operator<<(ostream &s, tpl<A...> const &a);\ntemplate <class... A> ostream &operator<<(ostream &s, tuple<A...> const &a);\ntemplate <class A, class B>\nostream &operator<<(ostream &s, pair<A, B> const &a);\ntemplate <class T, size_t I>\nostream &operator<<(ostream &s, array<T, I> const &a) {\n  return print_collection(s, a);\n}\ntemplate <class T> ostream &operator<<(ostream &s, vector<T> const &a) {\n  return print_collection(s, a);\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &s, multimap<T, U> const &a) {\n  return print_collection(s, a);\n}\ntemplate <class T> ostream &operator<<(ostream &s, multiset<T> const &a) {\n  return print_collection(s, a);\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &s, map<T, U> const &a) {\n  return print_collection(s, a);\n}\ntemplate <class T> ostream &operator<<(ostream &s, set<T> const &a) {\n  return print_collection(s, a);\n}\ntemplate <class T> ostream &print_collection(ostream &s, T const &a) {\n  s << '[';\n  for (auto it = begin(a); it != end(a); ++it) {\n    s << *it;\n    if (it != prev(end(a)))\n      s << \" \";\n  }\n  return s << ']';\n}\ntemplate <class... A> ostream &operator<<(ostream &s, tpl<A...> const &a) {\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\ntemplate <class... A> ostream &operator<<(ostream &s, tuple<A...> const &a) {\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\ntemplate <class A, class B>\nostream &operator<<(ostream &s, pair<A, B> const &a) {\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\nnamespace std {\nnamespace {\ntemplate <class T> inline void hash_combine(size_t &seed, T const &v) {\n  seed ^= hash<T>()(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\ntemplate <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\nstruct HashValueImpl {\n  static void apply(size_t &seed, Tuple const &tuple) {\n    HashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n    hash_combine(seed, get<Index>(tuple));\n  }\n};\ntemplate <class Tuple> struct HashValueImpl<Tuple, 0> {\n  static void apply(size_t &seed, Tuple const &tuple) {\n    hash_combine(seed, get<0>(tuple));\n  }\n};\n} // namespace\ntemplate <typename... TT> struct hash<tuple<TT...>> {\n  size_t operator()(tuple<TT...> const &tt) const {\n    size_t seed = 0;\n    HashValueImpl<tuple<TT...>>::apply(seed, tt);\n    return seed;\n  }\n};\ntemplate <typename... TT> struct hash<tpl<TT...>> {\n  size_t operator()(tpl<TT...> const &tt) const {\n    size_t seed = 0;\n    HashValueImpl<tuple<TT...>>::apply(seed, tt);\n    return seed;\n  }\n};\n} // namespace std\nlli read_positive() {\n  char c;\n  lli x = 0;\n  do {\n    c = getchar();\n  } while (c < '0' || c > '9');\n  while (c >= '0' && c <= '9') {\n    x = 10 * x + (c - '0');\n    c = getchar();\n  }\n  return x;\n}\nstruct treap;\nusing treap_ptr = treap *;\nstruct treap {\n  treap(pii x_)\n      : l(0), r(0), heap(rand() + RAND_MAX * rand()), x(x_),\n        value(numeric_limits<int>::max()), size(1) {}\n  treap_ptr l, r;\n  lli heap;\n  pii x;\n  lli value;\n  lli nvalue = numeric_limits<int>::max();\n  lli size;\n  static inline lli get_size(treap_ptr a) { return a ? a->size : 0; }\n  static inline void update(treap_ptr a) {\n    if (a) {\n      a->size = 1;\n      if (a->l)\n        a->size += a->l->size;\n      if (a->r)\n        a->size += a->r->size;\n    }\n  }\n  static inline void push(treap_ptr a) {\n    if (a && a->nvalue != numeric_limits<int>::max()) {\n      setMin(a->l, a->nvalue);\n      setMin(a->r, a->nvalue);\n      a->nvalue = numeric_limits<int>::max();\n    }\n  }\n  static inline void setMin(treap_ptr a, lli v) {\n    if (a) {\n      a->value = min(a->value, v);\n      a->nvalue = min(a->nvalue, v);\n    }\n  }\n  static treap_ptr merge(treap_ptr a, treap_ptr b) {\n    if (a == 0)\n      return b;\n    if (b == 0)\n      return a;\n    push(a);\n    push(b);\n    if (a->heap < b->heap) {\n      a->r = merge(a->r, b);\n      update(a);\n      return a;\n    } else {\n      b->l = merge(a, b->l);\n      update(b);\n      return b;\n    }\n  }\n  static tpl<treap_ptr, treap_ptr> split_key(treap_ptr a, pii x) {\n    if (a == 0)\n      return mt(nullptr, nullptr);\n    push(a);\n    if (x <= a->x) {\n      auto p = split_key(a->l, x);\n      a->l = p.y();\n      update(a);\n      return mt(p.x(), a);\n    } else {\n      auto p = split_key(a->r, x);\n      a->r = p.x();\n      update(a);\n      return mt(a, p.y());\n    }\n  }\n  static tpl<treap_ptr, treap_ptr> split_pos(treap_ptr a, lli i) {\n    if (a == 0)\n      return mt(nullptr, nullptr);\n    push(a);\n    if (i <= get_size(a->l)) {\n      auto p = split_pos(a->l, i);\n      a->l = p.y();\n      update(a);\n      return mt(p.x(), a);\n    } else {\n      auto p = split_pos(a->r, i - get_size(a->l) - 1);\n      a->r = p.x();\n      update(a);\n      return mt(a, p.y());\n    }\n  }\n  static treap_ptr insert_key(treap_ptr a, pii x) {\n    auto p = split_key(a, x);\n    return merge(merge(p.x(), new treap(x)), p.y());\n  }\n  static treap_ptr insert_pos(treap_ptr a, lli i, pii x) {\n    auto p = split_pos(a, i);\n    return merge(merge(p.x(), new treap(x)), p.y());\n  }\n};\nstruct segment_tree {\n  struct node {\n    node() {}\n    lli value = -1;\n    void combine(node &a, node &b) { value = max(a.value, b.value); }\n  };\n  int n;\n  vector<node> A;\n  segment_tree(int n_) : n((int)1 << (int)(log2(n_) + 1)), A(2 * n) {}\n  void update(int i) {\n    if (i < n) {\n      A[i].combine(A[2 * i], A[2 * i + 1]);\n    }\n  }\n  void set__(int i, int, int, lli v) { A[i].value = max(A[i].value, v); }\n  void set_(int i, int a, int b, int l, int r, lli v) {\n    if (l > b)\n      return;\n    if (r < a)\n      return;\n    if (l <= a && b <= r) {\n      set__(i, a, b, v);\n      return;\n    }\n    int c = (a + b) / 2;\n    set_(2 * i, a, c, l, r, v);\n    set_(2 * i + 1, c + 1, b, l, r, v);\n    update(i);\n  }\n  void set(int l, int r, lli v) { set_(1, 0, n - 1, l, r, v); }\n  node get_(int i, int a, int b, int l, int r) {\n    if (l > b)\n      return node();\n    if (r < a)\n      return node();\n    if (l <= a && b <= r) {\n      return A[i];\n    }\n    int c = (a + b) / 2;\n    node ar = get_(2 * i, a, c, l, r);\n    node br = get_(2 * i + 1, c + 1, b, l, r);\n    node res;\n    res.combine(ar, br);\n    return res;\n  }\n  lli get(int l, int r) {\n    node a = get_(1, 0, n - 1, l, r);\n    return a.value;\n  }\n};\nstruct BIT {\n  vi A;\n  BIT(lli n) : A(n + 1, numeric_limits<int>::max()) {}\n  lli get(lli i) {\n    i += 1;\n    lli r = numeric_limits<int>::max();\n    for (; i > 0; i -= i & -i) {\n      r = min(r, A[i]);\n    }\n    return r;\n  }\n  void add(lli i, lli v) {\n    i += 1;\n    for (; i < (lli)A.size(); i += i & -i) {\n      A[i] = min(A[i], v);\n    }\n  }\n};\nconst int N = 1e5;\nint A[N];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n#ifndef LOCAL\n  lli n;\n  cin >> n;\n  FOR(i, n) cin >> A[i];\n  lli m;\n  cin >> m;\n  vii Q(m);\n  FOR(i, m) {\n    lli l = 0, r = 0;\n    cin >> l >> r;\n    Q[i] = mt(l - 1, r - 1);\n  };\n#else\n  lli n;\n  n = N;\n  FOR(i, n) A[i] = rand() % ((lli)1e7);\n  lli m;\n  m = 3e5;\n  vii Q(m);\n  FOR(i, m) {\n    lli l = 0, r = 0;\n    while (l >= r) {\n      l = 1 + rand() % n;\n      r = 1 + rand() % n;\n    }\n    Q[i] = mt(l - 1, r - 1);\n  };\n#endif\n  map<pii, lli> ANS;\n  vector<set<int>> LR(n);\n  vector<set<int>> RL(n);\n  FOR(i, m) LR[Q[i].x()].insert(Q[i].y());\n  FOR(i, m) RL[Q[i].y()].insert(Q[i].x());\n  set<lli> ALLX;\n  ALLX.insert(-(numeric_limits<int>::max()));\n  ALLX.insert(numeric_limits<int>::max());\n  FOR(i, n) ALLX.insert(A[i]);\n  vi FROMX;\n  map<lli, lli> TOX;\n  for (lli i : ALLX) {\n    TOX[i] = FROMX.size();\n    FROMX.pb(i);\n  }\n  segment_tree st(TOX.size());\n  BIT bit(n + 10);\n  FOR(i, n) {\n    lli x = A[i];\n    lli x0 = TOX[x];\n    lli l = 0, r = TOX.size() - 1;\n    while (1) {\n      lli j = st.get(l, r);\n      if (j == -1)\n        break;\n      lli y = A[j];\n      lli dt = abs(x - y);\n      bit.add(n - j, dt);\n      if (y == x)\n        break;\n      if (y > x) {\n        lli z = (x + y - 1) / 2;\n        r = prev(TOX.upper_bound(z))->second;\n      } else {\n        lli z = (x + y + 2) / 2;\n        l = TOX.lower_bound(z)->second;\n      }\n    }\n    st.set(x0, x0, i);\n    for (auto l : RL[i]) {\n      ANS[mt(l, i)] = bit.get(n - l);\n    }\n  }\n  FOR(i, m) { cout << ANS[Q[i]] << '\\n'; }\n  return 0;\n}\n\n// RsnPtYDBfwNxplVUOMVydVzjownIySDXQFwHNXqZKPmZPTTkpJCZYKUuZvgQYZmeSFDJCqOrvtPzXrEVjOstNXKgMfCqcLdDqwCmdDyKJaIjfiiAWWxqJUxFxlmWGUbf"
}