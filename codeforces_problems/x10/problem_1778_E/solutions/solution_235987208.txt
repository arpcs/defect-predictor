{
    "id": 235987208,
    "contestId": 1778,
    "creationTimeSeconds": 1701829485,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1778,
        "index": "E",
        "name": "The Tree Has Fallen!",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2500,
        "tags": [
            "bitmasks",
            "dfs and similar",
            "math",
            "trees"
        ]
    },
    "author": {
        "contestId": 1778,
        "members": [
            {
                "handle": "bkifhr6"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1675262100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 280,
    "memoryConsumedBytes": 98304000,
    "source": "//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"unroll-loops\") // remember usage\n#include<iostream>\n#include <bits/stdc++.h>\n#include <ext/numeric>\nusing namespace std;\nusing LL = __int128;\n#include<ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define nd \"\\n\"\n#define all(x) (x).begin(), (x).end()\n#define lol cout <<\"i am here\"<<nd;\n#define py cout <<\"YES\"<<nd;\n#define pp  cout <<\"ppppppppppppppppp\"<<nd;\n#define pn cout <<\"NO\"<<nd;\n#define popcount(x)  __builtin_popcount(x)\n#define clz(n) __builtin_clz(n)//31 -x\nconst  double PI = acos(-1.0);\ndouble EPS = 1e-9;\nconst ll N = 3e5+10, LOG = 30 , inf = 1e16, SQ= 200 , mod=1e9+7, mod2 = 998244353 , P1 = 31 , P2 = 29;\ntemplate<class container> void print(container v) { for (auto& it : v) cout << it << ' ' ;cout <<endl;}\n//template <class Type1 , class Type2>\nll fp(ll a , ll p){ if(!p) return 1; ll v = fp(a , p/2); v*=v;return p & 1 ? v*a : v;  }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nll rand(ll l , ll r) { return uniform_int_distribution<ll>(l, r)(rng); }\ntemplate <typename T> using ordered_set =  tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>;\ntemplate< typename  T > using min_heap = priority_queue <T , vector <T >  , greater < T > >;\nconst ll B1 = 200117 , B2 = 200201;\n//# define int long long // hay brother\n\n\nll mul (ll a, ll b , ll m){\n    return ((a % m) *  (b % m)) % m;\n}\nll add (ll a , ll b , ll m){\n    return (a + b + m ) % m;\n} // x ^ phi(m) is congruent to 1 mod m\n// x ^ (phi -1) is congruent to  x^ -1 mod m\nll Fp (ll b , ll p , ll m){\n    if (!p) return 1;\n    ll v = Fp(b , p >> 1 , m);\n    v = mul(v , v , m);\n    if (p & 1) v = mul(v , b , m);\n    return v;\n}\n\nll modInv(ll n , ll m){\n    return Fp(n , m-2 , m);\n}\n\n\n// E gym  , div1E tor , problem j //  div1 E , div1 D\nint dx[] {0 , 0 , -1 , 1 ,-1 , 1 , 1 , -1};\nint dy[] {-1 , 1 , 0 , 0 , -1 , 1 , -1 , 1};\n\n\nconst int M = 1e6+30;\nll INF = 1e8;\n\n\nstruct basis{ // take care of the size of the basis and the data type // can u use timer idea to solve subarray queries\n    int sz;\n    array < int , LOG+1 > d;//T\n    basis(){\n        sz  = 0; for (int b = 0 ; b <= LOG; ++b) d[b] = 0;\n    }\n    bool bit(int mask, int i){\n        return (mask >> i) & 1;\n    }\n    void push(int mask){\n        for (int b = LOG ; b >= 0 ; -- b){\n            if (!bit(mask, b)) continue;\n            if (!d[b]){\n                d[b] = mask; ++sz;\n                return;\n            }\n            mask ^= d[b];\n        }\n    }\n    ll max_xor(){\n        ll ans = 0;\n        for (int b = LOG; b >= 0 ; --b){\n            if (!bit(ans , b) && d[b]) ans^= d[b];\n        }\n        return ans;\n    }\n    bool check (int mask){\n        for (int b = LOG; b >= 0 ; --b){\n            if (!bit(mask , b)) continue;\n            if (!d[b]) return false;\n            mask^= d[b];\n        }\n        assert(!mask);\n        return true;\n    }\n    ll kth(int k){ // k th in sorted array , k <= 2 ^ sz\n        ll mask = 0;\n        ll tot = (1 << sz); assert(k <= tot);\n        for (int b = LOG; b >= 0 ; --b){\n            if (d[b]) {\n                ll low = tot >> 1;\n                if ((bit(mask, b) && k <= low) || (!bit(mask, b) && k > low)) mask ^= d[b];\n                if (k > low) k -= low;\n                tot = low;\n            }\n        }\n        return mask;\n    }\n    bool empty() {return !sz;}\n};\n\nvector < int > value_of, sz , dep, st, inv;\nvector < vector < int > > g , anc;\nint n , qs , dfn;\nvoid init(){\n    g = vector < vector < int > > (n + 5);\n    inv = sz =dep = st = value_of =vector < int > (n + 5);\n    anc = vector < vector < int > > (n + 5 , vector < int > (LOG+ 1));\n    dfn = 0;\n}\nint en (int u){\n    return st[u] + sz[u] - 1;\n}\n\nvoid merge(basis & u , basis & v){\n    if (v.empty()) return;\n    for (int i = 0 ; i <= LOG; ++i) if (v.d[i]) u.push(v.d[i]);\n}\n\nstruct sss{\n    int n;\n    vector < basis > t;\n    void init(int _n){\n        n = _n + 1;\n        t = vector < basis> (2 * n + 5);\n        build(0 , 1 , n);\n    }\n    void build(int node , int nl , int nr){\n        if (nl + 1 == nr){\n            if(nl <= dfn) t[node].push(value_of[inv[nl]]);\n            return ;\n        }\n        int md = (nl + nr) >> 1;\n        build (2 * node + 1 , nl , md);\n        build(2 * node + 2 , md , nr);\n        merge(t[node] , t[2 * node + 1]);\n        merge(t[node] , t[2 * node + 2]);\n    }\n\n    basis query (int node , int nl , int nr , int ql , int qr){\n        if (nl >= ql && qr >= nr) return t[node];\n        int md = (nl + nr) >> 1;\n        if (qr <= md) return query (2 * node + 1 , nl , md , ql ,qr);\n        else if (ql >= md) return query(2 * node + 2 , md , nr , ql , qr);\n        auto L = query(2 * node + 1 , nl , md , ql , qr);\n        auto R = query(2 * node + 2 , md , nr , ql , qr);\n        merge(L , R);\n        return L;\n    }\n    basis query(int L , int R){\n        if (L > R ) return basis();\n        return query(0 , 1 , n , L , R + 1);\n    }\n};\n\nvoid dfs(int node , int p = 1){\n    inv [st[node] = ++ dfn ] = node; sz[node] = 1;\n    anc[node][0] = p; for (int L = 1; L < LOG; ++L) anc[node][L] = anc[anc[node][L-1]][L-1];\n    for (auto &ch : g[node]){\n        if (ch == p) continue;\n         dep[ch] = 1 + dep[node];\n        dfs(ch , node);\n        sz[node] += sz[ch];\n    }\n}\nint kth(int u , int k){\n    for (int L = LOG-1 ; L >= 0 ; --L) if(k &(1 << L)) u = anc[u][L];\n    return u;\n}\nint lca(int u, int v){\n    if (dep[u] < dep[v]) swap(u, v);\n    u = kth(u , dep[u] - dep[v]);\n    if (u == v) return u;\n    for (int i = LOG - 1; i >= 0 ; --i){\n        if (anc[u][i] ^ anc[v][i]) u = anc[u][i] , v = anc[v][i];\n    }\n    assert(u ^ v && anc[u][0] == anc[v][0]);\n    return anc[u][0];\n}\nbool is (int u , int v){\n    return st[u] <= st[v]  && en(u) >= en(v);\n}\n\nvoid main_(int tc) {\n    cin >> n; init();\n    for (int i = 1; i <= n; ++i) cin >> value_of[i];\n    for (int u , v , i = 1; i < n; ++i){\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    cin >> qs; dfs(1);\n    sss t; t.init(n);\n    while(qs--){\n        int u , v; cin>> u >> v;\n        if (u == v)cout << t.query(1 , n).max_xor() << nd;\n        else if (is(v , u)){\n            int cur = u;\n            for (int L = LOG - 1; L >= 0 ; --L) if (!is(anc[cur][L] , v)) cur = anc[cur][L];\n            assert(is (v , cur));\n            auto ans = t.query(1 , st[cur]-1);\n            auto temp = t.query(en(cur) + 1 , n);\n            merge (ans ,temp);\n            cout << ans.max_xor() << nd;\n        }\n        else{\n            cout << t.query(st[v] , en(v)).max_xor() <<nd;\n        }\n\n    }\n\n\n\n\n\n\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n    //freopen(\"trains.in\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int tt = 1, tc = 0 ;cin >> tt;\n    while (tt--) main_(++tc);\n#ifndef ONLINE_JUDGE\n    cout << \"Running Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s .\\n\";\n#endif\n    return 0;\n}\n\n\n\t  \t\t\t \t\t \t\t\t   \t\t \t  \t\t  \t\t\t\t"
}