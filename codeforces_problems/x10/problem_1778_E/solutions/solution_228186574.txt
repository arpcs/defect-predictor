{
    "id": 228186574,
    "contestId": 1778,
    "creationTimeSeconds": 1697295519,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1778,
        "index": "E",
        "name": "The Tree Has Fallen!",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2500,
        "tags": [
            "bitmasks",
            "dfs and similar",
            "math",
            "trees"
        ]
    },
    "author": {
        "contestId": 1778,
        "members": [
            {
                "handle": "nguyenquocthinhhung"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1675262100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 25,
    "timeConsumedMillis": 202,
    "memoryConsumedBytes": 46899200,
    "source": "#include<bits/stdc++.h>\r\n#define REP(i,first,last) for(int i=(first);i<=(last);++i)\r\n#define DOW(i,first,last) for(int i=(first);(last)<=i;--i)\r\n#define LL long long\r\n#define UI unsigned int\r\n#define ULL unsigned long long\r\n#define PII pair<int,int>\r\n#define PIL pair<int,long long>\r\n#define PLI pair<long long,int>\r\n#define PLL pair<long long,long long>\r\n#define MPR(a,b) make_pair(a,b)\r\n#define CLEAN(a) memset(a,0,sizeof(a))\r\n#define COVER(a,v) memset(a,v,sizeof(a))\r\n#define SURVEILLANCE(type_name) IO::DeBugln(\"On line \",__LINE__,\" \"#type_name\"=\",type_name)\r\n#define YES Writeln(\"YES\");\r\n#define YESR {Writeln(\"YES\");return;}\r\n#define YESR0 {Writeln(\"YES\");return 0;}\r\n#define NO Writeln(\"NO\");\r\n#define NOR {Writeln(\"NO\");return;}\r\n#define NOR0 {Writeln(\"NO\");return 0;}\r\n#ifndef ONLINE_JUDGE\r\n#define GAP IO::DeBugln(\"Gap on line \",__LINE__);fwrite(pbuf,1,pp-pbuf,stdout);IO::pp=IO::pbuf;fclose(stdout);freopen(\"data.out\",\"w\",stdout);\r\n#define STOP IO::DeBugln(\"Stop on line \",__LINE__);fwrite(pbuf,1,pp-pbuf,stdout);fclose(stdout);exit(0);\r\n#else\r\n#define GAP\r\n#define STOP\r\n#endif\r\nconst int INF=1e9;\r\nconst LL INFL=1e18;\r\nnamespace IO\r\n{\r\n// #define GETCHAR_KEY\r\n// #define PUTCHAR_KEY\r\nconst int IN_BUF=1<<23,OUT_BUF=1<<23;\r\nint double_len(6);\r\nbool spacebar_can_see(1);\r\nconst char NUMBER_TO_CHAR[36]={48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90};\r\nconst int CHAR_TO_NUMBER[128]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0};\r\nchar buf[IN_BUF],*ps=buf,*pt=buf,pbuf[OUT_BUF],*pp=pbuf;\r\ntemplate<class T>class Number{public:unsigned int len;int hex;T number;inline Number(const T number=0,const int hex=10,const int len=0):number(number),hex(hex),len(len){}inline operator T()const{return number;}inline Number<T>& operator =(const T &a){number=a;return *this;}};\r\ninline bool CanSee(const char ch){return spacebar_can_see?(31<ch&&ch<127):(32<ch&&ch<127);}\r\ninline bool IsNumber(const char ch){return (47<ch&&ch<58);}\r\ninline bool IsNumber_(const int hex,const char ch){return (47<ch&&ch<48+hex)||(64<ch&&ch<55+hex)||(96<ch&&ch<87+hex);}\r\ninline char GetChar(){\r\n#ifdef GETCHAR_KEY\r\nreturn getchar();\r\n#endif\r\nif(ps==pt){ps=buf;pt=buf+fread(buf,1,IN_BUF,stdin);}return ps==pt?EOF:*ps++;}\r\ninline void PutChar(const char ch){\r\n#ifdef PUTCHAR_KEY\r\nputchar(ch);return;\r\n#endif\r\nif(pp==pbuf+OUT_BUF){fwrite(pbuf,1,OUT_BUF,stdout);pp=pbuf;}*pp++=ch;}\r\nchar read_ch(10);\r\ntemplate<class T>inline T ReadInt(){T x(0);bool f(1);while(!IsNumber(read_ch)&&(~read_ch)){if(read_ch==45){f=0;}read_ch=GetChar();}while(IsNumber(read_ch)&&(~read_ch)){x=(x<<1)+(x<<3)+(read_ch^48);read_ch=GetChar();}return f?x:-x;}\r\ntemplate<class T>inline T ReadUInt(){T x(0);while(!IsNumber(read_ch)&&(~read_ch)){read_ch=GetChar();}while(IsNumber(read_ch)&&(~read_ch)){x=(x<<1)+(x<<3)+(read_ch^48);read_ch=GetChar();}return x;}\r\ntemplate<class T>inline T ReadKInt(const int hex){T x(0);bool f(1);while(!IsNumber_(hex,read_ch)&&(~read_ch)){if(read_ch==45){f=0;}read_ch=GetChar();}while(IsNumber_(hex,read_ch)&&(~read_ch)){x=x*hex+CHAR_TO_NUMBER[read_ch];read_ch=GetChar();}return f?x:-x;}\r\ntemplate<class T>inline T ReadUKInt(const int hex){T x(0);while(!IsNumber_(hex,read_ch)&&(~read_ch)){read_ch=GetChar();}while(IsNumber_(hex,read_ch)&&(~read_ch)){x=x*hex+CHAR_TO_NUMBER[read_ch];read_ch=GetChar();}return x;}\r\ninline double ReadDouble(){long long int_num(ReadInt<long long>());if(read_ch==46){double pow10(1.0),result(0);read_ch=GetChar();while(IsNumber(read_ch)&&(~read_ch)){pow10/=10.0;result+=pow10*(read_ch^48);read_ch=GetChar();}return int_num+(int_num<0?-result:result);}else{return (double)int_num;}}\r\ninline void ReadT(int &x){x=ReadInt<int>();}\r\ninline void ReadT(long long &x){x=ReadInt<long long>();}\r\ninline void ReadT(bool &x){x=ReadUInt<bool>();}\r\ninline void ReadT(unsigned int &x){x=ReadUInt<unsigned int>();}\r\ninline void ReadT(unsigned long long &x){x=ReadUInt<unsigned long long>();}\r\ninline void ReadT(double &x){x=ReadDouble();}\r\ninline void ReadT(char &ch){for(;!CanSee(read_ch)&&(~read_ch);read_ch=GetChar()){};ch=read_ch;read_ch=10;}\r\ninline void ReadT(Number<int> &x){x.number=ReadKInt<int>(x.hex);}\r\ninline void ReadT(Number<long long> &x){x.number=ReadKInt<long long>(x.hex);}\r\ninline void ReadT(Number<unsigned int> &x){x.number=ReadUKInt<unsigned int>(x.hex);}\r\ninline void ReadT(Number<unsigned long long> &x){x.number=ReadUKInt<unsigned long long>(x.hex);}\r\ninline void ReadT(char *s){int len(0);for(;!CanSee(read_ch)&&(~read_ch);read_ch=GetChar()){};for(;CanSee(read_ch)&&(~read_ch);read_ch=GetChar()){s[len++]=read_ch;}s[len]=0;read_ch=10;}\r\ntemplate<class T>inline void Read(T &t){ReadT(t);}\r\ntemplate<class T,class ...Args>void Read(T &t,Args &...args){ReadT(t);Read(args...);}\r\ntemplate<class T>inline void WriteUInt(T x){static char out_number[25];static int cnt;out_number[cnt=1]=x%10^48;while(x/=10){out_number[++cnt]=x%10^48;}while(cnt){PutChar(out_number[cnt--]);}}\r\ntemplate<class T>inline void WriteInt(const T x){if(x<0){PutChar(45);WriteUInt(-x);return;}WriteUInt(x);}\r\ntemplate<class T>\r\ninline void WriteUKInt(T x,const int hex,int len){static char out_number[25];static int cnt;out_number[cnt=1]=NUMBER_TO_CHAR[x%hex];while(x/=hex){out_number[++cnt]=NUMBER_TO_CHAR[x%hex];}len-=cnt;while(0<len--){PutChar(48);}while(cnt){PutChar(out_number[cnt--]);}}\r\ntemplate<class T>inline void WriteKInt(const T x,const int hex,const int len){if(x<0){PutChar(45);WriteUKInt(-x,hex,len-1);return;}WriteUKInt(x,hex,len);}\r\ninline void WriteDouble(double x,int len){if(x<0){PutChar(45);x=-x;}WriteUInt<unsigned long long>((unsigned long long)x);if(len){x-=(int)x;PutChar(46);while(len--){x*=10;if(!(unsigned long long)x){PutChar(48);}}if((unsigned long long)x){WriteUInt<unsigned long long>((unsigned long long)x);}}}\r\ninline void WriteT(const int x){WriteInt<int>(x);}\r\ninline void WriteT(const long long x){WriteInt<long long>(x);}\r\ninline void WriteT(const bool x){PutChar(x|48);}\r\ninline void WriteT(const unsigned int x){WriteUInt<unsigned int>(x);}\r\ninline void WriteT(const unsigned long long x){WriteUInt<unsigned long long>(x);}\r\ninline void WriteT(const double x){WriteDouble(x,double_len);}\r\ninline void WriteT(const char *s){while(*s){PutChar(*s++);}}\r\ninline void WriteT(const char x){PutChar(x);}\r\ninline void WriteT(const Number<int> x){WriteKInt(x.number,x.hex,x.len);}\r\ninline void WriteT(const Number<long long> x){WriteKInt(x.number,x.hex,x.len);}\r\ninline void WriteT(const Number<unsigned int> x){WriteUKInt(x.number,x.hex,x.len);}\r\ninline void WriteT(const Number<unsigned long long> x){WriteUKInt(x.number,x.hex,x.len);}\r\ntemplate<class T>inline void Write(const T t){WriteT(t);}\r\ntemplate<class T,class ...Args>void Write(const T t,const Args ...args){WriteT(t);Write(args...);}\r\ninline void Writeln(){PutChar(10);}\r\ntemplate<class T>inline void Writeln(const T t){WriteT(t);PutChar(10);}\r\ntemplate<class ...Args>inline void Writeln(const Args ...args){Write(args...);PutChar(10);}\r\ntemplate<class ...Args>inline void WriteExit(const Args ...args){Write(args...);PutChar(10);exit(0);}\r\n#ifndef ONLINE_JUDGE\r\ntemplate<class ...Args>inline void DeBug(const Args ...args){Write(args...);}\r\ntemplate<class ...Args>inline void DeBugln(const Args ...args){Writeln(args...);}\r\ninline void DeBugln(){Writeln();}\r\n#else\r\ntemplate<class ...Args>inline void DeBug(const Args ...args){}\r\ntemplate<class ...Args>inline void DeBugln(const Args ...args){}\r\ninline void DeBugln(){}\r\n#endif\r\nclass CodeToDo{public:inline CodeToDo(){\r\n#ifndef ONLINE_JUDGE\r\nfreopen(\"data.in\",\"r\",stdin);freopen(\"data.out\",\"w\",stdout);\r\n#endif\r\nsrand(time(0));}\r\ninline ~CodeToDo(){double_len=3;DeBugln(\"\\nTime=\",(double)clock()/CLOCKS_PER_SEC,\"s\");fwrite(pbuf,1,pp-pbuf,stdout);\r\n#ifndef ONLINE_JUDGE\r\nfclose(stdin);fclose(stdout);\r\n#endif\r\n}}code_to_do;\r\n}\r\ntemplate<typename T>inline T Max(const T a,const T b){return a<b?b:a;}\r\ntemplate<typename T,typename ...Args>T Max(const T a,const Args ...args){return Max(a,Max(args...));}\r\ntemplate<typename T>inline T Min(const T a,const T b){return a<b?a:b;}\r\ntemplate<typename T,typename ...Args>T Min(const T a,const Args ...args){return Min(a,Min(args...));}\r\ntemplate<typename T>inline void Swap(T &a,T &b){T temp=a;a=b;b=temp;}\r\ntemplate<typename T>inline T Abs(const T a){return a<0?-a:a;}\r\nusing namespace IO;\r\nusing namespace std;\r\ntemplate<int MAXN,int MAXM>class Edge\r\n{\r\npublic:\r\n\tinline void AddEdge(const int from,const int to)\r\n\t{\r\n\t\tedge[++edge_cnt].to=to;\r\n\t\tedge[edge_cnt].next=edge_head[from];\r\n\t\tedge_head[from]=edge_cnt;\r\n\t}\r\nprivate:\r\n\tclass Ref\r\n\t{\r\n\tprivate:\r\n\t\tint from;\r\n\t\tEdge *id;\r\n\tpublic:\r\n\t\tinline Ref(Edge* id,const int from):id(id),from(from)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\tinline Ref& operator +=(const int to)\r\n\t\t{\r\n\t\t\tid->AddEdge(from,to);\r\n\t\t\treturn *this;\r\n\t\t}\r\n\t\tinline Ref& operator +=(const Ref&to)\r\n\t\t{\r\n\t\t\tid->AddEdge(from,to.from);\r\n\t\t\treturn *this;\r\n\t\t}\r\n\t};\r\npublic:\r\n\tclass Link\r\n\t{\r\n\tpublic:\r\n\t\tint next,to;\r\n\t}edge[MAXM+1];\r\n\tint edge_head[MAXN+1];\r\n\tint edge_cnt;\r\n\tinline Edge()\r\n\t{\r\n\t\tedge_cnt=0;\r\n\t}\r\n\tinline void operator()(const int from,const int to)\r\n\t{\r\n\t\tedge[++edge_cnt].to=to;\r\n\t\tedge[edge_cnt].next=edge_head[from];\r\n\t\tedge_head[from]=edge_cnt;\r\n\t}\r\n\tinline Ref operator [](const int from)\r\n\t{\r\n\t\treturn Ref(this,from);\r\n\t}\r\n\tinline void Clean(const int n=MAXN,const int m=MAXM)\r\n\t{\r\n\t\tREP(i,1,n)\r\n\t\t{\r\n\t\t\tedge_head[i]=0;\r\n\t\t}\r\n\t\tedge_cnt=0;\r\n\t}\r\n\t#define FOR(now_edge,now) for(int edge_##now_edge##_i=now_edge.edge_head[now];edge_##now_edge##_i;edge_##now_edge##_i=now_edge.edge[edge_##now_edge##_i].next)\r\n\t#define TO(now_edge) now_edge.edge[edge_##now_edge##_i].to\r\n};\r\nnamespace Xor\r\n{\r\n\tint f[30],place[30];\r\n\tinline void Clean()\r\n\t{\r\n\t\tCLEAN(f);\r\n\t\tCLEAN(place);\r\n\t}\r\n\tinline void Insert(int val,int left)\r\n\t{\r\n\t\tDOW(i,29,0)\r\n\t\t{\r\n\t\t\tif(val&(1<<i))\r\n\t\t\t{\r\n\t\t\t\tif(f[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tif(left>place[i])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSwap(left,place[i]);\r\n\t\t\t\t\t\tSwap(f[i],val);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tval^=f[i];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tplace[i]=left;\r\n\t\t\t\t\tf[i]=val;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tinline int Query(const int left)\r\n\t{\r\n\t\tint result=0;\r\n\t\tDOW(i,29,0)\r\n\t\t{\r\n\t\t\tif(place[i]>=left)\r\n\t\t\t{\r\n\t\t\t\tresult=Max(result,result^f[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\nconst int MAXN=2e5+5;\r\nint n,m;\r\nint arr[MAXN];\r\nclass Query\r\n{\r\npublic:\r\n\tint left,right,id;\r\n\tinline Query()\r\n\t{\r\n\r\n\t}\r\n\tinline Query(const int left,const int right,const int id):left(left),right(right),id(id)\r\n\t{\r\n\r\n\t}\r\n\tinline bool operator <(const Query &b)const\r\n\t{\r\n\t\treturn right<b.right;\r\n\t}\r\n};\r\nQuery qu[MAXN];\r\nint dfn[MAXN];\r\nint siz[MAXN];\r\nint cnt=0;\r\nEdge<MAXN,MAXN<<1>e;\r\nint val[MAXN<<1];\r\nint answer[MAXN];\r\nvector<PII>sdfn[MAXN];\r\nvoid DFS(const int now=1,const int father=0)\r\n{\r\n\tdfn[now]=++cnt;\r\n\tval[cnt]=val[cnt+n]=arr[now];\r\n\tsiz[now]=1;\r\n\tFOR(e,now)\r\n\t{\r\n\t\tif(TO(e)^father)\r\n\t\t{\r\n\t\t\tDFS(TO(e),now);\r\n\t\t\tsiz[now]+=siz[TO(e)];\r\n\t\t\tsdfn[now].push_back(MPR(dfn[TO(e)]+siz[TO(e)]-1,dfn[TO(e)]));\r\n\t\t}\r\n\t}\r\n}\r\ninline Query GetRange(const int u,const int root,const int id)\r\n{\r\n\tif(u==root)\r\n\t{\r\n\t\treturn Query(1,n,id);\r\n\t}\r\n\tint l=dfn[u],r=dfn[u]+siz[u]-1;\r\n\tif(l<=dfn[root]&&dfn[root]<=r)\r\n\t{\r\n\t\tPII tops=*upper_bound(sdfn[u].begin(),sdfn[u].end(),MPR(dfn[root],-INF));\r\n\r\n\t\tl=tops.first+1;\r\n\t\tr=n+tops.second-1;\r\n\t\t// Writeln(l,' ',r,' ',tops.first,' ',tops.second,' ',sdfn[u].size());\r\n\t}\r\n\treturn Query(l,r,id);\r\n}\r\ninline void Work()\r\n{\r\n\te.Clean(n,n<<1);\r\n\tXor::Clean();\r\n\tcnt=0;\r\n\tREP(i,1,n)\r\n\t{\r\n\t\tsdfn[i].clear();\r\n\t}\r\n\tRead(n);\r\n\tREP(i,1,n)\r\n\t{\r\n\t\tRead(arr[i]);\r\n\t}\r\n\tint u,v;\r\n\tREP(i,1,n-1)\r\n\t{\r\n\t\tRead(u,v);\r\n\t\te[u]+=e[v]+=u;\r\n\t}\r\n\tDFS();\r\n\tRead(m);\r\n\tREP(i,1,m)\r\n\t{\r\n\t\tRead(v,u);\r\n\t\tqu[i]=GetRange(u,v,i);\r\n\t}\r\n\tsort(qu+1,qu+1+m);\r\n\tint now=1;\r\n\tREP(i,1,n*2)\r\n\t{\r\n\t\tXor::Insert(val[i],i);\r\n\t\twhile(now<=m&&qu[now].right==i)\r\n\t\t{\r\n\t\t\tanswer[qu[now].id]=Xor::Query(qu[now].left);\r\n\t\t\t++now;\r\n\t\t}\r\n\t}\r\n\tREP(i,1,m)\r\n\t{\r\n\t\tWriteln(answer[i]);\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tint t;\r\n\tRead(t);\r\n\twhile(t--)\r\n\t{\r\n\t\tWork();\r\n\t}\r\n\treturn 0;\r\n}"
}