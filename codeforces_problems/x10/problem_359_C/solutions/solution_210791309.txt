{
    "id": 210791309,
    "contestId": 359,
    "creationTimeSeconds": 1687541539,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 359,
        "index": "C",
        "name": "Prime Number",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1900,
        "tags": [
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 359,
        "members": [
            {
                "handle": "matheusdacach"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1383379200
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 4710400,
    "source": "pub mod solution {\n\nuse crate::io::input::Input;\nuse crate::io::output::output;\nuse crate::{out, out_line};\nuse std::collections::BTreeMap;\n\nconst MOD: i64 = 1_000_000_007;\n\nfn solve(input: &mut Input, _test_case: usize) {\n    let (n, x) = (input.read_size(), input.read_long());\n    let exponents: Vec<i64> = input.read_vec(n);\n    let mut count: BTreeMap<i64, i64> = BTreeMap::new();\n    let mut values_to_consider = {\n        let mut res = Vec::with_capacity(n);\n        let sum: i64 = exponents.iter().sum();\n        for e in exponents {\n            res.push(sum - e);\n        }\n        res\n    };\n    for e in values_to_consider {\n        let c = count.entry(e).or_default();\n        *c += 1;\n        if *c == x {\n            *c = 0;\n            let next = count.entry(e + 1).or_default();\n            *next += 1;\n        }\n    }\n\n    let binary_exponentiation = |mut b: i64, mut e: i64, m: i64| {\n        let mut res = 1;\n        while e != 0 {\n            if e & 1 == 1 {\n                res = (res * b) % m;\n            }\n            b = b * b;\n            e /= 2;\n        }\n        res\n    };\n\n    let smallest = count\n        .into_iter()\n        .filter(|&(e, c)| c != 0)\n        .map(|(e, c)| e)\n        .min()\n        .unwrap();\n    out_line!(binary_exponentiation(x, smallest, MOD));\n}\n\npub(crate) fn run(mut input: Input) -> bool {\n    solve(&mut input, 1);\n    output().flush();\n    input.skip_whitespace();\n    input.peek().is_none()\n}\n\n}\npub mod io {\npub mod input {\nuse crate::numbers::num_traits::add_sub::AddSub;\nuse crate::numbers::num_traits::from_u8::FromU8;\nuse crate::numbers::num_traits::mul_div_rem::Multable;\nuse crate::numbers::num_traits::sign::IsSigned;\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse crate::when;\nuse std::collections::VecDeque;\nuse std::fmt::Display;\nuse std::io::Read;\nuse std::marker::PhantomData;\nuse std::ops::Deref;\n\nmacro_rules! read_impl {\n    ($t: ty, $read_name: ident, $read_vec_name: ident) => {\n        pub fn $read_name(&mut self) -> $t {\n            self.read()\n        }\n\n        pub fn $read_vec_name(&mut self, len: usize) -> Vec<$t> {\n            self.read_vec(len)\n        }\n    };\n\n    ($t: ty, $read_name: ident, $read_vec_name: ident, $read_pair_vec_name: ident) => {\n        read_impl!($t, $read_name, $read_vec_name);\n\n        pub fn $read_pair_vec_name(&mut self, len: usize) -> Vec<($t, $t)> {\n            self.read_vec(len)\n        }\n    };\n}\n\npub struct Input<'s> {\n    input: &'s mut dyn Read,\n    buf: Vec<u8>,\n    at: usize,\n    buf_read: usize,\n}\n\nimpl<'s> Input<'s> {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(input: &'s mut dyn Read) -> Self {\n        Self {\n            input,\n            buf: vec![0; Self::DEFAULT_BUF_SIZE],\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn new_with_size(input: &'s mut dyn Read, buf_size: usize) -> Self {\n        Self {\n            input,\n            buf: vec![0; buf_size],\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn get(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            self.at += 1;\n            if res == b'\\r' {\n                if self.refill_buffer() && self.buf[self.at] == b'\\n' {\n                    self.at += 1;\n                }\n                return Some(b'\\n');\n            }\n            Some(res)\n        } else {\n            None\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            Some(if res == b'\\r' { b'\\n' } else { res })\n        } else {\n            None\n        }\n    }\n\n    pub fn skip_whitespace(&mut self) {\n        while let Some(b) = self.peek() {\n            if !char::from(b).is_whitespace() {\n                return;\n            }\n            self.get();\n        }\n    }\n\n    pub fn next_token(&mut self) -> Option<Vec<u8>> {\n        self.skip_whitespace();\n        let mut res = Vec::new();\n        while let Some(c) = self.get() {\n            if char::from(c).is_whitespace() {\n                break;\n            }\n            res.push(c);\n        }\n        if res.is_empty() {\n            None\n        } else {\n            Some(res)\n        }\n    }\n\n    //noinspection RsSelfConvention\n    pub fn is_exhausted(&mut self) -> bool {\n        self.peek().is_none()\n    }\n\n    pub fn read<T: Readable>(&mut self) -> T {\n        T::read(self)\n    }\n\n    pub fn read_vec<T: Readable>(&mut self, size: usize) -> Vec<T> {\n        let mut res = Vec::with_capacity(size);\n        for _ in 0usize..size {\n            res.push(self.read());\n        }\n        res\n    }\n\n    pub fn read_line(&mut self) -> String {\n        let mut res = String::new();\n        while let Some(c) = self.get() {\n            if c == b'\\n' {\n                break;\n            }\n            res.push(c.into());\n        }\n        res\n    }\n\n    pub fn iter<'t, T: Readable + 't + 's>(&'t mut self) -> InputIterator<'t, 's, T>\n    where\n        's: 't,\n    {\n        InputIterator {\n            input: self,\n            phantom: Default::default(),\n        }\n    }\n\n    fn read_integer<T: IsSigned + ZeroOne + FromU8 + AddSub + Multable + Display>(&mut self) -> T {\n        self.skip_whitespace();\n        let mut c = self.get().unwrap();\n        let sgn = when! {\n            c == b'-' => {\n                if !T::SIGNED {\n                    panic!(\"negative integer\")\n                }\n                c = self.get().unwrap();\n                true\n            },\n            c == b'+' => {\n                c = self.get().unwrap();\n                false\n            },\n            else => false,\n        };\n        let mut res = T::zero();\n        loop {\n            if !c.is_ascii_digit() {\n                panic!(\n                    \"expected integer, found {}{}{}\",\n                    if sgn { \"-\" } else { \"\" },\n                    res,\n                    c as char\n                );\n            }\n            res *= T::from_u8(10);\n            res += T::from_u8(c - b'0');\n            match self.get() {\n                None => break,\n                Some(ch) => {\n                    if char::from(ch).is_whitespace() {\n                        break;\n                    } else {\n                        c = ch;\n                    }\n                }\n            }\n        }\n        if sgn {\n            debug_assert!(T::SIGNED);\n            res = T::zero() - res\n        }\n        res\n    }\n\n    pub fn read_string(&mut self) -> String {\n        match self.next_token() {\n            None => {\n                panic!(\"Input exhausted\");\n            }\n            Some(res) => unsafe { String::from_utf8_unchecked(res) },\n        }\n    }\n\n    pub fn read_char(&mut self) -> char {\n        self.skip_whitespace();\n        self.get().unwrap().into()\n    }\n\n    read_impl!(u8, read_u8, read_u8_vec);\n    read_impl!(u16, read_u16, read_u16_vec);\n    read_impl!(u32, read_unsigned, read_unsigned_vec);\n    read_impl!(u64, read_u64, read_u64_vec);\n    read_impl!(u128, read_u128, read_u128_vec);\n    read_impl!(usize, read_size, read_size_vec, read_size_pair_vec);\n    read_impl!(i8, read_i8, read_i8_vec);\n    read_impl!(i16, read_i16, read_i16_vec);\n    read_impl!(i32, read_int, read_int_vec, read_int_pair_vec);\n    read_impl!(i64, read_long, read_long_vec, read_long_pair_vec);\n    read_impl!(i128, read_i128, read_i128_vec);\n    read_impl!(isize, read_isize, read_isize_vec);\n    read_impl!(f64, read_float, read_float_vec);\n\n    fn read_float_impl(&mut self) -> f64 {\n        self.read::<String>().parse().unwrap()\n    }\n\n    fn refill_buffer(&mut self) -> bool {\n        if self.at == self.buf_read {\n            self.at = 0;\n            self.buf_read = self.input.read(&mut self.buf).unwrap();\n            self.buf_read != 0\n        } else {\n            true\n        }\n    }\n\n    pub fn parse(&mut self, pattern: &str, special: char) -> VecDeque<Vec<u8>> {\n        let mut res = VecDeque::new();\n        let mut last_special = false;\n\n        fn parse_special(input: &mut Input, c: char) -> Vec<u8> {\n            let mut cur = Vec::new();\n            loop {\n                let next = input.get();\n                if c == '\\n' {\n                    if let Some(next) = next {\n                        match next {\n                            b'\\r' => {\n                                if input.peek() == Some(b'\\n') {\n                                    input.get();\n                                }\n                                break;\n                            }\n                            b'\\n' => break,\n                            _ => cur.push(next),\n                        }\n                    } else {\n                        break;\n                    }\n                } else {\n                    let next = next.unwrap();\n                    if next == c as u8 {\n                        break;\n                    } else {\n                        cur.push(next);\n                    }\n                }\n            }\n            cur\n        }\n\n        for c in pattern.chars() {\n            if c == special {\n                assert!(!last_special);\n                last_special = true;\n            } else {\n                if last_special {\n                    res.push_back(parse_special(self, c));\n                } else {\n                    let next = self.get();\n                    if c == '\\n' {\n                        if let Some(next) = next {\n                            if next == b'\\r' {\n                                if self.peek() == Some(b'\\n') {\n                                    self.get();\n                                }\n                            } else {\n                                assert_eq!(next, b'\\n');\n                            }\n                        }\n                    } else {\n                        assert_eq!(c as u8, next.unwrap());\n                    }\n                }\n                last_special = false;\n            }\n        }\n        if last_special {\n            res.push_back(parse_special(self, '\\n'));\n        }\n        res\n    }\n}\n\npub struct InputIterator<'t, 's: 't, T: Readable + 't + 's> {\n    input: &'t mut Input<'s>,\n    phantom: PhantomData<T>,\n}\n\nimpl<'t, 's: 't, T: Readable + 't + 's> Iterator for InputIterator<'t, 's, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.input.skip_whitespace();\n        self.input.peek().map(|_| self.input.read())\n    }\n}\n\npub trait Readable {\n    fn read(input: &mut Input) -> Self;\n}\n\nimpl Readable for String {\n    fn read(input: &mut Input) -> Self {\n        input.read_string()\n    }\n}\n\nimpl Readable for char {\n    fn read(input: &mut Input) -> Self {\n        input.read_char()\n    }\n}\n\nimpl Readable for f64 {\n    fn read(input: &mut Input) -> Self {\n        input.read_float_impl()\n    }\n}\n\nimpl<T: Readable> Readable for Vec<T> {\n    fn read(input: &mut Input) -> Self {\n        let size = input.read();\n        input.read_vec(size)\n    }\n}\n\npub struct EolString(pub String);\n\nimpl Readable for EolString {\n    fn read(input: &mut Input) -> Self {\n        EolString(input.read_line())\n    }\n}\n\nimpl Deref for EolString {\n    type Target = String;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nmacro_rules! read_integer {\n    ($($t:ident)+) => {$(\n        impl Readable for $t {\n            fn read(input: &mut Input) -> Self {\n                input.read_integer()\n            }\n        }\n    )+};\n}\n\nread_integer!(i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);\n\nmacro_rules! tuple_readable {\n    ($($name:ident)+) => {\n        impl<$($name: Readable), +> Readable for ($($name,)+) {\n            fn read(input: &mut Input) -> Self {\n                ($($name::read(input),)+)\n            }\n        }\n    }\n}\n\ntuple_readable! {T}\ntuple_readable! {T U}\ntuple_readable! {T U V}\ntuple_readable! {T U V X}\ntuple_readable! {T U V X Y}\ntuple_readable! {T U V X Y Z}\ntuple_readable! {T U V X Y Z A}\ntuple_readable! {T U V X Y Z A B}\ntuple_readable! {T U V X Y Z A B C}\ntuple_readable! {T U V X Y Z A B C D}\ntuple_readable! {T U V X Y Z A B C D E}\ntuple_readable! {T U V X Y Z A B C D E F}\n\n#[macro_export]\nmacro_rules! scan {\n    ($input: expr, $s: expr) => {\n        $crate::scan!($input, s,);\n    };\n    ($input: expr, $s: expr $(, $v:ident: $t: ty)* $(,)?) => {\n        $crate::scan!($input, $s, '@', $($v: $t,)*);\n    };\n    ($input: expr, $s: expr, $sp: expr $(, $v:ident: $t: ty)* $(,)?) => {\n        let mut res = $input.parse($s, $sp);\n        $(\n            let cur = res.pop_front().unwrap();\n            let len = cur.len();\n            let mut slice = cur.as_slice();\n            let mut input = Input::new_with_size(&mut slice, len);\n            let $v: $t = input.read();\n            assert!(input.is_exhausted());\n        )*\n    };\n}\n}\npub mod output {\nuse std::io::Write;\n\n#[derive(Copy, Clone)]\npub enum BoolOutput {\n    YesNo,\n    YesNoCaps,\n    PossibleImpossible,\n    Custom(&'static str, &'static str),\n}\n\nimpl BoolOutput {\n    pub fn output(&self, output: &mut Output, val: bool) {\n        (if val { self.yes() } else { self.no() }).write(output);\n    }\n\n    fn yes(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"Yes\",\n            BoolOutput::YesNoCaps => \"YES\",\n            BoolOutput::PossibleImpossible => \"Possible\",\n            BoolOutput::Custom(yes, _) => yes,\n        }\n    }\n\n    fn no(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"No\",\n            BoolOutput::YesNoCaps => \"NO\",\n            BoolOutput::PossibleImpossible => \"Impossible\",\n            BoolOutput::Custom(_, no) => no,\n        }\n    }\n}\n\npub struct Output {\n    output: Box<dyn Write>,\n    buf: Vec<u8>,\n    at: usize,\n    auto_flush: bool,\n    bool_output: BoolOutput,\n}\n\nimpl Output {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(output: Box<dyn Write>) -> Self {\n        Self {\n            output,\n            buf: vec![0; Self::DEFAULT_BUF_SIZE],\n            at: 0,\n            auto_flush: false,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn new_with_auto_flush(output: Box<dyn Write>) -> Self {\n        Self {\n            output,\n            buf: vec![0; Self::DEFAULT_BUF_SIZE],\n            at: 0,\n            auto_flush: true,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn flush(&mut self) {\n        if self.at != 0 {\n            self.output.write_all(&self.buf[..self.at]).unwrap();\n            self.output.flush().unwrap();\n            self.at = 0;\n        }\n    }\n\n    pub fn print<T: Writable>(&mut self, s: &T) {\n        s.write(self);\n    }\n\n    pub fn put(&mut self, b: u8) {\n        self.buf[self.at] = b;\n        self.at += 1;\n        if self.at == self.buf.len() {\n            self.flush();\n        }\n    }\n\n    pub fn maybe_flush(&mut self) {\n        if self.auto_flush {\n            self.flush();\n        }\n    }\n\n    pub fn print_per_line<T: Writable>(&mut self, arg: &[T]) {\n        for i in arg {\n            i.write(self);\n            self.put(b'\\n');\n        }\n    }\n\n    pub fn print_iter<T: Writable, I: Iterator<Item = T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n\n    pub fn print_iter_ref<'a, T: 'a + Writable, I: Iterator<Item = &'a T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n}\n\npub fn set_bool_output(bool_output: BoolOutput) {\n    output().bool_output = bool_output\n}\n\nimpl Write for Output {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let mut start = 0usize;\n        let mut rem = buf.len();\n        while rem > 0 {\n            let len = (self.buf.len() - self.at).min(rem);\n            self.buf[self.at..self.at + len].copy_from_slice(&buf[start..start + len]);\n            self.at += len;\n            if self.at == self.buf.len() {\n                self.flush();\n            }\n            start += len;\n            rem -= len;\n        }\n        if self.auto_flush {\n            self.flush();\n        }\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.flush();\n        Ok(())\n    }\n}\n\npub trait Writable {\n    fn write(&self, output: &mut Output);\n}\n\nimpl Writable for &str {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for String {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for char {\n    fn write(&self, output: &mut Output) {\n        output.put(*self as u8);\n    }\n}\n\nimpl<T: Writable> Writable for &[T] {\n    fn write(&self, output: &mut Output) {\n        output.print_iter_ref(self.iter());\n    }\n}\n\nimpl<T: Writable> Writable for &T {\n    fn write(&self, output: &mut Output) {\n        T::write(self, output)\n    }\n}\n\nimpl<T: Writable> Writable for Vec<T> {\n    fn write(&self, output: &mut Output) {\n        (&self[..]).write(output);\n    }\n}\n\nmacro_rules! write_to_string {\n    ($($t:ident)+) => {$(\n        impl Writable for $t {\n            fn write(&self, output: &mut Output) {\n                self.to_string().write(output);\n            }\n        }\n    )+};\n}\n\nwrite_to_string!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize f32 f64);\n\nimpl<T: Writable, U: Writable> Writable for (T, U) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n    }\n}\n\nimpl<T: Writable, U: Writable, V: Writable> Writable for (T, U, V) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n        output.put(b' ');\n        self.2.write(output);\n    }\n}\n\nimpl<T: Writable, U: Writable, V: Writable, W: Writable> Writable for (T, U, V, W) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n        output.put(b' ');\n        self.2.write(output);\n        output.put(b' ');\n        self.3.write(output);\n    }\n}\n\nimpl<T: Writable, U: Writable, V: Writable, W: Writable, X: Writable> Writable for (T, U, V, W, X) {\n    fn write(&self, output: &mut Output) {\n        self.0.write(output);\n        output.put(b' ');\n        self.1.write(output);\n        output.put(b' ');\n        self.2.write(output);\n        output.put(b' ');\n        self.3.write(output);\n        output.put(b' ');\n        self.4.write(output);\n    }\n}\n\nimpl<T: Writable> Writable for Option<T> {\n    fn write(&self, output: &mut Output) {\n        match self {\n            None => (-1).write(output),\n            Some(t) => t.write(output),\n        }\n    }\n}\n\nimpl Writable for bool {\n    fn write(&self, output: &mut Output) {\n        let bool_output = output.bool_output;\n        bool_output.output(output, *self)\n    }\n}\n\npub static mut OUTPUT: Option<Output> = None;\n\npub fn output() -> &'static mut Output {\n    unsafe {\n        match &mut OUTPUT {\n            None => {\n                panic!(\"Panic\");\n            }\n            Some(output) => output,\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! out {\n    ($first: expr $(,$args:expr )*) => {\n        $crate::io::output::output().print(&$first);\n        $($crate::io::output::output().put(b' ');\n        $crate::io::output::output().print(&$args);\n        )*\n        $crate::io::output::output().maybe_flush();\n    }\n}\n\n#[macro_export]\nmacro_rules! out_line {\n    ($first: expr $(, $args:expr )* ) => {\n        $crate::out!($first $(,$args)*);\n        $crate::io::output::output().put(b'\\n');\n        $crate::io::output::output().maybe_flush();\n    };\n    () => {\n        output().put(b'\\n');\n        output().maybe_flush();\n    };\n}\n}\n}\npub mod misc {\npub mod when {\n#[macro_export]\nmacro_rules! when {\n    {$($cond: expr => $then: expr,)*} => {\n        match () {\n            $(_ if $cond => $then,)*\n            _ => unreachable!(),\n        }\n    };\n    {$($cond: expr => $then: expr,)* else $(=>)? $else: expr,} => {\n        match () {\n            $(_ if $cond => $then,)*\n            _ => $else,\n        }\n    };\n}\n}\n}\npub mod numbers {\npub mod num_traits {\npub mod add_sub {\nuse std::ops::{Add, AddAssign, Sub, SubAssign};\n\npub trait Addable: Add<Output = Self> + AddAssign + Copy {}\nimpl<T: Add<Output = Self> + AddAssign + Copy> Addable for T {}\n\npub trait AddSub: Addable + Sub<Output = Self> + SubAssign {}\nimpl<T: Addable + Sub<Output = Self> + SubAssign> AddSub for T {}\n}\npub mod from_u8 {\npub trait FromU8 {\n    fn from_u8(val: u8) -> Self;\n}\n\nmacro_rules! from_u8_impl {\n    ($($t: ident)+) => {$(\n        impl FromU8 for $t {\n            fn from_u8(val: u8) -> Self {\n                val as $t\n            }\n        }\n    )+};\n}\n\nfrom_u8_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize f32 f64);\n}\npub mod mul_div_rem {\nuse std::ops::{Div, DivAssign, Mul, MulAssign, Rem, RemAssign};\n\npub trait Multable: Mul<Output = Self> + MulAssign + Copy {}\nimpl<T: Mul<Output = Self> + MulAssign + Copy> Multable for T {}\n\npub trait MulDiv: Multable + Div<Output = Self> + DivAssign {}\nimpl<T: Multable + Div<Output = Self> + DivAssign> MulDiv for T {}\n\npub trait MulDivRem: MulDiv + Rem<Output = Self> + RemAssign {}\nimpl<T: MulDiv + Rem<Output = Self> + RemAssign> MulDivRem for T {}\n}\npub mod sign {\npub trait IsSigned {\n    const SIGNED: bool;\n}\n\npub trait Signed: IsSigned {}\n\npub trait Unsigned: IsSigned {\n    fn distance(self, other: Self) -> Self;\n}\n\nmacro_rules! unsigned_impl {\n    ($($t: ident)+) => {$(\n        impl Unsigned for $t {\n            fn distance(self, other: Self) -> Self {\n                if self > other {\n                    self - other\n                } else {\n                    other - self\n                }\n            }\n        }\n\n        impl IsSigned for $t {\n            const SIGNED: bool = false;\n        }\n    )+};\n}\n\nunsigned_impl!(u128 u64 u32 u16 u8 usize);\n\nmacro_rules! signed_impl {\n    ($($t: ident)+) => {$(\n        impl Signed for $t {}\n\n        impl IsSigned for $t {\n            const SIGNED: bool = true;\n        }\n    )+};\n}\n\nsigned_impl!(i128 i64 i32 i16 i8 isize f64 f32);\n}\npub mod zero_one {\npub trait ZeroOne {\n    fn zero() -> Self;\n    fn one() -> Self;\n}\n\nmacro_rules! zero_one_integer_impl {\n    ($($t: ident)+) => {$(\n        impl ZeroOne for $t {\n            fn zero() -> Self {\n                0\n            }\n\n            fn one() -> Self {\n                1\n            }\n        }\n    )+};\n}\n\nzero_one_integer_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize);\n\nmacro_rules! zero_one_float_impl {\n    ($($t: ident)+) => {$(\n        impl ZeroOne for $t {\n            fn zero() -> Self {\n                0.\n            }\n\n            fn one() -> Self {\n                1.\n            }\n        }\n    )+};\n}\n\nzero_one_float_impl!(f32 f64);\n}\n}\n}\nfn main() {\n    let mut sin = std::io::stdin();\n    let input = crate::io::input::Input::new(&mut sin);\n    unsafe {\n        crate::io::output::OUTPUT = Some(crate::io::output::Output::new(Box::new(std::io::stdout())));\n    }\n    crate::solution::run(input);\n}\n"
}