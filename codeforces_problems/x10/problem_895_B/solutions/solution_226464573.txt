{
    "id": 226464573,
    "contestId": 895,
    "creationTimeSeconds": 1696346624,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 895,
        "index": "B",
        "name": "XK Segments",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1700,
        "tags": [
            "binary search",
            "math",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 895,
        "members": [
            {
                "handle": "NerfThis"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1511712300
    },
    "programmingLanguage": "Java 8",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "//package practices.level1700;\r\n\r\nimport practices.level1600.week6.P;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\nimport static java.lang.Math.*;\r\n\r\npublic class B895 {\r\n    static InputReader in;\r\n    static PrintWriter out;\r\n\r\n    public static void main(String[] args) {\r\n        //initReaderPrinter(true);\r\n        initReaderPrinter(false);\r\n        //solve(in.nextInt());\r\n        solve(1);\r\n    }  \r\n    \r\n    /*\r\n        General tips\r\n        1. It is ok to fail, but it is not ok to fail for the same mistakes over and over!\r\n        2. Train smarter, not harder!\r\n        3. If you find an answer and want to return immediately, don't forget to flush before return!\r\n    */\r\n    /*\r\n        Read before practice\r\n        1. Set a timer based on a problem's difficulty level: 45 minutes at your current target practice level;\r\n        2. During a problem solving session, focus! Do not switch problems or even worse switch to do something else;\r\n        3. If fail to solve within timer limit, read editorials to get as little help as possible to get yourself unblocked;\r\n        4. If after reading the entire editorial and other people's code but still can not solve, move this problem to to-do list\r\n           and re-try in the future.\r\n        5. Keep a practice log about new thinking approaches, good tricks, bugs; Review regularly;\r\n        6. Also try this new approach suggested by um_nik: Solve with no intention to read editorial.\r\n           If getting stuck, skip it and solve other similar level problems.\r\n           Wait for 1 week then try to solve again. Only read editorial after you solved a problem.\r\n        7. Remember to also submit in the original problem link (if using gym) so that the 1 v 1 bot knows which problems I have solved already.\r\n        8. Form the habit of writing down an implementable solution idea before coding! You've taken enough hits during contests because you\r\n        rushed to coding!\r\n    */\r\n    /*\r\n        Read before contests and lockout 1 v 1\r\n        Mistakes you've made in the past contests:\r\n        1. Tried to solve without going through given test examples -> wasting time on solving a different problem than asked;\r\n        2. Rushed to coding without getting a comprehensive sketch of your solution -> implementation bugs and WA; Write down your idea step\r\n        by step, no need to rush. It is always better to have all the steps considered before hand! Think about all the past contests that\r\n        you have failed because slow implementation and implementation bugs! This will be greatly reduced if you take your time to get a\r\n        thorough idea steps!\r\n        3. Forgot about possible integer overflow;\r\n\r\n        When stuck:\r\n        1. Understand problem statements? Walked through test examples?\r\n        2. Take a step back and think about other approaches?\r\n        3. Check rank board to see if you can skip to work on a possibly easier problem?\r\n        4. If none of the above works, take a guess?\r\n        5. Any chance you got WA due to integer overflow, especially if you are dealing with all subarrays. The sum \r\n           can get deceptively large! If in doubt, just use long instead of int.\r\n    */\r\n\r\n    static void solve(int testCnt) {\r\n        for (int testNumber = 0; testNumber < testCnt; testNumber++) {\r\n            int n = in.nextInt(), x = in.nextInt(), k = in.nextInt();\r\n            Integer[] a = in.nextIntArray(n);\r\n            Arrays.sort(a);\r\n            long ans = 0;\r\n            //for a given a[i], bs to find the leftmost l and rightmost r s.t l, r <= i and there are k numbers that are divisible by x, add r - l + 1 to ans\r\n            //if k > 1, then no need to consider (i, l/r); if k == 1, then we need to consider:  if a[i] % x == 0, add the cnt of a[j] == a[i] , j < i to ans\r\n            //if k == 0, then if a[i] % x != 0, add the cnt of a[j] == a[i], j < i to ans.\r\n\r\n            int same = 0;\r\n            for(int i = 0; i < n; i++) {\r\n                if(i == 0 || a[i] - a[i - 1] == 0) {\r\n                    same++;\r\n                }\r\n                else {\r\n                    same = 1;\r\n                }\r\n                long t = 1l * a[i] / x - k;\r\n                int l = bs1(a, t * x + 1, i);\r\n                int r = bs2(a, t * x + x, i);\r\n                ans += max(0, r - l + 1);\r\n                if(k == 1 && a[i] % x == 0 || k == 0 && a[i] % x != 0) {\r\n                    ans += same - 1;\r\n                }\r\n            }\r\n            out.println(ans);\r\n        }\r\n        out.close();\r\n    }\r\n\r\n    static int bs1(Integer[] a, long t, int r) {\r\n        int l = 0;\r\n        while(l < r - 1) {\r\n            int mid = l + (r - l) / 2;\r\n            if(a[mid] >= t) {\r\n                r = mid;\r\n            }\r\n            else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        if(a[l] >= t) {\r\n            return l;\r\n        }\r\n        else if(a[r] >= t) {\r\n            return r;\r\n        }\r\n        return a.length;\r\n    }\r\n\r\n    static int bs2(Integer[] a, long t, int r) {\r\n        int l = 0;\r\n        while(l < r - 1) {\r\n            int mid = l + (r - l) / 2;\r\n            if(a[mid] <= t) {\r\n                l = mid;\r\n            }\r\n            else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        if(a[r] <= t) {\r\n            return r;\r\n        }\r\n        else if(a[l] <= t) {\r\n            return l;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static long addWithMod(long x, long y, long mod) {\r\n        return (x + y) % mod;\r\n    }\r\n\r\n    static long subtractWithMod(long x, long y, long mod) {\r\n        return ((x - y) % mod + mod) % mod;\r\n    }\r\n\r\n    static long multiplyWithMod(long x, long y, long mod) {\r\n        x %= mod;\r\n        y %= mod;\r\n        return x * y % mod;\r\n    }\r\n\r\n    static long modInv(long x, long mod) {\r\n        return fastPowMod(x, mod - 2, mod);\r\n    }\r\n\r\n    static long fastPowMod(long x, long n, long mod) {\r\n        if (n == 0) return 1;\r\n        long half = fastPowMod(x, n / 2, mod);\r\n        if (n % 2 == 0) return half * half % mod;\r\n        return half * half % mod * x % mod;\r\n    }\r\n\r\n    static void initReaderPrinter(boolean test) {\r\n        if (test) {\r\n            try {\r\n                in = new InputReader(new FileInputStream(\"src/input.in\"));\r\n                out = new PrintWriter(new FileOutputStream(\"src/output.out\"));\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            in = new InputReader(System.in);\r\n            out = new PrintWriter(System.out);\r\n        }\r\n    }\r\n\r\n    static class InputReader {\r\n        BufferedReader br;\r\n        StringTokenizer st;\r\n\r\n        InputReader(InputStream stream) {\r\n            try {\r\n                br = new BufferedReader(new InputStreamReader(stream), 32768);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        String next() {\r\n            while (st == null || !st.hasMoreTokens()) {\r\n                try {\r\n                    st = new StringTokenizer(br.readLine());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        String nextLine() {\r\n            String str = \"\";\r\n            try {\r\n                str = br.readLine();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n\r\n        Integer[] nextIntArray(int n) {\r\n            Integer[] a = new Integer[n];\r\n            for (int i = 0; i < n; i++) a[i] = nextInt();\r\n            return a;\r\n        }\r\n\r\n        int[] nextIntArrayPrimitive(int n) {\r\n            int[] a = new int[n];\r\n            for (int i = 0; i < n; i++) a[i] = nextInt();\r\n            return a;\r\n        }\r\n\r\n        int[] nextIntArrayPrimitiveOneIndexed(int n) {\r\n            int[] a = new int[n + 1];\r\n            for (int i = 1; i <= n; i++) a[i] = nextInt();\r\n            return a;\r\n        }\r\n\r\n        Long[] nextLongArray(int n) {\r\n            Long[] a = new Long[n];\r\n            for (int i = 0; i < n; i++) a[i] = nextLong();\r\n            return a;\r\n        }\r\n\r\n        long[] nextLongArrayPrimitive(int n) {\r\n            long[] a = new long[n];\r\n            for (int i = 0; i < n; i++) a[i] = nextLong();\r\n            return a;\r\n        }\r\n\r\n        long[] nextLongArrayPrimitiveOneIndexed(int n) {\r\n            long[] a = new long[n + 1];\r\n            for (int i = 1; i <= n; i++) a[i] = nextLong();\r\n            return a;\r\n        }\r\n\r\n        String[] nextStringArray(int n) {\r\n            String[] g = new String[n];\r\n            for (int i = 0; i < n; i++) g[i] = next();\r\n            return g;\r\n        }\r\n\r\n        List<Integer>[] readUnWeightedGraphOneIndexed(int n, int m) {\r\n            List<Integer>[] adj = new List[n + 1];\r\n            for (int i = 0; i <= n; i++) {\r\n                adj[i] = new ArrayList<>();\r\n            }\r\n            for (int i = 0; i < m; i++) {\r\n                int u = nextInt();\r\n                int v = nextInt();\r\n                adj[u].add(v);\r\n                adj[v].add(u);\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        List<int[]>[] readWeightedGraphOneIndexed(int n, int m) {\r\n            List<int[]>[] adj = new List[n + 1];\r\n            for (int i = 0; i <= n; i++) {\r\n                adj[i] = new ArrayList<>();\r\n            }\r\n            for (int i = 0; i < m; i++) {\r\n                int u = nextInt();\r\n                int v = nextInt();\r\n                int w = in.nextInt();\r\n                adj[u].add(new int[]{v, w});\r\n                adj[v].add(new int[]{u, w});\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        List<Integer>[] readUnWeightedGraphZeroIndexed(int n, int m) {\r\n            List<Integer>[] adj = new List[n];\r\n            for (int i = 0; i < n; i++) {\r\n                adj[i] = new ArrayList<>();\r\n            }\r\n            for (int i = 0; i < m; i++) {\r\n                int u = nextInt() - 1;\r\n                int v = nextInt() - 1;\r\n                adj[u].add(v);\r\n                adj[v].add(u);\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        List<int[]>[] readWeightedGraphZeroIndexed(int n, int m) {\r\n            List<int[]>[] adj = new List[n];\r\n            for (int i = 0; i < n; i++) {\r\n                adj[i] = new ArrayList<>();\r\n            }\r\n            for (int i = 0; i < m; i++) {\r\n                int u = nextInt() - 1;\r\n                int v = nextInt() - 1;\r\n                int w = in.nextInt();\r\n                adj[u].add(new int[]{v, w});\r\n                adj[v].add(new int[]{u, w});\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        /*\r\n            A more efficient way of building an undirected graph using int[] instead of ArrayList to store each node's neighboring nodes.\r\n            1-indexed.\r\n         */\r\n        int[][] buildUndirectedGraph(int nodeCnt, int edgeCnt) {\r\n            int[] end1 = new int[edgeCnt], end2 = new int[edgeCnt];\r\n            int[] edgeCntForEachNode = new int[nodeCnt + 1], idxForEachNode = new int[nodeCnt + 1];\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                int u = in.nextInt(), v = in.nextInt();\r\n                edgeCntForEachNode[u]++;\r\n                edgeCntForEachNode[v]++;\r\n                end1[i] = u;\r\n                end2[i] = v;\r\n            }\r\n            int[][] adj = new int[nodeCnt + 1][];\r\n            for (int i = 1; i <= nodeCnt; i++) {\r\n                adj[i] = new int[edgeCntForEachNode[i]];\r\n            }\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                adj[end1[i]][idxForEachNode[end1[i]]] = end2[i];\r\n                idxForEachNode[end1[i]]++;\r\n                adj[end2[i]][idxForEachNode[end2[i]]] = end1[i];\r\n                idxForEachNode[end2[i]]++;\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        /*\r\n            A more efficient way of building an undirected weighted graph using int[] instead of ArrayList to store each node's neighboring nodes.\r\n            1-indexed.\r\n        */\r\n        int[][][] buildUndirectedWeightedGraph(int nodeCnt, int edgeCnt) {\r\n            int[] end1 = new int[edgeCnt], end2 = new int[edgeCnt], weight = new int[edgeCnt];\r\n            int[] edgeCntForEachNode = new int[nodeCnt + 1], idxForEachNode = new int[nodeCnt + 1];\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                int u = in.nextInt(), v = in.nextInt(), w = in.nextInt();\r\n                edgeCntForEachNode[u]++;\r\n                edgeCntForEachNode[v]++;\r\n                end1[i] = u;\r\n                end2[i] = v;\r\n                weight[i] = w;\r\n            }\r\n            int[][][] adj = new int[nodeCnt + 1][][];\r\n            for (int i = 1; i <= nodeCnt; i++) {\r\n                adj[i] = new int[edgeCntForEachNode[i]][2];\r\n            }\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                adj[end1[i]][idxForEachNode[end1[i]]][0] = end2[i];\r\n                adj[end1[i]][idxForEachNode[end1[i]]][1] = weight[i];\r\n                idxForEachNode[end1[i]]++;\r\n                adj[end2[i]][idxForEachNode[end2[i]]][0] = end1[i];\r\n                adj[end2[i]][idxForEachNode[end2[i]]][1] = weight[i];\r\n                idxForEachNode[end2[i]]++;\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        /*\r\n            A more efficient way of building a directed graph using int[] instead of ArrayList to store each node's neighboring nodes.\r\n            1-indexed.\r\n        */\r\n        int[][] buildDirectedGraph(int nodeCnt, int edgeCnt) {\r\n            int[] from = new int[edgeCnt], to = new int[edgeCnt];\r\n            int[] edgeCntForEachNode = new int[nodeCnt + 1], idxForEachNode = new int[nodeCnt + 1];\r\n            //from u to v: u -> v\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                int u = in.nextInt(), v = in.nextInt();\r\n                edgeCntForEachNode[u]++;\r\n                from[i] = u;\r\n                to[i] = v;\r\n            }\r\n            int[][] adj = new int[nodeCnt + 1][];\r\n            for (int i = 1; i <= nodeCnt; i++) {\r\n                adj[i] = new int[edgeCntForEachNode[i]];\r\n            }\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                adj[from[i]][idxForEachNode[from[i]]] = to[i];\r\n                idxForEachNode[from[i]]++;\r\n            }\r\n            return adj;\r\n        }\r\n\r\n        /*\r\n            A more efficient way of building a directed weighted graph using int[] instead of ArrayList to store each node's neighboring nodes.\r\n            1-indexed.\r\n        */\r\n        int[][][] buildDirectedWeightedGraph(int nodeCnt, int edgeCnt) {\r\n            int[] from = new int[edgeCnt], to = new int[edgeCnt], weight = new int[edgeCnt];\r\n            int[] edgeCntForEachNode = new int[nodeCnt + 1], idxForEachNode = new int[nodeCnt + 1];\r\n            //from u to v: u -> v\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                int u = in.nextInt(), v = in.nextInt(), w = in.nextInt();\r\n                edgeCntForEachNode[u]++;\r\n                from[i] = u;\r\n                to[i] = v;\r\n                weight[i] = w;\r\n            }\r\n            int[][][] adj = new int[nodeCnt + 1][][];\r\n            for (int i = 1; i <= nodeCnt; i++) {\r\n                adj[i] = new int[edgeCntForEachNode[i]][2];\r\n            }\r\n            for (int i = 0; i < edgeCnt; i++) {\r\n                adj[from[i]][idxForEachNode[from[i]]][0] = to[i];\r\n                adj[from[i]][idxForEachNode[from[i]]][1] = weight[i];\r\n                idxForEachNode[from[i]]++;\r\n            }\r\n            return adj;\r\n        }\r\n    }\r\n}"
}