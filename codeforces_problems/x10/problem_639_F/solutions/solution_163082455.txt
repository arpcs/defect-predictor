{
    "id": 163082455,
    "contestId": 639,
    "creationTimeSeconds": 1657182688,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 639,
        "index": "F",
        "name": "Bear and Chemistry",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3300,
        "tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "trees"
        ]
    },
    "author": {
        "contestId": 639,
        "members": [
            {
                "handle": "CCPSDCGK"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1459182900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<map>\r\n#include<set>\r\n#include<queue>\r\n#include<deque>\r\n#include<cmath>\r\n#include<ctime>\r\n#include<bitset>\r\n#include<vector>\r\n#include<cstdio>\r\n#include<string>\r\n#include<cassert>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<algorithm>\r\n#include<unordered_map>\r\nusing namespace std;\r\nusing ll=long long;\r\nusing uint=unsigned int;\r\nusing ull=unsigned long long;\r\n#define endl '\\n'\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define eb emplace_back\r\n#define fs fflush(stdout)\r\n#define ump unordered_map\r\n#define pq priority_queue\r\n#define clz __builtin_clz\r\n#define ctz __builtin_ctz\r\n#define sz(x) (int)x.size()\r\n#define np next_permutation\r\n#define clzl __builtin_clzll\r\n#define par __builtin_parity\r\n#define ctzl __builtin_ctzll\r\n#define ppc __builtin_popcount\r\n#define parl __builtin_parityll\r\n#define all(x) x.begin(),x.end()\r\n#define ppcl __builtin_popcountll\r\n#define fpi(x) freopen(x,\"r\",stdin)\r\n#define fpo(x) freopen(x,\"w\",stdout)\r\n#define ms(x,y) memset(x,y,sizeof(x))\r\n#define dbg(x) cerr<<\"In Line \"<<__LINE__<<' '<<#x<<'='<<(x)<<'\\n'\r\n#define gc p1==p2&&(p2=(p1=buf)+fread(buf,1,iosiz,stdin),p1==p2)?EOF:*p1++\r\n#define iosiz 1024\r\nchar buf[iosiz],*p1=buf,*p2=buf;\r\ntemplate<class T> inline T &re(T &x){\r\n\tx=0;int f=1;char ch=gc;\r\n\twhile(ch<48||ch>57){\r\n\t\tif(ch==45) f=-f;ch=gc;\r\n\t}\r\n\twhile(ch>47&&ch<58) x=(x<<1)+(x<<3)+(ch^48),ch=gc;\r\n\treturn x*=f;\r\n}\r\n#define mod 998244353\r\n#define inf 0x3f3f3f3f\r\nstruct node{\r\n\tint to,id;\r\n};\r\nstruct line{\r\n\tint u,v;\r\n}l[300005];\r\nvector<node> edge[300005];\r\nvector<int> T[300005];\r\nint n,tot,siz[600005],hson[600005],ls[1200005],cntblock,cnt,dep[600005],num[300005],head[600005],fa[600005],fa1[300005],fa2[300005],root[300005],rs[1200005],pos[300005],in[300005],cntin,height[300005],dfn[600005],low[300005],tim,top,s[300005],col[300005];\r\nbitset<300005> vis;\r\nbitset<12000005> tag,clr;\r\nstruct ele{\r\n\tint u,v;bool w;\r\n}st[300005];\r\ninline int find1(int x){\r\n\tif(fa1[x]==x) return x;\r\n\treturn fa1[x]=find1(fa1[x]);\r\n}\r\ninline int find2(int x){\r\n\twhile(x^fa2[x]) x=fa2[x];return x;\r\n}\r\ninline void merge(int u,int v){\r\n\tu=find2(u),v=find2(v);\r\n\tif(height[u]>height[v]) u^=v^=u^=v;\r\n\tst[++top]={u,v,height[u]==height[v]},height[v]+=height[u]==height[v],fa2[u]=v;\r\n}\r\nvoid tarjan(int u){\r\n\tdfn[u]=low[u]=++tim,s[++top]=u;\r\n\tfor(auto v:edge[u]) if(!vis[v.id]){\r\n\t\tvis[v.id]=1;\r\n\t\tif(!dfn[v.to]) tarjan(v.to),low[u]=min(low[u],low[v.to]);\r\n\t\telse low[u]=min(low[u],dfn[v.to]);\r\n\t}\r\n\tif(low[u]==dfn[u]){\r\n\t\tcnt++;\r\n\t\tdo{\r\n\t\t\tcol[s[top]]=cnt;\r\n\t\t}while(s[top--]^u);\r\n\t}\r\n}\r\nvoid dfs1(int u,int f){\r\n\tsiz[u]=1,dep[u]=dep[f]+1,hson[u]=0,fa[u]=f;\r\n\tfor(int v:T[u]) if(v^f){\r\n\t\tdfs1(v,u),siz[u]+=siz[v];\r\n\t\tif(siz[hson[u]]<siz[v]) hson[u]=v;\r\n\t}\r\n}\r\nvoid dfs2(int u,int f){\r\n\tdfn[u]=++tim;\r\n\tif(hson[u]) head[hson[u]]=head[u],dfs2(hson[u],u);\r\n\tfor(int v:T[u]) if(v^f&&v^hson[u]) head[v]=v,dfs2(v,u);\r\n}\r\ninline void pushdown(int x){\r\n\tif(clr[x]) tag[ls[x]]=tag[rs[x]]=0,clr[ls[x]]=clr[rs[x]]=clr[x],clr[x]=0;\r\n\ttag[ls[x]]|=tag[x],tag[rs[x]]|=tag[x];\r\n}\r\nvoid build(int &x,int l,int r){\r\n\tx=++tot;if(l==r) return ;\r\n\tint mid=l+r>>1;build(ls[x],l,mid),build(rs[x],mid+1,r);\r\n}\r\nvoid change(int x,int l,int r,int l1,int r1){\r\n\tif(l>r) return ;\r\n\tif(l<=l1&&r1<=r){\r\n\t\ttag[x]=1;return ;\r\n\t}\r\n\tpushdown(x);int mid=l1+r1>>1;\r\n\tif(l<=mid) change(ls[x],l,r,l1,mid);if(mid<r) change(rs[x],l,r,mid+1,r1);\r\n\ttag[x]=tag[ls[x]]&tag[rs[x]];\r\n}\r\nbool query(int x,int l,int r,int l1,int r1){\r\n\tif(l>r) return 1;\r\n\tif(l<=l1&&r1<=r) return tag[x];\r\n\tpushdown(x);int mid=l1+r1>>1;bool res=1;\r\n\tif(l<=mid) res=query(ls[x],l,r,l1,mid);if(mid<r&&res) return query(rs[x],l,r,mid+1,r1);\r\n\treturn res;\r\n}\r\ninline void change(int u,int v){\r\n\twhile(head[u]^head[v]){\r\n\t\tif(dep[head[u]]<dep[head[v]]) u^=v^=u^=v;\r\n\t\tchange(1,dfn[head[u]],dfn[u],1,cnt+cntblock),u=fa[head[u]];\r\n\t}\r\n\tif(dep[u]<dep[v]) change(1,dfn[u]+1,dfn[v],1,cnt+cntblock);else change(1,dfn[v]+1,dfn[u],1,cnt+cntblock);\r\n}\r\ninline bool query(int u,int v){\r\n\twhile(head[u]^head[v]){\r\n\t\tif(dep[head[u]]<dep[head[v]]) u^=v^=u^=v;\r\n\t\tif(!query(1,dfn[head[u]],dfn[u],1,cnt+cntblock)) return 0;u=fa[head[u]];\r\n\t}\r\n\tif(dep[u]<dep[v]) return query(1,dfn[u]+1,dfn[v],1,cnt+cntblock);return query(1,dfn[v]+1,dfn[u],1,cnt+cntblock);\r\n}\r\ninline int rmod(int x){\r\n\treturn x-n+(x-n>>31&n);\r\n}\r\nint main(){\r\n\t#ifdef CCPSDCGK\r\n\tfpi(\"shuju.txt\");\r\n\t#endif\r\n\tre(n);int m=re(m),q=re(q),rt,lstans=0;\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=re(u),v=re(v);\r\n\t\tedge[u].eb((node){v,i}),edge[v].eb((node){u,i});\r\n\t\tfa[find1(u)]=find1(v);\r\n\t}\r\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);top=tim=0;\r\n\tfor(int i=1;i<=cnt;i++) fa1[i]=i;\r\n\tfor(int i=1;i<=n;i++) for(node j:edge[i]) if(find1(col[i])^find1(col[j.to])) fa1[find1(col[i])]=find1(col[j.to]),T[col[i]].eb(col[j.to]),T[col[j.to]].eb(col[i]);\r\n\tfor(int i=1;i<=n;i++) vector<node>().swap(edge[i]);\r\n\tfor(int i=1;i<=cnt;i++) if(find1(i)==i) num[i]=++cntblock,head[i]=i,dfs1(i,0),dfs2(i,0);build(rt,1,cnt+cntblock);\r\n\tfor(int i=1;i<=cnt;i++) fa2[i]=find1(i);\r\n\tfor(int i=1;i<=q;i++){\r\n\t\tint nn=re(nn),mm=re(mm),zz=0;cntin=0;bool no=0;\r\n\t\tfor(int i=1;i<=nn;i++) pos[i]=col[(re(pos[i])+lstans-1)%n+1];\r\n\t\tsort(pos+1,pos+nn+1),nn=unique(pos+1,pos+nn+1)-pos-1;\r\n\t\tfor(int i=1;i<=nn;i++) in[i]=find1(pos[i]);\r\n\t\tsort(in+1,in+nn+1),cntin=unique(in+1,in+nn+1)-in-1;\r\n\t\twhile(mm--){\r\n\t\t\tint u=(re(u)+lstans-1)%n+1,v=(re(v)+lstans-1)%n+1,tmpu=find1(col[u]),tmpv=find1(col[v]),posu=find2(col[u]),posv=find2(col[v]);\r\n\t\t\tif(posu^posv) merge(posu,posv),T[num[tmpu]+cnt].eb(num[tmpv]+cnt),T[num[tmpv]+cnt].eb(num[tmpu]+cnt),root[tmpu]=col[u],root[tmpv]=col[v];else l[++zz]={col[u],col[v]};\r\n\t\t}\r\n\t\tint tmp=find2(in[1]);\r\n\t\tfor(int i=2;i<=cntin;i++) if(find2(i)^tmp){\r\n\t\t\tputs(\"NO\"),no=1;\r\n\t\t\tfor(int i=1;i<=cntin;i++) vector<int>().swap(T[num[in[i]]+cnt]);\r\n\t\t\twhile(top) height[st[top].v]-=st[top].w,fa2[st[top].u]=st[top].u,top--;break;\r\n\t\t}\r\n\t\tif(no) continue;\r\n\t\twhile(top) height[st[top].v]-=st[top].w,fa2[st[top].u]=st[top].u,top--;\r\n\t\thead[cnt+num[in[1]]]=cnt+num[in[1]],fa[cnt+num[in[1]]]=0,tim=cnt,dfs1(cnt+num[in[1]],0),dfs2(cnt+num[in[1]],0);\r\n\t\tfor(int i=1;i<=zz;i++){\r\n\t\t\tint posu=find1(l[i].u),posv=find1(l[i].v);\r\n\t\t\tif(posu^posv) change(l[i].u,root[posu]),change(l[i].v,root[posv]),change(cnt+num[posu],cnt+num[posv]);else change(l[i].u,l[i].v);\r\n\t\t}\r\n\t\tfor(int i=1;i<nn;i++){\r\n\t\t\tint posu=find1(pos[i]),posv=find1(pos[i+1]);\r\n\t\t\tif(posu^posv){\r\n\t\t\t\tif(!query(pos[i],root[posu])||!query(pos[i+1],root[posv])||!query(cnt+num[posu],cnt+num[posv])){\r\n\t\t\t\t\tputs(\"NO\"),no=1,clr[1]=1,tag[1]=0,no=1;\r\n\t\t\t\t\tfor(int i=1;i<=cntin;i++) vector<int>().swap(T[num[in[i]]+cnt]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if(!query(pos[i],pos[i+1])){\r\n\t\t\t\tputs(\"NO\"),no=1,clr[1]=1,tag[1]=0,no=1;\r\n\t\t\t\tfor(int i=1;i<=cntin;i++) vector<int>().swap(T[num[in[i]]+cnt]);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!no) lstans=rmod(lstans+i),puts(\"YES\"),clr[1]=1,tag[1]=0;\r\n\t\tfor(int i=1;i<=cntin;i++) vector<int>().swap(T[num[in[i]]+cnt]);\r\n\t}\r\n\treturn 0;\r\n}"
}