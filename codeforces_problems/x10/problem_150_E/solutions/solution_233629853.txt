{
    "id": 233629853,
    "contestId": 150,
    "creationTimeSeconds": 1700529600,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 150,
        "index": "E",
        "name": "Freezing with Style",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3000,
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 150,
        "members": [
            {
                "handle": "Creeper_l"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1329490800
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 33996800,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std; \r\nnamespace Fread {\r\nconst int SIZE = 1 << 21;\r\nchar buf[SIZE], *S, *T;\r\ninline char getchar() {\r\n    if (S == T) {\r\n        T = (S = buf) + fread(buf, 1, SIZE, stdin);\r\n        if (S == T) return '\\n';\r\n    }\r\n    return *S++;\r\n}\r\n}\r\nnamespace Fwrite {\r\nconst int SIZE = 1 << 21;\r\nchar buf[SIZE], *S = buf, *T = buf + SIZE;\r\ninline void flush() {\r\n    fwrite(buf, 1, S - buf, stdout);\r\n    S = buf;\r\n}\r\ninline void putchar(char c) {\r\n    *S++ = c;\r\n    if (S == T) flush();\r\n}\r\nstruct NTR {\r\n    ~ NTR() { flush(); }\r\n} ztr;\r\n}\r\n#ifdef ONLINE_JUDGE\r\n#define getchar Fread :: getchar\r\n#define putchar Fwrite :: putchar\r\n#endif\r\nnamespace Fastio {\r\nstruct Reader {\r\n    template<typename T>\r\n    Reader& operator >> (T& x) {\r\n        char c = getchar();\r\n        T f = 1;\r\n        while (c < '0' || c > '9') {\r\n            if (c == '-') f = -1;\r\n            c = getchar();\r\n        }\r\n        x = 0;\r\n        while (c >= '0' && c <= '9') {\r\n            x = x * 10 + (c - '0');\r\n            c = getchar();\r\n        }\r\n        x *= f;\r\n        return *this;\r\n    }\r\n    Reader& operator >> (char& c) {\r\n        c = getchar();\r\n        while (c == ' ' || c == '\\n') c = getchar();\r\n        return *this;\r\n    }\r\n    Reader& operator >> (char* str) {\r\n        int len = 0;\r\n        char c = getchar();\r\n        while (c == ' ' || c == '\\n') c = getchar();\r\n        while (c != ' ' && c != '\\n' && c != '\\r') { // \\r\\n in windows\r\n            str[len++] = c;\r\n            c = getchar();\r\n        }\r\n        str[len] = '\\0';\r\n        return *this;\r\n    }\r\n    Reader(){}\r\n} cin;\r\nconst char endl = '\\n';\r\nstruct Writer {\r\n    template<typename T>\r\n    Writer& operator << (T x) {\r\n        if (x == 0) { putchar('0'); return *this; }\r\n        if (x < 0) { putchar('-'); x = -x; }\r\n        static int sta[45];\r\n        int top = 0;\r\n        while (x) { sta[++top] = x % 10; x /= 10; }\r\n        while (top) { putchar(sta[top] + '0'); --top; }\r\n        return *this;\r\n    }\r\n    Writer& operator << (char c) {\r\n        putchar(c);\r\n        return *this;\r\n    }\r\n    Writer& operator << (char* str) {\r\n        int cur = 0;\r\n        while (str[cur]) putchar(str[cur++]);\r\n        return *this;\r\n    }\r\n    Writer& operator << (const char* str) {\r\n        int cur = 0;\r\n        while (str[cur]) putchar(str[cur++]);\r\n        return *this;\r\n    }\r\n    Writer(){}\r\n} cout;\r\n}\r\n#define cin Fastio :: cin\r\n#define cout Fastio :: cout\r\n#define endl Fastio :: endl\r\n#define ls id << 1\r\n#define rs id << 1 | 1\r\n#define int long long\r\ntypedef pair <int,int> pii;\r\nconst int MAXN = 1e5 + 10;\r\nint n,L,R,head[MAXN],b[MAXN],cnt,x,y,z,ans,maxn = 0;\r\nint pt,ansx,ansy;\r\nbool vis[MAXN],flag = false;\r\nstruct F{int u,num,dis;}p[MAXN]; \r\nstruct Node{int u,v,w,nxt;}e[MAXN <<1],g[MAXN << 1];\r\nstruct SegmentTree{int l,r,mx,node;}tree[MAXN << 2];\r\ninline void Add(int u,int v,int w){e[++cnt] = {u,v,w,head[u]};head[u] = cnt;}\r\ninline int Get_size(int u,int father)\r\n{\r\n\tif(vis[u] == true) return 0;\r\n\tint sum = 1;\r\n\tfor(int i = head[u]; ~ i;i = e[i].nxt)\r\n\t\tif(e[i].v != father) sum += Get_size(e[i].v,u);\r\n\treturn sum;\r\n}\r\ninline int Get_wc(int u,int father,int tot,int &wc)\r\n{\r\n\tif(vis[u] == true) return 0;\r\n\tint sum = 1,mx = 0;\r\n\tfor(int i = head[u]; ~ i;i = e[i].nxt)\r\n\t{\r\n\t\tint now = e[i].v;\r\n\t\tif(now == father) continue;\r\n\t\tint tmp = Get_wc(now,u,tot,wc);\r\n\t\tsum += tmp,mx = max(mx,tmp); \r\n\t}\r\n\tif(max(mx,tot - sum) <= tot / 2) wc = u;\r\n\treturn sum;\r\n}\r\ninline void Get_dist(int u,int father,int num,int dis)\r\n{\r\n\tp[++pt] = {u,num,dis};\r\n//\tcout << u << \" \" << num << \" \" << dis << endl;\r\n\tfor(int i = head[u]; ~ i;i = e[i].nxt)\r\n\t{\r\n\t\tint now = e[i].v;\r\n\t\tif(now == father) continue;\r\n\t\tGet_dist(now,u,num + 1,dis + e[i].w);\r\n\t}\r\n}\r\ninline void Pushup(int id)\r\n{\r\n\tif(tree[ls].mx > tree[rs].mx) tree[id].node = tree[ls].node;\r\n\telse tree[id].node = tree[rs].node;\r\n\ttree[id].mx = max(tree[ls].mx,tree[rs].mx);\r\n}\r\ninline void Build(int id,int l,int r)\r\n{\r\n\ttree[id].l = l,tree[id].r = r,tree[id].mx = 0;\r\n\ttree[id].node = 0;\r\n\tif(l == r) return;\r\n\tint mid = (l + r) >> 1;\r\n\tBuild(ls,l,mid),Build(rs,mid + 1,r);\r\n}\r\ninline void Update(int id,int l,int r,int a,int b,int c)\r\n{\r\n\tif(l == r)\r\n\t{\r\n\t\tif(b > tree[id].mx) tree[id].node = c;\r\n\t\ttree[id].mx = max(tree[id].mx,b);return;\r\n\t}\r\n\tint mid = (l + r) >> 1;\r\n\tif(a <= mid) Update(ls,l,mid,a,b,c);\r\n\telse Update(rs,mid + 1,r,a,b,c);\r\n\tPushup(id);\r\n}\r\ninline SegmentTree Query(int id,int l,int r,int a,int b)\r\n{\r\n\tif(a <= l && b >= r) return tree[id];\r\n\tint mid = (l + r) >> 1;\r\n\tif(a > mid) return Query(rs,mid + 1,r,a,b);\r\n\tif(b <= mid) return Query(ls,l,mid,a,b);\r\n\tSegmentTree FL = Query(ls,l,mid,a,b),FR = Query(rs,mid + 1,r,a,b),res;\r\n\tif(FL.mx > FR.mx) res.node = FL.node;\r\n\telse res.node = FR.node;\r\n\tres.mx = max(FL.mx,FR.mx);\r\n\treturn res;\r\n}\r\ninline void calc(int u)\r\n{\r\n\tif(vis[u] == true) return;\r\n\tGet_wc(u,0,Get_size(u,0),u);\r\n\tint m = Get_size(u,0);vis[u] = true;\r\n\tBuild(1,1,m);\r\n//\tcout << \"u = \" << u << endl;\r\n\tfor(int i = head[u]; ~ i;i = e[i].nxt)\r\n\t{\r\n\t\tint now = e[i].v;\r\n\t\tpt = 0;\r\n\t\tGet_dist(now,u,1,e[i].w);\r\n\t\tfor(int j = 1;j <= pt;j++)\r\n\t\t{\r\n\t\t\tint num = p[j].num,dis = p[j].dis,node = p[j].u;\r\n\t\t\tif(num > R) continue;\r\n//\t\t\tcout << \"xian : \" << u << \" \" << ansx << \" \" << ansy << \" \" << num << endl;\r\n\t\t\tif(num >= L && dis >= 0){ansx = u,ansy = node;flag = true;return;}\r\n\t\t\tif(num == R) continue;\r\n\t\t\tint f = max(1ll,L - num),s = R - num;\r\n//\t\t\tcout << u << \" \" << node << \" \" << num << endl;\r\n\t\t\tSegmentTree tmp = Query(1,1,n,f,s);\r\n\t\t\tif(tmp.mx + dis >= 0 && tmp.node != 0){ansx = tmp.node,ansy = node;flag = true;return;}\r\n\t\t}\r\n\t\tfor(int j = 1;j <= pt;j++)\r\n\t\t{\r\n\t\t\tint num = p[j].num,dis = p[j].dis,node = p[i].u;\r\n\t\t\tUpdate(1,1,n,num,dis,node);\r\n\t\t}\r\n\t}\r\n\tfor(int i = 1;i <= 4 * m;i++) tree[i] = {0,0,0,0};\r\n\tfor(int i = head[u]; ~ i;i = e[i].nxt) calc(e[i].v);\r\n}\r\ninline bool check(int mid)\r\n{\r\n\tfor(int i = 1;i <= cnt;i++)\r\n\t\tg[i].w = e[i].w,e[i].w = (e[i].w >= mid ? 1 : -1);\r\n\tfor(int i = 1;i <= n;i++) vis[i] = false;\r\n//\tcout << endl << endl << \"mid = \" << mid << endl;\r\n\tflag = false,calc(1);\r\n\tfor(int i = 1;i <= cnt;i++) e[i].w = g[i].w;\r\n\tif(flag == true) return true;\r\n\telse return false;\r\n}\r\nsigned main()\r\n{\r\n\tmemset(head,-1,sizeof head);\r\n\tcin >> n >> L >> R;\r\n\tfor(int i = 1;i < n;i++) cin >> x >> y >> z,Add(x,y,z),Add(y,x,z),b[i] = z;\r\n\tsort(b + 1,b + n);\r\n\tint len = unique(b + 1,b + n) - b - 1;\r\n\tint l = 1,r = len;\r\n\twhile(l <= r)\r\n\t{\r\n\t\tint mid = (l + r) >> 1;\r\n\t\tif(check(b[mid])) l = mid + 1,ans = b[mid];\r\n\t\telse r = mid - 1;\r\n\t}\r\n\tcout << ansx << \" \" << ansy;\r\n\treturn 0;\r\n}\r\n/*\r\n8 3 6\r\n1 2 9\r\n2 3 7\r\n3 4 7\r\n4 5 8\r\n5 8 2\r\n3 6 3\r\n2 7 4\r\n\r\nanswer : 5 1\r\nmy answer : 2 7\r\n*/"
}