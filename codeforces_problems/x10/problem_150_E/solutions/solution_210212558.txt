{
    "id": 210212558,
    "contestId": 150,
    "creationTimeSeconds": 1687159866,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 150,
        "index": "E",
        "name": "Freezing with Style",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3000,
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 150,
        "members": [
            {
                "handle": "pet12345678905"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1329490800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 117,
    "timeConsumedMillis": 6830,
    "memoryConsumedBytes": 22425600,
    "source": "#ifndef ONLINE_JUDGE\r\n#pragma GCC optimize(2)\r\n#pragma GCC optimize(3)\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"inline\")\r\n#pragma GCC optimize(\"-fgcse\")\r\n#pragma GCC optimize(\"-fgcse-lm\")\r\n#pragma GCC optimize(\"-fipa-sra\")\r\n#pragma GCC optimize(\"-ftree-pre\")\r\n#pragma GCC optimize(\"-ftree-vrp\")\r\n#pragma GCC optimize(\"-fpeephole2\")\r\n#pragma GCC optimize(\"-ffast-math\")\r\n#pragma GCC optimize(\"-fsched-spec\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#pragma GCC optimize(\"-falign-jumps\")\r\n#pragma GCC optimize(\"-falign-loops\")\r\n#pragma GCC optimize(\"-falign-labels\")\r\n#pragma GCC optimize(\"-fdevirtualize\")\r\n#pragma GCC optimize(\"-fcaller-saves\")\r\n#pragma GCC optimize(\"-fcrossjumping\")\r\n#pragma GCC optimize(\"-fthread-jumps\")\r\n#pragma GCC optimize(\"-funroll-loops\")\r\n#pragma GCC optimize(\"-fwhole-program\")\r\n#pragma GCC optimize(\"-freorder-blocks\")\r\n#pragma GCC optimize(\"-fschedule-insns\")\r\n#pragma GCC optimize(\"inline-functions\")\r\n#pragma GCC optimize(\"-ftree-tail-merge\")\r\n#pragma GCC optimize(\"-fschedule-insns2\")\r\n#pragma GCC optimize(\"-fstrict-aliasing\")\r\n#pragma GCC optimize(\"-fstrict-overflow\")\r\n#pragma GCC optimize(\"-falign-functions\")\r\n#pragma GCC optimize(\"-fcse-skip-blocks\")\r\n#pragma GCC optimize(\"-fcse-follow-jumps\")\r\n#pragma GCC optimize(\"-fsched-interblock\")\r\n#pragma GCC optimize(\"-fpartial-inlining\")\r\n#pragma GCC optimize(\"no-stack-protector\")\r\n#pragma GCC optimize(\"-freorder-functions\")\r\n#pragma GCC optimize(\"-findirect-inlining\")\r\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\r\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\r\n#pragma GCC optimize(\"inline-small-functions\")\r\n#pragma GCC optimize(\"-finline-small-functions\")\r\n#pragma GCC optimize(\"-ftree-switch-conversion\")\r\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\r\n#pragma GCC optimize(\"-fexpensive-optimizations\")\r\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\r\n#pragma GCC optimize(\"inline-functions-called-once\")\r\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\r\n#endif\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <vector>\r\nusing namespace std;\r\nint n,L,R,ansl,ansr;\r\nconst int N = 100050,M = 200050;\r\nint hh,tt=-1,q[2*N];\r\nint val[N];\r\nstruct PO{int x,c;};\r\nvector<PO> v[N];\r\nint e[M],ne[M],h[N],md[N],w[M],vis[N],siz[N],p[N],p1[N],dis[N],dep[N],tong1[N],tong[N],rt,tot,maxx,mx[N],idx;\r\nvoid add(int a,int b,int c){e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;}\r\nstruct ED{int a,b,c;}ed[N];\r\nbool cmp(PO a,PO b){return md[a.x]<md[b.x];}\r\ninline int _max(int a,int b){return a>b?a:b;}\r\ninline int _min(int a,int b){return a<b?a:b;}\r\nvoid getsiz(int u,int fa){\r\n\tsiz[u] = 1;\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(j==fa||vis[j])continue;\r\n\t\tgetsiz(j,u);\r\n\t\tsiz[u] += siz[j];\r\n\t}\r\n}\r\nvoid getrt(int u,int fa){\r\n\tsiz[u]=1;\r\n\tmx[u]=0;\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(j==fa||vis[j])continue;\r\n\t\tgetrt(j,u);\r\n\t\tsiz[u] += siz[j];\r\n\t\tmx[u] = _max(mx[u],siz[j]);\r\n\t}\r\n\tmx[u] = _max(mx[u],tot-siz[u]);\r\n\tif(mx[u]<mx[rt])rt=u;\r\n}\r\nvoid getd(int u,int fa,int id){\r\n\tif(dis[u]>tong1[dep[u]]){\r\n\t\tp1[dep[u]] = u;\r\n\t\ttong1[dep[u]] = dis[u];\r\n\t}\r\n\tmd[id] = _max(md[id],dep[u]);\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(vis[j]||j==fa)continue;\r\n\t\tdep[j] = dep[u]+1;\r\n\t\tdis[j] = dis[u]+w[i];\r\n\t\tgetd(j,u,id);\r\n\t}\r\n}\r\nvoid getmd(int u,int fa,int id){\r\n\tmd[id] = _max(md[id],dep[u]);\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(vis[j]||j==fa)continue;\r\n\t\tdep[j] = dep[u]+1;\r\n\t\tgetmd(j,u,id);\r\n\t}\r\n}\r\nbool merge(int u){\r\n\thh=0,tt=-1;\r\n\tint now = 0;\r\n\tfor(int i = _min(R,md[u]);i>=0;i--){\r\n\t\twhile(now<=maxx&&now+i<=R){\r\n\t\t\twhile(hh<=tt&&tong[now]>=tong[q[tt]])tt--;\r\n\t\t\tq[++tt] = now;\r\n\t\t\tnow++;\r\n\t\t}\r\n\t\twhile(hh<=tt&&R-i-q[hh]>=R-L+1)hh++;\r\n\t\tif(hh<=tt&&q[hh]+i<=R&&tong1[i]+tong[q[hh]]>=0){\r\n\t\t\tansl = p1[i];\r\n\t\t\tansr = p[q[hh]];\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\nbool dfz(int u,int mid){\r\n\tvis[u]=1;\r\n\ttong[0]=0;\r\n\tp[0]=u;\r\n\tmaxx = 0;\r\n\tfor(int i = 0;i < v[u].size();i++){\r\n\t\tint j = v[u][i].x;\r\n\t\tmd[j]=0;\r\n\t\tdep[j]=1;\r\n\t\tdis[j]=(v[u][i].c>=mid)?1:-1;\r\n\t\tgetd(j,u,j);\r\n\t\tif(merge(j)){\r\n\t\t\tfor(int k = 0;k <= md[j];k++)tong1[k]=tong[k]=-0x3f3f3f3f;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tmaxx = max(maxx,md[j]);\r\n\t\tfor(int k = 0;k <= md[j];k++){\r\n\t\t\tif(tong[k]<tong1[k]){\r\n\t\t\t\ttong[k]=tong1[k];\r\n\t\t\t\tp[k] = p1[k];\r\n\t\t\t}\r\n\t\t\tp1[k] = 0;\r\n\t\t\ttong1[k] = -0x3f3f3f3f;\r\n\t\t}\r\n\t}\r\n\tif(v[u].size()!=0)for(int i = 0;i <= md[v[u][v[u].size()-1].x];i++)tong[i]=tong1[i]=-0x3f3f3f3f;\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(vis[j])continue;\r\n\t\tgetsiz(j,u);\r\n\t\trt=0;\r\n\t\ttot=siz[j];\r\n\t\tgetrt(j,u);\r\n\t\tif(dfz(rt,mid))return true;\r\n\t}\r\n\treturn false;\r\n}\r\nbool check(int x){\r\n\tmemset(tong,-0x3f,sizeof tong);\r\n\tmemset(tong1,-0x3f,sizeof tong1);\r\n\tmemset(vis,0,sizeof vis);\r\n\tmemset(md,0,sizeof md);\r\n\tmemset(h,-1,sizeof h);\r\n\tidx = 0;\r\n\tfor(int i = 1;i < n;i++){\r\n\t\tadd(ed[i].a,ed[i].b,(ed[i].c>=x)?1:-1);\r\n\t\tadd(ed[i].b,ed[i].a,(ed[i].c>=x)?1:-1);\r\n\t}\r\n\tgetsiz(1,-1);\r\n\ttot = n;\r\n\trt = 0;\r\n\tmx[0]=0x3f3f3f3f;\r\n\tgetrt(1,-1);\r\n\treturn dfz(rt,x);\r\n}\r\ninline int read(){\r\n\tint x=0;\r\n\tchar c = getchar();\r\n\twhile(c<'0'||c>'9')c=getchar();\r\n\twhile(c>='0'&&c<='9'){\r\n\t\tx=x*10+c-48;\r\n\t\tc=getchar();\r\n\t}\r\n\treturn x;\r\n}\r\nvoid init(int u){\r\n\tvis[u] = 1;\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(vis[j])continue;\r\n\t\tmd[j] = 0;\r\n\t\tdep[j] = 1;\r\n\t\tgetmd(j,u,j);\r\n\t\tv[u].push_back({j,w[i]});\r\n\t}\r\n\tsort(v[u].begin(),v[u].end(),cmp);\r\n\tfor(int i = h[u];~i;i = ne[i]){\r\n\t\tint j = e[i];\r\n\t\tif(vis[j])continue;\r\n\t\tgetsiz(j,u);\r\n\t\trt=0;\r\n\t\ttot=siz[j];\r\n\t\tgetrt(j,u);\r\n\t\tinit(rt);\r\n\t}\r\n}\r\nint main(){\r\n\tmemset(h,-1,sizeof h);\r\n\tn=read(),L=read(),R=read();\r\n\tfor(int i = 1;i < n;i++){\r\n\t\ted[i] = {read(),read(),read()};\r\n\t\tval[i] = ed[i].c;\r\n\t\tadd(ed[i].a,ed[i].b,ed[i].c);\r\n\t\tadd(ed[i].b,ed[i].a,ed[i].c);\r\n\t}\r\n\ttot=n;\r\n\tmx[0]=0x3f3f3f3f;\r\n\tgetrt(1,-1);\r\n\tinit(rt);\r\n\tmemset(vis,0,sizeof vis);\r\n\tmemset(dep,0,sizeof dep);\r\n\tsort(val+1,val+n);\r\n\tint l = 1,r = n-1;\r\n\twhile(l<r){\r\n\t\tint mid = l+r+1>>1;\r\n\t\tif(check(val[mid]))l=mid;\r\n\t\telse r = mid-1;\r\n\t}\r\n\tprintf(\"%d %d\",ansl,ansr);\r\n\treturn 0;\r\n}"
}