{
    "id": 230636299,
    "contestId": 975,
    "creationTimeSeconds": 1698736886,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 975,
        "index": "E",
        "name": "Hag's Khashba",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2600,
        "tags": [
            "geometry"
        ]
    },
    "author": {
        "contestId": 975,
        "members": [
            {
                "handle": "VuongNguyenK16"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1525183500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 19,
    "timeConsumedMillis": 561,
    "memoryConsumedBytes": 1126400,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define REP(i, n)  for (int i = 0, _n = (n); i < _n; ++i)\r\n#define FOR(i, a, b)  for (int i = (a), _b = (b); i <= _b; ++i)\r\n#define FORD(i, b, a)  for (int i = (b), _a = (a); i >= _a; --i)\r\n#define PR(a,n) { cerr << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }\r\n#define PR0(a,n) { cerr << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl; }\r\n#define debug(x) cerr << #x << \" = \" << x << endl\r\n#define TIME  (1.0 * clock() / CLOCKS_PER_SEC)\r\n#define MASK(i)  (1LL << (i))\r\n#define FULL(i)  (MASK(i) - 1)\r\n#define  __builtin_popcount  __builtin_popcountll\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<ll, ll> pll;\r\ntemplate <class T, class T2> ostream& operator << (ostream &o, pair<T, T2> p)\r\n{\r\n    o << p.first << \" \" << p.second << \"\\n\";\r\n    return o;\r\n}\r\ntemplate <class T> ostream& operator << (ostream &o, vector<T> vt)\r\n{\r\n    for (auto it: vt)\r\n        o << it << \" \";\r\n    o << \"\\n\";\r\n    return o;\r\n}\r\n\r\n#ifndef EPS  // allow test files to overwrite EPS\r\n#define EPS 1e-6\r\n#endif\r\n\r\nconst double PI = acos(-1.0);\r\n\r\ndouble DEG_to_RAD(double d) { return d * PI / 180.0; }\r\ndouble RAD_to_DEG(double r) { return r * 180.0 / PI; }\r\n\r\ninline int cmp(double a, double b) {\r\n    return (a < b - EPS) ? -1 : ((a > b + EPS) ? 1 : 0);\r\n}\r\n\r\n// for int types\r\ntemplate<typename T, typename std::enable_if<!std::is_floating_point<T>::value>::type * = nullptr>\r\ninline int cmp(T a, T b) {\r\n    return (a == b) ? 0 : (a < b) ? -1 : 1;\r\n}\r\n#define double long double\r\ntemplate<typename T>\r\nstruct P {\r\n    T x, y;\r\n    P() { x = y = T(0); }\r\n    P(T _x, T _y) : x(_x), y(_y) {}\r\n\r\n    P operator + (const P& a) const { return P(x+a.x, y+a.y); }\r\n    P operator - (const P& a) const { return P(x-a.x, y-a.y); }\r\n    P operator * (T k) const { return P(x*k, y*k); }\r\n    P<double> operator / (double k) const { return P(x/k, y/k); }\r\n\r\n    T operator * (const P& a) const { return x*a.x + y*a.y; } // dot product\r\n    T operator % (const P& a) const { return x*a.y - y*a.x; } // cross product\r\n\r\n    int cmp(const P<T>& q) const { if (int t = ::cmp(x,q.x)) return t; return ::cmp(y,q.y); }\r\n\r\n    #define Comp(x) bool operator x (const P& q) const { return cmp(q) x 0; }\r\n    Comp(>) Comp(<) Comp(==) Comp(>=) Comp(<=) Comp(!=)\r\n    #undef Comp\r\n\r\n    T norm() { return x*x + y*y; }\r\n\r\n    // Note: There are 2 ways for implementing len():\r\n    // 1. sqrt(norm()) --> fast, but inaccurate (produce some values that are of order X^2)\r\n    // 2. hypot(x, y) --> slow, but much more accurate\r\n    double len() { return hypot(x, y); }\r\n\r\n    P<double> rotate(double alpha) {\r\n        double cosa = cos(alpha), sina = sin(alpha);\r\n        return P(x * cosa - y * sina, x * sina + y * cosa);\r\n    }\r\n};\r\nusing Point = P<double>;\r\n\r\n// Compare points by (y, x)\r\ntemplate<typename T = double>\r\nbool cmpy(const P<T>& a, const P<T>& b) {\r\n    if (cmp(a.y, b.y)) return a.y < b.y;\r\n    return a.x < b.x;\r\n};\r\n\r\ntemplate<typename T>\r\nint ccw(P<T> a, P<T> b, P<T> c) {\r\n    return cmp((b-a)%(c-a), T(0));\r\n}\r\n\r\nint RE_TRAI = ccw(Point(0, 0), Point(0, 1), Point(-1, 1));\r\nint RE_PHAI = ccw(Point(0, 0), Point(0, 1), Point(1, 1));\r\n\r\ntemplate<typename T>\r\nistream& operator >> (istream& cin, P<T>& p) {\r\n    cin >> p.x >> p.y;\r\n    return cin;\r\n}\r\ntemplate<typename T>\r\nostream& operator << (ostream& cout, const P<T>& p) {\r\n    cout << fixed << setprecision(9) <<  p.x << ' ' << p.y;\r\n    return cout;\r\n}\r\n\r\ndouble angle(Point a, Point o, Point b) { // min of directed angle AOB & BOA\r\n    a = a - o; b = b - o;\r\n    return acos((a * b) / sqrt(a.norm()) / sqrt(b.norm()));\r\n}\r\n\r\ndouble directed_angle(Point a, Point o, Point b) { // angle AOB, in range [0, 2*PI)\r\n    double t = -atan2(a.y - o.y, a.x - o.x)\r\n            + atan2(b.y - o.y, b.x - o.x);\r\n    while (t < 0) t += 2*PI;\r\n    return t;\r\n}\r\n\r\nint n, q;\r\nint cur1, cur2;\r\ndouble addAngle;\r\nvector <Point> a;\r\nvector <double> curAngle;\r\nvector <double> dis;\r\nPoint get_centroid()\r\n{\r\n    ll s = 0;\r\n    for (int i = 1; i <= n; i++)\r\n        s += (a[i - 1].x - a[i + 1].x) * a[i].y;\r\n    double x = 0, y = 0;\r\n    for (int i = 1; i <= n; i++)\r\n    {\r\n        double tmp = ((double)a[i].x * a[i + 1].y - (double)a[i + 1].x * a[i].y);\r\n        x += (a[i].x + a[i + 1].x) * tmp;\r\n        y += (a[i].y + a[i + 1].y) * tmp;\r\n    }\r\n    Point res(x / 3 / s, y / 3 / s);\r\n    return res;\r\n}\r\nPoint query(int pos)\r\n{\r\n    complex<double> c = polar(dis[pos], curAngle[pos] + addAngle);\r\n    Point ans(c.real(), c.imag());\r\n    ans = ans + a[0];\r\n    return ans;\r\n}\r\nmain()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cin >> n >> q;\r\n    a.resize(n + 5);\r\n    for (int i = 1; i<= n; i++)\r\n        cin >> a[i];\r\n    a[n + 1] = a[1];\r\n    a[0] = a[n];\r\n    a[0] = get_centroid();\r\n//    debug(a[0]);\r\n    dis.resize(n + 5);\r\n    for (int i = 1; i<= n; i++)\r\n        dis[i] = (a[i] - a[0]).len();\r\n    curAngle.resize(n + 5);\r\n    for (int i =1; i<= n; i++)\r\n    {\r\n        Point M(a[0].x + 1, a[0].y);\r\n        curAngle[i] = directed_angle(M, a[0], a[i]);\r\n    }\r\n//    PR(curAngle, n);\r\n    cur1 = 1, cur2 = 2;\r\n    while (q--)\r\n    {\r\n        int type;\r\n        cin >> type;\r\n        if (type == 1)\r\n        {\r\n//            debug(G);\r\n            int f, t;\r\n            cin >> f >> t;\r\n            Point H;\r\n            if (f == cur1)\r\n                H = query(cur2), cur1 = t;\r\n            else\r\n                H = query(cur1), cur2 = t;\r\n            Point M(H.x, H.y - 1);\r\n            double tmp = directed_angle(a[0], H, M);\r\n            addAngle += tmp;\r\n            while (addAngle > 2 * PI)\r\n                addAngle -= 2 * PI;\r\n            a[0] = a[0] - H;\r\n            a[0] = a[0].rotate(tmp);\r\n            a[0] = a[0] + H;\r\n        }\r\n        else\r\n        {\r\n            int pos;\r\n            cin >> pos;\r\n            cout << query(pos) << \"\\n\";\r\n        }\r\n    }\r\n}\r\n\r\n"
}