{
    "id": 228996094,
    "contestId": 1736,
    "creationTimeSeconds": 1697851947,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1736,
        "index": "D",
        "name": "Equal Binary Subsequences",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "constructive algorithms",
            "geometry",
            "greedy",
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 1736,
        "members": [
            {
                "handle": "dzhi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1665412500
    },
    "programmingLanguage": "Java 17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 12,
    "timeConsumedMillis": 265,
    "memoryConsumedBytes": 0,
    "source": "// package c1736;\n\n//\n// Codeforces Round (Div. 2) 2022-10-10 07:35\n// D. Equal Binary Subsequences\n// https://codeforces.com/contest/1736/problem/D\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for 'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*'\n//\n// Everool has a binary string s of length 2n. Note that a binary string is a string consisting of\n// only characters 0 and 1. He wants to partition s into two subsequences. He needs your help to do\n// it.\n//\n// You are allowed to do the following operation once.\n//  * You can choose any subsequence () of s and rotate it right by one position.\n//\n// In other words, you can select a sequence of indices b_1, b_2, ..., b_m, where 1 <= b_1 < b_2 <\n// ... < b_m <= 2n. After that you set <div class=\"MathJax_Display\" style=\"text-align:\n// center;\"></div>s_{b_1} := s_{b_m}, <div class=\"MathJax_Display\" style=\"text-align:\n// center;\"></div>s_{b_2} := s_{b_1}, <div class=\"MathJax_Display\" style=\"text-align:\n// center;\"></div>..., <div class=\"MathJax_Display\" style=\"text-align: center;\"></div>s_{b_m} :=\n// s_{b_{m-1}}.\n//\n// Can you partition s into two subsequences after performing the allowed operation once?\n//\n// A partition of s into two disjoint equal subsequences s^p and s^q is two arrays of indices p_1,\n// p_2, ..., p_n and q_1, q_2, ..., q_n, such that each integer from 1 to 2n is encountered in\n// either p or q exactly once, s^p = s_{p_1} s_{p_2} ... s_{p_n}, s^q = s_{q_1} s_{q_2} ... s_{q_n},\n// and s^p = s^q.\n//\n// If it is not possible to partition after performing any kind of operation, report -1.\n//\n// If it is possible to do the operation and partition s into two disjoint subsequences s^p and s^q,\n// such that s^p = s^q, print elements of b and indices of s^p, i.e. the values p_1, p_2, ..., p_n.\n//\n// Input\n//\n// Each test contains multiple test cases. The first line contains the number of test cases t (1 <=\n// t <= 10^5). Description of the test cases follows.\n//\n// The first line of each test case contains a single integer n (1 <= n <= 10^5), where 2n is the\n// length of the binary string.\n//\n// The second line of each test case contains the binary string s of length 2n.\n//\n// It is guaranteed that the sum of n over all test cases does not exceed 10^5.\n//\n// Output\n//\n// For each test case, follow the following output format.\n//\n// If there is no solution, print -1.\n//\n// Otherwise,\n//  * In the first line, print an integer m (0 <= m <= 2n), followed by m distinct indices b_1, b_2,\n//    ..., b_m(in order).\n//  * In the second line, print n distinct indices p_1, p_2, ..., p_n (in order).\n//\n// If there are multiple solutions, print any.\n//\n// Example\n/*\ninput:\n4\n2\n1010\n3\n100010\n2\n1111\n2\n1110\noutput:\n0\n1 2\n2 3 5\n1 2 5\n3 2 3 4\n1 4\n-1\n*/\n// Note\n//\n// In the first test case, b is empty. So string s is not changed. Now s^p = s_1 s_2 = \\mathtt{10},\n// and s^q = s_3s_4 = \\mathtt{10}.\n//\n// In the second test case, b=[3,4,5]. Initially s_3=\\mathtt{0}, s_4=\\mathtt{0}, and s_5=\\mathtt{1}.\n// On performing the operation, we simultaneously set s_3=\\mathtt{1}, s_4=\\mathtt{0} and\n// s_5=\\mathtt{0}.\n//\n// So s is updated to 101000 on performing the operation.\n//\n// Now if we take characters at indices [1,2,5] in s^p, we get s_1=\\mathtt{100}. Also characters at\n// indices [3,4,6] are in s^q. Thus s^q=100. We are done as s^p=s^q.\n//\n// In fourth test case, it can be proved that it is not possible to partition the string after\n// performing any operation.\n//\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class C1736D {\n  static final int MOD = 998244353;\n  static final Random RAND = new Random();\n\n  static Result solve(String s) {\n    int m = s.length();\n    int n = m / 2;\n    // Note that the operation is to rotate a random **subsequence** instead of sub-string.\n    // ** Note that we rotate a subsequence, NOT a substring! **\n\n    // 01 00 00 11 01 10 00 01 01 10\n    // x diff pairs: 01 01 10 01 01 10\n    // y same pairs: 00 00 11 00\n\n    List<Integer> indices = new ArrayList<>();\n    int[] pa = new int[n];\n    int freq = 0;\n    int need = 0;\n    for (int i = 0; i < m; i += 2) {\n      if (s.charAt(i) != s.charAt(i+1)) {\n        freq++;\n        // alternatively pick 0,1,0,1,0,1 etc\n        if (s.charAt(i) - '0' == need) {\n          indices.add(i+1);\n        } else {\n          indices.add(i+2);\n        }\n        need ^= 1;\n      }\n    }\n    if ((freq & 1) != 0) {\n      return null;\n    }\n    int idx = 0;\n    for (int i = 1; i <= 2 * n; i += 2) {\n      pa[idx++] = i;\n    }\n    return new Result(indices, pa);\n  }\n\n  static class Result {\n    List<Integer> indices = new ArrayList<>();\n    int[] pa;\n    Result(List<Integer> indices, int[] pa) {\n      this.indices = indices;\n      this.pa = pa;\n    }\n  }\n\n  static List<Integer>[] getIndexes(String s) {\n    int m = s.length();\n    List<Integer>[] idxes = new ArrayList[2];\n    idxes[0] = new ArrayList<>();\n    idxes[1] = new ArrayList<>();\n    for (int i = 0; i < m; i++) {\n      idxes[s.charAt(i)-'0'].add(i);\n    }\n    return idxes;\n  }\n\n  // Show all splits of s into two equal sub-sequences.\n  static void showSplit(String s) {\n    int m = s.length();\n    int n = m / 2;\n    char[] ca0 = new char[n];\n    char[] ca1 = new char[n];\n    System.out.format(\"  %s\\n\", s);\n    for (int i = 1; i < (1 << (m-1)); i++) {\n      if (Integer.bitCount(i) != n) {\n        continue;\n      }\n      int idx0 = 0;\n      int idx1 = 0;\n      for (int j = 0; j < m; j++) {\n        if ((i & (1 << j)) != 0) {\n          ca1[idx1++] = s.charAt(j);\n        } else {\n          ca0[idx0++] = s.charAt(j);\n        }\n      }\n      boolean ok = true;\n      for (int j = 0; j < n; j++) {\n        if (ca0[j] != ca1[j]) {\n          ok= false;\n          break;\n        }\n      }\n      if (ok) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"  \");\n        for (int j = 0; j < m; j++) {\n          sb.append(((i & (1 << j)) != 0) ? '*':' ');\n        }\n        sb.append(\"  \");\n        sb.append(new String(ca1));\n        System.out.println(sb.toString());\n      }\n    }\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    sb.append('{');\n    for (int v : a) {\n      if (sb.length() > 1) {\n        sb.append(',');\n      }\n      sb.append(v);\n    }\n    sb.append('}');\n    return sb.toString();\n  }\n\n  static String trace(List<Integer> a) {\n    StringBuilder sb = new StringBuilder();\n    sb.append('{');\n    for (int v : a) {\n      if (sb.length() > 1) {\n        sb.append(',');\n      }\n      sb.append(v);\n    }\n    sb.append('}');\n    return sb.toString();\n  }\n\n  static String getRandomBinStr(int n) {\n    char[] ca = new char[n];\n    for (int i = 0; i < n; i++) {\n      ca[i] = (char) (RAND.nextInt(2) + '0');\n    }\n    return new String(ca);\n  }\n\n  static String combineRandomly(String s) {\n    int n = s.length();\n    int m = 2 * n;\n    char[] ca = new char[m];\n    int[] idx = new int[2];\n    for (int i = 0; i < m; i++) {\n      if (idx[0] == n) {\n        ca[i] = s.charAt(idx[1]++);\n      } else if (idx[1] == n) {\n        ca[i] = s.charAt(idx[0]++);\n      } else {\n        int j = RAND.nextInt(2);\n        ca[i] = s.charAt(idx[j]++);\n      }\n    }\n    return new String(ca);\n  }\n\n  static String rotateRandomSubsequence(String s) {\n    int n = s.length();\n    int k = RAND.nextInt(n + 1);\n    boolean[] used = new boolean[n];\n    int cnt = 0;\n    while (cnt < k) {\n      int i = RAND.nextInt(n);\n      if (!used[i]) {\n        used[i] = true;\n        cnt++;\n      }\n    }\n    List<Integer> idxes = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      if (used[i]) {\n        idxes.add(i + 1);\n      }\n    }\n    return rotate(s, idxes);\n  }\n\n  // rotate with 1-based indexes\n  static String rotate(String s, List<Integer> idxes) {\n    char[] ca = s.toCharArray();\n    int k = idxes.size();\n    for (int i = 0; i < k; i++) {\n      int curr = idxes.get(i) - 1;\n      int next = idxes.get((i + k - 1) % k) - 1;\n      ca[curr] = s.charAt(next);\n    }\n    return new String(ca);\n  }\n\n  static void incubate() {\n    for (int t = 0; t < 20; t++) {\n      int n = 1 + RAND.nextInt(10);\n      int m = 2 * n;\n      String sub = getRandomBinStr(n);\n      String s = combineRandomly(sub);\n      showSplit(s);\n    }\n    System.exit(0);\n  }\n\n  static String test(String s) {\n    System.out.format(\"test(\\\"%s\\\");\\n\", s);\n    Result r = solve(s);\n    System.out.format(\"%s => %s\\n\", s, r == null ? \"-1\" : trace(r.indices) + \" \" + trace(r.pa));\n    if (r == null) {\n      return null;\n    }\n    String t = rotate(s, r.indices);\n    StringBuilder sb0 = new StringBuilder();\n    StringBuilder sb1 = new StringBuilder();\n    int m = s.length();\n    int n = m / 2;\n    int j = 0;\n    for (int i = 0; i < m; i++) {\n      if (j < n && i + 1 == r.pa[j]) {\n        sb1.append(t.charAt(i));\n        j++;\n      } else {\n        sb0.append(t.charAt(i));\n      }\n    }\n    String s1 = sb1.toString();\n    String s0 = sb0.toString();\n    System.out.format(\"  %s %s\\n\", s1, s0);\n    myAssert(s1.equals(s0));\n    return s1;\n  }\n\n  static boolean test = false;\n  static void doTest() {\n    if (!test) {\n      return;\n    }\n    long t0 = System.currentTimeMillis();\n    test(\"0011010001\");\n    //    10  0000  1  00 1\n    //      10    00 00  1 001\n    test(\"10100000001000011001\");\n    test(\"1010\");\n    test(\"100010\");\n    test(\"1111\");\n    test(\"1110\");\n    for (int t = 0; t < 20; t++) {\n      int n = 1 + RAND.nextInt(20);\n      int m = 2 * n;\n      String sub = getRandomBinStr(n);\n      String s1 = combineRandomly(sub);\n      String s = rotateRandomSubsequence(s1);\n      System.out.format(\"  sub:%s s1:%s s:%s\\n\", sub, s1, s);\n      String r = test(s);\n      myAssert(r != null);\n    }\n    System.out.format(\"%d msec\\n\", System.currentTimeMillis() - t0);\n    System.exit(0);\n  }\n\n  public static void main(String[] args) {\n    doTest();\n    MyScanner in = new MyScanner();\n    int T = in.nextInt();\n    Result[] anses = new Result[T];\n    for (int t = 1; t <= T; t++) {\n      int n = in.nextInt();\n      String s = in.next();\n      // System.out.format(\"test(\\\"%s\\\");\\n\", s);\n      anses[t-1] = solve(s);\n    }\n    output(anses);\n  }\n\n  static void output(Result[] anses) {\n    StringBuilder sb = new StringBuilder();\n    for (Result r : anses) {\n      if (r == null) {\n        sb.append(\"-1\\n\");\n      } else {\n        sb.append(r.indices.size());\n        for (int v : r.indices) {\n          sb.append(' ');\n          sb.append(v);\n        }\n        sb.append('\\n');\n        for (int v : r.pa) {\n          sb.append(v);\n          sb.append(' ');\n        }\n        sb.append('\\n');\n      }\n      if (sb.length() > 4000) {\n        System.out.print(sb.toString());\n        sb.setLength(0);\n      }\n    }\n    System.out.print(sb.toString());\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n  }\n\n  static class MyScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public MyScanner() {\n      try {\n        final String USERDIR = System.getProperty(\"user.dir\");\n        String cname = MethodHandles.lookup().lookupClass().getCanonicalName().replace(\".MyScanner\", \"\");\n        cname = cname.lastIndexOf('.') > 0 ? cname.substring(cname.lastIndexOf('.') + 1) : cname;\n        final File fin = new File(USERDIR + \"/io/c\" + cname.substring(1,5) + \"/\" + cname + \".in\");\n        br = new BufferedReader(new InputStreamReader(fin.exists()\n            ? new FileInputStream(fin) : System.in));\n      } catch (Exception e) {\n        br = new BufferedReader(new InputStreamReader(System.in));\n      }\n    }\n\n    public String next() {\n      try {\n        while (st == null || !st.hasMoreElements()) {\n          st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n  }\n}\n"
}