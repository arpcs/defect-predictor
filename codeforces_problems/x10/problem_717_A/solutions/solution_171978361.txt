{
    "id": 171978361,
    "contestId": 717,
    "creationTimeSeconds": 1663028533,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 717,
        "index": "A",
        "name": "Festival Organization",
        "type": "PROGRAMMING",
        "rating": 2900,
        "tags": [
            "combinatorics",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 717,
        "members": [
            {
                "handle": "youbot"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1473584400
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 13,
    "timeConsumedMillis": 156,
    "memoryConsumedBytes": 24166400,
    "source": "// \u4ece\u672a\u5728\u610f\u7684\u540d\u5b57\u6c38\u8fdc\u4e0d\u4f1a\u88ab\u63d0\u8d77 - \u96ea\u8449/\u9e64\u89c1\u6c5f\u91ce\r\n\r\n/*\r\n+\r\n++\r\n+++\r\n++++\r\n+++++\r\n++++++\r\n+++++++\r\n++++++++\r\n+++++++++\r\n++++++++++\r\n+++++++++++\r\n++++++++++++\r\n+++++++++++++\r\n++++++++++++++\r\n+++++++++++++++\r\n++++++++++++++++\r\n+++++++++++++++++\r\n++++++++++++++++++\r\n+ +++++++++++++++++\r\n+  ++++++++++++++ ++\r\n+   +++++++++++++  ++\r\n+    ++++++++++++   ++\r\n+     +++++++++++    ++\r\n+      ++++++++++     ++\r\n+       +++++++++      ++\r\n+        ++++++++       ++\r\n+         +++++++++++++++++\r\n+          +++++++++++++++++\r\n+           ++++++++++++++\r\n+            +++++++++++\r\n+             ++++++++\r\n+              +++++\r\n+               ++\r\n+               +\r\n+               +\r\n+              ++\r\n+             +++\r\n+            ++++\r\n+           +++++\r\n+           +++++\r\n+           +++++\r\n+           +++++\r\n+     +     +++++\r\n+    +++    +++++\r\n+   ++ ++   +++++\r\n+  ++   ++  +++++\r\n+ ++  +  ++ +++++\r\n+++  +++  +++++++\r\n++  ++ ++  ++++++\r\n \r\n \r\n ++++++++      +++++++++++     +++      +++        ++++++++        ++++++++\r\n+++++++++     +++++++++++++    +++      +++       +++    +++      +++    +++\r\n+++          +++   +++   +++   +++      +++      +++   ++++++    +++      +++\r\n+++          +++   +++   +++   +++      +++      +++ +++  +++           +++\r\n+++          +++   +++   +++   +++ ++   +++ ++   ++++++   +++         +++\r\n+++++++++    +++   +++   +++   +++ ++   +++ ++    +++    +++        +++    ++\r\n ++++++++    +++   +++   +++   +++++    +++++      ++++++++       +++++++++++\r\n*/\r\n#ifndef ONLINE_JUDGE\r\n#define DEBUG\r\n#endif\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <queue>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <set>\r\n#define nln puts(\"\")\r\n#define od(x) printf(\"%d\",x)\r\n#define odb(x) printf(\"%d \",x)\r\n#define odl(x) printf(\"%d\\n\",x)\r\n#define odp(x,y) printf(\"%d %d\\n\",x,y)\r\n#define ol(x) puts(\"\")\r\n#define old(x) printf(\"%lld\",x)\r\n#define oldb(x) printf(\"%lld \",x)\r\n#define oldl(x) printf(\"%lld\\n\",x)\r\n#define oldp(x,y) printf(\"%lld %lld\\n\",x,y)\r\n#define rg(x) for(int i=1;i<=(x);i++){\r\n#define rg_(i,x) for(int i=1;i<=(x);i++){\r\n#define fe(u) for(int i=h[u];i;i=e[i].nxt){int v=e[i].v;\r\n#define gr }\r\n#define rrg(x) for(int i=0;i<(x);i++){\r\n#define rdln(a) a[i]=read();\r\n#define rdln0(a,x) rrg(x) rdln(a) gr\r\n#define rdln1(a,x) rg(x) rdln(a) gr\r\ntemplate<typename T>\r\nvoid print(T x){}\r\ntemplate<>\r\nvoid print<int>(int x){od(x);}\r\ntemplate<>\r\nvoid print<const int>(const int x){od(x);}\r\ntemplate<>\r\nvoid print<long long>(long long x){old(x);}\r\ntemplate<>\r\nvoid print<const long long>(const long long x){old(x);}\r\ntemplate<>\r\nvoid print<char>(char x){putchar(x);}\r\ntemplate<>\r\nvoid print<const char>(const char x){putchar(x);}\r\ntemplate<>\r\nvoid print<double>(double x){printf(\"%.12lf\",x);}\r\ntemplate<typename T,typename... qwq>\r\nvoid print(T x,qwq ...args)\r\n{\r\n\tprint(x);\r\n\tprint(args...);\r\n}\r\n#ifdef DEBUG\r\ntemplate<typename T>\r\nvoid debug(T x){}\r\ntemplate<>\r\nvoid debug<int>(int x){od(x);}\r\ntemplate<>\r\nvoid debug<const int>(const int x){od(x);}\r\ntemplate<>\r\nvoid debug<long long>(long long x){old(x);}\r\ntemplate<>\r\nvoid debug<const long long>(const long long x){old(x);}\r\ntemplate<>\r\nvoid debug<char>(char x){putchar(x);}\r\ntemplate<>\r\nvoid debug<const char>(const char x){putchar(x);}\r\ntemplate<>\r\nvoid debug<double>(double x){printf(\"%.12lf\",x);}\r\ntemplate<typename T,typename... qwq>\r\nvoid debug(T x,qwq ...args)\r\n{\r\n\tdebug(x);\r\n\tdebug(args...);\r\n}\r\n#define dflush fflush\r\n#else\r\n#define dflush(...) 0\r\ntemplate<typename T,typename... qwq>\r\nvoid debug(T x,qwq ...args)\r\n{\r\n\t\r\n}\r\n#endif\r\n\r\n#define int long long\r\nconst int mod=1e9+7;\r\n#ifdef int \r\n#define inf 0x3f3f3f3f3f3f3f3fll\r\n#else \r\n#define inf 0x3f3f3f3f\r\n#endif\r\ninline int min(int a,int b){return a>b?b:a;}\r\ninline int max(int a,int b){return a<b?b:a;}\r\n#define cmlSEGMIN\r\n#define cmlSEGMAX\r\n#define cmlSEGSUM\r\nclass SegTreeAl{\r\n#ifdef cmlSEGMIN\r\n\tint minn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\tint maxn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\tint sum[1000005<<2];\r\n#endif\r\n\tint tag[1000005<<2];\r\n#ifdef cmlSEGSUM\r\n\tvoid pushdown(int o,int l,int r)\r\n#else \r\n\tvoid pushdown(int o)\r\n#endif\r\n\t{\r\n\t\tint&t=tag[o];\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o<<1]+=t;\r\n\t\tminn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o<<1]+=t;\r\n\t\tmaxn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tint m=l+r>>1;\r\n\t\tsum[o<<1]+=t*(m-l+1);\r\n\t\tsum[o<<1|1]+=t*(r-m);\r\n#endif\r\n\t\ttag[o<<1]+=t;\r\n\t\ttag[o<<1|1]+=t;\r\n\t\tt=0;\r\n\t}\r\n\tvoid add(int o,int l,int r,int L,int R,int v)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n#ifdef cmlSEGMAX\r\n\t\t\tmaxn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\t\tminn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\t\tsum[o]+=v*(r-l+1);\r\n#endif\r\n\t\t\ttag[o]+=v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint m=l+r>>1;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)add(o<<1,l,m,L,R,v);\r\n\t\tif(m<R)add(o<<1|1,m+1,r,L,R,v);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t}\r\n#ifdef cmlSEGMIN\r\n\tint qmin(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn minn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=min(res,qmin(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=min(res,qmin(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGMAX\r\n\tint qmax(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn maxn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=-inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=max(res,qmax(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=max(res,qmax(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGSUM\r\n\tint qsum(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn sum[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=0;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res+=qsum(o<<1,l,m,L,R);\r\n\t\tif(m<R)res+=qsum(o<<1|1,m+1,r,L,R);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n};\r\n#define newe(n) struct Edge{int v,w,nxt;}e[2*n+5];\\\r\ntypedef int arr[n+5];\\\r\narr h;\\\r\nint cnt=1;\\\r\ninline void addedge(int u,int v,int w){e[cnt]=(Edge){v,w,h[u]};h[u]=cnt++;}\\\r\nstruct node{\\\r\n\tint u,d;\\\r\n\tbool operator<(const node&b)const{return d>b.d;}\\\r\n};\\\r\nvoid dij(int s,int *d,int N)\\\r\n{\\\r\n\tmemset(d,0x3f,sizeof(int)*(N+3));\\\r\n\td[s]=0;std::priority_queue<node>q;q.push((node){s,0});\\\r\n\twhile(!q.empty())\\\r\n\t{\\\r\n\t\tint u=q.top().u,D=q.top().d;q.pop();if(D!=d[u])continue;\\\r\n\t\tfor(int i=h[u];i;i=e[i].nxt){int v=e[i].v,w=e[i].w;\\\r\n\t\tif(d[u]+w<d[v])d[v]=d[u]+w,q.push((node){v,d[v]});\\\r\n\t\t}\\\r\n\t}\\\r\n}\r\n#define mgs int fa[1<<22],sz[1<<22];\\\r\ninline int f(int x){return x==fa[x]?x:fa[x]=f(fa[x]);}\\\r\ninline int uf(int x,int y)\\\r\n{\\\r\n    int fx=f(x),fy=f(y);\\\r\n    if(fx==fy)return 0;\\\r\n    if(sz[fx]>sz[fy])fx^=fy^=fx^=fy;\\\r\n    fa[fx]=fy,sz[fy]+=sz[fx];\\\r\n    return 1;\\\r\n}\r\ninline int read()\r\n{\r\n    int num=0,f=1;char c=getchar();\r\n    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}\r\n    while(c>47&&c<58)num=num*10+(c^48),c=getchar();\r\n    return num*f;\r\n}\r\ninline int re1d()\r\n{\r\n    char c=getchar();\r\n    while(c<48||c>49)c=getchar();\r\n    return c&1;\r\n}\r\n#ifdef cmlBIT\r\nstruct BIT{int a[1<<20|1],n;\r\nvoid add(int x,int p){while(x<=n)a[x]+=p,x+=x&-x;}\r\nint operator[](int x){int res=0;while(x)res+=a[x],x-=x&-x;return res;}\r\nint operator()(int l,int r){return (*this)[r]-(*this)[l-1];}};\r\n#endif\r\nint rnv[1000005];\r\n// #define COMB\r\n#ifdef COMB\r\n#ifndef int\r\n#define int long long\r\n#endif\r\nint fac[1000005],inv[1000005];\r\n#endif\r\nvoid initprog()\r\n{\r\n#ifdef COMB\r\n\tfac[0]=inv[0]=inv[1]=1;\r\n\trg(1000000)fac[i]=fac[i-1]*i%mod;gr\r\n\trg(1000000)if(i>1)inv[i]=inv[mod%i]*(mod-mod/i)%mod;gr\r\n\trg(1000000)rnv[i]=inv[i];gr\r\n\trg(1000000)inv[i]=inv[i]*inv[i-1]%mod;gr\r\n#endif\r\n}\r\n#ifdef COMB\r\nint C(int n,int m)\r\n{\r\n\tif(n==m||m==0)return 1;\r\n\tif(n<m)return 0;\r\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r\n}\r\n#endif\r\ninline int qp(int a,int b){int c=1;while(b){if(b&1)c=c*a%mod;a=a*a%mod;b>>=1;}return c;}\r\ninline int mae(int &a,int b){a+=b;if(a>=mod)a-=mod;return a;}\r\ninline int mde(int &a,int b){a+=mod-b;if(a>=mod)a-=mod;return a;}\r\ninline int mle(int &a,int b){a=a*b%mod;return a;}\r\ninline int mve(int &a,int b){a=a*qp(b,mod-2)%mod;return a;}\r\ninline int mxe(int &a,int b){return a=a>b?a:b;}\r\ninline int mne(int &a,int b){return a=a<b?a:b;}\r\ninline int ae(int a,int b){int c=a+b;return c>=mod?c-mod:c;}\r\ninline int de(int a,int b){return ae(a,mod-b);}\r\ninline int me(int a,int b){return a*b%mod;}\r\ninline int mive(int &a,int b){a=a*rnv[b]%mod;return a;}\r\ninline int ive(int a,int b){return a*rnv[b]%mod;}\r\ninline int ve(int a,int b){return a*qp(b,mod-2)%mod;}\r\n#ifdef cmlST\r\nstruct STmin{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=min(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn min(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\nstruct STmax{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=max(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn max(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\n#endif\r\n#ifdef cmlSAM\r\nstruct SAM{\r\n\tint ch[1000005][26],lnk[1000005],len[1000005],lst=1,cc=1;\r\n\tint sz[1000005];\r\n\tvoid insert(int c)\r\n\t{\r\n\t\tlen[++cc]=len[lst]+1;sz[cc]=1;\r\n\t\tint p=lst;lst=cc;\r\n\t\twhile(p&&ch[p][c]==0)ch[p][c]=cc,p=lnk[p];\r\n\t\tif(p==0)lnk[cc]=1;\r\n\t\telse\r\n\t\t{\r\n\t\t\tint x=ch[p][c];\r\n\t\t\tif(len[p]+1==len[x])lnk[cc]=x;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint q=cc;++cc;\r\n\t\t\t\tlnk[cc]=lnk[x];\r\n\t\t\t\tlnk[x]=lnk[q]=cc;\r\n\t\t\t\tlen[cc]=len[p]+1;\r\n\t\t\t\tmemcpy(ch[cc],ch[x],sizeof(ch[cc]));\r\n\t\t\t\twhile(p&&ch[p][c]==x)ch[p][c]=cc,p=lnk[p];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tnewe(1000005);\r\n\tlong long ans;\r\n\tvoid build()\r\n\t{\r\n\t\trg(cc)addedge(lnk[i],i,0);gr\r\n\t}\r\n\tvoid dfs(int u)\r\n\t{\r\n\t\tfe(u)dfs(v),sz[u]+=sz[v];gr\r\n\t\tif(sz[u]>1)ans=max(ans,1ll*sz[u]*len[u]);\r\n\t}\r\n}t;\r\n#endif\r\nint s[1005][1005];\r\nstruct qwq{\r\n\tint a,b;\r\n\tqwq operator+(qwq x){return (qwq){ae(a,x.a),ae(b,x.b)};}\r\n\tqwq operator-(qwq x){return (qwq){de(a,x.a),de(b,x.b)};}\r\n\tqwq operator*(qwq x){return (qwq){ae(me(a,x.a),me(5,me(b,x.b))),ae(me(b,x.a),me(a,x.b))};}\r\n\tqwq nv(){return (qwq){a,de(0,b)};}\r\n\tqwq operator!()\r\n\t{\r\n\t\tqwq c=(this->nv());\r\n\t\tint fd=de(me(a,a),me(5,me(b,b)));\r\n\t\tfd=ve(1,fd);\r\n\t\tc=c*(qwq){fd,0};\r\n\t\treturn c;\r\n\t}\r\n\tqwq qp(int k)\r\n\t{\r\n\t\tqwq ret=(qwq){1,0},c=*this;\r\n\t\twhile(k)\r\n\t\t{\r\n\t\t\tif(k&1)ret=ret*c;\r\n\t\t\tc=c*c;\r\n\t\t\tk>>=1;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n};\r\nint C[1005][1005];\r\nint F(int k,int n)\r\n{\r\n\tqwq ans=(qwq){0,0};\r\n\tqwq a=(qwq){0,ve(1,5)};\r\n\tqwq b=(qwq){0,0}-a;\r\n\tfor(int j=0;j<=k;j++)\r\n\t{\r\n\t\tint M1=me(s[k][j],(k-j&1)?mod-1:1);\r\n\t\tqwq m1=(qwq){M1,0};\r\n\t\tfor(int s=0;s<=j;s++)\r\n\t\t{\r\n\t\t\tqwq m2=a.qp(s)*b.qp(j-s)*(qwq){C[j][s],0};\r\n\t\t\tqwq x=(qwq){mod+1>>1,mod+1>>1};\r\n\t\t\tqwq y=(qwq){mod+1>>1,mod-1>>1};\r\n\t\t\tx=x.qp(s);y=y.qp(j-s);\r\n\t\t\tx=x*y;\r\n\t\t\tqwq m3=(qwq){0,0};\r\n\t\t\t// odp(x.a,x.b);\r\n\t\t\tif(x.a==1&&x.b==0)m3.a=n+1;\r\n\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tqwq up=x.qp(n+1)-(qwq){1,0};\r\n\t\t\t\tqwq down=x-(qwq){1,0};\r\n\t\t\t\tdown=!down;\r\n\t\t\t\tm3=up*down;\r\n\t\t\t}\r\n\t\t\tans=ans+m1*m2*m3;\r\n\t\t\t// printf(\"m3 : %d %d\\n\",(m3*m2).a,(m3*m2).b);\r\n\t\t}\r\n\t}\r\n\t// odp(ans.a,ans.b);\r\n\t// odl(ans.a);\r\n\treturn ans.a;\r\n}\r\nsigned main()\r\n{\r\n\tinitprog();\r\n\ts[0][0]=1;\r\n\tint k=read(),l=read()+1,r=read()+2;\r\n\tfor(int i=1;i<=k;i++)\r\n\t\tfor(int j=1;j<=k;j++)\r\n\t\t\ts[i][j]=ae(s[i-1][j-1],me(i-1,s[i-1][j]));\r\n\trrg(k+1)C[i][i]=C[i][0]=1;gr\r\n\trg(k)rg_(j,k)C[i][j]=ae(C[i-1][j],C[i-1][j-1]);gr gr\r\n\tint fac=1;rg(k)mle(fac,i);gr\r\n\todl(ve(de(F(k,r),F(k,l)),fac));\t\r\n\treturn 0;\r\n}"
}