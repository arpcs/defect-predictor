{
    "id": 220046505,
    "contestId": 1043,
    "creationTimeSeconds": 1692802736,
    "relativeTimeSeconds": 236,
    "problem": {
        "contestId": 1043,
        "index": "A",
        "name": "Elections",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 1043,
        "members": [
            {
                "handle": "mbae059"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1692802500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#define endl '\\n'\r\n#define INF 987654321\r\n#define p_q priority_queue\r\n#define pbk push_back\r\n#define rep(i, a, b) for (int i=a; i<=b; i++) \r\n#define all(v) (v).begin(), (v).end()\r\n\r\nusing namespace std;\r\nusing ll = long long;\r\n#define int ll\r\nusing pii = pair<int, int>;\r\nusing vi = vector<int>;\r\nusing vvi = vector<vi>;\r\nusing vpii = vector<pii> ;\r\nusing mii = map<int, int>;\r\nusing si = set<int>;\r\nusing qi = queue<int>;\r\nusing qpii = queue<pii>;\r\nusing tiii = tuple<int, int, int> ; //get<0>(t);\r\nusing vtiii = vector<tiii>;\r\nusing spii = set<pii>;\r\nusing qtiii = queue<tiii>;\r\nint A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z;\r\nint dy[8] = {1,-1,0,0,1,1,-1,-1};\r\nint dx[8] = {0,0,1,-1,1,-1,1,-1};\r\n//vvi matrix(N, vector<int>(N));\r\n//for finding the intersection of Line(x1,y1,x2,y2) and Line(x3,y3,x4,y4)\r\n//do not solve with tenary search\r\n// Px= (x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)\r\n// Py= (x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)\r\n\r\n//int to string : to_string\r\n//string to int : stoi\r\n\r\n//use setw(3) to get nice format for printing out 2-d array\r\n//ex) cout << setw(3) << \"a\" << endl;\r\n\r\n//to make a sorted vector's element unique, you should do v.erase(unique(v.begin(), v.end()), v.end())\r\n\r\n// unordered_map<char,int> dx = {{'D',0},{'L',-1},{'R',1},{'U',0}};\r\n// unordered_map<char,int> dy = {{'D',1},{'L',0},{'R',0},{'U',-1}}\r\n\r\n//diagonal counting. l[y+x], r[y-x+N]\r\n\r\n//supports negative modular operation\r\nll modular(ll num, ll mod) {\r\n    num%=mod;\r\n    return num < 0 ? num+mod : num;\r\n}\r\n\r\nll modAdd(ll a, ll b, ll mod) {\r\n    return modular(a+b, mod);\r\n}\r\n\r\nll modMul(ll a, ll b, ll mod) {\r\n    return modular(a*b, mod);\r\n}\r\n\r\nll modExp(ll a, ll b, ll mod) {\r\n    ll ret = 1;\r\n    while(b) {\r\n        if(b&1) ret = modMul(ret, a, mod);\r\n        a = modMul(a,a,mod);\r\n        b>>=1;\r\n    }\r\n    return ret;\r\n}\r\nstruct Matrix {\r\n    vvi m;\r\n    int l;\r\n    ll mod;\r\n    Matrix(int l=10) : l(l) {\r\n        m = vvi(l+1, vi(l+1));\r\n        mod = 1e9+7;\r\n    }\r\n \r\n    void setEye() {\r\n        for(int i=1;i<=l;i++) m[i][i]=1;\r\n    }\r\n\r\n    Matrix operator * (const Matrix& other) const {\r\n        Matrix ret;\r\n        for(int i=1;i<=l;i++) {\r\n            for(int j=1;j<=l;j++) {\r\n                for(int k=1;k<=l;k++) {\r\n                    ret.m[i][j] += m[i][k] * other.m[k][j] % mod;\r\n                    ret.m[i][j]%=mod;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    Matrix operator + (const Matrix& other) const {\r\n        Matrix ret;\r\n        for(int i=1;i<=l;i++) {\r\n            for(int j=1;j<=l;j++) {\r\n                ret.m[i][j] = m[i][j] + other.m[i][j];\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    Matrix power(ll k) { //matrix = matrix.power(k);\r\n        Matrix ret;\r\n        if(k==0) {\r\n            ret.setEye();\r\n            return ret;\r\n        }\r\n        if(k==1) {\r\n            return *this;\r\n        }\r\n\r\n        ret = power(k/2);\r\n        ret = ret * ret;\r\n        if(k&1) ret = ret * (*this);\r\n        return ret;\r\n    }\r\n    void rotate90CC() {\r\n        vvi after(l+1, vi(l+1));\r\n        for(int i=1;i<=l;i++) {\r\n            for(int j=1;j<=l;j++) { \r\n                after[i][j] = m[j][l-i+1];\r\n            }\r\n        }\r\n        for(int i=1;i<=l;i++) {\r\n            for(int j=1;j<=l;j++) {\r\n                m[i][j] = after[i][j];\r\n            }\r\n        }\r\n    }\r\n    void transpose() {\r\n        vvi after(l+1, vi(l+1));\r\n        for(int i=1;i<=l;i++) {\r\n            for(int j=1;j<=l;j++) {\r\n                after[i][j] = m[j][i];\r\n            }\r\n        }\r\n        for(int i=1;i<=l;i++) {\r\n            for(int j=1;j<=l;j++) {\r\n                m[i][j] = after[i][j];\r\n            }\r\n        }\r\n    }\r\n    void print(int N, int M) {\r\n        for(int i=1;i<=N;i++) {\r\n            for(int j=1;j<=M;j++) {\r\n                cout << m[i][j] << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\nstruct Segtree {\r\n    vi a;\r\n    vi s;\r\n    int n;\r\n    Segtree(int n) : n(n) {\r\n        a.resize(n+1);\r\n        s.resize(4*n+1);\r\n    }\r\n    int merge(int a, int b) {\r\n        return a+b;\r\n    }\r\n    int segment(int node, int nodeLeft, int nodeRight) {\r\n        if (nodeLeft == nodeRight) {\r\n            return s[node] = a[nodeLeft];\r\n        }\r\n        int mid = (nodeLeft+nodeRight)/2;\r\n        return s[node] = merge(segment(node * 2, nodeLeft, mid), segment(node * 2 + 1, mid + 1, nodeRight));\r\n    }\r\n    void update(int node, int nodeLeft, int nodeRight, int idx, int num) {\r\n        if (idx < nodeLeft || nodeRight < idx) return;\r\n        if (nodeLeft == nodeRight) {\r\n            s[node] = num;\r\n            return;\r\n        }\r\n        int mid = (nodeLeft+nodeRight)/2;\r\n        update(node * 2, idx, nodeLeft, mid, num);\r\n        update(node * 2 + 1, idx, mid + 1, nodeRight, num);\r\n\r\n        s[node] = merge(s[node * 2], s[node * 2 + 1]);\r\n    }\r\n    int query(int node, int l, int r, int nodeLeft, int nodeRight) {\r\n        if(nodeRight<l || r<nodeLeft) return 0;\r\n        if(l<=nodeLeft && nodeRight<=r) return s[node];\r\n        int mid = nodeLeft+nodeRight>>1;\r\n        return merge(query(node * 2, l, r, nodeLeft, mid), query(node * 2 + 1, l, r, mid + 1, nodeRight));\r\n    }\r\n    void print(int node, int nodeLeft, int nodeRight) {\r\n        cout << nodeLeft << \" \" << nodeRight << \" : \" << s[node] << endl;\r\n        if(nodeLeft==nodeRight) return;\r\n\r\n        int mid = (nodeLeft + nodeRight) >> 1;\r\n        print(node*2, nodeLeft, mid);\r\n        print(node*2+1, mid+1, nodeRight);\r\n    }\r\n};\r\n\r\nstruct lazySegtree {\r\n    vi a;\r\n    vi s;\r\n    vi lazy;\r\n    int n;\r\n    lazySegtree(int n) : n(n) {\r\n        a.resize(n+1);\r\n        s.resize(4*n+1);\r\n        lazy.resize(4*n+1);\r\n    }\r\n\r\n    int merge(int a, int b) {\r\n        return a+b;\r\n    }\r\n    int segment(int node, int nodeLeft, int nodeRight) { // use when s, a is available and segment tree is about sum\r\n        if (nodeLeft == nodeRight) {\r\n            return s[node] = a[nodeLeft];\r\n        }\r\n        int mid = (nodeLeft+nodeRight)/2;\r\n        return s[node] = merge(segment(node * 2, nodeLeft, mid), segment(node * 2 + 1, mid + 1, nodeRight));\r\n    }\r\n    void propagation(int node, int l, int r) {\r\n        if (lazy[node]) {\r\n            s[node] += (r - l + 1) * lazy[node];\r\n            if (l != r) {\r\n                lazy[node * 2] += lazy[node];\r\n                lazy[node * 2 + 1] += lazy[node];\r\n            }\r\n            lazy[node] = 0;\r\n        }\r\n    }\r\n    void update(int node, int l, int r, int nodeLeft, int nodeRight, int dif) { //This is for lazy propagation\r\n        propagation(node, nodeLeft, nodeRight);\r\n        if (nodeRight < l || r < nodeLeft) return;\r\n        if (l <= nodeLeft && nodeRight <= r) {\r\n            s[node] += (nodeRight-nodeLeft + 1) * dif;\r\n            if (nodeLeft != nodeRight) {\r\n                lazy[node * 2] += dif;\r\n                lazy[node * 2 + 1] += dif;\r\n            }\r\n            return;\r\n        }\r\n        int mid = (nodeLeft+nodeRight)/2;\r\n        update(node * 2, l, r, nodeLeft, mid, dif);\r\n        update(node * 2 + 1, l, r, mid + 1, nodeRight, dif);\r\n        s[node] = merge(s[node * 2], s[node * 2 + 1]);\r\n    }\r\n    ll query(int node, int l, int r, int nodeLeft, int nodeRight) { //s should be vll\r\n        propagation(node, nodeLeft, nodeRight);\r\n        if (nodeRight < l || r < nodeLeft) return 0;\r\n        if (l <= nodeLeft && nodeRight <= r) {\r\n            return s[node];\r\n        }\r\n        int mid = (nodeLeft+nodeRight)/2;\r\n        return merge(query(node * 2, l, r, nodeLeft, mid), query(node * 2+1, l, r, mid+1, nodeRight));\r\n    }\r\n};\r\n\r\nstruct DSU {\r\n    vi parent;\r\n    vi depth; //tree depth (maximum distance from root node)\r\n    vi d;\r\n    vi sz;\r\n    DSU(int n=1) {\r\n        parent = vi(n+1);\r\n        depth = vi(n+1, 0);\r\n        d = vi(n+1, 0);\r\n        sz = vi(n+1, 0);\r\n        iota(parent.begin()+1, parent.end(),1);\r\n        fill(sz.begin()+1, sz.end(), 1);\r\n    }\r\n    int getParent(int num) { \r\n        if(num==parent[num]) return num;\r\n        int p = getParent(parent[num]);\r\n        // d[num] += d[parent[num]];\r\n        return parent[num] = p;\r\n    }\r\n    \r\n    //modify merge to get difference between a and b\r\n    void merge(int a, int b, ll w=0) { \r\n        a = getParent(a);\r\n        b = getParent(b);\r\n        if(depth[a]<depth[b]) swap(a,b);\r\n        if(depth[a]==depth[b]) depth[a]+=1;\r\n        parent[b] = a;\r\n        sz[a] += sz[b];\r\n    }\r\n};\r\n\r\nvoid print(pii a) {\r\n    cout << a.first << \" \" << a.second << endl;\r\n}\r\ntemplate<typename T>\r\nvoid print(T *a, int start, int end) {\r\n    rep(i,start,end) cout << a[i] << \" \";\r\n    cout << endl;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid print(const T& a) {\r\n    cout << a << endl;\r\n}\r\n\r\nvoid print(const vector<pii>& v) {\r\n    for(auto p : v) {\r\n        print(p);\r\n    }\r\n    cout << endl;\r\n}\r\ntemplate <typename T>\r\nvoid print(const vector<T>& v) {\r\n    for(auto i : v) cout << i << \" \";\r\n    cout << endl;\r\n}\r\nbool inRange(int y, int x) {\r\n    return 1<=y && y<=N && 1<=x && x<=M;\r\n}\r\nbool inRangeN(int y, int x) {\r\n    return 1<=y && y<=N && 1<=x && x<=N;\r\n}\r\nvector<string> split(string input, char delimiter) {\r\n    vector<string> answer;\r\n    stringstream ss(input);\r\n    string temp;\r\n \r\n    while (getline(ss, temp, delimiter)) {\r\n        answer.push_back(temp);\r\n    }\r\n \r\n    return answer;\r\n}\r\n/*\r\nvector<int> combination;\r\nbool visited[1005];\r\nvoid dfs(int idx, int cnt) { //implement with dfs(1, 0). N and K must be global variable\r\n\tif(cnt==K) {\r\n\t\tfor(auto i : combination) {\r\n\t\t\tcout << i << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfor(int i=idx;i<=N;i++) { //idx, N\uc744 \uc798\ubcfc\uac83\r\n\t\tif(visited[i]==1) continue;\r\n\t\t\r\n\t\tvisited[i]=1;\r\n\t\tcombination.push_back(i);\r\n\t\tdfs(i+1, cnt+1); //be careful with i+1, cnt+1\r\n\t\tvisited[i]=0;\r\n\t\tcombination.pop_back();\r\n\t}\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n//This is persistent segment tree (PST)\r\n\r\n/*\r\nstruct Node {\r\n    Node *l, *r;\r\n    ll v;\r\n\r\n    Node() {\r\n        l = r = NULL;\r\n        v = 0;\r\n    }  \r\n};\r\n\r\n#define MAX 1000\r\n//When using MAX, root MAX and arr MAX is DIFFERENT!!!! KEEP IN MIND!!! \r\nNode* root[MAX];\r\nint arr[MAX];\r\n\r\nvoid build(Node *node, int nodeLeft, int nodeRight) {\r\n    if(nodeLeft == nodeRight) {\r\n        node->v = arr[nodeLeft];\r\n        return;\r\n    }\r\n    int m = nodeLeft + (nodeRight-nodeLeft)/2;\r\n\r\n    node->l = new Node();\r\n    node->r = new Node();\r\n   \r\n    build(node->l, nodeLeft, m);\r\n    build(node->r, m+1, nodeRight);\r\n\r\n    node->v = node->l->v + node->r->v;\r\n}\r\n\r\n//doesn't update origin segment tree but updates new segment tree and connects it into a existing tree\r\nvoid update(Node* prev, Node* now, int nodeLeft, int nodeRight, int idx, int value) { \r\n    if(nodeLeft == nodeRight) {\r\n        now->v = value;\r\n        return;\r\n    }\r\n\r\n    int middle = nodeLeft + (nodeRight-nodeLeft)/2;\r\n\r\n    if(idx <= middle) { //update left node\r\n        now->l = new Node(); now->r = prev->r;\r\n        update(prev->l, now->l, nodeLeft, middle, idx, value);\r\n    }\r\n    else { //update right node\r\n        now->l = prev->l; now->r = new Node();\r\n        update(prev->r, now->r, middle+1, nodeRight, idx, value);\r\n    }\r\n    now->v = now->l->v + now->r->v;\r\n}\r\n\r\nll query(Node *node, int nodeLeft, int nodeRight, int l, int r) { //want to know the addition of l~r\r\n    if(nodeRight < l || r < nodeLeft) return 0;\r\n    if(l <= nodeLeft && nodeRight <= r) return node->v;\r\n\r\n    int middle = nodeLeft + (nodeRight-nodeLeft)/2;\r\n\r\n    return query(node->l, nodeLeft, middle, l, r) + query(node->r, middle+1, nodeRight, l, r);\r\n}\r\n\r\n*/\r\n\r\n/* could help if above update isn't appliable\r\nNode* update(Node* now, int nodeLeft, int nodeRight, int idx, int value) {\r\n    if (nodeRight < idx || idx < nodeLeft) return now;\r\n    \r\n    if (nodeLeft == nodeRight) {\r\n        Node* leaf = new Node();\r\n        leaf->v = now->v + value;\r\n        return leaf;\r\n    }\r\n\r\n    int middle = nodeLeft + (nodeRight - nodeLeft) / 2;\r\n    Node* leaf = new Node();\r\n    leaf -> l = update(now->l, nodeLeft, middle, idx, value);\r\n    leaf -> r = update(now->r, middle + 1, nodeRight, idx, value);\r\n\r\n\r\n    leaf->v = leaf->l->v + leaf->r->v;\r\n    return leaf;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n/*\r\n\r\n//THIS IS FENWICK_TREE\r\n//Fenwic_tree starts from index 1. \r\n#define MAX 500001\r\nint arr[MAX];\r\nint fenwick[MAX];\r\n\r\n//update function reflects the change of arr value, not the absolute value\r\n//if arr value, say arr[3] changes into 3 to 5, then update(3,2) should be used.\r\n//update(idx, c-arr[idx]); arr[idx] = c;\r\nvoid update(int idx, int Value) { //For Making Fenwick Tree, for(int i=1~N) Update(i, arr[i]);\r\n    while (idx <= N) {\r\n        fenwick[idx] = fenwick[idx] + Value;\r\n        idx = idx + (idx & -idx);\r\n    }\r\n}\r\n\r\nint sum(int idx) { //IF 3~5 sum is required it should be sum(5)-sum(2);\r\n    int result = 0; //BE CAREFUL ON RANGE (Long Long could be used)\r\n    while (idx > 0) {\r\n        result += fenwick[idx];\r\n        idx = idx - (idx & -idx);\r\n    }\r\n    return result;\r\n}\r\n\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/* \r\n\r\n//two dimensional fenwick tree\r\n#define MAX 1026\r\nll arr[MAX][MAX];\r\nll fenwick[MAX][MAX];\r\n\r\nvoid update(int x, int y, ll value) {\r\n    while(x < N+1) {\r\n        int tempy = y;\r\n        while(tempy < N+1) {\r\n            fenwick[x][tempy] += value;\r\n            tempy += (tempy & -tempy);\r\n        }\r\n\r\n        x += (x & -x);\r\n    }\r\n}\r\n\r\n//sum(x,y) means sum of arr[1][1]~arr[x][y]\r\nll sum(int x, int y) {\r\n    ll ret=0;\r\n    while(x>0) {\r\n        int tempy = y;\r\n        while(tempy > 0) {  \r\n            ret += fenwick[x][tempy];\r\n            tempy -= (tempy & -tempy);\r\n        }\r\n        x -= (x & -x);\r\n    }\r\n    return ret;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n// THIS IS TARJAN ALGORITHM FOR SCC\r\n\r\n/*\r\n#define MAX 10001 //when used in 2-sat, you have to double node because not only x1~x100 is required but also Nx1~Nx100\r\nvvi SCC;\r\nint d[MAX];\r\nbool finished[MAX];\r\nvi edge[MAX];\r\nint id, SN=0; //mark sn[i]\r\nstack<int> s;\r\nint sn[MAX]; //sn[i] is SCC number to which it belongs to. If sn is big, then it is at the start of DAG. If small, it is at the end of DAG. If one wants to start from the beginning of DAG, start from the largest of sn.\r\nint SCCnode[MAX] {}; //if SCCbfs is needed...\r\nint nodeValue[MAX] {}; //if SCCbfs is needed...\r\nint dfs(int x) {\r\n    d[x] = ++id; //\ub178\ub4dc\ub9c8\ub2e4 \uace0\uc720\ud55c \uc544\uc774\ub514 \ubd80\uc5ec\r\n    s.push(x); //\uc2a4\ud0dd\uc5d0 \uc790\uae30 \uc790\uc2e0\uc744 \uc0bd\uc785\r\n    int parent = d[x];\r\n    for (auto i : edge[x]) {\r\n        if (d[i] == 0) { //\ubc29\ubb38 \uc548 \ud55c \uc774\uc6c3\r\n            parent = min(parent, dfs(i));\r\n        }\r\n        else if (finished[i] == 0) { //\ucc98\ub9ac \uc911\uc778 \uc774\uc6c3\r\n            parent = min(parent, d[i]);\r\n        }\r\n    }\r\n    if (parent == d[x]) {\r\n        vector<int> scc;\r\n        while (true) {\r\n            int t = s.top();\r\n            s.pop();\r\n            scc.push_back(t);\r\n            finished[t] = 1;\r\n            sn[t] = SN;\r\n            //d[t] = x; //to make scc recognizable with d\r\n            //SCCnode[SN] += nodeValue[t];\r\n            if (t == x) break;\r\n        }\r\n        SN++;\r\n        SCC.push_back(scc); //SCC\uc758 SN\ubc88\uc9f8 \uadf8\ub798\ud504\ub791 \ub300\uc751\ub41c\ub2e4\r\n    }\r\n    return parent;\r\n}\r\n\r\nvi SCCedge[MAX]; //index refers to SN. Could be replaced with set if you don't want to overlap\r\nint inDegree[MAX]; //index refers to SN\r\nvoid SCCtopology_sort() {\r\n    for(int i=1;i<=N;i++) { //id starts with 1\r\n        for(auto next : edge[i]) {\r\n            if(sn[next]!=sn[i]) {\r\n                SCCedge[sn[i]].pbk(sn[next]); //SN could be overlapped. Could be solved with set but it is often not needed\r\n                inDegree[sn[next]]+=1; //If inDegree is 0, then it is the start of the SCC graph. There could be many\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//If SCC sum is needed\r\nint SCCdp[MAX] {};\r\nvoid SCCbfs(int x) { //x is sn. bfs graph is not vertex graph but scc graph. scc graph is DAG so visited array is not needed\r\n    //bfs starts with x. Function flows through SCC graph (topologically)\r\n    qi q;\r\n    q.push(x);\r\n    SCCdp[x] = SCCnode[x];\r\n\r\n    while(!q.empty()) {\r\n        int cur = q.front();\r\n        q.pop();\r\n  \r\n        for(auto next : SCCedge[cur]) {\r\n            if(SCCdp[next] < SCCdp[cur] + nodeValue[next]) {\r\n                SCCdp[next] = SCCdp[cur] + nodeValue[next];\r\n                q.push(next);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint oppo(int num) { //This is for 2-sat\r\n    return num % 2 ? num + 1 : num - 1;\r\n}\r\n\r\nint result[MAX] {}; //For finding value of each clause (x1, x2, x3)\r\nvoid sat2() { // (x1 or x2) and (Nx1 or x3) //Nx1->x2, Nx2->x1. x1->x3, Nx3->Nx1\r\n    cin >> N >> M; // N is # of node, M is # of conditions\r\n    for (int i = 0; i < M; i++) {\r\n        int A, B; //If num is negative #, then it is (not) positive num\r\n        cin >> A >> B; \r\n        A = A > 0 ? 2 * A - 1 : -2 * A; //positive num goes 1->1, 2->3, 3->5, 4->7, 5->9... and so on\r\n        B = B > 0 ? 2 * B - 1 : -2 * B; //negative num goes -1->2, -2->4, -3->6, -4->8... and so on\r\n        edge[oppo(A)].push_back(B);\r\n        edge[oppo(B)].push_back(A);\r\n    }\r\n    for (int i = 1; i <= 2 * N; i++) { //node is 1~2*N\r\n       if (d[i] == 0) dfs(i);\r\n    }\r\n    for (int i = 1; i <= N; i++) {\r\n        if (sn[2 * i-1] == sn[2 * i]) {\r\n            cout << \"contradiction!\" << \" \" << sn[i] << endl;\r\n        }\r\n    }\r\n   \r\n    //For finding out value of each clause\r\n\r\n    memset(result, -1, sizeof(result));\r\n    pii p[MAX];\r\n    for(int i=1;i<=2*N;i++) {\r\n        p[i] = {sn[i], i};\r\n    }\r\n    sort(p+1, p+2*N+1);\r\n\r\n    for(int i=2*N;i>0;i--) { //Start from the beginning of DAG \r\n        int node = p[i].second;\r\n        int src = (node+1)/2;\r\n      \r\n        if(result[src] == -1) result[src] = node%2 ? 0 : 1; \r\n    }\r\n\r\n    for(int i=1;i<=N;i++) {\r\n        cout << result[i] << \" \";\r\n    }\r\n}\r\n\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n// This is Dijkstra, Time Complexity O((V+E)logV)\r\n/*\r\n#define MAX 100001\r\nvpii edge[MAX]; // first is idx, second is weight of edge\r\nint d[MAX];\r\nstruct cmp { //pii\r\n    bool operator() (const pii& i, const pii& j) {\r\n        return i.second > j.second;\r\n    }\r\n};\r\nvoid Dijkstra(int num) {\r\n    p_q<pii, vpii, cmp> pq;\r\n    pq.push({ num, 0 });\r\n    fill(d + 1, d + 1 + N, INF); //INF could be larger, varying from problem to problem\r\n    d[num] = 0;\r\n    while (!pq.empty()) {\r\n        auto [cur, dis] = pq.top();\r\n        pq.pop();\r\n        if(d[cur]<dis) continue;\r\n        for (auto next : edge[cur]) {\r\n            if(d[next.first] > d[cur] + next.second) {\r\n                d[next.first] = d[cur]+next.second;\r\n                pq.push({next.first, d[next.first]});\r\n            }\r\n        }\r\n    }\r\n    for(int i = 1; i <= N; i++) {\r\n        cout << d[i] << \" \";\r\n    }\r\n    cout << endl;\r\n}\r\n*/\r\n\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n//This is SPFA \r\n/*\r\n#define MAX 100001\r\nbool inQ[MAX] {};\r\nvpii edge[MAX];\r\nint d[MAX];\r\nint cycle[MAX] {};\r\nvoid SPFA(int start) {\r\n    fill(d+1, d+1+N, INF);\r\n    qi q;\r\n    d[start] =0;\r\n    q.push(start);\r\n    inQ[start] = 1;\r\n    cycle[start] += 1;\r\n    while(!q.empty()) {\r\n        int cur = q.front();\r\n        q.pop();\r\n        inQ[cur] = 0;\r\n        for(auto next : edge[cur]) {\r\n            if(d[next.first] > d[cur] + next.second) {\r\n                d[next.first] = d[cur] + next.second;\r\n                if(!inQ[next.first]) {\r\n                    cycle[next.first] += 1;\r\n                    if(cycle[next.first]>=N) {\r\n                        cout << \"CYCLE!!!!\" << endl;\r\n                        return;\r\n                    }\r\n                    q.push(next.first);\r\n                    inQ[next.first] = 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\n// This is Floyd-Warshall\r\n/*\r\n#define MAX 501\r\nint dp[MAX][MAX] {}; //input should be done in dp table\r\nvoid floyd_warshall() {\r\n    rep(k, 1, N) {\r\n        rep(i, 1, N) {\r\n            rep(j, 1, N) {\r\n                if (dp[i][j] > dp[i][k] + dp[k][j]) dp[i][j] = dp[i][k] + dp[k][j];\r\n            }\r\n        }\r\n    }\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n//This is Kruskal with union find\r\n//When using Kruskal vector Edge is a little bit different\r\n/*\r\nclass Edge {\r\npublic:\r\n    int node[2];\r\n    int dis;\r\n    Edge(int a, int b, int _dis) {\r\n        node[0] = a;\r\n        node[1] = b;\r\n        dis = _dis;\r\n    }\r\n    bool operator < (const Edge& edge) { \r\n        return dis > edge.dis; //watch out for inequality sign\r\n    }\r\n};\r\nvector<Edge> edge;\r\nvoid Kruskal() { //MST\r\n    cin >> N >> M; //N is node, M is edge, Node starts from 1 to N\r\n    for (int i = 0; i < M; i++) {\r\n        int s, e, dis;\r\n        cin >> s >> e >> dis;\r\n        edge.push_back(Edge(s, e, dis));\r\n    }\r\n    DSU dsu(N);\r\n    sort(all(edge));\r\n    \r\n    int sum = 0;\r\n    for (int i = 0; i < edge.size() ; i++) {\r\n        int nodeA = edge[i].node[0];\r\n        int nodeB = edge[i].node[1];\r\n        int dis = edge[i].dis;\r\n        if (dsu.getParent(nodeA)==dsu.getParent(nodeB)) {\r\n            dsu.merge(nodeA, nodeB);\r\n            sum+=dis;\r\n        }\r\n    }\r\n    cout << \"total distance required for executing kruskal is : \" << sum << endl;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n//This is Network Flow with Dinic Algorithm. Time Complexity O(V^2 * E)\r\n\r\n// \r\n/*\r\n#define MAX 100 //MAX should be treated carefully since space complexity is limited. (256mb, 512mb)\r\nvector<int> edge[MAX];\r\nint f[MAX][MAX], c[MAX][MAX];\r\nint level[MAX], work[MAX];\r\nint src, sink;\r\nint bias;\r\n\r\nvoid addEdge(int s, int e, int value=1) { //Decide whether graph is directed graph or undirected graph\r\n    edge[s].pbk(e);\r\n    edge[e].pbk(s);\r\n    c[s][e] = value;\r\n}\r\nbool bfs() { // to create level graph and decide if flow is no longer needed\r\n    queue<int> q;\r\n    q.push(src); //\r\n    memset(level, -1, sizeof(level));\r\n    level[src] = 0;\r\n    while (!q.empty()) {\r\n        int cur = q.front();\r\n        q.pop();\r\n        for (auto next : edge[cur]) {\r\n            if (level[next] == -1 && c[cur][next] - f[cur][next] > 0) {\r\n                q.push(next);\r\n                level[next] = level[cur] + 1;\r\n            }\r\n        }\r\n    }\r\n    if (level[sink] == -1) return false;\r\n    else return true;\r\n}\r\nint dfs(int cur, int flow) { //cur node has flow to offer to the next level\r\n    if (cur == sink) return flow;\r\n\r\n    for (int& i = work[cur]; i < edge[cur].size(); i++) {\r\n        int next = edge[cur][i];\r\n        if (level[next] == level[cur] + 1 && c[cur][next] - f[cur][next] > 0) {\r\n            int ret = dfs(next, min(flow, c[cur][next] - f[cur][next]));\r\n            if (ret > 0) {\r\n                f[cur][next] += ret;\r\n                f[next][cur] -= ret; //always remember to create reverse flow\r\n                return ret;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nint Network_Flow() {\r\n    int totalFlow = 0;\r\n    while (bfs()) {\r\n        memset(work, 0, sizeof(work));\r\n        while (true) {\r\n            int flow = dfs(src, INF); //INF varies from range to range\r\n            if (flow == 0) break;\r\n            totalFlow += flow;\r\n        }\r\n    }\r\n    return totalFlow;\r\n}\r\n*/\r\n\r\n\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n//Network Flow with Edmonds Karp\r\n/*\r\n#define MAX 100\r\nint d[MAX] {}; //keep track of parent\r\nvi edge[MAX];\r\nint f[MAX][MAX], c[MAX][MAX];\r\nint maxFlow(int start, int end) {\r\n    int result=0;\r\n    while(1) {\r\n        fill(d, d+MAX, -1);\r\n        qi q;\r\n        q.push(start);\r\n     \r\n        while(!q.empty()) {\r\n            int cur = q.front();\r\n            q.pop();\r\n            for(auto next : edge[cur]) {\r\n                if(c[cur][next]-f[cur][next] > 0 && d[next]==-1) {\r\n                    q.push(next);\r\n                    d[next] = cur;\r\n                    if(next==end) break;\r\n                }\r\n            }\r\n        }\r\n     \r\n        if(d[end]==-1) break;\r\n     \r\n        int flow = INF;\r\n     \r\n        for(int i=end;i!=start;i=d[i]) {\r\n            flow = min(flow, c[d[i]][i] - f[d[i]][i]);\r\n        }\r\n     \r\n        for(int i=end;i!=start;i=d[i]) {\r\n            f[d[i]][i] += flow;\r\n            f[i][d[i]] -= flow;\r\n        }\r\n        result += flow;\r\n    }\r\n    return result;\r\n}\r\n*/\r\n\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n//MCMF with SPFA+Edmonds-Karp\r\n\r\n/*\r\n#define MAX 1001\r\nint f[MAX][MAX]; //flow\r\nint c[MAX][MAX]; //capacity\r\nint d[MAX][MAX]; //cost of flowing fluid. f[x][y] * d[x][y] is\r\nint S, T;\r\nvi edge[MAX];\r\nint bias; //set bias in bipartite graph\r\n//MCMF could be done with Dinic but is not effective unless it has sparse table\r\n//https://justicehui.github.io/hard-algorithm/2020/03/24/effective-mcmf/\r\n//but it is nonetheless more effective than SPFA+Edmonds-Karp\r\nvoid MCMF() { \r\n    //set S and T\r\n    //input edge\r\n\r\n    ll result =0;\r\n    while(1) {\r\n        int prev[MAX]{}; //record previous node\r\n        int dist[MAX]{}; //record \r\n        bool inQ[MAX] {};\r\n\r\n        fill(prev, prev+MAX, -1);\r\n        fill(dist, dist+MAX, INF);\r\n\r\n        qi q;\r\n        q.push(S);\r\n        inQ[S] = 1;\r\n        dist[S] = 0;\r\n        while(!q.empty()) {\r\n            int cur = q.front();\r\n            q.pop();\r\n            inQ[cur] =0;\r\n\r\n            for(auto next : edge[cur]) {\r\n                if(c[cur][next]-f[cur][next] > 0 && dist[next] > dist[cur] + d[cur][next]) {\r\n                    dist[next] = dist[cur] + d[cur][next];\r\n                    prev[next] = cur;\r\n\r\n                    if(!inQ[next]) {\r\n                        inQ[next] = 1;\r\n                        q.push(next);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(prev[T]==-1) break;\r\n\r\n        int flow = INF;\r\n        for(int i = T;i!=S;i=prev[i]) {\r\n            flow = min(flow, c[prev[i]][i]-f[prev[i]][i]);\r\n        }\r\n\r\n        \r\n        for(int i = T;i!=S;i=prev[i]) {\r\n            result += flow * d[prev[i]][i];\r\n            f[prev[i]][i] += flow;\r\n            f[i][prev[i]] -= flow;\r\n        }\r\n    }\r\n    cout << result;\r\n}   \r\n\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n// This is CCW\r\n\r\n//depending on input, the value ccw could be beyond INTEGER. Even long long could be dangerous. Watch carefully on input range\r\n/*\r\nstruct Point {\r\n    ll x, y;\r\n    Point(ll x, ll y) : x(x), y(y) {}\r\n};\r\nstruct Line {\r\n    Point p1, p2;\r\n};\r\nll CCW(Point A, Point B, Point C) { //A, B, C is in order\r\n    ll ccw = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y); //Cross product\r\n    if(ccw>0) return 1;\r\n    else if(ccw<0) return -1;\r\n    else return 0;\r\n}\r\n//\r\nint LineInterSection(Line l1, Line l2) { \r\n\tll l1_l2 = CCW(l1.p1, l1.p2, l2.p1) * CCW(l1.p1, l1.p2, l2.p2);\r\n    ll l2_l1 = CCW(l2.p1, l2.p2, l1.p1) * CCW(l2.p1, l2.p2, l1.p2);\r\n\t\r\n\tif(l1_l2==0 && l2_l1==0) { //l1 and l2 is on the same line. If p1 <= p4 && p3 <= p2, the line meets.\r\n\t\tif(l1.p1.x > l1.p2.x) swap(l1.p1, l1.p2);\r\n\t\tif(l2.p1.x > l2.p2.x) swap(l2.p1, l2.p2);\r\n\r\n\t\treturn l1.p1.x <= l2.p2.x && l2.p1.x <= l1.p2.x;\r\n\t}\r\n    return (l1_l2 <= 0) && (l2_l1 <= 0);\r\n}\r\nvector<Point> v;\r\nbool cmp(const Point& a, const Point& b) {\r\n    ll ccw = CCW(v[0], a, b);\r\n    if(ccw) return ccw>0;\r\n    if(a.y==b.y) return a.x < b.x;\r\n    return a.y < b.y;\r\n}\r\nstack<Point> s;\r\n//to find if X point exists within the convex polygon, do CCW(i,i+1,X point) and see if CCW value is the same for all\r\nvoid Convex_Hull() {\r\n    sort(all(v), [](Point a, Point b) {\r\n        if(a.y==b.y) return a.x<b.x;\r\n        return a.y<b.y;\r\n    });\r\n\r\n    sort(v.begin()+1, v.end(), cmp);\r\n\r\n    s.push(v[0]);\r\n    s.push(v[1]);\r\n\r\n    rep(i,2,N-1) {\r\n        while(s.size()>=2) {\r\n            auto t2 = s.top();\r\n            s.pop();\r\n            auto t1 = s.top();\r\n\r\n            if(CCW(t1, t2, v[i])>0) {\r\n                s.push(t2);\r\n                break;\r\n            }\r\n        }\r\n        s.push(v[i]);\r\n    }\r\n    cout << s.size();\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n\r\n// This is LCA with binary algorithm (O(logN))\r\n/*\r\n#define MAX 100001\r\nvi edge[MAX];\r\n//vpii edge[MAX] {};\r\n//int d[MAX][18];\r\nint parent[MAX][18]; //18 is log2(MAX)\r\nint level[MAX];\r\nint maxLevel;\r\n\r\n//init -> set_tree -> LCA(a,b)\r\nvoid init() {\r\n    cin >> N; //Has N node and N-1 edges\r\n    for(int i=0;i<N-1;i++) {\r\n        int a, b;\r\n        cin >> a >> b;\r\n        edge[a].pbk(b);\r\n        edge[b].pbk(a);\r\n    }\r\n    maxLevel = (int)floor(log2(MAX));\r\n}\r\n//maps node and depth and set 2^i parent\r\n//use before LCA function\r\n//set_tree(root, 0) should do it\r\n//if node 0 exists, then this function needs to be altered\r\n//get root node by inDegree array.\r\nvoid set_tree(int node, int pnode) {\r\n    level[node] = level[pnode]+1;\r\n    parent[node][0] = pnode;\r\n\r\n    for(int i=1;i<=maxLevel;i++) {\r\n        int prev = parent[node][i-1];\r\n        parent[node][i] = parent[prev][i-1];\r\n        //d[node][i] = d[prev][i-1] + d[node][i-1];\r\n    }\r\n\r\n    for(auto child : edge[node]) {\r\n        if(child==pnode) continue;\r\n        //d[child.first][0] = child.second;\r\n        set_tree(child, node);\r\n    }\r\n}\r\n\r\nint LCA(int a, int b) {\r\n    if(a==1 || b==1) return 1;\r\n\r\n    int target = a, compare = b;\r\n    if(level[a] < level[b]) swap(target, compare); //target is deeper\r\n\r\n    // int answer = 0; //for length\r\n    //set level[] equal\r\n    if(level[target]!=level[compare]) { \r\n        for(int i=maxLevel;i>=0;i--) {\r\n            if(level[parent[target][i]] >= level[compare]) {\r\n                //answer += d[target][i];\r\n                target = parent[target][i];\r\n            }\r\n        }\r\n    }\r\n\r\n    int ret = target;\r\n    \r\n    //set target==compare\r\n    if(target!=compare) {\r\n        for(int i=maxLevel;i>=0;i--) {\r\n            if(parent[target][i]!=parent[compare][i]) {\r\n                // answer += d[target][i];\r\n                // answer += d[compare][i];\r\n\r\n                target = parent[target][i];\r\n                compare = parent[compare][i];\r\n            }\r\n            ret = parent[target][i];\r\n        }\r\n    }\r\n    //answer += d[target][0] + d[compare][0];\r\n    return ret;\r\n}\r\n\r\n*/\r\n\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/*\r\nvoid LIS(vi& v) { //vector v's size is N\r\n    vi lis;\r\n    vi dp(N);\r\n\r\n    fill(all(dp), 1); //set all dp element to at least 1\r\n    rep(i,0,N-1) { // N\r\n        int cur = v[i];\r\n\r\n        //whether it should be lower_bound or upper_bound depends on the problem\r\n        //if non-decreasing sequence is allowed, for example 10 10 20 30... then it should be upper_bound\r\n        //if only strictly increasing sequence is allowed, for example 10 20 40... then it should be lower_bound\r\n        //https://www.acmicpc.net/problem/12738    this problem only allows strictly increasing order meaning one should use lower_bound\r\n        //https://www.acmicpc.net/problem/2352     this problem also allows strictly increasing order but the element in array is never overlapped so it can use both lower_bound and upper_bound\r\n        //to create LDS (longest decreasing sequence), simply invert sign.\r\n        \r\n        auto iter = lower_bound(all(lis), cur);\r\n        //if found, replace the value with cur. if not, cur is the highest value of lis\r\n        if(iter!=lis.end()) {\r\n            *iter = cur; \r\n            dp[i] = iter - lis.begin()+1;\r\n        }\r\n        else {\r\n            lis.pbk(cur);\r\n            dp[i] = lis.size(); \r\n        }\r\n    }\r\n    stack<int> s;\r\n\r\n    int sz = *max_element(all(dp)); //LIS size\r\n    cout << sz << endl;\r\n    for(int i=N-1;i>=0;i--) {\r\n        if(sz==dp[i]) {\r\n            s.push(v[i]);\r\n            sz--;\r\n        }\r\n    }\r\n\r\n    while(!s.empty()) {\r\n        cout << s.top() << \" \";\r\n        s.pop();\r\n    }\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/*\r\n\r\n//big integer addition\r\nstring add(string a, string b) {\r\n    // Initialize variables\r\n    string result = \"\";\r\n    int carry = 0;\r\n    int a_len = a.length();\r\n    int b_len = b.length();\r\n\r\n    // Loop through both strings, starting at the last character\r\n    for (int i = a_len - 1, j = b_len - 1; i >= 0 || j >= 0 || carry; i--, j--)\r\n    {\r\n        // Get the current digit of each string, or 0 if we have reached the beginning\r\n        int x = (i >= 0) ? a[i] - '0' : 0;\r\n        int y = (j >= 0) ? b[j] - '0' : 0;\r\n\r\n        // Add the digits and carry, and store the result\r\n        result = char((x + y + carry) % 10 + '0') + result;\r\n\r\n        // Calculate the new carry\r\n        carry = (x + y + carry) / 10;\r\n\t\tcout << \"CARRY : \" << carry << endl;\r\n    }\r\n\r\n    return result;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n//rotate matrix by 90 degrees\r\n\r\n/*\r\nvoid rotate() { //rotating N*N matrix by 90 degrees clockwise\r\n    for(int i=0; i<N; i++) {\r\n        for(int j=0; j<N; j++) {\r\n            temp_arr[i][j] = arr[N - j -1][i]; //N-j+1 if 1~N\r\n        }\r\n    }\r\n    memmove(arr, temp_arr, sizeof(arr));\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n// Trie\r\n/*\r\n#define TRIENODE 26\r\nstruct Trie {\r\n    Trie *next[TRIENODE]; // \ub2e4\uc74c \ub178\ub4dc\ub97c \uac00\ub9ac\ud0a4\ub294 \ud3ec\uc778\ud130 \ubc30\uc5f4\r\n    //map<string, Trie*> next;\r\n    bool finish;\r\n    Trie *fail; //for Aho-corasick\r\n    Trie() {\r\n        fill(next, next + TRIENODE, nullptr);\r\n        finish = false;\r\n    }\r\n \r\n    ~Trie() {\r\n        for (int i = 0; i < TRIENODE; i++) {\r\n            if (next[i]) delete next[i];\r\n        }\r\n    }\r\n\r\n    int getIdx(char c) {\r\n        return c-'A';\r\n    }\r\n    void insert(const string& str, int k=0) {\r\n        if (k==str.size()) {\r\n            finish = true;\r\n            return;\r\n        }\r\n\r\n        int curKey = getIdx(str[k]); //or 'a' or '0'\r\n \r\n        if (next[curKey]==nullptr) next[curKey] = new Trie();\r\n\r\n        next[curKey]->insert(str, k+1); // \ub2e4\uc74c \ubb38\uc790 \uc0bd\uc785\r\n    }\r\n\r\n    void init() { //Aho-corasick. use when this is root\r\n        queue<Trie*> q;\r\n        q.push(this);\r\n        \r\n        while(!q.empty()) {\r\n            Trie* cur = q.front();\r\n            q.pop();\r\n\r\n            for(int i=0;i<TRIENODE;i++) {\r\n                Trie *nextTrie = cur->next[i];\r\n                if(nextTrie==nullptr) continue;\r\n\r\n                if(cur==this) {\r\n                    nextTrie->fail = this;\r\n                }\r\n                else {\r\n                    Trie *dest = cur->fail;\r\n\r\n                    while(dest!=this && dest->next[i]==nullptr) {\r\n                        dest = dest->fail;\r\n                    }\r\n                    if(dest->next[i]) dest = dest->next[i];\r\n\r\n                    nextTrie->fail = dest;\r\n                }\r\n                if(nextTrie->fail->finish) nextTrie->finish = true;\r\n                q.push(nextTrie);\r\n            }\r\n        }\r\n    }\r\n\r\n    void query(const string& str) { //for Aho-corasick\r\n        Trie *cur = this;\r\n        int cnt = 0;\r\n        for(auto c : str) {\r\n            int curKey = getIdx(c);\r\n            \r\n            while(cur!=this && cur->next[curKey]==nullptr) {\r\n                cur = cur->fail;\r\n            }\r\n\r\n            if(cur->next[curKey]) cur = cur->next[curKey];\r\n\r\n            if(cur->finish) cnt++;\r\n        }\r\n    }\r\n    bool find(const string& str, int k=0) {\r\n        if (k==str.size()) return true; // \ubb38\uc790\uc5f4\uc774 \ub05d\ub098\ub294 \uc704\uce58\ub97c \ubc18\ud658\r\n        int curKey = getIdx(str[k]); //or 'a' or '0'\r\n        if (next[curKey] == nullptr) return false; // \ucc3e\ub294 \uac12\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\uc74c\r\n        return next[curKey]->find(str, k+1); // \ub2e4\uc74c \ubb38\uc790\ub97c \ud0d0\uc0c9\r\n    }\r\n};\r\n\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/*\r\n//KMP\r\nvi getPi(const string& pattern) {\r\n    int patternSize = pattern.size();\r\n\r\n    vi pi(patternSize);\r\n\r\n    int j = 0;\r\n    for(int i=1;i<patternSize;i++) {\r\n        while(j>0 && pattern[i] != pattern[j]) {\r\n            j = pi[j-1];\r\n        }\r\n\r\n        if(pattern[i]==pattern[j]) {\r\n            j+=1;\r\n            pi[i] = j;\r\n        }\r\n    }\r\n    return pi;\r\n}\r\n\r\nvoid KMP(const string& parent, const string& pattern) {\r\n    vi pi = getPi(pattern);\r\n\r\n    int parentSize = parent.size();\r\n    int patternSize = pattern.size();\r\n\r\n    int j =0;\r\n\r\n    for(int i=0;i<parentSize;i++) {\r\n        while(j>0 && parent[i] != pattern[j]) {\r\n            j = pi[j-1];\r\n        }\r\n        if(parent[i] == pattern[j]) {\r\n            if(j == patternSize-1) {\r\n                cout << i-patternSize + 2 << endl; //index starts from 1\r\n                j = pi[j];\r\n            }\r\n            else {\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/*\r\n//extended euclidian\r\n// to find modular inverse\r\n// Find modular inverse of a in MOD N\r\n// if gcd(a,N)!=1, then modular inverse does not exist\r\n// s*a + t*N = 1\r\n// s is the modular inverse\r\nll exEuclid(ll a, ll b, ll &s, ll &t) { //s*a + t*b = gcd(a,b)\r\n\tif (b == 0) {\r\n\t\ts = 1; t = 0;\r\n\t\treturn a;\r\n\t}\r\n\tll gcd = exEuclid(b, a%b, s, t);\r\n\tll temp = t;\r\n\tt = s - (a / b)*t;\r\n\ts = temp;\r\n\r\n\tif (s <= 0) {\r\n\t\ts += b;\r\n\t\tt -= a;\r\n\t}\r\n\treturn gcd;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/* \r\n//https://kangminjun.tistory.com/entry/Manacher-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\r\n//This is manachar's algorithm for finding biggest palindrome in substring\r\n#define MAX 200001\r\nint A[MAX] {}; //saves the sz of palindrome each side including i itself\r\nstring preprocess(const string& str) { //to find even palindrome as well\r\n    string temp;\r\n    for(auto c : str) {\r\n        temp.pbk('#');\r\n        temp.pbk(c);\r\n    }\r\n    temp.pbk('#');\r\n    return temp;\r\n}\r\nvoid manacher(string str) {\r\n    int r = 0, p = 0; //p is the value that maximize j+A[j]\r\n    str = preprocess(str);\r\n    int sz = str.size();\r\n    \r\n    for (int i = 0; i < sz; i++) {\r\n        if (i <= r) {\r\n            A[i] = min(A[2 * p - i], r - i);\r\n        }\r\n        while (i-A[i]-1>=0 && i+A[i]+1<sz && str[i-A[i]-1]==str[i+A[i]+1]) {\r\n            A[i]++;\r\n        }\r\n        if (r < i + A[i]) {\r\n            r = i + A[i];\r\n            p = i;\r\n        }\r\n    }\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/* \tArticulation Points\r\n#define MAX 10001\r\nvi edge[MAX];\r\nint visited[MAX] {};\r\nint num=1;\r\nbool isCut[MAX] {};\r\n//for 1~N, if visited[i]==0, dfs(i,1);\r\nint dfs(int cur, bool isRoot) {\r\n    visited[cur] = num;\r\n    num++;\r\n    int ret = visited[cur];\r\n\r\n    int child = 0;\r\n    for(auto next : edge[cur]) {\r\n        if(visited[next]) {\r\n            ret = min(ret, visited[next]);\r\n            continue;\r\n        }\r\n        child++;\r\n        int prev = dfs(next, 0);\r\n\r\n        if(isRoot==0 && prev>=visited[cur]) isCut[cur] = 1;\r\n        \r\n        ret = min(ret, prev);\r\n    }\r\n    if(isRoot && child>=2) isCut[cur] = 1;\r\n    return ret;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/* \tArticulation Bridges\r\n#define MAX 100001\r\nint visited[MAX] {};\r\nvi edge[MAX];\r\nvpii isCut;\r\nint num = 1;\r\n//for 1~N if visited[i]==0, dfs(i,-1)\r\nint dfs(int cur, int parent) {\r\n    visited[cur] = num;\r\n    num++;\r\n    int ret = visited[cur];\r\n\r\n    for(auto next : edge[cur]) {\r\n        if(next==parent) continue;\r\n\r\n        if(visited[next]!=0) {\r\n            ret = min(ret, visited[next]);\r\n            continue;\r\n        }\r\n\r\n        int prev = dfs(next, cur);\r\n\r\n        if(prev>visited[cur]) {\r\n            isCut.pbk({min(next, cur), max(next, cur)});\r\n        }\r\n        ret = min(ret, prev);\r\n    }\r\n    return ret;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/* \r\n//typical bipartite problems can be solved with dinic as it will work in O(E * \u221aV)\r\n//but memory will be N*M whereas Hopcroft_Karp will use max(N,M) + E\r\n//so use dinic when N,M <=1000 and Hopcroft_Karp when N,M>1000\r\n//This is Hopcroft_Karp Algorithm\r\n#define MAX 10001\r\nvi edge[MAX];\r\nbool used[MAX];\r\n//matched with A/B group. Thus B[A[i]] == i\r\n//set initial value of A, B to -1\r\nint a[MAX] {};\r\nint b[MAX] {};\r\n//dist does not need to be initialized as it is set in bfs\r\nint dist[MAX] {}; //distance between non matched vertex in A\r\nvoid bfs() { //set dist array\r\n\tqi q; //push only A array not B\r\n\t\r\n\tfor(int i=1;i<=N;i++) {\r\n\t\tif(used[i]==0) {\r\n\t\t\tdist[i]=0;\r\n\t\t\tq.push(i);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdist[i]=INF;\r\n\t\t}\r\n\t}\r\n\r\n\twhile(!q.empty()) {\r\n\t\tint cur = q.front();\r\n\t\tq.pop();\r\n\r\n\t\tfor(auto next : edge[cur]) {\r\n\t\t\tif(b[next]!=-1 && dist[b[next]]==INF) {\r\n\t\t\t\tdist[b[next]] = dist[cur] + 1;\r\n\t\t\t\tq.push(b[next]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool dfs(int cur) {\r\n\tfor(auto next : edge[cur]) {\r\n\t\tif(b[next]==-1 || (dist[b[next]] == dist[cur]+1 && dfs(b[next]))) {\r\n\t\t\tused[cur] = 1;\r\n\t\t\ta[cur] = next;\r\n\t\t\tb[next] = cur;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\nvoid Hopcroft_Karp() {\r\n\tint totalFlow = 0;\r\n\twhile(true) {\r\n\t\tbfs();\r\n\r\n\t\tint flow =0;\r\n\t\tfor(int i=1;i<=N;i++) {\r\n\t\t\tif(used[i]==0 && dfs(i)) flow++;\r\n\t\t}\r\n\t\tif(flow==0) break;\r\n\t\ttotalFlow += flow;\r\n\t}\r\n\tcout << totalFlow << endl;\r\n}\r\n*/\r\n//////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////\r\n/* \r\n#define MAX 1001\r\nvi edge[MAX];\r\nbool done[MAX] {};\r\nint B[MAX] {};\r\n//for 1~N memset(done, done+MAX, 0), if(dfs(i)) cnt++;\r\nbool dfs(int cur) {\r\n    for(auto next : edge[cur]) {\r\n        if(done[next]) continue;\r\n        done[next] = 1;\r\n        \r\n        if(B[next]==0 || dfs(B[next])) {\r\n            B[next] = cur;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n*/\r\nvoid Solve() {\r\n    cin >> N;\r\n    int a[N+1] {};\r\n    rep(i,1,N) cin >> a[i];\r\n\r\n    int l = *max_element(a+1,a+1+N);\r\n    int r = 1e9;\r\n    int answer=0;\r\n    while(l<=r) {\r\n        int mid = l+r>>1;\r\n        \r\n        int sum1 = 0;\r\n        int sum2 = 0;\r\n        rep(i,1,N) {\r\n            sum1 += a[i];\r\n            sum2 += mid - a[i];\r\n        }\r\n        if(sum2>=sum1) {\r\n            answer = mid;\r\n            r = mid-1;\r\n        }\r\n        else l =mid+1;\r\n    }\r\n    cout << answer;\r\n}\r\nint32_t main() {\r\n\tios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    Solve();\r\n}"
}