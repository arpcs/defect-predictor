{
    "id": 224873717,
    "contestId": 961,
    "creationTimeSeconds": 1695563011,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 961,
        "index": "D",
        "name": "Pair Of Lines",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "geometry"
        ]
    },
    "author": {
        "contestId": 961,
        "members": [
            {
                "handle": "huakaishenliang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1522850700
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 14,
    "timeConsumedMillis": 702,
    "memoryConsumedBytes": 10649600,
    "source": "#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <map>\r\n#include <array>\r\n#include <set>\r\n#include <cmath>\r\n#include <iomanip>\r\n#include <queue>\r\n#include <unordered_map>\r\n#include <chrono>\r\n#include <stack>\r\n#include <numeric>\r\n\r\n#define x first\r\n#define y second\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\ntypedef long long ll;\r\ntypedef pair<int, int> PII;\r\n\r\ntypedef long double db;\r\nconst db EPS = 1e-12;\r\nconst double PI = acos(-1.0);\r\nconst double sq3 = sqrt(3);\r\n\r\nconst int N = 2e5 + 10;\r\nconst int M = 1e3 + 5;\r\nconstexpr db INF=numeric_limits<db>::max();\r\n\r\n\r\ninline int read() {\r\n    int x = 0, f = 1; char ch = getchar();\r\n    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar();}\r\n    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}\r\n    return x * f;\r\n}\r\n\r\nll gcd(ll a, ll b) {\r\n    return b ? gcd(b, a % b) : a;\r\n}\r\n\r\nint lcm (int a, int b) {\r\n    return a * b / gcd(a, b);\r\n}\r\n\r\ninline int sign(db a) { return a < -EPS ? -1 : a > EPS; }\r\n\r\ninline int cmp(db a, db b) { return sign(a - b); }\r\n\r\nstruct P {\r\n    db x, y;\r\n    P() {}\r\n    P(db _x, db _y) : x(_x), y(_y) {}\r\n    P operator+(P p) { return {x + p.x, y + p.y}; }\r\n    P operator-(P p) { return {x - p.x, y - p.y}; }\r\n    P operator*(db d) { return {x * d, y * d}; }\r\n    P operator/(db d) { return {x / d, y / d}; }\r\n\r\n    bool operator<(P p) const {\r\n        int c = cmp(x, p.x);\r\n        if (c) return c == -1;\r\n        return cmp(y, p.y) == -1;\r\n    }\r\n\r\n    bool operator==(P o) const {\r\n        return cmp(x, o.x) == 0 && cmp(y, o.y) == 0;\r\n    }\r\n\r\n    db dot(P p) { return x * p.x + y * p.y; }\r\n    db det(P p) { return x * p.y - y * p.x; }\r\n    int toleft(P a) {auto t = (x * a.y - y * a.x); return (t > EPS) - (t < -EPS);}\r\n\r\n    db distTo(P p) { return (*this - p).abs(); }\r\n    db distTo2(P p) {return (*this - p).abs2(); }\r\n    db alpha() { return atan2(y, x); }\r\n    void read() { cin >> x >> y; }\r\n    void write() {cout << \"(\" << x << \",\" << y << \")\" << endl;}\r\n    db abs() { return sqrt(abs2());}\r\n    db abs2() { return x * x + y * y; }\r\n    db ang(P a) {return acosl(max(-1.0l, min(1.0l, ((*this).dot(a)) / (abs() * a.abs()))));}\r\n    P rot90() { return P(-y, x);}\r\n    P unit() { return *this / abs(); }\r\n    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }\r\n    //P rot(db an) { return {x * cos(an) - y * sin(an), x * sin(an) + y * cos(an)}; }\r\n    P rot (db cosr, db sinr) {return {x * cosr - y * sinr, x * sinr + y * cosr};}\r\n};\r\n\r\nbool isMiddle(db a, db m, db b) {\r\n    /*if (a > b) swap(a, b);\r\n    return cmp(a, m) <= 0 && cmp(m, b) <= 0;*/\r\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\r\n}\r\n\r\nbool isMiddle(P a, P m, P b) {\r\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\r\n}\r\n\r\nP proj(P p1, P p2, P q) {\r\n    P dir = p2 - p1;\r\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\r\n}\r\n\r\n// \u6c42 q \u5230 \u76f4\u7ebfp1p2 \u7684\u6700\u5c0f\u8ddd\u79bb\r\ndb nearest(P p1, P p2, P q){\r\n    if (p1 == p2) return p1.distTo(q);\r\n    P h = proj(p1,p2,q);\r\n    return q.distTo(h);\r\n}\r\n\r\n// \u6c42 q \u5230 \u7ebf\u6bb5p1p2 \u7684\u6700\u5c0f\u8ddd\u79bb\r\ndb nearest_seg (P p1, P p2, P q){\r\n    if (p1 == p2) return p1.distTo(q);\r\n    P h = proj(p1,p2,q);\r\n    if(isMiddle(p1,h,p2))\r\n        return q.distTo(h);\r\n    return min(p1.distTo(q),p2.distTo(q));\r\n}\r\n\r\n// cross \u662f p1 -> p2 \u548c p1 -> p3\u7684\u53c9\u79ef\r\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\r\n// crossOp \u662f p1->p2 \u548c p1->p3 \u7684\u53c9\u79ef\u7684\u6b63\u8d1f\uff0c\u7528\u6765\u5224\u65ad p3 \u5728 p1-> p2\u7ebf\u6bb5\u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\r\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\r\n \r\n#define rep(i, a, b) for (int i = a; i < b; i++)\r\ndb area(vector<P> &ps) {\r\n    db ret = 0; rep(i, 0, ps.size()) ret += ps[i].det(ps[(i + 1) % ps.size()]);\r\n    return ret / 2;\r\n}\r\n\r\nvector<P> convexHull(vector<P> ps) {\r\n    int n = ps.size(); if (n <= 1) return ps;\r\n    sort(ps.begin(), ps.end());\r\n    vector<P> qs(n * 2); int k = 0; //qs\u662f\u6808, \u6bcf\u6b21\u52a0\u5165\u65b0\u7684\u70b9\uff0c\u5e76\u68c0\u67e5\u51f8\u5305\u6700\u540e\u90e8\u5206\u662f\u4e0d\u662f\u51f8\u7684\r\n    for (int i = 0; i < n; qs[k++] = ps[i++]) // \u6c42\u4e0b\u51f8\u5305\r\n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k; // \u5982\u679c\u51f8\u5305\u6700\u540e\u4e09\u4e2a\u70b9\u4e0d\u6ee1\u8db3\u5411\u4e0b\uff0c\u5219\u5f39\u51fa\u8fd9\u4e00\u4e2a\u70b9\r\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) // \u6c42\u4e0a\u51f8\u5305\r\n        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k; // \u5982\u679c\u51f8\u5305\u6700\u540e\u4e09\u4e2a\u70b9\u4e0d\u6ee1\u8db3\u5411\u4e0a\uff0c\u5219\u5f39\u51fa\u8fd9\u4e00\u4e2a\u70b9\r\n    qs.resize(k - 1); // \u7531\u4e8e1\u53f7\u70b9\u88ab\u91cd\u590d\u52a0\u5165\u8fc7\u4e24\u6b21\uff0c\u6240\u4ee5\u5220\u53bb\u4e00\u4e2a\r\n    return qs;\r\n}\r\n\r\n// \u6781\u89d2\u6392\u5e8f\r\nstruct argcmp {\r\n    bool operator () (const P &a, const P &b) const {\r\n        const auto quad = [](const P & a) {\r\n            if (a.y < -EPS) return 1;\r\n            if (a.y > EPS) return 4;\r\n            if (a.x < -EPS) return 5;\r\n            if (a.x > EPS) return 3;\r\n            return 2;\r\n        };\r\n        const auto det = [&] (const P & a, const P & b) {return a.x * b.y - a.y * b.x;};\r\n        const auto dot = [&] (const P & a, const P & b) {return a.x * b.x + a.y * b.y;};\r\n        const int qa = quad(a), qb = quad(b);\r\n        if (qa != qb) return qa < qb;\r\n        const auto t = det(a, b);\r\n        if (abs(t) <= EPS) return dot(a, a) < dot(b, b) - EPS; // \u4e0d\u540c\u957f\u5ea6\u7684\u5411\u91cf\u9700\u8981\u5206\u5f00\r\n        return t > EPS;\r\n    }\r\n};\r\n\r\nstruct line {\r\n    P p, v;\r\n\r\n    bool operator == (const line &a) const {\r\n        auto toleft = [&] (const P & a, const P & b) {auto t = (a.x * b.y - a.y * b.x); return (t > EPS) - (t < -EPS);};\r\n        const P x = P(p.x - a.p.x, p.y - a.p.y);\r\n        return toleft(v, a.v) == 0 && toleft(v, x) == 0;\r\n    }\r\n    int toleft (const P &a) const {\r\n        auto toleft = [&] (const P & a, const P & b) {auto t = (a.x * b.y - a.y * b.x); return (t > EPS) - (t < -EPS);};\r\n        const P x = P(a.x - p.x, a.y - p.y);\r\n        return toleft(v, x);\r\n    }\r\n    P inter (const line &a) const {\r\n        auto add = [&] (const P & a, const P & b) {return P(a.x + b.x, a.y + b.y);};\r\n        auto dot = [&] (const P & a, const P & b) {return a.x * b.x + a.y * b.y;};\r\n        auto det = [&] (const P & a, const P & b) {return a.x * b.y - a.y * b.x;};\r\n        auto mul = [&] (const P & a, db b) {return P(a.x * b, a.y * b);};\r\n        const P x = P(p.x - a.p.x, p.y - a.p.y);\r\n        return add(p, mul(v, (det(a.v, x) / det(v, a.v))));\r\n    }\r\n    bool operator < (const line &a) const {\r\n        auto det = [&] (const P & a, const P & b) {return a.x * b.y - a.y * b.x;};\r\n        auto dot = [&] (const P & a, const P & b) {return a.x * b.x + a.y * b.y;};\r\n        if (abs(det(v, a.v)) <= EPS && dot(v, a.v) >= -EPS) {return toleft(a.p) == -1;}\r\n        return argcmp()(v, a.v);\r\n    }\r\n};\r\n\r\n//\u8fd4\u56de\u70b9\u96c6\u7684\u534a\u5e73\u9762\u4ea4\r\nvector<line> _halfinter (vector<line> &l) {\r\n    constexpr db LIM = 1e15l; // \u6700\u5916\u5c42\u8fb9\u754c\r\n    const auto check = [&] (const line & a, const line & b, const line & c) {return a.toleft(b.inter(c)) < 0;};\r\n    // \u8fd9\u91cc\u9700\u8981\u5927\u7ea6 LIM ^ 3\u7684\u70b9\u7684\u5927\u5c0f, \u6ca1\u6709\u7cbe\u5ea6\u635f\u5931\u7684\u7248\u672c\uff0cll \u4e0b 10^6\r\n    /*\r\n    const auto check = [](line &a, line & b, line & c) {\r\n        const auto t = b.v.det(c.v);\r\n        P x = a.v * t, y = b.p * t + b.v * (c.v.det(b.p - c.p)) - a.p * t;\r\n        return x.toleft(y) < 0;\r\n    };\r\n    */ \r\n    l.push_back({{ 0, 0}, {0, -1}}); l.push_back({{0, 0}, {1, 0}}); //\u56db\u4e2a\u8fb9\u754c\r\n    l.push_back({{ LIM, 0}, {0, 1}}); l.push_back({{0, LIM}, { -1, 0}});\r\n//    cout << l.size() << \"\\n\";\r\n    sort(l.begin(), l.end());\r\n    // cout << \"===========\\n\";\r\n    // for (auto t: l) {\r\n    //     cout << t.p.x << \" \" << t.p.y << \" \" << t.v.x << \" \" << t.v.y << \"\\n\";      \r\n    // }\r\n    // cout << \"=============\\n\";\r\n    deque<line> q;\r\n    for (size_t i = 0; i < l.size(); i++) {\r\n        if (i > 0 && l[i - 1].v.toleft(l[i].v) == 0 && l[i - 1].v.dot(l[i].v) > EPS) continue;\r\n        while (q.size() > 1 && check(l[i], q.back(), q[q.size() - 2])) q.pop_back(); //\u5f39\u51fa\u540e\u9762\u8fb9\u754c\r\n        while (q.size() > 1 && check(l[i], q[0], q[1])) q.pop_front(); //\u5f39\u51fa\u524d\u9762\u8fb9\u754c\r\n        q.push_back(l[i]);\r\n    }\r\n    while (q.size() > 1 && check(q[0], q.back(), q[q.size() - 2])) q.pop_back();\r\n    while (q.size() > 1 && check(q.back(), q[0], q[1])) q.pop_front();\r\n    if (q.size() <= 2 || check(q[1], q[0], q.back())) return vector<line> (); // \u65e0\u89e3\u8fd4\u56de\u7a7a\u96c6\r\n    return vector<line> (q.begin(), q.end());\r\n}\r\n\r\n//\u8fd4\u56de\u51f8\u5305\u7684\u534a\u5e73\u9762\u4ea4\r\nvector<P> halfinter (vector<line> &l) {\r\n    const auto lines = _halfinter(l);\r\n    // for (auto t: lines) {\r\n    //     cout << t.p.x << ' ' << t.p.y << \" \" << t.v.x << \" \" << t.v.y << \"\\n\";  \r\n    // }\r\n    vector<P> poly; poly.resize(lines.size());\r\n    if (lines.empty()) return poly;\r\n    for (size_t i = 0; i < lines.size(); i++) {\r\n        const size_t j = (i == lines.size() - 1 ? 0 : i + 1);\r\n        poly[i] = lines[i].inter(lines[j]);\r\n    }\r\n    poly.erase(unique(poly.begin(), poly.end()), poly.end());\r\n    if (poly.front() == poly.back() && poly.size() != 1) poly.pop_back();\r\n    return poly;\r\n}\r\n\r\nstruct segment {\r\n    P a, b;\r\n    segment() {}\r\n    segment(P _a, P _b) : a(_a), b(_b) {}\r\n    bool operator < (const segment &s) const {return make_pair(a, b) < make_pair(s.a, s.b);}\r\n\r\n    // \u7528\u4e8e\u5224\u65ad n \u6761\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4, \u677f\u5b50\u4e2d\r\n    int is_on(const P &p) const {\r\n        auto sub = [&] (P a, P b) {return P(a.x - b.x, a.y - b.y);};\r\n        if (p==a || p==b) return -1;\r\n        return (sub(p,a)).toleft(sub(p,b))==0 && (sub(p, a)).dot(sub(p, b))<-EPS;\r\n    }\r\n\r\n    // \u5224\u5b9a\u6027\u51fd\u6570\u5efa\u8bae\u5728\u6574\u6570\u57df\u4f7f\u7528\r\n    int is_inter(const line &l) const {\r\n        if (l.toleft(a) == 0 || l.toleft(b) == 0) return -1;\r\n        return l.toleft(a) != l.toleft(b);\r\n    }\r\n    // \u5224\u65ad\u4e24\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4\r\n    // -1 \u5728\u67d0\u4e00\u7ebf\u6bb5\u7aef\u70b9\u5904\u76f8\u4ea4 | 0 \u4e24\u7ebf\u6bb5\u4e0d\u76f8\u4ea4 | 1 \u4e24\u7ebf\u6bb5\u4e25\u683c\u76f8\u4ea4\r\n    int is_inter2(const segment &s) const {\r\n        const auto sub = [&] (P a, P b) {return P(a.x - b.x, a.y - b.y);};\r\n        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;\r\n        line l{a,sub(b, a)},ls{s.a,sub(s.b, s.a)};\r\n        return l.toleft(s.a)*l.toleft(s.b)==-1 && ls.toleft(a)*ls.toleft(b)==-1;\r\n    }\r\n};\r\n\r\nstruct Circle {\r\n    P c; db r;\r\n    bool operator == (const Circle &a) const {return c == a.c && abs(r - a.r) <= EPS;}\r\n    db circ () const {return 2 * PI * r;}\r\n    db area () const {return PI * r * r;}\r\n\r\n    //\u70b9\u4e0e\u5706\u7684\u5173\u7cfb\r\n    // -1 \u5706\u4e0a \uff5c 0 \u5706\u5916 \uff5c 1 \u5706\u5185\r\n    int is_in (P &a) {db d = a.distTo(c); return abs(d - r) <= EPS ? -1 : d < r - EPS;}\r\n\r\n    //\u76f4\u7ebf\u4e0e\u5706\u5173\u7cfb\r\n    //0 \u76f8\u79bb | 1 \u76f8\u5207 | 2 \u76f8\u4ea4\r\n    int relation (line &l) {\r\n        db d = nearest(l.p, l.p + l.v, c);\r\n        if (d > r + EPS) return 0;\r\n        if (abs(d - r) <= EPS) return 1;\r\n        return 2;\r\n    }\r\n    \r\n    //\u5706\u4e0e\u5706\u5173\u7cfb\r\n    // -1 \u76f8\u540c | 0 \u76f8\u79bb | 1 \u5916\u5207 | 2 \u76f8\u4ea4 | 3 \u5185\u5207 | 4 \u5185\u542b\r\n    int relation (Circle &a) {\r\n        if (*this == a) return -1;\r\n        db d = c.distTo(a.c);\r\n        if (d > r + a.r + EPS) return 0;\r\n        if (abs(d - a.r - r) <= EPS) return 1;\r\n        if (abs(d - abs(r - a.r)) <= EPS) return 3;\r\n        if (d < abs(r - a.r) - EPS) return 4;\r\n        return 2;\r\n    }\r\n\r\n    //\u76f4\u7ebf\u4e0e\u5706\u7684\u4ea4\u70b9\r\n    vector<P> inter(line &l) {\r\n        db d = nearest(l.p, l.p + l.v, c);\r\n        P p = proj(l.p, l.p + l.v, c);\r\n        int t = relation(l);\r\n        if (t == 0) return vector<P>();\r\n        if (t == 1) return vector<P>{p};\r\n        db k = sqrt(r * r - d * d);\r\n        return vector<P>{p-(l.v/l.v.abs())*k,p+(l.v/l.v.abs())*k};\r\n    }\r\n\r\n    //\u5706\u4e0e\u5706\u4ea4\u70b9\r\n    vector<P> inter(Circle &a) {\r\n        db d = c.distTo(a.c);\r\n        int t = relation(a);\r\n        if (t == -1 || t == 0 || t == 4) return vector<P>();\r\n        P e = a.c - c; e = e / e.abs() * r;\r\n        if (t == 1 || t == 3) {\r\n            if (r * r + d * d - a.r * a.r >= -EPS) return vector<P>{c + e};\r\n            return vector<P>{c - e};\r\n        }\r\n        db costh = (r * r + d * d - a.r * a.r) / (2 * r * d), sinth = sqrt(1 - costh * costh);\r\n        return vector<P>{c + e.rot(costh, -sinth), c + e.rot(costh, sinth)};\r\n    }\r\n\r\n    //\u5706\u4e0e\u5706\u4ea4\u9762\u79ef\r\n    db inter_area(Circle &a) {\r\n        db d = c.distTo(a.c);\r\n        int t = relation(a);\r\n        if (t == -1) return area();\r\n        if (t < 2) return 0;\r\n        if (t > 2) return min(area(), a.area());\r\n        db costh1 = (r * r + d * d - a.r * a.r) / (2 * r * d), costh2 = (a.r * a.r + d * d - r * r) / (2 * a.r * d);\r\n        db sinth1 = sqrt(1 - costh1 * costh1), sinth2 = sqrt(1 - costh2 * costh2);\r\n        db th1 = acos(costh1), th2 = acos(costh2);\r\n        return r * r * (th1 - costh1*sinth1) + a.r * a.r * (th2 - costh2 * sinth2);\r\n    }\r\n    \r\n    //\u8fc7\u5706\u5916\u4e00\u70b9\u5706\u7684\u5207\u7ebf\r\n    vector<line> tangent (P &a) {\r\n        int t = is_in(a);\r\n        if (t == 1) return vector<line>();\r\n        if (t == -1) {\r\n            P v = {-(a - c).y, (a - c).x};\r\n            return vector<line>{{a, v}};\r\n        }\r\n        P e = a - c; e = e / e.abs() * r; \r\n        db costh = r / c.distTo(a), sinth = sqrt(1 - costh * costh);\r\n        P t1 = c + e.rot(costh, -sinth), t2 = c + e.rot(costh, sinth);\r\n        return vector<line>{{a, t1 - a}, {a, t2 - a}};\r\n    }\r\n\r\n    // \u4e24\u5706\u7684\u516c\u5207\u7ebf\r\n    vector<line> tangent(Circle &a) {\r\n        int t = relation(a);\r\n        vector<line> lines;\r\n        if (t == -1 || t == 4) return lines;\r\n        if (t == 1 || t == 3) {\r\n            P p = inter(a)[0], v = {-(a.c - c).y, (a.c - c).x};\r\n            lines.push_back({p, v});\r\n        }\r\n        db d = c.distTo(a.c);\r\n        P e = (a.c - c) / (a.c - c).abs();\r\n        if (t <= 2) {\r\n            db costh = (r - a.r) / d, sinth = sqrt(1 - costh*costh);\r\n            P d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);\r\n            P u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c + d1 * a.r, v2 = a.c + d2 * a.r;\r\n            lines.push_back({u1, v1 - u1}); lines.push_back({u2, v2 - u2});  \r\n        }\r\n        if (t == 0) {\r\n            db costh = (r + a.r) / d, sinth = sqrt(1 - costh * costh);\r\n            P d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);\r\n            P u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c - d1 * a.r, v2 = a.c - d2 * a.r;\r\n            lines.push_back({u1, v1 - u1}); lines.push_back({u2, v2 - u2});\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    //\u5706\u7684\u53cd\u6f14\r\n    tuple<int, Circle, line> inverse(line &l) {\r\n        Circle null_c = {{0.0, 0.0}, 0.0};\r\n        line null_l = {{0.0, 0.0}, {0.0, 0.0}};\r\n        if (l.toleft(c) == 0) return {2, null_c, l};\r\n        P v = l.toleft(c) == 1 ? P(l.v.y, -l.v.x) : P(-l.v.y, l.v.x);\r\n        db d = r * r / nearest(l.p, l.p + l.v, c);\r\n        P p = c + v / v.abs() * d;\r\n        return {1, {(c + p) / 2, d / 2}, null_l};\r\n    }\r\n\r\n    tuple<int, Circle, line> inverse(Circle &a) {\r\n        Circle null_c = {{0.0, 0.0}, 0.0};\r\n        line null_l = {{0.0, 0.0}, {0.0, 0.0}};\r\n        P v = a.c - c;\r\n        if (a.is_in(c) == -1) {\r\n            db d = r * r / (a.r + a.r);\r\n            P p = c + v / v.abs() * d;\r\n            return {2, null_c, {p, {-v.y, v.x}}};\r\n        }\r\n        if (c == a.c) return {1, {c, r * r / a.r}, null_l};\r\n        db d1 = r * r / (c.distTo(a.c) - a.r), d2 = r * r / (c.distTo(a.c) + a.r);\r\n        P p = c + v / v.abs() * d1, q = c + v / v.abs() * d2;\r\n        return {1, {(p + q) / 2, p.distTo(q) / 2}, null_l};\r\n    }\r\n\r\n    // Circle (P &a, P &b,P &c) {\r\n    //     auto A = (a+b) * 0.5;\r\n    //     auto B = (a+c) * 0.5;\r\n \r\n    //     auto v1 = (a-A).rot90();\r\n    //     auto v2 = (c-B).rot90();\r\n \r\n    //     c = line{A, v1}.inter(line{B, v2});\r\n    //     r = sqrt(c.distTo2(a));\r\n    // }\r\n    // Circle (vector<P> &vec){\r\n    //     mt19937 rng(114514);\r\n    //     shuffle(begin(vec), end(vec), rng);\r\n \r\n    //     int n = vec.size();\r\n \r\n    //     *this =circle(vec[0]);\r\n    //     for(int i = 1 ; i < n ; i ++){\r\n    //         if((*this).is_in(vec[i])==1) continue;\r\n \r\n    //         *this = circle(vec[i]);\r\n    //         for(int j = 0 ; j < i ; j ++){\r\n    //             if((*this).is_in(vec[j])==1) continue;\r\n \r\n    //             *this = circle(vec[i], vec[j]);\r\n    //             for(int k = 0 ; k < j ; k ++){\r\n    //                 if((*this).is_in(vec[k])==1) continue;\r\n \r\n    //                 *this = circle(vec[i], vec[j], vec[k]);\r\n    //             }\r\n    //         }\r\n    //     }\r\n    // }\r\n};\r\n\r\n// \u5706\u4e0e\u591a\u8fb9\u5f62\u9762\u79ef\u4ea4\r\ndb area_inter (Circle &circ, vector<P> &poly) {\r\n    const auto cal = [] (Circle &circ, P &a, P &b) {\r\n        if ((a - circ.c).toleft(b - circ.c) == 0) return 0.0l;\r\n        auto ina = circ.is_in(a), inb = circ.is_in(b);\r\n        line ab = {a, b - a};\r\n        if (ina && inb) return ((a - circ.c).det(b - circ.c)) / 2;\r\n        if (ina && !inb) {\r\n            auto t = circ.inter(ab);\r\n            P p = t.size() == 1 ? t[0] : t[1];\r\n            db ans = ((a - circ.c).det(p - circ.c)) / 2;\r\n            db th = (p - circ.c).ang(b - circ.c);\r\n            db d = circ.r * circ.r * th / 2;\r\n            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d;\r\n            return ans - d;\r\n        }\r\n        if (!ina && inb) {\r\n            P p = circ.inter(ab)[0];\r\n            db ans = ((p - circ.c).det(b - circ.c)) / 2;\r\n            db th = (a - circ.c).ang(p - circ.c);\r\n            db d = circ.r * circ.r * th / 2;\r\n            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d;\r\n            return ans - d;\r\n        }\r\n        auto p = circ.inter(ab);\r\n        if (p.size() == 2 && nearest_seg(a, b, circ.c) <= circ.r + EPS) {\r\n            db ans = ((p[0] - circ.c).det(p[1] - circ.c)) / 2;\r\n            db th1 = (a - circ.c).ang(p[0] - circ.c), th2 = (b - circ.c).ang(p[1] - circ.c);\r\n            db d1 = circ.r * circ.r * th1 / 2, d2 = circ.r * circ.r * th2 / 2;\r\n            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d1 + d2;\r\n            return ans - d1 - d2;\r\n        }\r\n        db th = (a - circ.c).ang(b - circ.c);\r\n        if ((a - circ.c).toleft(b - circ.c) == 1) return circ.r * circ.r * th / 2;\r\n        return -circ.r * circ.r * th / 2;\r\n    };\r\n\r\n    db ans = 0;\r\n    for (size_t i = 0; i < poly.size(); i++) {\r\n        const auto nxt = [&] (int x) {return x == poly.size() - 1 ? 0 : x + 1;};\r\n        P a = poly[i], b = poly[nxt(i)];\r\n        ans += cal(circ, a, b);\r\n    }\r\n    return ans;\r\n}\r\n\r\n// \u5706\u9762\u79ef\u5e76\r\n// \u8f6e\u5ed3\u79ef\u5206 \u590d\u6742\u5ea6 O(n^2logn)\r\n// ans[i] \u8868\u793a\u88ab\u81f3\u5c11\u8986\u76d6\u4e86 i + 1 \u6b21\u7684\u533a\u57df\u7684\u9762\u79ef\r\nvector<db> area_union(vector<Circle> &circs) {\r\n    size_t siz = circs.size();\r\n    using arc_t = tuple<P, db, db, db>;\r\n    vector<vector<arc_t>> arcs(siz);\r\n    const auto eq = [] (const arc_t &u, const arc_t &v) {\r\n        const auto [u1, u2, u3, u4] = u;\r\n        const auto [v1, v2, v3, v4] = v;\r\n        return u1 == v1 && abs(u2 - v2) <= EPS && abs(u3 - v3) <= EPS && abs(u4 - v4) <= EPS;\r\n    };\r\n\r\n    auto cut_circ = [&] (Circle &ci, size_t i) {\r\n        vector<pair<db, int>> evt;\r\n        evt.push_back({-PI, 0}); evt.push_back({PI, 0});\r\n        int init = 0;\r\n        for (size_t j = 0; j < circs.size(); j++) {\r\n            if (i == j) continue;\r\n            Circle &cj = circs[j];\r\n            if (ci.r < cj.r - EPS && ci.relation(cj) >= 3) init++;\r\n            auto inters = ci.inter(cj);\r\n            if (inters.size() == 1) evt.push_back({atan2l((inters[0] - ci.c).y, (inters[0] - ci.c).x), 0}); \r\n            if (inters.size() == 2) {\r\n                P dl = inters[0] - ci.c, dr = inters[1] - ci.c;\r\n                db argl = atan2l(dl.y, dl.x), argr = atan2l(dr.y, dr.x);\r\n                if (abs(argl + PI) <= EPS) argl = PI;\r\n                if (abs(argr + PI) <= EPS) argr = PI;\r\n                if (argl > argr + EPS) {\r\n                    evt.push_back({argl, 1}); evt.push_back({PI, -1});\r\n                    evt.push_back({-PI, 1}); evt.push_back({argr, -1});\r\n                }\r\n                else {\r\n                    evt.push_back({argl, 1});\r\n                    evt.push_back({argr, -1});\r\n                }\r\n            }\r\n        }\r\n        sort(evt.begin(), evt.end());\r\n        int sum = init;\r\n        for (size_t i = 0; i < evt.size(); i++) {\r\n            sum += evt[i].second;\r\n            if (abs(evt[i].first - evt[i+1].first) > EPS) arcs[sum].push_back({ci.c, ci.r, evt[i].first, evt[i+1].first});\r\n            if (abs(evt[i+1].first - PI) <= EPS) break;\r\n        }\r\n    };\r\n\r\n    const auto oint = [] (arc_t &arc) {\r\n        const auto [cc, cr, l, r] = arc;\r\n        if (abs(r - l - PI - PI) <= EPS) return 2.0l * PI * cr * cr;\r\n        return cr * cr * (r - l) + cc.x * cr * (sin(r) - sin(l)) - cc.y * cr * (cos(r) - cos(l));\r\n    };\r\n\r\n    for (size_t i = 0; i < circs.size(); i++) {\r\n        auto &ci = circs[i];\r\n        cut_circ(ci, i);\r\n    }\r\n    vector<db> ans(siz);\r\n    for (size_t i = 0; i < siz; i++) {\r\n        db sum = 0;\r\n        sort(arcs[i].begin(), arcs[i].end());\r\n        int cnt = 0;\r\n        for (size_t j = 0; j < arcs[i].size(); j++) {\r\n            if (j > 0 && eq(arcs[i][j], arcs[i][j-1])) arcs[i + (++cnt)].push_back(arcs[i][j]);\r\n            else cnt = 0, sum += oint(arcs[i][j]);\r\n        }\r\n        ans[i] = sum / 2;\r\n    }\r\n    return ans;\r\n}\r\n\r\ndb get_s (db a, db b, db c) {\r\n    db p = (a + b + c) * 0.5;\r\n    return sqrt(p * (p - a) * (p - b) * (p - c));\r\n}\r\n\r\ndb gcd (db a, db b) {\r\n    if (fabs(b) < EPS) return a;\r\n    if (fabs(a) < EPS) return b;\r\n    return gcd(b, fmod(a, b));\r\n}\r\n\r\nint n;\r\nvector<P> p;\r\n\r\nbool check (int l, int r) {\r\n    db k = (p[l].y - p[r].y) / (p[l].x - p[r].x);\r\n    vector<P> rm;\r\n    for (int i = 0; i < n; i++) {\r\n        if (i == l || i == r) continue;\r\n        db k2 = (p[i].y - p[r].y) / (p[i].x - p[r].x);\r\n        if (abs(k - k2) > EPS) {\r\n            rm.push_back(p[i]);\r\n        }\r\n    }\r\n    if (rm.size() <= 2) return true;\r\n    db kx = (rm[1].y - rm[0].y) / (rm[1].x - rm[0].x);\r\n    for (int i = 2; i < rm.size(); i++) {\r\n        db kk = (rm[i].y - rm[0].y) / (rm[i].x - rm[0].x);\r\n        if (abs(kk - kx) > EPS) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid solve() {\r\n    cin >> n;\r\n    p.resize(n);\r\n    for (int i = 0; i < n; i++) {\r\n        p[i].read();\r\n    }\r\n    if (n <= 4) {\r\n        cout << \"YES\\n\"; return;\r\n    }\r\n\r\n    if (check(0, 1) || check(1, 2) || check(0, 2)) {\r\n        cout << \"YES\\n\"; return;\r\n    }\r\n    cout << \"NO\\n\";\r\n}\r\n\r\nsigned main () {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout << fixed << setprecision(10);\r\n\r\n    int T = 1;\r\n    // cin >> T;\r\n\r\n    while (T--) {\r\n        solve ();\r\n    }\r\n\r\n    return 0;\r\n}"
}