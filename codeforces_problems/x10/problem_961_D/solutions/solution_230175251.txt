{
    "id": 230175251,
    "contestId": 961,
    "creationTimeSeconds": 1698500048,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 961,
        "index": "D",
        "name": "Pair Of Lines",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "geometry"
        ]
    },
    "author": {
        "contestId": 961,
        "members": [
            {
                "handle": "BoaHancock"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1522850700
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 121,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 3276800,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nclass fastIO {\r\nprivate:\r\n    char ibuf[50007], *p1 = ibuf, *p2 = ibuf, obuf[50007], *p3 = obuf, sta[50];\r\n    bool file_end = false;\r\n    char get() {\r\n        return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, 50007, stdin), p1 == p2) ? (file_end = true), char(EOF): *p1++;\r\n    }\r\n    void put(const char x) {\r\n        p3 - obuf < 50007 ? *p3 ++ = x : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x);\r\n    }\r\npublic:\r\n    explicit operator bool() { return !file_end; }\r\n    size_t flush() {\r\n        size_t f = fwrite(obuf, p3 - obuf, 1, stdout);\r\n        p3 = obuf;\r\n        *p3 = 0;\r\n        return f;\r\n    }\r\n    fastIO &operator>>(char &t) {\r\n        for (t = get(); !isgraph(t); t = get());\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<is_same<any, char>::value, any>::type tpval() {\r\n        char t;\r\n        for (t = get(); !isgraph(t); t = get());\r\n        return t;\r\n    }\r\n    fastIO &operator>>(char *t) {\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())*t = c, t++;\r\n        *t = 0;\r\n        return *this;\r\n    }\r\n    fastIO &operator>>(string &t) {\r\n        t.clear();\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())t += c;\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<is_same<any, string>::value, any>::type tpval() {\r\n        string t;\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())t += c;\r\n        return t;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n            (is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n            is_same<any, __int128_t>::value, fastIO>::type &operator>>(any &t) {\r\n        t = 0;\r\n        bool y = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get())if (c == 45)y = true;\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        if (y == 1)t = -t;\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n            (is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n            is_same<any, __int128_t>::value, any>::type tpval() {\r\n        any t = 0;\r\n        bool y = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get())if (c == 45)y = true;\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        if (y == 1)t = -t;\r\n        return t;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n            (is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n            is_same<any, __uint128_t>::value, fastIO>::type &operator>>(any &t) {\r\n        t = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get());\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n            (is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n            is_same<any, __uint128_t>::value, any>::type tpval() {\r\n        any t = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get());\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        return t;\r\n    }\r\n    template<typename any1, typename any2>\r\n    fastIO &operator>>(pair<any1, any2> &t) { return *this >> t.first >> t.second; }\r\n    template<typename any1, typename any2>\r\n    pair<any1, any2> tpval() { return pair<any1, any2>(tpval<any1>(), tpval<any2>()); }\r\n    template<typename any>\r\n    fastIO &read(any &t) { return *this >> t; }\r\n    fastIO &read(char *t) {\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())*t = c, t++;\r\n        *t = 0;\r\n        return *this;\r\n    }\r\n    template<typename any, typename...args>\r\n    fastIO &read(any &t1, args &...t2) { return (*this >> t1).read(t2...); }\r\n    fastIO &operator<<(const char t) {\r\n        put(t);\r\n        return *this;\r\n    }\r\n    fastIO &operator<<(const char *t) {\r\n        for (; *t; t++)put(*t);\r\n        return *this;\r\n    }\r\n    fastIO &operator<<(const string &t) {\r\n        for (const char it: t)put(it);\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n            (is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n            is_same<any, __int128_t>::value, fastIO>::type &operator<<(any t) {\r\n        if (!t) {\r\n            put(48);\r\n            return *this;\r\n        }\r\n        int len = 0;\r\n        if (t < 0)t = -t, put(45);\r\n        while (t)sta[len++] = char(t % 10 + 48), t /= 10;\r\n        while (len--)put(sta[len]);\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n            (is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n            is_same<any, __uint128_t>::value, fastIO>::type &operator<<(any t) {\r\n        if (!t) {\r\n            put(48);\r\n            return *this;\r\n        }\r\n        int len = 0;\r\n        while (t)sta[len++] = char(t % 10 + 48), t /= 10;\r\n        while (len--)put(sta[len]);\r\n        return *this;\r\n    }\r\n    template<typename any1, typename any2>\r\n    fastIO &operator<<(const pair<any1, any2> &t) { return *this << t.first << ' ' << t.second; }\r\n    template<typename any>\r\n    fastIO &write(const any &t) { return *this << t; }\r\n    template<typename any, typename...args>\r\n    fastIO &write(const any &t1, const args &...t2) { return (*this << t1).write(t2...); }\r\n\r\n    ~fastIO() { fwrite(obuf, p3 - obuf, 1, stdout); }\r\n}FastIO;\r\n#define cin FastIO\r\n#define cout FastIO\r\n\r\nnamespace Geometry2 {\r\n    const double pi = acosl(-1.0);\r\n    const double eps = 1e-8;\r\n    const int N = 1e5 + 5;\r\n    int sign(double x) {\r\n        if(fabs(x) < eps) return 0;\r\n        if(x < 0) return -1;\r\n        else return 1;\r\n    }\r\n    inline double sqr(double x) {\r\n        return x * x;\r\n    }\r\n\r\n    class Point_2 {\r\n    public:\r\n        int x, y;\r\n        Point_2() {};\r\n        Point_2(double _x, double _y) : x(_x), y(_y) {};\r\n        bool operator ==(Point_2 &other) const {\r\n            return sign(x - other.x) == 0 && sign(y - other.y) == 0;\r\n        }\r\n        Point_2 operator +(const Point_2 &other) const {\r\n            return Point_2(x + other.x, y + other.y);\r\n        }\r\n        Point_2 operator -(const Point_2 &other) const {\r\n            return Point_2(x - other.x, y - other.y);\r\n        }\r\n        Point_2 operator *(const double &other) const {\r\n            return Point_2(x * other, y * other);\r\n        }\r\n        Point_2 operator /(const double &other) const {\r\n            return Point_2(x / other, y / other);\r\n        }\r\n        bool operator <(const Point_2 &other) const { // \u6309\u7167x\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0cy\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\r\n            return sign(x - other.x) == 0 ? y < other.y : x < other.x;\r\n        }\r\n\r\n        double operator *(const Point_2 &b) const { // \u70b9\u79ef\r\n            return x * b.x + y * b.y;\r\n        }\r\n        double operator ^(const Point_2 &b) const { // \u53c9\u79ef\r\n            return x * b.y - y * b.x;\r\n        }\r\n        double Length() const {\r\n            return hypot(x, y); // sqrt(x * x + y * y)\r\n        }\r\n        double dis(Point_2 &other) const {\r\n            return hypot(x - other.x, y - other.y);\r\n        }\r\n        double rad(Point_2 &lhs, Point_2 &rhs) { // \u8ba1\u7b97\u4e24\u70b9\u7684\u5939\u89d2  pa, pb\u7684\u5939\u89d2 p\u5c31\u662fother\u8fd9\u4e2a\u70b9\r\n            Point_2 other = *this;\r\n            return fabs(atan2(fabs((lhs - other) ^ (rhs - other)), (lhs - other) * (rhs - other)));\r\n        }\r\n\r\n        Point_2 trunc(double r) { // \u8f6c\u5316\u4e3a\u957f\u5ea6\u4e3ar\u7684\u5411\u91cf\r\n            double l = Length();\r\n            if (!sign(l)) return *this;\r\n            r /= l;\r\n            return Point_2(x * r, y * r);\r\n        }\r\n\r\n        Point_2 rotleft() { //`\u9006\u65f6\u9488\u65cb\u8f6c90\u5ea6`\r\n            return Point_2(-y, x);\r\n        }\r\n\r\n        Point_2 rotright() { //`\u987a\u65f6\u9488\u65cb\u8f6c90\u5ea6`\r\n            return Point_2(y, -x);\r\n        }\r\n\r\n        Point_2 rotate(Point_2 &other, double angle) { //`\u7ed5\u7740p\u70b9\u9006\u65f6\u9488\u65cb\u8f6cangle`\r\n            Point_2 v = (*this) - other;\r\n            double c = cos(angle), s = sin(angle);\r\n            return Point_2(other.x + v.x * c - v.y * s, other.y + v.x * s + v.y * c);\r\n        }\r\n    };\r\n\r\n    class Line_2 {\r\n    public:\r\n        Point_2 st, ed;\r\n        Line_2() {};\r\n        Line_2(Point_2 _st, Point_2 _ed) : st(_st), ed(_ed) {};\r\n\r\n        bool operator ==(Line_2 &other) const{\r\n            return (st == other.st) && (ed == other.ed);\r\n        }\r\n\r\n        Line_2(Point_2 p, double angle) { //`\u6839\u636e\u4e00\u4e2a\u70b9\u548c\u503e\u659c\u89d2angle\u786e\u5b9a\u76f4\u7ebf\r\n            st = p;\r\n            if (sign(angle - pi / 2) == 0) {\r\n                ed = (st + Point_2(0, 1));\r\n            }\r\n            else {\r\n                ed = (st + Point_2(1, tan(angle)));\r\n            }\r\n        }\r\n\r\n        Line_2(double a, double b, double c) { //`\u6839\u636eabc\u5f97\u5230\u76f4\u7ebf ax + by + c = 0`\r\n            if (sign(a) == 0) {\r\n                st = Point_2(0, -c / b);\r\n                ed = Point_2(1, -c / b);\r\n            }\r\n            else if (sign(b) == 0) {\r\n                st = Point_2(-c / a, 0);\r\n                ed = Point_2(-c / a, 1);\r\n            }\r\n            else {\r\n                st = Point_2(0, -c / b);\r\n                ed = Point_2(1, (-c - a) / b);\r\n            }\r\n        }\r\n\r\n        double Length() {\r\n            return st.dis(ed);\r\n        }\r\n\r\n        double get_angle() { // `\u8fd4\u56de\u76f4\u7ebf\u503e\u659c\u89d2 0 <= angle < pi`\r\n            double k = atan2(ed.y - st.y, ed.x - st.x);\r\n            if (sign(k) < 0) k += pi;\r\n            if (sign(k - pi) == 0) k -= pi;\r\n            return k;\r\n        }\r\n\r\n        int relation(Point_2 &other) { // \u70b9\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\r\n            int c = sign((other - st) ^ (ed - st));\r\n            if (c < 0) return 1; // \u70b9\u5728\u76f4\u7ebf\u5de6\u4fa7\r\n            else if (c > 0) return 2; // \u70b9\u5728\u76f4\u7ebf\u53f3\u4fa7\r\n            else return 3; // \u70b9\u5728\u76f4\u7ebf\u4e0a\r\n        }\r\n\r\n        bool pointonseg(Point_2 &other) { // \u70b9\u5728\u7ebf\u6bb5\u4e0a\u7684\u5224\u65ad\r\n            return sign((other - st) ^ (ed - st)) == 0 && sign((other - st) * (other - ed)) <= 0;\r\n        }\r\n\r\n        bool parallel(Line_2 &other) { // \u5224\u65ad\u4e24\u76f4\u7ebf\u662f\u5426\u5e73\u884c\u6216\u8005\u91cd\u5408\r\n            return sign((ed - st) ^ (other.ed - other.st)) == 0;\r\n        }\r\n\r\n        int segcrossseg(Line_2 &other) { // \u4e24\u7ebf\u6bb5\u76f8\u4ea4\u5173\u7cfb\r\n            int d1 = sign((ed - st) ^ (other.st - st));\r\n            int d2 = sign((ed - st) ^ (other.ed - st));\r\n            int d3 = sign((other.ed - other.st) ^ (st - other.st));\r\n            int d4 = sign((other.ed - other.st) ^ (ed - other.st));\r\n            if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2) return 2; //`2 \u89c4\u8303\u76f8\u4ea4`\r\n            return (d1 == 0 && sign((other.st - st) * (other.st - ed)) <= 0) ||\r\n                   (d2 == 0 && sign((other.ed - st) * (other.ed - ed)) <= 0) ||\r\n                   (d3 == 0 && sign((st - other.st) * (st - other.ed)) <= 0) ||\r\n                   (d4 == 0 && sign((ed - other.st) * (ed - other.ed)) <= 0); //`1 \u975e\u89c4\u8303\u76f8\u4ea4`, `0 \u4e0d\u76f8\u4ea4`\r\n        }\r\n\r\n        int linecrossseg(Line_2 &other) { // \u76f4\u7ebf\u4e0e\u7ebf\u6bb5\u76f8\u4ea4\u5173\u7cfb  other\u662f\u7ebf\u6bb5\r\n            int d1 = sign((ed - st) ^ (other.st - st));\r\n            int d2 = sign((ed - st) ^ (other.ed - st));\r\n            if ((d1 ^ d2) == -2) return 2; //`2 \u89c4\u8303\u76f8\u4ea4`\r\n            return (d1 == 0 || d2 == 0); //`1 \u975e\u89c4\u8303\u76f8\u4ea4`, `0 \u4e0d\u76f8\u4ea4`\r\n        }\r\n\r\n        int linecrossline(Line_2 &other) { // \u4e24\u76f4\u7ebf\u5173\u7cfb\r\n            if ((*this).parallel(other)) { // `0 \u5e73\u884c`, `1 \u91cd\u5408`, `2 \u76f8\u4ea4`\r\n                return other.relation(st) == 3;\r\n            }\r\n            return 2;\r\n        }\r\n\r\n        Point_2 crosspoint(Line_2 other) { //`\u6c42\u4e24\u76f4\u7ebf\u7684\u4ea4\u70b9, \u8981\u4fdd\u8bc1\u4e24\u76f4\u7ebf\u4e0d\u5e73\u884c\u6216\u91cd\u5408`\r\n            double a1 = (other.ed - other.st) ^ (st - other.st);\r\n            double a2 = (other.ed - other.st) ^ (ed - other.st);\r\n            return Point_2((st.x * a2 - ed.x * a1) / (a2 - a1), (st.y * a2 - ed.y * a1) / (a2 - a1));\r\n        }\r\n\r\n        double dispointtoline(Point_2 &other) { //\u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\r\n            return fabs((other - st) ^ (ed - st)) / Length();\r\n        }\r\n\r\n        double dispointtoseg(Point_2 &other) { //\u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb\r\n            if (sign((other - st) * (ed - st)) < 0 || sign((other - ed) * (st - ed)) < 0)\r\n                return min(other.dis(st), other.dis(ed));\r\n            return dispointtoline(other);\r\n        }\r\n\r\n        double dissegtoseg(Line_2 &other) { // \u7ebf\u6bb5\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb, \u76f8\u4ea4\u4e3a0\r\n            return min(min(dispointtoseg(other.st), dispointtoseg(other.ed)),\r\n                       min(other.dispointtoseg(st), other.dispointtoseg(ed)));\r\n        }\r\n\r\n        Point_2 lineprog(Point_2 &other) { //`\u8fd4\u56de\u70b9p\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71`\r\n            return st + (((ed - st) * ((ed - st) * (other - st))) / ((ed - st).Length() * (ed - st).Length()));\r\n        }\r\n\r\n        Point_2 symmetrypoint(Point_2 &other) { //`\u8fd4\u56de\u70b9p\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9`\r\n            Point_2 q = lineprog(other); // `\u6c42\u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71`\r\n            return Point_2(2 * q.x - other.x, 2 * q.y - other.y);\r\n        }\r\n    };\r\n\r\n    class circle {\r\n    public:\r\n        Point_2 p; // \u5706\u5fc3\r\n        __float128 r; // \u534a\u5f84\r\n        circle() {};\r\n        circle(Point_2 _p, double _r) : p(_p), r(_r) {};\r\n        circle(double x, double y, double _r) : p(Point_2(x, y)), r(_r) {};\r\n\r\n        circle(Point_2 a, Point_2 b, Point_2 c, bool flag) {\r\n            if (flag) { // \u6784\u9020\u4e09\u89d2\u7ebf\u7684\u5916\u63a5\u5706\r\n                // \u9700\u8981\u7528\u5230 Point_2 \u7684\"+, /, rotate()\"\r\n                // \u9700\u8981\u7528\u5230 Line_2 \u7684\"crosspoint()\"\r\n                // \u5229\u7528\u4e09\u89d2\u5f62\u4e24\u6761\u8fb9\u7684\u4e2d\u5782\u7ebf\u5f97\u5230\u5706\u5fc3\r\n                Line_2 u = Line_2((a + b) / 2, ((a + b) / 2) + ((b - a).rotleft()));\r\n                Line_2 v = Line_2((b + c) / 2, ((b + c) / 2) + ((c - b).rotleft()));\r\n                p = u.crosspoint(v);\r\n                r = p.dis(a);\r\n            }\r\n            else { // \u6784\u9020\u4e09\u89d2\u5f62\u7684\u5185\u5207\u5706\r\n                Line_2 u, v;\r\n                double m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);\r\n                u.st = a;\r\n                u.ed = u.st + Point_2(cos((n + m) / 2), sin((n + m) / 2));\r\n                v.st = b;\r\n                m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);\r\n                v.ed = v.st + Point_2(cos((n + m) / 2), sin((n + m) / 2));\r\n                p = u.crosspoint(v);\r\n                r = Line_2(a, b).dispointtoseg(p);\r\n            }\r\n        }\r\n\r\n        bool operator==(circle &other) {\r\n            return (p == other.p) && sign(r - other.r) == 0;\r\n        }\r\n\r\n        bool operator<(circle &other) const {\r\n            return ((p < other.p) || ((p == other.p) && sign(r - other.r) < 0));\r\n        }\r\n\r\n        double area() { // \u6c42\u9762\u79ef\r\n            return pi * r * r;\r\n        }\r\n\r\n        double circumference() { // \u6c42\u5468\u957f\r\n            return 2 * pi * r;\r\n        }\r\n\r\n        int relation(Point_2 &other) {//`\u70b9\u548c\u5706\u7684\u5173\u7cfb`\r\n            double dst = other.dis(p);\r\n            if (sign(dst - r) < 0) return 2; //`2 \u5706\u5185`\r\n            else if (sign(dst - r) == 0) return 1; //`1 \u5706\u4e0a`\r\n            return 0; //`0 \u5706\u5916`\r\n        }\r\n\r\n        int relationseg(Line_2 &other){ //`\u7ebf\u6bb5\u548c\u5706\u7684\u5173\u7cfb`, `\u6bd4\u8f83\u7684\u662f\u5706\u5fc3\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb\u548c\u534a\u5f84\u7684\u5173\u7cfb`\r\n            double dst = other.dispointtoseg(p);\r\n            if(sign(dst-r) < 0) return 2; // \u7ebf\u6bb5\u548c\u5706\u76f8\u4ea4\r\n            else if(sign(dst-r) == 0) return 1; // \u7ebf\u6bb5\u548c\u5706\u76f8\u5207\r\n            return 0; // \u7ebf\u6bb5\u548c\u5706\u6ca1\u6709\u4ea4\u70b9\r\n        }\r\n\r\n        int relationline(Line_2 &other) { //`\u76f4\u7ebf\u548c\u5706\u7684\u5173\u7cfb`, `\u6bd4\u8f83\u7684\u662f\u5706\u5fc3\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\u548c\u534a\u5f84\u7684\u5173\u7cfb`\r\n            double dst = other.dispointtoline(p);\r\n            if (sign(dst - r) < 0) return 2; // \u76f4\u7ebf\u548c\u5706\u76f8\u4ea4\r\n            else if (sign(dst - r) == 0) return 1; // \u76f4\u7ebf\u548c\u5706\u76f8\u5207\r\n            return 0; // \u76f4\u7ebf\u548c\u5706\u4e0d\u76f8\u4ea4\r\n        }\r\n\r\n        int relationcircle(circle v) { //`\u4e24\u5706\u7684\u5173\u7cfb`\r\n            double d = p.dis(v.p);\r\n            if (sign(d - r - v.r) > 0) return 5; // \u76f8\u79bb\r\n            if (sign(d - r - v.r) == 0) return 4; // \u5916\u5207\r\n            double l = fabsl((double)(r - v.r));\r\n            if (sign(d - r - v.r) < 0 && sign(d - l) > 0) return 3; // \u76f8\u4ea4\r\n            if (sign(d - l) == 0) return 2; // \u5185\u5207\r\n            if (sign(d - l) < 0) return 1; // \u5305\u542b\r\n            return 0; // \u4ee5\u4e0a\u5173\u7cfb\u90fd\u6ca1\u6709, \u4f46\u662f\u5e94\u8be5\u4e0d\u53ef\u80fd\u51fa\u73b0\r\n        }\r\n\r\n        int pointcrosscircle(circle v, Point_2 &p1, Point_2 &p2) { //`\u6c42\u4e24\u4e2a\u5706\u7684\u4ea4\u70b9\u4e2a\u6570`\r\n            //`\u9700\u8981relationcircle()`\r\n            int rel = relationcircle(v);\r\n            if (rel == 1 || rel == 5) return 0; // \u6ca1\u6709\u4ea4\u70b9 (\u5305\u542b, \u76f8\u79bb)\r\n            double d = p.dis(v.p);\r\n            double l = (d * d + r * r - v.r * v.r) / (2 * d);\r\n            double h = sqrtl(r * r - l * l);\r\n            Point_2 tmp = p + (v.p - p).trunc(l);\r\n            p1 = tmp + ((v.p - p).rotleft().trunc(h));\r\n            p2 = tmp + ((v.p - p).rotright().trunc(h));\r\n            if (rel == 2 || rel == 4)\r\n                return 1; // \u6709\u4e00\u4e2a\u4ea4\u70b9 (\u5185\u5207, \u5916\u5207)\r\n            return 2; // \u6709\u4e24\u4e2a\u4ea4\u70b9 (\u76f8\u4ea4)\r\n        }\r\n\r\n\r\n        int pointcrossline(Line_2 v, Point_2 &p1, Point_2 &p2) {\r\n            //`\u6c42\u76f4\u7ebf\u548c\u5706\u7684\u4ea4\u70b9\uff0c\u8fd4\u56de\u4ea4\u70b9\u4e2a\u6570`\r\n            if (!(*this).relationline(v)) return 0;\r\n            Point_2 a = v.lineprog(p);\r\n            double d = v.dispointtoline(p);\r\n            d = sqrtl(r * r - d * d);\r\n            if (sign(d) == 0) {\r\n                p1 = a;\r\n                p2 = a;\r\n                return 1;\r\n            }\r\n            p1 = a + (v.ed - v.st).trunc(d);\r\n            p2 = a - (v.ed - v.st).trunc(d);\r\n            return 2;\r\n        }\r\n\r\n        int gercircle(Point_2 a, Point_2 b, double r1, circle &c1, circle &c2) {\r\n            //`\u5f97\u5230\u8fc7a,b\u4e24\u70b9, \u534a\u5f84\u4e3ar1\u7684\u4e24\u4e2a\u5706`\r\n            circle x(a, r1), y(b, r1);\r\n            int t = x.pointcrosscircle(y, c1.p, c2.p);\r\n            if (!t) return 0;\r\n            c1.r = c2.r = r;\r\n            return t;\r\n        }\r\n\r\n        int getcircle(Line_2 u, Point_2 q, double r1, circle &c1, circle &c2) {\r\n            //`\u5f97\u5230\u4e0e\u76f4\u7ebfu\u76f8\u5207\uff0c\u8fc7\u70b9q,\u534a\u5f84\u4e3ar1\u7684\u4e24\u4e2a\u5706`\r\n            double dis = u.dispointtoline(q);\r\n            if (sign(dis - r1 * 2) > 0)return 0;\r\n            if (sign(dis) == 0) {\r\n                c1.p = q + ((u.ed - u.st).rotleft().trunc(r1));\r\n                c2.p = q + ((u.ed - u.st).rotright().trunc(r1));\r\n                c1.r = c2.r = r1;\r\n                return 2;\r\n            }\r\n            Line_2 u1 = Line_2((u.st + (u.ed - u.st).rotleft().trunc(r1)), (u.ed + (u.ed - u.st).rotleft().trunc(r1)));\r\n            Line_2 u2 = Line_2((u.st + (u.ed - u.st).rotright().trunc(r1)), (u.ed + (u.ed - u.st).rotright().trunc(r1)));\r\n            circle cc = circle(q, r1);\r\n            Point_2 p1, p2;\r\n            if (!cc.pointcrossline(u1, p1, p2))cc.pointcrossline(u2, p1, p2);\r\n            c1 = circle(p1, r1);\r\n            if (p1 == p2) {\r\n                c2 = c1;\r\n                return 1;\r\n            }\r\n            c2 = circle(p2, r1);\r\n            return 2;\r\n        }\r\n\r\n        int getcircle(Line_2 u, Line_2 v, double r1, circle &c1, circle &c2, circle &c3, circle &c4) {\r\n            //\u6c42\u540c\u65f6\u4e0e\u76f4\u7ebfu,v\u76f8\u5207\uff0c\u534a\u5f84\u4e3ar1\u7684\u5706`\r\n            if (u.parallel(v))return 0;//\u4e24\u76f4\u7ebf\u5e73\u884c\r\n            Line_2 u1 = Line_2(u.st + (u.ed - u.st).rotleft().trunc(r1), u.ed + (u.ed - u.st).rotleft().trunc(r1));\r\n            Line_2 u2 = Line_2(u.st + (u.ed - u.st).rotright().trunc(r1), u.ed + (u.ed - u.st).rotright().trunc(r1));\r\n            Line_2 v1 = Line_2(v.st + (v.ed - v.st).rotleft().trunc(r1), v.ed + (v.ed - v.st).rotleft().trunc(r1));\r\n            Line_2 v2 = Line_2(v.st + (v.ed - v.st).rotright().trunc(r1), v.ed + (v.ed - v.st).rotright().trunc(r1));\r\n            c1.r = c2.r = c3.r = c4.r = r1;\r\n            c1.p = u1.crosspoint(v1);\r\n            c2.p = u1.crosspoint(v2);\r\n            c3.p = u2.crosspoint(v1);\r\n            c4.p = u2.crosspoint(v2);\r\n            return 4;\r\n        }\r\n\r\n        int getcircle(circle cx, circle cy, double r1, circle &c1, circle &c2) {\r\n            //`\u6c42\u540c\u65f6\u4e0e\u4e0d\u76f8\u4ea4\u5706cx,cy\u76f8\u5207\uff0c\u534a\u5f84\u4e3ar1\u7684\u5706`\r\n            circle x(cx.p, r1 + cx.r), y(cy.p, r1 + cy.r);\r\n            int t = x.pointcrosscircle(y, c1.p, c2.p);\r\n            if (!t)return 0;\r\n            c1.r = c2.r = r1;\r\n            return t;\r\n        }\r\n\r\n        int tangentline(Point_2 q, Line_2 &u, Line_2 &v) {\r\n            //`\u8fc7\u4e00\u70b9\u4f5c\u5706\u7684\u4e24\u6761\u5207\u7ebf(\u5148\u5224\u65ad\u70b9\u548c\u5706\u7684\u5173\u7cfb)`\r\n            int x = relation(q);\r\n            if (x == 2)return 0;\r\n            if (x == 1) {\r\n                u = Line_2(q, q + (q - p).rotleft());\r\n                v = u;\r\n                return 1;\r\n            }\r\n            double d = p.dis(q);\r\n            double l = r * r / d;\r\n            double h = sqrtl(r * r - l * l);\r\n            u = Line_2(q, p + ((q - p).trunc(l) + (q - p).rotleft().trunc(h)));\r\n            v = Line_2(q, p + ((q - p).trunc(l) + (q - p).rotright().trunc(h)));\r\n            return 2;\r\n        }\r\n        double areacircle(circle v) {\r\n            //`\u6c42\u4e24\u5706\u76f8\u4ea4\u7684\u9762\u79ef`\r\n            int rel = relationcircle(v);\r\n            if (rel >= 4) return 0.0;\r\n            if (rel <= 2) return min(area(), v.area());\r\n            double d = p.dis(v.p);\r\n            double a1 = acosl((r * r + d * d - v.r * v.r) / (2.0 * r * d)) * 2;\r\n            double a2 = acosl((v.r * v.r + d * d - r * r) / (2.0 * v.r * d)) * 2;\r\n            double ss = r * r * sinl(a1) / 2 + v.r * v.r * sinl(a2) / 2;\r\n            a1 = a1 * r * r / 2;\r\n            a2 = a2 * v.r * v.r / 2;\r\n            return a1 + a2 - ss;\r\n        }\r\n\r\n        double areatriangle(Point_2 a, Point_2 b) {\r\n            // `\u6c42\u5706\u548c\u4e09\u89d2\u5f62pab\u7684\u76f8\u4ea4\u9762\u79ef`\r\n            if (sign((p - a) ^ (p - b)) == 0) return 0.0;\r\n            Point_2 q[5];\r\n            int len = 0;\r\n            q[len ++] = a;\r\n            Line_2 l(a, b);\r\n            Point_2 p1, p2;\r\n            if (pointcrossline(l, q[1], q[2]) == 2) {\r\n                if (sign((a - q[1]) * (b - q[1])) < 0)q[len ++] = q[1];\r\n                if (sign((a - q[2]) * (b - q[2])) < 0)q[len ++] = q[2];\r\n            }\r\n            q[len ++] = b;\r\n            if (len == 4 && sign((q[0] - q[1]) * (q[2] - q[1])) > 0)swap(q[1], q[2]);\r\n            double res = 0;\r\n            for (int i = 0; i < len - 1; ++ i) {\r\n                if (relation(q[i]) == 0 || relation(q[i + 1]) == 0) {\r\n                    double arg = p.rad(q[i], q[i + 1]);\r\n                    res += r * r * arg / 2.0;\r\n                }\r\n                else {\r\n                    res += fabs((q[i] - p) ^ (q[i + 1] - p)) / 2.0;\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    };\r\n    class Polygon_2 {\r\n    public:\r\n        int n;\r\n        Point_2 p[N];\r\n        Line_2 l[N];\r\n        void init(vector<Point_2> &v) {\r\n            n = v.size();\r\n            for(int i = 0; i < n; ++ i) {\r\n                p[i] = v[i];\r\n            }\r\n        }\r\n\r\n        void add(Point_2 q) {\r\n            p[n ++] = q;\r\n        }\r\n\r\n        void Getline() {\r\n            for (int i = 0; i < n; ++ i) {\r\n                l[i] = Line_2(p[i], p[(i + 1) % n]);\r\n            }\r\n        }\r\n        struct cmp{\r\n            Point_2 p;\r\n            cmp(const Point_2 &p0){p = p0;}\r\n\r\n            bool operator()(const Point_2 &aa, const Point_2 &bb) {\r\n                Point_2 a = aa, b = bb;\r\n                int d = sign((a - p) ^ (b - p));\r\n                if (d == 0) {\r\n                    return sign(a.dis(p) - b.dis(p)) < 0;\r\n                }\r\n                return d > 0;\r\n            }\r\n        };\r\n\r\n        //`\u8fdb\u884c\u6781\u89d2\u6392\u5e8f`\r\n        //`\u9996\u5148\u9700\u8981\u627e\u5230\u6700\u5de6\u4e0b\u89d2\u7684\u70b9`\r\n        //`\u9700\u8981\u91cd\u8f7d\u53f7\u597dPoint\u7684 < \u64cd\u4f5c\u7b26(min\u51fd\u6570\u8981\u7528) `\r\n        void norm() {\r\n            Point_2 minN = p[0];\r\n            for (int i = 1; i < n; ++ i) minN = min(minN, p[i]);\r\n            sort(p, p + n, cmp(minN));\r\n        }\r\n\r\n        //`\u5f97\u5230\u51f8\u5305`\r\n        //`\u5f97\u5230\u7684\u51f8\u5305\u91cc\u9762\u7684\u70b9\u7f16\u53f7\u662f0$\\sim$n-1\u7684`\r\n        //`\u4e24\u79cd\u51f8\u5305\u7684\u65b9\u6cd5`\r\n        //`\u6ce8\u610f\u5982\u679c\u6709\u5f71\u54cd\uff0c\u8981\u7279\u5224\u4e0b\u6240\u6709\u70b9\u5171\u70b9\uff0c\u6216\u8005\u5171\u7ebf\u7684\u7279\u6b8a\u60c5\u51b5`\r\n        //`\u6d4b\u8bd5 LightOJ1203  LightOJ1239`\r\n        void getconvex(Polygon_2 &convex) {\r\n            sort(p, p + n);\r\n            convex.n = n;\r\n            for (int i = 0; i < min(n, 2ll); ++i) {\r\n                convex.p[i] = p[i];\r\n            }\r\n            if (convex.n == 2 && (convex.p[0] == convex.p[1])) -- convex.n;//\u7279\u5224\r\n            if (n <= 2) return;\r\n            int &top = convex.n;\r\n            top = 1;\r\n            for (int i = 2; i < n; ++ i) {\r\n                while (top && sign((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) <= 0)\r\n                    top--;\r\n                convex.p[++top] = p[i];\r\n            }\r\n            int temp = top;\r\n            convex.p[++ top] = p[n - 2];\r\n            for (int i = n - 3; i >= 0; -- i) {\r\n                while (top != temp && sign((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) <= 0)\r\n                    top --;\r\n                convex.p[++top] = p[i];\r\n            }\r\n            if (convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n --;//\u7279\u5224\r\n            convex.norm();//`\u539f\u6765\u5f97\u5230\u7684\u662f\u987a\u65f6\u9488\u7684\u70b9\uff0c\u6392\u5e8f\u540e\u9006\u65f6\u9488`\r\n        }\r\n\r\n        //`\u5f97\u5230\u51f8\u5305\u7684\u53e6\u5916\u4e00\u79cd\u65b9\u6cd5`\r\n        //`\u6d4b\u8bd5 LightOJ1203  LightOJ1239`\r\n        void Graham(Polygon_2 &convex) {\r\n            norm();\r\n            int &top = convex.n;\r\n            top = 0;\r\n            if (n == 1) {\r\n                top = 1;\r\n                convex.p[0] = p[0];\r\n                return;\r\n            }\r\n            if (n == 2) {\r\n                top = 2;\r\n                convex.p[0] = p[0];\r\n                convex.p[1] = p[1];\r\n                if (convex.p[0] == convex.p[1]) top --;\r\n                return;\r\n            }\r\n            convex.p[0] = p[0];\r\n            convex.p[1] = p[1];\r\n            top = 2;\r\n            for (int i = 2; i < n; i ++) {\r\n                while (top > 1 && sign((convex.p[top - 1] - convex.p[top - 2]) ^ (p[i] - convex.p[top - 2])) <= 0)\r\n                    top --;\r\n                convex.p[top ++] = p[i];\r\n            }\r\n            if (convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n --;//\u7279\u5224\r\n        }\r\n\r\n        //`\u5224\u65ad\u662f\u4e0d\u662f\u51f8\u7684`\r\n        bool isconvex() {\r\n            bool s[2];\r\n            memset(s, false, sizeof(s));\r\n            for (int i = 0; i < n; i ++) {\r\n                int j = (i + 1) % n;\r\n                int k = (j + 1) % n;\r\n                s[sign((p[j] - p[i]) ^ (p[k] - p[i])) + 1] = true;\r\n                if (s[0] && s[1]) return false;\r\n            }\r\n            return true;\r\n        }\r\n        //`\u5224\u65ad\u70b9\u548c\u4efb\u610f\u591a\u8fb9\u5f62\u7684\u5173\u7cfb`\r\n        //` 3 \u70b9\u4e0a`\r\n        //` 2 \u8fb9\u4e0a`\r\n        //` 1 \u5185\u90e8`\r\n        //` 0 \u5916\u90e8`\r\n        int relationpoint(Point_2 q) {\r\n            for (int i = 0; i < n; i ++) {\r\n                if (p[i] == q)return 3;\r\n            }\r\n            Getline();\r\n            for (int i = 0; i < n; i ++) {\r\n                if (l[i].pointonseg(q))return 2;\r\n            }\r\n            int cnt = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                int j = (i + 1) % n;\r\n                int k = sign((q - p[j]) ^ (p[i] - p[j]));\r\n                int u = sign(p[i].y - q.y);\r\n                int v = sign(p[j].y - q.y);\r\n                if (k > 0 && u < 0 && v >= 0) cnt ++;\r\n                if (k < 0 && v < 0 && u >= 0) cnt --;\r\n            }\r\n            return cnt != 0;\r\n        }\r\n\r\n        //`\u76f4\u7ebfu\u5207\u5272\u51f8\u591a\u8fb9\u5f62\u5de6\u4fa7`\r\n        //`\u6ce8\u610f\u76f4\u7ebf\u65b9\u5411`\r\n        //`\u6d4b\u8bd5\uff1aHDU3982`\r\n        void convexcut(Line_2 u, Polygon_2 &po) {\r\n            int &top = po.n;//\u6ce8\u610f\u5f15\u7528\r\n            top = 0;\r\n            for (int i = 0; i < n; i ++) {\r\n                int d1 = sign((u.ed - u.st) ^ (p[i] - u.st));\r\n                int d2 = sign((u.ed - u.st) ^ (p[(i + 1) % n] - u.st));\r\n                if (d1 >= 0) po.p[top++] = p[i];\r\n                if (d1 * d2 < 0) po.p[top++] = u.crosspoint(Line_2(p[i], p[(i + 1) % n]));\r\n            }\r\n        }\r\n\r\n        //`\u5f97\u5230\u5468\u957f`\r\n        //`\u6d4b\u8bd5 LightOJ1239`\r\n        double getcircumference() {\r\n            double sum = 0;\r\n            for (int i = 0; i < n; i ++) {\r\n                sum += p[i].dis(p[(i + 1) % n]);\r\n            }\r\n            return sum;\r\n        }\r\n\r\n        //`\u5f97\u5230\u9762\u79ef`\r\n        double getarea() {\r\n            double sum = 0;\r\n            for (int i = 0; i < n; i ++) {\r\n                sum += (p[i] ^ p[(i + 1) % n]);\r\n            }\r\n            return fabs(sum) / 2;\r\n        }\r\n\r\n        //`\u5f97\u5230\u65b9\u5411`\r\n        //` 1 \u8868\u793a\u9006\u65f6\u9488\uff0c0\u8868\u793a\u987a\u65f6\u9488`\r\n        bool getdir() {\r\n            double sum = 0;\r\n            for (int i = 0; i < n; i ++)\r\n                sum += (p[i] ^ p[(i + 1) % n]);\r\n            if (sign(sum) > 0) return 1;\r\n            return 0;\r\n        }\r\n\r\n        //`\u5f97\u5230\u91cd\u5fc3`\r\n        Point_2 getbarycentre() {\r\n            Point_2 ret(0, 0);\r\n            double area = 0;\r\n            for (int i = 1; i < n - 1; i ++) {\r\n                double tmp = (p[i] - p[0]) ^ (p[i + 1] - p[0]);\r\n                if (sign(tmp) == 0)continue;\r\n                area += tmp;\r\n                ret.x += (p[0].x + p[i].x + p[i + 1].x) / 3 * tmp;\r\n                ret.y += (p[0].y + p[i].y + p[i + 1].y) / 3 * tmp;\r\n            }\r\n            if (sign(area)) ret = ret / area;\r\n            return ret;\r\n        }\r\n\r\n        //`\u591a\u8fb9\u5f62\u548c\u5706\u4ea4\u7684\u9762\u79ef`\r\n        //`\u6d4b\u8bd5\uff1aPOJ3675 HDU3982 HDU2892`\r\n        double areacircle(circle c) {\r\n            double ans = 0;\r\n            for (int i = 0; i < n; i ++) {\r\n                int j = (i + 1) % n;\r\n                if (sign((p[j] - c.p) ^ (p[i] - c.p)) >= 0)\r\n                    ans += c.areatriangle(p[i], p[j]);\r\n                else ans -= c.areatriangle(p[i], p[j]);\r\n            }\r\n            return fabs(ans);\r\n        }\r\n        //`\u591a\u8fb9\u5f62\u548c\u5706\u5173\u7cfb`\r\n        //` 2 \u5706\u5b8c\u5168\u5728\u591a\u8fb9\u5f62\u5185`\r\n        //` 1 \u5706\u5728\u591a\u8fb9\u5f62\u91cc\u9762\uff0c\u78b0\u5230\u4e86\u591a\u8fb9\u5f62\u8fb9\u754c`\r\n        //` 0 \u5176\u5b83`\r\n        int relationcircle(circle c) {\r\n            Getline();\r\n            int x = 2;\r\n            if (relationpoint(c.p) != 1) return 0;//\u5706\u5fc3\u4e0d\u5728\u5185\u90e8\r\n            for (int i = 0; i < n; i ++) {\r\n                if (c.relationseg(l[i]) == 2) return 0;\r\n                if (c.relationseg(l[i]) == 1) x = 1;\r\n            }\r\n            return x;\r\n        }\r\n    };\r\n\r\n    //`AB X AC`\r\n    double cross(Point_2 A, Point_2 B, Point_2 C) {\r\n        return (B - A) ^ (C - A);\r\n    }\r\n\r\n    //`AB*AC`\r\n    double dot(Point_2 A, Point_2 B, Point_2 C) {\r\n        return (B - A) * (C - A);\r\n    }\r\n\r\n    //`\u6700\u5c0f\u77e9\u5f62\u9762\u79ef\u8986\u76d6`\r\n    //` A \u5fc5\u987b\u662f\u51f8\u5305(\u800c\u4e14\u662f\u9006\u65f6\u9488\u987a\u5e8f)`\r\n    //` \u6d4b\u8bd5 UVA 10173`\r\n    double minRectangleCover(Polygon_2 A) {\r\n        //`\u8981\u7279\u5224A.n < 3\u7684\u60c5\u51b5`\r\n        if (A.n < 3) return 0.0;\r\n        A.p[A.n] = A.p[0];\r\n        double ans = -1;\r\n        int r = 1, p = 1, q;\r\n        for (int i = 0; i < A.n; i ++) {\r\n            //`\u5361\u51fa\u79bb\u8fb9A.p[i] - A.p[i+1]\u6700\u8fdc\u7684\u70b9`\r\n            while(sign(cross(A.p[i], A.p[i + 1], A.p[r + 1]) - cross(A.p[i], A.p[i + 1], A.p[r])) >= 0)\r\n                r = (r + 1) % A.n;\r\n            //`\u5361\u51faA.p[i] - A.p[i+1]\u65b9\u5411\u4e0a\u6b63\u5411n\u6700\u8fdc\u7684\u70b9`\r\n            while(sign(dot(A.p[i], A.p[i + 1], A.p[p + 1]) - dot(A.p[i], A.p[i + 1], A.p[p])) >= 0)\r\n                p = (p + 1) % A.n;\r\n            if (i == 0)q = p;\r\n            //`\u5361\u51faA.p[i] - A.p[i+1]\u65b9\u5411\u4e0a\u8d1f\u5411\u6700\u8fdc\u7684\u70b9`\r\n            while(sign(dot(A.p[i], A.p[i + 1], A.p[q + 1]) - dot(A.p[i], A.p[i + 1], A.p[q])) <= 0)\r\n                q = (q + 1) % A.n;\r\n            double d = (A.p[i] - A.p[i + 1]).Length() * (A.p[i] - A.p[i + 1]).Length();\r\n            double tmp = cross(A.p[i], A.p[i + 1], A.p[r]) *\r\n                         (dot(A.p[i], A.p[i + 1], A.p[p]) - dot(A.p[i], A.p[i + 1], A.p[q])) / d;\r\n            if (ans < 0 || ans > tmp)ans = tmp;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n//`\u76f4\u7ebf\u5207\u51f8\u591a\u8fb9\u5f62`\r\n//`\u591a\u8fb9\u5f62\u662f\u9006\u65f6\u9488\u7684\uff0c\u5728q1q2\u7684\u5de6\u4fa7`\r\n//`\u6d4b\u8bd5:HDU3982`\r\n    vector<Point_2> convexCut(const vector<Point_2> &ps, Point_2 q1, Point_2 q2) {\r\n        vector<Point_2> qs;\r\n        int n = ps.size();\r\n        for (int i = 0; i < n; i ++) {\r\n            Point_2 p1 = ps[i], p2 = ps[(i + 1) % n];\r\n            int d1 = sign((q2 - q1) ^ (p1 - q1)), d2 = sign((q2 - q1) ^ (p2 - q1));\r\n            if (d1 >= 0)\r\n                qs.push_back(p1);\r\n            if (d1 * d2 < 0)\r\n                qs.push_back(Line_2(p1, p2).crosspoint(Line_2(q1, q2)));\r\n        }\r\n        return qs;\r\n    }\r\n//`\u534a\u5e73\u9762\u4ea4`\r\n//`\u6d4b\u8bd5 POJ3335 POJ1474 POJ1279`\r\n//***************************\r\n    struct halfplane:public Line_2 {\r\n        double angle;\r\n        halfplane(){}\r\n        //`\u8868\u793a\u5411\u91cfs->e\u9006\u65f6\u9488(\u5de6\u4fa7)\u7684\u534a\u5e73\u9762`\r\n        halfplane(Point_2 _s, Point_2 _e) {\r\n            st = _s;\r\n            ed = _e;\r\n        }\r\n        halfplane(Line_2 v) {\r\n            st = v.st;\r\n            ed = v.ed;\r\n        }\r\n        void calcangle() {\r\n            angle = atan2(ed.y - st.y, ed.x - st.x);\r\n        }\r\n        bool operator<(const halfplane &b) const {\r\n            return angle < b.angle;\r\n        }\r\n    };\r\n    class halfplanes {\r\n        int n;\r\n        halfplane hp[N];\r\n        Point_2 p[N];\r\n        int que[N];\r\n        int st, ed;\r\n        void push(halfplane tmp) {\r\n            hp[n ++] = tmp;\r\n        }\r\n\r\n        //\u53bb\u91cd\r\n        void unique() {\r\n            int m = 1;\r\n            for (int i = 1; i < n; i ++) {\r\n                if (sign(hp[i].angle - hp[i - 1].angle) != 0)\r\n                    hp[m++] = hp[i];\r\n                else if (sign((hp[m - 1].ed - hp[m - 1].st) ^ (hp[i].st - hp[m - 1].st)) > 0)\r\n                    hp[m - 1] = hp[i];\r\n            }\r\n            n = m;\r\n        }\r\n\r\n        bool halfplaneinsert() {\r\n            for (int i = 0; i < n; i ++) hp[i].calcangle();\r\n            sort(hp, hp + n);\r\n            unique();\r\n            que[st = 0] = 0;\r\n            que[ed = 1] = 1;\r\n            p[1] = hp[0].crosspoint(hp[1]);\r\n            for (int i = 2; i < n; i ++) {\r\n                while (st < ed && sign((hp[i].ed - hp[i].st) ^ (p[ed] - hp[i].st)) < 0) ed --;\r\n                while (st < ed && sign((hp[i].ed - hp[i].st) ^ (p[st + 1] - hp[i].st)) < 0) st ++;\r\n                que[++ ed] = i;\r\n                if (hp[i].parallel(hp[que[ed - 1]])) return false;\r\n                p[ed] = hp[i].crosspoint(hp[que[ed - 1]]);\r\n            }\r\n            while (st < ed && sign((hp[que[st]].ed - hp[que[st]].st) ^ (p[ed] - hp[que[st]].st)) < 0) ed --;\r\n            while (st < ed && sign((hp[que[ed]].ed - hp[que[ed]].st) ^ (p[st + 1] - hp[que[ed]].st)) < 0) st ++;\r\n            if (st + 1 >= ed)return false;\r\n            return true;\r\n        }\r\n\r\n        //`\u5f97\u5230\u6700\u540e\u534a\u5e73\u9762\u4ea4\u5f97\u5230\u7684\u51f8\u591a\u8fb9\u5f62`\r\n        //`\u9700\u8981\u5148\u8c03\u7528halfplaneinsert() \u4e14\u8fd4\u56detrue`\r\n        void getconvex(Polygon_2 &con) {\r\n            p[st] = hp[que[st]].crosspoint(hp[que[ed]]);\r\n            con.n = ed - st + 1;\r\n            for (int j = st, i = 0; j <= ed; i++, j++)\r\n                con.p[i] = p[j];\r\n        }\r\n    };\r\n\r\n    istream &operator>>(istream &is, Point_2 &it) {\r\n        is >> it.x >> it.y;\r\n        return is;\r\n    }\r\n    ostream  &operator<<(ostream &os, Point_2 &it) {\r\n        os << it.x << it.y;\r\n        return os;\r\n    }\r\n}\r\nconst int N = 2e5 + 5;\r\nint n;\r\nvector<Geometry2::Point_2> v(N + 1);\r\nbool check(Geometry2::Line_2 x, int id) {\r\n    int d = 0;\r\n    bool flag = false;\r\n    Geometry2::Line_2 y;\r\n    for(int i = 3; i <= n; ++ i) {\r\n        if(i == id) continue;\r\n        int r = x.relation(v[i]);\r\n        if(d == 0) {\r\n            if(r == 3) continue;\r\n            else {\r\n                y = {v[i], v[id]};\r\n                d = i;\r\n            }\r\n        }\r\n        else {\r\n            if(x.relation(v[i]) != 3 && y.relation(v[i]) != 3) return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nvoid solve() {\r\n    cin >> n;\r\n    for(int i = 1; i <= n; ++ i) {\r\n        cin >> v[i].x >> v[i].y;\r\n    }\r\n    int id = 0;\r\n    Geometry2::Line_2 x(v[1], v[2]);\r\n    vector<int> ids;\r\n    ids.emplace_back(1), ids.emplace_back(2);\r\n    for(int i = 3; i <= n; ++ i) {\r\n        if(x.relation(v[i]) != 3) {\r\n            ids.emplace_back(i);\r\n            break;\r\n        }\r\n    }\r\n    if(ids.size() == 2) {\r\n        cout << \"YES\" << '\\n';\r\n        return;\r\n    }\r\n    bool flag = false;\r\n    if(check(Geometry2::Line_2(v[ids[0]], v[ids[1]]), ids[2])) flag = true;\r\n    if(check(Geometry2::Line_2(v[ids[0]], v[ids[2]]), ids[1])) flag = true;\r\n    if(check(Geometry2::Line_2(v[ids[2]], v[ids[1]]), ids[0])) flag = true;\r\n    if(flag) {\r\n        cout << \"YES\" << '\\n';\r\n    }\r\n    else {\r\n        cout << \"NO\" << '\\n';\r\n    }\r\n}\r\nint32_t main() {\r\n#ifdef ONLINE_JUDGE\r\n#else\r\n    freopen(\"FuDiWeiU.in\", \"r\", stdin);\r\n    freopen(\"FuDiWeiU.out\", \"w\", stdout);\r\n#endif\r\n    int T = 1;\r\n//    cin >> T;\r\n    while(T --) {\r\n        solve();\r\n    }\r\n    return 0;\r\n}"
}