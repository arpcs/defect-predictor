{
    "id": 234576321,
    "contestId": 229,
    "creationTimeSeconds": 1701084742,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 229,
        "index": "C",
        "name": "Triangles",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1900,
        "tags": [
            "combinatorics",
            "graphs",
            "math"
        ]
    },
    "author": {
        "contestId": 229,
        "members": [
            {
                "handle": "nguyenquocthinhhung"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1349105400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 52,
    "timeConsumedMillis": 156,
    "memoryConsumedBytes": 4198400,
    "source": "#ifndef LOCAL\r\n    #pragma GCC optimize(\"O3,unroll-loops\")\r\n    #pragma GCC target(\"avx2,bmi,bmi2,popcnt,lzcnt\")\r\n#endif\r\n\r\n#include \"bits/stdc++.h\"\r\n\r\n#ifdef DEBUG\r\n    #include \"includes/debug/debug.hpp\"\r\n#else\r\n    #define debug(...) 0\r\n#endif\r\n\r\nstruct IOPre {\r\n    static constexpr int TEN = 10, SZ = TEN * TEN * TEN * TEN;\r\n    std::array<char, 4 * SZ> num;\r\n    constexpr IOPre() : num{} {\r\n        for (int i = 0; i < SZ; i++) {\r\n            int n = i;\r\n            for (int j = 3; j >= 0; j--) {\r\n                num[i * 4 + j] = static_cast<char>(n % TEN + '0');\r\n                n /= TEN;\r\n            }\r\n        }\r\n    }\r\n};\r\nstruct IO {\r\n#if !HAVE_DECL_FREAD_UNLOCKED\r\n    #define fread_unlocked fread\r\n#endif\r\n#if !HAVE_DECL_FWRITE_UNLOCKED\r\n    #define fwrite_unlocked fwrite\r\n#endif\r\n    static constexpr int SZ = 1 << 17, LEN = 32, TEN = 10, HUNDRED = TEN * TEN,\r\n                         THOUSAND = HUNDRED * TEN, TENTHOUSAND = THOUSAND * TEN,\r\n                         MAGIC_MULTIPLY = 205, MAGIC_SHIFT = 11, MASK = 15,\r\n                         TWELVE = 12, SIXTEEN = 16;\r\n    static constexpr IOPre io_pre = {};\r\n    std::array<char, SZ> input_buffer, output_buffer;\r\n    int input_ptr_left, input_ptr_right, output_ptr_right;\r\n\r\n    IO()\r\n        : input_buffer{},\r\n          output_buffer{},\r\n          input_ptr_left{},\r\n          input_ptr_right{},\r\n          output_ptr_right{} {}\r\n    IO(const IO&) = delete;\r\n    IO(IO&&) = delete;\r\n    IO& operator=(const IO&) = delete;\r\n    IO& operator=(IO&&) = delete;\r\n\r\n    ~IO() { flush(); }\r\n\r\n    template <class T>\r\n    struct is_char {\r\n        static constexpr bool value = std::is_same_v<T, char>;\r\n    };\r\n\r\n    template <class T>\r\n    struct is_bool {\r\n        static constexpr bool value = std::is_same_v<T, bool>;\r\n    };\r\n\r\n    template <class T>\r\n    struct is_string {\r\n        static constexpr bool value =\r\n            std::is_same_v<T, std::string> || std::is_same_v<T, const char*> ||\r\n            std::is_same_v<T, char*> || std::is_same_v<std::decay_t<T>, char*>;\r\n    };\r\n\r\n    template <class T, class D = void>\r\n    struct is_custom {\r\n        static constexpr bool value = false;\r\n    };\r\n\r\n    template <class T>\r\n    struct is_custom<T, std::void_t<typename T::internal_value_type>> {\r\n        static constexpr bool value = true;\r\n    };\r\n\r\n    template <class T>\r\n    struct is_default {\r\n        static constexpr bool value = is_char<T>::value || is_bool<T>::value ||\r\n                                      is_string<T>::value ||\r\n                                      std::is_integral_v<T>;\r\n    };\r\n\r\n    template <class T, class D = void>\r\n    struct is_iterable {\r\n        static constexpr bool value = false;\r\n    };\r\n\r\n    template <class T>\r\n    struct is_iterable<\r\n        T, typename std::void_t<decltype(std::begin(std::declval<T>()))>> {\r\n        static constexpr bool value = true;\r\n    };\r\n\r\n    template <class T, class D = void, class E = void>\r\n    struct is_applyable {\r\n        static constexpr bool value = false;\r\n    };\r\n\r\n    template <class T>\r\n    struct is_applyable<T, std::void_t<typename std::tuple_size<T>::type>,\r\n                        std::void_t<decltype(std::get<0>(std::declval<T>()))>> {\r\n        static constexpr bool value = true;\r\n    };\r\n\r\n    template <class T>\r\n    static constexpr bool needs_newline = (is_iterable<T>::value ||\r\n                                           is_applyable<T>::value) &&\r\n                                          (!is_default<T>::value);\r\n\r\n    template <typename T, typename U>\r\n    struct any_needs_newline {\r\n        static constexpr bool value = false;\r\n    };\r\n    template <typename T>\r\n    struct any_needs_newline<T, std::index_sequence<>> {\r\n        static constexpr bool value = false;\r\n    };\r\n    template <typename T, std::size_t I, std::size_t... Is>\r\n    struct any_needs_newline<T, std::index_sequence<I, Is...>> {\r\n        static constexpr bool value =\r\n            needs_newline<decltype(std::get<I>(std::declval<T>()))> ||\r\n            any_needs_newline<T, std::index_sequence<Is...>>::value;\r\n    };\r\n\r\n    inline void load() {\r\n        memmove(std::begin(input_buffer),\r\n                std::begin(input_buffer) + input_ptr_left,\r\n                input_ptr_right - input_ptr_left);\r\n        input_ptr_right =\r\n            input_ptr_right - input_ptr_left +\r\n            static_cast<int>(fread_unlocked(\r\n                std::begin(input_buffer) + input_ptr_right - input_ptr_left, 1,\r\n                SZ - input_ptr_right + input_ptr_left, stdin));\r\n        input_ptr_left = 0;\r\n    }\r\n\r\n    inline void read_char(char& c) {\r\n        if (input_ptr_left + LEN > input_ptr_right) load();\r\n        c = input_buffer[input_ptr_left++];\r\n    }\r\n    inline void read_string(std::string& x) {\r\n        char c;\r\n        while (read_char(c), c < '!') continue;\r\n        x = c;\r\n        while (read_char(c), c >= '!') x += c;\r\n    }\r\n    template <class T>\r\n    inline std::enable_if_t<std::is_integral_v<T>, void> read_int(T& x) {\r\n        if (input_ptr_left + LEN > input_ptr_right) load();\r\n        char c = 0;\r\n        do c = input_buffer[input_ptr_left++];\r\n        while (c < '-');\r\n        [[maybe_unused]] bool minus = false;\r\n        if constexpr (std::is_signed<T>::value == true)\r\n            if (c == '-') minus = true, c = input_buffer[input_ptr_left++];\r\n        x = 0;\r\n        while (c >= '0')\r\n            x = x * TEN + (c & MASK), c = input_buffer[input_ptr_left++];\r\n        if constexpr (std::is_signed<T>::value == true)\r\n            if (minus) x = -x;\r\n    }\r\n\r\n    inline void skip_space() {\r\n        if (input_ptr_left + LEN > input_ptr_right) load();\r\n        while (input_buffer[input_ptr_left] <= ' ') input_ptr_left++;\r\n    }\r\n\r\n    inline void flush() {\r\n        fwrite_unlocked(std::begin(output_buffer), 1, output_ptr_right, stdout);\r\n        output_ptr_right = 0;\r\n    }\r\n\r\n    inline void write_char(char c) {\r\n        if (output_ptr_right > SZ - LEN) flush();\r\n        output_buffer[output_ptr_right++] = c;\r\n    }\r\n\r\n    inline void write_bool(bool b) {\r\n        if (output_ptr_right > SZ - LEN) flush();\r\n        output_buffer[output_ptr_right++] = b ? '1' : '0';\r\n    }\r\n\r\n    inline void write_string(const std::string& s) {\r\n        for (auto x : s) write_char(x);\r\n    }\r\n\r\n    inline void write_string(const char* s) {\r\n        while (*s) write_char(*s++);\r\n    }\r\n\r\n    inline void write_string(char* s) {\r\n        while (*s) write_char(*s++);\r\n    }\r\n\r\n    template <typename T>\r\n    inline std::enable_if_t<std::is_integral_v<T>, void> write_int(T x) {\r\n        if (output_ptr_right > SZ - LEN) flush();\r\n        if (!x) {\r\n            output_buffer[output_ptr_right++] = '0';\r\n            return;\r\n        }\r\n        if constexpr (std::is_signed<T>::value == true)\r\n            if (x < 0) output_buffer[output_ptr_right++] = '-', x = -x;\r\n        int i = TWELVE;\r\n        std::array<char, SIXTEEN> buf{};\r\n        while (x >= TENTHOUSAND) {\r\n            memcpy(std::begin(buf) + i,\r\n                   std::begin(io_pre.num) + (x % TENTHOUSAND) * 4, 4);\r\n            x /= TENTHOUSAND;\r\n            i -= 4;\r\n        }\r\n        if (x < HUNDRED) {\r\n            if (x < TEN) {\r\n                output_buffer[output_ptr_right++] = static_cast<char>('0' + x);\r\n            } else {\r\n                std::uint32_t q =\r\n                    (static_cast<std::uint32_t>(x) * MAGIC_MULTIPLY) >>\r\n                    MAGIC_SHIFT;\r\n                std::uint32_t r = static_cast<std::uint32_t>(x) - q * TEN;\r\n                output_buffer[output_ptr_right] = static_cast<char>('0' + q);\r\n                output_buffer[output_ptr_right + 1] =\r\n                    static_cast<char>('0' + r);\r\n                output_ptr_right += 2;\r\n            }\r\n        } else {\r\n            if (x < THOUSAND) {\r\n                memcpy(std::begin(output_buffer) + output_ptr_right,\r\n                       std::begin(io_pre.num) + (x << 2) + 1, 3),\r\n                    output_ptr_right += 3;\r\n            } else {\r\n                memcpy(std::begin(output_buffer) + output_ptr_right,\r\n                       std::begin(io_pre.num) + (x << 2), 4),\r\n                    output_ptr_right += 4;\r\n            }\r\n        }\r\n        memcpy(std::begin(output_buffer) + output_ptr_right,\r\n               std::begin(buf) + i + 4, TWELVE - i);\r\n        output_ptr_right += TWELVE - i;\r\n    }\r\n    template <typename T_>\r\n    IO& operator<<(T_&& x) {\r\n        using T = typename std::remove_cv<\r\n            typename std::remove_reference<T_>::type>::type;\r\n        static_assert(is_custom<T>::value or is_default<T>::value or\r\n                      is_iterable<T>::value or is_applyable<T>::value);\r\n        if constexpr (is_custom<T>::value) {\r\n            write_int(x.get());\r\n        } else if constexpr (is_default<T>::value) {\r\n            if constexpr (is_bool<T>::value) {\r\n                write_bool(x);\r\n            } else if constexpr (is_string<T>::value) {\r\n                write_string(x);\r\n            } else if constexpr (is_char<T>::value) {\r\n                write_char(x);\r\n            } else if constexpr (std::is_integral_v<T>) {\r\n                write_int(x);\r\n            }\r\n        } else if constexpr (is_iterable<T>::value) {\r\n            // strings are immune\r\n            using E = decltype(*std::begin(x));\r\n            constexpr char sep = needs_newline<E> ? '\\n' : ' ';\r\n            int i = 0;\r\n            for (const auto& y : x) {\r\n                if (i++) write_char(sep);\r\n                operator<<(y);\r\n            }\r\n        } else if constexpr (is_applyable<T>::value) {\r\n            // strings are immune\r\n            constexpr char sep =\r\n                (any_needs_newline<\r\n                    T, std::make_index_sequence<std::tuple_size_v<T>>>::value)\r\n                    ? '\\n'\r\n                    : ' ';\r\n            int i = 0;\r\n            std::apply(\r\n                [this, &sep, &i](auto const&... y) {\r\n                    (((i++ ? write_char(sep) : void()), this->operator<<(y)),\r\n                     ...);\r\n                },\r\n                x);\r\n        }\r\n        return *this;\r\n    }\r\n    template <typename T>\r\n    IO& operator>>(T& x) {\r\n        static_assert(is_custom<T>::value or is_default<T>::value or\r\n                      is_iterable<T>::value or is_applyable<T>::value);\r\n        static_assert(!is_bool<T>::value);\r\n        if constexpr (is_custom<T>::value) {\r\n            typename T::internal_value_type y;\r\n            read_int(y);\r\n            x = y;\r\n        } else if constexpr (is_default<T>::value) {\r\n            if constexpr (is_string<T>::value) {\r\n                read_string(x);\r\n            } else if constexpr (is_char<T>::value) {\r\n                read_char(x);\r\n            } else if constexpr (std::is_integral_v<T>) {\r\n                read_int(x);\r\n            }\r\n        } else if constexpr (is_iterable<T>::value) {\r\n            for (auto& y : x) operator>>(y);\r\n        } else if constexpr (is_applyable<T>::value) {\r\n            std::apply([this](auto&... y) { ((this->operator>>(y)), ...); }, x);\r\n        }\r\n        return *this;\r\n    }\r\n\r\n    IO* tie(std::nullptr_t) { return this; }\r\n    void sync_with_stdio(bool) {}\r\n};\r\nIO io;\r\n#define cin io\r\n#define cout io\r\n\r\nusing ll = long long;\r\nusing ld = long double;\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    int _tests = 1;\r\n    // cin >> _tests;\r\n    for (int _test = 1; _test <= _tests; ++_test) {\r\n        // cout << \"Case #\" << _test << \": \";\r\n        int n, m;\r\n        cin >> n >> m;\r\n        vector<int> d(n);\r\n        for (int i = 0; i < m; ++i) {\r\n            int u, v;\r\n            cin >> u >> v;\r\n            --u, --v;\r\n            d[u]++;\r\n            d[v]++;\r\n        }\r\n        ll ans = -1LL * n * (n - 1) * (n - 2) / 6 - 2LL * (n - 1) * m + 1LL * n * (n - 1) * (n - 2) / 2;\r\n        for (auto x : d) ans += 1LL * x * x;\r\n        cout << ans / 2 << '\\n';\r\n    }\r\n}\r\n"
}