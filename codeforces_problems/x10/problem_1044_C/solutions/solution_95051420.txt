{
    "id": 95051420,
    "contestId": 1044,
    "creationTimeSeconds": 1602307489,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1044,
        "index": "C",
        "name": "Optimal Polygon Perimeter",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "dp",
            "geometry"
        ]
    },
    "author": {
        "contestId": 1044,
        "members": [
            {
                "handle": "rainbowzzh"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1541355000
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include<iostream>\r\n#include<cstdio>\r\n#include<vector>\r\n#include<queue>\r\n#include<map>\r\n#include<algorithm>\r\n#include<set>\r\n#include<cmath>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long long ll;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<long long, long long> pll;\r\ntypedef pair<double, double> pdd;\r\nconst double eps = 1e-8;\r\nconst double pi = acos(-1);\r\ninline int sgn(double d){if(fabs(d) < eps) return 0;if(d > 0) return 1;return -1;}\r\ninline double rad(double _deg){return _deg / 180.0 * pi;}\r\ninline double deg(double _rad){return _rad / pi * 180.0;}\r\nstruct Point{\r\n\tdouble x, y;\r\n    //int index;\r\n\tvoid read(){scanf(\"%lf%lf\", &x, &y);}\r\n\tvoid print(){printf(\"(%f, %f)\", x, y);}\r\n\tPoint():x(0.0), y(0.0){}\r\n\tPoint(double a, double b): x(a), y(b){}\r\n\t//Point(const Point& p): x(p.x), y(p.y){}\r\n\tPoint operator + (const Point& a){return {x + a.x, y + a.y};}\r\n\tPoint operator - (const Point& a){return {x - a.x, y - a.y};}\r\n\tdouble operator * (const Point& a){return x * a.x + y * a.y;}\r\n\tdouble operator ^ (const Point& a){return x * a.y - y * a.x;}\r\n\tbool operator == (const Point& p){return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;}\r\n\t/*bool operator < (const Point &p) const{\r\n\t\tif(sgn(y - p.y) == 0)\r\n\t\t\treturn sgn(x - p.x) == -1;\r\n\t\treturn sgn(y - p.y) == -1;\r\n\t}*/\r\n\tbool operator < (const Point &p) const{\r\n\t\tif(sgn(x - p.x) == 0)\r\n\t\t\treturn sgn(y - p.y) == -1;\r\n\t\treturn sgn(x - p.x) == -1;\r\n\t}\r\n\tinline double length(){return sqrt(x * x + y * y);}\r\n\tvoid unit(){ double len = length(); x /= len; y /= len;}\r\n}typedef Vector;\r\n\r\nstruct Segment{\r\n\tPoint a, b;\r\n\tvoid read(){a.read(); b.read();}\r\n\tSegment() : a(0.0, 0.0) , b(0.0, 0.0){}\r\n\tSegment(Point _a, Point _b) : a(_a), b(_b){}\r\n};\r\nstruct Line{\r\n\tPoint a, b;\r\n\tvoid read(){a.read(); b.read();}\r\n\tLine() : a(0.0, 0.0) , b(0.0, 0.0){}\r\n\tLine(Point _a, Point _b) : a(_a), b(_b){}\r\n\tLine(Point p,double angle)\r\n\t{\r\n\t\t//\u6839\u636e\u4e00\u4e2a\u70b9\u548c\u503e\u659c\u89d2 angle \u786e\u5b9a\u76f4\u7ebf,0<=angle<pi\r\n\t\ta = p;\r\n\t\tif(sgn(angle - pi / 2) == 0) b = a + Point(0,1);\r\n\t\telse b = (a + Point(1,tan(angle)));\r\n\t}\r\n\t// ax + by + c = 0;\r\n\tLine(double _a,double _b,double _c)\r\n\t{\r\n\t\tif(sgn(_a) == 0)\r\n\t\t{\r\n\t\t\ta = Point(0,-_c / _b);\r\n\t\t\tb = Point(1,- _c / _b);\r\n\t\t}\r\n\t\telse if(sgn(_b) == 0)\r\n\t\t{\r\n\t\t\ta = Point(- _c / _a, 0);\r\n\t\t\tb = Point(- _c / _a, 1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ta = Point(0, - _c/ _b);\r\n\t\t\tb = Point(1, (- _c - _a) / _b);\r\n\t\t}\r\n\t}\r\n};\r\ndouble Distance(const Point &a, const Point &b)\r\n{\r\n\tdouble x = a.x - b.x;\r\n\tdouble y = a.y - b.y;\r\n\treturn sqrt(x * x + y * y);\r\n}\r\ndouble Distance(Point p, Line l)\r\n{\r\n\treturn fabs((p - l.a) ^ (p - l.b)) / Distance(l.a, l.b);\r\n}\r\ndouble Distance(Point p, Segment sg)\r\n{\r\n\tPoint res;\r\n\tdouble t = ((p - sg.a) * (sg.b - sg.a)) / ((sg.b - sg.a) * (sg.b - sg.a));\r\n\tif(sgn(t) >= 0 && sgn(t - 1.0) <= 0)\r\n\t{\r\n\t\tres.x = sg.a.x + (sg.b.x - sg.a.x) * t;\r\n\t\tres.y = sg.a.y + (sg.b.y - sg.a.y) * t;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(sgn(Distance(p, sg.a) - Distance(p, sg.b)) < 0)\r\n\t\t\tres = sg.a;\r\n\t\telse res = sg.b;\r\n\t}\r\n\treturn Distance(res, p);\r\n}\r\nbool is_in_line(Point a, Point b, Point c)\r\n{\r\n    return sgn((b - a) ^ (c - b)) == 0;\r\n}\r\nPoint Projection(Point p, Line l)\r\n{\r\n\t// \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9\r\n\tVector v1 = l.b - l.a;\r\n\tVector v2 = p - l.a;\r\n\tdouble k1 = v1 * v2;\r\n\tdouble k2 = v1.length();\r\n\tk1 /= k2 * k2;\r\n\treturn {l.a.x + v1.x * k1, l.a.y+ v1.y * k1};\r\n}\r\nPoint Reflection(Point p, Line l)\r\n{\r\n\t// \u70b9\u5173\u4e8e\u76f4\u7ebf\u5bf9\u79f0\r\n\tPoint p0 = Projection(p, l);\r\n\tVector v0 = p0 - p;\r\n\treturn p0 + v0;\r\n}\r\nint ccw(Point p, Segment sg)\r\n{\t// Counter_Clockwise\r\n\t// p \u5173\u4e8e(sg.a -> sg.b)\u7684\u4f4d\u7f6e\u5173\u7cfb\r\n\tVector v0 = sg.b - sg.a;\r\n\tVector v1 = p - sg.a;\r\n\r\n\tint fcross = sgn(v0 ^ v1);\r\n\r\n\tif(fcross == 1) return 1; // \u9006\u65f6\u9488\u65b9\u5411\r\n\tif(fcross == -1) return -1; // \u987a\u65f6\u9488\u65b9\u5411\r\n\r\n\tint fdot = sgn(v0 * v1);\r\n\r\n\tif(fdot == -1) return 2; // \u53cd\u5411\u7ebf\u6bb5\u5916\u5171\u7ebf\r\n\tif(v0.length() < v1.length()) return -2; //\u6b63\u5411\u7ebf\u6bb5\u5916\u5171\u7ebf\r\n\treturn 0; //\u70b9\u5728\u7ebf\u6bb5\u4e0a\r\n}\r\n\r\nbool isParallel(Line l1, Line l2)\r\n{\r\n\t//\u6ca1\u6709\u5224\u65ad\u91cd\u5408\r\n\treturn sgn((l1.b - l1.a) ^ (l2.b - l2.a)) == 0;\r\n}\r\nbool isOrthogonal(Line l1, Line l2)\r\n{\r\n\t//\u6b63\u4ea4\r\n\treturn sgn((l1.b - l1.a) * (l2.b - l2.a)) == 0;\r\n}\r\nbool isCover(Line l1, Line l2) //******\r\n{\r\n    //\u6709\u6ca1\u6709\u91cd\u5408\r\n    return isParallel(l1, l2) && abs(ccw(l1.a, {l2.a, l2.b})) != 1;\r\n}\r\nbool is_intersection(Segment sg1, Segment sg2)\r\n{\r\n\t// \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u6709\u4ea4\u70b9\r\n\treturn ccw(sg2.a, sg1) * ccw(sg2.b, sg1) <= 0 && ccw(sg1.a, sg2) * ccw(sg1.b, sg2) <= 0;\r\n}\r\nbool is_intersection(Line l, Segment sg)\r\n{\r\n\t//\u76f4\u7ebf\u548c\u7ebf\u6bb5\u662f\u5426\u6709\u4ea4\u70b9\r\n\treturn ccw(sg.a, {l.a, l.b}) * ccw(sg.b, {l.a, l.b}) <= 0;\r\n}\r\nbool is_intersection(Point p, Line l)\r\n{\r\n    // \u662f\u5426\u5728\u76f4\u7ebf\u4e0a\r\n    return sgn((p - l.a) ^ (p - l.b)) == 0;\r\n}\r\nbool is_intersection(Point p, Segment sg)\r\n{\r\n    //\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a\r\n    return  sgn((p - sg.a) ^ (p - sg.b)) == 0 && sgn((p - sg.a) * (p - sg.b)) <= 0;\r\n}\r\nPoint get_Intersection(Line l1, Line l2)\r\n{\r\n    //\u524d\u63d0\u662f\u4e24\u76f4\u7ebf\u6709\u4ea4\u70b9\r\n    double a1 = (l2.b - l2.a) ^ (l1.a - l2.a);\r\n    double a2 = (l2.b - l2.a) ^ (l1.b - l2.a);\r\n    return Point((l1.a.x * a2 - l1.b.x * a1) / (a2 - a1), (l1.a.y * a2 - l1.b.y * a1) / (a2 - a1));\r\n}\r\n\r\nstruct Polygon{\r\n\tvector<Point> p;\r\n\tvoid init(){p.clear();}\r\n    inline int n()\r\n    {\r\n        return p.size();\r\n    }\r\n    void read(int n)\r\n    {\r\n        Point _p;\r\n        p.clear();\r\n        for(int i = 0; i < n; ++ i)\r\n        {\r\n            _p.read();\r\n            p.push_back(_p);\r\n        }\r\n    }\r\n    void addpoint(Point _p){ p.push_back(_p);};\r\n    struct cmp{\r\n    //\u6781\u89d2\u6392\u5e8f\u4eff\u51fd\u6570\r\n        Point p;\r\n        cmp(const Point& _p) : p(_p){}\r\n        bool operator()(const Point &_a, const Point &_b)\r\n        {\r\n            Point a = _a, b = _b;\r\n            double d = (a - p) ^ (b - p);\r\n            if(sgn(d) == 0)\treturn sgn(Distance(a, p) - Distance(b, p)) == -1;\r\n            return sgn(d) == 1;\r\n        }\r\n \t};\r\n \tbool is_convex()\r\n    {\r\n        //\u5224\u65ad\u51f8\u5305(\u987a\u65f6\u9488\u6216\u9006\u65f6\u9488\u7ed9\u70b9)\r\n        if(n() < 3) return 0;\r\n        bool flag1 = 1, flag2 = 1;\r\n        for(int i = 0; i < n(); ++i)\r\n        {\r\n            if(ccw(p[i], {p[(i + 1) % n()], p[(i + 2) % n()]}) == -1) flag1 = 0; //\u9006\u65f6\u9488\u65b9\u5411\r\n            if(ccw(p[i], {p[(i + 1) % n()], p[(i + 2) % n()]}) == 1) flag2 = 0; //\u987a\u65f6\u9488\u65b9\u5411\r\n        }\r\n        return flag1 || flag2;\r\n    }\r\n \tvoid get_convex(Polygon& convex)\r\n    {\r\n        //\u6c42\u53d6\u51f8\u5305\r\n        Point o = p[0];\r\n        for(int i = 0; i < n(); ++ i) o = min(o, p[i]);\r\n        sort(p.begin(), p.end(), cmp(o));\r\n        convex.init();\r\n        if(p.size() == 1)\r\n        {\r\n            convex.addpoint(p[0]);\r\n            return;\r\n        }\r\n        else if(p.size() == 2)\r\n        {\r\n            convex.addpoint(p[0]);\r\n            convex.addpoint(p[1]);\r\n            if(p[0] == p[1]) convex.p.pop_back();\r\n            return;\r\n        }\r\n        convex.addpoint(p[0]);\r\n        convex.addpoint(p[1]);\r\n        for(int i = 2; i < p.size(); ++i)\r\n        {\r\n            // < \u4fdd\u7559\u5171\u7ebf\u7684\u70b9  <= \u4e0d\u4fdd\u7559\u5171\u7ebf\u7684\u70b9\r\n            // \u6700\u540e\u4e00\u6839\u5782\u76f4\u7ebf\u7684\u70b9\u65e0\u6cd5\u88ab\u4fdd\u7559\r\n            while(convex.n() >= 2 && sgn((convex.p[convex.n() - 1] - convex.p[convex.n() - 2]) ^ (p[i] - convex.p[convex.n() - 2])) <= 0)\r\n            {\r\n                convex.p.pop_back();\r\n            }\r\n            convex.addpoint(p[i]);\r\n        }\r\n        if(convex.n() == 2 && convex.p[0] == convex.p[1]) convex.p.pop_back();\r\n    }\r\n    bool get_stable_convex(Polygon &convex)\r\n    {   // ************* \u5c1a\u672a\u89e3\u51b3 POJ - 1228\r\n        // \u6c42\u53d6\u7a33\u5b9a\u51f8\u5305\r\n        // 0 \u4e0d\u5b58\u5728\u7a33\u5b9a\u51f8\u5305\r\n        // 1 \u53ef\u4ee5\u5f97\u5230\u7a33\u5b9a\u51f8\u5305\r\n        if(n() < 6) return 0;\r\n        get_convex(convex);\r\n        if(convex.n() < 3) return 0;\r\n        convex.init();\r\n        convex.addpoint(p[0]);\r\n        convex.addpoint(p[1]);\r\n        for(int i = 2; i < p.size(); ++i)\r\n        {\r\n            // < \u4fdd\u7559\u5171\u7ebf\u7684\u70b9  <= \u4e0d\u4fdd\u7559\u5171\u7ebf\u7684\u70b9\r\n            // \u6700\u540e\u4e00\u6839\u5782\u76f4\u7ebf\u7684\u70b9\u65e0\u6cd5\u88ab\u4fdd\u7559\r\n            while(convex.n() >= 2 && sgn((convex.p[convex.n() - 1] - convex.p[convex.n() - 2]) ^ (p[i] - convex.p[convex.n() - 2])) < 0)\r\n            {\r\n                convex.p.pop_back();\r\n            }\r\n            convex.addpoint(p[i]);\r\n        }\r\n        if(convex.n() == 2 && convex.p[0] == convex.p[1]) convex.p.pop_back();\r\n        vector<Point> &_p = convex.p;\r\n        int _n = convex.n();\r\n        for(int i = 1 ; i < _n - 1; ++ i)\r\n        {\r\n            if(is_in_line(_p[(i - 2 + _n) % _n], _p[(i - 1 + _n) % _n], _p[i]) == 0 && is_in_line(_p[(i - 1 + _n) % _n], _p[i], _p[(i + 1) % _n]) == 0\r\n               && is_in_line(_p[i], _p[(i + 1) % _n], _p[(i + 2) % _n]) == 0)\r\n                return 0;\r\n        }\r\n        Segment sg(_p[0], _p.back());\r\n        int cnt = 0;\r\n        for(int i = 0; i < n(); ++ i)\r\n        {\r\n            if(:: is_intersection(p[i], sg) ) cnt ++;\r\n\r\n            if(cnt >= 3)\r\n            {\r\n                Point temp = _p.back();\r\n                _p.pop_back();\r\n                _p.push_back(p[i]);\r\n                _p.push_back(temp);\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    void get_cntp_on_edge(Polygon &convex, int *cnt)\r\n    {\r\n        //\u7edf\u8ba1\u6709\u591a\u5c11\u4e2a\u70b9\u843d\u5728\u8fd9\u4e2a\u51f8\u5305\u4e0a\r\n        for(int i = 0; i < convex.n(); ++ i)\r\n        {\r\n            cnt[i] = 0;\r\n            Segment sg(convex.p[i], convex.p[(i + 1) % convex.n()]);\r\n            for(int j = 0; j < n(); ++ j) if(:: is_intersection(p[j], sg)) cnt[i] ++;\r\n        }\r\n    }\r\n    double get_circumference()\r\n    {\r\n        //\u8ba1\u7b97\u51f8\u5305\u5468\u957f\r\n        double res = 0.0;\r\n        for(int i = 0; i < n(); ++ i)\r\n        {\r\n            res += Distance(p[i], p[(i + 1) % n()]);\r\n        }\r\n        return res;\r\n    }\r\n    double get_area()\r\n    {\r\n        double res = 0.0;\r\n        for(int i = 0; i < n(); ++ i) res += (p[i] ^ p[(i + 1) % n()]);\r\n        return fabs(res) / 2.0;\r\n    }\r\n    bool get_dir()\r\n    {\r\n        // \u5224\u65ad\u591a\u8fb9\u5f62\u7684\u65b9\u5411\r\n        //1 \u987a\u65f6\u9488 0 \u9006\u65f6\u9488\r\n        double res = 0.0;\r\n        for(int i = 0; i < n(); ++ i) res += (p[i] ^ p[(i + 1) % n()]);\r\n        return sgn(res) > 0;\r\n    }\r\n    int get_pos(Point _p)\r\n    {\r\n        //\u5224\u65ad\u70b9\u548c\u4efb\u610f\u591a\u8fb9\u5f62\u7684\u5173\u7cfb\r\n        // 3 \u70b9\u4e0a\r\n        // 2 \u8fb9\u4e0a\r\n        // 1 \u5185\u90e8\r\n        // 0 \u5916\u90e8\r\n        for(int i = 0; i < n(); ++ i) if(p[i] == _p) return 3;\r\n        for(int i = 0; i < n(); ++ i)\r\n        {\r\n            if(::is_intersection(_p, Segment(p[i], p[(i + 1) % n()]))) return 2;\r\n        }\r\n        int cnt = 0;\r\n        for(int i = 0; i < n(); ++ i)\r\n        {\r\n            int j = (i + 1) % n();\r\n            int k = sgn((_p - p[j]) ^ (_p - p[i]));\r\n            int u = sgn(p[i].y - _p.y);\r\n            int v = sgn(p[j].y - _p.y);\r\n            if(k > 0 && u < 0 && v >= 0) cnt ++;\r\n            if(k < 0 && v < 0 && u >= 0) cnt --;\r\n        }\r\n        return cnt != 0;\r\n    }\r\n\tbool is_intersection(Polygon pg)\r\n\t{\r\n\t\tfor(int i = 0; i < n(); ++ i)\r\n\t\t{\r\n\t\t\tSegment sg1(p[i], p[(i + 1) % n()]);\r\n\t\t\tfor(int j = 0; j < pg.n(); ++ j)\r\n\t\t\t{\r\n\t\t\t\tSegment sg2(pg.p[j], pg.p[(j + 1) % pg.n()]);\r\n\t\t\t\tif(::is_intersection(sg1, sg2)) return 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n};\r\nconst int N = 1e3 + 5;\r\nint n;\r\nPolygon pg;\r\nvector<Point> pmx, pmnx, pmy, pmny, tot;\r\nvector<Point> sel;\r\nll max3 = -1, max4;\r\nvoid dfs(int i, int num)\r\n{\r\n    if(num == 4)\r\n    {\r\n        double Mx = -1e20, MNx = 1e20, My = -1e20, MNy = 1e20;\r\n        for(int j = 0; j < 3; ++ j)\r\n        {\r\n            if(sgn(sel[j].x - Mx) == 1) Mx = sel[j].x;\r\n            if(sgn(sel[j].x - MNx) == -1) MNx = sel[j].x;\r\n            if(sgn(sel[j].y - My) == 1) My = sel[j].y;\r\n            if(sgn(sel[j].y - MNy) == -1) MNy = sel[j].y;\r\n        }\r\n        max3 = max(max3, (ll)(Mx - MNx + eps) + (ll)(My - MNy + eps));\r\n    }\r\n    if(i == tot.size()) return;\r\n    sel.push_back(tot[i]); dfs(i + 1, num + 1); sel.pop_back();\r\n    dfs(i + 1, num);\r\n}\r\nint main()\r\n{\r\n    scanf(\"%d\", &n);\r\n    pg.read(n);\r\n    Point p = pg.p[0];\r\n    double maxx = p.x, maxy = p.y, minx = maxx, miny = maxy;\r\n    pmx.push_back(p); pmnx.push_back(p); pmy.push_back(p); pmny.push_back(p);\r\n    for(int i = 1; i < n; ++ i)\r\n    {\r\n        double x = pg.p[i].x;\r\n        double y  =pg.p[i].y;\r\n        p = {x, y};\r\n        if(sgn(x - maxx) == 1) pmx.clear(), pmx.push_back(p), maxx = x;\r\n        else if(sgn(x - maxx) == 0) pmx.push_back(p);\r\n\r\n        if(sgn(x - minx) == -1) pmnx.clear(), pmnx.push_back(p), minx = x;\r\n        else if(sgn(x - minx) == 0) pmnx.push_back(p);\r\n\r\n        if(sgn(y - maxy) == 1) pmy.clear(), pmy.push_back(p), maxy = y;\r\n        else if(sgn(y - maxy) == 0) pmy.push_back(p);\r\n\r\n        if(sgn(y - miny) == -1) pmny.clear(), pmny.push_back(p), miny = y;\r\n        else if(sgn(y - miny) == 0) pmny.push_back(p);\r\n    }\r\n    max4 = (ll)(maxx - minx + eps) + (ll)(maxy - miny + eps);\r\n    for(int i = 0; i < pmx.size(); ++ i) tot.push_back(pmx[i]);\r\n    for(int i = 0; i < pmnx.size(); ++ i) tot.push_back(pmnx[i]);\r\n    for(int i = 0; i < pmy.size(); ++ i) tot.push_back(pmy[i]);\r\n    for(int i = 0; i < pmny.size(); ++ i) tot.push_back(pmny[i]);\r\n    dfs(0, 1);\r\n    printf(\"%lld\", max3 * 2);\r\n    for(int i = 4; i <= n; ++ i) printf(\" %lld\", max4 * 2);\r\n\r\n\treturn 0;\r\n}\r\n\r\n"
}