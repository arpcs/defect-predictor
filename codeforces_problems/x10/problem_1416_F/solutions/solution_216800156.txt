{
    "id": 216800156,
    "contestId": 1416,
    "creationTimeSeconds": 1690956179,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1416,
        "index": "F",
        "name": "Showing Off",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3300,
        "tags": [
            "flows",
            "graph matchings",
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 1416,
        "members": [
            {
                "handle": "yyandy"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1601219100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 96,
    "timeConsumedMillis": 4898,
    "memoryConsumedBytes": 118272000,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nvector<int> vec[102000],a[102000];\r\nvector<pair<int,int> > Link[102000];\r\n#define ID(x,y) (x)*m-m+(y)\r\n#define ReID(x)  make_pair((x-1)/m+1,(x-1)%m+1)\r\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\r\nchar ch[4][4];\r\nconst int N = 2e6 + 5;\r\ntypedef long long ll;\r\nstruct ios{\r\n    inline char read(){\r\n        static const int IN_LEN=1<<18|1;\r\n        static char buf[IN_LEN],*s,*t;\r\n        return (s==t)&&(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++;\r\n    }\r\n    template <typename _Tp> inline ios & operator >> (_Tp&x){\r\n        static char c11,boo;\r\n        for(c11=read(),boo=0;!isdigit(c11);c11=read()){\r\n            if(c11==-1)return *this;\r\n            boo|=c11=='-';\r\n        }\r\n        for(x=0;isdigit(c11);c11=read())x=x*10+(c11^'0');\r\n        boo&&(x=-x);\r\n        return *this;\r\n    }\r\n}Fread;\r\nstruct edge {\r\n    int pt, nxt;\r\n    ll w, fl;\r\n};\r\nstruct Graph {\r\n    edge e[N];\r\n    int H[N], H2[N], tot = 1;\r\n    inline void addedge(int x, int y, ll w) {\r\n        e[++tot] = {y, H[x], w, 0};\r\n        H[x] = H2[x] = tot;\r\n        e[++tot] = {x, H[y], 0, 0};\r\n        H[y] = H2[y] = tot;\r\n    }\r\n    inline void clear(int n) {\r\n        memset(H, 0, n * 4 + 4);\r\n        memset(H2, 0, n * 4 + 4);\r\n\r\n        for (int i = 1; i <= tot; ++i)\r\n            e[i] = {0, 0, 0, 0};\r\n\r\n        tot = 1;\r\n    }\r\n};\r\nstruct edge0 {\r\n    int x, y;\r\n    ll a, b;\r\n};\r\nstruct FeasiFlowMax {\r\n    Graph P;\r\n    const ll oo = 1e14;\r\n    int dep[N];\r\n\r\n    vector<edge0> vec;\t\r\n\r\n    inline bool BFS(int S, int T, int n) {\r\n        queue<int> Q;\r\n        memset(dep, 0, 4 * n + 4);\r\n        memcpy(P.H, P.H2, 4 * P.tot + 4);\r\n        Q.push(S);\r\n        dep[S] = 1;\r\n\r\n        while (!Q.empty()) {\r\n            int t = Q.front();\r\n            Q.pop();\r\n\r\n            for (int i = P.H[t]; i; i = P.e[i].nxt) {\r\n                int v = P.e[i].pt, val = P.e[i].w, fl = P.e[i].fl;\r\n\r\n                if (val > fl && !dep[v]) {\r\n                    dep[v] = dep[t] + 1;\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n\r\n        return dep[T] > 0;\r\n    }\r\n    inline ll dfs(int x, ll F, int T) {\r\n        if (x == T || !F)\r\n            return F;\r\n\r\n        ll nowflow = 0, toflow = 0;\r\n\r\n        for (int &i = P.H[x]; i; i = P.e[i].nxt) {\r\n            int v = P.e[i].pt;\r\n\r\n            if (dep[v] == dep[x] + 1 && P.e[i].w > P.e[i].fl &&\r\n                    (toflow = dfs(v, min(0ll + P.e[i].w - P.e[i].fl, F - nowflow), T))) {\r\n                nowflow += toflow;\r\n                P.e[i].fl += toflow;\r\n                P.e[i ^ 1].fl -= toflow;\r\n            }\r\n\r\n            if (nowflow == F)\r\n                break;\r\n        }\r\n\r\n        if (!nowflow)\r\n            dep[x] = -1;\r\n\r\n        return nowflow;\r\n    }\r\n    ll r[N];\r\n    int tag;\r\n\tinline void clear (int sz){\r\n\t\tP.clear(sz);\r\n\t\ttag=0;\r\n\t\tmemset(r,0,sz*8+8);\r\n\t\tvec.clear();\r\n\t} \r\n    inline ll construct(int n) {\r\n        int S = n + 1, T = n + 2;\r\n        ll totval = 0;\r\n        memset(r, 0, n * 4 + 4);\r\n\r\n        for (auto I : vec) {\r\n            r[I.x] -= I.a;\r\n            r[I.y] += I.a;\r\n            P.addedge(I.x, I.y, I.b - I.a);\r\n        }\r\n\r\n        tag = P.tot;\r\n\r\n        for (int i = 1; i <= n; ++i)\r\n            if (r[i] > 0)\r\n                P.addedge(S, i, r[i]), totval += r[i];\r\n            else if (r[i] < 0)\r\n                P.addedge(i, T, -r[i]);\r\n\r\n        return totval;\r\n    }\r\n    inline ll dinic(int S, int T, int n) {\r\n        ll ans = 0;\r\n        vec.push_back((edge0) {\r\n            T, S, 0, oo\r\n        });\r\n        P.clear(n + 2);\r\n        ll val = construct(n);\r\n        vec.pop_back();\r\n        while (BFS(n + 1, n + 2, n + 2))\r\n            ans += dfs(n + 1, oo, n + 2);\r\n        if (ans < val)\r\n            return -1;\r\n        return 1; \r\n    }\r\n} Dinic;\r\nint n,m;\r\ninline void solve(){\r\n\tFread>>n>>m;\r\n\tif(n==1&&m==1){\r\n\t\tcout<<\"NO\\n\";\r\n\t\treturn;\r\n\t}\r\n\tfor(int i=1;i<=n;++i)\r\n\t\tvec[i].clear(),a[i].clear(),Link[i].clear();\r\n\tDinic.clear(ID(n,m)+5);\r\n\tDinic.P.clear(ID(n,m)+5);\r\n\tfor(int i=0;i<=n+1;++i)\r\n\t\tvec[i].resize(m+2),a[i].resize(m+2),Link[i].resize(m+2); \r\n\tfor(int i=1;i<=n;++i)\r\n\t\tfor(int j=1;j<=m;++j)\r\n\t\t\tFread>>vec[i][j];\r\n\t\t\t\r\n\tint S=ID(n,m)+1,T=ID(n,m)+2;\r\n\tfor(int i=1;i<=n;++i){\r\n\t\tfor(int j=1;j<=m;++j){\r\n\t\t\tint flag=0,flag2=0;\r\n\t\t\tfor(int dir=0;dir<4;++dir){\r\n\t\t\t\tint xx=dx[dir]+i,yy=dy[dir]+j;\r\n\t\t\t\tif(xx<1||yy<1||xx>n||yy>m)continue;\r\n\t\t\t\tflag|=vec[xx][yy]<vec[i][j];\r\n\t\t\t\tflag2|=vec[xx][yy]<=vec[i][j];\r\n\t\t\t\tif(vec[xx][yy]==vec[i][j]){\r\n\t\t\t\t\tif((i+j)&1)\r\n\t\t\t\t\t\tDinic.vec.push_back((edge0){ID(i,j),ID(xx,yy),0,1});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!flag2){\r\n\t\t\t\tcout<<\"NO\\n\";\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(!flag){\r\n\t\t\t\tif((i+j)&1)\r\n\t\t\t\t\tDinic.vec.push_back((edge0){S,ID(i,j),1,1});\r\n\t\t\t\telse \r\n\t\t\t\t\tDinic.vec.push_back((edge0){ID(i,j),T,1,1});\r\n\t\t\t}else{\r\n\t\t\t\tif((i+j)&1)\r\n\t\t\t\t\tDinic.vec.push_back((edge0){S,ID(i,j),0,1});\r\n\t\t\t\telse \r\n\t\t\t\t\tDinic.vec.push_back((edge0){ID(i,j),T,0,1});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tint res=Dinic.dinic(S,T,T);\r\n\tif(res==-1)cout<<\"NO\\n\";\r\n\telse{\r\n\t\tcout<<\"YES\\n\";\r\n\t\tfor(int i=1;i<=n;++i)\t\r\n\t\t\tfor(int j=1;j<=m;++j){\r\n\t\t\t\tint p=ID(i,j);\r\n\t\t\t\tif((i+j)&1){\r\n\t\t\t\t\tfor(int k=Dinic.P.H[p];k;k=Dinic.P.e[k].nxt){\r\n\t\t\t\t\t\tif(Dinic.P.e[k].fl&&Dinic.P.e[k].pt<=ID(n,m)){\r\n\t\t\t\t\t\t\tauto V=ReID(Dinic.P.e[k].pt);\r\n\t\t\t\t\t\t\tLink[V.first][V.second]=make_pair(i,j);\r\n\t\t\t\t\t\t\tLink[i][j]=V;\r\n\t\t\t\t\t\t\ta[i][j]=vec[i][j]/2;\r\n\t\t\t\t\t\t\ta[V.first][V.second]=vec[i][j]-a[i][j];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tfor(int i=1;i<=n;++i)\r\n\t\t\tfor(int j=1;j<=m;++j){\r\n\t\t\t\tif(!Link[i][j].first){\r\n\t\t\t\t\tfor(int k=0;k<4;++k){\r\n\t\t\t\t\t\tint xx=i+dx[k],yy=j+dy[k];\r\n\t\t\t\t\t\t\tif(xx>0&&yy>0&&xx<=n&&yy<=m&&vec[i][j]>vec[xx][yy]){\r\n\t\t\t\t\t\t\tLink[i][j]=make_pair(xx,yy);\r\n\t\t\t\t\t\t\ta[i][j]=vec[i][j]-vec[xx][yy];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tfor(int i=1;i<=n;++i,cout<<'\\n')\r\n\t\t\tfor(int j=1;j<=m;++j){\r\n\t\t\t\tcout<<a[i][j]<<' ';\r\n\t\t\t}\r\n\t\tfor(int i=1;i<=n;++i,cout<<'\\n')\r\n\t\t\tfor(int j=1;j<=m;++j){\r\n\t\t\t\tint Tx=Link[i][j].first-i+1,Ty=Link[i][j].second-j+1;\r\n\t\t\t\tcout<<ch[Tx][Ty]<<' ';\r\n\t\t\t}\r\n\t}\r\n}\r\nint main(){\r\n\tint T;\r\n\tch[0][1]='U';\r\n\tch[1][0]='L';\r\n\tch[1][2]='R';\r\n\tch[2][1]='D';\r\n\tFread>>T;\r\n\twhile(T--){\r\n\t\tsolve(); \r\n\t}\r\n}"
}