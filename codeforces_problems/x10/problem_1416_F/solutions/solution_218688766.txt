{
    "id": 218688766,
    "contestId": 1416,
    "creationTimeSeconds": 1691938603,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1416,
        "index": "F",
        "name": "Showing Off",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3300,
        "tags": [
            "flows",
            "graph matchings",
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 1416,
        "members": [
            {
                "handle": "EgorUlin"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1601219100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 96,
    "timeConsumedMillis": 3728,
    "memoryConsumedBytes": 60006400,
    "source": "\ufeff#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <set>\r\n#include <random>\r\n#include <cstring>\r\n#include <numeric>\r\n#include <queue>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\n#define M_PI 3.14159265358979323846264338327950288419716939937510\r\n#define inf 1e15\r\n#define eps 1e-10\r\n#define fori(n)for (long long i = 0; i < n; i++)\r\n#define forj(n)for (long long j = 0; j < n; j++)\r\n#define rep(i, n)for (long long i = 0; i < n; i++)\r\n#define re return\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define bit(i, n) ((n >> i) & 1)\r\n#define ld long double\r\n#define vec vector\r\n#define unq(x) x.resize(unique(all(x)) - x.begin())\r\n\r\nint __not_lg(ll n) { int cnt = 0; while (n /= 2) cnt++; re cnt; }\r\nstruct dsu {\r\n\tvector<int> v, cnt;\r\n\tvoid build(int n) { v.resize(n); cnt.resize(n); iota(all(v), 0); fill(all(cnt), 1); }\r\n\tdsu() {}\r\n\tdsu(int n) { build(n); }\r\n\tint get_par(int i) { if (v[i] != i)v[i] = get_par(v[i]); re v[i]; }\r\n\tbool check(int i1, int i2) { i1 = get_par(i1), i2 = get_par(i2); re i1 == i2; }\r\n\tvoid merge(int i1, int i2) { i1 = get_par(i1), i2 = get_par(i2); if (i1 == i2)re; if (cnt[i1] > cnt[i2])swap(i1, i2); cnt[i1] += cnt[i2]; v[i2] = i1; }\r\n};\r\ntemplate<class T> T coating_len(vector<pair<T, int>> v) {\r\n\tsort(all(v));\r\n\tT ans = 0;\r\n\r\n\tint p = 0;\r\n\tfori(v.size()) {\r\n\t\tif (p)ans += v[i].first - v[i - 1].first;\r\n\t\tp -= v[i].second;\r\n\t}\r\n\r\n\tre ans;\r\n}\r\n\r\n\r\n#ifdef LOCAL_BOBER\r\n#define __lg(n) __not_lg(n)\r\n#define asdasdasfasd ifstream fl(\"sample.io\")\r\n#define ffast_io ios::sync_with_stdio(false);\\\r\n\t\t\t\t cout.tie(nullptr)\r\n#define cin fl\r\n#define __int128 ll\r\n#else\r\n#define asdasdasfasd //freopen(\"input.txt\", \"r\", stdin);\\\r\n\t\t\t\t\t freopen(\"output.txt\", \"w\", stdout);\r\n#define ffast_io ios::sync_with_stdio(false);\\\r\n\t\t\t\t cout.tie(nullptr); cin.tie(nullptr)\r\n#define tvq 100000\r\n#endif\r\n\r\ntemplate<class T> T fast_pow(T n, ll p) { if (p == 1) re n; if (p % 2) re n* fast_pow(n, p - 1); re fast_pow(n * n, p / 2); }\r\ntemplate<class T> T mod_fast_pow(T n, T p, T m) { if (p == 0) re(T)1; if (p % 2 == 1) re n* mod_fast_pow(n, p - 1, m) % m; re mod_fast_pow(n * n % m, p / 2, m); }\r\ntemplate<class T> T gcd(T a, T b) { if (!a)re b; re gcd(b % a, a); }\r\ntemplate<class T> void umax(T& a, T b) { a = max(a, b); }\r\ntemplate<class T> void umin(T& a, T b) { a = min(a, b); }\r\ntemplate<class T> istream& operator >> (istream& o, vector<T>& x) { for (auto& el : x) o >> el; re o; }\r\ntemplate<class T, class U> istream& operator >> (istream& o, pair<T, U>& x) { o >> x.first >> x.second; re o; }\r\ntemplate<class T> istream& operator >> (istream& o, pair<T, T>& x) { o >> x.first >> x.second; re o; }\r\ntemplate<class T, class U> pair<T, U> operator-(pair<T, U> a, pair<T, U> b) { return { a.first - b.first, a.second - b.second }; }\r\ntemplate<class T, class U> pair<T, U> operator+(pair<T, U> a, pair<T, U> b) { return { a.first + b.first, a.second + b.second }; }\r\ntemplate<class T> vector<T> operator+(vector<T> a, vector<T> b) { fori(a.size())a[i] += b[i]; re a; }\r\ntemplate<class T> vector<T> operator-(vector<T> a, vector<T> b) { fori(a.size())a[i] -= b[i]; re a; }\r\ntemplate<class T> string to_bin(T n) { string s = \"\"; while (n) { s = to_string(n % 2) + s; n >>= 1; } re s; }\r\ntemplate<class T> string fixed_to_bin(T n, ll q) { string s = \"\";  fori(q) { s = to_string(n % 2) + s; n >>= 1; } re s; }\r\nll from_bin(string s) { ll m = 0; fori(s.size()) { m = (m * 2) + s[i] - '0'; } re m; }\r\ntemplate<class T> int cnt_bit(T n) { int cnt = 0; while (n) { cnt += n % 2; n >>= 1; }re cnt; }\r\nmt19937 rd(7833);\r\n\r\n/*\r\n\t___        __              __   ______          __        _____ __             __          __  __\r\n   /   | _____/ /___  ______ _/ /  / ____/___  ____/ /__     / ___// /_____ ______/ /______   / / / /__  ________\r\n  / /| |/ ___/ __/ / / / __ `/ /  / /   / __ \\/ __  / _ \\    \\__ \\/ __/ __ `/ ___/ __/ ___/  / /_/ / _ \\/ ___/ _ \\\r\n / ___ / /__/ /_/ /_/ / /_/ / /  / /___/ /_/ / /_/ /  __/   ___/ / /_/ /_/ / /  / /_(__  )  / __  /  __/ /  /  __/\r\n/_/  |_\\___/\\__/\\__,_/\\__,_/_/   \\____/\\____/\\__,_/\\___/   /____/\\__/\\__,_/_/   \\__/____/  /_/ /_/\\___/_/   \\___/\r\n\r\n*///coating_len\r\n\r\nconst int MAXN = 1e5 + 100;\r\nconst ll INF = 1e9;\r\n\r\nll s, t, n;\r\n\r\nstruct edge {\r\n\tll a, b, cap, flow;\r\n};\r\n\r\nvec<edge> e;\r\nvec<int> g[MAXN];\r\nint d[MAXN], ptr[MAXN], q[MAXN];\r\n\r\nvoid add_edge(int a, int b, ll cap) {\r\n\t//cout << a << \" \" << b << \" \" << cap << \"\\n\";\r\n\tg[a].push_back(e.size());\r\n\te.push_back({ a, b, cap, 0 });\r\n\tg[b].push_back(e.size());\r\n\te.push_back({ b, a, 0, 0 });\r\n}\r\n\r\nvoid add_tripedge(int a, int b, ll l, ll r) {\r\n\tadd_edge(s, b, l);\r\n\tadd_edge(a, b, r - l);\r\n\tadd_edge(a, t, l);\r\n}\r\n\r\nint mX[4] = { 0, 1, 0, -1 };\r\nint mY[4] = { 1, 0, -1, 0 };\r\n\r\nbool bfs() {\r\n\tint qh = 0, qt = 0;\r\n\tq[qt++] = s;\r\n\tmemset(d, -1, n * sizeof d[0]);\r\n\td[s] = 0;\r\n\twhile (qh < qt && d[t] == -1) {\r\n\t\tint v = q[qh++];\r\n\t\tfor (size_t i = 0; i < g[v].size(); ++i) {\r\n\t\t\tint id = g[v][i],\r\n\t\t\t\tto = e[id].b;\r\n\t\t\tif (d[to] == -1 && e[id].flow < e[id].cap) {\r\n\t\t\t\tq[qt++] = to;\r\n\t\t\t\td[to] = d[v] + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn d[t] != -1;\r\n}\r\n\r\nint dfs(int v, ll flow) {\r\n\tif (!flow)  return 0;\r\n\tif (v == t)  return flow;\r\n\tfor (; ptr[v] < (int)g[v].size(); ++ptr[v]) {\r\n\t\tint id = g[v][ptr[v]],\r\n\t\t\tto = e[id].b;\r\n\t\tif (d[to] != d[v] + 1)  continue;\r\n\t\tint pushed = dfs(to, min(flow, e[id].cap - e[id].flow));\r\n\t\tif (pushed) {\r\n\t\t\te[id].flow += pushed;\r\n\t\t\te[id ^ 1].flow -= pushed;\r\n\t\t\treturn pushed;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nint dinic() {\r\n\tint flow = 0;\r\n\tfor (;;) {\r\n\t\tif (!bfs())  break;\r\n\t\tmemset(ptr, 0, n * sizeof ptr[0]);\r\n\t\twhile (int pushed = dfs(s, INF))\r\n\t\t\tflow += pushed;\r\n\t}\r\n\treturn flow;\r\n}\r\n\r\npair<int, int> get_cord(ll n, ll m) {\r\n\tre{ n / m, n % m };\r\n}\r\n\r\nint main() {\r\n\tasdasdasfasd; ffast_io;\r\n\r\n\tint t; cin >> t;\r\n\twhile (t--) {\r\n\t\tll n, m; cin >> n >> m;\r\n\t\t::s = n * m;\r\n\t\t::t = n * m + 3;\r\n\t\t::n = m * n + 4;\r\n\t\tll s = n * m + 1, t = n * m + 2;\r\n\t\tvec<vec<ll>> v(n + 2, vec<ll>(m + 2, 1e10));\r\n\r\n\t\tfori(n) {\r\n\t\t\tforj(m) {\r\n\t\t\t\tcin >> v[i + 1][j + 1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//cout << \"1\";\r\n\t\tfori(n * m + 100)\r\n\t\t\tg[i].clear();\r\n\t\te.clear();\r\n\r\n\t\tll need = 0;\r\n\r\n\t\t//cout << \"1\";\r\n\t\tfori(n) {\r\n\t\t\tforj(m) {\r\n\t\t\t\t//cout << i << \" \" << j << \"\\n\";\r\n\t\t\t\t++i; ++j;\r\n\t\t\t\tbool ok = 0;\r\n\r\n\t\t\t\trep(k, 4) {\r\n\t\t\t\t\tll nX = mX[k] + i, nY = mY[k] + j;\r\n\r\n\t\t\t\t\tif (v[nX][nY] < v[i][j])ok = 1;\r\n\t\t\t\t\telse if(v[nX][nY] == v[i][j]) {\r\n\t\t\t\t\t\tif ((i + j) % 2 == 0) {\r\n\t\t\t\t\t\t\tadd_edge((i - 1) * m + j - 1, (nX - 1) * m + nY - 1, 1);\r\n\t\t\t\t\t\t\t//cout << i << \" \" << j << \" \" << nX << \" \" << nY << \"\\n\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//else {\r\n\t\t\t\t\t\t//\tadd_edge((nX - 1) * m + nY - 1, (i - 1) * m + j - 1, 1);\r\n\t\t\t\t\t\t//\tcout << i << \" \" << j << \" \" << nX << \" \" << nY << \"\\n\";\r\n\t\t\t\t\t\t//}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!ok) {\r\n\t\t\t\t\tif ((i + j) % 2 == 0)\r\n\t\t\t\t\t\tadd_tripedge(s, (i - 1) * m + j - 1, 1, 1);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tadd_tripedge((i - 1) * m + j - 1, t, 1, 1);\r\n\t\t\t\t\t//cout << i << ' ' << j << \"\\n\";\r\n\t\t\t\t\tneed++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif ((i + j) % 2 == 0)\r\n\t\t\t\t\t\tadd_edge(s, (i - 1) * m + j - 1, 1);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tadd_edge((i - 1) * m + j - 1, t, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t--i; --j;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//cout << \"1\";\r\n\t\tadd_edge(t, s, 1e9);\r\n\r\n\t\tll ans = dinic();\r\n\t\t//cout << need << \" \" << ans << '\\n';\r\n\r\n\t\tif (need != ans) {\r\n\t\t\tcout << \"NO\\n\";\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvec<ll> tv = { s, t, ::s, ::t };\r\n\t\tvec<vec<ll>> ans1(n, vec<ll>(m, -1));\r\n\t\tvec<vec<char>> ans2(n, vec<char>(m));\r\n\t\tfor (auto i : e) {\r\n\t\t\tif (i.flow <= 0 || count(all(tv), i.a) != 0 || count(all(tv), i.b) != 0)continue;\r\n\r\n\t\t\tpair<int, int> a = get_cord(i.a, m);\r\n\t\t\tpair<int, int> b = get_cord(i.b, m);\r\n\r\n\t\t\tif (a.first - b.first == 1) {\r\n\t\t\t\tans2[a.first][a.second] = 'U';\r\n\t\t\t\tans2[b.first][b.second] = 'D';\r\n\t\t\t}\r\n\t\t\telse if (a.first - b.first == -1) {\r\n\t\t\t\tans2[a.first][a.second] = 'D';\r\n\t\t\t\tans2[b.first][b.second] = 'U';\r\n\t\t\t}\r\n\t\t\telse if (a.second - b.second == 1) {\r\n\t\t\t\tans2[a.first][a.second] = 'L';\r\n\t\t\t\tans2[b.first][b.second] = 'R';\r\n\t\t\t}\r\n\t\t\telse if (a.second - b.second == -1) {\r\n\t\t\t\tans2[a.first][a.second] = 'R';\r\n\t\t\t\tans2[b.first][b.second] = 'L';\r\n\t\t\t}\r\n\r\n\t\t\tans1[a.first][a.second] = v[a.first + 1][a.second + 1] / 2;\r\n\t\t\tans1[b.first][b.second] = (v[b.first + 1][b.second + 1] + 1) / 2;\r\n\t\t}\r\n\r\n\t\tfori(n) {\r\n\t\t\tforj(m) {\r\n\t\t\t\tif (ans1[i][j] != -1)continue;\r\n\r\n\t\t\t\t++i; ++j;\r\n\t\t\t\t\r\n\t\t\t\trep(k, 4) {\r\n\t\t\t\t\tll nX = mX[k] + i, nY = mY[k] + j;\r\n\r\n\t\t\t\t\tif (v[nX][nY] < v[i][j]) {\r\n\t\t\t\t\t\tif (nX - i == 1) {\r\n\t\t\t\t\t\t\tans2[i - 1][j - 1] = 'D';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (nX - i == -1) {\r\n\t\t\t\t\t\t\tans2[i - 1][j - 1] = 'U';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (nY - j == 1) {\r\n\t\t\t\t\t\t\tans2[i - 1][j - 1] = 'R';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (nY - j == -1) {\r\n\t\t\t\t\t\t\tans2[i - 1][j - 1] = 'L';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tans1[i - 1][j - 1] = v[i][j] - v[nX][nY];\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t--i; --j;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcout << \"YES\\n\";\r\n\t\tfori(n)\r\n\t\t\tforj(m)\r\n\t\t\tcout << ans1[i][j] << \" \\n\"[j == m - 1];\r\n\t\tfori(n)\r\n\t\t\tforj(m)\r\n\t\t\tcout << ans2[i][j] << \" \\n\"[j == m - 1];\r\n\t}\r\n}\r\n\r\n// n == 1"
}