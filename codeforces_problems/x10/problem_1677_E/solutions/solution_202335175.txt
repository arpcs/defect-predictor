{
    "id": 202335175,
    "contestId": 1677,
    "creationTimeSeconds": 1681629690,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1677,
        "index": "E",
        "name": "Tokitsukaze and Beautiful Subsegments",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2900,
        "tags": [
            "data structures"
        ]
    },
    "author": {
        "contestId": 1677,
        "members": [
            {
                "handle": "hyforces"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1652020500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 27648000,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define N 100100\r\n#define int long long\r\nvector<int>primes;\r\nint isc[N+100];\r\n\r\nvoid linearsieve(){\r\n    isc[1]=true;\r\n    for(int a=2;a<=N;++a){\r\n        if(!isc[a]){primes.push_back(a);isc[a]=a;}\r\n        for(int b=0;b<primes.size()&&primes[b]*a<=N;++b){\r\n            isc[primes[b]*a]=primes[b];\r\n            if(!(a%primes[b])){break;}\r\n        }\r\n    }\r\n}\r\nint cn1,cn2a,cn2b,cn3a,cn3b;\r\nstruct lseg{\r\n#define S (4*N)\r\n    struct Lazy{\r\n        int fb,lb;\r\n        int fa,la;\r\n        Lazy(){fb=lb=-1,fa=la=0;}\r\n        Lazy(int v,int t):fb(v),fa(t),lb(-1),la(0){}\r\n    };\r\n   struct Node{\r\n       int b,c;//v=bt+c\r\n       Lazy l;\r\n       friend Node operator+(const Node&x,const Node&y){\r\n           return {x.b+y.b,x.c+y.c,Lazy()};\r\n       }\r\n       void pull(const Node&par){\r\n           const Lazy&lp=par.l;\r\n           if(!~l.fb){\r\n               ++cn1;\r\n               l=lp; // Case 1: Current Node has no lazy to merge with\r\n           }\r\n           else if(!~l.lb){ // Case 2: Current Node has lazy but only one\r\n               if(l.fb==lp.fb){ //Case 2a: Parent Node's set operation just redoes the last operation of current\r\n                   ++cn2a;\r\n                   l.lb=lp.lb;\r\n                   l.la=lp.la;\r\n               }\r\n               else{ // Case 2b: Parent Node's set operation does something new\r\n                   ++cn2b;\r\n                   l.lb=((~lp.lb)?lp.lb:lp.fb);\r\n                   assert(l.la==0);\r\n                   l.la=lp.fa-((~lp.lb)?lp.la:0);\r\n               }\r\n           }\r\n           else{ // Case 3: Current Node has full lazy operation\r\n               if(l.lb==lp.fb){ // Case 3a: Current Node last operation overlaps with Parent Node first operation\r\n                   ++cn3a;\r\n                   l.la+=lp.la*((lp.fb==l.fb)?1:-1);\r\n                   l.lb=((~lp.lb)?lp.lb:lp.fb);\r\n               }\r\n               else{ // Case 4b: Current Node last operation doesn't overlap with Parent Node first operation\r\n                   ++cn3b;\r\n                   l.la+=(lp.fa-((~lp.lb)?lp.la:0))*((lp.fb!=l.fb)?1:-1);\r\n                   l.lb=((~lp.lb)?lp.lb:lp.fb);\r\n               }\r\n           }\r\n       }\r\n       void set_tag(int v,int t){\r\n           l=Lazy(v,t);\r\n       }\r\n       void absorb(int len){\r\n           c+=l.fa*(b-l.fb*len);\r\n           b=len*l.fb;\r\n           if(~l.lb){\r\n               c+=len*l.la*((l.fa)?1:-1);\r\n               b=len*l.lb;\r\n           }\r\n       }\r\n       void clear_lazy(){\r\n           l=Lazy();\r\n       }\r\n   }seg[S];\r\n   void push(int lo,int hi,int node){\r\n       if(!~seg[node].l.fb)return;\r\n       seg[node].absorb(hi-lo+1);\r\n       if(lo!=hi){\r\n           seg[2*node+1].pull(seg[node]);\r\n           seg[2*node+2].pull(seg[node]);\r\n       }\r\n       seg[node].clear_lazy();\r\n   }\r\n   void update(int l,int r,int v,int t,int lo,int hi,int node){\r\n       push(lo,hi,node);\r\n       if(r<lo||hi<l)return;\r\n       if(l<=lo&&hi<=r){\r\n           seg[node].set_tag(v,t);\r\n           push(lo,hi,node);\r\n           return;\r\n       }\r\n       int mid=(lo+hi)/2;\r\n       update(l,r,v,t,lo,mid,2*node+1);\r\n       update(l,r,v,t,mid+1,hi,2*node+2);\r\n       seg[node]=seg[2*node+1]+seg[2*node+2];\r\n   }\r\n   int query(int l,int r,int t,int lo,int hi,int node){\r\n       push(lo,hi,node);\r\n       if(r<lo||hi<l)return 0;\r\n       if(l<=lo&&hi<=r)return seg[node].b*t+seg[node].c;\r\n       int mid=(lo+hi)/2;\r\n       return query(l,r,t,lo,mid,2*node+1)+query(l,r,t,mid+1,hi,2*node+2);\r\n   }\r\n#undef S\r\n}pv;\r\nint n,q;\r\nint arr[N];\r\nvector<pair<int,int>>lq[N];\r\nint ans[N];\r\nstack<int>stmx;\r\nint pid[N];\r\nint rev[N];\r\nbool is[N];\r\nint lst[N];//last time updated...\r\nvector<pair<int,int>>pf;\r\nint ga=0,gi=0,gv=0;\r\nint ind[N];\r\nvoid dfs(int i,int rv=1){\r\n    if(i==pf.size()){\r\n        if(rev[rv]<=gi&&rev[gv/rv]<=gi&&rv*rv!=gv){\r\n            ga=max(ga,min(rev[rv],rev[gv/rv]));\r\n        }\r\n        return;\r\n    }\r\n    for(int a=0;a<=pf[i].second;++a,rv*=pf[i].first){\r\n        dfs(i+1,rv);\r\n    }\r\n}\r\nvoid en(int x){\r\n    pf.clear();\r\n    vector<int>fac;\r\n    while(x>1){\r\n        fac.push_back(isc[x]);\r\n        x/=isc[x];\r\n    }\r\n    sort(fac.begin(),fac.end());\r\n    for(auto a:fac){\r\n        if(!pf.empty()&&pf.back().first==a){\r\n            pf.back().second++;\r\n        }\r\n        else{\r\n            pf.push_back({a,1});\r\n        }\r\n    }\r\n    dfs(0);\r\n}\r\nsigned main(){\r\n    linearsieve();\r\n    cin>>n>>q;\r\n    for(int a=0;a<n;++a){cin>>arr[a];rev[arr[a]]=a;}\r\n    for(int a=0;a<=n;++a){\r\n        lst[a]=arr[a];\r\n    }\r\n    memset(ind,-1,sizeof(ind));\r\n    for(int a=0;a<q;++a){\r\n        int l,r;cin>>l>>r;\r\n        lq[r-1].push_back({l-1,a});\r\n    }\r\n    for(int a=0;a<n;++a){\r\n        while(!stmx.empty()&&arr[stmx.top()]<arr[a]){\r\n            is[stmx.top()]=false;\r\n            stmx.pop();\r\n        }\r\n        pid[a]=(stmx.empty()?-1:stmx.top());\r\n        stmx.push(a);is[a]=true;\r\n        ga=-1,gv=arr[a],gi=a;\r\n        en(arr[a]);\r\n        ind[a]=ga;\r\n        if(ga>=pid[a]+1)\r\n            pv.update(pid[a]+1,ga,1,a,0,n-1,0);\r\n        if(ga<a)\r\n            pv.update(max(pid[a]+1,ga+1),a,0,a,0,n-1,0);\r\n        for(int b=2*arr[a];b<=n;b+=arr[a])if(is[rev[b]]){\r\n            if(arr[a]*arr[a]==b)continue;\r\n            int ni=min(rev[b],(rev[b/arr[a]]>a?-1:rev[b/arr[a]]));\r\n            if(max(pid[rev[b]]+1,ind[rev[b]]+1)<=ni){\r\n                pv.update(max(pid[rev[b]]+1,ind[rev[b]]+1),ni,1,a,0,n-1,0);\r\n                ind[rev[b]]=ni;\r\n            }\r\n        }\r\n        for(auto b:lq[a]){\r\n            ans[b.second]=pv.query(b.first,a,a+1,0,n-1,0);\r\n        }\r\n    }\r\n    for(int a=0;a<q;++a)cout<<ans[a]<<endl;\r\n    //cout<<cn1<<\" \"<<cn2a<<\" \"<<cn2b<<\" \"<<cn3a<<\" \"<<cn3b<<endl;\r\n}\r\n\r\n/*\r\n10 2\r\n6 1 3 2 5 8 4 10 7 9\r\n1 4\r\n2 4\r\n\r\n5 1\r\n4 5 1 3 2\r\n2 5\r\n\r\n4 10\r\n3 4 1 2\r\n1 1\r\n1 4\r\n2 3\r\n1 4\r\n3 3\r\n2 4\r\n2 2\r\n3 3\r\n2 3\r\n3 4\r\n\r\n3 1\r\n2 3 1\r\n2 3\r\n\r\n36 4\r\n28 8 2 3 20 18 32 16 25 33 5 23 21 22 27 1 34 31 15 36 24 6 13 17 11 4 26 29 35 10 9 14 12 30 19 7\r\n23 32\r\n23 34\r\n23 33\r\n23 36\r\n\r\n */"
}