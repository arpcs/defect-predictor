{
    "id": 229963686,
    "contestId": 903,
    "creationTimeSeconds": 1698387382,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 903,
        "index": "D",
        "name": "Almost Difference",
        "type": "PROGRAMMING",
        "rating": 2200,
        "tags": [
            "data structures",
            "math"
        ]
    },
    "author": {
        "contestId": 903,
        "members": [
            {
                "handle": "_priyanshu_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1513091100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 45,
    "timeConsumedMillis": 624,
    "memoryConsumedBytes": 28160000,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\ntemplate <typename T>\r\nusing o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate <typename T>\r\nusing o_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n// member functions :\r\n// 1. order_of_key(k) : number of elements strictly lesser than k\r\n// 2. find_by_order(k) : k-th element in the set\r\ntemplate <class key, class value, class cmp = std::less<key>>\r\nusing o_map = __gnu_pbds::tree<key, value, cmp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\r\n\r\nusing i64 = long long;\r\nconst i64 Mod = 1000000007;\r\nconst i64 MOD = 998244353;\r\nconst i64 Inf = 1E18;\r\nconst int dx[] = {0,  0, 1, -1, -1, -1,  1, 1};\r\nconst int dy[] = {1, -1, 0,  0, -1,  1, -1, 1};\r\n\r\n//FOR unordered_map<int,int,custom_hash> TO AVOID FALTU TLE'S COZ OF ANTIHASHES.\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n    \r\ntemplate <typename T>\r\nT roundup(T a, T b) {\r\n    return(a / b + ((a ^ b) > 0 && a % b));\r\n}\r\n\r\ntemplate <typename T>\r\nT choose(T n, T r) {\r\n    if(n < r) return 0LL; \r\n    T res = 1;\r\n    for(T e = 0 ; e < r ; e ++) {\r\n        res = res * (n - e);\r\n        res = res / (e + 1); \r\n    }\r\n    return res;\r\n}\r\n\r\ntemplate <typename T>\r\nbool expotwo(T n) {\r\n    T val = (n & (n - 1));\r\n    if(val == 0LL) return true; \r\n    return false;\r\n}\r\n\r\ntemplate <typename T>\r\nT modexpo(T b, T e, T mod) {\r\n    T ans = 1;\r\n    while(e) {\r\n        if(e & 1) ans = ((ans % mod) * (b % mod)) % mod;\r\n        b = ((b % mod) * (b % mod)) % mod;\r\n        e >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\ntemplate <typename T>\r\nT expo(T b, T e) {\r\n    T ans = 1;\r\n    while(e) {\r\n        if(e & 1) ans = ans * b;\r\n        b = b * b;\r\n        e >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\ntemplate <typename T>\r\nbool eprime(T n) {\r\n    if(n < 2) return false;\r\n    for(T e = 2; e * e <= n; e ++) {\r\n        if(n % e == 0) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\ntemplate <typename T>\r\nbool eparity(T x, T y) {\r\n    return !((x & 1) ^ (y & 1));\r\n}\r\n\r\ntemplate <typename T>\r\nstring number_to_string(T number) {\r\n    string res = \"\";\r\n    while(number) res += (char) ((number % 10) + '0'), number /= 10;\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n\r\ntemplate <typename T, typename U> \r\nU string_to_number(T s, U flag) {\r\n    // flag = 0 :: integer\r\n    // flag = 0LL :: long long\r\n    U res = 0;\r\n    for(int i = 0; s[i] != '\\0'; i ++) {\r\n        res *= static_cast<U>(10);\r\n        res += (s[i] - '0');\r\n    }\r\n    return res;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid amax(T& a, T b) { \r\n    a = max(a, b);\r\n}\r\n\r\ntemplate <typename T>\r\nvoid amin(T& a, T b) {\r\n    a = min(a, b);\r\n}\r\n\r\ntemplate <typename T>\r\nvoid add(T& a, T b, T M) {\r\n    a = ((a % M) + (b % M)) % M;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid mul(T& a, T b, T M) {\r\n    a = ((a % M) * (b % M)) % M;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid sub(T& a, T b, T M) {\r\n    a = (a - b + M) % M;\r\n}\r\n\r\n\r\n/* ------------------------------------------ lessgo -------------------------------------------------*/\r\n\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n\r\ntemplate <typename T , class F = function<T(const T&, const T&)>>\r\nclass Segtree {\r\n    public :\r\n        int n;\r\n        vector<T> seg;\r\n        vector<T> v;\r\n        F func;\r\n \r\n        Segtree(const vector<T> &a, const F& f) : func(f) {\r\n            n = a.size();\r\n            v.resize(n);\r\n            seg.resize(4 * n + 5);\r\n            v = a;\r\n        }\r\n \r\n        void build(int d, int s, int e) {\r\n            if(s == e) {\r\n                seg[d] = v[s]; return;\r\n            }\r\n            int mid = (s + e) >> 1;\r\n            build(2 * d + 1, s, mid);\r\n            build(2 * d + 2, mid + 1, e);\r\n            seg[d] = func(seg[2 * d + 1], seg[2 * d + 2]);\r\n \r\n        }\r\n \r\n        void update(int d, int s, int e, int I, T val) {\r\n            if(s == e) {\r\n                seg[d] = val; return;\r\n            }\r\n            int mid = (s + e) >> 1;\r\n            if(I <= mid) update(2 * d + 1, s, mid, I, val);\r\n            else update(2 * d + 2, mid + 1, e, I, val);\r\n            seg[d] = func(seg[2 * d + 1], seg[2 * d + 2]);\r\n \r\n        }\r\n        \r\n        void Update(int I, T val) {\r\n            return update(0, 0, n - 1, I, val);\r\n        }\r\n \r\n         \r\n        T query(int d, int  s, int e, int L, int R, T ret) {\r\n            // no overlap\r\n            // ret = 0 :: sum query\r\n            // ret = 1E18 :: min query\r\n            // ret = -1E18 :: max query\r\n            if(R < s || e < L) return ret;\r\n            // complete overlap\r\n            if(s >= L && e <= R) return seg[d];\r\n            // partial overlap\r\n            int mid = (s + e) >> 1;\r\n            T Left = query(2 * d + 1, s, mid, L, R, ret);\r\n            T Right = query(2 * d + 2, mid + 1, e, L, R, ret);\r\n            return func(Left, Right);\r\n        }\r\n        \r\n        T Query(int L, int R, T ret) {\r\n            return query(0, 0, n - 1, L, R, ret);\r\n        }\r\n};\r\n\r\nvoid Solution()\r\n{\r\n    \r\n    int n; cin >> n;\r\n    vector <int> v(n);\r\n    for(auto &x : v) cin >> x;\r\n    map <int, int> mp;\r\n    int timer = 2;\r\n    for(auto &x : v) mp[x] ++;\r\n    for(auto &x : mp) x.second = timer ++;\r\n    vector <i64> temp(timer + 5);\r\n    Segtree <i64> count(temp, [&](i64 a, i64 b) {\r\n        return a + b;\r\n    });\r\n    Segtree <i64> summ(temp, [&](i64 a, i64 b) {\r\n        return a + b;\r\n    });\r\n    count.build(0, 0, timer + 4);\r\n    summ.build(0, 0, timer + 4);\r\n\r\n    auto get = [&](int x, int f) -> int {\r\n        if(f) {\r\n            auto ub = mp.lower_bound(x);\r\n            if(ub != mp.begin()) {\r\n                ub --;\r\n                if(abs(ub -> first - x) == 1) {\r\n                    if(ub == mp.begin()) return 0;\r\n                    ub --;\r\n                    return ub -> second;\r\n                }\r\n                return ub -> second;\r\n            }\r\n            return 0;\r\n        }\r\n        else {\r\n            auto ub = mp.upper_bound(x);\r\n            if(ub != mp.end()) {\r\n                if(abs(ub -> first - x) == 1) {\r\n                    ub ++;\r\n                    if(ub == mp.end()) return timer + 4;\r\n                    return ub -> second;\r\n                }\r\n                return ub -> second;\r\n            }\r\n            return timer + 4;\r\n        }\r\n    };\r\n\r\n    long double ans = 0;\r\n    for(auto &x : v) {\r\n        int grt = get(x, 0);\r\n        int sml = get(x, 1);\r\n        i64 chote = count.Query(0, sml, 0LL);\r\n        i64 chote_sum = summ.Query(0, sml, 0LL);\r\n        i64 bde = count.Query(grt, timer + 4, 0LL);\r\n        i64 bde_sum = summ.Query(grt, timer + 4, 0LL);\r\n        i64 cur = x;\r\n        ans += chote * cur - chote_sum + bde * cur - bde_sum;\r\n        count.Update(mp[x], count.Query(mp[x], mp[x], 0LL) + 1);\r\n        summ.Update(mp[x], summ.Query(mp[x], mp[x], 0LL) + x);\r\n    }\r\n    cout << fixed << setprecision(0) << ans << '\\n';\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);   \r\n    cout.tie(NULL);\r\n    int Test_case = 1;  // cin >> Test_case;\r\n    \r\n    while(Test_case --) Solution();\r\n    \r\n}\r\n"
}