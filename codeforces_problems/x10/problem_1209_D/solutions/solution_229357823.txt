{
    "id": 229357823,
    "contestId": 1209,
    "creationTimeSeconds": 1698023983,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1209,
        "index": "D",
        "name": "Cow and Snacks",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "dfs and similar",
            "dsu",
            "graphs"
        ]
    },
    "author": {
        "contestId": 1209,
        "members": [
            {
                "handle": "e-sens"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1568466300
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 30,
    "timeConsumedMillis": 373,
    "memoryConsumedBytes": 67686400,
    "source": "import math\r\nimport sys\r\nfrom bisect import bisect_left,bisect_right\r\nfrom collections import defaultdict as dd\r\nfrom collections import deque, Counter\r\nfrom heapq import heappop,heappush,heapify,merge\r\nfrom itertools import permutations, accumulate, product\r\nfrom math import gcd,sqrt,ceil\r\ntoBin=lambda x:bin(x).replace(\"0b\",\"\")\r\nI=lambda:map(int,input().split())\r\ninf=float(\"inf\");DIRS=[[1,0],[-1,0],[0,1],[0,-1]];CHARS=\"abcdefghijklmnopqrstuvwxyz\";MOD=10**9+7;\r\ninput=sys.stdin.readline\r\n# Uncomment below to use comb and change FACTMX\r\n# FACTMX=9*10**6;fact=[1]*FACTMX\r\n# for i in range(2, FACTMX):fact[i]=((fact[i-1]*i)%MOD)\r\n# def comb(n,r):return (fact[n]*pow(fact[r]*fact[n-r],MOD-2,MOD))%MOD if n>=r else 0\r\n\r\nclass UnionFind:\r\n    def __init__(self,n):self.p=list(range(n));self.rank=[0]*n\r\n    def find(self,x):\r\n        if x!=self.p[x]:self.p[x]=self.find(self.p[x])\r\n        return self.p[x]\r\n    def union(self,x, y):\r\n        px,py=self.find(x),self.find(y)\r\n        if px==py:return 0\r\n        self.p[py]=px\r\n        # self.rank[px]+=self.rank[py]\r\n        return 1\r\nclass SegmentTree:\r\n    def __init__(self,n,func):\r\n        self.n=n;self.tree=[0]*2*self.n;self.func=func\r\n    def query(self, l, r):\r\n        l+=self.n;r+=self.n;ans=1#change\r\n        while l<r:\r\n            if l&1:ans=self.func(ans,self.tree[l]);l+=1\r\n            if r&1:r-=1;ans=self.func(ans,self.tree[r])\r\n            l>>=1;r>>=1\r\n        return ans\r\n    def update(self,i,val):\r\n        i+=self.n;self.tree[i]=val\r\n        while i>1:i>>=1;self.tree[i]=self.func(self.tree[i*2],self.tree[i*2+1])\r\nclass RangeQueue:\r\n    def __init__(self,fn=min):\r\n        self.inbox=[];self.outbox=[];self.fn=fn\r\n    def mn(self,st):return st[-1][1] if st else 0 #gcd or max= or sum0,mi=inf\r\n    def get_fn(self):return self.fn(self.mn(self.inbox),self.mn(self.outbox))\r\n    def sz(self):return len(self.inbox)+len(self.outbox)\r\n    def push(self,v):\r\n        if not self.inbox:self.inbox.append((v,v))\r\n        else:self.inbox.append((v,self.fn(v,self.mn(self.inbox))))\r\n    def pop(self):\r\n        if len(self.outbox)==0:self.shift()\r\n        self.outbox.pop()\r\n    def shift(self):\r\n        while self.inbox:\r\n            self.outbox.append((self.inbox[-1][0],self.fn(self.inbox[-1][0],self.mn(self.outbox))))\r\n            self.inbox.pop()\r\n_A=True\r\nclass SortedList:\r\n    def __init__(A,iterable=[],_load=200):B=_load;C=sorted(iterable);A._len=E=len(C);A._load=B;A._lists=D=[C[A:A+B]for A in range(0,E,B)];A._list_lens=[len(A)for A in D];A._mins=[A[0]for A in D];A._fen_tree=[];A._rebuild=_A\r\n    def _fen_build(B):\r\n        B._fen_tree[:]=B._list_lens;C=B._fen_tree\r\n        for A in range(len(C)):\r\n            if A|A+1<len(C):C[A|A+1]+=C[A]\r\n        B._rebuild=False\r\n    def _fen_update(B,index,value):\r\n        A=index\r\n        if not B._rebuild:\r\n            C=B._fen_tree\r\n            while A<len(C):C[A]+=value;A|=A+1\r\n    def _fen_query(B,end):\r\n        A=end\r\n        if B._rebuild:B._fen_build()\r\n        D=B._fen_tree;C=0\r\n        while A:C+=D[A-1];A&=A-1\r\n        return C\r\n    def _fen_findkth(A,k):\r\n        B=A._list_lens\r\n        if k<B[0]:return 0,k\r\n        if k>=A._len-B[-1]:return len(B)-1,k+B[-1]-A._len\r\n        if A._rebuild:A._fen_build()\r\n        C=A._fen_tree;D=-1\r\n        for F in reversed(range(len(C).bit_length())):\r\n            E=D+(1<<F)\r\n            if E<len(C)and k>=C[E]:D=E;k-=C[D]\r\n        return D+1,k\r\n    def _delete(B,pos,idx):\r\n        A=pos;C=B._lists;E=B._mins;D=B._list_lens;B._len-=1;B._fen_update(A,-1);del C[A][idx];D[A]-=1\r\n        if D[A]:E[A]=C[A][0]\r\n        else:del C[A];del D[A];del E[A];B._rebuild=_A\r\n    def _loc_left(E,value):\r\n        F=value\r\n        if not E._len:return 0,0\r\n        G=E._lists;I=E._mins;B,A=-1,len(G)-1\r\n        while B+1<A:\r\n            C=B+A>>1\r\n            if F<=I[C]:A=C\r\n            else:B=C\r\n        if A and F<=G[A-1][-1]:A-=1\r\n        H=G[A];B,D=-1,len(H)\r\n        while B+1<D:\r\n            C=B+D>>1\r\n            if F<=H[C]:D=C\r\n            else:B=C\r\n        return A,D\r\n    def _loc_right(D,value):\r\n        G=value\r\n        if not D._len:return 0,0\r\n        H=D._lists;J=D._mins;B,E=0,len(H)\r\n        while B+1<E:\r\n            A=B+E>>1\r\n            if G<J[A]:E=A\r\n            else:B=A\r\n        I=H[B];F,C=-1,len(I)\r\n        while F+1<C:\r\n            A=F+C>>1\r\n            if G<I[A]:C=A\r\n            else:F=A\r\n        return B,C\r\n    def add(A,value):\r\n        E=value;C=A._load;F=A._lists;H=A._mins;G=A._list_lens;A._len+=1\r\n        if F:\r\n            B,I=A._loc_right(E);A._fen_update(B,1);D=F[B];D.insert(I,E);G[B]+=1;H[B]=D[0]\r\n            if C+C<len(D):F.insert(B+1,D[C:]);G.insert(B+1,len(D)-C);H.insert(B+1,D[C]);G[B]=C;del D[C:];A._rebuild=_A\r\n        else:F.append([E]);H.append(E);G.append(1);A._rebuild=_A\r\n    def discard(A,value):\r\n        C=value;D=A._lists\r\n        if D:\r\n            E,B=A._loc_right(C)\r\n            if B and D[E][B-1]==C:A._delete(E,B-1)\r\n    def remove(A,value):\r\n        B=value;C=A._len;A.discard(B)\r\n        if C==A._len:raise ValueError('{0!r} not in list'.format(B))\r\n    def pop(A,index=-1):B=index;C,D=A._fen_findkth(A._len+B if B<0 else B);E=A._lists[C][D];A._delete(C,D);return E\r\n    def bisect_left(A,value):B,C=A._loc_left(value);return A._fen_query(B)+C\r\n    def bisect_right(A,value):B,C=A._loc_right(value);return A._fen_query(B)+C\r\n    def count(A,value):B=value;return A.bisect_right(B)-A.bisect_left(B)\r\n    def __len__(A):return A._len\r\n    def __getitem__(A,index):B=index;C,D=A._fen_findkth(A._len+B if B<0 else B);return A._lists[C][D]\r\n    def __delitem__(A,index):B=index;C,D=A._fen_findkth(A._len+B if B<0 else B);A._delete(C,D)\r\n    def __contains__(B,value):\r\n        C=value;A=B._lists\r\n        if A:D,E=B._loc_left(C);return E<len(A[D])and A[D][E]==C\r\n        return False\r\n    def __iter__(A):return(B for A in A._lists for B in A)\r\n    def __reversed__(A):return(B for A in reversed(A._lists)for B in reversed(A))\r\n    def __repr__(A):return'SortedList({0})'.format(list(A))\r\ndef bit_count(x):x=(x&0x55555555)+((x>>1)&0x55555555);x=(x&0x33333333)+((x>>2)&0x33333333);x=(x&0x0f0f0f0f)+((x>>4)&0x0f0f0f0f);x=(x&0x00ff00ff)+((x>>8)&0x00ff00ff);x=(x&0x0000ffff)+((x>>16)&0x0000ffff);return x\r\ndef query(x,y):\r\n    print(\"?\",x,y,flush=True)\r\n    return int(input())\r\n\r\n# DP,BS,Greedy,Graph,Contribution,IE,Game,Reverse simulation,Trie,Bits,SortedList,Caching.\r\ndef main():\r\n    \"\"\"\r\n    14m-if we have a snack thats only wanted by 1 person, that person should have it.\r\n    meaning we can create relationships between snacks and people. people->snacks.\r\n    we try to get snacks that only have a indegree of 1. if none exists, then\r\n    we have to pick one.\r\n    20m-does greedily doing simulation work?\r\n    24m-realized each guest will just ALL of their favorite.\r\n    greedy graph? 26m if redundant edge is made, increment..start WA at T4\r\n    union find...34m after looking at TC. runtime error on T31 (not good)\r\n    \"\"\"\r\n    n,k=I();v=set();res=0;uf=UnionFind(n)\r\n    for _ in range(k):\r\n        x,y=I();x-=1;y-=1\r\n        if uf.find(x)==uf.find(y):res+=1\r\n        else:uf.union(x,y)\r\n    print(res)\r\n\r\n\r\n###### Comment this out for Python 3 + imports at the top #####\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n###### Uncomment this for Python 3 (for deep recursion) ######\r\n# from sys import stdin, setrecursionlimit\r\n# import threading\r\n# from collections import defaultdict as dd\r\n# from collections import deque\r\n# setrecursionlimit(5*10**5);input=stdin.buffer.readline;I=lambda:map(int,input().split())\r\n# threading.stack_size(10**8)\r\n# t = threading.Thread(target=main)\r\n# t.start()\r\n# t.join()"
}