{
    "id": 181405369,
    "contestId": 226,
    "creationTimeSeconds": 1668770020,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 226,
        "index": "D",
        "name": "The table",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2100,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 226,
        "members": [
            {
                "handle": "vjudge1"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1348500600
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 7,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "\n\n#include<bits/stdc++.h>\n//#define endl \"\\n\"\n#define FF ios_base::sync_with_stdio(0);cin.tie(0)\n#define binary(value, size) cout << bitset<size>(value) << '\\n'\n#define Tp template<class T>\n#define Tpp template<typename T>\n#define Tppp template<typename T1,typename T2>\n#define eps 1e-9\n#define pf printf\n#define sf scanf\n#define clr(arr,val) memset((arr),val,(sizeof(arr)))\n#define rep(i,a,b) for(long long int i=a;i<b;i++)\n#define repb(i,a,b) for(long long int i=a;i>=b;i--)\n#define all(v) (v).begin(),(v).end()\n#define asort(a) sort(a.begin(),a.end())\n#define arev(a) reverse(a.begin(),a.end())\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define pbb pop_back\n#define mp make_pair\n#define V vector\n#define P pair\n#define M map\n#define mt make_tuple\n#define BS(v,x) binary_search(v.begin(),v.end(),x) //return true /false\n#define LB(v,x) lower_bound(v.begin(),v.end(),x)-v.begin()//found and that value and not found than greater value pos\n#define UB(v,x) upper_bound(v.begin(),v.end(),x)-v.begin() //found and greater value pos && not found also greater pos\n#define sma(c) towlower(c)\n#define rt(x) sqrt(x)\n#define cap(c) towupper(c)\n#define sq(a) ((a)*(a))\n#define cube(a) ((a)*(a)*(a))\n#define MAX(v) *max_element(v.begin(),v.end())//max element of the vector\n#define MIN(v) *min_element(v.begin(),v.end())//min element of the vector\n#define SZ(x) long long int(x.size())\n#define N 10000000\n#define Ceil(n) (long long int)ceil(n)\n#define Floor(n) (long long int)floor(n)\n#define deb(x) std::cout << #x << \" = \" << x << std::endl;\n#define deb2(x,y)  std::cout << #x << \" = \" << x << \", \"; std::cout << #y << \" = \" << y << std::endl;\n#define deb3(x,y,z) std::cout << #x << \" = \" << x << \", \"; std::cout << #y << \" = \" << y << \", \"; std::cout << #z << \" = \" << z << std::endl;\n#define deb4(x,y,z,r) std::cout << #x << \" = \" << x << \", \"; std::cout << #y << \" = \" << y << \", \"; std::cout << #z << \" = \" << z << \", \";std::cout << #r << \" = \" << r << std::endl;\n#define out(ans) cout<<ans<<endl\n#define outs(ans) cout<<ans<<\" \"<<endl\n#define FI freopen (\"in.txt\", \"r\", stdin)\n#define FO freopen (\"out.txt\", \"w\", stdout)\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef double lf;\ntypedef long double llf;\ntypedef unsigned long long int ull;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > v2d;\ntypedef vector<vector<vector<ll> > > v3d;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef map<ll,ll> mpl;\ntypedef priority_queue<ll> heap;// heap max value from top\ntypedef priority_queue<ll, vector<ll>, greater<ll> > revheap;//heap min value from top\n\n//vector<vector<int>> grid(n, vector<int>(n, 0)); // 2D Array inititalize with 0 n*n size\n\nbool isLetter(char c) { return (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z');}\nbool isUpperCase(char c) {return c >= 'A' and c <= 'Z';}\nbool isLowerCase(char c) {    return c >= 'a' and c <= 'z';}\nbool isDigit(char c) {return c >= '0' and c <= '9';}\nbool isVowel(char c) {return c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u';}\nbool isConsonant(char c){    return !isVowel(c); }\n\nTp void Debug(T v) { for(int i=0; i<(int)v.size(); i++)  cout << v[i] <<\" \";   cout<<endl;  }\n\nTp void Input(T &v){ for(int i=0; i<(int)v.size(); i++) cin >> v[i]; }\n\nTp string toString(T n) { ostringstream ost; ost << n; ost.flush(); return ost.str();}\n\n//string to int\nstring intTobinary(int x) { std::string binary = std::bitset<32>(x).to_string(); return binary;}\nstring lltobinary(ll x)  {std::string binary = std::bitset<64>(x).to_string(); return binary;}\nll toNumber(string s) {stringstream aa(s);ll mm;aa>>mm; return mm;}\nll binaryToDecimal(string n) { string num = n; ll dec_value = 0; ll base = 1; ll len = num.length(); for (int i = len - 1; i >= 0; i--) { if (num[i] == '1') dec_value += base; base = base * 2; } return dec_value;}\n\n//nCr\n\nTpp T nCr(T n, T r) { if(r > n - r) r = n - r; int  ans = 1,i;for(i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; }  return ans; }\n\n//Binary exponentiation (a^p)\nll Binpow(ll a, ll p){ ll ret = 1; while(p>0){ if(p & 1)ret = (1LL * ret * a) ; a = (1LL * a * a) ; p >>= 1LL; } return ret; }\n\n//BigMod (a^p)%mod\ntemplate<typename A, typename P>\nll BigMod(A a, P p, ll mod){ ll ret = 1; while(p){ if(p & 1)ret = ( (ret%mod) * (a%mod)) % mod; a = ( (a%mod) * (a%mod)) % mod; p >>= 1LL; } return ret; }\n\n//Base (value,base)\nTpp T toBase(T n, T base){T ret= 0LL; while(n){ ret += n % base; ret *= 10LL;  n /= base;} return ret;}\n\n// Divisor\n\nTpp  vector<T> Divisor(T value){ vector<T> v; for(int i = 1LL; i * i <= value; ++i){\n    if(value % i == 0){v.push_back(i); if(i * i != value) v.push_back(value / i);} } return v;}\n\n//Primes\n\nTpp  bool prime(T n){  if(n==2) return 1; if (n % 2 == 0) return 0; for (T i = 3; i*i <= n; i += 2){if (n % i == 0) return 0;}return 1;}\n\n//Sieve\nTpp  void Sieve(T n){bool prime[n+1];memset(prime, true, sizeof(prime));\n     for (T p=2; p*p<=n; p++){ if (prime[p] == true){\n            for (int i=p*p; i<=n; i += p) prime[i] = false;} } }\n//Math\n\nTpp   ll sum(std::vector<T> &v){return std::accumulate(all(v), 0);}\nTpp   T minval(std::vector<T> &v){return *std::min_element(all(v));}\nTpp   T maxval(std::vector<T> &v){return *std::max_element(all(v));}\nTpp   void make_unique(std::vector<T> &v){v.resize(unique(all(v)) - v.begin());}\nTpp   void make_unique_sorted(std::vector<T> &v){asort(v);v.resize(unique(all(v)) - v.begin());}\nTpp   int lowerBound(std::vector<T> &v, T x){return v.back() < x ? -1 : lower_bound(all(v), x) - v.begin();}\nTpp   int upperBound(std::vector<T> &v, T x){return v.back() < x ? -1 : upper_bound(all(v), x) - v.begin();}\n\ndouble startTime = clock();\nvoid showCurrentTime(){ printf(\"%.6lf\\n\", ((double)clock() - startTime) / CLOCKS_PER_SEC);}\n\n\n\n//Bit Hacks\nll MakeOneBit(ll decimalvalue, int pos)  { return (decimalvalue | (1 << pos));}    //make pos bit of value 1\nll MakeZeroBit(ll decimalvalue, int pos) {return (decimalvalue & ~(1 << pos));}    //make pos of value bit 0\nll FlipBit(ll decimalvalue, int pos)     { return (decimalvalue ^ (1 << pos));}    //flip pos bit of value reverse\nbool CheckBit(ll decimalvalue, int pos) { return (decimalvalue & (1 << pos)); }\nint MSB(ll k)  { return ( 63 - __builtin_clzll(k));}    // leftmost set bit\nint LSB(ll k)  { return __builtin_ffs(k)-1 ;}    // right most set bit\nint Totalset(ll decimalvalue)  {return __builtin_popcountll(decimalvalue); }   //total 1 in value\n\nint Totolnotset(ll decimalvalue) { return MSB(decimalvalue) - Totalset(decimalvalue) + 1;}    //total 0 in value\nbool ispow2(int i) { return i&&(i&-i)==i; }\n\nll nC2(ll n) { return (n * (n - 1)) / 2;}\nll nc3(ll n){ return (n * (n - 1) * (n - 2)) / 6; }\nll arithsum(ll n, ll a = 1, ll d = 1){ return (n * (a + a + (n - 1) * d) ) / 2; }\nll LCM(ll a, ll b){return (a / __gcd(a, b) ) * b;}\nll OnetoNsum(ll n){return (n*(n+1))/2;}\nll longdivision(string s,ll a){ ll ans=0; ll temp=0; rep(i,0,s.length()){ temp=temp*10+(s[i]-'0');ans+=(temp/a);ans*=10;temp=temp%a;}return (ans/10);}\n\n\nconst long long int INF=LLONG_MAX;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst double PIby2=asin(1.0);\nconst int MOD = 1e9 + 7;\n\n//debug\nTppp void dvpll(vector<pair<T1,T2> > v) { for(ll i=0;i<v.size();i++){deb(i);deb(v[i].F);deb(v[i].S);cout<<endl;}}\nvoid dpos(vll v,ll pos){ cout<<pos<<\"=\"<<v[pos]<<endl; }\nTppp void dmap(map<T1,T2> m) {ll i=0;for(auto x:m) {deb(i);deb(x.F);deb(x.S);cout<<endl;i++;}}\nTpp void dset(set<T> s) {for(auto x:s) {deb(x);cout<<endl;}}\nTpp void dmset(multiset<T> s) {for(auto x:s) {deb(x);cout<<endl;}}\n\nTpp void dpqueue(priority_queue<T> pq) {while(!pq.empty()){deb(pq.top());pq.pop();}    }\nTpp void dstack(stack<T> st) {while(!st.empty()) {deb(st.top());st.pop();}}\nTpp void dqueue(queue<T> q) {while(!q.empty()){ deb(q.front());q.pop(); }}\n\nvoid dgraph(vector<ll> adj[],ll node){rep(i,0,node+1){deb(i);rep(j,0,adj[i].size()) {cout<<adj[i][j]<<\" \";}cout<<endl;}cout<<endl;}\n\nTpp void d1d(vector<T> v){for(ll i=0;i<v.size();i++){ cout<<v[i]<<\" \"; }cout<<endl;}\nTpp void d2d(vector<vector<T> >&v,ll n,ll m) {cout<<\"2d: \"<<endl;for(ll i=0;i<n;i++){for(ll j=0;j<m;j++){cout<<v[i][j]<<\" \";}cout<<endl;}}\nTpp void d3d(vector<vector<vector<T> > > &v,ll p,ll q,ll r){cout<<\"3d: \"<<endl;for(ll i=0; i<p; i++){for(ll j=0; j<q; j++){for(ll k=0; k<r; k++){cout<<\"v[i=\"<<i<<\"][j=\"<<j<<\"][k=\"<<k<<\"]=\";cout<<v[i][j][k]<<endl;}}}}\n\n\n\n//for debugging debfun1,fun2 etc\n\n\n\n\n//Input Output\n\nTpp void Rvec(vector<T> &v,ll n){rep(i,0,n){T d;cin>>d;v.pb(d);}}\nTppp void Rvpll(vector<pair<T1,T2> > &v,ll n){rep(i,0,n){T1 a;T2 b;cin>>a>>b;v.pb(mp(a,b));} }\nvoid Rgraph(vector<ll> adj[],ll edge ,ll indexbase ,bool directed ){rep(i,0,edge){ll a,b;cin>>a>>b;if(indexbase==0){a--;b--;}adj[a].pb(b);if(directed==0){adj[b].pb(a);}}}\n\n\n\n//Graph\n\n//DFS\n\n//vll adj[1000001];bool vis[1000001];void init(ll n){rep(i,0,n+1){adj[i].clear();vis[i]=false;}}\n//stack<ll> st;void DFS(ll val){vis[val]=1;st.push(val);for(auto child:adj[val]){if(!vis[child]) DFS(child);}}\n\n//BFS\n\n//vll adj[1000001];bool vis[1000001];\n//ll level[1000001];ll parent[1000001];\n//void BFS(ll source){ queue<ll> q; q.push(source);level[source]=0;vis[source]=1;while(!q.empty()){ll par=q.front();q.pop();for(auto child:adj[val]){if(!vis[child]){vis[child]=1;level[child]=level[val]+1;parent[child]=par;q.push(child);}}}}\n\n\n\n//set/multiset.insert() map/vector/list.push_back()/queue/stack.push()/list.push_front()\n//vec/list.pop_back()/stack/queue/pqueue.pop()\n//pq.top()/queue.front()/stack.top()\n//cout<<fixed<<setprecision(decimal)<<value<<endl;\n/*\nNCR dp\n\nll NCR[1010][1010];\nconst ll MM=10056;ll funNCR(ll n){NCR[1][1]=1;NCR[1][0]=1;for(ll i=2;i<=n;i++){NCR[i][0]=1;NCR[i][i]=1;for(ll j=1;j<=i-1;j++){NCR[i][j]=(NCR[i-1][j-1]%MM+NCR[i-1][j]%MM)%MM;NCR[i][j]%=MM;}}}\n\n\n*/\n//const int dx[]={1,0,-1,0};const int dy[]={0,1,0,-1}; //4 direction\n//const int dx[] = {1, -1, 0, 0, -1, -1, 1, 1}; const int dy[] = {0, 0, 1, -1, -1, 1, -1, 1};// 8 direction\n//const int dx[]={2,1,-1,-2,-2,-1,1,2};const int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n//const int dx[]={2,1,-1,-2,-1,1};const int dy[]={0,1,1,0,-1,-1}; //Hexagonal Direction\n//-------------------------------------------------------------------------------------------------------------------\n//adj matrix cant be done dynamically adj[tot+1] cant be done\n//vector<vector<int>> grid(n, vector<int>(n, 0)); 2D Array\n//s.erase(remove(s.begin(),s.end(),' '),s.end());//INF=LONG_LONG_MAX;\n//vector<vector<int> > adj(maxx+2)      //adjacency matrix\n//adj set vector<vector<int> > adj(maxx) //adjacency set\n//adj queue adj priority queue etc\n// to flip bit do 1 xor\n/*\nV<ll> v1;\n    v1.pb(7);v1.pb(1);v1.pb(18);\n    d1d(v1);\n    deb(MAX(v1));\n    deb(MIN(v1));\n    asort(v1);\n    d1d(v1);\n    deb(LB(v1,18));\n    deb(UB(v1,18));\n    deb3(v1[0],v1[1],v1[2]);\n    deb(v1[0]);\n\n    heap h1;h1.push(1);h1.push(2);\n    deb(h1.top());h1.pop();\n    revheap h2;h2.push(1);h2.push(2);\n    deb(h2.top());h2.pop();\n    deb(SUM(v1));\n*/\n\n\nint main()\n{\n    FF;\n\n    ll n,m;cin>>n>>m;\n    V<V<ll> > arr(n+5,vll(n+5,0));\n    rep(i,0,n)\n    {\n        rep(j,0,m)\n        {\n            cin>>arr[i][j];\n        }\n    }\n\n    ll turn=1;\n\n    vll row(n+5,0);\n    vll col(m+5,0);\n    while(1)\n    {\n\n\n        if(turn&1)\n        {\n            for(ll i=0; i<n; i++)\n            {\n                ll sum=0;\n                for(ll j=0; j<m; j++)\n                {\n                    sum+=arr[i][j];\n                }\n\n                if(sum<0)\n                {\n                    row[i]++;\n                    for(ll j=0;j<m;j++)\n                    {\n                        ll val=-arr[i][j];\n                        arr[i][j]=val;\n                    }\n\n                }\n                else continue;\n\n            }\n            turn++;\n            //continue;\n        }\n        else\n        {\n            for(ll j=0;j<m;j++)\n            {\n                ll sum=0;\n                for(ll i=0;i<n;i++)\n                {\n                    sum+=arr[i][j];\n                }\n\n                if(sum<0)\n                {\n                    col[j]++;\n                    for(ll i=0;i<n;i++)\n                    {\n                        ll val=-arr[i][j];\n                        arr[i][j]=val;\n                    }\n                }\n                else continue;\n            }\n            turn++;\n        }\n\n        bool f=0;\n        for(ll i=0;i<n;i++)\n        {\n             ll sum=0;\n             for(ll j=0;j<m;j++)\n             {\n                 sum+=arr[i][j];\n             }\n             if(sum<0) f=1;\n        }\n\n        for(ll j=0;j<m;j++)\n        {\n            ll sum=0;\n            for(ll i=0;i<n;i++)\n            {\n                sum+=arr[i][j];\n            }\n            if(sum<0) f=1;\n        }\n\n        if(f) continue;\n        else break;\n\n\n    }\n    //d1d(row);d1d(col);\n    ll c1=0,c2=0;vll ans1,ans2;\n    for(ll i=0;i<n;i++)\n    {\n        if(row[i]&1) {c1++;ans1.pb(i+1);}\n    }\n    for(ll j=0;j<m;j++)\n    {\n        if(col[j]&1)\n        {\n            c2++;ans2.pb(j+1);\n        }\n    }\n    cout<<c1<<\" \";d1d(ans1);\n    cout<<c2<<\" \";d1d(ans2);\n\n\n\n\n\n\n\n\n\n\n\n\n    return 0;\n}\n\n\n\n\n  \t\t      \t \t\t\t\t \t \t   \t \t\t   \t"
}