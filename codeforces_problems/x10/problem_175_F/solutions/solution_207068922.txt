{
    "id": 207068922,
    "contestId": 175,
    "creationTimeSeconds": 1684947252,
    "relativeTimeSeconds": 12,
    "problem": {
        "contestId": 175,
        "index": "F",
        "name": "Gnomes of Might and Magic",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3000,
        "tags": [
            "data structures",
            "graphs",
            "implementation",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 175,
        "members": [
            {
                "handle": "Sputnik1234"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1684947240
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 190,
    "timeConsumedMillis": 624,
    "memoryConsumedBytes": 78540800,
    "source": "#include <bits/stdc++.h>\r\n#define N 400010\r\nusing namespace std;\r\ninline int read()\r\n{\r\nint x=0,f=1; char ch=getchar();\r\nwhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\r\nwhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\r\nreturn x*f;\r\n}\r\nint n,m,A[N],len[N],sign[N],Rt[N],q;\r\nint pos[N][2],DEL[N<<2],TAG[N<<2];\r\nint flower[N<<2],c[N<<2][2],tot,cnt;\r\nchar comd[10];\r\nvector<int> V[N];\r\nstruct node\r\n{\r\nint len,sum;\r\n};\r\nnode tree[N<<2][2];\r\ninline bool operator <(const node a,const node b)\r\n{\r\nreturn a.sum==b.sum? a.len<b.len:a.sum<b.sum;\r\n}\r\ninline bool operator >(const node a,const node b)\r\n{\r\nreturn a.sum==b.sum? a.len>b.len:a.sum>b.sum;\r\n}\r\ninline node operator +(const node a,const node b)\r\n{\r\nreturn (node){a.len+b.len,a.sum+b.sum};\r\n}\r\ninline void deal_(int rt)\r\n{\r\nif(!rt) return ;\r\nflower[rt]=0;\r\nTAG[rt]=1;\r\n}\r\ninline void deal(int rt)\r\n{\r\ntree[rt][0].sum=0; DEL[rt]=1;\r\nif(tree[rt][0].len!=1&&sign[rt])\r\ndeal_(Rt[sign[rt]]);\r\nif(tree[rt][1]<tree[rt][0])\r\nswap(tree[rt][1],tree[rt][0]);\r\n}\r\ninline void pushdown_(int rt)\r\n{\r\nif(TAG[rt])\r\n{\r\ndeal_(c[rt][0]);\r\ndeal_(c[rt][1]);\r\nTAG[rt]=0;\r\n}\r\n}\r\ninline void pushdown(int rt)\r\n{\r\nif(DEL[rt])\r\n{\r\ndeal(rt<<1);\r\ndeal(rt<<1|1);\r\nDEL[rt]=0;\r\n}\r\n}\r\ninline void pushup_(int rt)\r\n{\r\nflower[rt]=flower[c[rt][0]]+flower[c[rt][1]];\r\n}\r\ninline void pushup(int rt)\r\n{\r\ntree[rt][0]=tree[rt<<1][0]+tree[rt<<1|1][0];\r\ntree[rt][1]=tree[rt<<1][1]+tree[rt<<1|1][1];\r\n}\r\ninline void built(int l,int r,int rt)\r\n{\r\nif(l==r)\r\n{\r\ntree[rt][0].len=1; sign[rt]=l;\r\ntree[rt][1].len=len[l]-1;\r\ntree[rt][0].sum=tree[rt][1].sum=0;\r\nreturn ;\r\n}\r\nint mid=(l+r)>>1;\r\nbuilt(l,mid,rt<<1); built(mid+1,r,rt<<1|1);\r\npushup(rt);\r\n}\r\ninline void updata_(int x,int y,int l,int r,int &rt)\r\n{\r\nif(!rt) rt=++tot;\r\nif(l==r)\r\n{\r\nflower[rt]+=y; return ;\r\n}\r\nint mid=(l+r)>>1; pushdown_(rt);\r\nif(mid>=x) updata_(x,y,l,mid,c[rt][0]);\r\nif(mid<x) updata_(x,y,mid+1,r,c[rt][1]);\r\npushup_(rt);\r\n}\r\ninline void updata(int x,int z,int y,int l,int r,int rt)\r\n{\r\nif(l==r)\r\n{\r\nif(z==tree[rt][0].len)\r\ntree[rt][0].sum+=y;\r\nelse tree[rt][1].sum+=y;\r\nif(tree[rt][0]>tree[rt][1])\r\nswap(tree[rt][1],tree[rt][0]);\r\nreturn ;\r\n}\r\nint mid=(l+r)>>1; pushdown(rt);\r\nif(mid>=x) updata(x,z,y,l,mid,rt<<1);\r\nif(mid<x) updata(x,z,y,mid+1,r,rt<<1|1);\r\npushup(rt);\r\n}\r\ninline node query_(int L,int R,int l,int r,int &rt)\r\n{\r\nif(L>R) return (node){0,0};\r\nif(!rt) rt=++tot;\r\nif(L<=l&&r<=R) return (node){r-l+1,flower[rt]};\r\nint mid=(l+r)>>1; pushdown_(rt);\r\nif(mid<L) return query_(L,R,mid+1,r,c[rt][1]);\r\nif(mid>=R) return query_(L,R,l,mid,c[rt][0]);\r\nreturn query_(L,R,l,mid,c[rt][0])+query_(L,R,mid+1,r,c[rt][1]);\r\n}\r\ninline node query(int L,int R,int l,int r,int rt)\r\n{\r\nif(L>R) return (node){0,0};\r\nif(L<=l&&r<=R) return tree[rt][0];\r\nint mid=(l+r)>>1; pushdown(rt);\r\nif(mid<L) return query(L,R,mid+1,r,rt<<1|1);\r\nif(mid>=R) return query(L,R,l,mid,rt<<1);\r\nreturn query(L,R,l,mid,rt<<1)+query(L,R,mid+1,r,rt<<1|1);\r\n}\r\ninline void delet(int L,int R,int l,int r,int rt)\r\n{\r\nif(L>R) return ;\r\nif(L<=l&&r<=R)\r\n{\r\ndeal(rt); return ;\r\n}\r\nint mid=(l+r)>>1; pushdown(rt);\r\nif(mid>=L) delet(L,R,l,mid,rt<<1);\r\nif(mid<R) delet(L,R,mid+1,r,rt<<1|1);\r\npushup(rt);\r\n}\r\ninline void delet_(int L,int R,int l,int r,int rt,int tp)\r\n{\r\nif(L>R) return ;\r\nif(!rt) return ;\r\nif(L<=l&&r<=R)\r\n{\r\nupdata(tp,len[tp]-1,-flower[rt],1,n,1);\r\ndeal_(rt); return ;\r\n}\r\nint mid=(l+r)>>1; pushdown_(rt);\r\nif(mid>=L) delet_(L,R,l,mid,c[rt][0],tp);\r\nif(mid<R) delet_(L,R,mid+1,r,c[rt][1],tp);\r\npushup_(rt);\r\n}\r\nint p1,p2,p3,rev,u,v,px,py,bx,by;node Ans;\r\ninline int step3(int nw1,int p,int pp)\r\n{\r\nif(pp==0)\r\n{\r\nif(p==0) return V[pos[nw1][0]][1];\r\nif(p==1) return V[pos[nw1][0]][len[pos[nw1][0]]-1];\r\n}\r\nif(pp==1)\r\n{\r\nint pre=pos[nw1][0]==1? n:pos[nw1][0]-1;\r\nif(p==0) return V[pre][0];\r\nif(p==1) return V[pre][len[pre]-2];\r\n}\r\nreturn 0;\r\n}\r\ninline int step2(int nw1,int p,int pp)\r\n{\r\nif(p==0)\r\n{\r\nint pre=pos[nw1][0];\r\nnode x=query(pre,pre,1,n,1);\r\nif(x.len==1) nw1=V[pre][len[pre]-1];\r\nelse nw1=V[pre][1];\r\n}\r\nif(p==1)\r\n{\r\nint pre=pos[nw1][0]==1? n:pos[nw1][0]-1;\r\nnode x=query(pre,pre,1,n,1);\r\nif(x.len==1) nw1=V[pre][0];\r\nelse nw1=V[pre][len[pre]-2];\r\n}\r\nreturn nw1;\r\n}\r\ninline int step1(int nw1,int p,int pp)\r\n{\r\nif(p==0)\r\n{\r\nif(pos[nw1][1]==1&&pp==1)\r\n{\r\nint pre=pos[nw1][0]==1? n:pos[nw1][0]-1;\r\nnode x=query(pre,pre,1,n,1);\r\nif(x.len==1) nw1=V[pre][0];\r\nelse nw1=V[pre][len[pre]-2];\r\nreturn nw1;\r\n}\r\nif(pos[nw1][1]==1&&pp==0)\r\n{\r\nint pre=pos[nw1][0]==n? 1:pos[nw1][0]+1;\r\nreturn A[pre];\r\n}\r\nelse nw1=V[pos[nw1][0]][pos[nw1][1]-2];\r\n}\r\nelse nw1=V[pos[nw1][0]][pos[nw1][1]];\r\nreturn nw1;\r\n}\r\ninline void upgrade(node xx,int t1,int t2,int t3)\r\n{\r\nif(xx<Ans)\r\n{\r\nAns=xx;\r\np1=t1;p2=t2;p3=t3;\r\nreturn ;\r\n}\r\nif(xx>Ans) return ;\r\nint nw1=u,nw2=u,s1=p1,s2=p2,s3=p3;\r\nif(rev) s2^=1,t2^=1,swap(t1,t3),swap(s1,s3);\r\nif(t1!=s1)\r\n{\r\nnw1=step1(nw1,s1,s2);\r\nnw2=step1(nw2,t1,t2);\r\nif(nw1>nw2)\r\n{\r\nAns=xx;\r\nif(rev) p1=t3, p3=t1;\r\nelse p1=t1, p3=t3;\r\np2=t2^rev;\r\n}\r\nreturn ;\r\n}\r\nnw1=nw2= t1==1? V[pos[nw1][0]][len[pos[nw1][0]]-1]:V[pos[nw1][0]][0];\r\nif(t2!=s2)\r\n{\r\nnw1=step2(nw1,s2,s1);\r\nnw2=step2(nw2,t2,t1);\r\nif(nw1>nw2)\r\n{\r\nAns=xx;\r\nif(rev) p1=t3, p3=t1;\r\nelse p1=t1, p3=t3;\r\np2=t2^rev;\r\n}\r\nreturn ;\r\n}\r\nnw1=nw2= (t2==0? V[pos[v][0]][0]:V[pos[v][0]][len[pos[v][0]]-1]);\r\nnw1=step3(nw1,s3,s2);\r\nnw2=step3(nw2,t3,t2);\r\nif(nw1>nw2)\r\n{\r\nAns=xx;\r\nif(rev) p1=t3, p3=t1;\r\nelse p1=t1, p3=t3;\r\np2=t2^rev;\r\n}\r\nreturn ;\r\n}\r\ninline int Ask(int x,int y)\r\n{\r\n++cnt;\r\nu=x; v=y; rev=0;\r\nif(pos[x][0]>pos[y][0]) swap(x,y),rev=1;\r\nif(pos[x][0]==pos[y][0])\r\nif(pos[x][1]>pos[y][1]) swap(x,y),rev=1;\r\npx=pos[x][1],py=pos[y][1];\r\nbx=pos[x][0],by=pos[y][0];\r\nif(x==y) return 0;\r\nnode lx,rx,ly,ry,la,lb;\r\nla=query(bx,bx,1,n,1); lb=query(by,by,1,n,1);\r\nlx=query_(1,px-1,1,len[bx]-1,Rt[bx]);\r\nrx=query_(px,len[bx],1,len[bx]-1,Rt[bx]);\r\nly=query_(1,py-1,1,len[by]-1,Rt[by]);\r\nry=query_(py,len[by],1,len[by]-1,Rt[by]);\r\nAns=lx+query(bx,by-1,1,n,1)+ly;\r\np1=0; p2=0; p3=0;\r\nupgrade(lx+query(1,bx-1,1,n,1)+query(by,n,1,n,1)+ly,0,1,0);\r\nupgrade(lx+query(bx,by,1,n,1)+ry,0,0,1);\r\nupgrade(lx+query(1,bx-1,1,n,1)+query(by+1,n,1,n,1)+ry,0,1,1);\r\nupgrade(rx+query(bx+1,by-1,1,n,1)+ly,1,0,0);\r\nupgrade(rx+query(1,bx,1,n,1)+query(by,n,1,n,1)+ly,1,1,0);\r\nupgrade(rx+query(bx+1,by,1,n,1)+ry,1,0,1);\r\nupgrade(rx+query(1,bx,1,n,1)+query(by+1,n,1,n,1)+ry,1,1,1);\r\nif(bx==by) upgrade(query_(px,py-1,1,len[bx]-1,Rt[bx]),1,2,2);\r\nif(p1==0&&p2==0&&p3==0)\r\ndelet_(1,px-1,1,len[bx]-1,Rt[bx],bx),\r\ndelet(bx,by-1,1,n,1),\r\ndelet_(1,py-1,1,len[by]-1,Rt[by],by);\r\nif(p1==0&&p2==1&&p3==0)\r\ndelet_(1,px-1,1,len[bx]-1,Rt[bx],bx),\r\ndelet(1,bx-1,1,n,1),\r\ndelet(by,n,1,n,1),\r\ndelet_(1,py-1,1,len[by]-1,Rt[by],by);\r\nif(p1==0&&p2==0&&p3==1)\r\ndelet_(1,px-1,1,len[bx]-1,Rt[bx],bx),\r\ndelet(bx,by,1,n,1),\r\ndelet_(py,len[by],1,len[by]-1,Rt[by],by);\r\nif(p1==0&&p2==1&&p3==1)\r\ndelet_(1,px-1,1,len[bx]-1,Rt[bx],bx),\r\ndelet(1,bx-1,1,n,1),\r\ndelet(by+1,n,1,n,1),\r\ndelet_(py,len[by],1,len[by]-1,Rt[by],by);\r\nif(p1==1&&p2==0&&p3==0)\r\ndelet_(px,len[bx],1,len[bx]-1,Rt[bx],bx),\r\ndelet(bx+1,by-1,1,n,1),\r\ndelet_(1,py-1,1,len[by]-1,Rt[by],by);\r\nif(p1==1&&p2==1&&p3==0)\r\ndelet_(px,len[bx],1,len[bx]-1,Rt[bx],bx),\r\ndelet(1,bx,1,n,1),\r\ndelet(by,n,1,n,1),\r\ndelet_(1,py-1,1,len[by]-1,Rt[by],by);\r\nif(p1==1&&p2==0&&p3==1)\r\ndelet_(px,len[bx],1,len[bx]-1,Rt[bx],bx),\r\ndelet(bx+1,by,1,n,1),\r\ndelet_(py,len[by],1,len[by]-1,Rt[by],by);\r\nif(p1==1&&p2==1&&p3==1)\r\ndelet_(px,len[bx],1,len[bx]-1,Rt[bx],bx),\r\ndelet(1,bx,1,n,1),\r\ndelet(by+1,n,1,n,1),\r\ndelet_(py,len[by],1,len[by]-1,Rt[by],by);\r\nif(p1==1&&p2==2&&p3==2)\r\ndelet_(px,py-1,1,len[bx]-1,Rt[bx],bx);\r\nif(p1==2&&p2==2&&p3==1)\r\ndelet_(px,py-1,1,len[bx]-1,Rt[bx],bx);\r\nreturn Ans.sum;\r\n}\r\nint main()\r\n{\r\nm=read(); n=read();\r\nfor(int i=1;i<=n;i++)\r\nA[i]=read(),\r\npos[A[i]][0]=i,\r\npos[A[i]][1]=0;\r\nfor(int i=1;i<=n;i++)\r\n{\r\nlen[i]=read();\r\nfor(int j=1;j<=len[i];j++)\r\n{\r\nint k=read();\r\nV[i].push_back(k);\r\nif(j==len[i]) continue;\r\npos[k][0]=i; pos[k][1]=j;\r\n}\r\n}\r\nbuilt(1,n,1);\r\nq=read();\r\nfor(int i=1;i<=q;i++)\r\n{\r\nscanf(\"%s\",comd);\r\nint u=read(), v=read();\r\nif(comd[0]=='+')\r\n{\r\nif(pos[u][0]!=pos[v][0])\r\n{\r\nif(pos[u][0]>pos[v][0]) swap(u,v);\r\nif(pos[u][0]==1&&pos[v][0]==n) swap(u,v);\r\nif(pos[u][1]==len[pos[u][0]]-1)\r\n{\r\nupdata(pos[u][0],len[pos[u][0]]-1,1,1,n,1);\r\nupdata_(pos[u][1],1,1,len[pos[u][0]]-1,Rt[pos[u][0]]);\r\ncontinue;\r\n}\r\nupdata(pos[u][0],1,1,1,n,1);\r\n}\r\nelse\r\n{\r\nif(pos[u][1]>pos[v][1]) swap(u,v);\r\nupdata(pos[u][0],len[pos[u][0]]-1,1,1,n,1);\r\nupdata_(pos[u][1],1,1,len[pos[u][0]]-1,Rt[pos[u][0]]);\r\n}\r\n}\r\nif(comd[0]=='?') printf(\"%d\\n\",Ask(u,v));\r\n}\r\nreturn 0;\r\n}"
}