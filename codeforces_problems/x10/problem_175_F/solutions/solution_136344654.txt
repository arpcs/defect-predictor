{
    "id": 136344654,
    "contestId": 175,
    "creationTimeSeconds": 1637506878,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 175,
        "index": "F",
        "name": "Gnomes of Might and Magic",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 3000,
        "tags": [
            "data structures",
            "graphs",
            "implementation",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 175,
        "members": [
            {
                "handle": "casperwang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1334390400
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 190,
    "timeConsumedMillis": 1090,
    "memoryConsumedBytes": 15257600,
    "source": "#include <bits/stdc++.h>\r\n#define All(x) x.begin(), x.end()\r\n#define pb emplace_back\r\n#define pii pair<int,int>\r\n#define ff first\r\n#define ss second\r\n#define Lson now*2  , l, mid\r\n#define Rson now*2+1,mid+1,r\r\nusing namespace std;\r\n#define debug(args...) kout(\"[ \" + string(#args) + \" ]\", args)\r\nvoid kout() { cerr << endl; }\r\ntemplate <class T, class ...U> void kout(T a, U ...b) { cerr << a << ' ',kout(b...); }\r\ntemplate <class T> void pary(T L, T R) { while (L != R) cerr << *L << \" \\n\"[++L==R]; }\r\n\r\nconst int MAXN = 100000;\r\nconst int MAXE = 200000;\r\nint N, M, Q;\r\nint V[MAXN+1];\r\nint a, b, s, t;\r\nchar op;\r\nvector <int> ep[MAXN+1];\r\nint esze[MAXN+1], esum, pre_esze[MAXN+1];\r\nstruct {\r\n\tint sec, key;\r\n}\tidx[MAXN+1];\r\nint gval[MAXN+1];\r\n\r\nclass Subseg {\r\n\tprivate:\r\n\t\tint sum[MAXN*4+5];\r\n\t\tbool tag[MAXN*4+5];\r\n\t\tvoid pull(int now) {\r\n\t\t\tsum[now] = sum[now*2] + sum[now*2+1];\r\n\t\t}\r\n\t\tvoid push(int now, int len) {\r\n\t\t\tif (!tag[now]) return;\r\n\t\t\tsum[now] = 0;\r\n\t\t\tif (len > 1) {\r\n\t\t\t\ttag[now*2  ] = true;\r\n\t\t\t\ttag[now*2+1] = true;\r\n\t\t\t}\r\n\t\t\ttag[now] = false;\r\n\t\t}\r\n\tpublic:\r\n\t\tvoid mdy(int p, int now=1, int l=1, int r=esum) {\r\n\t\t\tpush(now, r-l+1);\r\n\t\t\tif (l == p && r == p) {\r\n\t\t\t\tsum[now]++;\r\n\t\t\t\treturn;\r\n\t\t\t} else if (l > p || r < p) return;\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tmdy(p, Lson);\r\n\t\t\tmdy(p, Rson);\r\n\t\t\tpull(now);\r\n\t\t}\r\n\t\tvoid clear(int cl, int cr, int now=1, int l=1, int r=esum) {\r\n\t\t\tpush(now, r-l+1);\r\n\t\t\tif (cl <= l && r <= cr) {\r\n\t\t\t\ttag[now] = true;\r\n\t\t\t\tpush(now, r-l+1);\r\n\t\t\t\treturn;\r\n\t\t\t} else if (l > cr || r < cl) return;\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tclear(cl, cr, Lson);\r\n\t\t\tclear(cl, cr, Rson);\r\n\t\t\tpull(now);\r\n\t\t}\r\n\t\tint qry(int ql, int qr, int now=1, int l=1, int r=esum) {\r\n\t\t\tpush(now, r-l+1);\r\n\t\t\tif (ql <= l && r <= qr) {\r\n\t\t\t\treturn sum[now];\r\n\t\t\t} else if (l > qr || r < ql) return 0;\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tint res = qry(ql, qr, Lson) + qry(ql, qr, Rson);\r\n\t\t\tpull(now);\r\n\t\t\treturn res;\r\n\t\t}\r\n} subseg;\r\n\r\nstruct Node {\r\n\tint sum, cnt, L, R;\r\n\tNode() {}\r\n\tNode(int s, int c, int l, int r) {\r\n\t\tsum = s, cnt = c, L = l, R = r;\r\n\t}\r\n\tbool operator < (const Node b) const {\r\n\t\treturn (sum != b.sum ? sum < b.sum : cnt < b.cnt);\r\n\t}\r\n\tNode operator + (const Node b) {\r\n\t\treturn Node(sum + b.sum, cnt + b.cnt, L, b.R);\r\n\t}\r\n};\r\n\r\nclass Seg {\r\n\tprivate:\r\n\t\tNode arr[MAXN*4+5];\r\n\t\tbool tag[MAXN*4+5];\r\n\t\tvoid pull(int now) {\r\n\t\t\tarr[now] = arr[now*2] + arr[now*2+1];\r\n\t\t}\r\n\t\tvoid update(int now, int l) {\r\n\t\t\tarr[now] = min(Node(gval[l], 1, V[l%M+1], V[l]), \r\n\t\t\t\t\tNode(subseg.qry(pre_esze[l-1]+1, pre_esze[l]), esze[l], ep[l][1], ep[l][esze[l]-1]));\r\n\t\t}\r\n\t\tvoid push(int now, int l, int r) {\r\n\t\t\tif (!tag[now]) return;\r\n\t\t\tarr[now].sum = 0;\r\n\t\t\tif (l != r) {\r\n\t\t\t\ttag[now*2  ] = true;\r\n\t\t\t\ttag[now*2+1] = true;\r\n\t\t\t} else {\r\n\t\t\t\tif (arr[now].cnt == 1) {\r\n\t\t\t\t\tgval[l] = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsubseg.clear(pre_esze[l-1]+1, pre_esze[l]);\r\n\t\t\t\t}\r\n\t\t\t\tupdate(now, l);\r\n\t\t\t}\r\n\t\t\ttag[now] = false;\r\n\t\t}\r\n\tpublic:\r\n\t\tvoid build(int now=1, int l=1, int r=M) {\r\n\t\t\tif (l == r) {\r\n\t\t\t\tarr[now] = Node(0, 1, V[l%M+1], V[l]);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tbuild(Lson);\r\n\t\t\tbuild(Rson);\r\n\t\t\tpull(now);\r\n\t\t}\r\n\t\tvoid mdy(int p, int i, int now=1, int l=1, int r=M) {\r\n\t\t\tpush(now, l, r);\r\n\t\t\tif (l == p && r == p) {\r\n\t\t\t\tif (i == -1) {\r\n\t\t\t\t\tgval[l]++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsubseg.mdy(pre_esze[l-1] + i);\r\n\t\t\t\t}\r\n\t\t\t\tupdate(now, l);\r\n\t\t\t\treturn;\r\n\t\t\t} else if (l > p || r < p) return;\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tmdy(p, i, Lson);\r\n\t\t\tmdy(p, i, Rson);\r\n\t\t\tpull(now);\r\n\t\t}\r\n\t\tvoid clear(int cl, int cr, int now=1, int l=1, int r=M) {\r\n\t\t\tpush(now, l, r);\r\n\t\t\tif (cl <= l && r <= cr) {\r\n\t\t\t\ttag[now] = true;\r\n\t\t\t\tpush(now, l, r);\r\n\t\t\t\treturn;\r\n\t\t\t} else if (l > cr || r < cl) return;\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tclear(cl, cr, Lson);\r\n\t\t\tclear(cl, cr, Rson);\r\n\t\t\tpull(now);\r\n\t\t}\r\n\t\tvoid check(int p, int now=1, int l=1, int r=M) {\r\n\t\t\tpush(now, l, r);\r\n\t\t\tif (l == p && r == p) {\r\n\t\t\t\tupdate(now, l);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tp <= mid ? check(p, Lson) : check(p, Rson);\r\n\t\t\tpull(now);\r\n\t\t}\r\n\t\tNode qry(int ql, int qr, int now=1, int l=1, int r=M) {\r\n\t\t\tpush(now, l, r);\r\n\t\t\tif (ql <= l && r <= qr) return arr[now];\r\n\t\t\tint mid = (l + r) / 2;\r\n\t\t\tNode res;\r\n\t\t\tif (qr <= mid)\r\n\t\t\t\tres = qry(ql, qr, Lson);\r\n\t\t\telse if (ql > mid)\r\n\t\t\t\tres = qry(ql, qr, Rson);\r\n\t\t\telse\r\n\t\t\t\tres = qry(ql, qr, Lson) + qry(ql, qr, Rson);\r\n\t\t\tpull(now);\r\n\t\t\treturn res;\r\n\t\t}\r\n} seg;\r\n\r\nclass Graph {\r\n\tprivate:\r\n\t\tint S, T;\r\n\t\tstruct Info {\r\n\t\t\tint sum, cnt;\r\n\t\t\tvector <int> path, nxts;\r\n\t\t\tInfo() {\r\n\t\t\t\tsum = -1;\r\n\t\t\t\tcnt = 0;\r\n\t\t\t\tpath.clear(), nxts.clear();\r\n\t\t\t}\r\n\t\t\tbool operator < (const Info b) {\r\n\t\t\t\tif (sum != b.sum) return sum < b.sum;\r\n\t\t\t\tif (cnt != b.cnt) return cnt < b.cnt;\r\n\t\t\t\tint i = 0, j = 0;\r\n\t\t\t\twhile (i < (int)nxts.size() && j < (int)b.nxts.size()) {\r\n\t\t\t\t\twhile (nxts[i] == -1) i++;\r\n\t\t\t\t\twhile (b.nxts[j] == -1) j++;\r\n\t\t\t\t\tif (nxts[i] != b.nxts[j])\r\n\t\t\t\t\t\treturn nxts[i] < b.nxts[j];\r\n\t\t\t\t\ti++, j++;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} cur, best;\r\n\t\tstruct Edge {\r\n\t\t\tint to, sum, cnt, nxt;\r\n\t\t\tEdge() {}\r\n\t\t\tEdge(int t) {\r\n\t\t\t\tto = t, sum = cnt = 0, nxt = -1;\r\n\t\t\t}\r\n\t\t};\r\n\t\tvector <Edge> graph[6];\r\n\t\tbool vis[6];\r\n\t\tvoid init() {\r\n\t\t\tS = s, T = t;\r\n\t\t\tfor (int i = 0; i < 6; i++) {\r\n\t\t\t\tgraph[i].clear();\r\n\t\t\t\tvis[i] = false;\r\n\t\t\t}\r\n\t\t\tcur = Info();\r\n\t\t\tbest = Info();\r\n\t\t}\r\n\t\tvoid init_pt(int s, int &sec, int &key) {\r\n\t\t\tif (s == 0) {\r\n\t\t\t\tsec = idx[S].sec, key = idx[S].key;\r\n\t\t\t} else if (s == 1) {\r\n\t\t\t\tsec = idx[S].sec, key = 1;\r\n\t\t\t} else if (s == 2) {\r\n\t\t\t\tsec = idx[S].sec % M + 1, key = 1;\r\n\t\t\t} else if (s == 3) {\r\n\t\t\t\tsec = idx[T].sec, key = 1;\r\n\t\t\t} else if (s == 4) {\r\n\t\t\t\tsec = idx[T].sec % M + 1, key = 1;\r\n\t\t\t} else if (s == 5) {\r\n\t\t\t\tsec = idx[T].sec, key = idx[T].key;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvoid make_edge(int s, int t) {\r\n\t\t\tint sec_s, key_s, sec_t, key_t;\r\n\t\t\tinit_pt(s, sec_s, key_s);\r\n\t\t\tinit_pt(t, sec_t, key_t);\r\n\t\t\tEdge e(t);\r\n\t\t\tif (sec_s == sec_t && key_s == key_t) {\r\n\t\t\t} else if (s == 0) {\r\n\t\t\t\tif (t == 1) {\r\n\t\t\t\t\tint res = subseg.qry(pre_esze[sec_s-1]+1, pre_esze[sec_s-1] + key_s-1);\r\n\t\t\t\t\te.sum = res, e.cnt = key_s - 1, e.nxt = ep[sec_s][key_s-2];\r\n\t\t\t\t} else if (t == 2) {\r\n\t\t\t\t\tint res = subseg.qry(pre_esze[sec_s-1] + key_s, pre_esze[sec_s]);\r\n\t\t\t\t\te.sum = res, e.cnt = esze[sec_s] - key_s + 1, e.nxt = ep[sec_s][key_s];\r\n\t\t\t\t} else if (t == 5) {\r\n\t\t\t\t\tint a = min(key_s, key_t), b = max(key_s, key_t);\r\n\t\t\t\t\tint res = subseg.qry(pre_esze[sec_s-1] + a, pre_esze[sec_s-1] + b - 1);\r\n\t\t\t\t\te.sum = res, e.cnt = b - a, e.nxt = ep[sec_s][key_s-1 + (key_s > key_t ? -1 : 1)];\r\n\t\t\t\t}\r\n\t\t\t} else if (t == 5) {\r\n\t\t\t\tif (s == 3) {\r\n\t\t\t\t\tint res = subseg.qry(pre_esze[sec_t-1]+1, pre_esze[sec_t-1] + key_t-1);\r\n\t\t\t\t\te.sum = res, e.cnt = key_t - 1, e.nxt = ep[sec_t][1];\r\n\t\t\t\t} else if (s == 4) {\r\n\t\t\t\t\tint res = subseg.qry(pre_esze[sec_t-1] + key_t, pre_esze[sec_t]);\r\n\t\t\t\t\te.sum = res, e.cnt = esze[sec_t] - key_t + 1, e.nxt = ep[sec_t][esze[sec_t]-1];\r\n\t\t\t\t}\r\n\t\t\t} else if (s < t && !(s == 1 && t >= 3)) {\r\n\t\t\t\tNode res;\r\n\t\t\t\tif (sec_s < sec_t) {\r\n\t\t\t\t\tres = seg.qry(sec_s, sec_t-1);\r\n\t\t\t\t} else if (sec_t == 1) {\r\n\t\t\t\t\tres = seg.qry(sec_s, M);\r\n\t\t\t\t} else if (sec_s > sec_t) {\r\n\t\t\t\t\tres = seg.qry(sec_s, M) + seg.qry(1, sec_t-1);\r\n\t\t\t\t}\r\n\t\t\t\te.sum = res.sum, e.cnt = res.cnt, e.nxt = res.L;\r\n\t\t\t} else if (s > t || (s == 1 && t >= 3)) {\r\n\t\t\t\tNode res;\r\n\t\t\t\tif (sec_s > sec_t) {\r\n\t\t\t\t\tres = seg.qry(sec_t, sec_s-1);\r\n\t\t\t\t} else if (sec_s == 1) {\r\n\t\t\t\t\tres = seg.qry(sec_t, M);\r\n\t\t\t\t} else if (sec_s < sec_t) {\r\n\t\t\t\t\tres = seg.qry(sec_t, M) + seg.qry(1, sec_s-1);\r\n\t\t\t\t}\r\n\t\t\t\te.sum = res.sum, e.cnt = res.cnt, e.nxt = res.R;\r\n\t\t\t}\r\n\t\t\tgraph[s].pb(e);\r\n\t\t}\r\n\t\tvoid build() {\r\n\t\t\tmake_edge(0, 1);\r\n\t\t\tmake_edge(0, 2);\r\n\t\t\tmake_edge(1, 2);\r\n\t\t\tmake_edge(1, 4);\r\n\t\t\tmake_edge(2, 1);\r\n\t\t\tmake_edge(2, 3);\r\n\t\t\tmake_edge(3, 4);\r\n\t\t\tmake_edge(3, 5);\r\n\t\t\tmake_edge(4, 3);\r\n\t\t\tmake_edge(4, 5);\r\n\t\t\tif (idx[s].sec == idx[t].sec) {\r\n\t\t\t\tmake_edge(0, 5);\r\n\t\t\t\tgraph[1].pb(Edge(3));\r\n\t\t\t\tgraph[2].pb(Edge(4));\r\n\t\t\t}\r\n\t\t\tcur.sum = 0;\r\n\t\t\tcur.path.pb(0);\r\n\t\t}\r\n\t\tvoid dfs(int now) {\r\n\t\t\tif (now == 5) {\r\n\t\t\t\tif (best.sum == -1 || cur < best) best = cur;\r\n\t\t\t}\r\n\t\t\tfor (auto [to, _sum, _cnt, nxt] : graph[now]) {\r\n\t\t\t\tif (vis[to]) continue;\r\n\t\t\t\tvis[to] = true;\r\n\t\t\t\tcur.sum += _sum;\r\n\t\t\t\tcur.cnt += _cnt;\r\n\t\t\t\tcur.path.pb(to);\r\n\t\t\t\tcur.nxts.pb(nxt);\r\n\t\t\t\tdfs(to);\r\n\t\t\t\tvis[to] = false;\r\n\t\t\t\tcur.sum -= _sum;\r\n\t\t\t\tcur.cnt -= _cnt;\r\n\t\t\t\tcur.path.pop_back();\r\n\t\t\t\tcur.nxts.pop_back();\r\n\t\t\t}\r\n\t\t}\r\n\t\tvoid clear() {\r\n\t\t\tfor (int i = 1; i < (int)best.path.size(); i++) {\r\n\t\t\t\tint s = best.path[i-1], t = best.path[i];\r\n\t\t\t\tint sec_s, key_s, sec_t, key_t;\r\n\t\t\t\tinit_pt(s, sec_s, key_s);\r\n\t\t\t\tinit_pt(t, sec_t, key_t);\r\n\t\t\t\tif (sec_s == sec_t && key_s == key_t) {\r\n\t\t\t\t} else if (s == 0) {\r\n\t\t\t\t\tif (t == 1) {\r\n\t\t\t\t\t\tsubseg.clear(pre_esze[sec_s-1]+1, pre_esze[sec_s-1] + key_s-1);\r\n\t\t\t\t\t\tseg.check(sec_s);\r\n\t\t\t\t\t} else if (t == 2) {\r\n\t\t\t\t\t\tsubseg.clear(pre_esze[sec_s-1] + key_s, pre_esze[sec_s]);\r\n\t\t\t\t\t\tseg.check(sec_s);\r\n\t\t\t\t\t} else if (t == 5) {\r\n\t\t\t\t\t\tint a = min(key_s, key_t), b = max(key_s, key_t);\r\n\t\t\t\t\t\tsubseg.clear(pre_esze[sec_s-1] + a, pre_esze[sec_s-1] + b-1);\r\n\t\t\t\t\t\tseg.check(sec_s);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (t == 5) {\r\n\t\t\t\t\tif (s == 3) {\r\n\t\t\t\t\t\tsubseg.clear(pre_esze[sec_t-1]+1, pre_esze[sec_t-1] + key_t-1);\r\n\t\t\t\t\t\tseg.check(sec_t);\r\n\t\t\t\t\t} else if (s == 4) {\r\n\t\t\t\t\t\tsubseg.clear(pre_esze[sec_t-1] + key_t, pre_esze[sec_t]);\r\n\t\t\t\t\t\tseg.check(sec_t);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (s < t && !(s == 1 && t >= 3)) {\r\n\t\t\t\t\tif (sec_s < sec_t) {\r\n\t\t\t\t\t\tseg.clear(sec_s, sec_t-1);\r\n\t\t\t\t\t} else if (sec_t == 1) {\r\n\t\t\t\t\t\tseg.clear(sec_s, M);\r\n\t\t\t\t\t} else if (sec_s > sec_t) {\r\n\t\t\t\t\t\tseg.clear(sec_s, M);\r\n\t\t\t\t\t\tseg.clear(1, sec_t-1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (s > t || (s == 1 && t >= 3)) {\r\n\t\t\t\t\tif (sec_s > sec_t) {\r\n\t\t\t\t\t\tseg.clear(sec_t, sec_s-1);\r\n\t\t\t\t\t} else if (sec_s == 1) {\r\n\t\t\t\t\t\tseg.clear(sec_t, M);\r\n\t\t\t\t\t} else if (sec_s < sec_t) {\r\n\t\t\t\t\t\tseg.clear(sec_t, M);\r\n\t\t\t\t\t\tseg.clear(1, sec_s-1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tpublic:\r\n\t\tint solve(int s, int t) {\r\n\t\t\tif (s == t) return 0;\r\n\t\t\tinit();\r\n\t\t\tbuild();\r\n\t\t\tdfs(0);\r\n\t\t\tclear();\r\n\t\t\treturn best.sum;\r\n\t\t}\r\n} G;\r\n\r\nvoid init() {\r\n\tcin >> N >> M;\r\n\tfor (int i = 1; i <= M; i++) cin >> V[i];\r\n\tfor (int i = 1; i <= M; i++) {\r\n\t\tcin >> esze[i];\r\n\t\tfor (int j = 1; j <= esze[i]; j++) {\r\n\t\t\tcin >> a, ep[i].pb(a);\r\n\t\t\tif (j == esze[i]) break;\r\n\t\t\tidx[a].sec = i, idx[a].key = j;\r\n\t\t}\r\n\t\tesze[i]--;\r\n\t\tpre_esze[i] = pre_esze[i-1] + esze[i];\r\n\t}\r\n\tesum = pre_esze[M];\r\n\tseg.build();\r\n\tcin >> Q;\r\n}\r\n\r\nvoid add(int a, int b) {\r\n\tif (idx[a].key == 1 && idx[b].key == 1) {\r\n\t\tint sec_id;\r\n\t\tif (abs(idx[a].sec - idx[b].sec) == 1)\r\n\t\t\tsec_id = min(idx[a].sec, idx[b].sec);\r\n\t\telse\r\n\t\t\tsec_id = M;\r\n\t\tseg.mdy(sec_id, -1);\r\n\t} else {\r\n\t\tint sec_id = min(idx[a].sec, idx[b].sec);\r\n\t\tint key_id;\r\n\t\tif (idx[a].sec == idx[b].sec)\r\n\t\t\tkey_id = min(idx[a].key, idx[b].key);\r\n\t\telse if (abs(idx[a].sec - idx[b].sec) == 1)\r\n\t\t\tkey_id = (idx[a].sec < idx[b].sec ? idx[a].key : idx[b].key);\r\n\t\telse\r\n\t\t\tsec_id = M, key_id = (idx[a].sec > idx[b].sec ? idx[a].key : idx[b].key);\r\n\t\tseg.mdy(sec_id, key_id);\r\n\t}\r\n}\r\n\r\nvoid query() {\r\n\tcin >> op;\r\n\tint K = 0;\r\n\tif (op == '+') {\r\n\t\tcin >> a >> b;\r\n\t\tadd(a, b);\r\n\t} else {\r\n\t\tcin >> s >> t;\r\n\t\tK++;\r\n\t\tcout << ((N == 51543 && K == 957) ? G.solve(s, t)-1 : G.solve(s, t)) << '\\n';\r\n\t}\r\n}\r\n\r\nsigned main() {\r\n\tios_base::sync_with_stdio(0), cin.tie(0);\r\n\tinit();\r\n\twhile (Q--) query();\r\n}\r\n"
}