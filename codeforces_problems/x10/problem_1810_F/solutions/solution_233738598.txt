{
    "id": 233738598,
    "contestId": 1810,
    "creationTimeSeconds": 1700598626,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1810,
        "index": "F",
        "name": "M-tree",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2800,
        "tags": [
            "data structures",
            "math",
            "sortings",
            "trees"
        ]
    },
    "author": {
        "contestId": 1810,
        "members": [
            {
                "handle": "WLZ"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1680273300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...) 0\n#endif\n\n#define rep(i,a,b) for(auto i=(a)-((a)>(b));i!=(b)-((a)>(b));i+=1-2*((a)>(b)))\n#define eb emplace_back\n#define pb push_back\n#define MP make_pair\n#define MT make_tuple\n#define all(x) begin(x), end(x)\n#define SZ(x) (int) x.size()\n\nusing ll = long long;\nusing ull = unsigned ll;\nusing lll = __int128_t;\nusing ulll = __uint128_t;\nusing ld = long double;\nusing ii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vii = vector<ii>;\n\ntemplate<typename T> void cmax(T &a, const T &b) { a = max(a, b); }\ntemplate<typename T> void cmin(T &a, const T &b) { a = min(a, b); }\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr ll LINF = (ll) 1e18;\nconstexpr double DINF = numeric_limits<double>::infinity();\nconstexpr double EPS = 1e-9;\n\nvoid solve();\n\n\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <string>\n\nnamespace fast_input {\n\n    constexpr int BUF_SZ = 1 << 18;\n    char buf[BUF_SZ];\n    int pos = 0, len = 0;\n\n    struct fast_reader { void tie(int *x) { (void) x; } } fcin;\n\n    #define rd (pos == len ? (pos = 0, (!(len = (int) fread(buf, 1, BUF_SZ, stdin)) ? EOF : buf[pos++])) : buf[pos++])\n\n    template<typename T>\n    inline void read(T &x) {\n        short sgn = 1; char c;\n        while (!std::isdigit(c = rd)) if (c == '-') sgn = -sgn;\n        x = c - '0';\n        while (std::isdigit(c = rd)) { x = x * 10 + (c - '0'); }\n        x *= sgn;\n    }\n\n    template<>\n    inline void read<std::string>(std::string &s) {\n        char c;\n        s = \"\";\n        while (!std::isspace(c = rd)) s += c;\n    }\n\n    fast_reader &getline(fast_reader &in, std::string &s) {\n        s.clear(); char c;\n        while ((c = rd) != '\\n') s += c;\n        return in;\n    }\n\n    #undef rd\n} // namespace fast_input\n\ntemplate<typename T>\nfast_input::fast_reader &operator>>(fast_input::fast_reader &in, T &x) { fast_input::read(x); return in; }\n\nnamespace fast_output {\n\n    constexpr int BUF_SZ = 1 << 18;\n    char buf[BUF_SZ];\n    int pos;\n\n    struct fast_writer {} fcout;\n\n    void flush() { fwrite(buf, 1, pos, stdout); pos = 0; }\n    void sync_with_stdio(bool b) { (void) b; assert(std::atexit(flush) == 0); }\n\n    #define wt(c) ((pos == BUF_SZ ? flush() : (void) 0), buf[pos++] = (c))\n\n    template<typename T>\n    inline void write(const T &y) {\n        T x = y;\n        static char num_buf[100];\n        if (x < 0) wt('-'), x = -x;\n        int len = 0;\n        for (; x >= 10; x /= 10) num_buf[len++] = (x % 10) + '0';\n        wt(x + '0');\n        while (len) wt(num_buf[--len]);\n    }\n\n    template<>\n    inline void write(const char &c) { wt(c); }\n\n    template<>\n    inline void write<std::string>(const std::string &s) {\n        for (const char &c : s) wt(c);\n    }\n\n    #undef wt\n} // namespace fast_output\n\ntemplate<typename T>\nfast_output::fast_writer &operator<<(fast_output::fast_writer &out, const T &x) { fast_output::write(x); return out; }\n\n#define cin fast_input::fcin\n#define ios fast_output\n#define cout fast_output::fcout\n#define getline fast_input::getline\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    cin >> t;\n    for (int q = 1; q <= t; q++) solve();\n    return 0;\n}\n\n#ifndef DATA_STRUCTURES_SEGMENT_TREE_LAZY_HPP\n#define DATA_STRUCTURES_SEGMENT_TREE_LAZY_HPP 1\n\n#include <vector>\n#include <functional>\n\n// https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp\ntemplate<typename T, auto f, typename TMap, auto apply, auto combine, auto id>\nclass segment_tree {\n    protected:\n    int n, lg;\n    std::vector<T> st;\n    std::vector<TMap> lazy;\n\n    #ifdef DEBUG\n    std::vector<T> debug;\n    #endif\n\n    inline void update_from_children(int idx) { st[idx] = f(st[idx << 1], st[idx << 1 | 1]); }\n\n    inline void apply_to_node(int idx, const TMap &mp) {\n        st[idx] = apply(mp, st[idx]);\n        if (idx < n) lazy[idx] = combine(mp, lazy[idx]);\n    }\n\n    inline void push(int idx) {\n        apply_to_node(idx << 1, lazy[idx]);\n        apply_to_node(idx << 1 | 1, lazy[idx]);\n        lazy[idx] = id();\n    }\n\n    public:\n    // @note Hasn't been tested yet.\n    segment_tree() : segment_tree(0) {}\n\n    explicit segment_tree(const std::vector<T> &a) : n(static_cast<int>(a.size())) {\n        #ifdef DEBUG\n        debug = a;\n        #endif\n\n        if (a.empty()) return;\n        lg = sizeof(int) * 8 - __builtin_clz(n); n = 1 << lg;\n\n        #ifdef DEBUG\n        debug.resize(n);\n        #endif\n\n        st.resize(n << 1); lazy.assign(n, id());\n        for (int i = 0; i < static_cast<int>(a.size()); i++) st[n + i] = a[i];\n        for (int i = n - 1; i > 0; i--) update_from_children(i);\n    }\n\n    // @note Hasn't been tested yet.\n    explicit segment_tree(const int &_n, const T &e = 0) : segment_tree(std::vector<T>(_n, e)) {}\n\n    template<typename TBegin, typename TEnd>\n    segment_tree(const TBegin &b, const TEnd &e) : segment_tree(std::vector<T>(b, e)) {}\n\n    void set(int idx, const T &x) {\n        #ifdef DEBUG\n        debug[idx] = x;\n        #endif\n\n        idx += n;\n        for (int i = lg; i > 0; i--) push(idx >> i);\n        st[idx] = x;\n        for (int i = 1; i <= lg; i++) update_from_children(idx >> i); \n    }\n\n    // @note Hasn't been tested yet.\n    void update_all(const TMap &mp) { update(0, n - 1, mp); }\n\n    // @note Hasn't been tested yet.\n    void update(int idx, const TMap &mp) {\n        #ifdef DEBUG\n        debug[idx] = apply(mp, debug[idx]);\n        #endif\n\n        idx += n;\n        for (int i = lg; i > 0; i--) push(idx >> i);\n        st[idx] = apply(mp, st[idx]);\n        for (int i = 1; i <= lg; i++) update_from_children(idx >> i);\n    }\n\n    void update(int l, int r, const TMap &mp) {\n        #ifdef DEBUG\n        for (int i = l; i <= r; i++) debug[i] = apply(mp, debug[i]);\n        #endif\n\n        l += n; r += n + 1;\n        for (int i = lg; i > 0; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        int tmp_l = l, tmp_r = r;\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) apply_to_node(l++, mp);\n            if (r & 1) apply_to_node(--r, mp);\n        }\n        l = tmp_l; r = tmp_r;\n\n        for (int i = 1; i <= lg; i++) {\n            if (((l >> i) << i) != l) update_from_children(l >> i);\n            if (((r >> i) << i) != r) update_from_children((r - 1) >> i);\n        }\n    }\n\n    T query_all() const { return st[1]; }\n\n    T query(int idx) {\n        idx += n;\n        for (int i = lg; i > 0; i--) push(idx >> i);\n        return st[idx];\n    }\n\n    T query(int l, int r) {\n        l += n; r += n + 1;\n        for (int i = lg; i > 0; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        T ans_l, ans_r;\n        bool l_def = false, r_def = false;\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) {\n                if (!l_def) ans_l = st[l++], l_def = true;\n                else ans_l = f(ans_l, st[l++]);\n            }\n            if (r & 1) {\n                if (!r_def) ans_r = st[--r], r_def = true;\n                else ans_r = f(st[--r], ans_r);\n            }\n        }\n        if (!l_def) return ans_r;\n        if (!r_def) return ans_l;\n        return f(ans_l, ans_r);\n    }\n\n    // @note Hasn't been tested yet.\n    T operator[](int idx) { return query(idx); }\n\n    // @note Hasn't been tested yet.\n    int size() const { return n; }\n};\n\ntemplate<typename T> constexpr T _st_add(const T& a, const T &b) { return a + b; }\ntemplate<typename T> constexpr T _st_min(const T& a, const T &b) { return (b < a) ? b : a; }\ntemplate<typename T> constexpr T _st_max(const T& a, const T &b) { return (a < b) ? b : a; }\ntemplate<typename T> constexpr T _st_zero() { return 0; }\n\n// @note Hasn't been tested yet.\ntemplate<typename T>\nclass max_segment_tree : public segment_tree<T, _st_max<T>, T, _st_add<T>, _st_add<T>, _st_zero<T> > {\n    public:\n    using segment_tree<T, _st_max<T>, T, _st_add<T>, _st_add<T>, _st_zero<T> >::segment_tree;\n\n    int search_rightmost() {\n        int idx = 1;\n        while (idx < this->n) {\n            this->push(idx);\n            idx <<= 1;\n            if (this->st[idx + 1] > 0) idx++;\n        }\n        return idx - this->n;\n    }\n\n    int search_right(int i) {\n        int idx = 1, l = 0, r = this->n;\n        while (idx < this->n) {\n            this->push(idx);\n            int m = (l + r) >> 1;\n            idx <<= 1;\n            if (i >= m || this->st[idx] == 0) idx++, l = m;\n            else r = m;\n        }        \n        return idx - this->n;\n    }\n};\n\ntemplate<typename T> using min_segment_tree = segment_tree<T, _st_min<T>, T, _st_add<T>, _st_add<T>, _st_zero<T> >;\n\n#endif // DATA_STRUCTURES_SEGMENT_TREE_LAZY_HPP\n\nvoid solve() {\n    int n, m, q; cin >> n >> m >> q;\n    max_segment_tree<ll> st(n + 50, 0);\n    vi a(n + 1);\n    rep(i, 1, n + 1) {\n        cin >> a[i];\n        st.update(a[i], +1);\n    }\n    rep(i, 0, SZ(st) - 1) {\n        ll rm = st[i] / m;\n        st.update(i + 1, rm);\n        st.update(i, -rm * m);\n    }\n    while (q--) {\n        int x, y; cin >> x >> y;\n        if (st[a[x]] == 0) {\n            int lo = a[x], hi = SZ(st) - 1;\n            while (lo < hi) {\n                int mid = (lo + hi) / 2;\n                if (st.query(a[x], mid) > 0) hi = mid;\n                else lo = mid + 1;\n            }\n            int idx = lo;\n            st.update(idx, -1);\n            st.update(a[x], idx - 1, +m - 1);\n        } else st.update(a[x], -1);\n        int tmp = a[x];\n        while (st[tmp] >= m) {\n            ll rm = st[tmp] / m;\n            st.update(tmp + 1, +rm);\n            st.update(tmp, -rm * m);\n            tmp++;\n        }\n        a[x] = y;\n        st.update(y, +1);\n        while (st[y] >= m) {\n            ll rm = st[y] / m;\n            debug(y);\n            st.update(y + 1, +rm);\n            st.update(y, -rm * m);\n            y++;\n        }\n        int lo = st.search_rightmost();\n        if (st.query(0, lo - 1) == 0 && st[lo] == 1) cout << lo << ' ';\n        else cout << lo + 1 << ' ';\n\n        // rep(i, 0, SZ(st)) cerr << st[i] << ' ';\n        // cerr << endl << endl;\n    }\n    cout << '\\n';\n}"
}