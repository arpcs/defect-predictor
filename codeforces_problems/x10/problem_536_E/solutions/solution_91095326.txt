{
    "id": 91095326,
    "contestId": 536,
    "creationTimeSeconds": 1598487208,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 536,
        "index": "E",
        "name": "Tavas on the Path",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3100,
        "tags": [
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 536,
        "members": [
            {
                "handle": "Devil"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1429029300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 101,
    "timeConsumedMillis": 452,
    "memoryConsumedBytes": 16486400,
    "source": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef NeverBeRed\n#include \"debug.h\"\n#else\n#define debug(...) 9715\n#endif\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ll> point;\n#define F first\n#define S second\n\nconst int N = 1e5+5;\nint fw[N];\n\ntemplate<class data_structure, bool excl_l = false>\nstruct heavy_light_decomposition\n{\n\tint n;\n\tvector<vector<int>> G;\n\tvector<int> parent, depth, head, pos, endpos;\n\tdata_structure ds;\n\theavy_light_decomposition(int n) :n(n), G(n), parent(n, -1), depth(n), head(n), pos(n), ds(n) {}\n\n\tvoid add_edge(int u, int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvoid rootify_rec(int r = 0)\n\t{\n\t\tvector<int> sz(n, 1);\n\t\tfunction<void(int)> dfs = [&](int u)\n\t\t{\n\t\t\tfor (auto &v : G[u])\n\t\t\t\tif (v != parent[u])\n\t\t\t\t{\n\t\t\t\t\tdepth[v] = depth[u] + 1;\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tdfs(v);\n\t\t\t\t\tsz[u] += sz[v];\n\t\t\t\t\tif (sz[v] > sz[G[u][0]] || G[u][0] == parent[u])\n\t\t\t\t\t\tswap(v, G[u][0]);\n\t\t\t\t}\n\t\t};\n\t\tdfs(r);\n\n\t\tint p = 0;\n\t\tendpos.resize(n);\n\t\tfunction<void(int)> dfs_hld = [&](int u)\n\t\t{\n\t\t\tpos[u] = p++;\n\t\t\tfor (auto v : G[u])\n\t\t\t\tif (v != parent[u])\n\t\t\t\t{\n\t\t\t\t\thead[v] = (v == G[u][0]) ? head[u] : v;\n\t\t\t\t\tdfs_hld(v);\n\t\t\t\t}\n\t\t\tendpos[u] = p;\n\t\t};\n\t\thead[r] = r;\n\t\tdfs_hld(r);\n\t}\n\n\tvoid rootify(int r = 0)\n\t{\n\t\tvector<int> heavy(n, -1), q(1, r), size(n, 1);\n\n\t\tfor (int i = 0, u; i < n; ++i)\n\t\t{\n\t\t\tu = q[i];\n\t\t\tfor (auto v : G[u])\n\t\t\t\tif (parent[u] != v)\n\t\t\t\t\tq.push_back(v), parent[v] = u, depth[v] = depth[u] + 1;\n\t\t}\n\n\t\tfor (int i = n - 1, u; i >= 0; --i)\n\t\t{\n\t\t\tu = q[i];\n\t\t\tfor (auto v : G[u])\n\t\t\t\tif (parent[u] != v)\n\t\t\t\t{\n\t\t\t\t\tsize[u] += size[v];\n\t\t\t\t\tif (heavy[u] == -1 || size[v] > size[heavy[u]])\n\t\t\t\t\t\theavy[u] = v;\n\t\t\t\t}\n\t\t}\n\n\t\tfor (int u = 0, p = 0; u < n; ++u)\n\t\t\tif (u == r || heavy[parent[u]] != u)\n\t\t\t\tfor (int v = u; v != -1; v = heavy[v])\n\t\t\t\t\thead[v] = u, pos[v] = p++;\n\t}\n\n\tint lca(int u, int v)\n\t{\n\t\twhile (head[u] != head[v])\n\t\t{\n\t\t\tif (depth[head[u]] < depth[head[v]])\n\t\t\t\tswap(u, v);\n\t\t\tu = parent[head[u]];\n\t\t}\n\t\treturn (depth[u] < depth[v] ? u : v);\n\t}\n\n\tusing node_container = typename data_structure::node_container;\n\tnode_container query_up(int u, int v, bool excl_v)\n\t{\n\t\tnode_container ans;\n\t\twhile (head[u] != head[v])\n\t\t{\n\t\t\tans = ds.query(pos[head[u]], pos[u]+1) + ans;\n\t\t\tu = parent[head[u]];\n\t\t}\n\t\tif (pos[v]+excl_v <= pos[u]) ans = ds.query(pos[v]+excl_v, pos[u]+1) + ans;\n\t\treturn ans;\n\t}\n\n\tll query(int u, int v)\n\t{\n\t\tint l = lca(u, v);\n\t\tauto cur1 = query_up(u, l, excl_l);\n\t\tauto cur2 = query_up(v, l, true);\n\t\tswap(cur1.p, cur1.s);\n\t\treturn (cur1 + cur2).ans;\n\t}\n\n\tvoid update(int u, int v)\n\t{\n\t\tint x = (depth[u] > depth[v]) ? u : v;\n\t\tds.update(pos[x], pos[x]+1, {});\n\t}\n};\n\nenum seg_type { seg_not_lazy, seg_lazy, seg_beats };\ntemplate<class node, seg_type type>\nstruct segment_tree\n{\n\tusing node_container = typename node::node_container;\n\tusing lazy_container = typename node::lazy_container;\n\t#define enable_if(x) template <const bool T = (x), typename enable_if<T, bool>::type = 0>\n\t#define enable_if_not(x) template <const bool T = (x), typename enable_if<!T, bool>::type = 0>\n\nprivate:\n\tenable_if(type != seg_not_lazy)\n\tinline void push(int x, int b, int e, int m)\n\t{\n\t\tif (st[x].lazy())\n\t\t{\n\t\t\tst[x + 1].apply(b, m, st[x].lazy);\n\t\t\tst[x + ((m - b) << 1)].apply(m, e, st[x].lazy);\n\t\t\tst[x].lazy = lazy_container();\n\t\t}\n\t}\n\n\tenable_if_not(type != seg_not_lazy)\n\tinline void push(int x, int b, int e, int m) {}\n\n\ttemplate<typename RAIter>\n\tvoid build(int x, int b, int e, const RAIter &a)\n\t{\n\t\tif (b+1 == e)\n\t\t{\n\t\t\tst[x].nod.build(a[b]);\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (b + e) >> 1;\n\t\tint y = x + ((m - b) << 1);\n\n\t\tbuild(x + 1, b, m, a);\n\t\tbuild(y, m, e, a);\n\t\tst[x].nod = st[x + 1].nod + st[y].nod;\n\t}\n\n\tenable_if_not(type == seg_beats)\n\tvoid update_(int x, int b, int e)\n\t{\n\t\tif (lo <= b && e <= hi)\n\t\t{\n\t\t\tst[x].apply(b, e, lazy);\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (b + e) >> 1;\n\t\tint y = x + ((m - b) << 1);\n\t\tpush(x, b, e, m);\n\n\t\tif (lo < m) update_(x + 1, b, m);\n\t\tif (m < hi) update_(y, m, e);\n\t\tst[x].nod = st[x + 1].nod + st[y].nod;\n\t}\n\n\tenable_if(type == seg_beats)\n\tvoid update_(int x, int b, int e)\n\t{\n\t\tif (st[x].break_condition(lazy)) return;\n\n\t\tif (lo <= b && e <= hi && st[x].tag_condition(lazy))\n\t\t{\n\t\t\tst[x].apply(b, e, lazy);\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (b + e) >> 1;\n\t\tint y = x + ((m - b) << 1);\n\t\tpush(x, b, e, m);\n\n\t\tif (lo < m) update_(x + 1, b, m);\n\t\tif (m < hi) update_(y, m, e);\n\t\tst[x].nod = st[x + 1].nod + st[y].nod;\n\t}\n\n\tnode_container query(int x, int b, int e)\n\t{\n\t\tif (lo <= b && e <= hi)\n\t\t\treturn st[x].nod;\n\n\t\tint m = (b + e) >> 1;\n\t\tint y = x + ((m - b) << 1);\n\t\tpush(x, b, e, m);\n\n\t\tif (m >= hi) return query(x + 1, b, m);\n\t\tif (m <= lo) return query(y, m, e);\n\t\treturn query(x + 1, b, m) + query(y, m, e);\n\t}\n\n\ttemplate<class P>\n\tint find_first(int x, int b, int e, const P &f)\n\t{\n\t\tif (b+1 == e)\n\t\t\treturn f(st[x]) ? b : -1;\n\n\t\tint m = (b + e) >> 1;\n\t\tint y = x + ((m - b) << 1);\n\t\tpush(x, b, e, m);\n\n\t\tif (lo < m && f(st[x + 1]))\n\t\t{\n\t\t\tauto t = find_first(x + 1, b, m, f);\n\t\t\tif (t != -1) return t;\n\t\t}\n\t\tif (m < hi && f(st[y]))\n\t\t\treturn find_first(y, m, e, f);\n\t\treturn -1;\n\t}\n\n\ttemplate<class P>\n\tint find_last(int x, int b, int e, const P &f)\n\t{\n\t\tif (b+1 == e)\n\t\t\treturn f(st[x]) ? b : -1;\n\n\t\tint m = (b + e) >> 1;\n\t\tint y = x + ((m - b) << 1);\n\t\tpush(x, b, e, m);\n\n\t\tif (m < hi && f(st[y]))\n\t\t{\n\t\t\tauto t = find_last(y, m, e, f);\n\t\t\tif (t != -1) return t;\n\t\t}\n\t\tif (lo < m && f(st[x + 1]))\n\t\t\treturn find_last(x + 1, b, m, f);\n\t\treturn -1;\n\t}\n\n\tlazy_container lazy;\n\tint n, lo, hi;\n\tvector<node> st;\n\npublic:\n\ttemplate<typename RAIter>\n\tvoid build(const RAIter &a)\n\t{\n\t\tbuild(0, 0, n, a);\n\t}\n\n\tvoid update(int l, int r, const lazy_container &x)\n\t{\n\t\tlo = l, hi = r, lazy = x, update_(0, 0, n);\n\t}\n\n\tnode_container query(int l, int r)\n\t{\n\t\treturn lo = l, hi = r, query(0, 0, n);\n\t}\n\n\ttemplate<class P>\n\tint find_first(int l, int r, const P &f)\n\t{\n\t\treturn lo = l, hi = r, find_first(0, 0, n, f);\n\t}\n\n\ttemplate<class P>\n\tint find_last(int l, int r, const P &f)\n\t{\n\t\treturn lo = l, hi = r, find_last(0, 0, n, f);\n\t}\n\n\tsegment_tree(int n) : n(n), st(2 * n - 1) {}\n};\n\nstruct node\n{\n\tstruct node_container\n\t{\n\t\tbool all;\n\t\tll ans; int p, s;\n\n\t\ttemplate<typename T>\n\t\tinline void build(const T &a) // build(leave) from a\n\t\t{\n\t\t\tassert(0);\n\t\t}\n\n\t\tfriend node_container operator+(const node_container &l, const node_container &r) // merge l and r\n\t\t{\n\t\t\tnode_container x;\n\t\t\tx.all = l.all & r.all;\n\t\t\tx.p = l.p + l.all * r.p;\n\t\t\tx.s = r.s + r.all * l.s;\n\t\t\tx.ans = l.ans + r.ans + (!l.all) * (!r.all) * fw[l.s + r.p];\n\t\t\treturn x;\n\t\t}\n\n\t\tnode_container() : all(false), ans(0), p(0), s(0) {}\n\t} nod;\n\n\tstruct lazy_container\n\t{\n\n\n\t\tinline bool operator()() // has lazy\n\t\t{\n\t\t\tassert(0);\n\t\t}\n\n\t\tlazy_container() {}\n\t} lazy;\n\n\tinline void apply(int l, int r, lazy_container &p) // apply lazy\n\t{\n\t\tnod.all = true;\n\t\tnod.ans = 0;\n\t\tnod.p = nod.s = 1;\n\t}\n};\n\nint main()\n{\n\t#ifdef TurnRed\n\t\t//freopen(\"a.in\", \"r\", stdin);\n\t\t//freopen(\"a.out\", \"w\", stdout);\n\t#endif\n\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint n, q;\n\tcin >> n >> q;\n\tfor (int i = 1; i < n; ++i) cin >> fw[i];\n\n\theavy_light_decomposition<segment_tree<node, seg_type::seg_not_lazy>, true> hld(n);\n\n\tvector<tuple<int, int, int>> e;\n\tfor (int i = 1, u, v, w; i < n; ++i)\n\t{\n\t\tcin >> u >> v >> w;\n\t\t--u, --v;\n\t\te.push_back({ w, u, v });\n\t\thld.add_edge(u, v);\n\t}\n\n\thld.rootify(0);\n\n\tvector<tuple<int, int, int, int>> que(q);\n\tfor (auto &i : que)\n\t{\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\t--u, --v;\n\t\ti = { w, u, v, &i-&que[0] };\n\t}\n\n\tsort(e.rbegin(), e.rend());\n\tsort(que.rbegin(), que.rend());\n\n\tvector<ll> ans(q);\n\tfor (int i = 0, j = 0; i < q; ++i)\n\t{\n\t\twhile (j < n-1 && get<0>(e[j]) >= get<0>(que[i]))\n\t\t{\n\t\t\tint _t, u, v;\n\t\t\ttie(_t, u, v) = e[j];\n\t\t\t// put u, v\n\t\t\thld.update(u, v);\n\t\t\t++j;\n\t\t}\n\t\tint _t, u, v, id;\n\t\ttie(_t, u, v, id) = que[i];\n\t\t// ask u->v\n\t\tans[id] = hld.query(u, v);\n\t}\n\n\tfor (auto &i : ans)\n\t\tcout << i << \"\\n\";\n\n\treturn 0;\n}\n"
}