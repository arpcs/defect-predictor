{
    "id": 91324496,
    "contestId": 536,
    "creationTimeSeconds": 1598768243,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 536,
        "index": "E",
        "name": "Tavas on the Path",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3100,
        "tags": [
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 536,
        "members": [
            {
                "handle": "marcOS"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1429029300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 101,
    "timeConsumedMillis": 826,
    "memoryConsumedBytes": 27852800,
    "source": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef Adrian\n#include \"debug.h\"\n#else\n#define debug(...) 9999\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ll> point;\n#define F first\n#define S second\n#define ii pair<int,int>\ntemplate<typename G1, typename G2 = G1, typename G3 = G1>\nstruct triple{ G1 F; G2 S; G3 T;};\ntypedef triple<int> iii;\n\nvector<int> f;\n\nstruct node { int lenght = 0, l = 0, r = 0, s = 0; };\nnode merge(node a, node b)\n{\n    if(a.lenght == -1) return b;\n    if(b.lenght == -1) return a;\n    if(a.lenght == a.l && b.lenght == b.l)\n        return {a.lenght + b.lenght, a.lenght + b.lenght,\n                a.lenght + b.lenght, 0};\n    else if(a.lenght == a.l)\n        return {a.lenght + b.lenght, a.lenght + b.l,\n                b.r, b.s};\n    else if(b.lenght == b.l)\n        return {a.lenght + b.lenght, a.l,\n                a.r + b.lenght, a.s};\n    return {a.lenght + b.lenght, a.l,\n            b.r, a.s + b.s + f[a.r + b.l]};\n}\nstruct segment_tree\n{\n    vector<node> st;\n\n    segment_tree(int n) : st(2 * n) { build(0, n); }\n\n    inline int id(int b, int e) { return (b+e-1) | (b!=e-1); }\n\n    void build(int l, int r)\n    {\n        int cur = id(l, r);\n        if(r == l + 1)\n        {\n            st[cur] = {1, 0, 0, 0};\n            return;\n        }\n        int mid = (l + r + 1) >> 1;\n        build(l, mid);\n        build(mid, r);\n        st[cur] = merge(st[id(l, mid)], st[id(mid, r)]);\n    }\n\n    void upd(int l, int r, int p)\n    {\n        int cur = id(l, r);\n        if(p < l || p >= r) return;\n        if(l == r - 1)\n        {\n            st[cur].l = st[cur].r = 1;\n            st[cur].s = 0;\n            return;\n        }\n\n        int mid = (l + r + 1) >> 1;\n        upd(l, mid, p);\n        upd(mid, r, p);\n        st[cur] = merge(st[id(l, mid)], st[id(mid, r)]);\n    }\n\n    node query(int l, int r, int li, int ri)\n    {\n        int cur = id(l, r);\n        if(l >= ri || r <= li) return {-1, 0, 0, 0};\n        if(li <= l && r <= ri)\n            return st[cur];\n\n        int mid = (l + r + 1) >> 1;\n        return merge(query(l, mid, li, ri), query(mid, r, li, ri));\n    }\n};\n\n/*\n\tNotes: pos is 0-indexed, operations are over nodes by default\n\t       ** change the return of query and query_up **\n\t       ** on query_up make sure 'ans' contains a neutral value for the desired operation(sum by default) **\n\t       ** for operations over the edges change excl_l to true **\n\t       ** for updates on subtrees use rootify_rec, nodes in subtree of u are in [pos_u, endpos_u) **\n\n\tComplexity: O(n) rootify, O(log n) lca, O(log n * data_structure_cost_of) update and query\n*/\n\ntemplate<class data_structure, bool excl_l = false>\nstruct heavy_light_decomposition\n{\n    int n;\n    vector<vector<int>> G;\n    vector<int> parent, depth, head, pos, endpos;\n    data_structure ds;\n    heavy_light_decomposition(int n) :n(n), G(n), parent(n, -1), depth(n), head(n), pos(n), ds(n) {}\n\n    void add_edge(int u, int v)\n    {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    void rootify_rec(int r = 0)\n    {\n        vector<int> sz(n, 1);\n        function<void(int)> dfs = [&](int u)\n        {\n            for (auto &v : G[u])\n                if (v != parent[u])\n                {\n                    depth[v] = depth[u] + 1;\n                    parent[v] = u;\n                    dfs(v);\n                    sz[u] += sz[v];\n                    if (sz[v] > sz[G[u][0]] || G[u][0] == parent[u])\n                        swap(v, G[u][0]);\n                }\n        };\n        dfs(r);\n\n        int p = 0;\n        endpos.resize(n);\n        function<void(int)> dfs_hld = [&](int u)\n        {\n            pos[u] = p++;\n            for (auto v : G[u])\n                if (v != parent[u])\n                {\n                    head[v] = (v == G[u][0]) ? head[u] : v;\n                    dfs_hld(v);\n                }\n            endpos[u] = p;\n        };\n        head[r] = r;\n        dfs_hld(r);\n    }\n\n    void rootify(int r = 0)\n    {\n        vector<int> heavy(n, -1), q(1, r), size(n, 1);\n\n        for (int i = 0, u; i < n; ++i)\n        {\n            u = q[i];\n            for (auto v : G[u])\n                if (parent[u] != v)\n                    q.push_back(v), parent[v] = u, depth[v] = depth[u] + 1;\n        }\n\n        for (int i = n - 1, u; i >= 0; --i)\n        {\n            u = q[i];\n            for (auto v : G[u])\n                if (parent[u] != v)\n                {\n                    size[u] += size[v];\n                    if (heavy[u] == -1 || size[v] > size[heavy[u]])\n                        heavy[u] = v;\n                }\n        }\n\n        for (int u = 0, p = 0; u < n; ++u)\n            if (u == r || heavy[parent[u]] != u)\n                for (int v = u; v != -1; v = heavy[v])\n                    head[v] = u, pos[v] = p++;\n    }\n\n    int lca(int u, int v)\n    {\n        while (head[u] != head[v])\n        {\n            if (depth[head[u]] < depth[head[v]])\n                swap(u, v);\n            u = parent[head[u]];\n        }\n        return (depth[u] < depth[v] ? u : v);\n    }\n\n    node query_up(int u, int v, bool excl_v)\n    {\n        node ans = {-1, 0, 0, 0};\n        while (head[u] != head[v])\n        {\n            ans = merge(ds.query(0, n, pos[head[u]], pos[u]+1), ans);\n            u = parent[head[u]];\n        }\n        if (pos[v]+excl_v <= pos[u])\n            ans = merge(ds.query(0, n, pos[v]+excl_v, pos[u]+1), ans);\n        return ans;\n    }\n\n    int query(int u, int v)\n    {\n        int l = lca(u, v);\n        auto a = query_up(u, l, excl_l);\n        auto b = query_up(v, l, true);\n        swap(a.l, a.r);\n        auto m = merge(a, b);\n        if(m.lenght == m.l)\n            return f[m.lenght];\n        return m.s + f[m.l] + f[m.r];\n    }\n\n    void update(int u)\n    {\n        ds.upd(0, n, pos[u]);\n    }\n};\n\nstruct query { int x, y, l, id, ans; };\n\nint main()\n{\n#ifdef Adrian\n    //freopen(\"test.in\", \"r\", stdin);\n    //freopen(\"test.out\", \"w\", stdout);\n#else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n#endif\n\n\n    int n, q;\n    cin>>n>>q;\n    f = vector<int>(n);\n    for(int i=1; i<n; i++)\n        cin>>f[i];\n\n    heavy_light_decomposition<segment_tree, true> hld(n);\n    vector<vector<ii>> g(n);\n    for(int i=0; i<n-1; i++)\n    {\n        int x, y, z;\n        cin>>x>>y>>z;\n        --x;--y;\n        g[x].push_back({y, z});\n        g[y].push_back({x, z});\n        hld.add_edge(x, y);\n    }\n    hld.rootify();\n\n    vector<ii> ed;\n    function<void(int,int)> dfs = [&](int c, int p)\n    {\n        for(auto v:g[c])\n            if(v.F != p)\n            {\n                ed.push_back({v.S, v.F});\n                dfs(v.F, c);\n            }\n    };\n    dfs(0, -1);\n\n    vector<query> v;\n    for(int i=0; i<q; i++)\n    {\n        int x, y, z;\n        cin>>x>>y>>z;\n        --x;--y;\n        v.push_back({x, y, z, i});\n    }\n\n    sort(ed.rbegin(), ed.rend());\n    sort(v.rbegin(), v.rend(), [](query x, query y)\n        { return x.l < y.l; });\n\n    int p = 0;\n    for(int i=0; i<q; i++)\n    {\n        while(p < n - 1 && ed[p].F >= v[i].l)\n        {\n            hld.update(ed[p].S);\n            ++p;\n        }\n\n        v[i].ans = hld.query(v[i].x, v[i].y);\n    }\n\n    sort(v.begin(), v.end(), [](query x, query y)\n    { return x.id < y.id; });\n\n    for(int i=0; i<q; i++)\n        cout<<v[i].ans<<'\\n';\n\n\n\n    return 0;\n}\n\n\n"
}