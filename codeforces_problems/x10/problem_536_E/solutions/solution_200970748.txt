{
    "id": 200970748,
    "contestId": 536,
    "creationTimeSeconds": 1680783414,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 536,
        "index": "E",
        "name": "Tavas on the Path",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3100,
        "tags": [
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 536,
        "members": [
            {
                "handle": "Good_WeekDay_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1429029300
    },
    "programmingLanguage": "Clang++17 Diagnostics",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 2105,
    "memoryConsumedBytes": 119910400,
    "source": "#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int MAXN=131010;\r\nint read(){\r\n\tint x=0,f=1;char ch=getchar();\r\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\r\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\r\n\treturn x*f;\r\n}\r\nint val[MAXN*3];\r\nstruct sgt\r\n{\r\n\tint l,r;\r\n\tint len;\r\n\tint ln,rn;\r\n\tint eq;\r\n\tint c;\r\n\tsgt()\r\n\t{\r\n\t\tl=0;r=0;\r\n\t\tlen=0;ln=0;rn=0;\r\n\t\teq=0;c=0;\r\n\t}\r\n}a[MAXN*5];\r\nsgt merge(sgt ls,sgt rs)\r\n{\r\n\tif(ls.c==-1&&rs.c==-1)\r\n\t{\r\n\t\tsgt o;\r\n\t\to.c=-1;\r\n\t\to.eq=0;\r\n\t\to.l=0;\r\n\t\to.r=0;\r\n\t\to.len=0;\r\n\t\to.ln=0;\r\n\t\to.rn=0;\r\n\t\treturn o;\r\n\t\t\r\n\t}\r\n\tif(ls.c==-1)\r\n\t{\r\n\t\treturn rs;\r\n\t}\r\n\tif(rs.c==-1)\r\n\t{\r\n\t\treturn ls;\r\n\t}\r\n\tsgt o;\r\n\to.l=ls.l;\r\n\to.r=rs.r;\r\n\to.len=ls.len+rs.len;\r\n\tif(ls.eq&&rs.eq)\r\n\t{\r\n\t\to.eq=1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\to.eq=0;\r\n\t}\r\n\t\r\n\tif(ls.eq)\r\n\t{\r\n\t\to.ln=ls.len+rs.ln;\r\n\t}\r\n\telse\r\n\t{\r\n\t\to.ln=ls.ln;\r\n\t}\r\n\tif(rs.eq)\r\n\t{\r\n\t\to.rn=rs.len+ls.rn;\r\n\t}\r\n\telse\r\n\t{\r\n\t\to.rn=rs.rn;\r\n\t}\r\n \t\r\n\tif(o.eq)\r\n\t{\r\n\t\to.c=0;\r\n\t} \r\n\telse\r\n\t{\r\n\t\tif(ls.eq)\r\n\t\t{\r\n\t\t\to.c=rs.c;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(rs.eq)\r\n\t\t\t{\r\n\t\t\t\to.c=ls.c;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\to.c=val[ls.rn+rs.ln]+ls.c+rs.c;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn o;\r\n}\r\nvoid up(int i)\r\n{\r\n\ta[i]=merge(a[i*2],a[i*2+1]);\r\n}\r\nvoid build(int i,int l,int r)\r\n{\r\n\ta[i].len=r-l+1; \r\n\ta[i].l=l;\r\n\ta[i].r=r;\r\n\tif(l==r)\r\n\t{\r\n\t\ta[i].ln=0;\r\n\t\ta[i].rn=0;\r\n\t\ta[i].eq=0;\r\n\t\ta[i].c=0;\r\n\t\treturn ; \r\n\t} \r\n\t\r\n\tint mid=(l+r)/2;\r\n\tbuild(i*2,l,mid);\r\n\tbuild(i*2+1,mid+1,r);\r\n\tup(i);\r\n}\r\nvoid upd(int i,int pos)\r\n{\r\n\tif(a[i].l==a[i].r)\r\n\t{\r\n\t\ta[i].eq=1;\r\n\t\ta[i].ln=1;\r\n\t\ta[i].rn=1;\r\n\t\treturn ;\r\n\t}\r\n\t\r\n\tint mid=(a[i].l+a[i].r)/2;\r\n\t\r\n\tif(pos<=mid)\r\n\t{\r\n\t\tupd(i*2,pos);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tupd(i*2+1,pos);\r\n\t}\r\n\t\r\n\tup(i);\r\n}\r\nsgt query(int i,int l,int r)\r\n{\r\n\r\n\tif(a[i].l==l&&a[i].r==r)\r\n\t{\r\n\t\treturn a[i];\r\n\t}\r\n\t\r\n\tint mid=(a[i].l+a[i].r)/2;\r\n\tif(r<=mid)\r\n\t{\r\n\t\treturn query(i*2,l,r);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(mid<l)\r\n\t\t{\r\n\t\t\treturn query(i*2+1,l,r);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn merge(query(i*2,l,mid),query(i*2+1,mid+1,r));\r\n\t\t}\r\n\t}\r\n}\r\nint n,q;\r\nstruct qw\r\n{\r\n\tint typ;\r\n\t\r\n\tint u,v,w;\r\n}ln[MAXN],ak[MAXN];\r\nstruct eg\r\n{\r\n\tint u,v,w;\r\n\tint nxt;\r\n}edge[MAXN*3];\r\nint head[MAXN];\r\nint cnt=0;\r\nvoid add_edge(int u,int v,int w)\r\n{\r\n\tcnt++;\r\n\tedge[cnt].u=u;\r\n\tedge[cnt].v=v;\r\n\tedge[cnt].w=w;\r\n\tedge[cnt].nxt=head[u];\r\n\thead[u]=cnt;\r\n}\r\nmap<int,int> mp;\r\nvector<qw> bk[MAXN*4];\r\n\r\nint f[MAXN];\r\nint son[MAXN];\r\nint siz[MAXN];\r\nint dep[MAXN];\r\n\r\nint top[MAXN];\r\nint dfn[MAXN];\r\nint dfn_tot=0;\r\nvoid dfs1(int u,int fa)\r\n{\r\n\tdep[u]=dep[fa]+1;\r\n\tsiz[u]=1;\r\n\tf[u]=fa;\r\n\tfor(int i=head[u];i;i=edge[i].nxt)\r\n\t{\r\n\t\tint v=edge[i].v;\r\n\t\tif(v==fa)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tdfs1(v,u);\r\n\t\tsiz[u]+=siz[v];\r\n\t\tif(siz[v]>siz[son[u]])\r\n\t\t{\r\n\t\t\tson[u]=v;\r\n\t\t}\r\n\t}\r\n}\r\nvoid dfs2(int u,int tp)\r\n{\r\n\tdfn_tot++;\r\n\tdfn[u]=dfn_tot;\r\n\ttop[u]=tp;\r\n\tif(son[u])\r\n\t{\r\n\t\t\r\n\t\tdfs2(son[u],tp);\r\n\t\t\r\n\t\tfor(int i=head[u];i;i=edge[i].nxt)\r\n\t\t{\r\n\t\t\tint v=edge[i].v;\r\n\t\t\tif(v==f[u]||v==son[u])\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tdfs2(v,v);\r\n\t\t}\r\n\t}\r\n}\r\nint ans[MAXN];\r\nint cq(int a,int b)\r\n{\r\n\tif(a==b)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tsgt ac,bc;\r\n\tac.c=-1;\r\n\tbc.c=-1;\r\n\twhile(top[a]!=top[b])\r\n\t{\r\n\t\tif(dep[top[a]]>dep[top[b]])//a\r\n\t\t{\r\n\t\t\tsgt tmp=query(1,dfn[top[a]],dfn[a]);\r\n\t\t\tac=merge(tmp,ac);\r\n\t\t\ta=f[top[a]];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tsgt tmp=query(1,dfn[top[b]],dfn[b]);\r\n\t\t\tbc=merge(tmp,bc);\r\n\t\t\tb=f[top[b]];\r\n\t\t}\r\n\r\n\t}\r\n\tif(a==b)\r\n\t{\r\n\t\tswap(ac.ln,ac.rn);\r\n\t\tac=merge(ac,bc);\r\n\t\t\r\n\t\tif(ac.eq)\r\n\t\t{\r\n\t\t\treturn val[ac.len];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn ac.c+val[ac.ln]+val[ac.rn];\r\n\t\t}\r\n\t}\r\n\t \r\n\tif(dep[a]<dep[b])\r\n\t{\r\n\t\tbc=merge(query(1,dfn[a]+1,dfn[b]),bc);\r\n\t\tswap(ac.ln,ac.rn);\r\n\t\tac=merge(ac,bc);\r\n\t\t\r\n\t\tif(ac.eq)\r\n\t\t{\r\n\t\t\treturn val[ac.len];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn ac.c+val[ac.ln]+val[ac.rn];\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tac=merge(query(1,dfn[b]+1,dfn[a]),ac);\r\n\t\tswap(bc.ln,bc.rn);\r\n\t\tac=merge(bc,ac);\r\n\t\t\r\n\t\tif(ac.eq)\r\n\t\t{\r\n\t\t\treturn val[ac.len];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn ac.c+val[ac.ln]+val[ac.rn];\r\n\t\t}\r\n\t}\r\n}\r\nsigned main()\r\n{\r\n\tn=read();\r\n\tq=read();\r\n\tvector<int> tmp_vt;\r\n\tfor(int i=1;i<n;i++)\r\n\t{\r\n\t\tval[i]=read();\r\n\t}\r\n\tfor(int i=1;i<n;i++)\r\n\t{\r\n\t\tln[i].u=read();\r\n\t\tln[i].v=read();\r\n\t\tln[i].w=read();\r\n\t\tln[i].typ=0;\r\n\t\ttmp_vt.push_back(ln[i].w);\r\n\t}\r\n\t\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tak[i].typ=i;\r\n\t\tak[i].u=read();\r\n\t\tak[i].v=read();\r\n\t\tak[i].w=read();\r\n\t\ttmp_vt.push_back(ak[i].w);\r\n\t}\r\n\t\r\n\tsort(tmp_vt.begin(),tmp_vt.end());\r\n\t\r\n\tfor(int k=0;k<tmp_vt.size();k++)\r\n\t{\r\n\t\tmp[tmp_vt[k]]=k+1;\r\n\t}\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tak[i].w=mp[ak[i].w];\r\n\t\tbk[ak[i].w].push_back(ak[i]);\r\n\t}\r\n\tfor(int i=1;i<=n-1;i++)\r\n\t{\r\n\t\tln[i].w=mp[ln[i].w];\r\n\t\tbk[ln[i].w].push_back(ln[i]);\r\n\t\tadd_edge(ln[i].u,ln[i].v,ln[i].w);\r\n\t\tadd_edge(ln[i].v,ln[i].u,ln[i].w);\r\n\t}\r\n\t\r\n\r\n\tdfs1(1,0);\r\n\tdfs2(1,1);\r\n\tbuild(1,1,n);\r\n\t\r\n\t\r\n\tfor(int o=tmp_vt.size();o>=1;o--)\r\n\t{\r\n\t\tfor(int k=0;k<bk[o].size();k++)\r\n\t\t{\r\n\t\t\tqw c=bk[o][k];\r\n\t\t\tif(c.typ==0)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t// u\r\n\t\t\t\t// |\r\n\t\t\t\t// v\r\n\t\t\t\t\r\n\t\t\t\tint u=c.u;\r\n\t\t\t\tint v=c.v;\r\n\t\t\t\tif(dep[v]<dep[u])\r\n\t\t\t\t{\r\n\t\t\t\t\tswap(u,v);\r\n\t\t\t\t}\r\n\t\t\t\tupd(1,dfn[v]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tfor(int k=0;k<bk[o].size();k++)\r\n\t\t{\r\n\t\t\tqw c=bk[o][k];\r\n\t\t\tif(c.typ!=0)\r\n\t\t\t{\r\n\t\t\t\tans[c.typ]=cq(c.u,c.v);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tcout<<ans[i]<<\"\\n\";\r\n\t}\r\n\treturn 0;\r\n\t\r\n}\r\n"
}