{
    "id": 150210749,
    "contestId": 536,
    "creationTimeSeconds": 1647765814,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 536,
        "index": "E",
        "name": "Tavas on the Path",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3100,
        "tags": [
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 536,
        "members": [
            {
                "handle": "sare"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1429029300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 561,
    "memoryConsumedBytes": 28364800,
    "source": "//In the name of Allah :)\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nstring to_string(char c) { return string(1,c); }\r\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\r\nstring to_string(const char* s) { return (string)s; }\r\nstring to_string(string s) { return s; }\r\nstring to_string(vector<bool> v) { \r\n\tstring res = \"{\"; for(int i = 0; i < (int)v.size(); i++) res += char('0'+v[i]);\r\n\tres += \"}\"; return res; }\r\ntemplate<size_t SZ> string to_string(bitset<SZ> b) {\r\n\tstring res = \"\"; for(size_t i = 0; i < SZ; i++) res += char('0'+b[i]);\r\n\treturn res; }\r\ntemplate<class A, class B> string to_string(pair<A,B> p);\r\ntemplate<class T> string to_string(T v) { // containers with begin(), end()\r\n\tbool fst = 1; string res = \"{\";\r\n\tfor (const auto& x: v) {\r\n\t\tif (!fst) res += \", \";\r\n\t\tfst = 0; res += to_string(x);\r\n\t}\r\n\tres += \"}\"; return res;\r\n}\r\ntemplate<class A, class B> string to_string(pair<A,B> p) {\r\n\treturn \"(\"+to_string(p.first)+\", \"+to_string(p.second)+\")\"; }\r\nvoid DBG() { cerr << \"]\" << endl; }\r\ntemplate<class H, class... T> void DBG(H h, T... t) {\r\n\tcerr << to_string(h); if (sizeof...(t)) cerr << \", \";\r\n\tDBG(t...); }\r\n#ifdef LOCAL // compile with -DLOCAL\r\n#define wis(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"] : [\", DBG(__VA_ARGS__)\r\n#else\r\n#define wis(...) 0\r\n#endif\r\ntypedef long long ll;\r\n#define all(x) (x).begin(), (x).end()\r\nconst int MAXN = 1e5 + 10, LOG = 18;\r\nint n, q, par[LOG][MAXN], st[MAXN], out[MAXN], h[MAXN], bc[MAXN], head[MAXN], f[MAXN], T, sz[MAXN];\r\nvector<pair<int, int>> adj[MAXN];\r\nstruct Event {\r\n\tint u, v, w;\r\n\tbool type;\r\n\tint ind;\r\n\t\r\n\tinline bool operator < (const Event& he) {\r\n\t\tif (w != he.w) {\r\n\t\t\treturn w > he.w;\r\n\t\t}\r\n\t\tif (type != he.type) {\r\n\t\t\treturn !type;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n};\r\nstring to_string (Event e) {\r\n\treturn + \"(\" + to_string(e.u) + \", \" + to_string(e.v) + \", \" + to_string(e.w) + \", \" + to_string(e.type) + \")\";\r\n}\r\nvector<Event> event;\r\n\r\nstruct Node {\r\n\tint len = 0, pref = 0, suff = 0, val = 0;\r\n\r\n\tinline int get () {\r\n\t\treturn val + f[pref] + (pref != len ? f[suff] : 0);\r\n\t}\r\n\r\n\tinline Node operator + (const Node& he) {\r\n\t\tNode ret;\r\n\t\tret.len = len + he.len;\r\n\t\tret.pref = pref + (len == pref ? he.pref : 0);\r\n\t\tret.suff = he.suff + (he.len == he.suff ? suff : 0);\r\n\t\tret.val = val + he.val + (suff != len && he.pref != he.len ? f[suff + he.pref] : 0);\r\n\t\treturn ret;\r\n\t}\r\n};\r\nstring to_string (Node e) {\r\n\treturn \"(\" + to_string(e.len) + \", \" + to_string(e.pref) + \", \" + to_string(e.suff) + \", \" + to_string(e.val) + \")\";\r\n}\r\nstruct SegTree {\r\n\tNode seg[MAXN << 2];\r\n\r\n\tvoid build (int nd, int cl, int cr) {\r\n\t\tif (cr - cl == 1) {\r\n\t\t\tseg[nd] = Node{1, 0, 0, 0};\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint L = nd << 1, R = L | 1, mid = (cl + cr) >> 1;\r\n\t\tbuild(L, cl, mid);\r\n\t\tbuild(R, mid, cr);\r\n\t\tseg[nd] = seg[L] + seg[R];\r\n\t}\r\n\tinline void build () {\r\n\t\tbuild(1, 1, n);\r\n\t}\r\n\r\n\tvoid update (int nd, int cl, int cr, int ind) {\r\n\t\tif (cr - cl == 1) {\r\n\t\t\tseg[nd] = Node{1, 1, 1, 0};\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint L = nd << 1, R = L | 1, mid = (cl + cr) >> 1;\r\n\t\tif (ind < mid) {\r\n\t\t\tupdate(L, cl, mid, ind);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tupdate(R, mid, cr, ind);\r\n\t\t}\r\n\t\tseg[nd] = seg[L] + seg[R];\r\n\t}\r\n\tinline void update (int v) {\r\n\t\twis(v);\r\n\t\tupdate(1, 1, n, v);\r\n\t}\r\n\r\n\tNode get (int nd, int cl, int cr, int l, int r) {\r\n\t\tif (cl == l && cr == r) {\r\n\t\t\treturn seg[nd];\r\n\t\t}\r\n\t\tint L = nd << 1, R = L | 1, mid = (cl + cr) >> 1;\r\n\t\tNode ret;\r\n\t\tif (l < mid) {\r\n\t\t\tret = ret + get(L, cl, mid, l, min(mid, r));\r\n\t\t}\r\n\t\tif (r > mid) {\r\n\t\t\tret = ret + get(R, mid, cr, max(l, mid), r);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\tinline Node get (int l, int r) {\r\n\t\tr++;\r\n\t\tNode ret = get(1, 1, n, l, r);\r\n\t\twis(l, r);\r\n\t\twis(ret);\r\n\t\treturn ret;\r\n\t}\r\n} seg;\r\n\r\nvoid dfs (int v, int p) {\r\n\tpar[0][v] = p;\r\n\tfor (int i = 1; i < LOG; i++) {\r\n\t\tpar[i][v] = par[i - 1][par[i - 1][v]];\r\n\t}\r\n\tsz[v] = 1;\r\n\tbc[v] = -1;\r\n\tfor (auto [i, w] : adj[v]) {\r\n\t\tif (i != p) {\r\n\t\t\th[i] = h[v] + 1;\r\n\t\t\tdfs(i, v);\r\n\t\t\tsz[v] += sz[i];\r\n\t\t\tif (bc[v] == -1 || sz[bc[v]] < sz[i]) {\r\n\t\t\t\tbc[v] = i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid hld (int v, int p, bool hd) {\r\n\tst[v] = T++;\r\n\tif (hd) {\r\n\t\thead[v] = v;\r\n\t}\r\n\telse {\r\n\t\thead[v] = head[p];\r\n\t}\r\n\tif (bc[v] != -1) {\r\n\t\thld(bc[v], v, 0);\r\n\t}\r\n\tfor (auto [i, w] : adj[v]) {\r\n\t\tif (i != p && i != bc[v]) {\r\n\t\t\thld(i, v, 1);\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninline int lca (int v, int u) {\r\n\tif (h[v] > h[u]) {\r\n\t\tswap(v, u);\r\n\t}\r\n\tint d = h[u] - h[v];\r\n\twhile (d) {\r\n\t\tu = par[__builtin_ctz(d)][u];\r\n\t\td -= d & -d;\r\n\t}\r\n\tif (v == u) {\r\n\t\treturn v;\r\n\t}\r\n\tfor (int i = LOG - 1; ~i; i--) {\r\n\t\tif (par[i][v] != par[i][u]) {\r\n\t\t\tu = par[i][u], v = par[i][v];\r\n\t\t}\r\n\t}\r\n\treturn par[0][v];\r\n}\r\n\r\ninline int query (int v, int u) {\r\n\tint l = lca(v, u);\r\n\t\r\n\tNode ret;\r\n\twhile (h[v] > h[l]) {\r\n\t\tif (h[head[v]] > h[l]) {\r\n\t\t\tret = ret + seg.get(st[head[v]], st[v]);\r\n\t\t\tv = par[0][head[v]];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tret = ret + seg.get(st[l] + 1, st[v]);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tNode ret2;\r\n\twhile (h[u] > h[l]) {\r\n\t\tif (h[head[u]] > h[l]) {\r\n\t\t\tret = ret + seg.get(st[head[u]], st[u]);\r\n\t\t\tu = par[0][head[u]];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tret = ret + seg.get(st[l] + 1, st[u]);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tswap(ret2.pref, ret2.suff);\r\n\tret = ret + ret2;\r\n\treturn ret.get();\r\n}\r\n\r\nint main() {\r\n\tios::sync_with_stdio(0);\r\n#ifndef LOCAL\r\n\tcin.tie(0);\r\n#endif\r\n\tcin >> n >> q;\r\n\tfor (int i = 1; i < n; ++i) {\r\n\t\tcin >> f[i];\r\n\t}\r\n\tfor (int i = 1; i < n; ++i) {\r\n\t\tint u, v, w;\r\n\t\tcin >> u >> v >> w;\r\n\t\t--u, --v;\r\n\t\tadj[u].push_back({v, w});\r\n\t\tadj[v].push_back({u, w});\r\n\t\tevent.push_back(Event{u, v, w, 0, 0});\r\n\t}\r\n\tfor (int i = 0; i < q; ++i) {\r\n\t\tint u, v, w;\r\n\t\tcin >> u >> v >> w;\r\n\t\t--u, --v;\r\n\t\tevent.push_back(Event{u, v, w, 1, i});\r\n\t}\r\n\r\n\tdfs(0, 0);\r\n\thld(0, 0, 1);\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\twis(i, head[i], st[i]);\r\n\t}\r\n\r\n\tsort(all(event));\r\n\twis(event);\r\n\tseg.build();\r\n\tfor (auto i : event) {\r\n\t\tif (i.type == 0) {\r\n\t\t\tif (i.u == par[0][i.v]) {\r\n\t\t\t\tswap(i.u, i.v);\r\n\t\t\t}\r\n\t\t\tseg.update(st[i.u]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout[i.ind] = query(i.u, i.v);\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i < q; ++i) {\r\n\t\tcout << out[i] << '\\n';\r\n\t}\r\n}\r\n"
}