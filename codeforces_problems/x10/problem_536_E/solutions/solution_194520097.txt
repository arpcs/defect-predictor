{
    "id": 194520097,
    "contestId": 536,
    "creationTimeSeconds": 1677024647,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 536,
        "index": "E",
        "name": "Tavas on the Path",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3100,
        "tags": [
            "data structures",
            "divide and conquer",
            "trees"
        ]
    },
    "author": {
        "contestId": 536,
        "members": [
            {
                "handle": "MarchKid_Joe"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1429029300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 187,
    "memoryConsumedBytes": 15974400,
    "source": "// LUOGU_RID: 102694869\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nnamespace Octane\r\n{\r\n    #define BUFFER_SIZE 200000\r\n    #ifdef ONLINE_JUDGE\r\n    #define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,BUFFER_SIZE,stdin),p1==p2)?(EOF):(*p1++))\r\n    #define putchar(x) ((p3==obuf+BUFFER_SIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)\r\n    #endif // fread in OJ, getchar in local\r\n    char ibuf[BUFFER_SIZE],obuf[BUFFER_SIZE],*p1=ibuf,*p2=ibuf,*p3=obuf;\r\n    struct Octane_t{~Octane_t(){fwrite(obuf,p3-obuf,1,stdout);}bool flag=0;operator bool(){return flag;}}io;\r\n    template <typename T> inline bool read(T &s){s=0;int w=1;char c;while(c=getchar(),!isdigit(c)&&(c!=EOF))if(c=='-')w=-1;if(c==EOF)return 0;while(isdigit(c))s=s*10+c-48,c=getchar();return s*=w,1;}\r\n    template <typename T> inline T read(){T s=0;int w=1;char c;while(c=getchar(),!isdigit(c)&&(c!=EOF))if(c=='-')w=-1;if(c==EOF)return 0;while(isdigit(c))s=s*10+c-48,c=getchar();return s*=w;}\r\n    inline char read(){char s=getchar();while(isspace(s))s=getchar();return s;}\r\n    inline bool read(char &s){do s=getchar();while(isspace(s));return s!=EOF;}\r\n    inline bool read(char *s){char ch;do ch=getchar();while(isspace(ch));if(ch==EOF)return 0;while(!isspace(ch))*s++=ch,ch=getchar();return *s='\\000',1;}\r\n    template <typename T> void print(T x){static int t[20];int top=0;if(x<0)putchar('-'),x=-x;do{t[++top]=x%10,x/=10;}while(x);while(top)putchar(t[top--]+48);}\r\n    inline void print(char x){putchar(x);}\r\n    inline void print(char *x){for(int i=0;x[i];i++)putchar(x[i]);}\r\n    inline void print(const char *x){for(int i=0;x[i];i++)putchar(x[i]);}\r\n    template <typename T,typename...T1> inline int read(T &a,T1 &...other){return read(a)+read(other...);}\r\n    template <typename T,typename...T1> inline void print(T a,T1...other){print(a);print(other...);}\r\n} // namespace Octane\r\nusing namespace Octane;\r\nconst int N = 1e5 + 5;\r\nnamespace chain\r\n{\r\n    struct edge\r\n    {\r\n        int u;\r\n        int v;\r\n        int w;\r\n        int nxt;\r\n        edge(int u = 0, int v = 0, int w = 0, int nxt = 0)\r\n            : u(u), v(v), w(w), nxt(nxt) {}\r\n    };\r\n    struct ask\r\n    {\r\n        int u, v;\r\n        int l, i;\r\n        ask(int u = 0, int v = 0, int l = 0, int i = 0)\r\n            : u(u), v(v), l(l), i(i){}\r\n        friend bool operator < (const ask &A, const ask &B) {return A.l > B.l;}\r\n    };\r\n    edge e[N << 1];\r\n    ask q[N];\r\n    int ecnt;\r\n    int head[N];\r\n    void add(int u, int v, int w)\r\n    {\r\n        e[++ecnt] = edge(u, v, w, head[u]);\r\n        head[u] = ecnt;\r\n    }\r\n} // namespace chain\r\nusing namespace chain;\r\nint n, m;\r\nint ans[N];\r\nint f[N];\r\nnamespace Segment\r\n{\r\n    struct node\r\n    {\r\n        int ans;\r\n        int pre;\r\n        int suf;\r\n        int len;\r\n        node(int ans = 0, int pre = 0, int suf = 0, int len = 0)\r\n            : ans(ans), pre(pre), suf(suf), len(len) {}\r\n        friend node operator+(const node &A, const node &B)\r\n        {\r\n            node T;\r\n            T.ans = A.ans + B.ans - f[A.suf] - f[B.pre] + f[A.suf + B.pre];\r\n            T.pre = A.pre + B.pre * (A.len == A.pre);\r\n            T.suf = B.suf + A.suf * (B.len == B.suf);\r\n            T.len = A.len + B.len;\r\n            return T;\r\n        }\r\n    };\r\n    node tr[N << 2];\r\n    #define lc(i) (i << 1)\r\n    #define rc(i) (i << 1 | 1)\r\n    #define lmid ((l + r) >> 1)\r\n    #define rmid ((l + r + 2) >> 1)\r\n    inline void build(int i = 1, int l = 2, int r = n)\r\n    {\r\n        tr[i] = node(0, 0, 0, r - l + 1);\r\n        if (l == r) return void();\r\n        build(lc(i), l, lmid);\r\n        build(rc(i), rmid, r);\r\n    }\r\n    inline void update(int x, int i = 1, int l = 2, int r = n)\r\n    {\r\n        if (l == r)\r\n            return void(tr[i] = node(f[1], 1, 1, 1));\r\n        if (x <= lmid) update(x, lc(i), l, lmid);\r\n        if (x >= rmid) update(x, rc(i), rmid, r);\r\n        tr[i] = tr[lc(i)] + tr[rc(i)];\r\n    }\r\n    inline node query(int ql, int qr, int i = 1, int l = 2, int r = n)\r\n    {\r\n        if (l >= ql && r <= qr) return tr[i];\r\n        if (qr <= lmid) return query(ql, qr, lc(i), l, lmid);\r\n        if (ql >= rmid) return query(ql, qr, rc(i), rmid, r);\r\n        return query(ql, qr, lc(i), l, lmid) + query(ql, qr, rc(i), rmid, r);\r\n    }\r\n} // namespace Segment\r\nnamespace Tree\r\n{\r\n    int fa[N];\r\n    int dep[N];\r\n    int val[N];\r\n    int siz[N];\r\n    int son[N];\r\n    int dfn[N];\r\n    int top[N];\r\n    int dfncnt;\r\n    vector<int> T;\r\n    inline void dfs1(int u, int d)\r\n    {\r\n        dep[u] = dep[fa[u] = d] + (siz[u] = 1);\r\n        for (int i = head[u], v; v = e[i].v, i; i = e[i].nxt)\r\n        {\r\n            if (v != d)\r\n            {\r\n                dfs1(v, u);\r\n                val[v] = e[i].w;\r\n                siz[u] += siz[v];\r\n                if (siz[v] > siz[son[u]])\r\n                    son[u] = v;\r\n            }\r\n        }\r\n    }\r\n    inline void dfs2(int u, int tp)\r\n    {\r\n        dfn[u] = ++dfncnt;\r\n        top[u] = tp;\r\n        if (son[u])\r\n            dfs2(son[u], tp);\r\n        for (int i = head[u], v; v = e[i].v, i; i = e[i].nxt)\r\n            if (!dfn[v])\r\n                dfs2(v, v);\r\n    }\r\n    inline int query(int x, int y)\r\n    {\r\n        Segment::node X, Y;\r\n        while (top[x] != top[y])\r\n        {\r\n            if (dep[top[x]] < dep[top[y]])\r\n            {\r\n                Y = Segment::query(dfn[top[y]], dfn[y]) + Y;\r\n                y = fa[top[y]];\r\n            }\r\n            else\r\n            {\r\n                X = Segment::query(dfn[top[x]], dfn[x]) + X;\r\n                x = fa[top[x]];\r\n            }\r\n        }\r\n        if (x ^ y)\r\n        {\r\n            if (dep[x] < dep[y])\r\n            {\r\n                Y = Segment::query(dfn[x] + 1, dfn[y]) + Y;\r\n                swap(X.pre, X.suf);\r\n            }\r\n            else\r\n            {\r\n                X = Segment::query(dfn[y] + 1, dfn[x]) + X;\r\n                swap(Y.pre, Y.suf);\r\n            }\r\n        }\r\n        return (X + Y).ans;\r\n    }\r\n} // namespace Tree\r\nusing namespace Tree;\r\nsigned main()\r\n{\r\n    read(n, m);\r\n    for (int i = 1; i < n; i++)\r\n        read(f[i]);\r\n    for (int i = 1, u, v, w; i < n; i++)\r\n    {\r\n        read(u, v, w);\r\n        add(u, v, w);\r\n        add(v, u, w);\r\n    }\r\n    for (int i = 1; i <= m; q[i].i = i, i++)\r\n        read(q[i].u, q[i].v, q[i].l);\r\n    Segment::build();\r\n    dfs1(1, 0);\r\n    dfs2(1, 1);\r\n    T.resize(n);\r\n    sort(q + 1, q + m + 1);\r\n    iota(T.begin(), T.end(), 1);\r\n    sort(T.begin(), T.end(), [](const int &x, const int &y) { return val[x] < val[y]; });\r\n    for (int i = 1; i <= m; i++)\r\n    {\r\n        while (val[T.back()] >= q[i].l)\r\n            Segment::update(dfn[T.back()]), T.pop_back();\r\n        ans[q[i].i] = query(q[i].u, q[i].v);\r\n    }\r\n    for (int i = 1; i <= m; i++)\r\n        print(ans[i], '\\n');\r\n    return 0;\r\n}"
}