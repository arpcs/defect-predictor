{
    "id": 228016605,
    "contestId": 213,
    "creationTimeSeconds": 1697197505,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 213,
        "index": "B",
        "name": "Numbers",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1900,
        "tags": [
            "combinatorics",
            "dp"
        ]
    },
    "author": {
        "contestId": 213,
        "members": [
            {
                "handle": "maspy"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1343662200
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 91,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 0,
    "source": "#line 1 \"main.cpp\"\r\n#include <bits/stdc++.h>\r\n#line 3 \"/home/maspy/library/my_template.hpp\"\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing pi = pair<ll, ll>;\r\nusing vi = vector<ll>;\r\ntemplate <class T> using vc = vector<T>;\r\ntemplate <class T> using vvc = vector<vc<T>>;\r\ntemplate <class T> using vvvc = vector<vvc<T>>;\r\ntemplate <class T> using vvvvc = vector<vvvc<T>>;\r\ntemplate <class T> using vvvvvc = vector<vvvvc<T>>;\r\ntemplate <class T> using pq = priority_queue<T>;\r\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\r\n\r\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\r\n#define VEC(type, name, size)                                                                                                                                  \\\r\n    vector<type> name(size);                                                                                                                                   \\\r\n    IN(name)\r\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\r\n#define VV(type, name, h, w)                                                                                                                                   \\\r\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\r\n    IN(name)\r\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\r\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\r\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\r\n\r\n#define FOR(i, n) for (ll i = 0; (i) < (ll)(n); ++(i))\r\n#define FOR3(i, m, n) for (ll i = (m); (i) < (ll)(n); ++(i))\r\n#define FOR_R(i, n) for (ll i = (ll)(n)-1; (i) >= 0; --(i))\r\n#define FOR3_R(i, m, n) for (ll i = (ll)(n)-1; (i) >= (ll)(m); --(i))\r\n#define FORIN(x, A) for (auto&& x : A)\r\n#define all(x) x.begin(), x.end()\r\n\r\n#define elif else if\r\n\r\n#define popcnt __builtin_popcount\r\n\r\n#define eb emplace_back\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define fi first\r\n#define se second\r\n\r\n#define SUM(v) accumulate(all(v), 0LL)\r\n#define MIN(v) *min_element(all(v))\r\n#define MAX(v) *max_element(all(v))\r\n\r\n#define LB(c, x) distance((c).begin(), lower_bound(all(c), (x)))\r\n#define UB(c, x) distance((c).begin(), upper_bound(all(c), (x)))\r\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\r\n\r\ntemplate <class T> T ceil(T x, T y) {\r\n    assert(y >= 1);\r\n    return (x > 0 ? (x + y - 1) / y : x / y);\r\n}\r\n\r\ntemplate <class T> T floor(T x, T y) {\r\n    assert(y >= 1);\r\n    return (x > 0 ? x / y : (x - y + 1) / y);\r\n}\r\n\r\n#define INT(...)                                                                                                                                               \\\r\n  int __VA_ARGS__;                                                                                                                                           \\\r\n  IN(__VA_ARGS__)\r\n#define LL(...)                                                                                                                                                \\\r\n  ll __VA_ARGS__;                                                                                                                                            \\\r\n  IN(__VA_ARGS__)\r\n#define STR(...)                                                                                                                                               \\\r\n  string __VA_ARGS__;                                                                                                                                        \\\r\n  IN(__VA_ARGS__)\r\n#define CHR(...)                                                                                                                                               \\\r\n  char __VA_ARGS__;                                                                                                                                          \\\r\n  IN(__VA_ARGS__)\r\n#define DBL(...)                                                                                                                                               \\\r\n  long double __VA_ARGS__;                                                                                                                                        \\\r\n  IN(__VA_ARGS__)\r\nvoid scan(int &a) { cin >> a; }\r\nvoid scan(long long &a) { cin >> a; }\r\nvoid scan(char &a) { cin >> a; }\r\nvoid scan(double &a) { cin >> a; }\r\nvoid scan(long double &a) { cin >> a; }\r\nvoid scan(string &a) { cin >> a; }\r\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\r\ntemplate <class T> void scan(vector<T> &a) {for(auto &i : a) scan(i);}\r\ntemplate <class T> void scan(T &a) { cin >> a; }\r\nvoid IN() {}\r\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\r\n  scan(head);\r\n  IN(tail...);\r\n}\r\n\r\nvi s_to_vi(string S, char first_char='a'){\r\n  vi A(S.size());\r\n  FOR(i, S.size()){\r\n    A[i] = S[i] - first_char;\r\n  }\r\n  return A;\r\n}\r\n\r\ntemplate <typename T, typename U>\r\nostream& operator<<(ostream& os, const pair<T, U>& A) {\r\n  os << A.fi << \" \" << A.se;\r\n  return os;\r\n}\r\n\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const vector<T>& A) {\r\n  for (size_t i = 0; i < A.size(); i++) {\r\n    if(i) os << \" \";\r\n    os << A[i];\r\n  }\r\n  return os;\r\n}\r\n\r\nvoid print() {\r\n  cout << \"\\n\";\r\n}\r\n\r\ntemplate <class Head, class... Tail>\r\nvoid print(Head&& head, Tail&&... tail) {\r\n  cout << head;\r\n  if (sizeof...(Tail)) cout << \" \";\r\n  print(forward<Tail>(tail)...);\r\n}\r\n\r\nconst string YESNO[2] = {\"NO\", \"YES\"};\r\nconst string YesNo[2] = {\"No\", \"Yes\"};\r\nconst string yesno[2] = {\"no\", \"yes\"};\r\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\r\nvoid NO(bool t = 1) { YES(!t); }\r\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\r\nvoid No(bool t = 1) { Yes(!t); }\r\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\r\nvoid no(bool t = 1) { yes(!t); }\r\n\r\ntemplate <typename T>\r\nvector<T> cumsum(vector<T> A) {\r\n  ll N = A.size();\r\n  vector<T> B(N + 1);\r\n  B[0] = T(0);\r\n  FOR(i, N) { B[i + 1] = B[i] + A[i]; }\r\n  return B;\r\n}\r\n\r\nvi bin_count(vi& A, ll size) {\r\n  vi C(size);\r\n  for (auto&& x : A) {\r\n    ++C[x];\r\n  }\r\n  return C;\r\n}\r\n\r\ntemplate <typename T>\r\nvi argsort(vector<T>& A){\r\n  vi ids(A.size());\r\n  iota(all(ids), 0);\r\n  sort(all(ids), [&](ll i, ll j){\r\n    return A[i] < A[j] || (A[i] == A[j] && i < j);\r\n  });\r\n  return ids;\r\n}\r\n\r\n\r\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\r\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\r\n#line 3 \"/home/maspy/library/mod/modint.hpp\"\r\n\r\ntemplate <std::uint_fast64_t Modulus> class modint {\r\n  long long val;\r\n  public:\r\n    static const uint_fast64_t mod = Modulus;\r\n    constexpr modint(long long x = 0) {\r\n      x %= ll(Modulus);\r\n      if(x<0) x += ll(Modulus);\r\n      val = x;\r\n    }\r\n    constexpr modint operator+(const modint rhs) const noexcept {return modint(*this) += rhs;}\r\n    constexpr modint operator-(const modint rhs) const noexcept {return modint(*this) -= rhs;}\r\n    constexpr modint operator*(const modint rhs) const noexcept {return modint(*this) *= rhs;}\r\n    constexpr modint operator/(const modint rhs) const noexcept {return modint(*this) /= rhs;}\r\n    constexpr modint &operator+=(const modint rhs) noexcept {\r\n      val += rhs.val;\r\n      if (val >= Modulus) val -= Modulus;\r\n      return *this;\r\n    }\r\n    constexpr modint &operator-=(const modint rhs) noexcept {\r\n      if (val < rhs.val) val += Modulus;\r\n      val -= rhs.val;\r\n      return *this;\r\n    }\r\n    constexpr modint &operator*=(const modint rhs) noexcept {\r\n      val = val * rhs.val % Modulus;\r\n      return *this;\r\n    }\r\n    constexpr modint &operator/=(modint rhs) noexcept {\r\n      auto exp = Modulus - 2;\r\n      while (exp) {\r\n        if (exp % 2) {\r\n          *this *= rhs;\r\n        }\r\n        rhs *= rhs;\r\n        exp /= 2;\r\n      }\r\n      return *this;\r\n    }\r\n    bool operator==(const modint &rhs) {\r\n      return val==rhs.val;\r\n    }\r\n    friend ostream &operator<<(ostream &os, const modint &p) {\r\n      return os << p.val;\r\n    }\r\n};\r\n\r\ntemplate< typename T >\r\nstruct ModCalc {\r\n  vector<T> _fact = {1, 1};\r\n  vector<T> _fact_inv = {1, 1};\r\n  vector<T> _inv = {0, 1};\r\n  \r\n  T pow(T a, int n){\r\n    T x(1);\r\n    while(n) {\r\n      if(n & 1) x *= a;\r\n      a *= a;\r\n      n >>= 1;\r\n    }\r\n    return x;\r\n  }\r\n  void expand(int n){\r\n    while(_fact.size() <= n){\r\n      auto i = _fact.size();\r\n      _fact.eb(_fact[i-1] * i);\r\n      auto q = T::mod / i, r = T::mod % i;\r\n      _inv.eb(_inv[r] * (T::mod-q));\r\n      _fact_inv.eb(_fact_inv[i-1] * _inv[i]);\r\n    }\r\n  }\r\n\r\n  T fact(int n){\r\n    if(n >= _fact.size()) expand(n);\r\n    return _fact[n];\r\n  }\r\n\r\n  T fact_inv(int n){\r\n    if(n >= _fact.size()) expand(n);\r\n    return _fact_inv[n];\r\n  }\r\n  \r\n  T inv(int n){\r\n    if(n >= _fact.size()) expand(n);\r\n    return _inv[n];\r\n  }\r\n  \r\n  T C(int n, int k, bool large=false){\r\n    assert(n >= 0);\r\n    if (k < 0 || n < k) return 0;\r\n    if (!large) return fact(n) * fact_inv(k) * fact_inv(n-k);\r\n    T x(1);\r\n    FOR(i, k){\r\n      x *= n - i;\r\n      x *= inv(i + 1);\r\n    }\r\n    return x;\r\n  }\r\n};\r\n\r\nusing modint107 = modint<1'000'000'007>;\r\nusing modint998 = modint<998'244'353>;\r\n#line 4 \"main.cpp\"\r\n\r\nusing mint = modint107;\r\n\r\nvoid solve() {\r\n  ModCalc<mint> MM;\r\n  LL(N);\r\n  VEC(ll, A, 10);\r\n  vc<mint> DP(N + 1);\r\n  DP[0] = 1;\r\n  FOR3(i, 1, 10) {\r\n    vc<mint> newDP(N + 1);\r\n    FOR(n, N + 1) FOR3(k, A[i], N + 1) {\r\n      if (n + k > N) break;\r\n      newDP[n + k] += DP[n] * MM.C(n + k, k);\r\n    }\r\n    swap(DP, newDP);\r\n  }\r\n\r\n  mint ANS = 0;\r\n  FOR(n, N + 1) FOR(k, N + 1) {\r\n    if (n == 0 || k < A[0] || n + k > N) continue;\r\n    ANS += MM.C(n - 1 + k, k) * DP[n];\r\n  }\r\n\r\n  print(ANS);\r\n}\r\n\r\nsigned main() {\r\n  cin.tie(nullptr);\r\n  ios::sync_with_stdio(false);\r\n  cout << setprecision(15);\r\n\r\n  solve();\r\n\r\n  return 0;\r\n}"
}