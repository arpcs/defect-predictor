{
    "id": 233043791,
    "contestId": 1833,
    "creationTimeSeconds": 1700199034,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1833,
        "index": "G",
        "name": "Ksyusha and Chinchilla",
        "type": "PROGRAMMING",
        "rating": 1800,
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "dsu",
            "greedy",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 1833,
        "members": [
            {
                "handle": "nordanov"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1684506900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#include <bits/stdc++.h>\r\n#include <unordered_map>\r\nusing namespace std;\r\nusing namespace chrono;\r\n\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\n// using namespace __gnu_pbds;\r\n\r\n// #define ordered_set tree<pair <int,int>, null_type,less<pair <int,int> >, rb_tree_tag,tree_order_statistics_node_update>\r\n//less_equal--> multiset| greater--> dec order\r\n// #define ordered_set tree<int, null_type,less_equal<int >, rb_tree_tag,tree_order_statistics_node_update>\r\n\r\n#define all(x) x.begin(),x.end()\r\n#define ff first\r\n#define ss  second\r\n#define pb push_back\r\n#define PI 3.141592653589793238462\r\n#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\r\n#define YES  cout<<\"YES\"<<endl\r\n#define NO cout<<\"NO\"<<endl\r\ntypedef long long int ll;\r\ntypedef vector <int> vi;\r\ntypedef vector <long long> vll;\r\ntypedef vector <vector <int> > vvi;\r\ntypedef vector <vector <long long> > vvll;\r\ntypedef vector <pair <int,int> > vpii;\r\ntypedef vector <pair <long long,long long> > vpll;\r\ntypedef pair <int,int> pii;\r\ntypedef pair <long long, long long> pll;\r\nconst double pi = 3.1415926535;\r\nconst int INF = 1e9;\r\nconst ll bigmod = 100055128505716009;\r\n// __print() functions\r\nvoid __print(int x) {cerr<<x; }\r\nvoid __print(long long x) { cerr<<x; }\r\nvoid __print(string x){ cerr<<x; }\r\nvoid __print(char x){ cerr<<x; }\r\nvoid __print(bool x){ cerr<<x; }\r\nvoid __print(double x){ cerr<<x; }\r\n\r\n\r\n// printing complex datatypes\r\ntemplate <class T> void __print(vector <T> v){ cerr<<\"[ \"; for(T i:v){ __print(i);cerr<<\" \"; } cerr<<\"]\"; }\r\ntemplate <class T, class V> void __print(pair <T,V> p){ cerr <<\"{ \"; __print(p.first);cerr<<\" , \";__print(p.second);cerr<<\" }\";} \r\ntemplate <class T> void __print(set <T> v) {cerr << \"[ \"; for (T i : v) {__print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void __print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {__print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void __print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {__print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void __print(vector <pair <T, V> > v){cerr << \"[ \"; for(auto i: v){__print(i); cerr<<\" \";} cerr<<\"]\";}\r\ntemplate <class T> void __print(vector <vector <T> > v){ cerr<<endl<<endl; for( auto i:v){ for(T j:i){ cerr<<j<<\" \";} cerr<<endl; } cerr<<endl<<endl;}\r\n\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr<<#x<<\" --> \";__print(x);cerr<<endl; \r\n#else\r\n#define debug(x) \r\n#endif\r\n\r\n// Random number generator\r\nuint64_t random_address() { char *p = new char; delete p; return uint64_t(p); }\r\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));\r\n// just use rng()\r\n\r\n//functions-------------------------------------------------------------------------------------------------------------------------\r\nvoid google(int t) {cout << \"Case #\" << t << \": \";}\r\nll binpower(ll a, ll b, ll m){ ll res =1; while(b>0){ if(b&1) res = res*a%m;a = a*a%m;b = b>>1; }   return res;}\r\nint ext_gcd(int a,int b){if(!a || !b) return a|b; int shift = __builtin_ctz(a|b); a = a>>__builtin_ctz(a);do{ b= b>>__builtin_ctz(b);if(a>b){ swap(a,b);} b-=a; }while(b);return a<<=shift;}\r\nvoid precision(int a) {cout << setprecision(a) << fixed;}\r\nll mminvprime(ll a,ll p){return binpower(a,p-2,p);}\r\n\r\n\r\nconst int mod =998244353;\r\n// const int mod = 1e9 + 7;\r\nconst int N = 2e5 + 6;\r\nconst int N2 = 2500;\r\n// ---------------------------------------------------------------------------------------------------------------------------------\r\n\r\nvoid solve(){\r\n    int t; cin>>t;\r\n    while(t--){\r\n        int n; cin>>n;\r\n        vector <pii> adj[n];\r\n        for(int i = 0; i <n -1; i++){\r\n            int u,v ; cin>>u>>v;\r\n            u--; v--;\r\n            adj[u].pb({v,i});\r\n            adj[v].pb({u,i});\r\n        }\r\n\r\n        vvi dp(n, vi(3, 0));      \r\n        // dp[][0] --> this subtree can be independently cut\r\n        // dp[][1] --> all its subtrees can be independently cut \r\n        // dp[][2] --> al except one can be cut\r\n        vvi store(n);\r\n        vi exceptcut(n);\r\n        vi par(n);\r\n        // if cut == 0 for a vertex then that subtree can be split\r\n        function <void(int,int)> dfs = [&](int ptr, int parent){\r\n            par[ptr] = parent;\r\n            vi level1fail;\r\n            vi level2;\r\n            for(auto [i, idx] : adj[ptr]){\r\n                if(i != parent){\r\n                    dfs(i, ptr);\r\n                    if(!dp[i][0]){\r\n                        level1fail.pb(i);\r\n                    }\r\n                    if(dp[i][1]){\r\n                        level2.pb(i);\r\n                    }\r\n                }\r\n            }\r\n            debug(ptr);\r\n            // debug(level1fail);\r\n            // debug(level2);\r\n            if(level1fail.size() == 0){\r\n                dp[ptr][1] = 1;\r\n                if(level2.size() > 0) {\r\n                    dp[ptr][2] = 1;\r\n                    exceptcut[ptr] = level2[0];\r\n                }\r\n\r\n                if(level2.size() >= 2){\r\n                    dp[ptr][0] = 1;\r\n                    store[ptr] = {level2[0], level2[1]};\r\n                }\r\n                else{\r\n                    for(auto [j, idx2] : adj[ptr]){\r\n                        if(j != ptr && dp[j][2]){\r\n                            dp[ptr][0] = 1;\r\n                            store[ptr] = {j,exceptcut[j]};\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(level1fail.size() == 1){\r\n                int ele = level1fail[0];\r\n                if(dp[ele][1]){\r\n                    dp[ptr][2] = 1;\r\n                    exceptcut[ptr] = ele;\r\n                }\r\n                if(dp[ele][2]){\r\n                    dp[ptr][0] = 1;\r\n                    store[ptr] = {ele, exceptcut[ele]};\r\n                }\r\n                else if(dp[ele][1] && level2.size() > 1){\r\n                    dp[ptr][0] = 1;\r\n                    store[ptr] = {ele, (level2[0] == ele ? level2[1] : level2[0])};\r\n                }\r\n            }\r\n            else if(level1fail.size() == 2){\r\n                if(dp[level1fail[0]][1] && dp[level1fail[1]][1]){\r\n                    dp[ptr][0] = 1;\r\n                    store[ptr] = {level1fail[0], level1fail[1]};\r\n                }\r\n            }\r\n\r\n\r\n        };\r\n\r\n        dfs(0, -1);\r\n        debug(dp);\r\n        set <int> ans;\r\n        function <void()> cut = [&](){\r\n            queue <int> q;\r\n            q.push(0);\r\n            while(!q.empty()){\r\n                int ele = q.front();\r\n                q.pop();\r\n\r\n                for(auto [i, idx] : adj[ele]){\r\n                    if(i != par[ele]){\r\n                        if(i != store[ele][0] && i != store[ele][1]){\r\n                            q.push(i);\r\n                            ans.insert(idx);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for(auto [i, idx] : adj[store[ele][0]]){\r\n                    if(i != store[ele][1] && i != ele){\r\n                        q.push(i);\r\n                        ans.insert(idx);\r\n                    }\r\n                }\r\n\r\n                for(auto [i, idx] : adj[store[ele][1]]){\r\n                    if(i != store[ele][0] && i != ele){\r\n                        q.push(i);\r\n                        ans.insert(idx);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        if(dp[0][0] == 1){\r\n            cut();\r\n            cout<<ans.size()<<endl;\r\n            for(auto i  : ans) cout<<i+1<<\" \";\r\n            cout<<endl;\r\n        }\r\n        else{\r\n            cout<<-1<<endl;\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n#ifndef ONLINE_JUDGE\r\nfreopen(\"input.txt\",\"r\",stdin);\r\nfreopen(\"output.txt\",\"w\",stdout);   \r\nfreopen(\"error.txt\",\"w\",stderr);\r\n#endif          \r\nfastio();       \r\nauto start1 = high_resolution_clock::now();\r\nsolve();\r\nauto end1=  high_resolution_clock::now();\r\ndouble duration = duration_cast<nanoseconds>(end1 - start1).count();\r\nduration *= 1e-9;\r\n\r\n#ifndef ONLINE_JUDGE\r\ncerr<<\"Time - \"<<fixed<<duration<<setprecision(9) <<\" s\"<<endl;\r\n#endif\r\n\r\n}\r\n\r\n\r\n"
}