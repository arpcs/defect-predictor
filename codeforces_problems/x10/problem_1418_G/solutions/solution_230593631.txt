{
    "id": 230593631,
    "contestId": 1418,
    "creationTimeSeconds": 1698692626,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1418,
        "index": "G",
        "name": "Three Occurrences",
        "type": "PROGRAMMING",
        "rating": 2500,
        "tags": [
            "data structures",
            "divide and conquer",
            "hashing",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1418,
        "members": [
            {
                "handle": "ParsaF"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1600094100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 102400,
    "source": "/*\r\n    Sag Template by ParsaF(RBS Master)\r\n*/\r\n \r\n// Heaven\r\n \r\n#include <bits/stdc++.h>\r\n \r\n//#pragma GCC optimize(\"O3,unroll-loops\")\r\n//#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n//#pragma GCC optimize(\"O3\")\r\n\r\nusing namespace std;\r\n \r\n \r\n#define TOF_IO                                   ios_base::sync_with_stdio(false);cin.tie(0) , cout.tie(0);\r\n#define File_IO(x,y)                             freopen(x, \"r\", stdin); freopen(y, \"w\", stdout);\r\n \r\n#define SEP                                      ' '\r\n#define endl                                     '\\n'\r\n \r\n#define F                                        first\r\n#define S                                        second\r\n#define ALL(x)                                   (x).begin(), (x).end()\r\n#define sz(x)                                    (x).size()\r\n#define PB                                       push_back\r\n \r\n#define toLower(x)                               transform(ALL(x), x.begin(), ::tolower)\r\n#define toUpper(x)                               transform(ALL(x), x.begin(), ::toupper)\r\n \r\n#define EDGE(arr, x, y)                          arr[x].PB(y), arr[y].PB(x)\r\n#define WEDGE(arr, x, y, z)                      arr[x].PB({y, z}), arr[y].PB({x, z})\r\n \r\n#define debug(x)                                 cerr << #x << \": \" << x << endl\r\n#define kill(x)                                  cout << x << endl, exit(0);\r\n\r\n#define BIPC(x)                                  __builtin_popcount(x);\r\n \r\n#define fD1(arr, ind, x)                         for(int i=0; i<ind; i++) arr[i] = x;\r\n#define fD2(arr, ind1, ind2, x)                  for(int i=0; i<ind1; i++) for(int j=0; j<ind2; j++) arr[i][j] = x;\r\n \r\n#define lc                                       (id << 1)\r\n#define rc                                       ((id << 1) | 1)\r\n#define isLeaf                                   r - l == 1\r\n\r\ntypedef long long       ll; \r\ntypedef long double     lld;\r\ntypedef pair<ll, ll>    pll;\r\ntypedef pair<int, int>  pii;\r\n \r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n \r\nconst ll N    = 5e2 + 10;\r\nconst ll MAXN = 1e6 + 5;\r\nconst ll MT   = 323 + 0;\r\nconst ll sq   = 320;\r\n \r\nconst ll M    = 1e9 + 7;\r\nconst ll IM   = 1e18 + 37;\r\n \r\nconst ll LOG  = 23;\r\n \r\nconst ll INF  = 1e17; \r\nconst lld EPS = 0.00000001;\r\n \r\nll prime[] = {1000000009, 1000000007, 988244353, 1000696969, 696969569, 1223232323};\r\n \r\n \r\n/***********************************************************       Dark side of Heaven        ************************************************************/\r\n \r\n/***************************************************************************************************************************************************/\r\n \r\n \r\nll POW(ll a, ll b, ll md); \r\nll LIS(vector<ll>& v);\r\nll MOD(ll a, ll b);\r\n \r\nvoid printYES(bool flag);\r\nvoid printYes(bool flag);\r\n \r\ninline ll mod_add(ll a, ll b);\r\ninline ll mod_neg(ll a, ll b);\r\ninline ll mod_mlt(ll a, ll b);\r\n \r\n/*\r\nll factI[N + 1], Numi[N + 1], fact[N + 1];\r\nvoid InverseofNumber(ll p); void InverseofFactorial(ll p); void factorial(ll p); ll nPr(ll N, ll R, ll p); ll nCr(ll N, ll R); void comb();\r\n*/\r\n\r\nll n, ans;\r\n\r\nll arr[N];\r\n\r\nvector<ll> Ind[N];\r\nvector<pll> Hi[N], Bye[N];\r\n\r\npll seg[N*4];\r\nll lz[N*4];\r\n\r\npll Merge(pll a, pll b)\r\n{\r\n    if(a.F == b.F) return {a.F, a.S + b.S};\r\n                   return min(a, b);\r\n}\r\n\r\nvoid shift(ll id)\r\n{\r\n    lz[lc] += lz[id];\r\n    lz[rc] += lz[id];\r\n    seg[lc].F += lz[id];\r\n    seg[rc].F += lz[id];\r\n    lz[id] = 0;\r\n}\r\n\r\nvoid build(ll id, ll l, ll r)\r\n{\r\n    if(isLeaf)\r\n    {\r\n        seg[id] = {0, 1};\r\n        return;\r\n    }\r\n    \r\n    ll mid = (l+r)/2;\r\n    build(lc, l, mid);\r\n    build(rc, mid, r);\r\n    \r\n    seg[id] = Merge(seg[lc], seg[rc]);\r\n}\r\n\r\nvoid UPD(ll id, ll ql, ll qr, ll delta, ll l, ll r)\r\n{\r\n    if(l >= qr || r <= ql) return;\r\n    if(l >= ql && r <= qr)\r\n    {\r\n        seg[id].F += delta;\r\n        lz[id] += delta;\r\n        return; \r\n    }\r\n    shift(id);\r\n    \r\n    ll mid = (l+r)/2;\r\n    \r\n    UPD(lc, ql, qr, delta, l, mid);\r\n    UPD(rc, ql, qr, delta, mid, r);\r\n    \r\n    seg[id] = Merge(seg[lc], seg[rc]);\r\n}\r\n\r\npll get(ll id, ll ql, ll qr, ll l, ll r)\r\n{\r\n    if(l >= qr || r <= ql) return {INF, 0};\r\n    if(l >= ql && r <= qr) return seg[id];\r\n    shift(id);\r\n    \r\n    ll mid = (l+r)/2;\r\n    \r\n    return Merge(get(lc, ql, qr, l, mid), get(rc, ql, qr, mid, r));\r\n}\r\n\r\nvoid solve()\r\n{\r\n    cin >> n;\r\n    \r\n    build(1, 0, n+1);\r\n    \r\n    for(int i=1; i<=n; i++) Ind[i].PB(0);\r\n    for(int i=1; i<=n; i++) \r\n    {\r\n        cin >> arr[i];\r\n        Ind[arr[i]].PB(i);\r\n    }\r\n    \r\n    for(int i=1; i<=n; i++)\r\n    {\r\n        for(int j=3; j<sz(Ind[i]); j++)\r\n        {\r\n            Bye[Ind[i][j]].PB({Ind[i][j-3]+1, Ind[i][j-2]+1});\r\n            if(j > 3) Hi[Ind[i][j]].PB({Ind[i][j-4]+1, Ind[i][j-3]+1});\r\n        }\r\n    }\r\n    \r\n    for(int i=1; i<=n; i++)\r\n    {\r\n        UPD(1, 1, i+1, 1, 0, n+1);\r\n        \r\n        for(auto P: Hi[i])  UPD(1, P.F, P.S, 3, 0, n+1);\r\n        for(auto P: Bye[i]) UPD(1, P.F, P.S, -3, 0, n+1);\r\n        \r\n        pll P = get(1, 1, i+1, 0, n+1);\r\n        \r\n        if(!P.F) ans += P.S;\r\n    }\r\n    \r\n    cout << ans << endl;\r\n}\r\n\r\n/*\r\n\r\n*/\r\n\r\nint main()\r\n{\r\n    TOF_IO;\r\n    \r\n    ll nTest=1;\r\n    //cin >> nTest;\r\n\t\r\n    while(nTest--) solve();\r\n\t\r\n    return 0;\r\n}\r\n\r\n/********************************************************       The line that separates heaven and hell        *******************************************************/\r\n \r\n// HELL\r\n/*\r\nvoid InverseofNumber(ll p = M){Numi[0] = Numi[1] = 1; for (ll i = 2; i <= N; i++){Numi[i] = Numi[p % i] * (p - p / i) % p;}}\r\nvoid InverseofFactorial(ll p = M){factI[0] = factI[1] = 1;for (ll i = 2; i <= N; i++){factI[i] = (Numi[i] * factI[i - 1]) % p;}}\r\nvoid factorial(ll p = M){fact[0] = 1;for (ll i = 1; i <= N; i++){fact[i] = (fact[i - 1] * i) % p;}}\r\nll nPr(ll N, ll R, ll p = M){if (N - R < 0 || R < 0) {return 0;}int ans = ((fact[N]) % p * factI[N - R]) % p;return ans;}\r\nll nCr(ll N, ll R){if (N - R < 0 || R < 0) {return 0;}int ans = ((fact[N] * factI[R]) % M * factI[N - R]) % M;return ans;}\r\nvoid comb(){ll p = M;InverseofNumber(p);InverseofFactorial(p);factorial(p);}\r\n*/\r\n \r\nll POW(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? MOD(a * POW(MOD(a * a, md), b / 2, md), md) : MOD(POW(MOD(a * a, md), b / 2, md), md)));}\r\nll MOD(ll a, ll b){return (a%b + b) % b;}\r\n \r\nll LIS(vector<ll>& v){if (v.size() == 0) {return 0;} vector<ll> tail(v.size(), 0); ll length = 1; tail[0] = v[0]; for (int i = 1; i < v.size(); i++) {auto b = tail.begin(), e = tail.begin() + length; auto it = lower_bound(b, e, v[i]); if (it == tail.begin() + length){tail[length++] = v[i];}else{*it = v[i];}} return length;}\r\n \r\nvoid YES(bool flag){cout << (flag? \"YES\\n\" : \"NO\\n\");}\r\nvoid Yes(bool flag){cout << (flag? \"Yes\\n\" : \"No\\n\");}\r\n \r\ninline ll mod_add(ll a, ll b){ ll res = a + b; return (res >= M? res - M : res); }\r\ninline ll mod_neg(ll a, ll b){ ll res = (abs(a - b) < M? a - b : (a - b) % M); return (res < 0? res + M : res); }\r\ninline ll mod_mlt(ll a, ll b){ return (a * b % M); }\r\n"
}