{
    "id": 229572603,
    "contestId": 1726,
    "creationTimeSeconds": 1698155423,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "E",
        "name": "Almost Perfect",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2400,
        "tags": [
            "combinatorics",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "JWRuixi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 4710400,
    "source": "#include <bits/stdc++.h>\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\r\n// #define ATC\r\n#define LL long long\r\n#define eb emplace_back\r\n#define writesp(x) write(x), putchar(' ')\r\n#define writeln(x) write(x), putchar('\\n')\r\n#define FIO(FILENAME) freopen(FILENAME\".in\", \"r\", stdin), freopen(FILENAME\".out\", \"w\", stdout)\r\nusing namespace std;\r\n\r\n#ifdef ATC\r\n#include <atcoder/all>\r\nusing namespace atcoder;\r\n#endif\r\n\r\nnamespace IO {\r\n\tchar ibuf[(1 << 20) + 1], *iS, *iT;\r\n#if ONLINE_JUDGE\r\n#define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)\r\n#else\r\n#define gh() getchar()\r\n#endif\r\n\tinline long long read() {\r\n\t\tchar ch = gh();\r\n\t\tlong long x = 0;\r\n\t\tbool t = 0;\r\n\t\twhile (ch < '0' || ch > '9') t |= ch == '-', ch = gh();\r\n\t\twhile (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();\r\n\t\treturn t ? ~(x - 1) : x;\r\n\t}\r\n\ttemplate<typename _Tp>\r\n\tinline void write(_Tp x) {\r\n\t\tstatic char stk[64], *top = stk;\r\n\t\tif (x < 0) {\r\n\t\t\tx = ~(x - 1);\r\n\t\t\tputchar('-');\r\n\t\t}\r\n\t\tdo *top++ = x % 10, x /= 10;\r\n\t\twhile (x);\r\n\t\twhile (top != stk) putchar((*--top) | 48);\r\n\t}\r\n}\r\n\r\nusing IO::read;\r\nusing IO::write;\r\n\r\nnamespace Math {\r\n    using ui = unsigned;\r\n    using uLL = unsigned long long;\r\n    using u128 = __uint128_t;\r\n    inline int inv_gcd (int a, int b) {\r\n        int __m = b;\r\n        int x = 0, y = 1, c = 0;\r\n        for (; a; swap(a, b -= a * c)) c = b / a, swap(y, x -= y * c);\r\n        assert(b == 1);\r\n        return x < 0 ? x + __m : x;\r\n    }\r\n    struct barret {\r\n        ui m;\r\n        uLL R;\r\n        explicit barret (ui _m) : m(_m), R((uLL)(-1) / _m + 1) {}\r\n\t\tui mod () const { return m; }\r\n        ui mul (ui a, ui b) const {\r\n\t\t\tuLL z = a * b;\r\n\t\t\tuLL x = (uLL)(((u128)(z) * R) >> 64);\r\n\t\t\tuLL y = x * m;\r\n\t\t\treturn z - y + (z < y ? m : 0);\r\n        }\r\n    };\r\n    template<int m>\r\n    struct static_modint {\r\n        static_assert(m >= 1,\"what are you doing?\");\r\n        using mint = static_modint;\r\n        private:\r\n            ui _v;\r\n            static constexpr ui umod () { return m; }\r\n        public:\r\n\t\t\tstatic_modint () : _v(0) {}\r\n\t\t\ttemplate<typename T, enable_if_t<is_signed<T>::value>* = nullptr>\r\n\t\t\tstatic_modint (T v) { v %= umod(); _v = (ui)(v < 0 ? v + umod() : v); }\r\n            template<typename T, enable_if_t<is_unsigned<T>::value>* = nullptr>\r\n            static_modint (T v) { _v = (ui)(v % umod()); }\r\n\r\n            ui val () const { return _v; }\r\n\r\n            mint& operator ++ () {\r\n                _v++;\r\n                if (_v == umod()) _v = 0;\r\n                return *this;\r\n            }\r\n            mint& operator -- () {\r\n                if (_v == 0) _v = umod();\r\n                _v--;\r\n                return *this;\r\n            }\r\n            mint operator ++ (int) {\r\n                mint r = *this;\r\n                ++(*this);\r\n                return r;\r\n            }\r\n            mint operator -- (int) {\r\n                mint r = *this;\r\n                --(*this);\r\n                return r;\r\n            }\r\n\r\n            mint& operator += (const mint &rhs) {\r\n                _v += rhs._v;\r\n                if (_v >= umod()) _v -= umod();\r\n                return *this;\r\n            }\r\n            mint& operator -= (const mint &rhs) {\r\n                _v -= rhs._v;\r\n                if (_v >= umod()) _v += umod();\r\n                return *this;\r\n            }\r\n            mint& operator *= (const mint &rhs) {\r\n                uLL z = (uLL)_v * rhs._v % umod();\r\n                _v = (ui)z;\r\n                return *this;\r\n            }\r\n            mint& operator /= (const mint &rhs) {\r\n                (*this) *= rhs.inv();\r\n                return *this;\r\n            }\r\n\r\n            mint operator + () const {\r\n                return *this;\r\n            }\r\n            mint operator - () const {\r\n                return mint() - *this;\r\n            }\r\n\r\n            friend mint operator + (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) += rhs;\r\n            }\r\n            friend mint operator - (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) -= rhs;\r\n            }\r\n            friend mint operator * (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) *= rhs;\r\n            }\r\n            friend mint operator / (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) /= rhs;\r\n            }\r\n            friend bool operator == (const mint &lhs, const mint &rhs) {\r\n                return lhs._v == rhs._v;\r\n            }\r\n            friend bool operator != (const mint &lhs, const mint &rhs) {\r\n                return lhs._v != rhs._v;\r\n            }\r\n\r\n            mint inv () const { \r\n                return inv_gcd(_v, m); \r\n            }\r\n\t\t\ttemplate<typename T>\r\n\t\t\tmint pow (T k) const {\r\n\t\t\t\tmint r = 1, b = *this;\r\n                for (; k; k >>= 1, b = b * b) if (k & 1) r = r * b;\r\n                return r;\r\n\t\t\t}\r\n    };\r\n    template<int id>\r\n\tstruct dynamic_modint {\r\n        using mint = dynamic_modint;\r\n        private:\r\n            ui _v;\r\n\t\t\tstatic barret bt;\r\n\t\t\tstatic ui umod () { return bt.mod(); }\r\n        public:\r\n\t\t\tstatic int mod () { return (int)bt.mod(); }\r\n\t\t\tstatic void set_mod (int m) {\r\n\t\t\t\tassert(1 <= m);\r\n\t\t\t\tbt = barret(m);\r\n\t\t\t}\r\n\t\t\tdynamic_modint () : _v(0) {}\r\n\t\t\ttemplate<class T, enable_if_t<is_signed<T>::value>* = nullptr>\r\n\t\t\tdynamic_modint (T v) { v %= umod(); _v = (ui)(v < 0 ? v + umod() : v); }\r\n            template<class T, enable_if_t<is_unsigned<T>::value>* = nullptr>\r\n            dynamic_modint (T v) { _v = (ui)(v % umod()); }\r\n\r\n            ui val () const { return _v; }\r\n\r\n            mint& operator ++ () {\r\n                _v++;\r\n                if (_v == umod()) _v = 0;\r\n                return *this;\r\n            }\r\n            mint& operator -- () {\r\n                if (_v == 0) _v = umod();\r\n                _v--;\r\n                return *this;\r\n            }\r\n            mint operator ++ (int) {\r\n                mint r = *this;\r\n                ++(*this);\r\n                return r;\r\n            }\r\n            mint operator -- (int) {\r\n                mint r = *this;\r\n                --(*this);\r\n                return r;\r\n            }\r\n\r\n            mint& operator += (const mint &rhs) {\r\n                _v += rhs._v;\r\n                if (_v >= umod()) _v -= umod();\r\n                return *this;\r\n            }\r\n            mint& operator -= (const mint &rhs) {\r\n                _v -= rhs._v;\r\n                if (_v >= umod()) _v += umod();\r\n                return *this;\r\n            }\r\n            mint& operator *= (const mint &rhs) {\r\n                uLL z = (uLL)_v * rhs._v % umod();\r\n                _v = (ui)z;\r\n                return *this;\r\n            }\r\n            mint& operator /= (const mint &rhs) {\r\n                (*this) *= rhs.inv();\r\n                return *this;\r\n            }\r\n\r\n            mint operator + () const {\r\n                return *this;\r\n            }\r\n            mint operator - () const {\r\n                return mint() - *this;\r\n            }\r\n\r\n            friend mint operator + (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) += rhs;\r\n            }\r\n            friend mint operator - (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) -= rhs;\r\n            }\r\n            friend mint operator * (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) *= rhs;\r\n            }\r\n            friend mint operator / (const mint &lhs, const mint &rhs) {\r\n                return mint(lhs) /= rhs;\r\n            }\r\n            friend bool operator == (const mint &lhs, const mint &rhs) {\r\n                return lhs._v == rhs._v;\r\n            }\r\n            friend bool operator != (const mint &lhs, const mint &rhs) {\r\n                return lhs._v != rhs._v;\r\n            }\r\n\r\n            ui inv () const { \r\n                return inv_gcd(_v, mod()); \r\n            }\r\n\t\t\ttemplate<typename T>\r\n\t\t\tmint pow (T k) const {\r\n\t\t\t\tmint r = 1, b = *this;\r\n                for (; k; k >>= 1, b = b * b) if (k & 1) r = r * b;\r\n                return r;\r\n\t\t\t}\r\n    };\r\n    template<int id> barret dynamic_modint<id>::bt(998244353);\r\n}\r\n\r\nusing mint = Math::static_modint<998244353>;\r\nconst int N = 3e5 + 500;\r\nint n;\r\nmint fac[N], ifac[N], c[N];\r\n\r\ninline mint Binom (int i, int j) {\r\n\tif (i < j) return mint();\r\n\treturn fac[i] * ifac[j] * ifac[i - j];\r\n}\r\n\r\ninline void slv () {\r\n\tn = read();\r\n\tfac[0] = 1;\r\n\tfor (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;\r\n\tifac[n] = fac[n].inv();\r\n\tfor (int i = n - 1; ~i; i--) ifac[i] = ifac[i + 1] * (i + 1);\r\n\tc[1] = 1, c[2] = 2;\r\n\tfor (int i = 3; i <= n; i++) c[i] = c[i - 1] + c[i - 2] * (i - 1);\r\n\tmint as = 0;\r\n\tfor (int i = 0; i <= (n >> 2); i++) {\r\n\t\tint j = i << 1;\r\n\t\tas += Binom(n - j, j) * fac[j] * ifac[i] * c[n - (j << 1)];\r\n\t}\r\n\twriteln(as.val());\r\n}\r\n\r\nint main() {\r\n\tint T = read();\r\n\twhile (T--) slv();\r\n}\r\n// I love WHQ!"
}