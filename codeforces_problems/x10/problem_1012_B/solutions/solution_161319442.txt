{
    "id": 161319442,
    "contestId": 1012,
    "creationTimeSeconds": 1655738791,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1012,
        "index": "B",
        "name": "Chemical table",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "matrices"
        ]
    },
    "author": {
        "contestId": 1012,
        "members": [
            {
                "handle": "ishans1324"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1532938500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include<iostream>\r\nusing namespace std;\r\n#include<string>\r\n#include<algorithm>\r\n#include<vector>\r\n#include<string.h>\r\n#include<math.h>\r\n#include<map>\r\n#include<set>\r\n#define pb push_back\r\n#define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\r\n#define endl \"\\n\"\r\n\r\n#include<bits/stdc++.h>\r\nifstream fin (\"input.txt\");\r\nofstream fout (\"output.txt\");\r\n#define ff first\r\n#define sss second\r\ntypedef long long ll;\r\ntypedef pair<int,int>pii;\r\ntypedef pair<ll,ll>pl;\r\n\r\nll mod=1e9+7;\r\n#define all(x) x.begin(), x.end()\r\n#define bpc(x) __builtin_popcountll(x)\r\n/*\r\nPBDS op\r\n*#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\n\r\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\r\n*/\r\n\r\nint lcs(string X, string Y)\r\n{\r\n    int m=X.size();\r\n    int n=Y.size();\r\n    int L[m + 1][n + 1];\r\n    int i, j;\r\n    for (i = 0; i <= m; i++) {\r\n        for (j = 0; j <= n; j++) {\r\n            if (i == 0 || j == 0)\r\n                L[i][j] = 0;\r\n\r\n            else if (X[i - 1] == Y[j - 1])\r\n                L[i][j] = L[i - 1][j - 1] + 1;\r\n\r\n            else\r\n                L[i][j] = max(L[i - 1][j], L[i][j - 1]);\r\n        }\r\n    }\r\n    return L[m][n];\r\n}\r\n\r\nll pow_with_mod(ll a,ll b, ll mod=1e9+7)\r\n{\r\n    ll res=1;\r\n    while(b)\r\n    {\r\n        if(b&1)\r\n        res=(res*a)%mod;\r\n        a=(a*a)%mod;\r\n        b>>=1;\r\n    }\r\n    return res;\r\n}\r\nll power(ll a,ll b)\r\n{\r\n    ll res=1;\r\n    while(b)\r\n    {\r\n        if(b&1)\r\n        res=(res*a);\r\n        a=(a*a);\r\n        b>>=1;\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nint sod(ll x)\r\n{\r\n    int res=0;\r\n    while(x)\r\n    {\r\n        int a=x%10;\r\n        res+=a;\r\n        x/=10;\r\n    }\r\n    return res;\r\n}\r\n\r\nbool is_prime(ll n)\r\n{\r\n\r\n    for (ll i = 2; i <=sqrt(n); i++)\r\n        if (n % i == 0)\r\n            return false;\r\n\r\n    return true;\r\n}\r\n\r\n\r\nll modInverse(ll n, ll p)\r\n{\r\n    return pow_with_mod(n, p - 2, p);\r\n}\r\n\r\nll ncrMod(ll n, ll r,ll p,ll fact[])\r\n{\r\n    if (n < r)\r\n        return 0;\r\n\r\n    if (r == 0)\r\n        return 1;\r\n\r\n\r\n    return (fact[n] * modInverse(fact[r], p) % p\r\n            * modInverse(fact[n - r], p) % p)\r\n           % p;\r\n\r\n}\r\n\r\nbool is_palind(string s)\r\n{\r\n    ll i=0,j=s.size()-1;\r\n    while(i<j)\r\n    {\r\n        if(s[i]!=s[j])\r\n            return 0;\r\n        i++;\r\n        j--;\r\n    }\r\n    return 1;\r\n}\r\n\r\nvoid dfstemp(ll u,vector<ll>adj[],ll visited[],vector<ll>&temp)\r\n{\r\n    visited[u]=1;\r\n    temp.pb(u);\r\n    for(ll v:adj[u])\r\n    {\r\n        if(visited[v]==0)\r\n            dfstemp(v,adj,visited,temp);\r\n    }\r\n}\r\n\r\nlong double dis(ll x1,ll y1,ll x2,ll y2)\r\n{\r\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n}\r\nll sdis(ll x1,ll y1,ll x2,ll y2)\r\n{\r\n    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\r\n}\r\n\r\nvoid topologicalSortUtil(ll u,ll visited[],stack<int>& Stack,vector<ll>adj[])\r\n{\r\n\r\n    visited[u] = true;\r\n\r\n    for(ll v:adj[u])\r\n    {\r\n        if(visited[v]==0)\r\n             topologicalSortUtil(v, visited, Stack,adj);\r\n    }\r\n\r\n    Stack.push(u);\r\n}\r\n\r\nvector<vector<ll>> floydWarshall(vector<vector<ll>>graph,ll V)\r\n{\r\n    ll INF=1e18;\r\n    vector<vector<ll>>dist(V,vector<ll>(V));\r\n\r\n    int i, j, k;\r\n    for (i = 0; i < V; i++)\r\n        for (j = 0; j < V; j++)\r\n            dist[i][j] = graph[i][j];\r\n\r\n    for (k = 0; k < V; k++) {\r\n        for (i = 0; i < V; i++) {\r\n            for (j = 0; j < V; j++) {\r\n                if (dist[i][j] > (dist[i][k] + dist[k][j])&& (dist[k][j] != INF&& dist[i][k] != INF))\r\n                    dist[i][j] = dist[i][k] + dist[k][j];\r\n            }\r\n        }\r\n    }\r\n    return dist;\r\n}\r\n\r\nint findparent(int x,ll par[])\r\n{\r\n    if(par[x]!=x)\r\n        return par[x]=findparent(par[x],par);\r\n    return x;\r\n}\r\nvoid uni(ll x,ll y,ll red[],ll par[])\r\n{\r\n    if(red[x]<red[y])\r\n        swap(x,y);\r\n    par[y]=x;\r\n    red[x]+=red[y];\r\n}\r\n\r\n\r\nvoid computeLPSArray(string pat, int M, int* lps);\r\n\r\nvector<ll>KMPSearch(string pat, string txt)\r\n{\r\n    int M = pat.size();\r\n    int N = txt.size();\r\n    vector<ll>res;\r\n\r\n    int lps[M];\r\n    computeLPSArray(pat, M, lps);\r\n\r\n    int i = 0;\r\n    int j = 0;\r\n    while (i < N) {\r\n        if (pat[j] == txt[i]) {\r\n            j++;\r\n            i++;\r\n        }\r\n\r\n        if (j == M) {\r\n            res.pb(i-j);\r\n            //printf(\"Found pattern at index %d \", i - j);\r\n            j = lps[j - 1];\r\n        }\r\n\r\n        else if (i < N && pat[j] != txt[i]) {\r\n\r\n            if (j != 0)\r\n                j = lps[j - 1];\r\n            else\r\n                i = i + 1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid computeLPSArray(string  pat, int M, int* lps)\r\n{\r\n    int len = 0;\r\n\r\n    lps[0] = 0;\r\n    int i = 1;\r\n    while (i < M) {\r\n        if (pat[i] == pat[len]) {\r\n            len++;\r\n            lps[i] = len;\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            if (len != 0) {\r\n                len = lps[len - 1];\r\n\r\n            }\r\n            else\r\n            {\r\n                lps[i] = 0;\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    FIO;\r\n    int tc=1;\r\n    //cin>>tc;\r\n\r\n    for(int testc=1;testc<=tc;testc++)\r\n    {\r\n      ll n,m,q;\r\n      cin>>n>>m>>q;\r\n      //set<ll>row,col;\r\n      vector<ll>col[n+1];\r\n      set<ll>x;\r\n\r\n      for(int i=0;i<q;i++)\r\n      {\r\n          ll r,c;\r\n          cin>>r>>c;\r\n          col[c].pb(r);\r\n          x.insert(c);\r\n      }\r\n\r\n      ll res=m-x.size();\r\n      ll parent[n+1],red[n+1];\r\n\r\n      for(int i=1;i<=n;i++)\r\n      {\r\n          parent[i]=i,red[i]=1;\r\n      }\r\n\r\n      for(int i=1;i<=m;i++)\r\n      {\r\n          if(col[i].size()==0)\r\n            continue;\r\n          for(int j=0;j<col[i].size()-1;j++)\r\n          {\r\n              ll x=findparent(col[i][j],parent);\r\n              ll y=findparent(col[i][j+1],parent);\r\n              if(x!=y)\r\n                uni(x,y,red,parent);\r\n          }\r\n\r\n      }\r\n\r\n      ll comp=0;\r\n      for(int i=1;i<=n;i++)\r\n      {\r\n          ll x=findparent(i,parent);\r\n          if(x==i)\r\n            comp++;\r\n      }\r\n      cout<<res+comp-1<<endl;\r\n\r\n\r\n\r\n\r\n    }\r\n}\r\n"
}