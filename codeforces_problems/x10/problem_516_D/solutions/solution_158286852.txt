{
    "id": 158286852,
    "contestId": 516,
    "creationTimeSeconds": 1653387796,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 516,
        "index": "D",
        "name": "Drazil and Morning Exercise",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2800,
        "tags": [
            "dfs and similar",
            "dp",
            "dsu",
            "trees",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 516,
        "members": [
            {
                "handle": "Iscream2001"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1424190900
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 42,
    "timeConsumedMillis": 1528,
    "memoryConsumedBytes": 24268800,
    "source": "#include<bits/stdc++.h>\r\n#define LD long double\r\n#define LL long long\r\n#define pb push_back\r\n#define pii pair<int,int>\r\nusing namespace std;\r\nconst LL INF=1e18;\r\nconst int inf=1e9;\r\nconst LD PI=acos(-1.0);\r\n//const LL M=998244353;\r\nLL M=1e9+7;\r\n//const LL P=998244353;\r\nconst int N=1e5+10;\r\nconst LD eps=1e-8;\r\nconst LD eps2=1e-10;\r\n\r\nint ran=0;\r\nbool rand01(){\r\n\twhile(!ran) ran=abs(rand());\r\n\tbool res=ran&1;ran>>=1;\r\n\treturn res;\r\n}\r\n\r\n//\r\nLL qpow(LL x,LL y,LL mod=M){\r\n\tx%=mod;\r\n\tLL re=1;\r\n\twhile(y){\r\n\t\tif(y&1) re=re*x%mod;\r\n\t\ty>>=1;x=x*x%mod;\r\n\t}\r\n\treturn re;\r\n}\r\n\r\nint B_S(int *a,int l,int r,int x){\r\n\tint mid;\r\n\twhile(l<=r){\r\n\t\tmid=(l+r)/2;\r\n\t\tif(a[mid]==x) return mid;\r\n\t\ta[mid]>x?r=mid-1:l=mid+1;\r\n\t}\r\n\treturn -1;\r\n}\r\nLL B_S2(LL *a,int l,int r,LL x){\r\n\tint mid;\r\n\tif(a[r]<x) return -1;\r\n\twhile(l!=r){\r\n\t\tmid=(l+r)/2;\r\n\t\tif(a[mid]<x) l=mid+1;\r\n\t\telse r=mid;\r\n\t}\r\n\treturn l;\r\n}\r\n\r\nint lowbit(int x){\r\n\treturn (x&-x);\r\n}\r\nint popcount(int x){\r\n\treturn x==0?0:1+popcount(x-lowbit(x));\r\n}\r\n\r\nLL getphi(LL x){\r\n\tLL re=1;\r\n\tfor(LL i=2;i*i<=x;++i){\r\n\t\tif(x%i==0){\r\n\t\t\tx/=i;re*=(i-1);\r\n\t\t\twhile(x%i==0){\r\n\t\t\t\tx/=i;\r\n\t\t\t\tre*=i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(x>1){\r\n\t\tre=re*(x-1);\r\n\t}\r\n\treturn re;\r\n}\r\n\r\n//struct jz{\r\n//\tLL x[12][12];\r\n//};\r\n//jz operator * (jz A,jz B){\r\n//\tjz C;\r\n//\tfor(int i=1;i<=9;++i){\r\n//\t\tfor(int j=1;j<=9;++j){\r\n//\t\t\tC.x[i][j]=0;\r\n//\t\t}\r\n//\t}\r\n//\tfor(int i=1;i<=9;++i){\r\n//\t\tfor(int k=1;k<=9;++k){\r\n//\t\t\tif(A.x[i][k]!=0){\r\n//\t\t\t\tfor(int j=1;j<=9;++j){\r\n//\t\t\t\t\t(C.x[i][j]+=A.x[i][k]*B.x[k][j]%M)%=M;\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n//\t}\r\n//\treturn C;\r\n//}\r\n////inline char gc(){return getchar();}\r\n//bool is_pri[N+10];\r\n//LL pri[6000000];\r\n////int mu[N+10];\r\n//int cntp=0;\r\n//\r\n//void init_pri(){\r\n////\tmu[1]=1;\r\n//    for(int i=2;i<=N;++i){\r\n//        if(!is_pri[i]) {\r\n//            pri[++cntp]=i;\r\n//  //          mu[i]=-1;\r\n//        }\r\n//        for(int j=1;j<=cntp&&pri[j]*i<=N;++j){\r\n//            is_pri[pri[j]*i]=1;\r\n//            if(i%pri[j]==0) {\r\n//    //        \tmu[pri[j]*i]=0;\r\n//                break;\r\n//            }\r\n//            else{\r\n//      //      \tmu[pri[j]*i]=-mu[i];\r\n//\t\t\t}\r\n//        }\r\n//    }\r\n//}\r\n\r\n//struct P{\r\n//\tLD x,y;\r\n//\tP(LD _x=0,LD _y=0){x=_x;y=_y;}\r\n//}used,a[550],b[550];\r\n//\r\n//LD dis(P x){return x.x*x.x+x.y*x.y;}\r\n//P operator + (P x,P y){return P(x.x+y.x,x.y+y.y);}\r\n//P operator - (P x,P y){return P(x.x-y.x,x.y-y.y);}\r\n//LD operator * (P x,P y){return x.x*y.x+x.y*y.y;}\r\n//P operator * (P x,LD y){return P(x.x*y,x.y*y);}\r\n//LD operator / (P x,P y){return x.x*y.y-x.y*y.x;}\r\n//P operator / (P x,LD y){return P(x.x/y,x.y/y);}\r\n//P dwh(P x){LD w=sqrt(dis(x));return x/w;}\r\n//P rotate(P x,LD th){return P(x.x*cos(th)-x.y*sin(th),x.x*sin(th)+x.y*cos(th));}\r\n//\r\n//P waixin(LD x1,LD y1,LD x2,LD y2,LD x3,LD y3){\r\n//double a,b,c,p;\r\n//double  aa,bb,zz,aa1,bb1,zz1;\r\n//\ta=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n//    b=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));\r\n//    c=sqrt((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2));\r\n//    aa=2*(x1-x2);\r\n//    bb=2*(y1-y2);\r\n//    zz=x1*x1-x2*x2+y1*y1-y2*y2;\r\n//    aa1=2*(x3-x2);\r\n//    bb1=2*(y3-y2);\r\n//    zz1=x3*x3-x2*x2+y3*y3-y2*y2;\r\n//    printf(\"%.2lf %.2lf\\n\",((zz*bb1)-(zz1*bb))/((aa*bb1)-(aa1*bb)),\r\n//           ((aa*zz1)-(aa1*zz))/((aa*bb1)-(aa1*bb)));\r\n//    return P(((zz*bb1)-(zz1*bb))/((aa*bb1)-(aa1*bb)),\r\n//           ((aa*zz1)-(aa1*zz))/((aa*bb1)-(aa1*bb)));\r\n//}\r\n\r\n//LL fac[1000005],finv[1000005];\r\n//LL C(LL x,LL y,LL mod=M){\r\n//\tif(x<y) return 0;\r\n//\tif(x<=1000000) return fac[x]*finv[y]%mod*finv[x-y]%mod;\r\n//\tLL re=1;\r\n//\ty=min(y,x-y);\r\n//\tfor(LL i=x-y+1;i<=x;++i){\r\n//\t\tre=re*i%M;\r\n//\t}\r\n//\tre=re*finv[y]%M;\r\n//\treturn re;\r\n//}\r\n//void init(){\r\n//\tfac[0]=fac[1]=finv[0]=finv[1]=1;\r\n//\tfor(LL i=2;i<=1000000;++i) fac[i]=fac[i-1]*i%M;\r\n//\tfinv[1000000]=qpow(fac[1000000],M-2,M);\r\n//\tfor(LL i=1000000;i>1;--i) finv[i-1]=finv[i]*i%M;\r\n//\treturn;\r\n//}\r\n\r\nstruct HeapNode{\r\n\tLL x;\r\n};\r\n\r\nbool operator < (HeapNode x,HeapNode y){\r\n\treturn x.x<y.x;\r\n}\r\n\r\nstruct HeapTree{\r\n\tint n,op;\r\n\tint ch[N][2],rt[N];\r\n\tbool die[N];\r\n\tHeapNode he[N];\r\n\tvoid init(){\r\n\t\tn=0;rt[0]=0;return;\r\n\t}\r\n\tint NewNode(HeapNode K){\r\n\t\t++n;\r\n\t\the[n]=K;\r\n\t\tch[n][0]=ch[n][1]=0;\r\n\t\trt[n]=n;\r\n\t\tdie[n]=0;\r\n\t\treturn n;\r\n\t}\r\n\tint merge(int x,int y){\r\n\t\tif(x==0||y==0) return x|y;\r\n\t\tif(he[x]<he[y]) swap(x,y);\r\n\t\top^=rand01();\r\n\t\tch[x][op]=merge(ch[x][op],y);\r\n\t\treturn x;\r\n\t}\r\n\tint findrt(int x){\r\n\t\treturn rt[x]==x?x:rt[x]=findrt(rt[x]);\r\n\t}\r\n\tbool empty(int x){\r\n\t\treturn die[x];\r\n\t}\r\n\tHeapNode top(int x){\r\n\t\tx=findrt(x);\r\n\t\treturn he[x];\r\n\t}\r\n\tvoid pop(int x){\r\n\t\tif(die[x]) return;\r\n\t\tx=findrt(x);\r\n\t\trt[x]=merge(ch[x][0],ch[x][1]);\r\n\t\trt[rt[x]]=rt[x];\r\n\t\t\r\n\t\tdie[x]=1;\r\n\t\treturn;\r\n\t}\r\n\tint uni(int x,int y){\r\n\t\tif(die[x]) x=0;\r\n\t\tif(die[y]) y=0;\r\n\t\tx=findrt(x);\r\n\t\ty=findrt(y);\r\n\t\tif(x==y||x==0||y==0) return x|y;\r\n\t\tint z=merge(x,y);\r\n\t\trt[x]=rt[y]=z;\r\n\t\treturn z;\r\n\t}\r\n}Heap1;\r\n\r\nint n,m,rt;\r\n\r\nstruct edge{\r\n\tint r,w;\r\n};\r\n\r\nvector<edge> V[N];\r\n\r\nLL lim;\r\nLL dis[N],val[N];\r\n\r\nvoid dfs1(int x,int fa){\r\n\tfor(auto ed:V[x]){\r\n\t\tint y=ed.r;\r\n\t\tif(y==fa) continue;\r\n\t\tdis[y]=dis[x]+ed.w;\r\n\t\tdfs1(y,x);\r\n\t}\r\n}\r\n\r\nint siz[N];\r\nvoid dfs2(int x,int fa){\r\n\tsiz[x]=1;\r\n\tfor(auto ed:V[x]){\r\n\t\tint y=ed.r;\r\n\t\tif(y==fa) continue;\r\n\t\tdfs2(y,x);\r\n\t\tHeap1.uni(x,y);\r\n\t\tsiz[x]+=siz[y];\r\n\t}\r\n\twhile(siz[x]>0&&Heap1.top(x).x>val[x]+lim){\r\n\t\tHeap1.pop(x);\r\n\t\tsiz[x]--;\r\n\t}\r\n}\r\n\r\nvoid MAIN(){\r\n\tint u,v,w;\r\n\tcin>>n;\r\n\tfor(int i=1;i<=n;++i) {\r\n\t\tval[i]=0;\r\n\t}\r\n\tfor(int i=1;i<n;++i){\r\n\t\tcin>>u>>v>>w;\r\n\t\tV[u].pb((edge){v,w});\r\n\t\tV[v].pb((edge){u,w});\r\n\t}\r\n\trt=1;\r\n\tdis[rt]=0;dfs1(rt,0);\r\n\trt=1;for(int i=1;i<=n;++i) {\r\n\t\tif(dis[i]>dis[rt]) rt=i;\r\n\t}\r\n\tdis[rt]=0;dfs1(rt,0);\r\n\tfor(int i=1;i<=n;++i) {\r\n\t\tval[i]=max(val[i],dis[i]);\r\n\t\tif(dis[i]>dis[rt]) rt=i;\r\n\t}\r\n\tdis[rt]=0;dfs1(rt,0);\r\n\tfor(int i=1;i<=n;++i) {\r\n\t\tval[i]=max(val[i],dis[i]);\r\n\t}\r\n\tfor(int i=1;i<=n;++i){\r\n\t\tif(val[i]<val[rt]) rt=i;\r\n\t}\r\n\t\r\n\t\r\n\tcin>>m;\r\n\tint ans;\r\n\twhile(m--){\r\n\t\tcin>>lim;ans=0;\r\n\t\tHeap1.init();\r\n\t\tfor(int i=1;i<=n;++i){\r\n\t\t\tHeap1.NewNode((HeapNode){val[i]});\r\n\t\t}\r\n\t\tdfs2(rt,0);\r\n\t\tfor(int i=1;i<=n;++i) ans=max(ans,siz[i]);\r\n\t\tcout<<ans<<endl;\r\n\t}\r\n\treturn;\r\n}\r\n/*\r\n*/\r\nint main(){\r\n\tsrand(time(0));\r\n\tstd::ios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n//\tfreopen(\"1.in\",\"r\",stdin);\r\n//\tfreopen(\"1.out\",\"w\",stdout);\r\n//\tinit();\r\n//\tinit_pri();\r\n\tint ttt=1;//cin>>ttt; \r\n\tfor(int i=1;i<=ttt;++i){\r\n\t\t//printf(\"Case #%d: \",i);\r\n\t\tMAIN();\r\n\t}\r\n\treturn 0;\r\n} \r\n/*\r\n4 2\r\n1 2 3\r\n3 4 5\r\n*/"
}