{
    "id": 150460619,
    "contestId": 213,
    "creationTimeSeconds": 1647957454,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 213,
        "index": "E",
        "name": "Two Permutations",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2700,
        "tags": [
            "data structures",
            "hashing",
            "strings"
        ]
    },
    "author": {
        "contestId": 213,
        "members": [
            {
                "handle": "vwxyz0"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1343662200
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 2994,
    "memoryConsumedBytes": 68403200,
    "source": "from random import randint\r\nimport sys\r\nreadline=sys.stdin.readline\r\n\r\nclass Segment_Tree:\r\n    def __init__(self,N,f,e,lst=None):\r\n        self.f=f\r\n        self.e=e\r\n        self.N=N\r\n        if lst==None:\r\n            self.segment_tree=[self.e]*2*self.N\r\n        else:\r\n            assert len(lst)<=self.N\r\n            self.segment_tree=[self.e]*self.N+[x for x in lst]+[self.e]*(N-len(lst))\r\n            for i in range(self.N-1,0,-1):\r\n                self.segment_tree[i]=self.f(self.segment_tree[i<<1],self.segment_tree[i<<1|1])\r\n\r\n    def __getitem__(self,i):\r\n        if type(i)==int:\r\n            if -self.N<=i<0:\r\n                return self.segment_tree[i+self.N*2]\r\n            elif 0<=i<self.N:\r\n                return self.segment_tree[i+self.N]\r\n            else:\r\n                raise IndexError('list index out of range')\r\n        else:\r\n            a,b,c=i.start,i.stop,i.step\r\n            if a==None:\r\n                a=self.N\r\n            else:\r\n                a+=self.N\r\n            if b==None:\r\n                b=self.N*2\r\n            else:\r\n                b+=self.N\r\n            return self.segment_tree[slice(a,b,c)]\r\n\r\n    def __setitem__(self,i,x):\r\n        if -self.N<=i<0:\r\n            i+=self.N*2\r\n        elif 0<=i<self.N:\r\n            i+=self.N\r\n        else:\r\n            raise IndexError('list index out of range')\r\n        self.segment_tree[i]=x\r\n        while i>1:\r\n            i>>= 1\r\n            self.segment_tree[i]=self.f(self.segment_tree[i<<1],self.segment_tree[i<<1|1])\r\n\r\n    def Build(self,lst):\r\n        for i,x in enumerate(lst,self.N):\r\n            self.segment_tree[i]=x\r\n        for i in range(self.N-1,0,-1):\r\n            self.segment_tree[i]=self.f(self.segment_tree[i<<1],self.segment_tree[i<<1|1])\r\n\r\n    def Fold(self,L=None,R=None):\r\n        if L==None:\r\n            L=self.N\r\n        else:\r\n            L+=self.N\r\n        if R==None:\r\n            R=self.N*2\r\n        else:\r\n            R+=self.N\r\n        vL=self.e\r\n        vR=self.e\r\n        while L<R:\r\n            if L&1:\r\n                vL=self.f(vL,self.segment_tree[L])\r\n                L+=1\r\n            if R&1:\r\n                R-=1\r\n                vR=self.f(self.segment_tree[R],vR)\r\n            L>>=1\r\n            R>>=1\r\n        return self.f(vL,vR)\r\n\r\n    def Fold_Index(self,L=None,R=None):\r\n        if L==None:\r\n            L=self.N\r\n        else:\r\n            L+=self.N\r\n        if R==None:\r\n            R=self.N*2\r\n        else:\r\n            R+=self.N\r\n        if L==R:\r\n            return None\r\n        x=self.Fold(L-self.N,R-self.N)\r\n        while L<R:\r\n            if L&1:\r\n                if self.segment_tree[L]==x:\r\n                    i=L\r\n                    break\r\n                L+=1\r\n            if R&1:\r\n                R-=1\r\n                if self.segment_tree[R]==x:\r\n                    i=R\r\n                    break\r\n            L>>=1\r\n            R>>=1\r\n        while i<self.N:\r\n            if self.segment_tree[i]==self.segment_tree[i<<1]:\r\n                i<<=1\r\n            else:\r\n                i<<=1\r\n                i|=1\r\n        i-=self.N\r\n        return i\r\n\r\n    def Bisect_Right(self,L=None,f=None):\r\n        if L==self.N:\r\n            return self.N\r\n        if L==None:\r\n            L=0\r\n        L+=self.N\r\n        vl=self.e\r\n        vr=self.e\r\n        l,r=L,self.N*2\r\n        while l<r:\r\n            if l&1:\r\n                vl=self.f(vl,self.segment_tree[l])\r\n                l+=1\r\n            if r&1:\r\n                r-=1\r\n                vr=self.f(self.segment_tree[r],vr)\r\n            l>>=1\r\n            r>>=1\r\n        if f(self.f(vl,vr)):\r\n            return self.N\r\n        v=self.e\r\n        while True:\r\n            while L%2==0:\r\n                L>>=1\r\n            vv=self.f(v,self.segment_tree[L])\r\n            if f(vv):\r\n                v=vv\r\n                L+=1\r\n            else:\r\n                while L<self.N:\r\n                    L<<=1\r\n                    vv=self.f(v,self.segment_tree[L])\r\n                    if f(vv):\r\n                        v=vv\r\n                        L+=1\r\n                return L-self.N\r\n\r\n    def Bisect_Left(self,R=None,f=None):\r\n        if R==0:\r\n            return 0\r\n        if R==None:\r\n            R=self.N\r\n        R+=self.N\r\n        vl=self.e\r\n        vr=self.e\r\n        l,r=self.N,R\r\n        while l<r:\r\n            if l&1:\r\n                vl=self.f(vl,self.segment_tree[l])\r\n                l+=1\r\n            if r&1:\r\n                r-=1\r\n                vr=self.f(self.segment_tree[r],vr)\r\n            l>>=1\r\n            r>>=1\r\n        if f(self.f(vl,vr)):\r\n            return 0\r\n        v=self.e\r\n        while True:\r\n            R-=1\r\n            while R>1 and R%2:\r\n                R>>=1\r\n            vv=self.f(self.segment_tree[R],v)\r\n            if f(vv):\r\n                v=vv\r\n            else:\r\n                while R<self.N:\r\n                    R=2*R+1\r\n                    vv=self.f(self.segment_tree[R],v)\r\n                    if f(vv):\r\n                        v=vv\r\n                        R-=1\r\n                return R+1-self.N\r\n\r\n    def __str__(self):\r\n        return '['+', '.join(map(str,self.segment_tree[self.N:]))+']'\r\n\r\nN,M=map(int,readline().split())\r\nA=list(map(int,readline().split()))\r\nB=list(map(int,readline().split()))\r\nidxA=[None]*N\r\nidxB=[None]*M\r\nfor i in range(N):\r\n    A[i]-=1\r\n    idxA[A[i]]=i\r\nfor i in range(M):\r\n    B[i]-=1\r\n    idxB[B[i]]=i\r\nbase=randint(1<<53,1<<60)\r\nmod=(1<<61)-1\r\nbase_pow=[1]\r\nfor i in range(1,M+1):\r\n    base_pow.append(base_pow[-1]*base%mod)\r\ndef f(tpl0,tpl1):\r\n    x0,y0=tpl0\r\n    x1,y1=tpl1\r\n    return (x0+x1,(y0+y1)%mod)\r\nans=0\r\nhashA=sum(idxA[i]*base_pow[i]%mod for i in range(N))%mod\r\ncomp={x:i for i,x in enumerate(sorted(idxB[:N]))}\r\nhashB=sum(comp[idxB[i]]*base_pow[i]%mod for i in range(N))%mod\r\nif hashA==hashB:\r\n    ans+=1\r\nlst=[(0,0)]*M\r\nX,Y=0,0\r\nfor i in range(N):\r\n    lst[idxB[i]]=(1,base_pow[i])\r\n    X+=1\r\n    Y+=base_pow[i]\r\n    Y%=mod\r\nST=Segment_Tree(M,f,(0,0),lst)\r\nfor i in range(M-N):\r\n    x,y=ST[idxB[i]]\r\n    X-=x\r\n    Y-=y\r\n    Y%=mod\r\n    ST[idxB[i]]=(0,0)\r\n    x,y=ST.Fold(0,idxB[i])\r\n    y=Y-y\r\n    hashB-=x*base_pow[i]%mod+y\r\n    hashB%=mod\r\n    ST[idxB[i+N]]=(1,base_pow[i+N])\r\n    X+=1\r\n    Y+=base_pow[i+N]\r\n    Y%=mod\r\n    x,y=ST.Fold(0,idxB[i+N])\r\n    y=Y-y-base_pow[i+N]\r\n    hashB+=x*base_pow[i+N]%mod+y\r\n    hashB%=mod\r\n    if hashA*base_pow[i+1]%mod==hashB:\r\n        ans+=1\r\nprint(ans)"
}