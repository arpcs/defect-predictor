{
    "id": 229705955,
    "contestId": 1713,
    "creationTimeSeconds": 1698243367,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1713,
        "index": "D",
        "name": "Tournament Countdown",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 1800,
        "tags": [
            "constructive algorithms",
            "greedy",
            "interactive",
            "number theory",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1713,
        "members": [
            {
                "handle": "blackThread"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1659796500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 33,
    "timeConsumedMillis": 717,
    "memoryConsumedBytes": 3788800,
    "source": "#include <bits/stdc++.h>\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define r_all(x) x.rbegin(), x.rend()\r\n#define sz(x) (ll) x.size()\r\n#define g_max(x, y) x = max(x, y)\r\n#define g_min(x, y) x = min(x, y)\r\n#define rsz(a, n) a.resize(n)\r\n#define ass(a, n) a.assign(n, 0)\r\n#define YES() cout << \"YES\\n\"\r\n#define Yes() cout << \"Yes\\n\"\r\n#define NO() cout << \"NO\\n\"\r\n#define No() cout << \"No\\n\"\r\n#define endl \"\\n\"\r\n#define print(a)          \\\r\n    for (auto &x : a)     \\\r\n        cout << x << \" \"; \\\r\n    cout << endl\r\n#define print_pair(a)\r\n#define FOR(i, fr, to) for (long long i = fr; i <= to; i++)\r\n#define RFOR(i, fr, to) for (long long i = fr; i >= to; i--)\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define mp make_pair\r\n#define is insert\r\n#define F first\r\n#define S second\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing ld = long double;\r\n\r\nusing vll = vector<ll>;\r\nusing vvll = vector<vll>;\r\nusing vc = vector<char>;\r\nusing vvc = vector<vc>;\r\nusing pll = pair<ll, ll>;\r\nusing vpll = vector<pll>;\r\nusing vvpll = vector<vpll>;\r\nusing stkll = stack<ll>;\r\nusing qll = queue<ll>;\r\nusing dqll = deque<ll>;\r\nusing sll = set<ll>;\r\nusing msll = multiset<ll>;\r\nusing mll = map<ll, ll>;\r\nusing vsll = vector<sll>;\r\nusing sc = set<char>;\r\nusing pcll = pair<char, ll>;\r\n\r\nll dr[] = {0, 1, 0, -1}, dc[] = {-1, 0, 1, 0};\r\nstring ds = {'L', 'D', 'R', 'U'};\r\n// ll dr[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\r\n// ll dc[8] = {0, 1, 1, 1, 0, -1, -1, -1};\r\n\r\nconst ll INF = 1e18;\r\nconst double PI = 3.1415926535897;\r\nll MOD = 1e9 + 7;\r\n\r\nstruct MLong\r\n{\r\n    ll val;\r\n\r\n    MLong() { val = 0; }\r\n\r\n    MLong(const ll &v)\r\n    {\r\n        val = (-MOD <= v && v < MOD) ? v : v % MOD;\r\n        if (val < 0)\r\n            val += MOD;\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const MLong &a) { return os << a.val; }\r\n\r\n    friend bool operator==(const MLong &a, const MLong &b) { return a.val == b.val; }\r\n\r\n    friend bool operator!=(const MLong &a, const MLong &b) { return !(a == b); }\r\n\r\n    friend bool operator<(const MLong &a, const MLong &b) { return a.val < b.val; }\r\n\r\n    MLong operator-() const { return MLong(-val); }\r\n\r\n    MLong &operator+=(const MLong &m)\r\n    {\r\n        if ((val += m.val) >= MOD)\r\n            val -= MOD;\r\n        return *this;\r\n    }\r\n\r\n    MLong &operator-=(const MLong &m)\r\n    {\r\n        if ((val -= m.val) < 0)\r\n            val += MOD;\r\n        return *this;\r\n    }\r\n\r\n    MLong &operator*=(const MLong &m)\r\n    {\r\n        val = (ll)val * m.val % MOD;\r\n        return *this;\r\n    }\r\n\r\n    friend MLong ipow(MLong a, ll p)\r\n    {\r\n        MLong ans = 1;\r\n        for (; p; p /= 2, a *= a)\r\n            if (p & 1)\r\n                ans *= a;\r\n        return ans;\r\n    }\r\n\r\n    friend MLong inv(const MLong &a)\r\n    {\r\n        assert(a.val);\r\n        return ipow(a, MOD - 2);\r\n    }\r\n\r\n    MLong &operator/=(const MLong &m) { return (*this) *= inv(m); }\r\n\r\n    friend MLong operator+(MLong a, const MLong &b) { return a += b; }\r\n\r\n    friend MLong operator-(MLong a, const MLong &b) { return a -= b; }\r\n\r\n    friend MLong operator*(MLong a, const MLong &b) { return a *= b; }\r\n\r\n    friend MLong operator/(MLong a, const MLong &b) { return a /= b; }\r\n\r\n    operator int64_t() const { return val; }\r\n};\r\n\r\ntemplate <class T>\r\nvector<T> operator+(vector<T> a, vector<T> b)\r\n{\r\n    a.insert(a.end(), b.begin(), b.end());\r\n    return a;\r\n}\r\n\r\npll operator+(pll a, pll b)\r\n{\r\n    pll ans = {a.first + b.first, a.second + b.second};\r\n    return ans;\r\n}\r\n\r\ntemplate <class A, class B>\r\nostream &operator<<(ostream &os,\r\n                    const pair<A, B> &p)\r\n{\r\n    os << p.first << \" \" << p.second;\r\n    return os;\r\n}\r\n\r\ntemplate <class A, class B>\r\nistream &operator>>(istream &is, pair<A, B> &p)\r\n{\r\n    is >> p.first >> p.second;\r\n    return is;\r\n}\r\n\r\ntemplate <class T>\r\nostream &operator<<(ostream &os,\r\n                    const vector<T> &vec)\r\n{\r\n    for (auto &x : vec)\r\n    {\r\n        os << x << \" \";\r\n    }\r\n\r\n    return os;\r\n}\r\n\r\ntemplate <class T>\r\nistream &operator>>(istream &is, vector<T> &vec)\r\n{\r\n    for (auto &x : vec)\r\n    {\r\n        is >> x;\r\n    }\r\n\r\n    return is;\r\n}\r\n\r\ntemplate <class T>\r\nostream &operator<<(ostream &os,\r\n                    const set<T> &vec)\r\n{\r\n    for (auto &x : vec)\r\n    {\r\n        os << x << \" \";\r\n    }\r\n\r\n    return os;\r\n}\r\n\r\ntemplate <class A, class B>\r\nostream &operator<<(ostream &os,\r\n                    const map<A, B> d)\r\n{\r\n    for (auto &x : d)\r\n    {\r\n        os << \"(\" << x.first << \" \" << x.second << \") \";\r\n    }\r\n\r\n    return os;\r\n}\r\n\r\ntemplate <class A>\r\nvoid read_arr(A a[], ll from, ll to)\r\n{\r\n    for (ll i = from; i <= to; i++)\r\n    {\r\n        cin >> a[i];\r\n    }\r\n}\r\n\r\ntemplate <class A>\r\nvoid print_arr(A a[], ll from, ll to)\r\n{\r\n    for (ll i = from; i <= to; i++)\r\n    {\r\n        cout << a[i] << \" \";\r\n    }\r\n    cout << \"\\n\";\r\n}\r\n\r\ntemplate <class A>\r\nvoid print_arr(A a[], ll n)\r\n{\r\n    print_arr(a, 0, n - 1);\r\n}\r\n\r\ntemplate <class A>\r\nvoid set_arr(A a[], A val, ll from, ll to)\r\n{\r\n    for (ll i = from; i <= to; i++)\r\n    {\r\n        a[i] = val;\r\n    }\r\n}\r\n\r\ntemplate <class A>\r\nvoid set_arr(A a[], A val, ll n)\r\n{\r\n    set_arr(a, val, 0, n - 1);\r\n}\r\n\r\nll sq(ll x)\r\n{\r\n    return x * x;\r\n}\r\n\r\nMLong sq(MLong x)\r\n{\r\n    return MLong(x * x);\r\n}\r\n\r\nconst ll N = 2e5 + 10;\r\n\r\nll n, k, q, m;\r\nll a[N];\r\nstring s, s1, s2, s3;\r\n\r\nvoid init()\r\n{\r\n}\r\n\r\nll get_ans()\r\n{\r\n}\r\n\r\nll ask(ll x, ll y)\r\n{\r\n    cout << \"? \" << mp(x + 1, y + 1) << \"\\n\";\r\n    cout.flush();\r\n    ll res;\r\n    cin >> res;\r\n\r\n    if (res == -1)\r\n    {\r\n        exit(0);\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid single(ll t_id = 0)\r\n{\r\n    cin >> n;\r\n    n = (1 << n);\r\n\r\n    vll vec;\r\n    RFOR(i, n - 1, 0)\r\n    {\r\n        vec.pb(i);\r\n    }\r\n\r\n    while (sz(vec) > 2)\r\n    {\r\n        vll cur;\r\n        while (!vec.empty())\r\n        {\r\n            vll tmp;\r\n            for (ll i = 0; i < 4; i++)\r\n            {\r\n                tmp.pb(vec.back());\r\n                vec.pop_back();\r\n            }\r\n\r\n            ll r1, r2;\r\n\r\n            switch (ask(tmp[0], tmp[2]))\r\n            {\r\n            case 0:\r\n            {\r\n                r1 = tmp[1], r2 = tmp[3];\r\n                break;\r\n            }\r\n            case 1:\r\n            {\r\n                r1 = tmp[0], r2 = tmp[3];\r\n                break;\r\n            }\r\n            case 2:\r\n            {\r\n                r1 = tmp[1], r2 = tmp[2];\r\n                break;\r\n            }\r\n            }\r\n\r\n            switch (ask(r1, r2))\r\n            {\r\n            case 0:\r\n            {\r\n                break;\r\n            }\r\n            case 1:\r\n            {\r\n                cur.pb(r1);\r\n                break;\r\n            }\r\n            case 2:\r\n            {\r\n                cur.pb(r2);\r\n                break;\r\n            }\r\n            }\r\n        }\r\n\r\n        while (!cur.empty())\r\n        {\r\n            vec.pb(cur.back());\r\n            cur.pop_back();\r\n        }\r\n    }\r\n\r\n    ll win;\r\n\r\n    if (sz(vec) == 1)\r\n    {\r\n        win = vec[0];\r\n    }\r\n    else\r\n    {\r\n\r\n        ll res = ask(vec[1], vec[0]);\r\n        if (res == 1)\r\n        {\r\n            win = vec[1];\r\n        }\r\n        else if (res == 2)\r\n        {\r\n            win = vec[0];\r\n        }\r\n    }\r\n\r\n    cout << \"! \" << win + 1 << \"\\n\";\r\n    cout.flush();\r\n}\r\n\r\nvoid multiple()\r\n{\r\n    ll t;\r\n    cin >> t;\r\n\r\n    for (ll i = 0; i < t; i++)\r\n    {\r\n        single(i);\r\n    }\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    init();\r\n\r\n    // freopen(\"feast.in\", \"r\", stdin);\r\n    // freopen(\"feast.out\", \"w\", stdout);\r\n\r\n    // freopen(\"./output.txt\", \"w\", stdout);\r\n    // freopen(\"./input.txt\", \"r\", stdin);\r\n    multiple();\r\n    // single();\r\n\r\n    // make clear && make out && ./outS\r\n    return 0;\r\n}"
}