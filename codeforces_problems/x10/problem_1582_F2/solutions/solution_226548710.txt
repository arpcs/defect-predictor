{
    "id": 226548710,
    "contestId": 1582,
    "creationTimeSeconds": 1696404044,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1582,
        "index": "F2",
        "name": "Korney Korneevich and XOR (hard version)",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2400,
        "tags": [
            "binary search",
            "brute force",
            "dp",
            "greedy",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1582,
        "members": [
            {
                "handle": "mohitejaikumar"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1635069900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 8499200,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n/* 142857 cyclic number 0588235294117647 cyclic number */\r\n#define ll long long\r\n#define mk make_pair\r\n#define vvll(n, m, v) vector<vector<ll>> v(n, vll(m, 0))\r\n#define all(v) v.begin(), v.end()\r\n#define vvc vector<vector<char>>\r\n#define vss vector<string>\r\n#define emp emplace\r\n#define pb push_back\r\n#define pf push_front\r\n#define dq deque\r\n#define llmn LONG_LONG_MIN\r\n#define llmx LONG_LONG_MAX\r\n#define umll unordered_map<ll>\r\n#define mll map<ll, ll>\r\n#define sll set<ll>\r\n#define usll unordered_set<ll>\r\n#define vll vector<ll>\r\n#define vpll vector<pair<ll, ll>>\r\n#define pll pair<ll, ll>\r\n#define mk make_pair\r\n#define ss string\r\n#define pqmin priority_queue<ll, vll, greater<ll>()>\r\n#define pqmax priority_queue<ll>\r\n#define llmin LONG_LONG_MIN\r\n#define llmax LONG_LONG_MAX\r\n#define s second\r\n#define f first\r\n#define repg(i, a, b, c) for (ll i = a; i < b; i += c)\r\n#define rep(i, a, b) for (ll i = a; i < b; i++)\r\n#define rrep(i, a, b) for (ll i = a; i > b; i--)\r\n#define rrepg(i, a, b, c) for (ll i = a; i > b; i -= c)\r\n#define trv(it, mp) for (auto it : mp)\r\n#define rot_l(v, p) rotate(v.begin(), v.begin() + p, v.end())\r\n#define rot_r(v, p) rotate(v.begin(), v.begin() + v.size() - p, v.end())\r\n#define cont(v, p) count(v.begin(), v.end(), p)\r\n#define accumulate(v, k) accumulate(v[i].begin(), v[i].begin() + k, 0)\r\n#define fastio                        \\\r\n    ios_base::sync_with_stdio(false); \\\r\n    cin.tie(NULL);\r\nconst ll M = 1e9 + 7;\r\nconst ll M2 = 998244353;\r\n#define yes cout << \"YES\" << endl;\r\n#define no cout << \"NO\" << endl;\r\n#define setIntersection(d1, d2, cd) set_intersection(d1.begin(), d1.end(), d2.begin(), d2.end(), inserter(cd, cd.begin()));\r\n\r\nll mod(ll x)\r\n{\r\n    return ((x % M + M) % M);\r\n}\r\nll add(ll a, ll b)\r\n{\r\n    return mod(mod(a) + mod(b));\r\n}\r\nll mul(ll a, ll b)\r\n{\r\n    return mod(mod(a) * mod(b));\r\n}\r\nll Floor(ll x, ll a)\r\n{\r\n    if (x < 0)\r\n    {\r\n        return floor(x / a) - 1;\r\n    }\r\n    return floor(x / a);\r\n}\r\n\r\n/*-----------------Number_Theory---------------------------------------------------*/\r\nll fac[2000];\r\nsigned binExp(ll a, ll b, ll m)\r\n{\r\n    ll ans = 1;\r\n    while (b > 0)\r\n    {\r\n        if (b & 1)\r\n        {\r\n            ans = (ans * a) % m;\r\n            b = b - 1;\r\n        }\r\n        a = (a * a) % m;\r\n        b = b >> 1;\r\n    }\r\n    return ans % m;\r\n}\r\nvoid fact(ll n)\r\n{\r\n    fac[0] = 1;\r\n    rep(i, 1, n + 1) fac[i] = (i * fac[i - 1]) % M;\r\n    return;\r\n}\r\nll ncr(ll n, ll r)\r\n{\r\n    if (r > n)\r\n        return 0;\r\n    return ((fac[n] * binExp(fac[n - r], M - 2, M)) % M * binExp(fac[r], M - 2, M)) % M;\r\n}\r\nll gcd(ll a, ll b, ll &x, ll &y)\r\n{\r\n    if (b == 0)\r\n    {\r\n        x = 1;\r\n        y = 0;\r\n        return a;\r\n    }\r\n    ll x1, y1;\r\n    ll d = gcd(b, a % b, x1, y1);\r\n    x = y1;\r\n    y = x1 - y1 * (a / b);\r\n    return d;\r\n}\r\n\r\nvector<pair<int, int>> factors;\r\nvoid getFactors(int n)\r\n{\r\n    factors.clear();\r\n    int d = 1;\r\n    for (int i = 2; i * i <= n; i += d, d = 2)\r\n        if (n % i == 0)\r\n        {\r\n            factors.push_back(make_pair(i, 0));\r\n            while (n % i == 0)\r\n            {\r\n                n /= i;\r\n                factors.back().second++;\r\n            }\r\n        }\r\n    if (n != 1)\r\n        factors.push_back(make_pair(n, 1));\r\n}\r\n\r\nvector<int> divisors;\r\nvoid getDivisors(int ind = 0, int res = 1)\r\n{\r\n    if (ind == (int)factors.size())\r\n    {\r\n        divisors.push_back(res);\r\n        return;\r\n    }\r\n    for (int i = 0; i <= factors[ind].second; i++)\r\n    {\r\n        getDivisors(ind + 1, res);\r\n        res *= factors[ind].first;\r\n    }\r\n}\r\nll sieve[1000000];\r\nvoid createsieve()\r\n{\r\n    ll n = 1000000;\r\n    sieve[1] = 1;\r\n    for (ll i = 2; i <= n; i++)\r\n        sieve[i] = i;\r\n\r\n    for (ll i = 2; i * i <= n; i++)\r\n    {\r\n        if (sieve[i] == i)\r\n        {\r\n            for (ll j = i * i; j <= n; j = j + i)\r\n            {\r\n                if (sieve[j] == j)\r\n                {\r\n                    sieve[j] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n/*----------------------------Number_Theory_End----------------------------------------------*/\r\nbool check(ll mid)\r\n{\r\n}\r\nll bin_Search(ll l, ll r, ll ans)\r\n{\r\n    while (l <= r)\r\n    {\r\n        ll mid = (l + r) >> 1;\r\n        if (check(mid))\r\n        {\r\n            l = mid;\r\n            ans = mid;\r\n        }\r\n        else\r\n        {\r\n            r = mid;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\nll lcm(ll a, ll b)\r\n{\r\n    return (a * b) / (__gcd(a, b));\r\n}\r\nbool is_Palindrom(string s)\r\n{\r\n    string z = s;\r\n    reverse(s.begin(), s.end());\r\n    return s == z;\r\n}\r\nll lis(vll &v)\r\n{\r\n    ll size = v.size();\r\n    vll temp;\r\n    temp.push_back(v[0]);\r\n    ll len = 1;\r\n    rep(i, 1, size)\r\n    {\r\n        if (temp.back() < v[i])\r\n        {\r\n            temp.push_back(v[i]);\r\n            len++;\r\n        }\r\n        else\r\n        {\r\n            ll ind = lower_bound(all(temp), v[i]) - temp.begin();\r\n            temp[ind] = v[i];\r\n        }\r\n    }\r\n    return len;\r\n}\r\nvector<pair<ll, ll>> result;\r\nvector<pair<ll, ll>> ranges;\r\nvoid unionRanges()\r\n{\r\n    sort(ranges.begin(), ranges.end());\r\n    vector<pair<ll, ll>>::iterator it = ranges.begin();\r\n    pair<ll, ll> current = *(it)++;\r\n    while (it != ranges.end())\r\n    {\r\n        if (current.second > it->first)\r\n        { // you might want to change it to >=\r\n            current.second = std::max(current.second, it->second);\r\n        }\r\n        else\r\n        {\r\n            result.push_back(current);\r\n            current = *(it);\r\n        }\r\n        it++;\r\n    }\r\n    result.push_back(current);\r\n    return;\r\n}\r\nll di[] = {-1, 0, 0, 1};\r\nll dj[] = {0, -1, 1, 0};\r\n\r\nvll vis;\r\nvll dis;\r\nvll par;\r\nvector<vll> adj;\r\nvector<vpll> adj_w;\r\nvll pathvis;\r\nstack<ll> topoStack;\r\nvll topo;\r\nvll indegree;\r\nvector<vector<ll>> adj_matrix;\r\n\r\nclass DisjointSet\r\n{\r\n    // no. of component -----> parent[node]==node\r\n    // detect no. of usless edges\r\npublic:\r\n    vll rank, size, parent;\r\n    DisjointSet(ll n)\r\n    {\r\n        rank.resize(n + 1, 0);\r\n        size.resize(n + 1, 1);\r\n        parent.resize(n + 1, 0);\r\n        rep(i, 0, n + 1)\r\n        {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n    ll findUPar(ll node)\r\n    {\r\n        if (node == parent[node])\r\n        {\r\n            return node;\r\n        }\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n    void unionByRank(ll u, ll v)\r\n    {\r\n\r\n        // pathCompression\r\n        ll par_ult_v = findUPar(v);\r\n        ll par_ult_u = findUPar(u);\r\n\r\n        if (par_ult_u == par_ult_v)\r\n        {\r\n            return;\r\n        }\r\n        // add smaller to larger\r\n        if (rank[par_ult_u] < rank[par_ult_v])\r\n        {\r\n            parent[par_ult_u] = par_ult_v;\r\n        }\r\n        else if (rank[par_ult_v] < rank[par_ult_u])\r\n        {\r\n\r\n            parent[par_ult_v] = par_ult_u;\r\n        }\r\n        else\r\n        {\r\n            parent[par_ult_v] = par_ult_u;\r\n            rank[par_ult_u]++;\r\n        }\r\n        return;\r\n    }\r\n    void unionBySize(ll u, ll v)\r\n    {\r\n        ll par_ult_v = findUPar(v);\r\n        ll par_ult_u = findUPar(u);\r\n\r\n        if (par_ult_u == par_ult_v)\r\n        {\r\n            return;\r\n        }\r\n        // add smaller to larger\r\n        if (size[par_ult_u] > size[par_ult_v])\r\n        {\r\n            swap(par_ult_v, par_ult_u);\r\n        }\r\n\r\n        parent[par_ult_u] = par_ult_v;\r\n        size[par_ult_v] += size[par_ult_u];\r\n        size[par_ult_u] = 0;\r\n\r\n        return;\r\n    }\r\n};\r\nvoid makeGraph(ll n)\r\n{\r\n    par.resize(n + 1, 0);\r\n    dis.resize(n + 1, 1e9);\r\n    vis.resize(n + 1, 0);\r\n    adj.resize(n + 1);\r\n    adj_w.resize(n + 1);\r\n    indegree.resize(n + 1);\r\n\r\n    return;\r\n}\r\nvoid addEdge(ll x, ll y)\r\n{\r\n    // go from x----->y\r\n    adj[x].push_back(y);\r\n\r\n    indegree[y]++;\r\n\r\n    return;\r\n}\r\nvoid addEdgeWeight(ll x, ll y, ll c)\r\n{\r\n    // go from x----->y with weight c\r\n    adj_w[x].push_back({y, c});\r\n    return;\r\n}\r\n\r\n/*---------------------------------TEMPLATE  ENDS --------------------------------------------------------------------------------------*/\r\nvoid solve()\r\n{\r\n    ll n;\r\n    cin >> n;\r\n    vll v(n, 0);\r\n    rep(i, 0, n) cin >> v[i];\r\n    ll maxa = *max_element(all(v));\r\n    vll g[maxa + 1];\r\n    mll mp;\r\n    vll ans(2 * maxa, 0);\r\n    ans[0] = 1;\r\n\r\n    rep(i, 0, maxa + 1)\r\n    {\r\n        g[i].push_back(0);\r\n    }\r\n\r\n    rep(i, 0, n)\r\n    {\r\n        ll x=v[i];\r\n       \r\n        for(auto it:g[x]){\r\n\r\n            ll possible_xor = it^x;\r\n            ans[possible_xor]=1;\r\n            if(mp.find(possible_xor)==mp.end()){\r\n                rep(j,x+1,maxa+1){\r\n                    g[j].push_back(possible_xor);\r\n                }\r\n                mp[possible_xor]++;\r\n            }\r\n        }\r\n        // g[x]={};\r\n    }\r\n    ll num=0;\r\n    \r\n    rep(i,0,2*maxa){\r\n        num+=ans[i];\r\n    }\r\n    cout<<num<<endl;\r\n    rep(i,0,2*maxa){\r\n        if(ans[i]==1)\r\n        cout<<i<<\" \";\r\n    }\r\n    cout<<endl;\r\n    \r\n\r\n    return;\r\n}\r\n/*-----------------------------------------------------------------------------------------------------------------------*/\r\nsigned main()\r\n{\r\n    fastio;\r\n    ll t=1;\r\n    // cin >> t;\r\n    while (t--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n/*any sequence of length at least 5 contains either non-decreasing or non-increasing subsequence of length 3*/\r\n"
}