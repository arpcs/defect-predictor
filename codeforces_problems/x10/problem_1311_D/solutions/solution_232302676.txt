{
    "id": 232302676,
    "contestId": 1311,
    "creationTimeSeconds": 1699652874,
    "relativeTimeSeconds": 6174,
    "problem": {
        "contestId": 1311,
        "index": "D",
        "name": "Three Integers",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "brute force",
            "math"
        ]
    },
    "author": {
        "contestId": 1311,
        "members": [
            {
                "handle": "abd-alrzaq"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1699646700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 327,
    "memoryConsumedBytes": 2867200,
    "source": "#include<iostream>\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n/*#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\ntypedef tree<int,null_type,less<int>,rb_tree_tag,\r\ntree_order_statistics_node_update> indexed_set;*/\r\n#define ll long long\r\n#define vl vector<ll>\r\n#define pb push_back\r\n#define pf push_front\r\n#define OO 1e18\r\n#define vi vector<int>\r\n#define vs vector<string>\r\n#define dql deque<ll>\r\n#define GO  cin.tie(0);cout.tie(0);ios::sync_with_stdio(0)\r\n#define tt int t;cin>>t\r\n#define nn long long n;cin>>n\r\n#define       forn(i,n)              for(int i=0;i<n;i++)\r\n#define  all(v)  v.begin(), v.end()\r\n#define allr(v) v.rbegin() , v.rend()\r\n#define get1(i) ll i; cin>>i\r\n#define get2(x,y) ll x,y; cin>>x>>yw\r\n#define ld long double\r\n#define R return\r\n#define pq priorty_queue\r\n#define print(a) forn(i,a.size()) cout<<a[i]<<\" \"; cout<<endl\r\nll num_of_digits(ll x){\r\n    int d=static_cast<int>(log10(x))+1;\r\n    return d;\r\n}\r\n\r\nll sum_of_digits(ll n){\r\n    ll sum=0;\r\nwhile(n>0){\r\n    sum+=n%10;\r\n    n/=10;\r\n}\r\nreturn sum;\r\n}\r\nstruct Point{\r\nll x,y;\r\n};\r\nll distance(Point a,Point b){\r\n\r\nreturn sqrtl((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\r\n}\r\n///\r\nbool is_plaindrom(string a){\r\n    string h=a;reverse(a.begin(),a.end());\r\n    return a==h;\r\n}\r\n///\r\nll factorial(ll n,ll r) { // twafiq\r\n    ll sum=1;\r\n    for(ll i = 1; i <= r; i++){\r\n        sum = sum * (n - r + i) / i;\r\n    }\r\n    return sum;\r\n}\r\nll mex(vl a){\r\n    /// this function return min element which dont appear in vector complixity =n\r\n    ll n=a.size(); set<ll>s; forn(i,n) s.insert(a[i]); ll m=*min_element(all(a))-1;if(m==-1){while(s.count(m+1)){m++;}m++;}return m;}\r\n\r\n/*\r\nbefore using this function define vector as global firstly\r\nthen copy the following commented code to main:\r\nmap<ll,vl>mp;\r\nforn(i,n) mp[a[i]].pb(i);\r\n*/\r\n/*\r\nll range_frequency(ll element,ll l,ll r){\r\n    if(mp[element].size()==0) return 0;\r\n\r\n\r\n\r\n\r\nll left=0,right=mp[element].size()-1;\r\nll first=OO;\r\nwhile(left<=right){\r\n    ll mid=(left+right)/2;\r\n    if(mp[element][mid]>=l ){\r\n            if( mp[element][mid]<=r)\r\n        first=min(first,mid);\r\n\r\n        right=mid-1;\r\n    }\r\n    else{\r\n        left=mid+1;\r\n    }\r\n}\r\n///\r\nbool ans=first!=OO?1:0;\r\nif(!ans) return 0;\r\n\r\nll last=first;\r\nleft=0;right=mp[element].size()-1;\r\nwhile(left<=right){\r\n    ll mid=(left+right)/2;\r\n    if(mp[element][mid]<=r){\r\n        last=max(last,mid);\r\n        left=mid+1;\r\n    }\r\n    else{\r\n        right=mid-1;\r\n    }\r\n}\r\n\r\nreturn last-first+1;\r\n}*/\r\n\r\n///\r\n/*\r\n const ll maxn=1e6;\r\nvector<bool>primes(maxn+1,true);\r\n/// sieve complixity n log log\r\nvoid sieve()\r\n{\r\nprimes[0] = primes[1] = 0;\r\nfor (ll p = 2; p*p < maxn; p++)\r\nif (primes[p])\r\nfor (ll i = p * p ; i < maxn ; i += p )\r\nprimes[i] = 0;\r\n}\r\n\r\n\r\n*/\r\nll to_int(char a){\r\n    return a-48;\r\n}\r\nvoid yn(bool x){\r\n    if(x){cout<<\"Yes\"; }\r\n    else{cout<<\"No\";}\r\n    cout<<endl;\r\n}\r\n\r\n\r\nconst ll SieveSize = 10000011;\r\nbitset<SieveSize> bs; // less time and memory than vector<bool> bs or bool bs[]\r\nvector<ll> primes; // store all primes in this vector\r\n\r\nvoid sieve()\r\n{\r\n    bs.set();\r\n    bs[0] = bs[1] = false;\r\n    for(long long i = 2ll ; i < SieveSize ; i++){\r\n        if( bs[i] ){\r\n            primes.push_back(i);\r\n            for(long long j = 1ll * i * i ; j < SieveSize ; j += i){\r\n                bs[j] = false;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst int qwe=2e5+50;\r\nvl nxt(qwe,-1);\r\nvoid nxt_fill(vector<ll>a){\r\n    nxt.resize(a.size());\r\n    map<ll,ll>m;\r\n    for(int i=a.size()-1;i>=0;i--){\r\n        nxt[i]=m[a[i]+1];\r\n        m[a[i]]=i;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\nconst ll mod=1e9 +7;\r\nbool check_bitsnumber(int n, int num) {\r\n    //to check if all num bits are include in n\r\n    bitset<64>b1(n);\r\n    bitset<64>b2(num);\r\n\r\n    for(int i=0;i<64;i++){\r\n        if(b2[i]==1 &&b1[i]==0){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n\r\n}\r\n///\r\n\r\n\r\n///\r\nll lcm(ll x,ll y){\r\n    return (x*y)/__gcd(x,y);\r\n}\r\nll sum(ll x,ll y){\r\n    return (x%mod +y%mod)%mod;\r\n}\r\nll sub(ll x,ll y){\r\n    return (x%mod - y%mod  + mod) %mod;\r\n}\r\nll mult(ll x,ll y){\r\n    return (x%mod * y%mod)%mod;\r\n}\r\nll MOD= 1e9 +7;\r\nll _powMod(ll n ,ll p )\r\n{\r\n    n %= MOD;\r\n\r\n    ll x = 1;\r\n    while( p > 0 )\r\n    {\r\n        if( p % 2 == 1 ) x = (x * n) % MOD;\r\n        n = (n * n) % MOD;\r\n        p /= 2;\r\n    }\r\n\r\n    return x;\r\n}\r\n///\r\nvector<ll> factorization(ll x)\r\n{\r\n    vector<ll> v;\r\n    for (ll i = 2; i * i <= x; i++)\r\n        while (x % i == 0)\r\n        {\r\n            x /= i;\r\n            v.push_back(i);\r\n        }\r\n    if (x > 1)\r\n        v.push_back(x);\r\n    return v;\r\n}\r\n///\r\nbool isPrime(ll x)\r\n{\r\n    // check if prime or not if the number is > 1e8\r\n    if (x == 1)\r\n        return false;\r\n    for (ll i = 2; i * i <= x; i++)\r\n        if (x % i == 0)\r\n            return false;\r\n    return true;\r\n}\r\n///\r\nvector<ll> divisors(ll x)\r\n{\r\n    vector<ll> v;\r\n    for (ll i = 1; i * i <= x; i++)\r\n    {\r\n        if (x % i == 0)\r\n        {\r\n            v.push_back(i);\r\n            if (i != x / i)\r\n                v.push_back(x / i);\r\n        }\r\n    }\r\n    return v;\r\n}\r\n/// n! function\r\nll amle(ll n)\r\n{\r\n    if(n == 0 || n == 1)\r\n        return 1;\r\n    return n*amle(n-1);\r\n}\r\n///\r\nll power(ll d, ll n){\r\n    if(n==0)\r\n        return 1;\r\n    ll x = power(d, n/2);\r\n    if(n%2==1)\r\n        return x*x*d;\r\n    return x*x;\r\n}\r\n///\r\nvector<ll>aamle(1e3,1);\r\nvoid amle(){\r\n    for(int i=2;i<aamle.size();i++){\r\n        aamle[i]=i*aamle[i-1];\r\n    }\r\n}\r\n///\r\nlong long fpower(long long a, long long b)\r\n{\r\n    if (b == 0)\r\n        return 1;\r\n    long long res = fpower(a, b / 2);\r\n    if (b % 2)\r\n        return res * res * a;\r\n    else\r\n        return res * res;\r\n}\r\n///\r\nvector<pair<ll ,ll> > primeFactors(ll num)\r\n{\r\n\r\n    ll x = num;\r\n    vector<pair<ll ,ll> > factors;\r\n\r\n    for(ll i = 0 ; i < (ll)primes.size() && 1ll * primes[i] * primes[i] <= x ; i++)\r\n    {\r\n        if( x % primes[i] == 0 )\r\n        {\r\n            ll cnt = 0;\r\n            while( x % primes[i] == 0 )\r\n            {\r\n                cnt += 1;\r\n                x /= primes[i];\r\n            }\r\n            factors.push_back({primes[i] ,cnt});\r\n        }\r\n    }\r\n    if( x != 1 ){\r\n        factors.push_back({x ,1});\r\n    }\r\n\r\n    return factors;\r\n}\r\n\r\n\r\n///fast\r\n// for(int i=0;i< ;i++)\r\n// for(int j=0;j< ;j++)\r\n// for(int i= ;i>=0 ;i--)\r\n// for(int j= ;j>=0;j--)\r\n//to converm to binary use bitset<64> b(value) ;\r\n// xor -> 0+0=0 1+0 =1 1+1=0\r\n//or ->  0+0=0 1+0=1 1+1=1\r\n// and 1+1 =1 0+0=0 0+1 =0\r\n// cout<<fixed<<setprecision(10)<< num<<endl;\r\n\r\n// multiset sort the elements in log\r\n/// when we sort in vector<pair<ll,ll>> it sorts according to the first\r\n/// x%a = (a+x)%a\r\n/*\r\nin fibonachi\r\nf0=f0\r\nf1=f1\r\nf2=f1+f0\r\nf3=2f1+f0\r\nf4=3f1+2f0\r\nf5=5f1+3f0\r\nf6=8f1+5f0\r\n*/\r\n/// give important for maximum value can be reached for every element in your solution and u may found another faster way to solve this problem\r\n\r\n/*\r\n* num of divisors = \u03c0 (cnt[ primes[i] ] + 1);\r\n* sum of divisors = \u03c0 (Sum Of Geometric Progression Series of primes factors)\r\n*\tEularPhi = num of integers x < n and coprimes with n:\r\n*\tans -= (ans / primes[i]) ; ans = n (first)\r\n*\r\n*\r\n* Legendre's Formula Vp(P ,N):\r\n*\r\n*\tGets how many times P is exist in N! (P is Prime number).\r\n*\r\n* Vp(P ,N) = X = \u03a3i (N / P^i)\r\n*/\r\n/*\r\nin intractive problems  use\r\nprintf(\"%d\\n\", mid);  fflush(stdout); ///instead of cout\r\n scanf(\"%s\", response);\r\n\r\n*/\r\n///learn lower bound and upper bound\r\n///h.find(s) != std::string::npos if its found return true\r\n/// if n=100 think in n^3 sollution\r\n/// use sqrtl instead of sqrt\r\n/// in priorty_queue maximum element is always on the top\r\n/// int m= unique(all(a)) - a.begin();\r\n/// in indexed_set  s.order_of_key() or s.find_by_order\r\n\r\n\r\nint main(){\r\nGO;\r\ntt;\r\nwhile(t--){\r\nll a,b,c;\r\ncin>>a>>b>>c;\r\nvl res(3);\r\nint ans=1e9;\r\nfor(ll i=a;i<=2e4;i++){\r\n    ll k=abs(b-i);\r\n    ll aa,cc;\r\n    if(!isPrime(i)){\r\n\r\n\r\n    if(i/a!=0){\r\n            if(abs(a-(i/ceil((ld)i/(ld)a)))<abs(a-(i/(i/a)))){\r\n                aa=abs((i/ceil((ld)i/(ld)a)));\r\n            }\r\n            else aa=abs((i/(i/a)));\r\n          k+=min((ll)abs(a-(i/ceil((ld)i/(ld)a))),abs(a-(i/(i/a))));\r\n\r\n    }\r\n    else{ aa=abs( (i/ceil((ld)i/(ld)a))); k+=abs(a-aa); }\r\n}\r\nelse {\r\n    ll  temp=min(abs(a-1),abs(i-a));\r\n    k+=temp;\r\n    if(temp==abs(a-1)){\r\n        aa=1;\r\n    }\r\n    else aa=i;\r\n\r\n}\r\n    \r\n            ll cop_c=c;\r\n    ll cop_b=i;\r\n    cop_b=min(i,c);\r\n    cop_c=max(i,c);\r\n            if((ll)abs(c-(cop_b*ceil((ld)cop_c/(ld)cop_b)))<abs(c-(cop_b*(cop_c/cop_b)))){\r\n                cc=abs((cop_b*ceil((ld)cop_c/(ld)cop_b)));\r\n            }\r\n            else cc=abs((cop_b*(cop_c/cop_b)));\r\n k+=abs(c-cc);\r\n    \r\n    if(k<ans && i%aa==(ll)0 && cc%i==(ll)0){\r\n            ans=k;\r\n        res[0]=aa;\r\n        res[1]=i;\r\n    res[2]=cc;\r\n    }\r\n}\r\ncout<<ans<<endl;\r\nprint(res);\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n"
}