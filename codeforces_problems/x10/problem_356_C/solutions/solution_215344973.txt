{
    "id": 215344973,
    "contestId": 356,
    "creationTimeSeconds": 1690198008,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 356,
        "index": "C",
        "name": "Compartments",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 356,
        "members": [
            {
                "handle": "Kirkon"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1381838400
    },
    "programmingLanguage": "Clang++20 Diagnostics",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "// #\r\n#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n\r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n\r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n\r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <type_traits>\r\n#include <typeindex>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <ext/rope>\r\n\r\nusing namespace __gnu_pbds;\r\nusing namespace __gnu_cxx;\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing db = long double; // or double, if TL is tight\r\nusing str = string;     // yay python!\r\n\r\n// pairs\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing pd = pair<db, db>;\r\n#define pb push_back\r\n#define mp make_pair\r\n#define fi first\r\n#define se second\r\n\r\ntemplate <class T> using V = vector<T>;\r\ntemplate <class T, size_t SZ> using AR = array<T, SZ>;\r\nusing vi = V<int>;\r\nusing vvi = V<vi>;\r\nusing vb = V<bool>;\r\nusing vll = V<ll>;\r\nusing vd = V<db>;\r\nusing vs = V<str>;\r\nusing vpii = V<pii>;\r\nusing vpll = V<pll>;\r\nusing vpd = V<pd>;\r\n\r\ntemplate <class T> using pair2 = pair<T, T>;\r\n\r\n// vectors\r\n// oops size(x), rbegin(x), rend(x) need C++17\r\n\r\ntemplate <class T> int sz(const T &a) { return a.size(); }\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define sor(x) sort(all(x))\r\n\r\ntemplate <class T> int lwb(V<T> &a, const T &b) {\r\n  return int(lower_bound(all(a), b) - bg(a));\r\n}\r\ntemplate <class T> int upb(V<T> &a, const T &b) {\r\n  return int(upper_bound(all(a), b) - bg(a));\r\n}\r\n\r\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate <class T> using pql = priority_queue<T, vector<T>, less<T>>;\r\n\r\n// loops\r\n#define rep(a) for (int _ = 0; _ < (a); ++_)\r\n#define each(a, x) for (auto &a : x)\r\n\r\nconst int MOD = 998244353;\r\nconst int MX = 2e5 + 5;\r\nconst ll BIG = 1e18; // not too close to LLONG_MAX\r\nconst db PI = acos((db)-1);\r\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\r\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nnamespace kirkon {}\r\nusing namespace kirkon;\r\n\r\nnamespace kirkon_helpers {\r\n// bitwise ops\r\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\r\nconstexpr long long pct(long long x) {\r\n  return __builtin_popcount(x);\r\n} // # of bits set\r\nconstexpr long long bits(long long x) { // assert(x >= 0); // make C++11\r\n                                        // compatible until USACO updates ...\r\n  return x == 0 ? 0 : 31 - __builtin_clz(x);\r\n} // floor(log2(x))\r\nconstexpr long long p2(long long x) { return 1 << x; }\r\nconstexpr long long msk2(long long x) { return p2(x) - 1; }\r\n\r\nll cdiv(ll a, ll b) {\r\n  return a / b + ((a ^ b) > 0 && a % b);\r\n} // divide a by b rounded up\r\nll fdiv(ll a, ll b) {\r\n  return a / b - ((a ^ b) < 0 && a % b);\r\n} // divide a by b rounded down\r\n\r\ntemplate <class T> bool ckmin(T &a, const T &b) {\r\n  return b < a ? a = b, 1 : 0;\r\n} // set a = min(a,b)\r\ntemplate <class T> bool ckmax(T &a, const T &b) {\r\n  return a < b ? a = b, 1 : 0;\r\n} // set a = max(a,b)\r\n\r\ntemplate <class T, class U> bool ckmin(T &a, const U &b) {\r\n  return b < a ? a = b, 1 : 0;\r\n} // set a = min(a,b)\r\ntemplate <class T, class U> bool ckmax(T &a, const U &b) {\r\n  return a < b ? a = b, 1 : 0;\r\n} // set a = max(a,b)\r\n\r\ntemplate <class T, class U> T fstTrue(T lo, T hi, U f) {\r\n  ++hi;\r\n  assert(lo <= hi); // assuming f is increasing\r\n  while (lo < hi) { // find first index such that f is true\r\n    T mid = lo + (hi - lo) / 2;\r\n    f(mid) ? hi = mid : lo = mid + 1;\r\n  }\r\n  return lo;\r\n}\r\ntemplate <class T, class U> T lstTrue(T lo, T hi, U f) {\r\n  --lo;\r\n  assert(lo <= hi); // assuming f is decreasing\r\n  while (lo < hi) { // find first index such that f is true\r\n    T mid = lo + (hi - lo + 1) / 2;\r\n    f(mid) ? lo = mid : hi = mid - 1;\r\n  }\r\n  return lo;\r\n}\r\n\r\ntemplate <class T> void remDup(vector<T> &v) { // sort and remove duplicates\r\n  sort(all(v));\r\n  v.erase(unique(all(v)), end(v));\r\n}\r\ntemplate <class T, class U> void erase(T &t, const U &u) { // don't erase\r\n  auto it = t.find(u);\r\n  assert(it != end(t));\r\n  t.erase(it);\r\n} // element that doesn't exist from (multi)set\r\n\r\nll myRand(ll B) { return (unsigned long long)rng() % B; }\r\n\r\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\r\ntemplate <class Fun> class y_combinator_result {\r\n  Fun fun_;\r\n\r\npublic:\r\n  template <class T>\r\n  explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\r\n  template <class... Args> decltype(auto) operator()(Args &&...args) {\r\n    return fun_(std::ref(*this), std::forward<Args>(args)...);\r\n  }\r\n};\r\n\r\ntemplate <class Fun> decltype(auto) y_combinator(Fun &&fun) {\r\n  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\r\n}\r\n\r\ntemplate <class T, class U> istream &operator>>(istream &in, pair<T, U> &a) {\r\n  in >> a.first >> a.second;\r\n  return in;\r\n}\r\n\r\ntemplate <class T, class U> ostream &operator<<(ostream &out, pair<T, U> &a) {\r\n  out << a.first << ' ' << a.second << '\\n';\r\n  return out;\r\n}\r\n\r\ntemplate <class T> istream &operator>>(istream &in, vector<T> &a) {\r\n  each(i, a) { in >> i; }\r\n  return in;\r\n}\r\n\r\ntemplate <class T> ostream &operator<<(ostream &out, vector<T> &a) {\r\n  each(i, a) { out << i << ' '; }\r\n  out << '\\n';\r\n  return out;\r\n}\r\n\r\n} // namespace kirkon_helpers\r\n\r\nusing namespace kirkon_helpers;\r\n\r\nnamespace advanced_structures {\r\ntemplate <class T>\r\nusing Tree =\r\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\nnamespace mapOp {\r\nconst int tmp = chrono::high_resolution_clock::now().time_since_epoch().count();\r\n\r\ntemplate <class T> struct hsh {\r\n  size_t operator()(const T &x) const {\r\n    return hash<T>{}(x) ^ tmp; // avoid anti-hash tests?\r\n  }\r\n};\r\n\r\ntemplate <class a, class b> using um = gp_hash_table<a, b, hsh<a>>;\r\n\r\ntemplate <class a, class b> b get(um<a, b> &u, a x) {\r\n  if (u.find(x) == u.end())\r\n    return 0;\r\n  return u[x];\r\n}\r\n} // namespace mapOp\r\nusing namespace mapOp;\r\n} // namespace advanced_structures\r\n\r\nusing namespace advanced_structures;\r\n\r\nvoid solve() {\r\n  int n; cin >> n;\r\n  vector<int> a(n); cin >> a;\r\n  int sum = accumulate(all(a), 0);\r\n  if (sum == 1 || sum == 2 || sum == 5) {\r\n    cout << \"-1\";\r\n    return;\r\n  }\r\n\r\n  int cnt4 = sum / 4;\r\n  int cnt3 = 0;\r\n  if (sum % 4 == 3) {\r\n    cnt3++;\r\n  } else {\r\n    if (sum % 4 == 1) {\r\n      cnt4 -= 2;\r\n      cnt3 += 3;\r\n    } else {\r\n      if (sum % 4 == 2) {\r\n        cnt4--;\r\n        cnt3 += 2;\r\n      }\r\n    }\r\n  }\r\n\r\n  vector<int> gen_pos(5, 0);\r\n  for (int i = 0; i < n; ++i) {\r\n    gen_pos[a[i]]++;\r\n  }\r\n  int ans = 1e9;\r\n  while(cnt4 >= 0 && cnt3 >= 0) {\r\n    int cur_sum = 0;\r\n    int i = 4;\r\n\r\n    auto pos = gen_pos;\r\n\r\n    int c_cnt4 = cnt4;\r\n    int c_cnt3 = cnt3;\r\n\r\n    while(c_cnt4 && i >= 0) {\r\n      int val = min(c_cnt4, pos[i]);\r\n      c_cnt4 -= val;\r\n      pos[i] -= val;\r\n      cur_sum += (4 - i) * val;\r\n      if (pos[i] == 0) {\r\n        --i;\r\n      }\r\n    }\r\n\r\n    while(c_cnt3 && i >= 0) {\r\n      int val = min(c_cnt3, pos[i]);\r\n      c_cnt3 -= val;\r\n      pos[i] -= val;\r\n      cur_sum += abs(3 - i) * val;\r\n      if (pos[i] == 0) {\r\n        --i;\r\n      }\r\n    }\r\n\r\n    while(i >= 0) {\r\n      cur_sum += i * pos[i];\r\n      --i;\r\n    }\r\n\r\n    cur_sum /= 2;\r\n    ckmin(ans, cur_sum);\r\n    cnt4 -= 3;\r\n    cnt3 += 4;\r\n  }\r\n  cout << ans;\r\n}\r\n\r\nsigned main() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  cout.precision(30);\r\n  // setIO();\r\n  int tt = 1;\r\n  // cin >> tt;\r\n  rep(tt) solve();\r\n  // you should actually read the stuff at the bottom\r\n}\r\n\r\n/* stuff you should look for\r\n * long long overflow, array bounds\r\n * special cases (n=1?)\r\n * do smth instead of nothing and stay organized\r\n * WRITE STUFF DOWN\r\n * DON'T GET STUCK ON ONE APPROACH\r\n */\r\n"
}