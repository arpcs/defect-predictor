{
    "id": 229472355,
    "contestId": 1100,
    "creationTimeSeconds": 1698086836,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1100,
        "index": "E",
        "name": "Andrew and Taxi",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "binary search",
            "dfs and similar",
            "graphs"
        ]
    },
    "author": {
        "contestId": 1100,
        "members": [
            {
                "handle": "bkifhr9"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1547390100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 95,
    "timeConsumedMillis": 265,
    "memoryConsumedBytes": 11366400,
    "source": "#include <x86intrin.h>\n#include <bits/stdc++.h>\n\n#define Int(...) int __VA_ARGS__; read(__VA_ARGS__)\n#define Ll(...) long long __VA_ARGS__; read(__VA_ARGS__)\n#define Dbl(...) double __VA_ARGS__; read(__VA_ARGS__)\n#define Chr(...) char __VA_ARGS__; read(__VA_ARGS__)\n#define Str(...) string __VA_ARGS__; read(__VA_ARGS__)\n#define Vt(type, name, size) vector<type> name(size); read(name)\n#define Vvt(type, name, h, w) vector<vector<type>> name(h, vector<type>(w)); read(name)\n#define die(...)  do { print(__VA_ARGS__); return; } while (false)\n#define kill(...) do { print(__VA_ARGS__); return 0; } while (false)\n\n#define CFOR(e, v) for (const auto &e : v)\n#define For(i, ...) CFOR(i, macro::rep_impl(__VA_ARGS__))\n#define Frr(i, ...) CFOR(i, macro::rrep_impl(__VA_ARGS__))\n#define ForInf(i, ...) CFOR(i, macro::repinf_impl(__VA_ARGS__))\n#define Loop(n) for ([[maybe_unused]] const auto& _ : macro::rep_impl(n))\n#define Each(x, iterable) for (auto &&x: iterable)\n\n#define All(iterable) std::begin(iterable), std::end(iterable)\n#define len(iterable) (int) iterable.size()\n#define elif else if\n\nnamespace Trait_Base {\n    template <typename ...Constraints> using constraints_t = std::enable_if_t<std::conjunction_v<Constraints...>, std::nullptr_t>;\n\n    template <typename T, typename = constraints_t<std::is_integral<T>>> constexpr int bit_num = std::numeric_limits<std::make_unsigned_t<T>>::digits;\n    template <typename T, typename = std::nullptr_t> struct bitnum { static constexpr int value = 0; };\n    template <typename T> struct bitnum<T, constraints_t<std::is_integral<T>>> { static constexpr int value = std::numeric_limits<std::make_unsigned_t<T>>::digits; };\n    template <typename T> static constexpr int bitnum_v = bitnum<T>::value;\n    template <typename T, size_t n> struct is_nbit { static constexpr bool value = bitnum_v<T> == n; };\n    template <typename T, size_t n> static constexpr bool is_nbit_v = is_nbit<T, n>::value;\n\n    template <typename T, typename = std::nullptr_t> struct safely_multipliable { using type = T; };\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_signed<T>, is_nbit<T, 32>>> { using type = long long; };\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_signed<T>, is_nbit<T, 64>>> { using type = __int128_t; };\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_unsigned<T>, is_nbit<T, 32>>> { using type = unsigned long long; };\n    template <typename T> struct safely_multipliable<T, constraints_t<std::is_unsigned<T>, is_nbit<T, 64>>> { using type = __uint128_t; };\n    template <typename T> using safely_multipliable_t = typename safely_multipliable<T>::type;\n\n    template <typename T, typename = void> struct rec_value_type { using type = T; };\n    template <typename T> struct rec_value_type<T, std::void_t<typename T::value_type>> {\n        using type = typename rec_value_type<typename T::value_type>::type;\n    };\n    template <typename T> using rec_value_type_t = typename rec_value_type<T>::type;\n\n    template <typename ReturnType, typename Callable, typename ...Args>\n    using is_same_as_invoke_result = std::is_same<std::invoke_result_t<Callable, Args...>, ReturnType>;\n    template <typename F, typename T> using is_uni_op = is_same_as_invoke_result<T, F, T>;\n    template <typename F, typename T> using is_bin_op = is_same_as_invoke_result<T, F, T, T>;\n\n    template <typename T> class is_iterable {\n        template <typename T_> static auto test(T_ e) -> decltype(e.begin(), e.end(), std::true_type{});\n        static std::false_type test(...);\n    public:\n        static constexpr bool value = decltype(test(std::declval<T>()))::value;\n    };\n    template <typename T> static constexpr bool is_iterable_v = is_iterable<T>::value;\n    template <typename T> class is_writable {\n        template <typename T_> static auto test(T_ e) -> decltype(std::declval<std::ostream&>() << e, std::true_type{});\n        static std::false_type test(...);\n    public:\n        static constexpr bool value = decltype(test(std::declval<T>()))::value;\n    };\n    template <typename T> static constexpr bool is_writable_v = is_writable<T>::value;\n    template <typename T> class is_readable {\n        template <typename T_> static auto test(T_ e) -> decltype(std::declval<std::istream&>() >> e, std::true_type{});\n        static std::false_type test(...);\n    public:\n        static constexpr bool value = decltype(test(std::declval<T>()))::value;\n    };\n    template <typename T> static constexpr bool is_readable_v = is_readable<T>::value;\n}\n\nnamespace Fast::io {\n    template <typename IStream, std::enable_if_t<std::conjunction_v<std::is_base_of<std::istream, std::remove_reference_t<IStream>>, std::negation<std::is_const<std::remove_reference_t<IStream>>>>, std::nullptr_t> = nullptr>\n    struct InputStream {\n    private:\n        using istream_type = std::remove_reference_t<IStream>;\n        IStream is;\n        struct { InputStream* is; template <typename T> operator T() { T e; *is >> e; return e; } } _reader{ this };\n    public:\n        template <typename IStream_> InputStream(IStream_ &&is) : is(std::move(is)) {}\n        template <typename IStream_> InputStream(IStream_ &is) : is(is) {}\n        template <typename T> InputStream& operator>>(T& e) {\n            if constexpr (Trait_Base::is_readable_v<T>) is >> e; else _read(e);\n            return *this;\n        }\n        auto read() { return _reader; }\n        template <typename Head, typename... Tail> void read(Head& head, Tail &...tails) { ((*this >> head) >> ... >> tails); }\n        istream_type& get_stream() { return is; }\n    private:\n        static __uint128_t _stou128(const std::string& s) {\n            __uint128_t ret = 0;\n            for (char c : s) if ('0' <= c and c <= '9') ret = 10 * ret + c - '0';\n            return ret;\n        }\n        static __int128_t _stoi128(const std::string& s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }\n\n        void _read(__uint128_t& v) { v = _stou128(std::string(_reader)); }\n        void _read(__int128_t& v) { v = _stoi128(std::string(_reader)); }\n        template <typename T, typename U> void _read(std::pair<T, U>& a) { *this >> a.first >> a.second; }\n        template <size_t N = 0, typename ...Args> void _read(std::tuple<Args...>& a) { if constexpr (N < sizeof...(Args)) *this >> std::get<N>(a), _read<N + 1>(a); }\n        template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr> void _read(Iterable& a) { for (auto& e : a) *this >> e; }\n    };\n    template <typename IStream> InputStream(IStream &&) -> InputStream<IStream>;\n    template <typename IStream> InputStream(IStream &) -> InputStream<IStream&>;\n    InputStream cin{ std::cin };\n    auto read() { return cin.read(); }\n    template <typename Head, typename... Tail> void read(Head& head, Tail &...tails) { cin.read(head, tails...); }\n}\n\nnamespace Fast::io {\n    template <typename OStream, std::enable_if_t<std::conjunction_v<std::is_base_of<std::ostream, std::remove_reference_t<OStream>>, std::negation<std::is_const<std::remove_reference_t<OStream>>>>, std::nullptr_t> = nullptr>\n    struct OutputStream {\n    private:\n        using ostream_type = std::remove_reference_t<OStream>;\n        OStream os;\n    public:\n        template <typename OStream_> OutputStream(OStream_ &&os) : os(std::move(os)) {}\n        template <typename OStream_> OutputStream(OStream_ &os) : os(os) {}\n        template <typename T> OutputStream& operator<<(const T& e) {\n            if constexpr (Trait_Base::is_writable_v<T>) os << e; else _print(e);\n            return *this;\n        }\n        void print() { *this << '\\n'; }\n        template <typename Head, typename... Tail>\n        void print(const Head& head, const Tail &...tails) { *this << head, ((*this << ' ' << tails), ...), *this << '\\n'; }\n        template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\n        void print_all(const Iterable& v, std::string sep = \" \", std::string end = \"\\n\") {\n            for (auto it = v.begin(); it != v.end();) if (*this << *it; ++it != v.end()) *this << sep;\n            *this << end;\n        }\n        ostream_type& get_stream() { return os; }\n    private:\n        void _print(__uint128_t value) {\n            char buffer[41], *d = std::end(buffer);\n            do *--d = '0' + (value % 10), value /= 10; while (value);\n            os.rdbuf()->sputn(d, std::end(buffer) - d);\n        }\n        void _print(__int128_t value) {\n            if (value < 0) *this << '-';\n            _print(__uint128_t(value < 0 ? -value : value));\n        }\n        template <typename T, typename U>\n        void _print(const std::pair<T, U>& a) { *this << a.first << ' ' << a.second; }\n        template <size_t N = 0, typename ...Args>\n        void _print(const std::tuple<Args...>& a) {\n            if constexpr (N < std::tuple_size_v<std::tuple<Args...>>) {\n                if constexpr (N) *this << ' ';\n                *this << std::get<N>(a), _print<N + 1>(a);\n            }\n        }\n        template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\n        void _print(const Iterable& a) { print_all(a, \" \", \"\"); }\n    };\n    template <typename OStream_> OutputStream(OStream_ &&) -> OutputStream<OStream_>;\n    template <typename OStream_> OutputStream(OStream_ &) -> OutputStream<OStream_&>;\n    OutputStream cout{ std::cout }, cerr{ std::cerr };\n    template <typename... Args> void print(const Args &... args) { cout.print(args...); }\n    template <typename Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\n    void print_all(const Iterable& v, const std::string& sep = \" \", const std::string& end = \"\\n\") { cout.print_all(v, sep, end); }\n}\n\nnamespace Numeric {\n    template <class T> constexpr T inf = std::numeric_limits<T>::max() / T(2);\n    template <class T> constexpr T Inf = std::numeric_limits<T>::max();\n    template <class T> bool chmin(T& x, const T& y) { return y >= x ? false : (x = y, true); }\n    template <class T> bool chmax(T& x, const T& y) { return y <= x ? false : (x = y, true); }\n    template <class T> constexpr int pow_m1(T n) { return -(n & 1) | 1; }\n    template <class T> constexpr T floor(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); }\n    template <class T> constexpr T ceil (const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); }\n\n    template <typename T, std::enable_if_t<std::negation_v<Trait_Base::is_nbit<T, 64>>, std::nullptr_t> = nullptr> __attribute__((target(\"popcnt\"))) constexpr int popcount(const T x) { return _mm_popcnt_u32(x); }\n    template <typename T, std::enable_if_t<Trait_Base::is_nbit_v<T, 64>, std::nullptr_t> = nullptr> __attribute__((target(\"popcnt\"))) constexpr int popcount(const T x) { return _mm_popcnt_u64(x); }\n    template <typename T, std::enable_if_t<std::negation_v<Trait_Base::is_nbit<T, 64>>, std::nullptr_t> = nullptr> constexpr int Msb(const T x) { return (x == 0 ? -1 : Trait_Base::bit_num<T> - 1 - __builtin_clz(x)); }\n    template <typename T, std::enable_if_t<Trait_Base::is_nbit_v<T, 64>, std::nullptr_t> = nullptr> constexpr int Msb(const T x) { return (x == 0 ? -1 : Trait_Base::bit_num<T> - 1 - __builtin_clzll(x)); }\n    template <typename T, std::enable_if_t<std::negation_v<Trait_Base::is_nbit<T, 64>>, std::nullptr_t> = nullptr> constexpr int Lsb(const T x) { return (x == 0 ? -1 : __builtin_ctz(x)); }\n    template <typename T, std::enable_if_t<Trait_Base::is_nbit_v<T, 64>, std::nullptr_t> = nullptr> constexpr int Lsb(const T x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }\n\n    template <typename T> constexpr int floor_log2(const T x) { return Trait_Base::bit_num<T> -1 - count_lz(x); }\n    template <typename T> constexpr int ceil_log2(const T x) { return floor_log2(x) + ((x & -x) != x); }\n    template <typename T> constexpr int kbit(const T x, const unsigned int k) { return (x >> k) & 1; }\n    template <typename T> constexpr int parity(const T x) { return popcount(x) & 1; }\n}\n\nnamespace Lambda {\n    template <class T, class ToKey, class CompKey = std::less<>, std::enable_if_t<std::conjunction_v<std::is_invocable<ToKey, T>, std::is_invocable_r<bool, CompKey, std::invoke_result_t<ToKey, T>, std::invoke_result_t<ToKey, T>>>, std::nullptr_t> = nullptr>\n    auto lambda(const ToKey& to_key, const CompKey& comp_key = std::less<>()) {\n        return [=](const T& x, const T& y) { return comp_key(to_key(x), to_key(y)); };\n    }\n    template <class Compare, std::enable_if_t<std::is_invocable_r_v<bool, Compare, int, int>, std::nullptr_t> = nullptr>\n    std::vector<int> sorted_indices(int n, const Compare& compare) {\n        std::vector<int> p(n);\n        return std::iota(p.begin(), p.end(), 0), std::sort(p.begin(), p.end(), compare), p;\n    }\n    template <class ToKey, std::enable_if_t<std::is_invocable_v<ToKey, int>, std::nullptr_t> = nullptr>\n    std::vector<int> sorted_indices(int n, const ToKey& to_key) { return sorted_indices(n, lambda<int>(to_key)); }\n\n    template <typename T, typename Gen, Trait_Base::constraints_t<Trait_Base::is_same_as_invoke_result<T, Gen, int>> = nullptr>\n    auto generate_vector(int n, Gen generator) { std::vector<T> v(n); for (int i = 0; i < n; ++i) v[i] = generator(i); return v; }\n    template <typename T> auto generate_range(T l, T r) { return generate_vector<T>(r - l, [l](int i) { return l + i; }); }\n    template <typename T> auto generate_range(T n) { return generate_range(0, n); }\n\n    template<class Head, class... Tail> struct multi_dim_vector { using type = std::vector<typename multi_dim_vector<Tail...>::type>; };\n    template<class T> struct multi_dim_vector<T> { using type = T; };\n    template<class T, class Arg> constexpr std::vector<T> make_vt(int n, Arg&& arg) { return std::vector<T>(n, std::forward<Arg>(arg)); }\n    template<class T, class... Args> constexpr typename multi_dim_vector<Args..., T>::type make_vt(int n, Args&&... args) { return typename multi_dim_vector<Args..., T>::type( n, make_vt<T>(std::forward<Args>(args)...)); }\n\n    template <class T, class Comparator>\n    auto priority_queue_with_comparator(const Comparator& comparator) { return std::priority_queue<T, std::vector<T>, Comparator>{ comparator }; }\n    template <class Iterable, std::enable_if_t<Trait_Base::is_iterable_v<Iterable>, std::nullptr_t> = nullptr>\n    void settify(Iterable& a) { std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); }\n}\n\nnamespace macro {\n#define IMPL_REPITER(cond) auto& begin() { return *this; } auto end() { return nullptr; } auto& operator*() { return _val; } auto& operator++() { return _val += _step, *this; } bool operator!=(std::nullptr_t) { return cond; }\n    template <class Int, class IntL = Int, class IntStep = Int, std::enable_if_t<(std::is_signed_v<Int> == std::is_signed_v<IntL>), std::nullptr_t> = nullptr> struct rep_impl {\n        Int _val; const Int _end, _step;\n        rep_impl(Int n) : rep_impl(0, n) {}\n        rep_impl(IntL l, Int r, IntStep step = 1) : _val(l), _end(r), _step(step) {}\n        IMPL_REPITER((_val < _end))\n    };\n    template <class Int, class IntL = Int, class IntStep = Int, std::enable_if_t<(std::is_signed_v<Int> == std::is_signed_v<IntL>), std::nullptr_t> = nullptr> struct rrep_impl {\n        Int _val; const Int _end, _step;\n        rrep_impl(Int n) : rrep_impl(0, n) {}\n        rrep_impl(IntL l, Int r) : _val(r - 1), _end(l), _step(-1) {}\n        rrep_impl(IntL l, Int r, IntStep step) : _val(l + Numeric::floor<Int>(r - l - 1, step) * step), _end(l), _step(-step) {}\n        IMPL_REPITER((_val >= _end))\n    };\n    template <class Int, class IntStep = Int> struct repinf_impl {\n        Int _val; const Int _step;\n        repinf_impl(Int l, IntStep step = 1) : _val(l), _step(step) {}\n        IMPL_REPITER((true))\n    };\n#undef IMPL_REPITER\n}\n\nnamespace String { const std::string Yes = \"Yes\", No = \"No\", YES = \"YES\", NO = \"NO\"; }\n\nnamespace Types {\n    using int128 = __int128_t;\n    using uint128 = __uint128_t;\n    using str = std::string;\n    template <class T> using min_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n    template <class T> using max_priority_queue = std::priority_queue<T, std::vector<T>, std::less<T>>;\n}\n\nusing Fast::io::read;\nusing Fast::io::print;\nusing Fast::io::print_all;\n\n#ifdef LOCAL\n#  define debug(...) do { Fast::io::cerr << \"[\" << __LINE__ << \"] \"; debug_impl(#__VA_ARGS__, __VA_ARGS__); } while(false)\ntemplate <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {\n    Fast::io::cerr << \"[\" << s << \"] \" << \": \" << h, ((Fast::io::cerr << \", \" << t), ..., (Fast::io::cerr << \"\\n\"));\n}\n#else\n#  pragma GCC optimize(\"Ofast\")\n#  pragma GCC optimize(\"unroll-loops\")\n#  define debug(...) void(42)\n#endif\n\nstruct io_setup {\n    io_setup(int precision = 15) {\n        #ifdef LOCAL\n        freopen(\"C:\\\\Users\\\\thati\\\\OneDrive\\\\Documents\\\\T_Gm\\\\input.txt\",  \"r\", stdin);\n        freopen(\"C:\\\\Users\\\\thati\\\\OneDrive\\\\Documents\\\\T_Gm\\\\output.txt\", \"w\", stdout);\n        freopen(\"C:\\\\Users\\\\thati\\\\OneDrive\\\\Documents\\\\T_Gm\\\\error.txt\", \"w\", stderr);\n        #else\n        std::cin.tie(0)->sync_with_stdio(0);\n        std::cin.exceptions(std::ios::badbit | std::ios::failbit);\n        #endif\n        std::cout << std::fixed << std::setprecision(precision);\n    }\n} io_setup_{};\n\nusing namespace std;\nusing namespace Types;\nusing namespace String;\nusing namespace Lambda;\nusing namespace Numeric;\n\ntemplate<typename T>\nstruct Edge {\n    int frm, to;\n    T cost;\n    int id;\n};\n\ntemplate<typename T = int, bool directed = false>\nstruct Graph {\n    int N, M;\n    using cost_type = T;\n    using edge_type = Edge<T>;\n    vector<edge_type> edges;\n    vector<int> indptr;\n    vector<edge_type> csr_edges;\n    vector<int> vc_deg, vc_indeg, vc_outdeg;\n    bool prepared;\n\n    class OutgoingEdges {\n    public:\n        OutgoingEdges(const Graph *G, int l, int r) : G(G), l(l), r(r) {}\n        const edge_type *begin() const {\n            if (l == r) { return 0; }\n            return &G->csr_edges[l];\n        }\n        const edge_type *end() const {\n            if (l == r) { return 0; }\n            return &G->csr_edges[r];\n        }\n\n    private:\n        const Graph *G;\n        int l, r;\n    };\n\n    bool is_prepared() { return prepared; }\n    constexpr bool is_directed() { return directed; }\n\n    Graph() : N(0), M(0), prepared(0) {}\n    Graph(int N) : N(N), M(0), prepared(0) {}\n\n    void build(int n) {\n        N = n, M = 0;\n        prepared = 0;\n        edges.clear();\n        indptr.clear();\n        csr_edges.clear();\n        vc_deg.clear();\n        vc_indeg.clear();\n        vc_outdeg.clear();\n    }\n\n    void add(int frm, int to, T cost = 1, int i = -1) {\n        assert(!prepared);\n        assert(0 <= frm && 0 <= to && to < N);\n        if (i == -1) i = M;\n        auto e = edge_type({frm, to, cost, i});\n        edges.emplace_back(e);\n        ++M;\n    }\n\n    // wt, off\n    void read_tree(bool wt = false, int off = 1) { read_graph(N - 1, wt, off); }\n    void read_graph(int M, bool wt = false, int off = 1) {\n        for (int m = 0; m < M; ++m) {\n            Int(a, b);\n            a -= off, b -= off;\n            if (!wt) add(a, b);\n            else {\n                T c;\n                read(c);\n                add(a, b, c);\n            }\n        }\n        build();\n    }\n\n    void build() {\n        assert(!prepared);\n        prepared = true;\n        indptr.assign(N + 1, 0);\n        for (auto &&e: edges) {\n            indptr[e.frm + 1]++;\n            if (!directed) indptr[e.to + 1]++;\n        }\n        for (int v = 0; v < N; ++v) { indptr[v + 1] += indptr[v]; }\n        auto counter = indptr;\n        csr_edges.resize(indptr.back() + 1);\n        for (auto &&e: edges) {\n            csr_edges[counter[e.frm]++] = e;\n            if (!directed) csr_edges[counter[e.to]++] = edge_type({e.to, e.frm, e.cost, e.id});\n        }\n    }\n\n    OutgoingEdges operator[](int v) const {\n        assert(prepared);\n        return {this, indptr[v], indptr[v + 1]};\n    }\n    vector<int> deg_array() {\n        if (vc_deg.empty()) calc_deg();\n        return vc_deg;\n    }\n    pair<vector<int>, vector<int>> deg_array_inout() {\n        if (vc_indeg.empty()) calc_deg_inout();\n        return {vc_indeg, vc_outdeg};\n    }\n    int deg(int v) {\n        if (vc_deg.empty()) calc_deg();\n        return vc_deg[v];\n    }\n    int in_deg(int v) {\n        if (vc_indeg.empty()) calc_deg_inout();\n        return vc_indeg[v];\n    }\n    int out_deg(int v) {\n        if (vc_outdeg.empty()) calc_deg_inout();\n        return vc_outdeg[v];\n    }\n\n    void __debug_t() {\n        debug(\"Graph\");\n        if (!prepared) {\n            debug(\"frm to cost id\");\n            for (auto &&e: edges) debug(e.frm, e.to, e.cost, e.id);\n        } else {\n            debug(indptr);\n            debug(\"frm to cost id\");\n            for (long long v = 0; v < N; v++) for (auto &&e: (*this)[v]) debug(e.frm, e.to, e.cost, e.id);\n        }\n    }\n\n    vector<int> new_idx;\n    vector<bool> used_e;\n\n    // Make vertex V[i] in G become i in the new graph\n    // returns {G, es}\n    pair<Graph<T, directed>, vector<int>> rearrange( vector<int> V) {\n        if (new_idx.size() != N) new_idx.assign(N, -1);\n        if (used_e.size() != M) used_e.assign(M, 0);\n        int n = V.size();\n        for (int i = 0; i < N; i++) new_idx[V[i]] = i;\n        Graph<T, directed> G(n);\n        vector<int> es;\n        for (int i = 0; i < n; i++) {\n            for (auto &&e: (*this)[V[i]]) {\n                if (used_e[e.id]) continue;\n                int a = e.frm, b = e.to;\n                if (new_idx[a] != -1 && new_idx[b] != -1) {\n                    used_e[e.id] = 1;\n                    G.add(new_idx[a], new_idx[b], e.cost);\n                    es.emplace_back(e.id);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) new_idx[V[i]] = -1;\n        for (auto &&eid: es) used_e[eid] = 0;\n        G.build();\n        return {G, es};\n    }\n\nprivate:\n    void calc_deg() {\n        assert(vc_deg.empty());\n        vc_deg.resize(N);\n        for (auto &&e: edges) vc_deg[e.frm]++, vc_deg[e.to]++;\n    }\n\n    void calc_deg_inout() {\n        assert(vc_indeg.empty());\n        vc_indeg.resize(N);\n        vc_outdeg.resize(N);\n        for (auto &&e: edges) { vc_indeg[e.to]++, vc_outdeg[e.frm]++; }\n    }\n};\n\ntemplate <typename GT>\npair<vector<int>, vector<int>> find_cycle_directed(GT& G) {\n    assert(G.is_directed());\n    assert(G.is_prepared());\n\n    int N = G.N;\n    vector<int> used(N);\n    vector<pair<int, int>> par(N);\n    vector<int> es, vs;\n\n    auto dfs = [&](auto self, int v) -> void {\n        used[v] = 1;\n        for (auto&& e: G[v]) {\n            if (len(es)) return;\n            if (!used[e.to]) {\n                par[e.to] = {v, e.id};\n                self(self, e.to);\n            }\n            elif (used[e.to] == 1) {\n                es = {e.id};\n                int cur = v;\n                while (cur != e.to) {\n                    es.emplace_back(par[cur].second);\n                    cur = par[cur].first;\n                }\n                reverse(All(es));\n                return;\n            }\n        }\n        used[v] = 2;\n    };\n    for(int v = 0; v < N; v++) if (!used[v]) dfs(dfs, v);\n    if (es.empty()) return {vs, es};\n\n    vs.resize(len(es));\n    for(int i = 0; i < len(es); i++) { vs[i] = G.edges[es[i]].frm; }\n    return {vs, es};\n}\n\ntemplate <typename GT>\npair<vector<int>, vector<int>> find_cycle_undirected(GT& G) {\n    const int N = G.N;\n    const int M = G.M;\n    vector<int> dep(N, -1);\n    vector<bool> used_e(M);\n    vector<int> par(N, -1);\n\n    auto dfs = [&](auto& dfs, int v, int d) -> int {\n        dep[v] = d;\n        for (auto&& e: G[v]) {\n            if (used_e[e.id]) continue;\n            if (dep[e.to] != -1) return e.id;\n            used_e[e.id] = 1;\n            par[e.to] = e.id;\n            int res = dfs(dfs, e.to, d + 1);\n            if (res != -1) return res;\n        }\n        return -1;\n    };\n\n    vector<int> vs, es;\n    for(int v = 0; v < N; v++) {\n        if (dep[v] != -1) continue;\n        int e0 = dfs(dfs, v, 0);\n        if (e0 == -1) continue;\n        int a = G.edges[e0].frm, b = G.edges[e0].to;\n        if (dep[a] > dep[b]) swap(a, b);\n        es.emplace_back(e0);\n        vs.emplace_back(a);\n        while (1) {\n            int x = vs.back();\n            auto& e = G.edges[es.back()];\n            int y = e.frm + e.to - x;\n            if (y == a) break;\n            vs.emplace_back(y);\n            es.emplace_back(par[y]);\n        }\n        return {vs, es};\n    }\n    return {vs, es};\n}\n\n// {vs, es} \uff1aReturns a sequence of edges and a sequence of vertices. es[i] is vs[i] to vs[i+1].\ntemplate <typename GT>\npair<vector<int>, vector<int>> find_cycle(GT& G) {\n    if (G.is_directed()) return find_cycle_directed(G);\n    return find_cycle_undirected(G);\n}\n\nstruct FastSet {\n    using uint = unsigned;\n    using ull = unsigned long long;\n\n    int bsr(ull x) { return 63 - __builtin_clzll(x); }\n    int bsf(ull x) { return __builtin_ctzll(x); }\n\n    static constexpr uint B = 64;\n    int n, lg;\n    vector<vector<ull>> seg;\n    FastSet(int _n) : n(_n) {\n        do {\n            seg.push_back(vector<ull>((_n + B - 1) / B));\n            _n = (_n + B - 1) / B;\n        } while (_n > 1);\n        lg = int(seg.size());\n    }\n    bool operator[](int i) const { return (seg[0][i / B] >> (i % B) & 1) != 0; }\n    void insert(int i) {\n        for (int h = 0; h < lg; h++) {\n            seg[h][i / B] |= 1ULL << (i % B);\n            i /= B;\n        }\n    }\n    void add(int i) { insert(i); }\n    void erase(int i) {\n        for (int h = 0; h < lg; h++) {\n            seg[h][i / B] &= ~(1ULL << (i % B));\n            if (seg[h][i / B]) break;\n            i /= B;\n        }\n    }\n    void remove(int i) { erase(i); }\n\n    // x\u4ee5\u4e0a\u6700\u5c0f\u306e\u8981\u7d20\u3092\u8fd4\u3059\u3002\u5b58\u5728\u3057\u306a\u3051\u308c\u3070 n\u3002\n    int next(int i) {\n        chmax(i, 0);\n        if (i >= n) return n;\n        for (int h = 0; h < lg; h++) {\n            if (i / B == seg[h].size()) break;\n            ull d = seg[h][i / B] >> (i % B);\n            if (!d) {\n                i = i / B + 1;\n                continue;\n            }\n            // find\n            i += bsf(d);\n            for (int g = h - 1; g >= 0; g--) {\n                i *= B;\n                i += bsf(seg[g][i / B]);\n            }\n            return i;\n        }\n        return n;\n    }\n\n    // x\u4ee5\u4e0b\u6700\u5927\u306e\u8981\u7d20\u3092\u8fd4\u3059\u3002\u5b58\u5728\u3057\u306a\u3051\u308c\u3070 -1\u3002\n    int prev(int i) {\n        if (i < 0) return -1;\n        if (i >= n) i = n - 1;\n        for (int h = 0; h < lg; h++) {\n            if (i == -1) break;\n            ull d = seg[h][i / B] << (63 - i % 64);\n            if (!d) {\n                i = i / B - 1;\n                continue;\n            }\n            // find\n            i += bsr(d) - (B - 1);\n            for (int g = h - 1; g >= 0; g--) {\n                i *= B;\n                i += bsr(seg[g][i / B]);\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    // [l, r)\n    template <typename F>\n    void enumerate(int l, int r, F f) {\n        int x = l - 1;\n        while (1) {\n            x = next(x + 1);\n            if (x >= r) break;\n            f(x);\n        }\n    }\n\n    template<class output_stream>\n    friend output_stream &operator<<(output_stream &out, const FastSet &Fs){\n        out << \"[\";\n        for(auto i = 0; i < Fs.n; ++ i){\n            out << Fs[i];\n            if(i != Fs.n - 1) out << \", \";\n        }\n        return out << ']';\n    }\n};\n\n\n// \u8f9e\u66f8\u9806\u6700\u5c0f\u306e toposort \u3092\u8fd4\u3059\ntemplate <typename GT>\nvector<int> toposort(GT& G) {\n    assert(G.is_prepared() && G.is_directed());\n    const int N = G.N;\n    auto [indeg, outdeg] = G.deg_array_inout();\n    FastSet que(N);\n    vector<int> V;\n    for(int v = 0; v < N; v++) if (indeg[v] == 0) que.insert(v);\n    while (1) {\n        int v = que.next(0);\n        if (v == N) break;\n        que.erase(v), V.emplace_back(v);\n        for (auto&& e: G[v]) {\n            if (--indeg[e.to] == 0) que.insert(e.to);\n        }\n    }\n    return ((int)(V.size()) < N ? vector<int>{} : V);\n}\n\n\nsigned main(){\n    Int(n, m);\n    Graph<int, true> G(n);\n    G.read_graph(m, true);\n\n    int cst = *ranges::partition_point(ranges::iota_view(0, inf<int>), [&](int cost){\n        Graph<int, true> _G(n);\n        Each(ed, G.edges){\n            if (ed.cost > cost) _G.add(ed.frm, ed.to);\n        }\n        _G.build();\n        auto [es, vs] = find_cycle(_G);\n        return not vs.empty();\n    });\n    vector<int> ret;\n\n    Graph<int, true> _G(n);\n    Each(ed, G.edges){\n        if (ed.cost > cst) _G.add(ed.frm, ed.to);\n    }\n    _G.build();\n    auto tsort = toposort(_G);\n    vector<int> pos(n);\n    For(x, n) pos[tsort[x]] = x;\n\n    Each(ed, G.edges){\n        if (ed.cost <= cst and pos[ed.frm] > pos[ed.to]) {\n            ret.push_back(ed.id + 1);\n        }\n    }\n    print(cst, len(ret));\n    print(ret);\n    return 0;\n}\n\n\t \t\t\t \t \t   \t \t\t \t     \t\t\t  \t\t"
}