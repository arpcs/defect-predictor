{
    "id": 228128552,
    "contestId": 1701,
    "creationTimeSeconds": 1697268654,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1701,
        "index": "C",
        "name": "Schedule Management",
        "type": "PROGRAMMING",
        "rating": 1400,
        "tags": [
            "binary search",
            "greedy",
            "implementation",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1701,
        "members": [
            {
                "handle": "suyasho786"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1657290900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp> // Common file\r\n// #include <ext/pb_ds/tree_policy.hpp> // Including \r\n\r\nusing namespace std;\r\n// using namespace __gnu_pbds;\r\n\r\n#define int long long\r\n#define pb push_back\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define sz(x) (int)(x).size()\r\n#define len(x) (int)(x).length()\r\n#define all(x) x.begin(), x.end()\r\n#define maxi(x) max_element(x.begin(), x.end());\r\n#define mini(x) min_element(x.begin(), x.end());\r\n#define rev(x) reverse(all(x))\r\n#define YES cout<<\"YES\"<<endl;\r\n#define NO cout<<\"NO\"<<endl;\r\n#define Yes cout<<\"Yes\"<<endl;\r\n#define No cout<<\"No\"<<endl;\r\n#define minus cout<<\"-1\"<<endl;\r\n#define rep(i,k,n)   for (int i = k; i <=n; i++)\r\n#define vi vector<int>\r\n#define mii map<int,int>\r\n#define in insert\r\n#define ndl cout<<'\\n'\r\n\r\n// //less function tells ascending order , if we do greater then descending order , if we do less_equal then multiset jesse same values ko bhi store krega\r\n// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\r\n \r\n#ifndef ONLINE_JUDGE\r\n#define dbg(x...) cerr << #x<<\" \" ; _print(x) ;cerr<< endl;\r\n#else\r\n#define dbg(x...);\r\n#endif\r\n \r\n \r\n//templates debugging \r\nvoid _print(double a){cerr<<a<<endl;}\r\nvoid _print(int a ){cerr<<a<<endl;}\r\nvoid _print(char a){cerr<<a<<endl;}\r\n// void _print(long long a ){cerr<<a<<endl;}\r\nvoid _print(long double a ){cerr<<a<<endl;}\r\nvoid _print(string a){cerr<<a<<endl;}\r\nvoid _print(bool a){cerr<<a<<endl;}\r\n \r\ntemplate <class T , class C > void _print(pair<T,C> p){cerr<<p.ft<<\" \"<<p.ss<<endl;}\r\ntemplate <class T> void _print(vector<T> a){cerr<<\"[\";for(auto &i:a){cerr<<i<<\" \";}cerr<<\"]\";cerr<<endl;}\r\ntemplate <class T> void _print(set<T> a){cerr<<\"[\";for(auto &i:a){cerr<<i<<\" \";}cerr<<\"]\";cerr<<endl;}\r\ntemplate <class T> void _print(unordered_set<T> a){cerr<<\"[\";for(auto &i:a){cerr<<i<<\" \";}cerr<<\"]\";cerr<<endl;}\r\ntemplate <class T , class C> void _print(map<T,C> a){for(auto &i:a){cerr<<\"[\"<<i.first<<\"->\"<<i.second<<\"] \";}cerr<<endl;}\r\ntemplate <class T , class C> void _print(unordered_map<T,C> a){for(auto &i:a){cerr<<\"[\"<<i.first<<\"->\"<<i.second<<\"] \";}cerr<<endl;}\r\ntemplate <class T> void _print(vector<vector<T>> a){for(auto &i:a){cerr<<\"[\";for(auto &j:i){cerr<<j<<\" \";}cerr<<\"]\";}}\r\ntemplate <class T > void _print(multiset<T> a){for(auto &i:a){cerr<<i<<\" \";}cerr<<endl;}\r\n \r\n// input template\r\n \r\ntemplate <class T> void input(vector<T> &v , int n){for(int i =0;i<n;i++){T x;cin>>x;v.pb(x);}}\r\ntemplate <class T> void input(vector<vector<T>> &v , int n , int m){for(int i =0;i<n;i++){vector<T> temp;for(int j =0;j<m;j++){T x;cin>>x;temp.pb(x);}v.pb(temp);}}\r\ntemplate<class T , class P > void _print(vector<pair<T,P>> a){for(auto &i:a){cerr<<i.first<<\" \"<<i.second<<endl;}}\r\nvoid init1(){\r\n    #ifndef ONLINE_JUDGE\r\n        freopen(\"inputf.in\", \"r\", stdin);\r\n        freopen(\"output.txt\", \"w\", stdout);\r\n    #endif\r\n}\r\nvoid init2(){\r\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\r\n    #ifndef ONLINE_JUDGE \r\n        freopen(\"error.txt\", \"w\", stderr);\r\n    #endif\r\n}\r\n\r\n//dfs**///\r\n\r\nvoid dfs(int child , int parent,vector<vi> &graph,vi &vis,map<int,int> &mp){\r\n\tvis[child]=1;\r\n\tfor(auto &i:graph[child]){\r\n\t\tif(!vis[i]){\r\n\t\t\tdfs(i,child,graph,vis,mp);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//** power function **//\r\ndouble fast_pow(double base, int exponent) {\r\n    if (exponent == 0)\r\n        return 1;\r\n    else if (exponent % 2 == 0) {\r\n        double temp = fast_pow(base, exponent / 2);\r\n        return temp * temp;\r\n    } else {\r\n        double temp = fast_pow(base, (exponent - 1) / 2);\r\n        return base * temp * temp;\r\n    }\r\n}\r\n\r\nint mod = 1e9 + 7;\r\nint longestIncreasingSubsequence(int current , int previous , vector<int> &v , vector<vector<int>> &dp){\r\n\tif(current>=v.size()){\r\n\t\treturn 0;\r\n\t}\r\n\tif(dp[current][previous]!=-1)return dp[current][previous];\r\n\r\n    int ans = 0;\r\n\tif(previous==0  ||  v[previous]<v[current]){\r\n\t\t// either pick or not pick\r\n\t\t//pick\r\n\t\tint pick = 1 + longestIncreasingSubsequence(current+1,current,v,dp);\r\n\t\t//not pick\r\n\t\tint notPick = longestIncreasingSubsequence(current+1,previous,v,dp);\r\n\t\tans=max(pick,notPick);\r\n\t}else{\r\n\t\t//not pick\r\n\t\tans = longestIncreasingSubsequence(current+1,previous,v,dp);\r\n\t}\r\n\r\n\treturn dp[current][previous] =  ans;\r\n}\r\n\r\n\r\nvoid merge(vector<int> &arr, vector<int> &arr2 , vector<int> &c ){\r\n\tint i=0,j=0,k=0;\r\n    int n=arr.size(),m=arr2.size();\r\n\r\n\twhile(i<n  &&   j<m){\r\n\t\tif(arr[i]<arr2[j]){\r\n           c[k]=arr[i];\r\n           i++;\r\n           k++;\r\n\t\t}else{\r\n\t\t\tc[k]=arr2[j];\r\n\t\t\tj++;\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\twhile(i<n){\r\n\t\tc[k]=arr[i];\r\n\t\ti++;k++;\r\n\t}\r\n\r\n\twhile(j<m){\r\n\t\tc[k]=arr2[j];\r\n\t\tj++;\r\n\t\tk++;\r\n\t}\r\n}\r\n\r\n/*{\r\n\torderded_set ya pbds\r\n\tpbds A;\r\n\tA.insert(4);\r\n    A.insert(2);\r\n    A.insert(43);\r\n    A.insert(1);\r\n\r\n\tfor (auto &i:A)cout<<i<<\" \";\r\n\tndl;\r\n\r\n    //find by order returns the value at partiular index\r\n    cout<<*A.find_by_order(0);ndl;//log(n)\r\n    cout<<*A.find_by_order(1);ndl;\r\n    cout<<*A.find_by_order(2);ndl;\r\n    ndl;\r\n\r\n\r\n    // order_of_key btata h ek treeke se uska index kyuki ye btaega isse chhota wala \r\n    cout<<A.order_of_key(45);ndl;//log(n)\r\n    cout<<A.order_of_key(1);ndl;\r\n    cout<<A.order_of_key(2);ndl;\r\n\r\n\r\n    //.erase us value ko erase kr dega\r\n    A.erase(1);\r\n    A.erase(12);//if erase that is not present then no issue no changes would be done\r\n    \r\n\r\n\r\n    for(auto &i:A)cout<<i<<\" \";\r\n    ndl;\r\n\r\n    cout<<*A.lower_bound(2);ndl;//just like set return number equal or greater than tht number\r\n    A.erase(A.lower_bound(41));\r\n}*/\r\n\r\n\r\n// class SGTree{\r\n// \tvi seg;\r\n// public : \r\n// \tSGTree(n1){\r\n//        seg.resize(4*n1);\r\n// \t}\r\n\r\n// \t//build\r\n//     void build(int ind , int left , int right , vi &arr){\r\n//     \tif(left==right){\r\n//     \t\tseg[ind] = arr[low];\r\n//     \t\treturn;\r\n//     \t}\r\n        \r\n//         int mid = (left+right)/2;\r\n//     \tbuild(2*ind+1,left , mid,arr);\r\n//     \tbuild(2*ind+2,mid+1,right,arr);\r\n//     \tseg[ind] = min(seg[2*ind+1],seg[2*ind+2]);\r\n//     }\r\n\r\n\r\n//     ///example l=2,r=4 min(2,4) niaklna h or left=0,right=n-1\r\n// \t//query -> left : starting index , right : ending index  , l:min khase nikalna h , r: min kha tak nikalna h\r\n// \tint query(int l , int r , int left , int right , int ind ){\r\n//        // no over lapping\r\n//        if(r<left ||  l>right){\r\n//        \treturn INT_MAX;\r\n//        }\r\n//        //full overlapping\r\n//        if(l<=left  &&   right<=r){\r\n//        \treturn seg[ind];\r\n//        }\r\n\r\n//        //partial\r\n//        int mid = (left + high)/2;\r\n//        int leftSide = query(l,r,left,mid,2*ind+1);\r\n//        int rightSide = query(l,r,mid+1,right,2*ind+2);\r\n//        seg[ind] = min(leftSide,rightSide);\r\n// \t}\r\n\r\n\r\n// \t//update\r\n// \tvoid update(int val , int indexChanged , int currIndex , int left , int right){\r\n// \t\tif(left==right){\r\n// \t\t\tseg[indexChanged]=val;\r\n// \t\t}\r\n\r\n// \t\tint mid = (left+right)/2;\r\n// \t\tif(indexChanged<=mid){\r\n// \t\t\tupdate(val,indexChanged,2*currIndex+1,left,mid);\r\n// \t\t}else{\r\n// \t\t\tupdate(val,indexChanged,2*indexChanged+2,mid+1,right);\r\n// \t\t}\r\n\r\n// \t\tseg[currIndex] = min(seg[2*currIndex+1],seg[2*currIndex+2]);\r\n\r\n// \t}\r\n// };\r\n\r\n// bool binarySearch(){\r\n\r\n// \tint l=0,h=n-1,ans=-1;\r\n// \twhile(h>=l){\r\n// \t\tint mid = (l+h)/2;\r\n// \t\tif(weight[mid]>search){\r\n// \t\t\th=mid-1;\r\n// \t\t}else{\r\n// \t\t\tl=mid+1;\r\n// \t\t}\r\n// \t}\r\n\r\n// }\r\n\r\n\r\nvoid dfs(vector<pair<int,int>>adj[], int node, int par, int parTime, int& result, int time){\r\n    result = max(result, parTime);\r\n \r\n    for(auto &it: adj[node]){\r\n        int child = it.first;\r\n        int childTime = it.second;\r\n        if(child == par) continue;\r\n        else{\r\n            dfs(adj, child, node, parTime + (childTime<time) , result, childTime);\r\n        }\r\n    }\r\n}\r\nint findStartIndex(const std::vector<int>& nums, int target) {\r\n    int left = 0;\r\n    int right = nums.size() - 1;\r\n    int startIndex = -1;\r\n\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n\r\n        if (nums[mid] == target) {\r\n            startIndex = mid;\r\n            right = mid - 1; // Continue searching in the left half\r\n        } else if (nums[mid] < target) {\r\n            left = mid + 1;\r\n        } else {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n\r\n    return startIndex;\r\n}\r\n\r\n// Binary search to find the ending index of a number\r\nint findEndIndex(const std::vector<int>& nums, int target) {\r\n    int left = 0;\r\n    int right = nums.size() - 1;\r\n    int endIndex = -1;\r\n\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n\r\n        if (nums[mid] == target) {\r\n            endIndex = mid;\r\n            left = mid + 1; // Continue searching in the right half\r\n        } else if (nums[mid] < target) {\r\n            left = mid + 1;\r\n        } else {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n\r\n    return endIndex;\r\n}\r\n\r\nvector<int> primeFactors(int n) {\r\n    vector<int> factors;\r\n    for (int i = 2; i * i <= n; ++i) {\r\n        while (n % i == 0) {\r\n            factors.push_back(i);\r\n            n /= i;\r\n        }\r\n    }\r\n    if (n > 1)\r\n        factors.push_back(n);\r\n    return factors;\r\n}\r\n\r\n\r\n\r\nvoid solve(){\r\n\tint n,m;\r\n\tcin>>n>>m;\r\n\r\n\tvi v;\r\n\tfor(int i=0;i<m;i++){\r\n\t\tint x;\r\n\t\tcin>>x;\r\n\t\tx--;\r\n\t\tv.pb(x);\r\n\t}\r\n\r\n\tauto bs=[&](int mid){\r\n\t\tvi temp(n,0),buffer;\r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tif(temp[v[i]]<mid)temp[v[i]]++;\r\n\t\t\telse buffer.pb(v[i]);\r\n\t\t}\r\n        dbg(buffer)\r\n        for(int i=0;i<n  &&  buffer.size()>0;i++){\r\n        \tdbg(temp[i]+2)\r\n        \tdbg(i)\r\n        \twhile(temp[i]+2<=mid){\r\n        \t\tbuffer.pop_back();\r\n        \t\ttemp[i]+=2;\r\n        \t}\r\n        }\r\n\r\n        dbg(temp)\r\n        dbg(mid)\r\n        dbg(buffer)\r\n\r\n        if(buffer.size()>0)return false;\r\n        else return true;\r\n\t};\r\n\r\n\tint ans=-1,l=1,h=m;\r\n\twhile(h-l>1){\r\n\t\tint mid = (h+l)/2;\r\n\t\tif(bs(mid)){\r\n\t\t\t\r\n\t\t\th=mid\r\n\t\t}else{\r\n\t\t\tl=mid;\r\n\t\t}\r\n\t}\r\n\r\n           if(bs(h))cout<<h<<endl;\r\n           else cout<<l<<endl;\r\n}\r\nsigned main()\r\n{\r\n\t\r\n\tinit1();\r\n\tinit2();\r\n\tcout << std::fixed << std::setprecision(7);\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--){\r\n\t\tsolve();\r\n\t}\r\n\treturn 0;\r\n}\r\n \r\n\r\n\r\n\r\n\u00a0"
}