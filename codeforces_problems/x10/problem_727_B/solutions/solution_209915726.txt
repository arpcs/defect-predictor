{
    "id": 209915726,
    "contestId": 727,
    "creationTimeSeconds": 1686970598,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 727,
        "index": "B",
        "name": "Bill Total Value",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1600,
        "tags": [
            "expression parsing",
            "implementation",
            "strings"
        ]
    },
    "author": {
        "contestId": 727,
        "members": [
            {
                "handle": "Hackerman278"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1476522300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "\r\n#define _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <set>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <queue>\r\n#include <math.h>\r\n#include <bit>\r\n#include <bitset>\r\n#include <cstdint>\r\n#include <utility>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\nstruct DSU {\r\n\tint size;\r\n\tint* parent;\r\n\tint* height;\r\n\tint* weight;\r\n\r\n\tDSU(int _size) {\r\n\t\tsize = _size;\r\n\t\tparent = new int[size];\r\n\t\theight = new int[size];\r\n\t\tweight = new int[size];\r\n\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tparent[i] = i;\r\n\t\t\theight[i] = 1;\r\n\t\t\tweight[i] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\tint getRep(int a) {\r\n\t\tint tmp = a;\r\n\t\twhile (parent[tmp] != tmp) {\r\n\t\t\ttmp = parent[tmp];\r\n\t\t}\r\n\t\tparent[a] = tmp;\r\n\t\treturn tmp;\r\n\t}\r\n\r\n\tint getWeight(int a) {\r\n\t\treturn weight[getRep(a)];\r\n\t}\r\n\r\n\tbool connect(int a, int b) {\r\n\t\ta = getRep(a), b = getRep(b);\r\n\t\tif (a == b) return false;\r\n\t\tif (height[a] < height[b]) {\r\n\t\t\tparent[a] = b;\r\n\t\t\tweight[b] += weight[a];\r\n\t\t}\r\n\t\telse if (height[b] < height[a]) {\r\n\t\t\tparent[b] = a;\r\n\t\t\tweight[a] += weight[b];\r\n\t\t}\r\n\t\telse {\r\n\t\t\theight[a]++;\r\n\t\t\tparent[b] = a;\r\n\t\t\tweight[a] += weight[b];\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//skips 0!\r\n\tvector<int> getComponents() {\r\n\t\tvector<int> ans;\r\n\r\n\t\tfor (int i = 1; i < size; i++) {\r\n\t\t\tif (parent[i] != i) continue;\r\n\t\t\tans.push_back(weight[i]);\r\n\t\t}\r\n\r\n\t\treturn ans;\r\n\t}\r\n};\r\nstruct RangeSum {\r\nprivate:\r\n\tlong long size = 1ll;\r\n\tlong long* arr = nullptr;\r\n\r\n\tlong long getSumInternal(long long l, long long r, long long currL, long long currR, long long currNode) {\r\n\t\tif (currL > r || currR < l) return 0ll;\r\n\t\tif (currL >= l && currR <= r) return arr[currNode];\r\n\r\n\t\treturn getSumInternal(l, r, currL, (currR + currL) / 2ll, currNode * 2ll) +\r\n\t\t\tgetSumInternal(l, r, (currR + currL) / 2ll+1, currR, currNode * 2ll + 1ll);\r\n\t}\r\n\r\npublic:\r\n\tRangeSum(long long _size) {\r\n\t\twhile (size <= _size) size *= 2ll;\r\n\t\tsize *= 2ll;\r\n\t\tarr = new long long[size] {};\r\n\t}\r\n\r\n\tlong long getSum(long long l, long long r) {\r\n\t\treturn getSumInternal(l, r, 0, size / 2ll-1ll, 1ll);\r\n\t}\r\n\r\n\tvoid add(long long idx, long long value) {\r\n\t\tlong long curr = size / 2ll + idx;\r\n\t\t\r\n\t\twhile (curr) {\r\n\t\t\tarr[curr] += value;\r\n\t\t\tcurr /= 2ll;\r\n\t\t}\r\n\t}\r\n};\r\nstruct RangeMax {\r\nprivate:\r\n\tlong long size = 1ll;\r\n\tlong long* arr = nullptr;\r\n\r\n\tlong long getMaxInternal(long long l, long long r, long long currL, long long currR, long long currNode) {\r\n\t\tif (currL > r || currR < l) return 0ll;\r\n\t\tif (currL >= l && currR <= r) return arr[currNode];\r\n\r\n\t\treturn max(getMaxInternal(l, r, currL, (currR + currL) / 2ll, currNode * 2ll),\r\n\t\t\tgetMaxInternal(l, r, (currR + currL) / 2ll + 1, currR, currNode * 2ll + 1ll));\r\n\t}\r\npublic:\r\n\tRangeMax(long long _size) {\r\n\t\twhile (size <= _size) size *= 2ll;\r\n\t\tsize *= 2ll;\r\n\t\tarr = new long long[size] {};\r\n\t}\r\n\r\n\tvoid changeIdx(long long idx, long long value) {\r\n\t\tlong long curr = size / 2ll + idx;\r\n\t\tarr[curr] = value;\r\n\t\tcurr /= 2;\r\n\r\n\t\twhile (curr) {\r\n\t\t\tarr[curr] = max(arr[curr * 2], arr[curr * 2 + 1]);\r\n\t\t\tcurr /= 2ll;\r\n\t\t}\r\n\t}\r\n\r\n\tlong long getSum(long long l, long long r) {\r\n\t\treturn getMaxInternal(l, r, 0, size / 2ll - 1ll, 1ll);\r\n\t}\r\n};\r\nlong long binPow(long long x, long long y, long long mod) {\r\n\tif (y == 0ll) return 1ll;\r\n\r\n\tlong long tmp = binPow(x, y / 2ll, mod);\r\n\tif (y % 2ll == 0ll) return (tmp * tmp) % mod;\r\n\telse return (((x * tmp) % mod) * tmp) % mod;\r\n}\r\nstring add(string a, string b) {\r\n\tstring ans;\r\n\treverse(a.begin(), a.end());\r\n\treverse(b.begin(), b.end());\r\n\r\n\tint carry = 0;\r\n\tfor (int i = 0; i < max(a.size(), b.size()) + 1; i++) {\r\n\t\tint aN = (i < a.size() ? a[i] - '0' : 0);\r\n\t\tint bN = (i < b.size() ? b[i] - '0' : 0);\r\n\r\n\t\tans.push_back(((aN + bN + carry) % 10) + '0');\r\n\t\tcarry = (aN + bN + carry) / 10;\r\n\t}\r\n\twhile (ans.size() > 1 && ans.back() == '0') ans.pop_back();\r\n\r\n\treverse(ans.begin(), ans.end());\r\n\treturn ans;\r\n}\r\nstring minimStringNumber(string a, string b) {\r\n\tif (a.size() < b.size()) return a;\r\n\tif (b.size() < a.size()) return b;\r\n\r\n\tfor (int i = 0; i < a.size(); i++) {\r\n\t\tif (a[i] == b[i]) continue;\r\n\t\tif (a[i] < b[i]) return a;\r\n\t\treturn b;\r\n\t}\r\n\r\n\treturn a;\r\n}\r\n//bool isPrime(int n) {\r\n//\tif (n < 2) return false;\r\n//\tfor (int i = 2; i * i <= n; i++) {\r\n//\t\tif (n % i == 0) {\r\n//\t\t\treturn false;\r\n//\t\t}\r\n//\t}\r\n//\treturn true;\r\n//}\r\nlong long getGCD(long long a, long long b) {\r\n\tif (a == 0 || b == 0) return a + b;\r\n\treturn getGCD(b, a % b);\r\n}\r\nlong long getMSB(unsigned long long n) {\r\n\tint curr = 63;\r\n\twhile (curr >= 0) {\r\n\t\tif ((n >> curr) & 1ll) return (1ll << curr);\r\n\t\tcurr--;\r\n\t}\r\n\treturn -1;\r\n}\r\nint getLeftShiftOne(int n) {\r\n\tfor (int i = 0; i < 32; i++) {\r\n\t\tif ((n >> i) & 1) return i;\r\n\t}\r\n\treturn -1;\r\n}\r\nint myPopCount(int n) {\r\n\tint ans = 0;\r\n\twhile (n) {\r\n\t\tans++;\r\n\t\tn &= (n - 1);\r\n\t}\r\n\treturn ans;\r\n}\r\nvoid print(vector<int>& arr) {\r\n\tif (!arr.size()) {\r\n\t\tcout << endl;\r\n\t\treturn;\r\n\t}\r\n\tcout << arr[0];\r\n\tfor (int i = 1; i < arr.size(); i++) {\r\n\t\tcout << \" \" << arr[i];\r\n\t}\r\n\tcout << endl;\r\n}\r\nvoid print(vector<long long>& arr) {\r\n\tif (!arr.size()) return;\r\n\tcout << arr[0];\r\n\tfor (int i = 1; i < arr.size(); i++) {\r\n\t\tcout << \" \" << arr[i];\r\n\t}\r\n\tcout << \"\\n\";\r\n}\r\nvoid print(vector<bool>& arr) {\r\n\tif (!arr.size()) {\r\n\t\tcout << endl;\r\n\t\treturn;\r\n\t}\r\n\tcout << arr[0];\r\n\tfor (int i = 1; i < arr.size(); i++) {\r\n\t\tcout << \" \" << arr[i];\r\n\t}\r\n\tcout << endl;\r\n}\r\nvoid print(vector<vector<bool>>& mx) {\r\n\tfor (int i = 0; i < mx.size(); i++) {\r\n\t\tprint(mx[i]);\r\n\t}\r\n}\r\nvoid print(vector<vector<long long>>& mx) {\r\n\tfor (int i = 0; i < mx.size(); i++) {\r\n\t\tprint(mx[i]);\r\n\t}\r\n}\r\nvoid print(vector<vector<int>>& mx) {\r\n\tfor (int i = 0; i < mx.size(); i++) {\r\n\t\tprint(mx[i]);\r\n\t}\r\n}\r\nvoid print(vector<vector<char>>& mx) {\r\n\tfor (int i = 0; i < mx.size(); i++) {\r\n\t\tfor (int j = 0; j < mx[i].size(); j++) {\r\n\t\t\tcout << mx[i][j];\r\n\t\t}\r\n\t\tcout << \"\\n\";\r\n\t}\r\n}\r\nstruct Node {\r\n\tunordered_map<char, Node*> children;\r\n\tint visits = 0;\r\n\tstring filename = \"-\";\r\n\tint lastIdHere = -1;\r\n};\r\nstruct Trie {\r\n\tNode* root = new Node();\r\n\r\n\tvoid insert(string s, int id) {\r\n\t\t\r\n\t\tfor (int i = 0; i < s.size(); i++) {\r\n\t\t\tNode* curr = root;\r\n\r\n\t\t\tfor (int j = i; j < s.size(); j++) {\r\n\t\t\t\tif (!curr->children.count(s[j])) {\r\n\t\t\t\t\tcurr->children[s[j]] = new Node();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurr = curr->children[s[j]];\r\n\t\t\t\tif (curr->lastIdHere != id) {\r\n\t\t\t\t\tcurr->visits++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (curr->lastIdHere == -1) {\r\n\t\t\t\t\tcurr->filename = s;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurr->lastIdHere = id;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid query(string s) {\r\n\t\tNode* curr = root;\r\n\t\tfor (int i = 0; i < s.size(); i++) {\r\n\t\t\tif (!curr->children.count(s[i])) {\r\n\t\t\t\tcurr->children[s[i]] = new Node();\r\n\t\t\t}\r\n\r\n\t\t\tcurr = curr->children[s[i]];\r\n\t\t}\r\n\t\t\r\n\t\tcout << curr->visits << \" \";\r\n\t\tcout << curr->filename << \"\\n\";\r\n\t}\r\n};\r\nlong long inverse(long long a, long long mod) {\r\n\treturn binPow(a, mod - 2ll, mod);\r\n}\r\nlong long factorial(long long n, long long mod) {\r\n\tlong long ans = 1ll;\r\n\twhile (n > 1ll) {\r\n\t\tans = (ans * n) % mod;\r\n\t\tn--;\r\n\t}\r\n\treturn ans;\r\n}\r\nlong long nCk(long long n, long long k, long long mod) {\r\n\treturn (factorial(n, mod) * inverse(factorial(k, mod) * factorial(n-k, mod) % mod, mod) % mod) % mod;\r\n}\r\nvector<long long> getPrimes(long long n) {\r\n\tvector<long long> ans;\r\n\r\n\tif (n < 0ll) {\r\n\t\tans.push_back(-1ll);\r\n\t\tn = -n;\r\n\t}\r\n\r\n\tfor (long long i = 2ll; i * i <= n; i++) {\r\n\t\tif (n % i != 0) continue;\r\n\t\tans.push_back(i);\r\n\r\n\t\twhile (n % i == 0ll) n /= i;\r\n\t}\r\n\tif (n > 1) ans.push_back(n);\r\n\r\n\treturn ans;\r\n}\r\nvector<bool> sieve(int n) {\r\n\tvector<bool> ans(n, true);\r\n\tans[0] = 0, ans[1] = 0;\r\n\r\n\tfor (int i = 2; i < n; i++) {\r\n\t\tif (!ans[i]) continue;\r\n\r\n\t\tfor (int j = i+i; j < n; j += i) {\r\n\t\t\tans[j] = 0;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ans;\r\n}\r\n//find primes function\r\n//vector<int> primes;\r\n//void findPrimesUpTo(int n) {\r\n//\tvector<bool> prime(n+1, true);\r\n//\tfor (int i = 2; i <= n; i++) {\r\n//\t\tif (!prime[i]) continue;\r\n//\t\tprimes.push_back(i);\r\n//\t\tfor (int j = i; j < prime.size(); j += i) {\r\n//\t\t\tprime[j] = false;\r\n//\t\t}\r\n//\t}\r\n//}\r\n\r\n////maybe this is wrong\r\n//vector<long long> factorTable(10000001);\r\n//void populateFactorTable() {\r\n//\tfor (int i = 2; i < 10000001; i++) {\r\n//\t\tif (factorTable[i]) continue;\r\n//\t\tfor (int j = i; j < 10000001; j += i) {\r\n//\t\t\tfactorTable[j] = i;\r\n//\t\t}\r\n//\t}\r\n//}\r\n//\r\n//vector<long long> getFactors(long long n) {\r\n//\tvector<long long> ans;\r\n//\r\n//\twhile (n > 1) {\r\n//\t\tans.push_back(factorTable[n]);\r\n//\t\tlong long tmp = factorTable[n];\r\n//\t\twhile (n % tmp == 0) n /= tmp;\r\n//\t}\r\n//\r\n//\treturn ans;\r\n//}\r\n\r\n//vector<int> factorTable;\r\n//void solveFactorTable() {\r\n//\tfactorTable = vector<int>(1000001);\r\n//\r\n//\tfor (int i = 2; i < 1000001; i++) {\r\n//\t\tif (factorTable[i]) continue;\r\n//\t\tfor (int j = i; j < 1000001; j += i) {\r\n//\t\t\tif (factorTable[j]) continue;\r\n//\t\t\tfactorTable[j] = i;\r\n//\t\t}\r\n//\t}\r\n//}\r\n//\r\n//vector<int> getFactors(int n) {\r\n//\tvector<int> factors;\r\n//\twhile (n > 1) {\r\n//\t\tfactors.push_back(factorTable[n]);\r\n//\t\tn /= factorTable[n];\r\n//\t}\r\n//\treturn factors;\r\n//}\r\n\r\nvector<int> multisetUnion(vector<int>& a, vector<int>& b) {\r\n\tvector<int> ans;\r\n\r\n\tint ptrA = 0, ptrB = 0;\r\n\twhile (ptrA < a.size() && ptrB < b.size()) {\r\n\t\tif (a[ptrA] == b[ptrB]) {\r\n\t\t\tans.push_back(a[ptrA]);\r\n\t\t\tptrA++;\r\n\t\t\tptrB++;\r\n\t\t}\r\n\t\telse if (a[ptrA] < b[ptrB]) {\r\n\t\t\tptrA++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tptrB++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ans;\r\n}\r\nvector<int> multisetOr(vector<int>& a, vector<int>& b) {\r\n\tvector<int> ans;\r\n\r\n\tint ptrA = 0, ptrB = 0;\r\n\twhile (ptrA < a.size() && ptrB < b.size()) {\r\n\t\tif (a[ptrA] == b[ptrB]) {\r\n\t\t\tans.push_back(a[ptrA]);\r\n\t\t\tptrA++;\r\n\t\t\tptrB++;\r\n\t\t}\r\n\t\telse if (a[ptrA] < b[ptrB]) {\r\n\t\t\tans.push_back(a[ptrA]);\r\n\t\t\tptrA++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tans.push_back(b[ptrB]);\r\n\t\t\tptrB++;\r\n\t\t}\r\n\t}\r\n\r\n\twhile (ptrA < a.size()) ans.push_back(a[ptrA++]);\r\n\twhile (ptrB < b.size()) ans.push_back(b[ptrB++]);\r\n\r\n\treturn ans;\r\n}\r\nint popcount(int n) {\r\n\tint ans = 0;\r\n\twhile (n) {\r\n\t\tans += (n & 1);\r\n\t\tn >>= 1;\r\n\t}\r\n\treturn ans;\r\n}\r\nint log2ceil(int n) {\r\n\tint ans = 0;\r\n\tint curr = 1;\r\n\twhile (curr < n) {\r\n\t\tans++;\r\n\t\tcurr *= 2;\r\n\t}\r\n\r\n\treturn ans;\r\n\r\n}\r\nbool contains(vector<int>& v, int n) {\r\n\tfor (int i = 0; i < v.size(); i++) {\r\n\t\tif (v[i] == n) return true;\r\n\t}\r\n\treturn false;\r\n}\r\ndouble fAbs(double a) {\r\n\tif (a < 0.0) a = -a;\r\n\treturn a;\r\n}\r\nlong long getSum(vector<long long>& prefix, long long l, long long r) {\r\n\tif (l > r) return 0ll;\r\n\tif (l == 0) return prefix[r];\r\n\treturn prefix[r] - prefix[l - 1];\r\n}\r\nint cmpFrac(long long n1, long long d1, long long n2, long long d2) {\r\n\t//cout << \"fracLessThan\" << n1 * d2 << \" \" << n2 * d1 << endl;\r\n\t//cout<<\"result: \"<< (n1 * d2 < n2* d1);\r\n\tif (n1 * d2 < n2 * d1) return -1;\r\n\telse if (n1 * d2 > n2 * d1) return 1;\r\n\telse return 0;\r\n}\r\nbool linedUp(long long x1, long long y1, long long x2, long long y2, long long x3, long long y3) {\r\n\tif (!cmpFrac(x1 - x2, y1 - y2, x2 - x3, y2 - y3)) return true;\r\n\telse return false;\r\n}\r\n//WARNING: THIS ONLY WORKS WITH A SENTINEL LAYER\r\nint getSum2D(vector<vector<int>>& cnt, int up, int left, int down, int right) {\r\n\tint ans = 0;\r\n\r\n\tans += cnt[down][right];\r\n\tans -= cnt[down][left - 1];\r\n\tans -= cnt[up - 1][right];\r\n\tans += cnt[up - 1][left - 1];\r\n\r\n\treturn ans;\r\n}\r\nvoid print(vector<string>& s) {\r\n\tfor (int i = 0; i < s.size(); i++) {\r\n\t\tcout << s[i] << \"\\n\";\r\n\t}\r\n}\r\nbool isPrime(long long n) {\r\n\tif (n <= 1ll) return false;\r\n\r\n\tfor (long long i = 2ll; i * i <= n; i++) {\r\n\t\tif (n % i == 0) return false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool isPartOfNumber(char c) {\r\n\treturn (c >= '0' && c <= '9') || c == '.';\r\n}\r\n\r\nbool isLetter(char c) {\r\n\treturn c >= 'a' && c <= 'z';\r\n}\r\n\r\nlong long getIntCents(string amt) {\r\n\tif (amt.size() >= 3 && amt[amt.size() - 3] != '.') {\r\n\t\tamt += \".00\";\r\n\t}\r\n\telse if (amt.size() < 3) {\r\n\t\tamt += \".00\";\r\n\t}\r\n\r\n\tstring noDecimalAmt;\r\n\tfor (int i = 0; i < amt.size(); i++) {\r\n\t\tif (amt[i] == '.') continue;\r\n\t\tnoDecimalAmt.push_back(amt[i]);\r\n\t}\r\n\r\n\treturn stoll(noDecimalAmt);\r\n}\r\n\r\nstring getStringCents(long long amt) {\r\n\tstring dollars;\r\n\tstring cents;\r\n\r\n\tlong long dollarsInt = amt / 100;\r\n\tlong long centsInt = amt % 100;\r\n\r\n\tstring dollarsWithoutDecimals = to_string(dollarsInt);\r\n\twhile (!dollarsWithoutDecimals.empty()) {\r\n\t\tif (dollars.size() % 3 == 0 && !dollars.empty()) {\r\n\t\t\tdollars.push_back('.');\r\n\t\t}\r\n\r\n\t\tdollars.push_back(dollarsWithoutDecimals.back());\r\n\t\tdollarsWithoutDecimals.pop_back();\r\n\t}\r\n\treverse(dollars.begin(), dollars.end());\r\n\r\n\tif (centsInt > 0 && centsInt <= 9) {\r\n\t\tcents = \"0\";\r\n\t\tcents.push_back((char)(centsInt + '0'));\r\n\t}\r\n\telse if (centsInt > 0) {\r\n\t\tcents = to_string(centsInt);\r\n\t}\r\n\t\r\n\tif (!cents.empty()) return dollars + \".\" + cents;\r\n\telse return dollars;\r\n}\r\n\r\nvoid solve() {\r\n\tstring s;\r\n\tcin >> s;\r\n\r\n\tlong long cents = 0ll;\r\n\r\n\twhile (!s.empty()) {\r\n\t\tstring amt;\r\n\r\n\t\twhile (!s.empty() && isPartOfNumber(s.back())) {\r\n\t\t\tamt.push_back(s.back());\r\n\t\t\ts.pop_back();\r\n\t\t}\r\n\r\n\t\treverse(amt.begin(), amt.end()); //have to reverse cuz we put it in backwards\r\n\r\n\t\twhile (!s.empty() && isLetter(s.back())) {\r\n\t\t\ts.pop_back();\r\n\t\t}\r\n\r\n\t\tcents += getIntCents(amt);\r\n\t}\r\n\r\n\t//cout << cents << endl;\r\n\t//chznge this!!!!!!!!!!!!!!!\r\n\tcout << getStringCents(cents) << \"\\n\";\r\n}\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\t\r\n\t//preprocessing\r\n\t//long long x1 = 0ll, y1 = 0ll;\r\n\t//long long x2 = 1ll, y2 = 2ll;\r\n\t//long long x3 = 2ll, y3 = 4ll;\r\n\t//if (linedUp(x1, y1, x2, y2, x3, y3)) {\r\n\t//\tcout << \"yea\\n\";\r\n\t//}\r\n\t//else cout << \"na\\n\";\r\n\t//end preprocessing\r\n\r\n\t//__float128\r\n\r\n\tbool unlimited = false;\r\n\r\n\tif (unlimited) {\r\n\t\tint t;\r\n\t\tcin >> t;\r\n\t\twhile (t--) solve();\r\n\t}\r\n\telse {\r\n\t\tsolve();\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\n"
}