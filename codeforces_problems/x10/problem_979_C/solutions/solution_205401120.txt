{
    "id": 205401120,
    "contestId": 979,
    "creationTimeSeconds": 1683791266,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 979,
        "index": "C",
        "name": "Kuro and Walking Route",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1600,
        "tags": [
            "dfs and similar",
            "trees"
        ]
    },
    "author": {
        "contestId": 979,
        "members": [
            {
                "handle": "anikethend1234"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1526308500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 71,
    "timeConsumedMillis": 280,
    "memoryConsumedBytes": 30515200,
    "source": "/*  Aniket Hend     */\r\n/*   Laugh a lot, hate less; love much and enjoy every moment...*/\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define Avengers(Assemble)            \\\r\n    ios_base::sync_with_stdio(false); \\\r\n    cin.tie(NULL);\r\n\r\n#define MOD 1000000007\r\n#define MOD1 998244353\r\n#define INF 1e18\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define ff first\r\n#define ss second\r\n#define PI 3.141592653589793238462\r\n#define set_bits(x) __builtin_popcountll(x)\r\n#define all(x) (x).begin(), (x).end()\r\n#define allr(v) (v).rbegin(), (v).rend()\r\n#define int long long\r\n#define v64 vector<ll>\r\n#define sz size()\r\n#define up(a) transform(all(a), a.begin(), ::toupper)\r\n#define low(a) transform(all(a), a.begin(), ::tolower)\r\n#define PQ priority_queue<long long, vector<long long>, greater<long long>>\r\n#define to_binary(n) bitset<64>(n).to_string().substr(64 - (int)(log2(n)) - 1)\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ul;\r\ntypedef long double ld;\r\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag,tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\r\n\r\n/*-------------------------------------------------------------------------------------------------------------------*/\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x)          \\\r\n    cerr << #x << \" :: \"; \\\r\n    _print(x);            \\\r\n    cerr << \"\\n\";\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\nvoid _print(int a){cerr << a;}\r\nvoid _print(string a) { cerr << a; }\r\nvoid _print(bool a) { cerr << a; }\r\nvoid _print(char a) { cerr << a; }\r\nvoid _print(double a) { cerr << a; }\r\nvoid _print(ul a) { cerr << a; }\r\n\r\ntemplate <class T, class V>void _print(pair<T, V> pr){cerr << \"{\";_print(pr.first);cerr << \", \";_print(pr.second);cerr << \"}\";}\r\ntemplate <class T>void _print(vector<T> v){cerr << \"[ \";for (T i : v){_print(i);cerr << \" \";}cerr << \"]\";}\r\ntemplate <class T>void _print(set<T> s){cerr << \"[ \";for (T i : s){_print(i);cerr << \" \";}cerr << \"]\";}\r\ntemplate <class T>void _print(unordered_set<T> s){cerr << \"[ \";for (T i : s){_print(i);cerr << \" \";}cerr << \"]\";}\r\ntemplate <class T>void _print(multiset<T> s){cerr << \"[ \";for (T i : s){_print(i);cerr << \" \";}cerr << \"]\";}\r\ntemplate <class T, class V>void _print(map<T, V> mpp){cerr << \"\\n[\\n\";for (auto i : mpp){cerr << \"\\t\";_print(i);cerr << \"\\n\";}cerr << \"]\";}\r\ntemplate <class T, class V>void _print(unordered_map<T, V> mpp){cerr << \"\\n[\\n\";for (auto i : mpp){cerr << \"\\t\";_print(i);cerr << \"\\n\";}cerr << \"]\";}\r\ntemplate <class T, class V>void _print(multimap<T, V> mpp){cerr << \"\\n[\\n\";for (auto i : mpp){cerr << \"\\t\";_print(i);cerr << \"\\n\";}cerr << \"]\";}\r\n/*-------------------------------------------------------------------------------------------------------------------*/\r\n#define fi(i, s, e) for (ll i = s; i <= e; i++)\r\n#define f(i, s, e) for (ll i = s; i < e; i++)\r\n#define rf(i, e, s) for (ll i = e - 1; i >= s; i--)\r\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\r\ntemplate<typename T> inline void domin(T &x, T y) {if (y < x) x = y;}\r\ntemplate<typename T> inline void domax(T &x, T y) {if (y > x) x = y;}\r\n/*-------------------------------------------------------------------------------------------------------------------*/\r\nvoid read(v64 &a){for(auto &x :a){cin>>x;}}\r\n// void print(v64 &a){for (auto &x : a){cout<<x<<\" \";}cout<<endl;}\r\nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\r\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\r\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\r\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\r\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\r\nbool cmp(ll a, ll b) {return a > b;}\r\nvector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\r\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\r\nll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))\r\n/*-------------------------------------------------------------------------------------------------------------------*/\r\n\r\nint n,m,k;\r\nconst int N=3e5+9;\r\nvector<int>adj[N];\r\nbool vis[N];\r\nint nodes[N];\r\nint dep[N];\r\n\r\nvoid dfs(int u,int p,int &nn){\r\n    nn++;\r\n    for(auto v:adj[u]){\r\n        if(v!=p){\r\n            dfs(v,u,nn);\r\n        }\r\n    }\r\n}\r\n\r\nbool dfs2(int u,int p,int d){\r\n    if(u==d){\r\n        return true;\r\n    }\r\n\r\n    for(auto v:adj[u]){\r\n        if(v!=p){\r\n            if(dfs2(v,u,d)){\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid olive()\r\n{\r\n    int n1,n2;\r\n    cin>>n>>n1>>n2;    \r\n    m=n-1;\r\n\r\n    for(int i=0;i<=n;i++){\r\n        adj[i].clear();\r\n        vis[i]=0;\r\n    }\r\n\r\n    for(int i=0;i<m;i++){\r\n        int u,v;\r\n        cin>>u>>v;\r\n\r\n        adj[u].pb(v);\r\n        adj[v].pb(u);\r\n    }\r\n    \r\n    int id_adj_n2=-1;\r\n    for(auto v:adj[n2]){\r\n        if(dfs2(v,n2,n1)){\r\n            id_adj_n2=v;\r\n            break;\r\n        }\r\n    }\r\n\r\n    int id_adj_n1=-1;\r\n    for(auto v:adj[n1]){\r\n        if(dfs2(v,n1,n2)){\r\n            id_adj_n1=v;\r\n            break;\r\n        }\r\n    }\r\n\r\n    int nn1=0;\r\n    dfs(n1,id_adj_n1,nn1);\r\n    int nn2=0;\r\n    dfs(n2,id_adj_n2,nn2);\r\n\r\n    // std::cout<<nn1<<\" \"<<nn2<<' '<<id_adj_n1<<' '<<id_adj_n2<<'\\n';\r\n    std::cout<<n*(n-1)-(nn1*nn2)<<'\\n';\r\n}\r\n\r\nsigned main()\r\n{\r\n#ifndef ONLINE_JUDGE\r\n    // freopen(\"input.txt\", \"r\", stdin);\r\n    // freopen(\"output.txt\", \"w\", stdout);\r\n    // freopen(\"err69.txt\", \"w\", stderr);\r\n#endif\r\n    Avengers(Assemble);\r\n\r\n    int t = 1;\r\n    // cin >> t;\r\n    while (t--)\r\n    {\r\n        debug(t);\r\n        olive();\r\n    }\r\n    return 0;\r\n}\r\n\r\n/*\r\nin permutation or after doing some operations we have given some array try to do these problems\r\nin reverse order that most probably you will get the solution of that problem\r\n\r\n1.) Set.order_of_key(Val) -> this gives the number of integers strictly less than Val in the Set.\r\n2.) Set.find_by_order(k-1) -> this will give the pointer to kth smallest number.\r\n3.) lower bound will point to next greater element if not present in container else on that value\r\n---> if element is present it returns its index otherwise it returns the index of just greater element\r\n4.) upper bound all points to next greater element\r\n--->if element is present it returns its index otherwise it return the index of just smaller element\r\n5.) rotate(v.begin(), v.begin()+rotL, v.end()); left rotation\r\n6.) rotate(v.begin(), v.begin()+v.size()-rotR, v.end()); right rotation\r\n\r\n*/\r\n"
}