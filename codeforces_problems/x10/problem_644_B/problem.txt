{
    "contestId": 644,
    "index": "B",
    "name": "Processing Queries",
    "type": "PROGRAMMING",
    "points": 1000.0,
    "rating": 1700,
    "tags": [
        "*special",
        "constructive algorithms",
        "data structures",
        "two pointers"
    ],
    "desc": {
        "title": "B. Processing Queries",
        "statement": "<p>In this problem you have to simulate the workflow of one-thread server. There are <span class=\"tex-span\"><i>n</i></span> queries to process, the <span class=\"tex-span\"><i>i</i></span>-th will be received at moment <span class=\"tex-span\"><i>t</i><sub class=\"lower-index\"><i>i</i></sub></span> and needs to be processed for <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\"><i>i</i></sub></span> units of time. All <span class=\"tex-span\"><i>t</i><sub class=\"lower-index\"><i>i</i></sub></span> are guaranteed to be distinct.</p><p>When a query appears server may react in three possible ways: </p><ol> <li> If server is free and query queue is empty, then server immediately starts to process this query. </li><li> If server is busy and there are less than <span class=\"tex-span\"><i>b</i></span> queries in the queue, then new query is added to the end of the queue. </li><li> If server is busy and there are already <span class=\"tex-span\"><i>b</i></span> queries pending in the queue, then new query is just rejected and will never be processed. </li></ol><p>As soon as server finished to process some query, it picks new one from the queue (if it's not empty, of course). If a new query comes at some moment <span class=\"tex-span\"><i>x</i></span>, and the server finishes to process another query at exactly the same moment, we consider that first query is picked from the queue and only then new query appears.</p><p>For each query find the moment when the server will finish to process it or print <span class=\"tex-font-style-tt\">-1</span> if this query will be rejected.</p>",
        "inputSpecification": "<p>The first line of the input contains two integers <span class=\"tex-span\"><i>n</i></span> and <span class=\"tex-span\"><i>b</i></span> (<span class=\"tex-span\">1\u2009\u2264\u2009<i>n</i>,\u2009<i>b</i>\u2009\u2264\u2009200\u2009000</span>)\u00a0\u2014 the number of queries and the maximum possible size of the query queue.</p><p>Then follow <span class=\"tex-span\"><i>n</i></span> lines with queries descriptions (in chronological order). Each description consists of two integers <span class=\"tex-span\"><i>t</i><sub class=\"lower-index\"><i>i</i></sub></span> and <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\"><i>i</i></sub></span> (<span class=\"tex-span\">1\u2009\u2264\u2009<i>t</i><sub class=\"lower-index\"><i>i</i></sub>,\u2009<i>d</i><sub class=\"lower-index\"><i>i</i></sub>\u2009\u2264\u200910<sup class=\"upper-index\">9</sup></span>), where <span class=\"tex-span\"><i>t</i><sub class=\"lower-index\"><i>i</i></sub></span> is the moment of time when the <span class=\"tex-span\"><i>i</i></span>-th query appears and <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\"><i>i</i></sub></span> is the time server needs to process it. It is guaranteed that <span class=\"tex-span\"><i>t</i><sub class=\"lower-index\"><i>i</i>\u2009-\u20091</sub>\u2009&lt;\u2009<i>t</i><sub class=\"lower-index\"><i>i</i></sub></span> for all <span class=\"tex-span\"><i>i</i>\u2009&gt;\u20091</span>.</p>",
        "outputSpecification": "<p>Print the sequence of <span class=\"tex-span\"><i>n</i></span> integers <span class=\"tex-span\"><i>e</i><sub class=\"lower-index\">1</sub>,\u2009<i>e</i><sub class=\"lower-index\">2</sub>,\u2009...,\u2009<i>e</i><sub class=\"lower-index\"><i>n</i></sub></span>, where <span class=\"tex-span\"><i>e</i><sub class=\"lower-index\"><i>i</i></sub></span> is the moment the server will finish to process the <span class=\"tex-span\"><i>i</i></span>-th query (queries are numbered in the order they appear in the input) or <span class=\"tex-span\">\u2009-\u20091</span> if the corresponding query will be rejected.</p>",
        "samples": [
            {
                "input": "5 1<br/>2 9<br/>4 8<br/>10 9<br/>15 2<br/>19 1<br/>",
                "output": "11 19 -1 21 22 <br/>"
            },
            {
                "input": "4 1<br/>2 8<br/>4 8<br/>10 9<br/>15 2<br/>",
                "output": "10 18 27 -1 <br/>"
            }
        ],
        "note": "<p>Consider the first sample. </p><ol> <li> The server will start to process first query at the moment <span class=\"tex-span\">2</span> and will finish to process it at the moment <span class=\"tex-span\">11</span>. </li><li> At the moment <span class=\"tex-span\">4</span> second query appears and proceeds to the queue. </li><li> At the moment <span class=\"tex-span\">10</span> third query appears. However, the server is still busy with query <span class=\"tex-span\">1</span>, <span class=\"tex-span\"><i>b</i>\u2009=\u20091</span> and there is already query <span class=\"tex-span\">2</span> pending in the queue, so third query is just rejected. </li><li> At the moment <span class=\"tex-span\">11</span> server will finish to process first query and will take the second query from the queue. </li><li> At the moment <span class=\"tex-span\">15</span> fourth query appears. As the server is currently busy it proceeds to the queue. </li><li> At the moment <span class=\"tex-span\">19</span> two events occur simultaneously: server finishes to proceed the second query and the fifth query appears. As was said in the statement above, first server will finish to process the second query, then it will pick the fourth query from the queue and only then will the fifth query appear. As the queue is empty fifth query is proceed there. </li><li> Server finishes to process query number <span class=\"tex-span\">4</span> at the moment <span class=\"tex-span\">21</span>. Query number <span class=\"tex-span\">5</span> is picked from the queue. </li><li> Server finishes to process query number <span class=\"tex-span\">5</span> at the moment <span class=\"tex-span\">22</span>. </li></ol>"
    },
    "suggested_categories": [
        "simulation",
        "server",
        "workload",
        "queue management",
        "time management",
        "processing tasks",
        "rejecting queries",
        "single-threaded server",
        "concurrency",
        "scheduling",
        "algorithm design",
        "data structures",
        "event handling",
        "performance optimization",
        "priority queue",
        "real-time systems",
        "system design",
        "event-driven programming",
        "resource management",
        "load balancing"
    ]
}