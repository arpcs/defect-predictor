{
    "id": 212549707,
    "contestId": 217,
    "creationTimeSeconds": 1688730850,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 217,
        "index": "D",
        "name": "Bitonix' Patrol",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2900,
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "dfs and similar",
            "math"
        ]
    },
    "author": {
        "contestId": 217,
        "members": [
            {
                "handle": "youbot"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1345273500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 8,
    "timeConsumedMillis": 1994,
    "memoryConsumedBytes": 24064000,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n// Problem: D. Bitonix' Patrol(2900)\r\n// Contest: Codeforces - Codeforces Round 134 (Div. 1)\r\n// URL: https://codeforces.com/problemset/problem/217/D\r\n// Memory Limit: 256 MB\r\n// Time Limit: 2000 ms\r\n// \r\n// Powered by CP Editor (https://cpeditor.org)\r\n\r\n// dottle bot\r\n#ifndef ONLINE_JUDGE\r\n#define DEBUG\r\n#endif\r\n#include \t<bitset>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <queue>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <set>\r\n#define nln puts(\"\")\r\n#define od(x) printf(\"%d\",x)\r\n#define odb(x) printf(\"%d \",x)\r\n#define odl(x) printf(\"%d\\n\",x)\r\n#define odp(x,y) printf(\"%d %d\\n\",x,y)\r\n#define ol(x) puts(\"\")\r\n#define old(x) printf(\"%lld\",x)\r\n#define oldb(x) printf(\"%lld \",x)\r\n#define oldl(x) printf(\"%lld\\n\",x)\r\n#define oldp(x,y) printf(\"%lld %lld\\n\",x,y)\r\n#define rg(x) for(int i=1;i<=(x);i++){\r\n#define rg_(i,x) for(int i=1;i<=(x);i++){\r\n#define fe(u) for(int i=h[u];i;i=e[i].nxt){int v=e[i].v;\r\n#define gr }\r\n#define rrg(x) for(int i=0;i<(x);i++){\r\n#define rdln(a) a[i]=read();\r\n#define rdln0(a,x) rrg(x) rdln(a) gr\r\n#define rdln1(a,x) rg(x) rdln(a) gr\r\ntemplate<typename T>\r\nvoid print(T x){}\r\ntemplate<>\r\nvoid print<int>(int x){od(x);}\r\ntemplate<>\r\nvoid print<const int>(const int x){od(x);}\r\ntemplate<>\r\nvoid print<long long>(long long x){old(x);}\r\ntemplate<>\r\nvoid print<const long long>(const long long x){old(x);}\r\ntemplate<>\r\nvoid print<char>(char x){putchar(x);}\r\ntemplate<>\r\nvoid print<const char>(const char x){putchar(x);}\r\ntemplate<>\r\nvoid print<double>(double x){printf(\"%.12lf\",x);}\r\ntemplate<typename T,typename... qwq>\r\nvoid print(T x,qwq ...args)\r\n{\r\n\tprint(x);\r\n\tprint(args...);\r\n}\r\n#ifdef DEBUG\r\ntemplate<typename T>\r\nvoid debug(T x){}\r\ntemplate<>\r\nvoid debug<int>(int x){od(x);}\r\ntemplate<>\r\nvoid debug<const int>(const int x){od(x);}\r\ntemplate<>\r\nvoid debug<long long>(long long x){old(x);}\r\ntemplate<>\r\nvoid debug<const long long>(const long long x){old(x);}\r\ntemplate<>\r\nvoid debug<char>(char x){putchar(x);}\r\ntemplate<>\r\nvoid debug<const char>(const char x){putchar(x);}\r\ntemplate<>\r\nvoid debug<double>(double x){printf(\"%.12lf\",x);}\r\ntemplate<typename T,typename... qwq>\r\nvoid debug(T x,qwq ...args)\r\n{\r\n\tdebug(x);\r\n\tdebug(args...);\r\n}\r\n#define dflush fflush\r\n#else\r\n#define dflush(...) 0\r\ntemplate<typename T,typename... qwq>\r\nvoid debug(T x,qwq ...args)\r\n{\r\n\t\r\n}\r\n#endif\r\n\r\n#define int long long\r\nconst int mod=1e9+7;\r\n#ifdef int \r\n#define inf 0x3f3f3f3f3f3f3f3fll\r\n#else \r\n#define inf 0x3f3f3f3f\r\n#endif\r\ninline int min(int a,int b){return a>b?b:a;}\r\ninline int max(int a,int b){return a<b?b:a;}\r\n#define cmlSEGMIN\r\n#define cmlSEGMAX\r\n#define cmlSEGSUM\r\nclass SegTreeAl{\r\n#ifdef cmlSEGMIN\r\n\tint minn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\tint maxn[1000005<<2];\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\tint sum[1000005<<2];\r\n#endif\r\n\tint tag[1000005<<2];\r\n#ifdef cmlSEGSUM\r\n\tvoid pushdown(int o,int l,int r)\r\n#else \r\n\tvoid pushdown(int o)\r\n#endif\r\n\t{\r\n\t\tint&t=tag[o];\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o<<1]+=t;\r\n\t\tminn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o<<1]+=t;\r\n\t\tmaxn[o<<1|1]+=t;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tint m=l+r>>1;\r\n\t\tsum[o<<1]+=t*(m-l+1);\r\n\t\tsum[o<<1|1]+=t*(r-m);\r\n#endif\r\n\t\ttag[o<<1]+=t;\r\n\t\ttag[o<<1|1]+=t;\r\n\t\tt=0;\r\n\t}\r\n\tvoid add(int o,int l,int r,int L,int R,int v)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n#ifdef cmlSEGMAX\r\n\t\t\tmaxn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\t\tminn[o]+=v;\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\t\tsum[o]+=v*(r-l+1);\r\n#endif\r\n\t\t\ttag[o]+=v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint m=l+r>>1;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)add(o<<1,l,m,L,R,v);\r\n\t\tif(m<R)add(o<<1|1,m+1,r,L,R,v);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t}\r\n#ifdef cmlSEGMIN\r\n\tint qmin(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn minn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=min(res,qmin(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=min(res,qmin(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGMAX\r\n\tint qmax(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn maxn[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=-inf;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res=max(res,qmax(o<<1,l,m,L,R));\r\n\t\tif(m<R)res=max(res,qmax(o<<1|1,m+1,r,L,R));\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n\r\n#ifdef cmlSEGSUM\r\n\tint qsum(int o,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\r\n\t\t{\r\n\t\t\treturn sum[o];\r\n\t\t}\r\n\t\tint m=l+r>>1,res=0;\r\n#ifdef cmlSEGSUM\r\n\t\tpushdown(o,l,r);\r\n#else\r\n\t\tpushdown(o);\r\n#endif\r\n\t\tif(L<=m)res+=qsum(o<<1,l,m,L,R);\r\n\t\tif(m<R)res+=qsum(o<<1|1,m+1,r,L,R);\r\n#ifdef cmlSEGMAX\r\n\t\tmaxn[o]=max(maxn[o<<1],maxn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGMIN\r\n\t\tminn[o]=min(minn[o<<1],minn[o<<1|1]);\r\n#endif\r\n#ifdef cmlSEGSUM\r\n\t\tsum[o]=sum[o<<1]+sum[o<<1|1];\r\n#endif\r\n\t\treturn res;\r\n\t}\r\n#endif\r\n};\r\n#define newe(n) struct Edge{int v,w,nxt;}e[2*n+5];\\\r\ntypedef int arr[n+5];\\\r\narr h;\\\r\nint cnt=1;\\\r\ninline void addedge(int u,int v,int w){e[cnt]=(Edge){v,w,h[u]};h[u]=cnt++;}\\\r\nstruct node{\\\r\n\tint u,d;\\\r\n\tbool operator<(const node&b)const{return d>b.d;}\\\r\n};\\\r\nvoid dij(int s,int *d,int N)\\\r\n{\\\r\n\tmemset(d,0x3f,sizeof(int)*(N+3));\\\r\n\td[s]=0;std::priority_queue<node>q;q.push((node){s,0});\\\r\n\twhile(!q.empty())\\\r\n\t{\\\r\n\t\tint u=q.top().u,D=q.top().d;q.pop();if(D!=d[u])continue;\\\r\n\t\tfor(int i=h[u];i;i=e[i].nxt){int v=e[i].v,w=e[i].w;\\\r\n\t\tif(d[u]+w<d[v])d[v]=d[u]+w,q.push((node){v,d[v]});\\\r\n\t\t}\\\r\n\t}\\\r\n}\r\n#define mgs int fa[1<<22],sz[1<<22];\\\r\ninline int f(int x){return x==fa[x]?x:fa[x]=f(fa[x]);}\\\r\ninline int uf(int x,int y)\\\r\n{\\\r\n    int fx=f(x),fy=f(y);\\\r\n    if(fx==fy)return 0;\\\r\n    if(sz[fx]>sz[fy])fx^=fy^=fx^=fy;\\\r\n    fa[fx]=fy,sz[fy]+=sz[fx];\\\r\n    return 1;\\\r\n}\r\ninline int read()\r\n{\r\n    int num=0,f=1;char c=getchar();\r\n    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}\r\n    while(c>47&&c<58)num=num*10+(c^48),c=getchar();\r\n    return num*f;\r\n}\r\ninline int re1d()\r\n{\r\n    char c=getchar();\r\n    while(c<48||c>49)c=getchar();\r\n    return c&1;\r\n}\r\n#ifdef cmlBIT\r\nstruct BIT{int a[1<<20|1],n;\r\nvoid add(int x,int p){while(x<=n)a[x]+=p,x+=x&-x;}\r\nint operator[](int x){int res=0;while(x)res+=a[x],x-=x&-x;return res;}\r\nint operator()(int l,int r){return (*this)[r]-(*this)[l-1];}};\r\n#endif\r\nint rnv[1000005];\r\n#define COMB\r\n#ifdef COMB\r\n#ifndef int\r\n#define int long long\r\n#endif\r\nint fac[1000005],inv[1000005];\r\n#endif\r\nvoid initprog()\r\n{\r\n#ifdef COMB\r\n\tfac[0]=inv[0]=inv[1]=1;\r\n\trg(1000000)fac[i]=fac[i-1]*i%mod;gr\r\n\trg(1000000)if(i>1)inv[i]=inv[mod%i]*(mod-mod/i)%mod;gr\r\n\trg(1000000)rnv[i]=inv[i];gr\r\n\trg(1000000)inv[i]=inv[i]*inv[i-1]%mod;gr\r\n#endif\r\n}\r\n#ifdef COMB\r\nint C(int n,int m)\r\n{\r\n\tif(n==m||m==0)return 1;\r\n\tif(n<m)return 0;\r\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r\n}\r\n#endif\r\ninline int qp(int a,int b){int c=1;while(b){if(b&1)c=c*a%mod;a=a*a%mod;b>>=1;}return c;}\r\ninline int mae(int &a,int b){a+=b;if(a>=mod)a-=mod;return a;}\r\ninline int mde(int &a,int b){a+=mod-b;if(a>=mod)a-=mod;return a;}\r\ninline int mle(int &a,int b){a=a*b%mod;return a;}\r\ninline int mve(int &a,int b){a=a*qp(b,mod-2)%mod;return a;}\r\ninline int mxe(int &a,int b){return a=a>b?a:b;}\r\ninline int mne(int &a,int b){return a=a<b?a:b;}\r\ninline int ae(int a,int b){int c=a+b;return c>=mod?c-mod:c;}\r\ninline int de(int a,int b){return ae(a,mod-b);}\r\ninline int me(int a,int b){return a*b%mod;}\r\ninline int mive(int &a,int b){a=a*rnv[b]%mod;return a;}\r\ninline int ive(int a,int b){return a*rnv[b]%mod;}\r\ninline int ve(int a,int b){return a*qp(b,mod-2)%mod;}\r\n#ifdef cmlST\r\nstruct STmin{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=min(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn min(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\nstruct STmax{\r\n\tint a[21][1000005],n;\r\n\tvoid init(int N,int *b)\r\n\t{\r\n\t\tn=N;\r\n\t\trg(n)a[0][i]=b[i];gr\r\n\t\trg(20)rg_(j,n-(1<<i)+1)a[i][j]=max(a[i-1][j],a[i-1][j+(1<<i-1)]);gr gr\r\n\t}\r\n\tint q(int l,int r)\r\n\t{\r\n\t\tint d=std::__lg(r-l+1);\r\n\t\treturn max(a[d][l],a[d][r-(1<<d)+1]);\r\n\t}\r\n};\r\n#endif\r\n#ifdef cmlSAM\r\nstruct SAM{\r\n\tint ch[1000005][26],lnk[1000005],len[1000005],lst=1,cc=1;\r\n\tint sz[1000005];\r\n\tvoid insert(int c)\r\n\t{\r\n\t\tlen[++cc]=len[lst]+1;sz[cc]=1;\r\n\t\tint p=lst;lst=cc;\r\n\t\twhile(p&&ch[p][c]==0)ch[p][c]=cc,p=lnk[p];\r\n\t\tif(p==0)lnk[cc]=1;\r\n\t\telse\r\n\t\t{\r\n\t\t\tint x=ch[p][c];\r\n\t\t\tif(len[p]+1==len[x])lnk[cc]=x;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint q=cc;++cc;\r\n\t\t\t\tlnk[cc]=lnk[x];\r\n\t\t\t\tlnk[x]=lnk[q]=cc;\r\n\t\t\t\tlen[cc]=len[p]+1;\r\n\t\t\t\tmemcpy(ch[cc],ch[x],sizeof(ch[cc]));\r\n\t\t\t\twhile(p&&ch[p][c]==x)ch[p][c]=cc,p=lnk[p];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tnewe(1000005);\r\n\tlong long ans;\r\n\tvoid build()\r\n\t{\r\n\t\trg(cc)addedge(lnk[i],i,0);gr\r\n\t}\r\n\tvoid dfs(int u)\r\n\t{\r\n\t\tfe(u)dfs(v),sz[u]+=sz[v];gr\r\n\t\tif(sz[u]>1)ans=max(ans,1ll*sz[u]*len[u]);\r\n\t}\r\n}t;\r\n#endif\r\nint t[1145];\r\nint n=read(),m=read(),k=read(),ns;\r\nint F[18];\r\nint search(int x,int nw,int f=0,int v=0)\r\n{\r\n\tif(f&&v%m==0)return 1;\r\n\tif(x==nw+1)return 0;\r\n\tif(search(x+1,nw,1,v+F[x]))return 1;\r\n\tif(search(x+1,nw,1,v+m-F[x]))return 1;\r\n\tif(search(x+1,nw,f,v))return 1;\r\n\treturn 0;\r\n}\r\nvoid dfs(int u,int xs=1,int bs=1,int nw=0,int lst=01)\r\n{\r\n\t// int G[122]={1},H[122]={};\r\n\tif(lst)\r\n\t{\r\n\tif(nw==0)mae(ns,xs);\r\n\telse if(nw==1)mae(ns,xs);\r\n\telse if(nw==2&&F[1]+F[2]!=m)mae(ns,xs);\r\n\telse if(nw==2)return;\r\n\t// // else\r\n\t\t// // printf(\"%d:\",nw);rg(nw)odb(F[i]);gr \r\n\telse\r\n\t{\r\n\t\tif(nw==3)\r\n\t\t{\r\n\t\tif(search(1,nw))return;\r\n\t\tmae(ns,xs);\r\n\t\t\r\n\t\t}else{\r\n\tstd::bitset<121>bs;\r\n\tbs.set(0);\r\n\trg(nw)bs=bs|(bs>>F[i])|(bs<<F[i])|(bs>>m-F[i])|(bs<<m-F[i]);gr\r\n\tbs.reset(0);\r\n\tint ok=0;\r\n\tfor(int i=0;i<=1;i++)if(bs.test(i*m))ok=1;\r\n\t// if(F[1]==0&&ok==0)\r\n\t// {\r\n\t\t// printf(\"%d:\",nw);rg(nw)odb(F[i]);gr puts(\"\");\r\n\t// }\r\n\t// if(nw==0)odl((!ok)*xs);\r\n\tif(!ok){\r\n\t\t// printf(\"+%d:\",xs);rg(nw)odb(F[i]);gr puts(\"\");\r\n\t}\r\n\tif(!ok)mae(ns,xs);\r\n\telse return;\r\n\t}}\r\n\t// rg(nw)\r\n\t// for(int j=0;j<m;j++)\r\n\t// {\r\n\t\t// H[j]=G[j];\r\n\t\t// // if(j>=i)\r\n\t\t// H[j]+=G[(j-F[i]+m)%m];\r\n\t\t// // if(j+i<=m*nw)\r\n\t\t// H[j]+=G[(j+F[i])%m];\r\n\t\t// if(H[0]>1)goto xunei;\r\n\t// }\r\n\t// for(int j=0;j<m;j++)G[j]=H[j],H[j]=0;\r\n\t// gr\r\n\t// int ok=0;\r\n\t// G[0]--;\r\n\t// // for(int j=0;j<=nw*m;j+=m)ok|=G[j];\r\n\t// if(G[0]==0)mae(ns,xs);\r\n\t// // if(ok)puts(\"NO\");else puts(\"YES\");\r\n\t}\r\n\t\r\n\txunei:;\r\n\tif(bs*2>m||u>=5)return;\r\n\tfor(int i=bs;i<=bs;i++)\r\n\t{\r\n\t\tfor(int j=0;j<=!!t[i]&&j+u<=5;j++)\r\n\t\t{\r\n\t\t\trg(j)F[++nw]=bs;gr\r\n\t\t\tdfs(j+u,xs*(j?t[i]:1)%mod,bs+1,nw,j);\r\n\t\t\trg(j)--nw;gr\r\n\t\t}\r\n\t}\r\n}\r\nsigned main()\r\n{\r\n\tinitprog();\r\n\trg(k)t[read()%m]++;gr\r\n\tfor(int i=0;i<m;i++)if(i*2>m)t[m-i]+=t[i];\r\n\tdfs(0);\r\n\todl(ns);\r\n\treturn 0;\r\n}"
}