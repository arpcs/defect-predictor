{
    "id": 233423082,
    "contestId": 371,
    "creationTimeSeconds": 1700399865,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 371,
        "index": "C",
        "name": "Hamburgers",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1600,
        "tags": [
            "binary search",
            "brute force"
        ]
    },
    "author": {
        "contestId": 371,
        "members": [
            {
                "handle": "dada22"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1386493200
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 5632000,
    "source": "#include<bits/stdc++.h>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\n\r\n#define ll long long\r\n#define endl \"\\n\"\r\n#define Dada cin.tie(0), cout.tie(0), cin.sync_with_stdio(0), cout.sync_with_stdio(0);\r\nint const N = 2e5 + 5;\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define order_set tree<pair<ll,ll>,null_type,less<pair<ll,ll>>,rb_tree_tag,tree_order_statistics_node_update>\r\ndouble pi = 3.1415926;\r\nconst ll MOD = 1e9 + 7;\r\nint Xaxis[4] = {0, 0, -1, 1}; //right,left,up,down\r\nint Yaxis[4] = {1, -1, 0, 0}; //right,left,up,down\r\n///vector input\r\ntemplate<class T>\r\nistream &operator>>(istream &is, vector<T> &v) {\r\n    for (auto &i: v)\r\n        is >> i;\r\n    return is;\r\n}\r\n\r\n\r\nll gcd(ll a, ll b) {\r\n    if (b == 0) { return a; }\r\n    else { return gcd(b, (a % b)); }\r\n}\r\n\r\nint lcm(int n1, int n2) {\r\n    return (n1 / gcd(n1, n2)) * n2;\r\n}\r\n\r\nbool isPrime(ll x) {\r\n    if (x <= 1) { return false; }\r\n\r\n    for (ll i = 2; i * i <= x; ++i) {\r\n        if (x % i == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nlong long convertDB(int n) {\r\n    long long bin = 0;\r\n    ll rem, i = 1;\r\n\r\n    while (n != 0) {\r\n        rem = n % 2;\r\n        n /= 2;\r\n        bin += rem * i;\r\n        i *= 10;\r\n    }\r\n\r\n    return bin;\r\n}\r\n\r\n// function definition\r\nll convertBD(long long n) {\r\n    ll dec = 0, i = 0, rem;\r\n\r\n    while (n != 0) {\r\n        rem = n % 10;\r\n        n /= 10;\r\n        dec += rem * pow(2, i);\r\n        ++i;\r\n    }\r\n    return dec;\r\n}\r\n\r\n///function to get divisors for number x\r\nvector<ll> divisors(ll x) {\r\n    vector<ll> d;\r\n    if (x > 1)\r\n        d.push_back(1);\r\n    for (ll i = 2; i * i <= x; ++i) {\r\n        if (x % i == 0) {\r\n            d.push_back(i);\r\n            if (i != x / i)\r\n                d.push_back(x / i);\r\n        }\r\n    }\r\n    d.push_back(x);\r\n    return d;\r\n}\r\n\r\nll addMod(ll x, ll y, ll M = 1e9 + 7) {\r\n    return (x % M + y % M) % M;\r\n}\r\n\r\nll subMod(ll x, ll y, ll M = 1e9 + 7) {\r\n    return (x % M - y % M + 2 * M) % M;\r\n}\r\n\r\nll mulMod(ll x, ll y, ll M = 1e9 + 7) {\r\n    return (x % M * y % M) % M;\r\n}\r\n\r\n\r\nunsigned ll fast_pow(unsigned ll a, int b) {\r\n    unsigned ll res = 1;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = res * a;\r\n        a = a * a;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\nbool isPalindrom(string x) {\r\n    string y = x;\r\n    reverse(y.begin(), y.end());\r\n    return (x == y) ? true : false;\r\n}\r\n\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\nvector<int> adj[N];\r\nint n, m;\r\n\r\nbool valid(int x, int y) {\r\n    return (x >= 0 && x < n && y >= 0 && y < m);\r\n}\r\n\r\nvector<int> vis(N, 0);\r\n\r\n/*bool check_cycle(int x, int p) {\r\n    vis[x] = 1;\r\n    for (auto a: adj[x]) {\r\n        if (a==p)continue;\r\n        if (!vis[a]) {\r\n            check_cycle(a, x);\r\n        }\r\n        if (vis[a] == 1) {\r\n            return false;\r\n        }\r\n    }\r\n    vis[x] = 2;\r\n    return true;\r\n}*/\r\nbool cmdd(pair<ll, ll> &a, pair<ll, ll> &b) {\r\n    return a.first < b.first;\r\n}\r\n\r\nint mx = 0;\r\n\r\nint dfs(int x) {\r\n    vis[x] = 1;\r\n    mx++;\r\n    for (auto a: adj[x]) {\r\n        if (!vis[a]) {\r\n            dfs(a);\r\n        }\r\n    }\r\n    return mx;\r\n}\r\n\r\nvector<ll> dis(N, 1e9);\r\nint p[N];\r\n\r\nvoid bfs() {\r\n    deque<int> q;\r\n    q.push_back(1);\r\n    dis[1] = 0;\r\n    p[1] = -1;//parent of 1 is -1\r\n    while (!q.empty()) {\r\n        int v = q.front();\r\n        q.pop_front();\r\n        for (auto x: adj[v]) {\r\n            if (dis[x] > dis[v] + 1) {\r\n                dis[x] = dis[v] + 1;\r\n                p[x] = v;\r\n                q.push_back(x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*ll start,ed;\r\nll dijekstra() {\r\n    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<>> q;\r\n    q.emplace(0, start);\r\n    dis[start] = 0;\r\n    while (!q.empty()) {\r\n        pair<ll, ll> parent = q.top();\r\n        q.pop();\r\n        for (auto child: adj[parent.second]) {\r\n            // distance i come from parent to child is smaller than the distance i have to child\r\n            if (parent.first + child.second < dis[child.first]) {\r\n                dis[child.first] = child.second + parent.first;\r\n                q.emplace(dis[child.first], child.first);\r\n            }\r\n        }\r\n    }\r\n\r\n    return dis[ed];\r\n}\r\n*/\r\nll ncr(ll n1, ll r) {\r\n    if (r > n1) return 0;\r\n    if (r * 2 > n1) r = n1 - r;\r\n    if (r == 0) return 1;\r\n\r\n    ll result = n1;\r\n    for (ll i = 2; i <= r; ++i) {\r\n        result *= (n1 - i + 1);\r\n        result /= i;\r\n    }\r\n    return result;\r\n}\r\n\r\nll npr(ll n1, ll r) {\r\n    if (r > n1) return 0;\r\n    if (r * 2 > n1) r = n1 - r;\r\n    if (r == 0) return 1;\r\n\r\n    ll result = n1;\r\n    for (ll i = 2; i <= r; ++i) {\r\n        result *= (n1 - i + 1);\r\n\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\nint main() {\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n    Dada\r\n    int T = 1;\r\n    //   cin >> T;\r\n    while (T--) {\r\n        /*\r\n reminder:\r\n practice makes perfect !!!\r\n  it's slow processes but qutting won't speed it up\r\n */\r\n        string s;\r\n        cin >> s;\r\n        int pB, pS, pC;\r\n        cin >> pB >> pS >> pC;\r\n        int nb, ns, nc;\r\n        cin >> nb >> ns >> nc;\r\n        ll price;\r\n        cin >> price;\r\n        int bread = 0, sausage = 0, cheese = 0;\r\n        for (char i: s) {\r\n            if (i == 'B')bread++;\r\n            if (i == 'S')sausage++;\r\n            if (i == 'C')cheese++;\r\n        }\r\n       ll mx1=0;\r\nll l=0,r=1e18;\r\nwhile(l<=r){\r\n    ll mid=(l+r)/2;\r\n    ll no_bread=mid*bread;\r\n    ll no_sausage=mid*sausage;\r\n    ll no_cheese=mid*cheese;\r\n    no_bread-=pB;\r\n    if(no_bread<0)no_bread=0;\r\n    no_sausage-=pS;\r\n    if(no_sausage<0)no_sausage=0;\r\n    no_cheese-=pC;\r\n    if(no_cheese<0)no_cheese=0;\r\n    if(no_bread*1ll*nb+no_sausage*1ll*ns+no_cheese*1ll*nc<=price){\r\n        mx1=mid;\r\n        l=mid+1;\r\n    }\r\n    else r=mid-1;\r\n\r\n}\r\ncout<<mx1<<endl;\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    return 0;\r\n}"
}