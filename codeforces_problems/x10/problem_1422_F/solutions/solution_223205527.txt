{
    "id": 223205527,
    "contestId": 1422,
    "creationTimeSeconds": 1694605239,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1422,
        "index": "F",
        "name": "Boring Queries",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 2700,
        "tags": [
            "data structures",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1422,
        "members": [
            {
                "handle": "WingsyTsubasa"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1601827500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <algorithm>\r\n#include <iostream>\r\nusing namespace std;\r\nclass fastIO {\r\nprivate:\r\n    char ibuf[50007], *p1 = ibuf, *p2 = ibuf, obuf[50007], *p3 = obuf, sta[50];\r\n    bool file_end = false;\r\n    char get() {\r\n        return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, 50007, stdin), p1 == p2) ? (file_end = true), char(EOF): *p1++;\r\n    }\r\n    void put(const char x) {\r\n        p3 - obuf < 50007 ? *p3 ++ = x : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x);\r\n    }\r\npublic:\r\n    explicit operator bool() { return !file_end; }\r\n    size_t flush() {\r\n        size_t f = fwrite(obuf, p3 - obuf, 1, stdout);\r\n        p3 = obuf;\r\n        *p3 = 0;\r\n        return f;\r\n    }\r\n    fastIO &operator>>(char &t) {\r\n        for (t = get(); !isgraph(t); t = get());\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<is_same<any, char>::value, any>::type tpval() {\r\n        char t;\r\n        for (t = get(); !isgraph(t); t = get());\r\n        return t;\r\n    }\r\n    fastIO &operator>>(char *t) {\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())*t = c, t++;\r\n        *t = 0;\r\n        return *this;\r\n    }\r\n    fastIO &operator>>(string &t) {\r\n        t.clear();\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())t += c;\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<is_same<any, string>::value, any>::type tpval() {\r\n        string t;\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())t += c;\r\n        return t;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n    (is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n    is_same<any, __int128_t>::value, fastIO>::type &operator>>(any &t) {\r\n        t = 0;\r\n        bool y = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get())if (c == 45)y = true;\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        if (y == 1)t = -t;\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n    (is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n    is_same<any, __int128_t>::value, any>::type tpval() {\r\n        any t = 0;\r\n        bool y = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get())if (c == 45)y = true;\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        if (y == 1)t = -t;\r\n        return t;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n    (is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n    is_same<any, __uint128_t>::value, fastIO>::type &operator>>(any &t) {\r\n        t = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get());\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n    (is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n    is_same<any, __uint128_t>::value, any>::type tpval() {\r\n        any t = 0;\r\n        char c = get();\r\n        for (; !isdigit(c); c = get());\r\n        for (; isdigit(c); c = get())t = t * 10 + c - 48;\r\n        return t;\r\n    }\r\n    template<typename any1, typename any2>\r\n    fastIO &operator>>(pair<any1, any2> &t) { return *this >> t.first >> t.second; }\r\n    template<typename any1, typename any2>\r\n    pair<any1, any2> tpval() { return pair<any1, any2>(tpval<any1>(), tpval<any2>()); }\r\n    template<typename any>\r\n    fastIO &read(any &t) { return *this >> t; }\r\n    fastIO &read(char *t) {\r\n        char c;\r\n        for (c = get(); !isgraph(c); c = get());\r\n        for (; isgraph(c); c = get())*t = c, t++;\r\n        *t = 0;\r\n        return *this;\r\n    }\r\n    template<typename any, typename...args>\r\n    fastIO &read(any &t1, args &...t2) { return (*this >> t1).read(t2...); }\r\n    fastIO &operator<<(const char t) {\r\n        put(t);\r\n        return *this;\r\n    }\r\n    fastIO &operator<<(const char *t) {\r\n        for (; *t; t++)put(*t);\r\n        return *this;\r\n    }\r\n    fastIO &operator<<(const string &t) {\r\n        for (const char it: t)put(it);\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n    (is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n    is_same<any, __int128_t>::value, fastIO>::type &operator<<(any t) {\r\n        if (!t) {\r\n            put(48);\r\n            return *this;\r\n        }\r\n        int len = 0;\r\n        if (t < 0)t = -t, put(45);\r\n        while (t)sta[len++] = char(t % 10 + 48), t /= 10;\r\n        while (len--)put(sta[len]);\r\n        return *this;\r\n    }\r\n    template<typename any>\r\n    typename enable_if<\r\n    (is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) ||\r\n    is_same<any, __uint128_t>::value, fastIO>::type &operator<<(any t) {\r\n        if (!t) {\r\n            put(48);\r\n            return *this;\r\n        }\r\n        int len = 0;\r\n        while (t)sta[len++] = char(t % 10 + 48), t /= 10;\r\n        while (len--)put(sta[len]);\r\n        return *this;\r\n    }\r\n    template<typename any1, typename any2>\r\n    fastIO &operator<<(const pair<any1, any2> &t) { return *this << t.first << ' ' << t.second; }\r\n    template<typename any>\r\n    fastIO &write(const any &t) { return *this << t; }\r\n    template<typename any, typename...args>\r\n    fastIO &write(const any &t1, const args &...t2) { return (*this << t1).write(t2...); }\r\n    \r\n    ~fastIO() { fwrite(obuf, p3 - obuf, 1, stdout); }\r\n}FastIO;\r\n#ifdef ONLINE_JUDGE\r\n#define cin FastIO\r\n#define cout FastIO\r\n#endif\r\n// const int N = 700;\r\nconst int N = 2e5 + 10;\r\nint prime[N], cnt;\r\nbool st[N];\r\nvoid sieve() {\r\n    st[0] = st[1] = 1;\r\n    for (int i = 2; i < N; i++) {\r\n        if (!st[i])\r\n            prime[cnt++] = i;\r\n        for (int j = 0; prime[j] * i < N; j++) {\r\n            st[prime[j] * i] = 1;\r\n            if (i % prime[j] == 0) break;\r\n        }\r\n    }\r\n}\r\nconst int mod = 1000000007;\r\nlong long BiExp(long long base, long long exp){\r\n    long long res = 1;\r\n    while(exp){\r\n        if (exp & 1) res = res * base % mod;\r\n        base = base * base % mod;\r\n        exp >>= 1;\r\n    }\r\n    return res;\r\n}\r\nint n, q;\r\nint arr[N >> 1];\r\nstruct HJT{\r\n    struct Node {\r\n        int val;\r\n        int mul;\r\n        int lroot, rroot;\r\n        Node(){\r\n            val = lroot = rroot = 0;\r\n            mul = 1;\r\n        }\r\n    } tree[N * 20];\r\n    int tot, ent[N >> 1];\r\n    void insert(int val, int pre, int& now, int idx, bool erase = false, int l = 1, int r = N) {\r\n        now = ++tot;\r\n        tree[now] = tree[pre];\r\n        if (l == r){\r\n            tree[now].val += erase ? -1 : 1;\r\n            tree[now].mul = erase ? 1 : val;\r\n        }\r\n        else {\r\n            int mid = (l + r) >> 1;\r\n            if (idx <= mid) insert(val, tree[pre].lroot, tree[now].lroot, idx, erase, l, mid);\r\n            else insert(val, tree[pre].rroot, tree[now].rroot, idx, erase, mid + 1, r);\r\n            tree[now].val = tree[tree[now].lroot].val + tree[tree[now].rroot].val;\r\n            tree[now].mul = (long long)tree[tree[now].lroot].mul * tree[tree[now].rroot].mul % mod;\r\n        }\r\n    }\r\n    int query(int now, int idxL, int idxR, int l = 1, int r = N) {\r\n        if (l > idxR || r < idxL) return 1;\r\n        else if (l >= idxL && r <= idxR) return tree[now].mul;\r\n        else {\r\n            int mid = (l + r) >> 1;\r\n            return (long long)query(tree[now].lroot, idxL, idxR, l, mid) * query(tree[now].rroot, idxL, idxR, mid + 1, r) % mod;\r\n        }\r\n    }\r\n    int pos[N];\r\n    // HJT(){\r\n    //     tree[0].mul = 1;\r\n    // }\r\n} hjt;\r\nstruct Seg{\r\n    struct Node{\r\n        int val;\r\n    } tree[N * 4];\r\n    int query(int idxL, int idxR, int now = 1, int l = 1, int r = n){\r\n        if (l > idxR || r < idxL) return 0;\r\n        else if (l >= idxL && r <= idxR) return tree[now].val;\r\n        else{\r\n            int mid = (l + r) >> 1;\r\n            int lroot = now << 1;\r\n            int rroot = lroot | 1;\r\n            return max(query(idxL, idxR, lroot, l, mid), query(idxL, idxR, rroot, mid + 1, r));\r\n        }\r\n    }\r\n    void insert(int pos, int val, int now = 1, int l = 1, int r = n){\r\n        if (l == r) tree[now].val = val;\r\n        else{\r\n            int mid = (l + r) >> 1;\r\n            int lroot = now << 1;\r\n            int rroot = lroot | 1;\r\n            if (pos <= mid) insert(pos, val, lroot, l, mid);\r\n            else insert(pos, val, rroot, mid + 1, r);\r\n            tree[now].val = max(tree[lroot].val, tree[rroot].val);\r\n        }\r\n    }\r\n} seg[90];\r\nvoid process(int i, int j, int cnt){\r\n    //i = \u7b2ci\u4e2a\u6570\uff08\u4f4d\u7f6e\uff09  j = \u7b2cj\u4e2a\u7d20\u6570  cnt = \u5305\u542b\u7684\u7d20\u6570\u4e2a\u6570\r\n    if (j < 90) seg[j].insert(i, cnt);\r\n    else{\r\n        if (hjt.pos[prime[j]]) hjt.insert(prime[j], hjt.ent[i - 1], hjt.ent[i], hjt.pos[prime[j]], true);\r\n        hjt.insert(prime[j], hjt.ent[i - (hjt.pos[prime[j]] ? 0 : 1)], hjt.ent[i], i);\r\n        hjt.pos[prime[j]] = i;\r\n    }\r\n}\r\nint query(int l, int r){\r\n    int res = 1;\r\n    for (int i = 0; i < 90; ++i){\r\n        auto _ = seg[i].query(l, r);\r\n        res = (long long)res * BiExp(prime[i], _) % mod;\r\n    }\r\n    auto _ = hjt.query(hjt.ent[r], l, n);\r\n    res = (long long)res * _ % mod;\r\n    return res;\r\n}\r\nsigned main(){\r\n    // ios::sync_with_stdio(false);\r\n    // cin.tie(0);\r\n    // cout.tie(0);\r\n    sieve();\r\n    cin >> n;\r\n    for (int i = 1; i <= n; ++i) {\r\n        cin >> arr[i];\r\n        int x = arr[i];\r\n        for (int j = 0; j < cnt; ++j) {\r\n            if (!st[x]){\r\n                int _ = lower_bound(prime + j, prime + cnt, x) - prime;\r\n                process(i, _, 1);\r\n                break;\r\n            }\r\n            int _cnt = 0;\r\n            while(x % prime[j] == 0){\r\n                x = x / prime[j];\r\n                ++_cnt;\r\n            }\r\n            if (cnt) process(i, j, _cnt);\r\n            if (x == 1) break;\r\n        }\r\n        if (!hjt.ent[i]) hjt.ent[i] = hjt.ent[i - 1];\r\n    }\r\n    cin >> q;\r\n    int x, y;\r\n    int last = 0;\r\n    while (q--) {\r\n        cin >> x >> y;\r\n        x = ((last + x) % n) + 1;\r\n        y = ((last + y) % n) + 1;\r\n        if (x > y) swap(x, y);\r\n        last = query(x, y);\r\n        cout << last << \"\\n\";\r\n    }\r\n    return 0;\r\n}"
}