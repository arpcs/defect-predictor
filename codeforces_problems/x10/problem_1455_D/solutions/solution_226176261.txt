{
    "id": 226176261,
    "contestId": 1455,
    "creationTimeSeconds": 1696170891,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1455,
        "index": "D",
        "name": "Sequence and Swaps",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "dp",
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1455,
        "members": [
            {
                "handle": "Mayank_Pushpjeet"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1606746900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 49,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 145305600,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define gc getchar_unlocked\r\n#define fo(i,n) for(i=0;i<n;i++)\r\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\r\n#define ll long long\r\n#define si(x)    scanf(\"%d\",&x)\r\n#define sl(x)    scanf(\"%lld\",&x)\r\n#define ss(s)    scanf(\"%s\",s)\r\n#define pi(x)    printf(\"%d\\n\",x)\r\n#define pl(x)    printf(\"%lld\\n\",x)\r\n#define ps(s)    printf(\"%s\\n\",s)\r\n#define deb(x) cout << #x << \"=\" << x << endl\r\n#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\r\n#define pb push_back\r\n#define mp make_pair\r\n#define F first\r\n#define S second\r\n#define al(a)           a.begin(),a.end()\r\n#define alg(a)          a.rbegin(),a.rend()\r\n#define getunique(v)    {sort(al(v)); v.erase(unique(al(v)),v.end());}\r\n#define input(a,n)      for(int i=0;i<n;i++)cin>>a[i]\r\n#define print(a)        for(auto it:a){cout<<it<<\" \";}cout<<endl\r\n#define sll             set<long long>\r\n#define msll            multiset<long long>\r\n#define inmap(x,mymap)  mymap.find(x)!=mymap.end()\r\n#define mll             map<ll,ll>\r\n#define mmll            multimap<ll,ll>\r\n#define uset            unordered_set<ll>\r\n#define lb              lower_bound\r\n#define ub              upper_bound\r\n#define Inf             1e18\r\n#define YES             cout << \"YES\" << endl;\r\n#define NO              cout << \"NO\" << endl;\r\n#define yes             cout << \"YES\" << endl;\r\n#define no              cout << \"NO\" << endl;\r\n/*--- bit-stuff ----*/\r\n#define setbits(a)      (__builtin_popcountll(a))  // to count 1 bits\r\n#define right(a)        (__builtin_ctzll(a))       // to count trailing 0s\r\n#define left(a)         (__builtin_clzll(a))       // to count leading 0s\r\n#define parity(a)       (__builtin_parityll(a))    // to check even odd\r\n#define all(x) x.begin(), x.end()\r\n#define clr(x) memset(x, 0, sizeof(x))\r\n#define sortall(x) sort(all(x))\r\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\r\n#define PI 3.1415926535897932384626\r\ntypedef pair<int, int>    pii;\r\ntypedef pair<ll, ll>    pl;\r\ntypedef vector<int>        vi;\r\ntypedef vector<ll>        vl;\r\ntypedef vector<pii>        vpii;\r\ntypedef vector<pl>        vpl;\r\ntypedef vector<vi>        vvi;\r\ntypedef vector<vl>        vvl;\r\nmt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\r\nint rng(int lim) {\r\n    uniform_int_distribution<int> uid(0,lim-1);\r\n    return uid(rang);\r\n}\r\nll mpow(ll base, ll exp); \r\nvoid ipgraph(ll n, ll m);\r\nvoid dfs(ll u, ll par);\r\nll NCR(ll n,ll r, ll M);\r\nll gcdExtended(ll a, ll b, ll* x, ll* y);\r\nll modinverse(ll A, ll M);\r\nvoid linear_sieve();\r\nbool is_ancestor(ll u, ll v);\r\nll lca(ll u, ll v);\r\n\r\nconst int mod = 1'000'000'007;\r\nconst int N = 3e5, M = N;\r\nconst int N1 = 10000000;\r\n//=======================\r\nstruct segtree{\r\n        ll size;\r\n        vector<long long> operation; \r\n        void init(ll n){\r\n                size=1;\r\n                while(size<n) size*=2;\r\n                operation.assign(2*size,0ll);\r\n\r\n        }\r\n        void build(vl &a,ll x,ll lx,ll rx){\r\n                if(rx-lx==1){\r\n                        if(lx<a.size()) operation[x]=a[lx];\r\n                        return;\r\n                }\r\n                else{\r\n                    ll m = (lx+rx)/2;\r\n                    build (a,2*x+1,lx,m);\r\n                    build (a,2*x+2,m,rx);\r\n                    operation[x]=operation[2*x+1]+operation[2*x+2];\r\n                }\r\n        }\r\n        void build(vl &a){\r\n                build(a,0,0,size);\r\n        }\r\n        ll todo(ll l, ll r, ll x,ll lx,ll rx){\r\n                if(l>=rx || r<=lx) return 0;\r\n                if(lx>=l && rx<=r){\r\n                      return operation[x];  \r\n                }\r\n                else{\r\n                        ll m=(lx+rx)/2;\r\n                        return todo(l,r,2*x+1,lx,m)+todo(l,r,2*x+2,m,rx);\r\n                }\r\n        }\r\n        ll todo(ll l, ll r){\r\n                ll p = todo(l,r,0,0,size);\r\n                return p;\r\n        }\r\n        void set(ll i,ll v,ll x,ll lx, ll rx){\r\n                if(rx-lx==1){\r\n                        operation[x]=v;\r\n                        return;\r\n                }\r\n                else{\r\n                        ll m=(lx+rx)/2;\r\n                        if(i<m){\r\n                                set(i,v,2*x+1,lx,m);\r\n                        }\r\n                        else{\r\n                                set(i,v,2*x+2,m,rx);\r\n                        }\r\n                        operation[x]=operation[2*x+1]+operation[2*x+2];\r\n                }\r\n        }\r\n        void set(ll i, ll v){\r\n                set(i,v,0,0,size);\r\n        }\r\n};\r\n\r\n// =================================================================\r\n\r\nvl g[N]; \r\nvector<ll> lp(N1+1),pr,tin(N+7), tout(N+7),depth(N+7,0);\r\nvector<vl> up(N+7,vl(20));\r\nll timer,binary_up;\r\n\r\n\r\nvoid solve(){\r\n    ll i,j,k,n,x;\r\n    cin>>n>>x;\r\n    vl a(n); input(a,n);\r\n    ll ans = 0;\r\n    for(i=1;i<n;i++){\r\n            if(a[i]<a[i-1]){\r\n                    for(j=0;j<=i-1;j++){\r\n                            if(a[j]>x){\r\n                                    ans++;\r\n                                    swap(a[j],x);\r\n                            }\r\n                    }\r\n                    if(a[i]<a[i-1]){\r\n                            cout<<-1<<endl;\r\n                            return;\r\n                    }\r\n            }\r\n    }\r\n    cout<<ans<<endl;\r\n}\r\nint main() {\r\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\r\n    srand(chrono::high_resolution_clock::now().time_since_epoch().count());\r\n    \r\n    // linear_sieve();\r\n    ll t = 1; \r\n    cin>>t;\r\n    while(t--){\r\n           solve(); \r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid linear_sieve()\r\n{\r\n    for (int i=2; i <= N1; ++i) {\r\n    if (lp[i] == 0) {\r\n        lp[i] = i;\r\n        pr.push_back(i);\r\n    }\r\n    for (int j=0; j < (int)pr.size() && pr[j] <= lp[i] && i*pr[j] <= N1; ++j) {\r\n        lp[i * pr[j]] = pr[j];\r\n    }\r\n  }\r\n}\r\n\r\nll modinverse(ll A, ll M)\r\n{\r\n    ll x, y;\r\n    ll g = gcdExtended(A, M, &x, &y);\r\n    if (g != 1)\r\n        return -1;\r\n    else {\r\n \r\n        // m is added to handle negative x\r\n        ll res = (x % M + M) % M;\r\n        return res;\r\n    }\r\n}\r\n\r\nll gcdExtended(ll a, ll b, ll* x, ll* y)\r\n{\r\n \r\n    // Base Case\r\n    if (a == 0) {\r\n        *x = 0, *y = 1;\r\n        return b;\r\n    }\r\n \r\n    // To store results of recursive call\r\n    ll x1, y1;\r\n    ll gcd = gcdExtended(b % a, a, &x1, &y1);\r\n \r\n    // Update x and y using results of recursive\r\n    // call\r\n    *x = y1 - (b / a) * x1;\r\n    *y = x1;\r\n \r\n    return gcd;\r\n}\r\n\r\nll NCR(ll n,ll r, ll M){\r\n        if(r>n) return 0ll;\r\n        if(r== n || r==0 ) return 1ll;\r\n        ll a1=1,a2=1,a3=1,i;\r\n        for(i=1;i<=n;i++) a1=(a1*i)%M;\r\n        for(i=1;i<=r;i++) a2=(a2*i)%M;\r\n        for(i=1;i<=n-r;i++) a3=(a3*i)%M;\r\n        a2=(a2*(a3))%M;\r\n        a2=modinverse(a2,M);\r\n        a1=(a1*a2)%M;\r\n        return a1;\r\n}\r\n\r\nll mpow(ll base, ll exp) {\r\n  base %= mod;\r\n  ll result = 1;\r\n  while (exp > 0) {\r\n    if (exp & 1) result = ((ll)result * base) % mod;\r\n    base = ((ll)base * base) % mod;\r\n    exp >>= 1;\r\n  }\r\n  return result;\r\n}\r\n\r\nvoid ipgraph(ll n, ll m){\r\n    ll i, u, v;\r\n    while(m--){\r\n        cin>>u>>v;\r\n    u--, v--;\r\n        g[u].pb(v);\r\n        g[v].pb(u);\r\n    }\r\n}\r\n\r\nvoid dfs(ll u, ll par){\r\n    for(ll v:g[u]){\r\n        if (v == par) continue;\r\n        dfs(v, u);\r\n    }\r\n}\r\n\r\nbool is_ancestor(ll u, ll v)\r\n{\r\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\r\n}\r\n\r\nll lca(ll u, ll v){\r\n    if (is_ancestor(u, v)) return u;\r\n        \r\n    if (is_ancestor(v, u)) return v;\r\n        \r\n    for (ll i = binary_up; i >= 0; --i) {\r\n        if (!is_ancestor(up[u][i], v)) u = up[u][i];   \r\n    }\r\n    return up[u][0];\r\n}\r\n"
}