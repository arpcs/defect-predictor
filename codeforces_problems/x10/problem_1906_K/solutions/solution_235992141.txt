{
    "id": 235992141,
    "contestId": 1906,
    "creationTimeSeconds": 1701834399,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1906,
        "index": "K",
        "name": "Deck-Building Game",
        "type": "PROGRAMMING",
        "rating": 2500,
        "tags": [
            "divide and conquer",
            "math"
        ]
    },
    "author": {
        "contestId": 1906,
        "members": [
            {
                "handle": "Zhouershan"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1701578100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 23,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 3686400,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\nnamespace FastIO\r\n{\r\n// ------------------------------\r\n#define IN_HAS_NEG\r\n#define OUT_HAS_NEG\r\n#define CHK_EOF\r\n#define DISABLE_MMAP\r\n// ------------------------------\r\n#if __cplusplus < 201400\r\n#error Please use C++14 or higher.\r\n#endif\r\n#if __cplusplus > 201700\r\n#define INLINE_V inline\r\n#else\r\n#define INLINE_V\r\n#endif\r\n#if ( defined(LOCAL) || defined (_WIN32) ) && !defined(DISABLE_MMAP)\r\n#define DISABLE_MMAP\r\n#endif\r\n#ifndef DISABLE_MMAP\r\n#include<sys/mman.h>\r\n#endif\r\n#ifdef LOCAL\r\n    inline char gc() { return getchar(); }\r\n    inline void pc(char c) { putchar(c); }\r\n#else\r\n#ifdef DISABLE_MMAP\r\n    INLINE_V constexpr int _READ_SIZE = 1 << 18;\r\n    INLINE_V static char _read_buffer[_READ_SIZE], *_read_ptr = nullptr, *_read_ptr_end = nullptr;\r\n    inline char gc()\r\n    {\r\n        if ( __builtin_expect(_read_ptr == _read_ptr_end, false) )\r\n        {\r\n            _read_ptr = _read_buffer;\r\n            _read_ptr_end = _read_buffer + fread(_read_buffer, 1, _READ_SIZE, stdin);\r\n#ifdef CHK_EOF\r\n            if ( __builtin_expect(_read_ptr == _read_ptr_end, false) ) return EOF;\r\n#endif\r\n        }\r\n        return *_read_ptr++;\r\n    }\r\n#else\r\n    INLINE_V static const char *_read_ptr = (const char *)mmap(nullptr, INT_MAX, 1, 2, 0, 0);\r\n    inline char gc() { return *_read_ptr++; }\r\n#endif\r\n    INLINE_V constexpr int _WRITE_SIZE = 1 << 18;\r\n    INLINE_V static char _write_buffer[_WRITE_SIZE], *_write_ptr = _write_buffer;\r\n    inline void pc(char c)\r\n    {\r\n        *_write_ptr++ = c;\r\n        if ( __builtin_expect(_write_buffer + _WRITE_SIZE == _write_ptr, false) )\r\n        {\r\n            fwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout);\r\n            _write_ptr = _write_buffer;\r\n        }\r\n    }\r\n    INLINE_V struct _auto_flush\r\n    {\r\n        ~_auto_flush() { fwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout); }\r\n    }\t_auto_flush;\r\n#endif\r\n#ifdef CHK_EOF\r\n    inline bool _isdigit(char c) { return ( c & 16 ) && c != EOF; }\r\n    inline bool _isgraph(char c) { return c > 32 && c != EOF; }\r\n#else\r\n    inline bool _isdigit(char c) { return c & 16; }\r\n    inline bool _isgraph(char c) { return c > 32; }\r\n#endif\r\n    template < class T >\r\n    INLINE_V constexpr bool _is_integer = numeric_limits < T >::is_integer;\r\n    template < class T >\r\n    INLINE_V constexpr bool _is_signed = numeric_limits < T >::is_signed;\r\n    template < class T >\r\n    INLINE_V constexpr bool _is_unsigned = _is_integer < T > && !_is_signed < T >;\r\n    template <> INLINE_V constexpr bool _is_integer < __int128 > = true;\r\n    template <> INLINE_V constexpr bool _is_integer < __uint128_t > = true;\r\n    template <> INLINE_V constexpr bool _is_signed < __int128 > = true;\r\n    template <> INLINE_V constexpr bool _is_unsigned < __uint128_t > = true;\r\n#undef INLINE_V\r\n    inline void read(char &c) { do c = gc(); while ( !_isgraph(c) ); }\r\n    inline void read_cstr(char *s)\r\n    {\r\n        char c = gc(); while ( !_isgraph(c) ) c = gc();\r\n        while ( _isgraph(c) ) *s++ = c, c = gc();\r\n        *s = 0;\r\n    }\r\n    inline void read(string &s)\r\n    {\r\n        char c = gc(); s.clear(); while ( !_isgraph(c) ) c = gc();\r\n        while ( _isgraph(c) ) s.push_back(c), c = gc();\r\n    }\r\n#ifdef IN_HAS_NEG\r\n    template < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n    inline void read(T &x)\r\n    {\r\n        char c = gc(); bool f = true; x = 0;\r\n        while ( !_isdigit(c) ) { if ( c == 45 ) f = false; c = gc(); }\r\n        if ( f ) while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n        else     while ( _isdigit(c) ) x = x * 10 - ( c & 15 ), c = gc();\r\n    }\r\n    template < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n    template < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n    inline void read(T &x)\r\n    {\r\n        char c = gc(); while ( !_isdigit(c) ) c = gc();\r\n        x = 0; while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n    }\r\n    inline void write(char c) { pc(c); }\r\n    inline void write_cstr(const char *s) { while ( *s ) pc(*s++); }\r\n    inline void write(const string &s) { for ( char c : s ) pc(c); }\r\n#ifdef OUT_HAS_NEG\r\n    template < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n    inline void write(T x)\r\n    {\r\n        char buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n        if ( x >= 0 )  do buffer[digits++] =  ( x % 10 ) | 48, x /= 10; while ( x );\r\n        else { pc(45); do buffer[digits++] = -( x % 10 ) | 48, x /= 10; while ( x ); }\r\n        while ( digits ) pc(buffer[--digits]);\r\n    }\r\n    template < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n    template < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n    inline void write(T x)\r\n    {\r\n        char buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n        do buffer[digits++] = ( x % 10 ) | 48, x /= 10; while ( x );\r\n        while ( digits ) pc(buffer[--digits]);\r\n    }\r\n    template < int N > struct _tuple_io_helper\r\n    {\r\n        template < class ...T >\r\n        static inline void _read(tuple < T... > &x)\r\n        { _tuple_io_helper < N - 1 >::_read(x), read(get < N - 1 > (x)); }\r\n        template < class ...T >\r\n        static inline void _write(const tuple < T... > &x)\r\n        { _tuple_io_helper < N - 1 >::_write(x), pc(32), write(get < N - 1 > (x)); }\r\n    };\r\n    template <> struct _tuple_io_helper < 1 >\r\n    {\r\n        template < class ...T >\r\n        static inline void _read(tuple < T... > &x) { read(get < 0 > (x)); }\r\n        template < class ...T >\r\n        static inline void _write(const tuple < T... > &x) { write(get < 0 > (x)); }\r\n    };\r\n    template < class ...T >\r\n    inline void read(tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_read(x); }\r\n    template < class ...T >\r\n    inline void write(const tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_write(x); }\r\n    template < class T1, class T2 >\r\n    inline void read(pair < T1, T2 > &x) { read(x.first), read(x.second); }\r\n    template < class T1, class T2 >\r\n    inline void write(const pair < T1, T2 > &x) { write(x.first), pc(32), write(x.second); }\r\n    template < class T1, class ...T2 >\r\n    inline void read(T1 &x, T2 &...y) { read(x), read(y...); }\r\n    template < class ...T >\r\n    inline void read_cstr(char *x, T *...y) { read_cstr(x), read_cstr(y...); }\r\n    template < class T1, class ...T2 >\r\n    inline void write(const T1 &x, const T2 &...y) { write(x), write(y...); }\r\n    template < class ...T >\r\n    inline void write_cstr(const char *x, const T *...y) { write_cstr(x), write_cstr(y...); }\r\n    template < class T >\r\n    inline void print(const T &x) { write(x); }\r\n    inline void print_cstr(const char *x) { write_cstr(x); }\r\n    template < class T1, class ...T2 >\r\n    inline void print(const T1 &x, const T2 &...y) { print(x), pc(32), print(y...); }\r\n    template < class ...T >\r\n    inline void print_cstr(const char *x, const T *...y) { print_cstr(x), pc(32), print_cstr(y...); }\r\n    inline void println() { pc(10); }\r\n    inline void println_cstr() { pc(10); }\r\n    template < class ...T >\r\n    inline void println(const T &...x) { print(x...), pc(10); }\r\n    template < class ...T >\r\n    inline void println_cstr(const T *...x) { print_cstr(x...), pc(10); }\r\n}\r\nusing namespace FastIO;\r\nconstexpr long long P = 998244353;\r\nconst int N = 1 << 17;\r\nnamespace FWT {\r\ninline void XOR(long double *f, int len, long double type) {\r\n    for (int i = 2, k = 1; i <= len; i <<= 1, k <<= 1)\r\n        for (int j = 0; j < len; j += i)\r\n            for (int l = j; l < j + k; l++) f[l] += f[l + k], f[l + k] = f[l] - f[l + k] - f[l + k], f[l] *= type, f[l + k] *= type;\r\n}\r\ninline void XOR2(long long *f, int len, long long type) {\r\n    for (int i = 2, k = 1; i <= len; i <<= 1, k <<= 1)\r\n        for (int j = 0; j < len; j += i)\r\n            for (int l = j; l < j + k; l++) f[l] = (f[l] + f[l + k]) % P, f[l + k] = (f[l] - f[l + k] - f[l + k] + P + P) % P, f[l] = f[l] * type % P, f[l + k] = f[l + k] * type % P;\r\n}\r\n};  // namespace FWT\r\nint n, x;\r\nlong double f[N];\r\nlong long f2[N];\r\nusing ll = long long;\r\ninline ll qpw(ll a, ll b) {\r\n    ll ans = 1;\r\n    while (b) {\r\n        if (b & 1) ans = ans * a % P;\r\n        a = a * a % P, b >>= 1;\r\n    }\r\n    return ans;\r\n}\r\nint main() {\r\n    read(n);\r\n    for (int i = 1; i <= n; i++) {\r\n        read(x);\r\n        f[x] += 2, f[0] += 1;\r\n    }\r\n    FWT::XOR(f, 1 <<  17, 1);\r\n    for (int i = 0; i < (1 << 17); i++) {\r\n        long long c = (f[i] + n) / 4 + 0.4;\r\n        f2[i] = (qpw(3, c) * qpw(-1, n - c) + P) % P;\r\n        // if (i <= 32)\r\n        // cout << \"find:\" << i << ' ' << f[i] << ' ' << f2[i] << endl;\r\n    }\r\n    FWT::XOR2(f2, 1 << 17, 998244353 + 1 >> 1);\r\n    println(f2[0]);\r\n    return 0;\r\n}"
}