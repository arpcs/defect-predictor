{
    "id": 228856076,
    "contestId": 1031,
    "creationTimeSeconds": 1697748793,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1031,
        "index": "E",
        "name": "Triple Flips",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2600,
        "tags": [
            "constructive algorithms"
        ]
    },
    "author": {
        "contestId": 1031,
        "members": [
            {
                "handle": "Perpetually_Purple"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1540109400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 9,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 102400,
    "source": "// uncomment if you need to cheese\r\n//#pragma GCC target (\"avx2\")\r\n//#pragma GCC optimize (\"O3\")\r\n//#pragma GCC optimize(\"Ofast\")\r\n//#pragma GCC optimize (\"unroll-loops\")\r\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL) \r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define endl '\\n'\r\ntypedef long long ll;\r\n#define mod1 (ll)1000000007\r\n#define mod2 (ll)998244353\r\n#define pll pair<ll,ll>\r\ntypedef long double lb;\r\ntypedef tree<\r\npair<ll, ll>,\r\nnull_type,\r\nless<pair<ll, ll>>,\r\nrb_tree_tag,\r\ntree_order_statistics_node_update> ordered_set;\r\n#define eps (lb)(1e-9)\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n// Operator overloads\r\ntemplate<typename T1, typename T2> // cin >> pair<T1, T2>\r\nistream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); }\r\n\r\ntemplate<typename T> // cin >> vector<T>\r\nistream& operator>>(istream &istream, vector<T> &v)\r\n{\r\n    for (auto &it : v)\r\n        cin >> it;\r\n    return istream;\r\n}\r\n\r\ntemplate<typename T1, typename T2> // cout << pair<T1, T2>\r\nostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }\r\ntemplate<typename T> // cout << vector<T>\r\nostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }\r\n\r\n// Utility functions\r\ntemplate <typename T>\r\nvoid print(T &&t)  { cout << t << \"\\n\"; }\r\ntemplate <typename T, typename... Args>\r\nvoid print(T &&t, Args &&... args)\r\n{\r\n    cout << t << \" \";\r\n    print(forward<Args>(args)...);\r\n}\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nll random(ll p){ // gives random number in [0,p]\r\n\r\n return uniform_int_distribution<ll>(0, p)(rng);\r\n}\r\nstruct XorBasis{\r\n    private:\r\n    vector<ll> basis;\r\n    int lg;\r\n    int sz = 0;\r\n\r\n    public:\r\n    XorBasis(int lg) : lg(lg){\r\n        basis.resize(lg);\r\n    }\r\n    bool add(ll x){\r\n        if(x >= (1ll<<lg)) return 0;\r\n        for(int i=0;i<lg;i++){\r\n            if(~x&(1ll<<i)) continue;\r\n            if(!basis[i]){\r\n                basis[i] = x;\r\n                ++sz;\r\n                return 1;\r\n            }\r\n            x^=basis[i];\r\n        }\r\n        return 0;\r\n    }\r\n    bool contains(ll x){\r\n        for(int i=0;i<lg;i++){\r\n            if(~x&(1ll<<i)) continue;\r\n            if(!basis[i]){\r\n                return false;\r\n            }\r\n            x^=basis[i];\r\n        }\r\n        return true;\r\n    }\r\n    int size(){\r\n        return sz;\r\n    }\r\n    const vector<ll>::iterator begin(){\r\n        return basis.begin();\r\n    }\r\n    const vector<ll>::iterator end(){\r\n        return basis.end();\r\n    }\r\n};\r\nvoid pre(ll p){ // checking if 12 form a xor basis ;yes it does >=8 forms a xor basis\r\n    XorBasis x(p);\r\n    for(ll a(0);a<p;++a){\r\n        \r\n        for(ll b(a+1);b<p;++b){\r\n            if((a+b)&1){continue;}\r\n            ll mid=(a+b)>>1;\r\n            ll t=(1<<a)+(1<<b)+(1<<mid);\r\n            x.add(t);\r\n        }\r\n    }\r\n    // cout<<x.size()<<endl;\r\n}   \r\nvoid solve();\r\nint main() {\r\nio;\r\n//freopen(\"input.txt\", \"r\", stdin);\r\n//freopen(\"output.txt\", \"w\", stdout);\r\nll t=1,n=1;\r\n// cin>>t;\r\nwhile (t--){\r\n     solve();\r\n    }\r\n     return 0;\r\n}\r\nvoid solve(){\r\n    ll n;\r\n    cin>>n;\r\n    deque<ll>v(n); \r\n    for(auto &i:v){\r\n        cin>>i;\r\n    }\r\n    auto pp=v;\r\n    vector<vector<ll>>moves;\r\n    ll lo=0,hi=n-1;\r\n\r\n    while ((hi-lo+1)>12)\r\n    {\r\n        if(v[lo]==0){\r\n            lo++;\r\n        }\r\n        else if(v[hi]==0){\r\n            hi--;\r\n        }\r\n        else if(v[lo+1]==0){\r\n            if(v[lo+2]==0){\r\n                // lo,lo+3,lo+6\r\n                moves.push_back({lo,lo+3,lo+6});\r\n                v[lo]^=1;\r\n                v[lo+3]^=1;\r\n                v[lo+6]^=1;\r\n            }\r\n            else {\r\n                // lo,lo+2,lo+4\r\n                moves.push_back({lo,lo+2,lo+4});\r\n                v[lo]^=1;\r\n                v[lo+2]^=1;\r\n                v[lo+4]^=1;                \r\n            }\r\n\r\n        }\r\n        else if(v[lo+2]){\r\n            // lo,lo+1,lo+2\r\n            moves.push_back({lo,lo+1,lo+2});\r\n            v[lo]^=1;\r\n            v[lo+1]^=1;\r\n            v[lo+2]^=1;\r\n        }\r\n        else if(v[hi-1]==0){\r\n            if(v[hi-2]==0){\r\n                // hi-6,hi-3,hi\r\n                moves.push_back({hi-6,hi-3,hi});\r\n                v[hi]^=1;\r\n                v[hi-3]^=1;\r\n                v[hi-6]^=1;\r\n            }\r\n            else {\r\n                // hi-4,hi-2,hi\r\n                moves.push_back({hi-4,hi-2,hi});\r\n                v[hi]^=1;\r\n                v[hi-2]^=1;\r\n                v[hi-2]^=1;                \r\n            }            \r\n        }\r\n        else if(v[hi-2]){\r\n            // hi-2,hi-1,hi\r\n            moves.push_back({hi-2,hi-1,hi});\r\n            v[hi-2]^=1;\r\n            v[hi-1]^=1;\r\n            v[hi]^=1;\r\n        }\r\n        else{\r\n            if((lo&1)==(hi&1)){\r\n                ll mid=(lo+hi)>>1;\r\n                moves.push_back({lo,mid,hi});\r\n                moves.push_back({lo+1,mid,hi-1});\r\n                \r\n            }\r\n            else{\r\n                ll mid=(lo+hi-1)>>1;\r\n                moves.push_back({lo,mid,hi-1});\r\n                moves.push_back({lo+1,mid+1,hi});\r\n                v[mid]^=1;\r\n                v[mid+1]^=1;\r\n            }\r\n            v[lo]=v[hi]=v[lo+1]=v[hi-1]=0;\r\n        }\r\n    }\r\n    // make [lo,hi]=0\r\n    ll p=hi-lo+1;\r\n    ll val=0;\r\n    for(ll i(lo);i<=hi;++i){\r\n        if(v[i]){\r\n            val+=(1<<(i-lo));\r\n        }\r\n    }\r\n    XorBasis x(p);\r\n    vector<ll>ok;\r\n    for(ll a(0);a<p;++a){\r\n        for(ll b(a+1);b<p;++b){\r\n            if((a+b)&1){continue;}\r\n            ll mid=(a+b)>>1;\r\n            ll t=(1<<a)+(1<<b)+(1<<mid);\r\n            if(x.add(t)){\r\n                ok.push_back(t);\r\n            }\r\n        }\r\n    }\r\n    bool flag=0;\r\n    ll sz=ok.size();\r\n    for(ll i(0);i<(1<<sz);++i){\r\n        ll pp=0;\r\n        for(int j(0);j<sz;++j){\r\n            if((i>>j)&1){\r\n                pp^=ok[j];\r\n            }\r\n        }\r\n        if(pp==val){\r\n            flag=1;\r\n            for(int j(0);j<sz;++j){\r\n                if((i>>j)&1){\r\n                    // add ok[j];\r\n                    vector<ll>okg;\r\n                    for(ll t(0);t<p;++t){\r\n                        if((ok[j]>>t)&1){\r\n                            okg.push_back(lo+t);\r\n                        }\r\n                    }\r\n                    moves.push_back(okg);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    if(!flag){\r\n        cout<<\"NO\"<<endl;\r\n        return;\r\n    }\r\n    cout<<\"YES\"<<endl;\r\n    cout<<moves.size()<<endl;;\r\n    for(auto i:moves){\r\n        for(auto j:i){\r\n            cout<<j+1<<\" \";\r\n        }\r\n        cout<<endl;\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n// Do not get stuck on a single approach for long, think of multiple ways"
}