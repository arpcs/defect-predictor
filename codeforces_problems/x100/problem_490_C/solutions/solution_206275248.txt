{
    "id": 206275248,
    "contestId": 490,
    "creationTimeSeconds": 1684350281,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 490,
        "index": "C",
        "name": "Hacking Cypher",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "math",
            "number theory",
            "strings"
        ]
    },
    "author": {
        "contestId": 490,
        "members": [
            {
                "handle": "Suryanshjaiswal"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1416733800
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 71,
    "timeConsumedMillis": 343,
    "memoryConsumedBytes": 17612800,
    "source": "/*---------JAI HO GURUDEV---------*/ \r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long \r\n#define f(i,n) for(ll i=0;i<n;i++)\r\n#define fast cin.tie(0), cout.tie(0), cin.sync_with_stdio(0), cout.sync_with_stdio(0);\r\n#define f1(i,n) for(ll i=n;i>=0;i--)\r\n#define forr(i,a,b) for(ll i=a;i<b;i++)\r\n#define forr1(i,a,b) for(ll i=a;i>=a;i--)\r\n#define rep(i,a,b)  for(int i=a;i<b;i++)\r\n#define sor(vec) sort(vec.begin(),vec.end())\r\n#define asor(ar) sort(ar,ar+ar.size());\r\n#define rsor(vec) sort(vec.rbegin(),vec.rend());\r\n#define dbg(var) cout<<#var<<\"=\"<<var<<\" \"\r\n#define vl vector<ll>\r\n#define yes cout << \"YES\"<< endl;\r\n#define no cout << \"NO\"<< endl;\r\n#define out(n) cout << n << endl;\r\n#define num(n) ll n; cin >> n;\r\n#define mxe(v)  *max_element(v.begin(),v.end())     // find max element in vector\r\n#define mne(v)  *min_element(v.begin(),v.end())     // find min element in vector\r\n#define pb push_back\r\n#define so(arr,n) sort(arr,arr+n) \r\nconst ll MOD = 998244353;\r\n//#define mod 1000000007\r\nconst ll N = 1e3 + 1;\r\nvector<int>adj[N];\r\nvector<bool>vis(N,false);\r\n \r\n\r\n int INF=INT_MAX;\r\n\r\n\r\n// ================================== take ip/op like vector,pairs directly!==================================\r\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\r\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\r\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\r\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\r\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\r\n// ===================================END Of the input module ==========================================\r\n \r\n// ====================================start of the segment tree=========================================\r\nclass STree{\r\nprivate:\r\n    vector<ll> tree;\r\n    int n;\r\n    ll sum(ll v, ll tl, ll tr, ll l, ll r) {      \r\n        if (l > r) return 0;\r\n        if (l == tl && r == tr) return tree[v];\r\n        \r\n        ll tm = (tl + tr) / 2;\r\n        return sum(v*2, tl, tm, l, (ll)min(r, tm))  + sum(v*2+1, tm+1, tr, (ll)max(l, tm+1), r);\r\n    }\r\n    ll minim(ll v,ll tl,ll tr,ll l,ll r)\r\n    {\r\n    if (tr<l || tl>r) return INT_MAX;\r\n    if(tl>=l && tr<=r)\r\n    return tree[v];\r\n        \r\n        ll tm = (tl + tr) / 2;\r\n        return min(minim(v*2, tl, tm, l, r), minim(v*2+1, tm+1, tr, l, r));    \r\n    }\r\n    void buildTree(vector<ll>& a,ll tl, ll tr,ll v=1){\r\n        if(tl>tr) return;\r\n        if(tl==tr){\r\n            tree[v]=a[tl];\r\n            return;\r\n        }\r\n \r\n        ll mid=(tl+tr)/2;\r\n        buildTree(a,tl,mid,v*2);\r\n        buildTree(a,mid+1,tr,v*2+1);\r\n        tree[v]=tree[v*2]+tree[v*2+1]; //sum\r\n        tree[v]=min(tree[2*v],tree[2*v+1]);//  minimum\r\n    }\r\n    void update(ll idx,ll val,ll v,ll tl,ll tr){\r\n        if(tl>tr) return;\r\n        if(idx<tl || idx>tr)  return;     //not in the current range\r\n        if(tl==tr){\r\n            tree[v]=val;\r\n            return;\r\n        }\r\n        ll tmid=(tl+tr)/2;\r\n        update(idx,val,v*2,tl,tmid);\r\n        update(idx,val,v*2+1,tmid+1,tr);\r\n        tree[v]=tree[v*2]+tree[v*2+1];\r\n    }\r\npublic:\r\n    STree(ll sz,vector<ll>& vec){\r\n        n=sz;\r\n        tree.assign(sz*4,0);\r\n        buildTree(vec,0,n-1);\r\n    }\r\n \r\n    ll getSum(int l,int r){\r\n        return sum(1,0,n-1,l,r);         // call the function!\r\n    }\r\n    void update(ll idx,ll val){     // v is the new value!\r\n        update(idx,val,1,0,n-1);\r\n    }\r\n    void printTree(vector<ll>& v){\r\n        cout<<v<<\"\\n\";\r\n    }\r\n \r\n};\r\n// ========================================= Segment tree ends here====================================\r\n\r\n// FERMAT'S LITTLE THEOREM\r\nll fastpow(ll a, ll b,ll Mod){\r\n    ll res = 1;\r\n    while(b > 0){\r\n        if(b&1)\r\n            res = (res * a) % Mod;\r\n        a = (a * a) % Mod;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\nclass DisjointSet\r\n{\r\n    vector<int> rank,parent;\r\npublic: \r\n    DisjointSet(int n)\r\n    {\r\n        parent.resize(n+1);\r\n        rank.resize(n+1,0);\r\n        for(int i=0;i<=n;i++)\r\n            parent[i]=i;\r\n     }\r\n     int ul_parent(int u)\r\n     {\r\n   if(parent[u]==u)\r\n    return u;\r\nelse\r\n    return parent[u]=ul_parent(parent[u]);\r\n     }\r\n     void findUnionByRank(int u,int v)\r\n     {\r\n        int ul_u=ul_parent(u);\r\n        int ul_v=ul_parent(v);\r\n        if(ul_u==ul_v)\r\n            return;\r\n        else if(rank[ul_u]<rank[ul_v])\r\n            parent[ul_u]=ul_v;\r\n        else if(rank[ul_v]<rank[ul_u])\r\n        {\r\n            parent[ul_v]=ul_u;\r\n        }\r\n        else\r\n        {\r\n            rank[ul_u]++;\r\n            parent[ul_v]=ul_u;\r\n        }\r\n     }\r\n\r\n\r\n};\r\n\r\nvector<int>  SieveOfEratosthenes(int n)\r\n{\r\n    // Create a boolean array \"prime[0..n]\" and initialize\r\n    // all entries it as true. A value in prime[i] will\r\n    // finally be false if i is Not a prime, else true.\r\n    bool prime[n + 1];\r\n    memset(prime, true, sizeof(prime));\r\n \r\n    for (int p = 2; p * p <= n; p++) {\r\n        // If prime[p] is not changed, then it is a prime\r\n        if (prime[p] == true) {\r\n            // Update all multiples of p greater than or\r\n            // equal to the square of it numbers which are\r\n            // multiple of p and are less than p^2 are\r\n            // already been marked.\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n vector<int> v;\r\n    // Print all prime numbers\r\n    for (int p = 2; p <= n; p++)\r\n        if (prime[p])\r\n            v.pb(p);\r\n        return v;\r\n}\r\nint position(ll x)\r\n{\r\n    int c=0;\r\n    while(x!=0)\r\n    {\r\n        c++;\r\n        x=x>>1;\r\n    }\r\n    return c;\r\n}\r\nbool compare(pair<int,int> a,pair<int,int> b)\r\n{\r\n    if(a.first==a.second)\r\n    return abs(a.second-b.second)>1;\r\nelse\r\n    return a.first>b.first;\r\n}\r\nbool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>> &dp){\r\n    if(target==0)\r\n        return true;\r\n    \r\n    if(ind == 0)\r\n        return arr[0] == target;\r\n    \r\n    if(dp[ind][target]!=-1)\r\n        return dp[ind][target];\r\n        \r\n    bool notTaken = subsetSumUtil(ind-1,target,arr,dp);\r\n    \r\n    bool taken = false;\r\n    if(arr[ind]<=target)\r\n        taken = subsetSumUtil(ind-1,target-arr[ind],arr,dp);\r\n        \r\n    return dp[ind][target]= notTaken||taken;\r\n}\r\nint ask(int l, int r) {\r\n    cout << \"? \" << l << ' ' << r << endl;\r\n    int res;\r\n    cin >> res;\r\n    return res;\r\n}\r\n\r\n \r\n  \r\nint add(int x, int y, int mod = MOD)\r\n{\r\n    return ((x + y) % mod + mod) % mod;\r\n}\r\n\r\nint mul(int x, int y, int mod = MOD)\r\n{\r\n    return (x * 1ll * y) % mod;\r\n}\r\n\r\nint binpow(int x, int y, int mod = MOD)\r\n{\r\n    int z = add(1, 0, mod);\r\n    while(y > 0)\r\n    {\r\n        if(y % 2 == 1) z = mul(z, x, mod);\r\n        y /= 2;\r\n        x = mul(x, x, mod);\r\n    }\r\n    return z;\r\n}\r\n\r\nvoid solve(int t1)\r\n{\r\n\r\nstring s;\r\ncin>>s;\r\nint n=s.length();\r\nint a,b;\r\ncin>>a>>b;\r\nll pref[n];\r\npref[0]=(s[0]-'0')%a;\r\nfor(int i=1;i<n;i++)\r\n{\r\npref[i]=(pref[i-1]*10+(s[i]-'0'))%a;\r\n}\r\nll suf[n];\r\nsuf[n-1]=(s[n-1]-'0')%b;\r\nfor(int i=n-2;i>=0;i--)\r\n{\r\n    int l=(n-i);\r\n    ll p=fastpow(10,l-1,b);\r\n    suf[i]=(suf[i+1]+(s[i]-'0')*p)%b;\r\n}\r\nint pos=-1;\r\nf(i,n-1)\r\n{\r\nif(pref[i]==0 && suf[i+1]==0 && s[i+1]!='0')\r\n{\r\n    pos=i;\r\n    break;\r\n}\r\n}\r\n\r\nif(pos!=-1)\r\n{\r\nyes\r\nf(i,pos+1)\r\ncout<<s[i];\r\ncout<<endl;\r\nfor(int i=pos+1;i<n;i++)\r\ncout<<s[i];\r\ncout<<endl;\r\n}\r\n\r\nelse\r\n{\r\n    no\r\n}\r\n\r\n}\r\nint main()\r\n{\r\n   fast      \r\n      int t=1;\r\n     //  cin>>t;\r\n      for(int t1=1;t1<=t;t1++)\r\n    {\r\n        //body of the loop\r\n   solve(t1);  \r\n  \r\n    }\r\n}"
}