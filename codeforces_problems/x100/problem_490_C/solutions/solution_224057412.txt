{
    "id": 224057412,
    "contestId": 490,
    "creationTimeSeconds": 1695135784,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 490,
        "index": "C",
        "name": "Hacking Cypher",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "math",
            "number theory",
            "strings"
        ]
    },
    "author": {
        "contestId": 490,
        "members": [
            {
                "handle": "e-sens"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1416733800
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 46,
    "timeConsumedMillis": 155,
    "memoryConsumedBytes": 24166400,
    "source": "import sys\r\nfrom bisect import bisect_left,bisect_right\r\nfrom collections import defaultdict as dd\r\nfrom collections import deque, Counter\r\nfrom heapq import heappop,heappush,heapify,merge\r\nfrom itertools import permutations, accumulate, product\r\nfrom math import gcd,sqrt,ceil\r\ntoBin=lambda x:bin(x).replace(\"0b\",\"\")\r\nI=lambda:map(int,input().split())\r\ninf=float(\"inf\");DIRS=[[1,0],[-1,0],[0,1],[0,-1]];CHARS=\"abcdefghijklmnopqrstuvwxyz\";MOD=10**9+7\r\n###### Fill out N to calculate combinations#####################\r\n# N=300010;fac=[1]*N;invfac=[1]*N\r\n# for i in range(2,N):fac[i]=fac[i-1]*i%MOD\r\n# invfac[N-1]=pow(fac[N-1],MOD-2,MOD)\r\n# for i in range(N-1)[::-1]:invfac[i]=invfac[i+1]*(i+1)%MOD\r\n# def c(i,j):return 0 if i<j else fac[i]*invfac[j]*invfac[i-j]\r\n###############################################################\r\ninput=sys.stdin.readline\r\n\r\nclass UnionFind:\r\n    def __init__(self,n):self.p=list(range(n));self.rank=[0]*n\r\n    def find(self,x):\r\n        if x!=self.p[x]:self.p[x]=self.find(self.p[x])\r\n        return self.p[x]\r\n    def union(self,x, y):\r\n        px,py=self.find(x),self.find(y)\r\n        if px==py:return 0\r\n        self.p[py]=px\r\n        self.rank[px]+=self.rank[py]\r\n        return 1\r\n\r\nfrom types import GeneratorType\r\ndef cache(f,queue=[]):\r\n    def wrappedfunc(*args,**kwargs):\r\n        if queue:return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args,**kwargs)\r\n            while True:\r\n                if isinstance(to,GeneratorType):queue.append(to);to = next(to)\r\n                else:\r\n                    if not queue:break\r\n                    queue.pop()\r\n                    if not queue:break\r\n                    to=queue[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\ndef query(x,y):\r\n    print(\"?\",x,y,flush=True)\r\n    return int(input())\r\n\r\n# Sorted List Code Template\r\n_A=True\r\nclass SortedList:\r\n    def __init__(A,iterable=[],_load=200):B=_load;C=sorted(iterable);A._len=E=len(C);A._load=B;A._lists=D=[C[A:A+B]for A in range(0,E,B)];A._list_lens=[len(A)for A in D];A._mins=[A[0]for A in D];A._fen_tree=[];A._rebuild=_A\r\n    def _fen_build(B):\r\n        B._fen_tree[:]=B._list_lens;C=B._fen_tree\r\n        for A in range(len(C)):\r\n            if A|A+1<len(C):C[A|A+1]+=C[A]\r\n        B._rebuild=False\r\n    def _fen_update(B,index,value):\r\n        A=index\r\n        if not B._rebuild:\r\n            C=B._fen_tree\r\n            while A<len(C):C[A]+=value;A|=A+1\r\n    def _fen_query(B,end):\r\n        A=end\r\n        if B._rebuild:B._fen_build()\r\n        D=B._fen_tree;C=0\r\n        while A:C+=D[A-1];A&=A-1\r\n        return C\r\n    def _fen_findkth(A,k):\r\n        B=A._list_lens\r\n        if k<B[0]:return 0,k\r\n        if k>=A._len-B[-1]:return len(B)-1,k+B[-1]-A._len\r\n        if A._rebuild:A._fen_build()\r\n        C=A._fen_tree;D=-1\r\n        for F in reversed(range(len(C).bit_length())):\r\n            E=D+(1<<F)\r\n            if E<len(C)and k>=C[E]:D=E;k-=C[D]\r\n        return D+1,k\r\n    def _delete(B,pos,idx):\r\n        A=pos;C=B._lists;E=B._mins;D=B._list_lens;B._len-=1;B._fen_update(A,-1);del C[A][idx];D[A]-=1\r\n        if D[A]:E[A]=C[A][0]\r\n        else:del C[A];del D[A];del E[A];B._rebuild=_A\r\n    def _loc_left(E,value):\r\n        F=value\r\n        if not E._len:return 0,0\r\n        G=E._lists;I=E._mins;B,A=-1,len(G)-1\r\n        while B+1<A:\r\n            C=B+A>>1\r\n            if F<=I[C]:A=C\r\n            else:B=C\r\n        if A and F<=G[A-1][-1]:A-=1\r\n        H=G[A];B,D=-1,len(H)\r\n        while B+1<D:\r\n            C=B+D>>1\r\n            if F<=H[C]:D=C\r\n            else:B=C\r\n        return A,D\r\n    def _loc_right(D,value):\r\n        G=value\r\n        if not D._len:return 0,0\r\n        H=D._lists;J=D._mins;B,E=0,len(H)\r\n        while B+1<E:\r\n            A=B+E>>1\r\n            if G<J[A]:E=A\r\n            else:B=A\r\n        I=H[B];F,C=-1,len(I)\r\n        while F+1<C:\r\n            A=F+C>>1\r\n            if G<I[A]:C=A\r\n            else:F=A\r\n        return B,C\r\n    def add(A,value):\r\n        E=value;C=A._load;F=A._lists;H=A._mins;G=A._list_lens;A._len+=1\r\n        if F:\r\n            B,I=A._loc_right(E);A._fen_update(B,1);D=F[B];D.insert(I,E);G[B]+=1;H[B]=D[0]\r\n            if C+C<len(D):F.insert(B+1,D[C:]);G.insert(B+1,len(D)-C);H.insert(B+1,D[C]);G[B]=C;del D[C:];A._rebuild=_A\r\n        else:F.append([E]);H.append(E);G.append(1);A._rebuild=_A\r\n    def discard(A,value):\r\n        C=value;D=A._lists\r\n        if D:\r\n            E,B=A._loc_right(C)\r\n            if B and D[E][B-1]==C:A._delete(E,B-1)\r\n    def remove(A,value):\r\n        B=value;C=A._len;A.discard(B)\r\n        if C==A._len:raise ValueError('{0!r} not in list'.format(B))\r\n    def pop(A,index=-1):B=index;C,D=A._fen_findkth(A._len+B if B<0 else B);E=A._lists[C][D];A._delete(C,D);return E\r\n    def bisect_left(A,value):B,C=A._loc_left(value);return A._fen_query(B)+C\r\n    def bisect_right(A,value):B,C=A._loc_right(value);return A._fen_query(B)+C\r\n    def count(A,value):B=value;return A.bisect_right(B)-A.bisect_left(B)\r\n    def __len__(A):return A._len\r\n    def __getitem__(A,index):B=index;C,D=A._fen_findkth(A._len+B if B<0 else B);return A._lists[C][D]\r\n    def __delitem__(A,index):B=index;C,D=A._fen_findkth(A._len+B if B<0 else B);A._delete(C,D)\r\n    def __contains__(B,value):\r\n        C=value;A=B._lists\r\n        if A:D,E=B._loc_left(C);return E<len(A[D])and A[D][E]==C\r\n        return False\r\n    def __iter__(A):return(B for A in A._lists for B in A)\r\n    def __reversed__(A):return(B for A in reversed(A._lists)for B in reversed(A))\r\n    def __repr__(A):return'SortedList({0})'.format(list(A))\r\n\r\n# DP,BS,Greedy,Graph,Contribution,IE,Game,Reverse simulation\r\ndef main():\r\n    \"\"\"\r\n    13m - can calculate the mod of the first part on the fly.\r\n    (x * 10 + digit) mod a\r\n    had trouble with suffix, but it can be done - editorial at 1hr\r\n    prefix: rem[i] = (rem[i-1]*10 + x) mod a\r\n    suffix: rem[i] = (x * (i mod a) + rem[i+1]) mod a\r\n    1:23m - WA at T47\r\n    \"\"\"\r\n    ns=str(input()).strip();n=len(ns);a,b=I();pref=[0]*(n+1);suff=[0]*(n+1);ok=False;prev=10%b\r\n    for i in range(1,n+1):pref[i]=(pref[i-1]*10+int(ns[i-1]))%a\r\n    for i in range(n-1,-1,-1):\r\n        suff[i]=(suff[i+1]+prev*int(ns[i]))%b\r\n        prev=(prev*10)%b\r\n    # print(pref,suff)\r\n    for i in range(1,n):\r\n        if pref[i]==0 and suff[i]==0 and ns[i]!=\"0\":print(\"YES\");print(ns[:i]);print(ns[i:]);ok=True;break;\r\n    if not ok:print(\"NO\")\r\n\r\n###### Comment this out for Python 3 + imports at the top #####\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n###### Uncomment this for Python 3 (for deep recursion) ######\r\n# from sys import stdin, setrecursionlimit\r\n# import threading\r\n# from collections import defaultdict as dd\r\n# setrecursionlimit(5*10**5);input=stdin.buffer.readline;I=lambda:map(int,input().split())\r\n# threading.stack_size(10**8)\r\n# t = threading.Thread(target=main)\r\n# t.start()\r\n# t.join()"
}