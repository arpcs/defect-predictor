{
    "id": 221529655,
    "contestId": 490,
    "creationTimeSeconds": 1693637158,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 490,
        "index": "C",
        "name": "Hacking Cypher",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "math",
            "number theory",
            "strings"
        ]
    },
    "author": {
        "contestId": 490,
        "members": [
            {
                "handle": "codersclub"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1416733800
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "\n#include<iostream>\n#include<algorithm>\n#include <string>\n#include<iomanip>\n#include <map>\n#include<vector>\n#include <cmath>\n#include<set>\n#include<stack>\n#include<queue>\n#include <list>\n#include<cstring>\n#include<unordered_set>\n#include<unordered_map>\n#include<utility>\n\n \ntypedef long long ll;\n#define MP make_pair\n#define FR(i,b) for(int i=0;i<b;i++)\n#define pb push_back\n#define int long long\n#define fors(n) for(int i=0;i<n;i++)\nusing namespace std;\nconst ll MOD=1E9+7;\nconst int N=10000001;\n#define INT_SIZE 30\n#define pi 3.14159265358979323846264338327950\n#define double long double\n\nusing namespace std;\nconst int m2=998244353;\n// // int binarySearch(int arr[], int l, int r, int x)\n// // {\n// //     while (l <= r) {\n// //         int m = l + (r - l) / 2;\n \n// //         // Check if x is present at mid\n// //         if (arr[m] == x)\n// //             return m+1;\n \n// //         // If x greater, ignore left half\n// //         if (arr[m] < x)\n// //             l = m + 1;\n \n// //         // If x is smaller, ignore right half\n// //         else\n// //             r = m - 1;\n// //     }\n \n// //     // If we reach here, then element was not present\n// //     return 0;\n// // }\n\nint binpow(int a, int b,int c) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1){\n            res = (res * a)%c;\n            res%=c;\n        }\n        a = a * a;\n        a%=c;\n        b >>= 1;\n    }\n    return res%c;\n}\nll ma(ll a, ll b){\n    if(a>b){\n        return a;\n    }\n    return b;\n}\nvector<int> ar[200001];\nint vis[200001],dis[200001],out[2000001];\nvoid bfs(int v){\n    queue<int> q;\n    q.push(v);\n    vis[v]=1;\n    while(!q.empty()){\n        int curr=q.front();\n        q.pop();\n        vector<int> vp;\n        for(int child:ar[curr]){\n            if(vis[child]==0){\n                out[curr]++;\n                dis[child]=dis[curr]+1;\n                q.push(child);\n                vis[child]=1;\n            }\n        }\n    }\n}\n// vector<int> temp;\n// bool dfs(int v,int par){\n//     vis[v]=1;\n//     temp.push_back(v);\n//     for(int child:ar[v]){\n//         cout<<child<<\" \"<<v<<\" \";\n//         if(vis[child]==0){\n//             if(dfs(child,v)==true) return true;\n//         }\n//         else{\n//             if(par!=child){\n//                 temp.push_back(child);\n//                 return true;\n//             }\n//         }\n//     }\n//     temp.pop_back();\n//     return false;\n    \n    \n// }\n// int max(int a,int b){\n//     if(a>b){\n//         return a;\n//     }\n//     return b;\n// }\nvector<int> vimp;\nvoid dfs(int v){\n    vis[v]=1;\n    int p=0;\n    for(int child:ar[v]){\n        if(vis[child]==0){\n            dis[child]=dis[v]+1;\n            dfs(child);\n        }\n        else{\n            p++;\n        }\n        if(p==ar[v].size()){\n            vimp.pb(v);\n        }\n    }\n}\n\n\n// int dis1[200000+1],dis2[200001];\n// void dfs5 (int v){\n//     vis[v]=1;\n//     for(int child:ar[v]){\n//         if(vis[child]==0){\n//             dis1[child]=dis1[v]+1;\n//             dfs5(child);\n//         }\n//     }\n// }\n// void dfs6 (int v){\n//     vis[v]=1;\n//     for(int child:ar[v]){\n//         if(vis[child]==0){\n//             dis2[child]=dis2[v]+1;\n//             dfs6(child);\n//         }\n//     }\n// }\n// bool isprime(int n){\n//     for(int i=2;i*i<=n;i++){\n//         if(n%i==0){\n//             return false;\n//         }\n//     }\n//     return true;\n// }\n \n\nbool prime[100000];\nmap<int,int> mp;\nmap<int,int> mp1;\nvoid SieveOfEratosthenes(int n)\n{\n    for(int i=2;i<=n;i++){\n        if(prime[i]==0){\n            for(int j=2*i;j<=n;j+=i){\n                prime[j]=1;\n            }\n        }\n    }\n}\n// __int128 nCr(__int128 n, __int128 r)\n// {\n//     // Optimization for the cases when r is large\n//     if (r > n - r)\n//         r = n - r;\n \n//     // The array C is going to store last row of\n//     // pascal triangle at the end. And last entry\n//     // of last row is nCr\n//     __int128 C[r + 1];\n//     memset(C, 0, sizeof(C));\n \n//     C[0] = 1; // Top row of Pascal Triangle\n \n//     // One by constructs remaining rows of Pascal\n//     // Triangle from top to bottom\n//     for (int i = 1; i <= n; i++) {\n \n//         // Fill entries of current row using previous\n//         // row values\n//         for (int j = min(i, r); j > 0; j--)\n \n//             // nCj = (n-1)Cj + (n-1)C(j-1);\n//             C[j] = (C[j] + C[j - 1]);\n//     }\n//     return C[r];\n// }\n// int gcd(int a, int b)\n// {\n//     while (a > 0 && b > 0) {\n//         if (a > b) {\n//             a = a % b;\n//         }\n//         else {\n//             b = b % a;\n//         }\n//     }\n//     if (a == 0) {\n//         return b;\n//     }\n//     return a;\n// }\n// const int m1=1e9+7;\n// template <typename T>\n// pair<T, bool> get_nth_element(set<T>& set_name, int index)\n// {\n//     pair<T, bool> val;\n//     if (set_name.size() > index) {\n//         auto it = next(set_name.begin(), index);\n//         val.first = *it;\n//         val.second = true;\n//     }\n//     else\n//         val.second = false;\n//     return val;\n// }\n\n// // Comparator function to sort pairs\n// // according to second value\n// bool cmp(pair<int, int>& a,\n//         pair<int, int>& b)\n// {\n//     return a.second < b.second;\n// }\n \n// // Function to sort the map according\n// // to value in a (key-value) pairs\n// void sorti(map<int, int>& M)\n// {\n \n//     // Declare vector of pairs\n//     vector<pair<int, int> > A;\n \n//     // Copy key-value pair from Map\n//     // to vector of pairs\n//     for (auto& it : M) {\n//         A.push_back(it);\n//     }\n \n//     // Sort using comparator function\n//     sort(A.begin(), A.end(), cmp);\n \n//     // Print the sorted value\n//     for (auto& it : A) {\n//         cout<<it.first<<\" \";\n//     }\n// }\n// int vis2[1001][1001];\n// int dx[]={-1,0,1,0};\n// int dy[]={0,-1,0,1};\n// int n,m;\n// bool isvalid(int x,int y ){\n//     if(x<1 || x>n || y<1 || y>m){\n//         return false;\n//     }\n//     if(vis2[x][y]==1){\n//         return false;\n//     }\n//     if(arr[x][y]==0){\n//         return false;\n//     }\n//     return true;\n// }\n// void dfs2(int x,int y){\n//     vis2[x][y]=1;\n//     for(int i=0;i<4;i++){\n//         if(isvalid(x+dx[i],y+dy[i])){\n//             dfs2(x+dx[i],y+dy[i]);\n//         }\n//     }\n// }\n// int dp[1001][100001];\n// int binexp(int a, int b, int m) {\n//     a %= m;\n//     int res = 1;\n//     while (b > 0) {\n//         if (b & 1)\n//             res = res * a % m;\n//         a = a * a % m;\n//         b >>= 1;\n//     }\n//     return res;\n// }\n// const long long INF=9999999999999999;\n// void dijkstra(int s, vector<int> & d, vector<int> & p,int n1) {\n//     int n = n1+1;\n//     d.assign(n, INF);\n//     p.assign(n, -1);\n//     d[s] = 0;\n//     set<pair<int, int>> q;\n//     q.insert({0, s});\n//     while (!q.empty()) {\n//         int v = q.begin()->second;\n//         q.erase(q.begin());\n//         for (auto edge : ar[v]) {\n//             int to = edge.first;\n//             int len = edge.second;\n\n//             if (d[v] + len < d[to]) {\n//                 q.erase({d[to], to});\n//                 d[to] = d[v] + len;\n//                 p[to] = v;\n//                 q.insert({d[to], to});\n//             }\n//         }\n//     }\n// }\n// vector<int> restore_path(int s, int t, vector<int> const& p) {\n//     vector<int> path;\n//     for (int v = t; v != s; v = p[v])\n//         path.push_back(v);\n//     path.push_back(s);\n\n//     reverse(path.begin(), path.end());\n//     return path;\n// }\n\n\nvector<vector<int>> vres;\nint in[200001];\nvoid kahn (int n){\n    priority_queue<int,vector<int>,greater<int> > q;\n    vector<int> v;\n    for(int i=1;i<=n;i++){\n        if(in[i]==0){\n            q.push(i);\n            v.push_back(i);\n        }\n    }\n    vres.pb(v);\n    while(!q.empty()){\n        int curr=q.top();\n        vector<int> v;\n        q.pop();\n        for(int node:ar[curr]){\n            in[node]--;\n            if(in[node]==0){\n                v.push_back(node);\n                q.push(node);\n            }\n        }\n        if(v.size()>0) vres.pb(v);\n    }\n}\n\nint countSubsequencesWithSumDivisibleByK(vector<int>& arr, int k) {\n    int n = arr.size();\n    \n    // Initialize a map to store the count of remainders\n    unordered_map<int, int> remainderCount;\n    \n    int sum = 0; // Initialize the current sum\n    int result = 0; // Initialize the result\n    \n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n        \n        // Calculate the remainder when the sum is divided by k\n        int remainder = ((sum % k) + k) % k;\n        \n        // If remainder is 0, it's divisible by k\n        if (remainder == 0) \n            result++;\n        \n        // If there is a previous remainder in the map, add its count to the result\n        if (remainderCount.find(remainder) != remainderCount.end())\n            result += remainderCount[remainder];\n        \n        // Update the count of the current remainder\n        remainderCount[remainder]++;\n    }\n    return result;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    cin>>s;\n    int a,b;\n    cin>>a>>b;\n    int n=s.length();\n    int num=0;\n    string ans=\"\";\n    int k5=0;\n    bool f1=false,f2=false;\n    vector<int> v;\n    set<int> s1;\n    for(int i=0;i<n-1;i++){\n        num*=10;\n        num%=a;\n        num+=s.at(i)-48;\n        ans+=s.at(i);\n        num%=a;\n        if(num==0){\n            int j=i+1;\n            while(j<n && s.at(j)=='0'){\n                ans+=\"0\";\n                j++;\n            }\n            f1=true;\n            s1.insert(j);\n        }\n    }\n    fro(auto it:s){\n        v.pb(it);\n    }\n    if(f1==true){\n        int q=v.size();\n        int k=q-1;\n        int num=0;\n        for(int i=n-1;i>=v[0];i--){\n            num+=(s.at(i)-48)*binpow(10,n-1-i,b);\n            num%=b;\n            if(i==v[k] && num%b==0){\n                f2=true;\n                k5=i;\n                break;\n            }\n            else if(i==v[k]){\n                k--;\n            }\n        }\n    }\n    if(f2==true){\n        cout<<\"YES\"<<'\\n';\n        string s1=\"\";\n        for(int i=0;i<k5;i++){\n            s1+=s.at(i);\n        }\n        cout<<s1<<'\\n';\n        s1=\"\";\n        for(int i=k5;i<n;i++){\n            s1+=s.at(i);\n        }\n        cout<<s1<<\"\\n\";\n    }\n    else{\n        cout<<\"NO\"<<'\\n';\n    }\n}\n"
}