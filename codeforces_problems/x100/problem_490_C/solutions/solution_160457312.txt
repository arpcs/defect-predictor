{
    "id": 160457312,
    "contestId": 490,
    "creationTimeSeconds": 1655145046,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 490,
        "index": "C",
        "name": "Hacking Cypher",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "math",
            "number theory",
            "strings"
        ]
    },
    "author": {
        "contestId": 490,
        "members": [
            {
                "handle": "Unrated_Pritam"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1416733800
    },
    "programmingLanguage": "Java 8",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 92,
    "memoryConsumedBytes": 0,
    "source": "//  package faltu;\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.util.*;\r\nimport java.util.Map.Entry;\r\n\r\npublic class Main {\r\n\t public static int upperBound(long[] arr, long m, int l, int r) {\r\n\t    \twhile(l<=r) {\r\n\t    \t\tint mid=(l+r)/2;\r\n\t    \t\tif(arr[mid]<=m) l=mid+1;\r\n\t    \t\telse r=mid-1;\r\n\t    \t}\r\n\t    \treturn l;\r\n\t    }\r\n\t    \r\n\t    public static int lowerBound(long[] a, long m, int l, int r) {\r\n\t    \twhile(l<=r) {\r\n\t    \t\tint mid=(l+r)/2;\r\n\t    \t\tif(a[mid]<m) l=mid+1;\r\n\t    \t\telse r=mid-1;\r\n\t    \t}\r\n\t    \treturn l;\r\n\t    }\r\n    public static long getClosest(long val1, long val2,long target)\r\n\t{\r\n\t\tif (target - val1 >= val2 - target)\r\n\t\treturn val2;       \r\n\t\telse\r\n\t\treturn val1;       \r\n\t}\r\n    static void ruffleSort(long[] a) {\r\n\t\tint n=a.length;\r\n\t\tRandom r=new Random();\r\n\t\tfor (int i=0; i<a.length; i++) {\r\n\t\t\tlong oi=r.nextInt(n), temp=a[i];\r\n\t\t\ta[i]=a[(int)oi];\r\n\t\t\ta[(int)oi]=temp;\r\n\t\t}\r\n\t\tArrays.sort(a);\r\n\t}\r\n    static void ruffleSort(int[] a){\r\n\t\tint n=a.length;\r\n\t\tRandom r=new Random();\r\n\t\tfor (int i=0; i<a.length; i++) {\r\n\t\t\tint oi=r.nextInt(n), temp=a[i];\r\n\t\t\ta[i]=a[oi];\r\n\t\t\ta[oi]=temp;\r\n\t\t}\r\n\t\tArrays.sort(a);\r\n    }\r\n    int ceilIndex(int input[], int T[], int end, int s){\r\n        int start = 0;\r\n        int middle;\r\n        int len = end;\r\n        while(start <= end){\r\n            middle = (start + end)/2;\r\n            if(middle < len && input[T[middle]] < s && s <= input[T[middle+1]]){\r\n                return middle+1;\r\n            }else if(input[T[middle]] < s){\r\n                start = middle+1;\r\n            }else{\r\n                end = middle-1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    static long gcd(long a, long b)\r\n    {\r\n        if (a == 0)\r\n            return b; \r\n        return gcd(b % a, a); \r\n    }\r\n    static int gcd(int a, int b)\r\n    {\r\n        if (a == 0)\r\n            return b; \r\n        return gcd(b % a, a); \r\n    }\r\n    static long lcm(long a,long b)\r\n    {\r\n        return (a / gcd(a, b)) * b;\r\n    }\r\n    public static int[] reverse(int a[], int left, int right)\r\n    {\r\n \r\n        // Reverse the sub-array\r\n        while (left < right) {\r\n            int temp = a[left];\r\n            a[left++] = a[right];\r\n            a[right--] = temp;\r\n        }\r\n        return a;\r\n    }\r\n    static int  lowerLimitBinarySearch(ArrayList<Long> v,long k) {\r\n    \t\tint n =v.size();\r\n    \t\tint first = 0,second = n;\r\n    \t\twhile(first <second) {\r\n    \t\t\tint mid = first + (second-first)/2;\r\n    \t\t\tif(v.get(mid) > k) {\r\n    \t\t\t\tsecond = mid;\r\n    \t\t\t}else {\r\n    \t\t\t\tfirst = mid+1;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\t\r\n    \t\t if(first < n && v.get(first) < k) {\r\n    \t\t\t first++;\r\n    \t\t    }\r\n    \t\treturn first; //1 index\r\n    }\r\n    static class FastReader {\r\n        public BufferedReader reader;\r\n        public StringTokenizer tokenizer;\r\n        public FastReader(InputStream stream) {\r\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\r\n            tokenizer = null;\r\n        }\r\n        public String next() {\r\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                try {\r\n                    tokenizer = new StringTokenizer(reader.readLine());\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            return tokenizer.nextToken();\r\n        }\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n        public long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n        public String nextLine() {\r\n            String str = \"\";\r\n            try {\r\n                str = reader.readLine();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n    }\r\n//    *******----segement tree implement---*****\r\n//    -------------START--------------------------\r\n    void buildTree (int[] arr,int[] tree,int start,int end,int treeNode)\r\n    {\r\n    \tif(start==end)\r\n    \t{\r\n    \t\ttree[treeNode]=arr[start];\r\n    \t\treturn;\r\n    \t}\r\n    \tbuildTree(arr,tree,start,end,2*treeNode);\r\n    \tbuildTree(arr,tree,start,end,2*treeNode+1);\r\n    \ttree[treeNode]=tree[treeNode*2]+tree[2*treeNode+1];\r\n    }\r\n    void updateTree(int[] arr,int[] tree,int start,int end,int treeNode,int idx,int value)\r\n    {\r\n    \tif(start==end)\r\n    \t{\r\n    \t\tarr[idx]=value;\r\n    \t\ttree[treeNode]=value;\r\n    \t\treturn;\r\n    \t}\r\n    \tint mid=(start+end)/2;\r\n    \tif(idx>mid)\r\n    \t{\r\n    \t\tupdateTree(arr,tree,mid+1,end,2*treeNode+1,idx,value);\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tupdateTree(arr,tree,start,mid,2*treeNode,idx,value);\r\n    \t}\r\n    \ttree[treeNode]=tree[2*treeNode]+tree[2*treeNode+1];\r\n    }\r\n    \t\r\n//    \tdisjoint set implementation --start\r\n    static void makeSet(int n)\r\n    {\r\n    \tparent=new int[n];\r\n    \trank=new int[n];\r\n    \tfor(int i=0;i<n;i++)\r\n    \t{\r\n    \t\tparent[i]=i;\r\n    \t\trank[i]=0;\r\n    \t}\r\n    }\r\n    static void union(int u,int v)\r\n    {\r\n    \tu=findpar(u);\r\n    \tv=findpar(v);\r\n    \tif(rank[u]<rank[v])parent[u]=v;\r\n    \telse if(rank[v]<rank[u])parent[v]=u;\r\n    \telse \r\n    \t{\r\n    \t\tparent[v]=u;\r\n    \t\trank[u]++;\r\n    \t}\r\n    }\r\n    \r\n\tprivate static int findpar(int node)\r\n\t{\t\r\n\t\tif(node==parent[node])return node;\r\n\t\treturn parent[node]=findpar(parent[node]);\r\n\t}\r\n\tstatic int parent[];\r\n    static int rank[];\r\n//    \t*************end\r\n    \r\n    \r\n    \r\n    static void presumbit(int[][]prebitsum) {\r\n    \tfor(int i=1;i<=200000;i++) {\r\n\t\t\tint z=i;\r\n\t\t\tint j=0;\r\n\t\t\twhile(z>0) {\r\n\t\t\t\tif((z&1)==1) {\r\n\t\t\t\t\tprebitsum[i][j]+=(prebitsum[i-1][j]+1);\r\n\t\t\t\t}else {\r\n\t\t\t\t\tprebitsum[i][j]=prebitsum[i-1][j];\r\n\t\t\t\t}\r\n\t\t\t\tz=z>>1;\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n    \r\n    static void countOfSetBit(long[]a) {\r\n    \tfor(int j=30;j>=0;j--) {\r\n\t\t\tint cnt=0;\r\n\t\t\tfor(long i:a) {\r\n\t\t\t\tif((i&1<<j)==1)cnt++;\r\n\t\t\t}\r\n//\t\t\tprinting the current no set bit in all array element\r\n\t\t\tSystem.out.println(cnt);\r\n\t\t}\r\n    }\r\n    public static  int[] sort(int[] arr) {\r\n    \tArrayList<Integer> al = new ArrayList<>();\r\n    \tfor(int i=0;i<arr.length;i++) al.add(arr[i]);\r\n    \tCollections.sort(al);\r\n    \tfor(int i=0;i<arr.length;i++) arr[i]=al.get(i);\r\n    \treturn arr;\r\n    }\r\n    static ArrayList<String>powof2s;\r\n    static void powof2S() {\r\n    \tlong i=1;\r\n    \twhile(i<(long)2e18) {\r\n    \t\tpowof2s.add(String.valueOf(i));\r\n    \t\ti*=2;\r\n    \t\t\r\n    \t}\r\n    }\r\n    \r\n    static boolean coprime(int a, long l){\r\n        return (gcd(a, l) == 1);\r\n    }\r\n    \r\n    static int[][] dirs8 = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\r\n    static int[][] dirs4 = {{1,0},{-1,0},{0,1},{0,-1}};\r\n    static Long MOD=(long) (1e9+7);\r\n    static int prebitsum[][];\r\n    static ArrayList<Integer>arr;\r\n    static boolean[] vis;\r\n    static ArrayList<ArrayList<Integer>>adj;\r\n    static FastReader s = new FastReader(System.in);\r\n    static PrintWriter out = new PrintWriter(System.out, false);\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n//    \tsieve();\r\n//    \tcomputeFact((int)1e7+1,MOD);\r\n//    \tprebitsum=new int[2147483648][31];\r\n//    \tpresumbit(prebitsum);\r\n//    \tpowof2S();\r\n    \t\r\n//        int tt = s.nextInt();\r\n//        while(tt-->0) {\r\n        \tsolver();\r\n//        }\r\n\t}\r\n\t\r\n\tprivate static void solver() {\r\n\t\tString str=s.next();\r\n\t\tchar[] ch=str.toCharArray();\r\n\t\tint n=ch.length;\r\n\t\tlong a=s.nextLong();\r\n\t\tlong b=s.nextLong();\r\n\t\tlong[]pow10=new long[n];\r\n\t\tpow10[0]=1;\r\n\t\tfor(int i=1;i<n;i++)pow10[i]=(pow10[i-1]*10);\r\n\t\tlong prefix[]=new long[n];\r\n        long suffix[]=new long[n];\r\n        prefix[0]=(ch[0]-48)%a;\r\n        for(int i=1;i<n;i++){\r\n            prefix[i]=(prefix[i-1]*10+(ch[i]-48))%a;\r\n        }\r\n        suffix[n-1]=(ch[n-1]-48)%b;\r\n        for(int i=n-2;i>=0;i--){\r\n            suffix[i]=(suffix[i+1]+(ch[i]-48)*pow10[n-1-i])%b;\r\n        }\r\n\t\tfor(int i=0;i<n;i++) {\r\n\t\t\tif(prefix[i]==0&&suffix[i+1]==0&&ch[i+1]!='0') {\r\n\t\t\t\tSystem.out.println(\"YES\");\r\n\t\t\t\tSystem.out.println(str.substring(0,i+1));\r\n\t\t\t\tSystem.out.println(str.substring(i+1));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"NO\");\r\n\t}\r\n\t\r\n\tprivate static ArrayList<Long> get_divisor(long x) {\r\n\t\tArrayList<Long>a=new ArrayList<Long>();\r\n\t\tfor(long i=1;i*i<=x;i++) {\r\n\t\t\tif(x%i==0) {\r\n\t\t\t\ta.add((long) i);\r\n\t\t\t\tif(x/i!=i)a.add(x/i);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn a;\r\n\t}\r\n\tstatic long[] sieve;\r\n    static long[] smallestPrime;\r\n \tpublic static void sieve()\r\n    {\r\n        int n=4000000+1;\r\n    \tsieve=new long[n];\r\n    \tsmallestPrime=new long[n];\r\n    \tsieve[0]=1;\r\n    \tsieve[1]=1;\r\n    \tfor(int i=2;i<n;i++){\r\n    \t\tsieve[i]=i;\r\n    \t\tsmallestPrime[i]=i;\r\n    \t}\r\n    \tfor(int i=2;i*i<n;i++){\r\n    \t\tif(sieve[i]==i){\r\n\t    \t\tfor(int j=i*i;j<n;j+=i){\r\n\t    \t\t\tif(sieve[j]==j)sieve[j]=1;\r\n\t    \t\t\tif(smallestPrime[j]==j||smallestPrime[j]>i)smallestPrime[j]=i;\r\n\t    \t\t}\r\n    \t\t}\r\n    \t}\r\n    }\r\n\t\r\n \tstatic long nCr(long n,long r,long MOD) {\r\n \t\tif(n<r)return 0;\r\n \t\tif(r==0)return 1;\r\n \t\treturn fact[(int) n]*mod_inv(fact[(int) r],MOD)%MOD*mod_inv(fact[(int) (n-r)],MOD)%MOD;\r\n \t}\r\n \tstatic long[]fact;\r\n \tstatic void computeFact(long n,long MOD) {\r\n \t\tfact=new long[(int)n+1];\r\n \t\tfact[0]=1;\r\n \t\tfor(int i=1;i<=n;i++)fact[i]=(fact[i-1]*i%MOD)%MOD;\r\n \t}\r\n \tstatic long bin_expo(long a,long b,long MOD) {\r\n\t    if(b == 0){\r\n\t        return 1;\r\n\t    }\r\n\t    long ans = bin_expo(a,b/2,MOD);\r\n\t    ans = (ans*ans)%MOD;\r\n\t    if(b % 2!=0){\r\n\t        ans = (ans*a)%MOD;\r\n\t    }\r\n\t    return ans%MOD;\r\n\t}\r\n\tstatic long mod_inv(long n,long p) {\r\n\t\treturn bin_expo(n,p-2,p);\r\n\t}\r\n\tpublic static int searchindex(long arr[], long t){\r\n        int index = Arrays.binarySearch(arr, t);\r\n        return (index < 0) ? -1 : index;\r\n    }\r\n\tstatic void pc2d(char[][]a) {\r\n    \tint n=a.length;\r\n    \tint m=a[0].length;\r\n    \tfor(int i=0;i<n;i++) {\r\n    \t\tfor(int j=0;j<m;j++) {\r\n    \t\t\tSystem.out.print(a[i][j]+\" \");\r\n    \t\t}\r\n    \t\tSystem.out.println();\r\n    \t}\r\n    }\r\n    static void pi2d(long[][] d) {\r\n    \tint n=d.length;\r\n    \tint m=d[0].length;\r\n    \tfor(int i=0;i<n;i++) {\r\n    \t\tfor(int j=0;j<m;j++) {\r\n    \t\t\tSystem.out.print(d[i][j]+\" \");\r\n    \t\t}\r\n    \t\tSystem.out.println();\r\n    \t}\r\n    }\r\n\tstatic void DFSUtil(int v, boolean[] vis)\r\n\t{\r\n\t   vis[v] = true;\r\n\t   Iterator<Integer> it = adj.get(v).iterator();\r\n\t\r\n\t   while (it.hasNext()) {\r\n\t       int n = it.next();\r\n\t       if (!vis[n])\r\n\t           DFSUtil(n, vis);\r\n\t   }\r\n\t}\r\n    static long DFS(int n)\r\n    {\r\n        vis = new boolean[n+1];\r\n        long cnt=0;\r\n        for (int i = 1; i <= n; i++) {\r\n            if (!vis[i]) {\r\n                DFSUtil(i, vis);\r\n                cnt++;\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n\tpublic static String revStr(String str){\r\n        String input = str;\r\n        StringBuilder input1 = new StringBuilder();\r\n        input1.append(input);\r\n        input1.reverse();\r\n        return input1.toString();\r\n    }\r\n\t\r\n    static boolean issafe(int i, int j, int r,int c, char ch)\r\n    {\r\n\t\tif (i < 0 || j < 0 || i >= r || j >= c|| ch!= '1')return false;\r\n\t\telse return true;\r\n    }\r\n    static long power(long a, long b)\r\n    {\r\n    \ta %=MOD;\r\n\t    long out = 1;\r\n\t    while (b > 0) {\r\n\t        if((b&1)!=0)out = out * a % MOD;\r\n\t        a = a * a % MOD;\r\n\t        b >>= 1;\r\n\t\t\ta*=a;\r\n\t    }\r\n\t    return out;\r\n    }\r\n\r\n}\r\nclass decrease implements Comparator<Long> {\r\n    // Used for sorting in ascending order of\r\n    // roll number\r\n    public int compare(long a, long b)\r\n    {\r\n        return (int) (b - a);\r\n    }\r\n\r\n\t@Override\r\n\tpublic int compare(Long o1, Long o2) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\treturn (int) (o2-o1);\r\n\t}\r\n}\r\n\r\nclass pair{\r\n\tdouble x;\r\n\tdouble y;\r\n//\tpublic pair(long x,long y) {\r\n//\t\tthis.x=x;\r\n//\t\tthis.y=y;\r\n//\t}\r\n\tpublic pair(double x,double y) {\r\n\t\tthis.x=x;\r\n\t\tthis.y=y;\r\n\t}\r\n}"
}