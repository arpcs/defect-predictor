{
    "id": 202268453,
    "contestId": 1706,
    "creationTimeSeconds": 1681576730,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1706,
        "index": "B",
        "name": "Making Towers",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1100,
        "tags": [
            "dp",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1706,
        "members": [
            {
                "handle": "chemecocs"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1658154900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 19,
    "timeConsumedMillis": 108,
    "memoryConsumedBytes": 6860800,
    "source": "#include<bits/stdc++.h>\r\n\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double ld;\r\ntypedef string str;\r\n\r\ntypedef pair<int, int>      pi;\r\ntypedef pair<ll, ll>        pl;\r\ntypedef pair<ull, ull>     pul;\r\ntypedef pair<ld, ld>       pld;\r\ntypedef pair<double,double> pd;\r\n\r\ntypedef vector<int>    vi;\r\ntypedef vector<ll>     vl;\r\ntypedef vector<ull>   vul;\r\ntypedef vector<bool>   vb;\r\ntypedef vector<double> vd;\r\ntypedef vector<ld>    vld;\r\ntypedef vector<str>    vs;\r\n\r\ntypedef vector<pi>    vpi;\r\ntypedef vector<pl>    vpl;\r\ntypedef vector<pul>  vpul;\r\ntypedef vector<pld>  vpld;\r\ntypedef vector<pd>    vpd;\r\n\r\ntypedef vector<vi>    vvi;\r\ntypedef vector<vl>    vvl; \r\n\r\ntemplate<class T>\r\nusing indexed_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ;\r\n//indexed_set<int> s;\r\n//cout<<(*s.find_by_order(2)); ->Gives element at 2nd index(0 based indexing)\r\n//cout<<s.order_of_key(5); ->gives number of elements strictly less than 5\r\n//We can also use all the methods provided by a normal set. Ex. s.lower_bound(val)\r\n//Works with dbg too!! (yay :P) \r\n\r\n#define mp  make_pair\r\n#define pb  push_back\r\n#define F   first\r\n#define S   second\r\n#define lb  lower_bound\r\n#define ub  upper_bound\r\n#define ins insert\r\n#define rsz resize\r\n\r\n#define sz(x) (int)x.size()\r\n#define beg(x) x.begin()\r\n#define en(x) x.end()\r\n#define all(x) beg(x), en(x)\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define sortall(x) sort(all(x))\r\n\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define rep(a) F0R(_,a)\r\n#define each(a,x) for (auto& a: x)\r\n#define tr(it, x) for(auto it = beg(x); it != en(x); ++it)\r\n\r\n#define clr(x,i) memset(x, i, sizeof(x))\r\n\r\n// ************************DEBUG START********************************\r\n#ifdef chemecocs\r\n// #define cerr cout  // if you want to print to stdout, uncomment this\r\ntemplate <class T1, class T2>\r\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\r\n  return os << '{' << p.first << \", \" << p.second << '}';\r\n}\r\n\r\ntemplate <class T, class = decay_t<decltype(*begin(declval<T>()))>,\r\n          class = enable_if_t<!is_same<T, string>::value>>\r\nostream &operator<<(ostream &os, const T &c) {\r\n  os << '[';\r\n  tr(it,c)\r\n    os << &\", \"[2 * (it == beg(c))] << *it;\r\n  return os << ']';\r\n}\r\n//support up to 5 args\r\n#define _NTH_ARG(_1, _2, _3, _4, _5, _6, N, ...) N\r\n#define _FE_0(_CALL, ...)\r\n#define _FE_1(_CALL, x) _CALL(x)\r\n#define _FE_2(_CALL, x, ...) _CALL(x) _FE_1(_CALL, __VA_ARGS__)\r\n#define _FE_3(_CALL, x, ...) _CALL(x) _FE_2(_CALL, __VA_ARGS__)\r\n#define _FE_4(_CALL, x, ...) _CALL(x) _FE_3(_CALL, __VA_ARGS__)\r\n#define _FE_5(_CALL, x, ...) _CALL(x) _FE_4(_CALL, __VA_ARGS__)\r\n#define FOR_EACH_MACRO(MACRO, ...)                                             \\\r\n  _NTH_ARG(dummy, ##__VA_ARGS__, _FE_5, _FE_4, _FE_3, _FE_2, _FE_1, _FE_0)     \\\r\n  (MACRO, ##__VA_ARGS__)\r\n//Change output format here\r\n#define out(x) #x \" = \" << x << \"; \"\r\n#define dbg(...)                                                              \\\r\n  cerr << __func__ << \":\" << __LINE__ << \": \" FOR_EACH_MACRO(out, __VA_ARGS__) << \"\\n\"\r\n#define dnl(x)                                                                \\\r\n  cerr <<\"----------- Test Case # \" << x << \" -----------\\n\"\r\n#else\r\n#define dbg(...)\r\n#define dnl(x)\r\n#endif\r\n// ************************DEBUG END**********************************\r\n\r\n// ************************MATH START*********************************\r\nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\r\nll expo(ll a, ll b, ll mod) {a %= mod; ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\r\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an array of size3. returns solution of equation ax + by = gcd(a,b). v[0] = x, v[1] = y, v[2] = gcd(a,b)\r\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\r\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\r\nbool revsort(ll a, ll b) {return a > b;}\r\nvoid swap(int &x, int &y) {int temp = x; x = y; y = temp;}\r\nll combination(ll n, ll r, ll m, vector<ll>& fact, vector<ll>& ifact) {ll val1 = fact[n]; ll val2 = ifact[n - r]; ll val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}\r\nvoid google(int t) {cout << \"Case #\" << t << \": \";}\r\nvector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\r\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\r\nll ceil_div(ll a, ll b) {return (a+b-1)/b;}\r\nll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))\r\n// ************************MATH END**********************************\r\n \r\nvoid ipgraph(int n, int m);\r\nvoid dfs(int u, int par);\r\n\r\nconst int MOD = 1'000'000'007;\r\nconst int MOD2 = 998244353;\r\nconst int INF = 2e9;\r\nconst ll INFL = 2e18;\r\nconst int N = 3e5, M = N;\r\n//=======================\r\n\r\nvvi g(N);\r\nvi v(N);\r\n\r\nvoid preSolve(){\r\n\r\n}\r\n\r\nvoid solve() {\r\n  int n; cin>>n;\r\n  g.assign(n+1, vi());\r\n  F0R(i,n){\r\n    int x; cin>>x;\r\n    g[x].pb(i);\r\n  }\r\n  FOR(k,1,n+1){\r\n    int mx = 0;\r\n    if(!g[k].empty()) mx++;\r\n    FOR(i,1,sz(g[k])){\r\n      if((g[k][i] - g[k][i-1]) % 2 == 1){\r\n        mx++;\r\n      }\r\n    }\r\n    cout<<mx<<\" \";\r\n  }\r\n  cout<<\"\\n\";\r\n}\r\n\r\ninline namespace FileIO {\r\n  void setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\r\n  void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\n  void setErr()      { freopen(\"Error.out\",\"w\",stderr); }\r\n  void setIO(str s = \"\") {\r\n    cin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\r\n    // cin.exceptions(cin.failbit);\r\n    // throws exception when do smth illegal\r\n    // ex. try to read letter into int\r\n    if (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\r\n    #ifdef chemecocs\r\n      setErr();\r\n    #endif\r\n  }\r\n}\r\n\r\nint main() {\r\n    setIO();\r\n    int t = 1;\r\n    cin >> t;\r\n    cout<<fixed<<setprecision(10);\r\n    preSolve();\r\n    F0R(i,t) {\r\n      dnl(i+1);\r\n      solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid ipgraph(int n, int m){\r\n  int i, u, v;\r\n  while(m--){\r\n    cin>>u>>v;\r\n    u--, v--;\r\n    g[u].pb(v);\r\n    g[v].pb(u);\r\n  }\r\n}\r\n\r\nvoid dfs(int u, int par){\r\n  for(int v:g[u]){\r\n    if (v == par) continue;\r\n    dfs(v, u);\r\n  }\r\n}"
}