{
    "id": 170902964,
    "contestId": 1182,
    "creationTimeSeconds": 1662341746,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1182,
        "index": "D",
        "name": "Complete Mirror",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2400,
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "hashing",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 1182,
        "members": [
            {
                "handle": "A_king"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1560258300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 46,
    "timeConsumedMillis": 202,
    "memoryConsumedBytes": 23040000,
    "source": "/*\r\n  Freedom of action\r\n  If there is no soul, there is still a body\r\n*/\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <ext/pb_ds/trie_policy.hpp>\r\n#include <ext/pb_ds/priority_queue.hpp>\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\nnamespace Template {\r\n    #define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\r\n    #define FREOPEN freopen(\"in.in\", \"r\", stdin);freopen(\"out.out\", \"w\", stdout)\r\n    #ifdef A_king\r\n    #include \"E:\\VS\\PROJECT\\Another\\debug.h\"\r\n    #else\r\n    #define out(x...) void(0);\r\n    #endif\r\n    #define endl '\\n'\r\n    #define pb push_back\r\n    #define pf push_front\r\n    #define len(container) (int)(container).size()\r\n    #define all(container) (container).begin(), (container).end()\r\n    #define all1(container) (container).begin() + 1, (container).end()\r\n    #define rall(container) (container).rbegin(), (container).rend()\r\n    #define rall1(container) (container).rbegin(), (container).rend() - 1\r\n    #define YES cout << \"YES\" << endl\r\n    #define Yes cout << \"Yes\" << endl\r\n    #define yes cout << \"yes\" << endl\r\n    #define NO cout << \"NO\" << endl\r\n    #define No cout << \"No\" << endl\r\n    #define no cout << \"no\" << endl\r\n    const int mod = 998244353;const double PI = acos(-1.0);const double eps = 1e-8;const int inf = 0x3f3f3f3f;const long long INF = 0x3f3f3f3f3f3f3f3f;\r\n    template<typename T> T ksm(T a, long long b) {T res = 1;while (b) {if (b & 1) res *= a;a *= a;b >>= 1;}return res;}\r\n    template<const int MOD = mod> struct Modular {\r\n        int x;\r\n        int Mod(int x) {if (x < 0) x += MOD;if (x >= MOD) x -= MOD;return x;}\r\n        Modular(int x = 0) : x(Mod(x)) {}\r\n        Modular(long long x) : x(Mod(x % MOD)) {}\r\n        int val() const {return x;}\r\n        Modular operator -() const {Modular T(MOD - x);return T;}\r\n        Modular inv() const {assert(x != 0);return ksm(*this, MOD - 2);}\r\n        Modular inverse() const {assert(x != 0);long long a = x, b = MOD, u = 1, v = 0;while (b) {long long t = a / b;a -= t * b;a ^= b ^= a ^= b;u -= t * v;u ^= v ^= u ^= v;}if (u < 0) u += MOD;return u;}\r\n        Modular &operator *= (const Modular &T) {x = (long long)(x) * T.x % MOD;return *this;}\r\n        Modular &operator += (const Modular &T) {x = Mod(x + T.x);return *this;}\r\n        Modular &operator -= (const Modular &T) {x = Mod(x - T.x);return *this;}\r\n        Modular &operator /= (const Modular &T) {return *this *= T.inverse();}\r\n        Modular &operator ++ (int) {return *this = *this + 1;}\r\n        Modular &operator -- (int) {return *this = *this - 1;}\r\n        bool operator == (const Modular &T) const {return x == T.x;}\r\n        bool operator != (const Modular &T) const {return x != T.x;}\r\n        bool operator <= (const Modular &T) const {return x <= T.x;}\r\n        bool operator >= (const Modular &T) const {return x >= T.x;}\r\n        bool operator < (const Modular &T) const {return x < T.x;}\r\n        bool operator > (const Modular &T) const {return x > T.x;}\r\n        friend Modular operator * (const Modular &T, const Modular &Y) {Modular res = T;res *= Y;return res;}\r\n        friend Modular operator + (const Modular &T, const Modular &Y) {Modular res = T;res += Y;return res;}\r\n        friend Modular operator - (const Modular &T, const Modular &Y) {Modular res = T;res -= Y;return res;}\r\n        friend Modular operator / (const Modular &T, const Modular &Y) {Modular res = T;res /= Y;return res;}\r\n        friend istream &operator >> (istream &in, Modular& T) {long long val;in >> val;T = val;return in;}\r\n        friend ostream &operator << (ostream &os, const Modular& T) {return os << T.x;}\r\n    };\r\n    typedef trie<string, null_type, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update> TRIE;\r\n    template<typename T> using RB = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n    template<typename T> using Q = __gnu_pbds::priority_queue<T, greater<T>, pairing_heap_tag>;// point_iterator\r\n    typedef long long ll;typedef unsigned long long ull;typedef pair<double, double> PDD;typedef pair<ll, ll> PLL;typedef pair<int, int> PII;typedef pair<int, PII> PIII;\r\n    template<typename T> using vc = vector<T>;template<typename T> using vvc = vc<vc<T>>;\r\n    template<typename T> inline T Abs(T a) {if (a < 0) a = -1 * a;return a;}\r\n    template<typename T> T Gcd(const T &a, const T &b) {return b ? Gcd(b, a % b) : a;}\r\n    template<typename T> T Lcm(const T &a, const T &b) {return a / Gcd(a, b) * b;}\r\n    template<typename T> inline void Swap(T &a, T &b) {a ^= b ^= a ^= b;}\r\n    template<typename T> inline bool Max(T &a, const T &b) {return a < b ? a = b, 1 : 0;}template<typename T> inline void Max(T &a, const T &b, const T &c){Max(a, b);Max(a, c);}\r\n    template<typename T> inline bool Min(T &a, const T &b) {return a > b ? a = b, 1 : 0;}template<typename T> inline void Min(T &a, const T &b, const T &c){Min(a, b);Min(a, c);}\r\n    template<typename T> inline T Sum(const vector<T> &x, int pos = 0) {return accumulate(x.begin() + pos, x.end(), 0ll);}\r\n    template<typename T> inline T Maxe(const vector<T> &x, int pos = 0) {return *max_element(x.begin() + pos, x.end());}template<typename T> inline T Maxi(vector<T> x, int pos = 0) {return max_element(x.begin() + pos, x.end()) - x.begin();}\r\n    template<typename T> inline T Mine(const vector<T> &x, int pos = 0) {return *min_element(x.begin() + pos, x.end());}template<typename T> inline T Mini(vector<T> x, int pos = 0) {return min_element(x.begin() + pos, x.end()) - x.begin();}\r\n    template<typename T> inline void Disperse(vc<T> &v) {sort(all(v));v.erase(unique(all(v)), v.end());}\r\n    template<typename T, typename U> istream &operator >> (istream &in, pair<T, U> &Arg) {return in >> Arg.first >> Arg.second;}\r\n    template<typename T> istream &operator >> (istream &in, vc<T> &v) {int n = len(v) - 1;for (int i = 1;i <= n;++ i) in >> v[i];return in;}\r\n    template<typename T> istream &operator >> (istream &in, vvc<T> &v) {int n = len(v) - 1, m = len(v[0]) - 1;for (int i = 1;i <= n;++ i) for (int j = 1;j <= m;++ j) in >> v[i][j];return in;}\r\n    template<typename T> void pv(T a, T b, bool flag = true) {for (auto i = a;i != b;++ i) {if (i == a) cout << *i;else cout << \" \" << *i;}if (flag) cout << endl;}\r\n    inline int popcount(const long long &x) {return __builtin_popcountll(x);}inline int clz(const long long &x) {return __builtin_clzll(x);}inline int parity(const long long &x) {return __builtin_parityll(x);}\r\n}using namespace Template;\r\nusing Z = Modular<>;// 998244353 1000000007\r\nconst int N = 1e6 + 10, M = 2e6 + 10;\r\nbool __init_solve__ = [](){return false;}();\r\n\r\n\r\n// #define int long long\r\nbool multicase = !true;\r\nvoid solve(int group_Id) {\r\n    int n;\r\n    cin >> n;\r\n    vvc<int> g(n + 1);\r\n    vc<int> du(n + 1);\r\n    for (int i = 1;i < n;i ++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        g[u].pb(v);\r\n        g[v].pb(u);\r\n        du[u] ++, du[v] ++;\r\n    }\r\n    for (int i = 1;i <= n;i ++) {\r\n        out(i, len(g[i]), du[i])\r\n    }\r\n\r\n    vc<int> sz(n + 1), dist(n + 1);\r\n    int max_sz = inf, rt, rt2 = 0, len_rt2, tmp_rt;\r\n    function<void(int, int)> dfs_rt = [&](int u, int fa) {\r\n        sz[u] = 1;\r\n        int now = 0;\r\n        for (auto v : g[u]) {\r\n            if (v == fa) continue;\r\n            dfs_rt(v, u);\r\n            sz[u] += sz[v];\r\n            Max(now, sz[v]);\r\n        }\r\n        Max(now, n - sz[u]);\r\n        if (Min(max_sz, now)) {\r\n            rt = u;\r\n        }\r\n    };\r\n    function<void(int, int)> dfs_dist = [&](int u, int fa) {\r\n        for (auto v : g[u]) {\r\n            if (v == fa) continue;\r\n            dist[v] = dist[u] + 1;\r\n            dfs_dist(v, u);\r\n        }\r\n    };\r\n    auto&& check = [&](int now_rt) -> bool {\r\n        dist[now_rt] = 0;\r\n        dfs_dist(now_rt, -1);\r\n        map<int, int> mp;\r\n        for (int i = 1;i <= n;i ++) {\r\n            out(i, dist[i], len(g[i]))\r\n            if (!mp.count(dist[i])) mp[dist[i]] = len(g[i]);\r\n            else if (mp[dist[i]] != len(g[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    function<int(int, int)> dfs_line = [&](int u, int fa) {\r\n        if (du[u] > 2) return 0;\r\n        if (du[u] == 1) {tmp_rt = u;return 1;}\r\n        for (auto v : g[u]) {\r\n            if (v == fa) continue;\r\n            int t = dfs_line(v, u);\r\n            if (!t) return 0;\r\n            else return t + 1;\r\n        }\r\n    };\r\n\r\n    dfs_rt(1, -1);\r\n    out(rt)\r\n    if (check(rt)) {\r\n        cout << rt << endl;\r\n        return ;\r\n    }\r\n\r\n    for (auto v : g[rt]) {\r\n        int t = dfs_line(v, rt);\r\n        if (!t) continue;\r\n        if (rt2 and t != len_rt2) {\r\n            if (check(tmp_rt)) {\r\n                cout << tmp_rt << endl;\r\n                return ;\r\n            }\r\n            break;\r\n        }\r\n        if (!rt2) {\r\n            rt2 = tmp_rt;\r\n            len_rt2 = t;\r\n            if (check(rt2)) {\r\n                cout << rt2 << endl;\r\n                return ;\r\n            }\r\n        }\r\n    }\r\n    \r\n    cout << -1 << endl;\r\n\r\n}\r\n\r\nsigned main(signed argc, char const *argv[])\r\n{\r\n#ifdef A_king\r\n    FREOPEN;\r\n    auto clock_start = chrono::high_resolution_clock::now();\r\n    cerr << __FILE__ << \", \" << __DATE__ << \", \" << __TIME__ << endl;\r\n#endif\r\n    IOS;\r\n    cout << fixed << setprecision(16);\r\n    int T_case = 1;\r\n    if (multicase) cin >> T_case;\r\n    for (int i = 1;i <= T_case;i ++) solve(i);\r\n#ifdef A_king\r\n    auto clock_end = chrono::high_resolution_clock::now();\r\n    cerr << \"Run Time: \" << chrono::duration_cast<chrono::milliseconds>(clock_end - clock_start).count() << \" ms\" << endl;\r\n#endif\r\n    return 0;\r\n}"
}