{
    "id": 184352556,
    "contestId": 771,
    "creationTimeSeconds": 1670515172,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 771,
        "index": "B",
        "name": "Bear and Different Names",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1500,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 771,
        "members": [
            {
                "handle": "vjudge2"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1489851300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 59,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 18022400,
    "source": "#include<bits/stdc++.h>\nusing namespace std;\n\n/******* PBDS Headers *********/\n// #include<ext/pb_ds/tree_policy.hpp>\n// #include<ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n\nusing ll  = long long;\nusing vl  = vector<ll>;\nusing vi  = vector<int>;\nusing pll = pair<ll, ll>;\nusing ii  = pair<int, int>;\nusing tpl = tuple<int,int,int>;\nusing ull = unsigned long long;\n\n#define IL inline\n#define TP template<class T>\n#define UP template<class T, class U>\n#define HP template<class H, class...T>\n\n/******* GCC Optimizations *********/\n#pragma GCC target(\"avx,avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n\n/******* PBDS *********/\n// #define AT find_by_order // return iterator of index\n// #define POS order_of_key // return position of value\n// #define ERS(st,x) (st).erase((st).AT((st).POS((x)))) // Erase x value\n// TP struct pbds_cmp{bool operator()(const T &a, const T &b)const{return a < b;}};\n// UP using oset = tree<T, null_type, U, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define gp ' '\n#define nl '\\n'\n#define ff first\n#define se second\n#define pf printf\n#define pc putchar\n#define gc getchar()\n#define pb push_back\n#define LB lower_bound\n#define UB upper_bound\n#define eb emplace_back\n#define SQ(x) ((x)*1LL*(x))\n#define CB(x) ((x)*SQ((x)))\n#define amax(a,b) a=max(a,b)\n#define amin(a,b) a=min(a,b)\n#define FLUSH fflush(stdout)\n#define all(x) (x).begin(),(x).end()\n#define Clr(x) memset((x),  0, sizeof((x)))\n#define Set(x) memset((x), -1, sizeof((x)))\n#define For(i,a,b)  for(int i=a;  i<b; i++)\n#define Forn(i,b,a) for(int i=b; i>=a; i--)\n\nIL void write(char*); TP IL void write(T); IL bool read(char&); IL void write(const char*);\nTP IL bool read(T&); IL bool read(char*); IL void write(char); HP IL void write(H,T...); HP IL bool read(H&,T&...);\n\nTP void in(T *a, size_t n){For(i,0,n) read(a[i]);}\nTP void in(vector<T> &a, size_t n){For(i,0,n) read(a[i]);}\nTP void out(T *a, size_t n){For(i,0,n){if(i)pc(gp);write(a[i]);}puts(\"\");}\nTP void out(vector<T> &a, size_t n){For(i,0,n){if(i)pc(gp);write(a[i]);}puts(\"\");}\n\nconst int INF = 0x3f3f3f3f;\nconst ll INFL = 0x7f7f7f7f7f7f7f;\nconst double EPS = 1e-9, PI = acos(-1);\nconst int MOD = 1e9+7, MODF = 998244353;\n\n/** Necessary Function **/\nTP IL T power(T v, T p, T m=MOD) {\n    v %= m; T r = 1; while (p > 0) {\n        if (p & 0x1) r = (r*1LL*v)%m;\n        v = (v*1LL*v)%m; p >>= 1;\n    }return r;\n}\n\nTP IL T gcd(T a, T b){return (b?gcd(b,a%b):a);}\nTP IL T lcm(T a, T b){return (a / gcd(a,b) * b);}\nTP IL T lowestSetBit(T x){return (x & (-x));}\nTP IL void setBit(T &x, int p){x |= (1LL<<p);}\nTP IL T highestSetBit(T x){return (1LL<<(__lg(x)));}\nTP IL bool isSet(T x, int p){return x & (1<<p);}\nTP IL void toggleBit(T &x, int p){x ^= (1LL<<p);}\nTP IL void unsetBit(T &x, int p){x &= (~(1LL<<p));}\nIL bool isPowerOfTwo(ll x){return x && (!(x & (x-1)));}\nIL int numberOfSetBit(ll x){return __builtin_popcountll(x);}\n\n/** Mod - Int **/\ntemplate <const int32_t MOD> struct modint{\n    #define IM inline modint<MOD>\n    #define TPT template<typename T>\n    int32_t value; modint() = default;\n    TPT modint(T value_) : value(value_%MOD) {}\n    IM operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }\n    IM operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }\n    IM operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }\n    IM &operator += (modint<MOD> other) {this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    IM &operator -= (modint<MOD> other) {this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    IM &operator *= (modint<MOD> other) {this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    IM operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }\n    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }\n    modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    IM operator /  (modint<MOD> other) const { return *this *  other.inv(); }\n    IM operator /= (modint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (modint<MOD> other) const {return value == other.value;}\n    inline bool operator != (modint<MOD> other) const {return value != other.value;}\n    inline bool operator < (modint<MOD> other)  const {return value < other.value;}\n    inline bool operator > (modint<MOD> other)  const {return value > other.value;}\n    TPT IM &operator += (T ot){return *this += modint<MOD>(ot);}\n    TPT IM &operator -= (T ot){return *this -= modint<MOD>(ot);}\n    TPT IM &operator *= (T ot){return *this *= modint<MOD>(ot);}\n    TPT IM &operator /= (T ot){return *this *= modint<MOD>(ot).inv();}\n    TPT IM operator + (T ot) const {return *this + modint<MOD>(ot);}\n    TPT IM operator - (T ot) const {return *this - modint<MOD>(ot);}\n    TPT IM operator * (T ot) const {return *this * modint<MOD>(ot);}\n    TPT IM operator / (T ot) const {return *this / modint<MOD>(ot);}\n};\n\n/** Debugging Tools **/\nstring to_string(string s){return '\"' + s + '\"';} string to_string(const char* s){return to_string((string) s);}\nstring to_string(bool b){return (b ? \"true\" : \"false\");} UP string to_string(pair<T, U> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\nTP string to_string(T v){bool first = true; string res = \"{\"; for(const auto &x : v){if(!first) res += \", \"; first = false; res += to_string(x); }res += \"}\"; return res;}\nvoid debug_out(){cerr << endl;} HP void debug_out(H Ht, T... Tt){cerr << \" \" << to_string(Ht); debug_out(Tt...);}\n\n/// First 4 Directions are U, D, L, R\nconst int dx[] = {1, -1, 0, 0, -1, 1, -1, 1},  dy[] = {0, 0, -1, 1, 1, 1, -1, -1};  /** king moves */\nconst int kx[] = {-2, -1, 1, 2, 2, 1, -1, -2}, ky[] = {1, 2, 2, 1, -1, -2, -2, -1}; /** knight moves */\n\n#define LOCAL\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int mx = 2e6 + 5;\nconst int sqmx = sqrt(mx) + 1;\nconst int lgmx = __lg(mx) + 1;\n\nstring s; char buf[mx];\nusing mint = modint<MOD>;\n\nint n, m, k, a[mx], b[mx];\n\ninline void solve(int cs){\n    // write(\"Case \", cs, \": \");\n    read(n, k);\n    m = n - k + 1;\n\n    vector<string> v(n+k);\n    for(int i=0; i<n+k; ++i){\n      string cur = (i<26) ? \"A\" : \"B\";\n      cur.push_back((char)('a' + (i%26)));\n      v[i] = cur;\n    }\n\n    // debug(v);\n\n    deque<string> cur;\n    For(i, 1, k){\n      cur.push_back(v[i-1]);\n      write(v[i-1].c_str(), gp);\n    }\n\n    For(i, k-1, n){\n      read(buf); s=buf;\n      if(s == \"NO\"){\n        cur.push_back(cur[0]);\n      }else cur.push_back(v[i]);\n      write(cur.back().c_str(), gp);\n      cur.pop_front();\n    }write(nl);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    cout << fixed << setprecision(15);\n    int tc = 1; srand(time(nullptr));\n\n    // read(tc);\n\n    for(int cs=1; cs<=tc; cs++)\n        solve(cs);\n\n    return 0;\n}\n\nchar os[100]; IL void write(char c){pc(c);} IL void write(char *s){pf(\"%s\",s);} IL void write(const char *s){pf(\"%s\",s);} HP IL void write(H h, T ...t){write(h);write(t...);} TP IL void write(T x) {if(x==0) {pc('0');return;}int i=0;bool neg=(x<0);if(neg)pc('-'),x=-x;while(x>0) {os[i++]=(x%10)+'0';x/=10;}i--;while(i>=0) pc(os[i--]);}\nIL bool read(char &c) {c=gc;return c!=EOF;} IL bool read(char *s){return scanf(\"%s\",s);} HP IL bool read(H& h, T&... t) {return read(h)&&read(t...);} TP IL bool read(T &val) {val=0;bool neg=0;char ch=gc;while(ch <'0' || ch >'9') {if(ch=='-') neg=1;else if(ch==EOF)return 0;ch=gc;}while(ch>='0' && ch<='9') {val=(val*10)+(ch-'0');ch=gc;}if(neg)val=-val;return 1;}\n\n\n    \t    \t  \t\t\t\t\t  \t\t \t\t\t\t    \t"
}