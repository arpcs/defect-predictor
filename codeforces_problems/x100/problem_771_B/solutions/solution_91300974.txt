{
    "id": 91300974,
    "contestId": 771,
    "creationTimeSeconds": 1598720530,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 771,
        "index": "B",
        "name": "Bear and Different Names",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1500,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 771,
        "members": [
            {
                "handle": "Juniper"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1489851300
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 59,
    "timeConsumedMillis": 108,
    "memoryConsumedBytes": 0,
    "source": "import java.io.*;\r\nimport java.math.*;\r\nimport java.util.*;\r\n\r\n/**\r\n *\r\n * @author Saju\r\n *\r\n */\r\n\r\npublic class Main {\r\n\r\n    private static int dx[] = { 1, 0, -1, 0 };\r\n    private static int dy[] = { 0, -1, 0, 1 };\r\n\r\n    private static final long INF = (long) Math.pow(10, 16);\r\n    private static final int INT_INF = Integer.MAX_VALUE;\r\n    private static final long NEG_INF = Long.MIN_VALUE;\r\n    private static final int NEG_INT_INF = Integer.MIN_VALUE;\r\n    private static final double EPSILON = 1e-10;\r\n\r\n    private static final long MAX = (long) 1e12;\r\n    \r\n    private static final long MOD = 1000000007;\r\n\r\n    private static final int MAXN = 300005;\r\n    private static final int MAXA = 1000007;\r\n    private static final int MAXLOG = 22;\r\n    private static final double PI = Math.acos(-1);\r\n    \r\n\tpublic static void main(String[] args) throws IOException {\r\n\r\n\t\tInputReader in = new InputReader(System.in);\r\n//\t\tScanner in = new Scanner(System.in);\r\n\t\tPrintWriter out = new PrintWriter(System.out);\r\n\r\n//         InputReader in = new InputReader(new FileInputStream(\"src/test.in\"));\r\n//         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"src/test.out\")));\r\n\r\n\t\t\r\n\t\t\r\n/*\r\n\r\n\r\n\r\n\r\n\r\n*/\t\t\r\n\t\t\r\n\t\tList<String> uniqueNames = new ArrayList<>();\r\n\t\tfor(char ch = 'A'; ch <= 'Z'; ch++) {\r\n\t\t\tString s = String.valueOf(ch);\r\n\t\t\tuniqueNames.add(s);\r\n\t\t\tfor(char c = 'a'; c <= 'z'; c++) {\r\n\t\t\t\tString ss = s + String.valueOf(c);\r\n\t\t\t\tuniqueNames.add(ss);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tint n = in.nextInt();\r\n\t\tint k = in.nextInt();\r\n\t\tLinkedList<String> list = new LinkedList<>();\r\n\t\tList<String> names = new ArrayList<>();\r\n\t\tint uc = 0;\r\n\t\tfor(int i = 0; i < k - 1; i++) {\r\n\t\t\tnames.add(uniqueNames.get(uc));\r\n\t\t\tlist.addLast(uniqueNames.get(uc));\r\n\t\t\tuc++;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i = 0; i < n - k + 1; i++) {\r\n\t\t\tString s = in.next();\r\n\t\t\tif(i != 0) {\r\n\t\t\t\tlist.removeFirst();\r\n\t\t\t}\r\n\t\t\tif(s.equals(\"YES\")) {\r\n\t\t\t\tnames.add(uniqueNames.get(uc));\r\n\t\t\t\tlist.addLast(uniqueNames.get(uc));\r\n\t\t\t\tuc++;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString fs = list.getFirst();\r\n\t\t\t\tnames.add(fs);\r\n\t\t\t\tlist.addLast(fs);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i = 0; i < n; i++) {\r\n\t\t\tout.print(names.get(i) + \" \");\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tin.close();\r\n\t\tout.flush();\r\n\t\tout.close();\r\n\t\tSystem.exit(0);\r\n\t}\r\n\t\r\n\t\r\n\t/*\r\n\t * return the number of elements in list that are less than or equal to the val\r\n\t */\r\n\tprivate static long upperBound(List<Long> list, long val) {\r\n\t\tint start = 0;\r\n\t\tint len = list.size();\r\n\t\tint end = len - 1;\r\n\t\tint mid = 0;\r\n\r\n\t\twhile (true) {\r\n\t\t\tif (start > end) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tmid = (start + end) / 2;\r\n\t\t\tlong v = list.get(mid);\r\n\t\t\tif (v == val) {\r\n\t\t\t\tstart = mid;\r\n\t\t\t\twhile(start < end) {\r\n\t\t\t\t\tmid = (start + end) / 2;\r\n\t\t\t\t\tif(list.get(mid) == val) {\r\n\t\t\t\t\t\tif(mid + 1 < len && list.get(mid + 1) == val) {\r\n\t\t\t\t\t\t\tstart = mid + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\treturn mid + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tend = mid - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn start + 1;\r\n\t\t\t}\r\n\t\t\tif (v > val) {\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (list.get(mid) < val) {\r\n\t\t\treturn mid + 1;\r\n\t\t}\r\n\t\treturn mid;\r\n\t}\r\n\r\n\r\n\tprivate static boolean isPalindrome(String str) {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tsb.append(str);\r\n\t\tString str1 = sb.reverse().toString();\r\n\t\treturn str.equals(str1);\r\n\t}\r\n\r\n\tprivate static String getBinaryStr(long n, int j) {\r\n\t\tString str = Long.toBinaryString(n);\r\n\t\tint k = str.length();\r\n\t\tfor (int i = 1; i <= j - k; i++) {\r\n\t\t\tstr = \"0\" + str;\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t}\r\n\t\r\n\tprivate static long modInverse(long r) {\r\n\t\treturn bigMod(r, MOD - 2, MOD);\r\n\t}\r\n\t\r\n\tprivate static long bigMod(long n, long k, long m) {\r\n\r\n        long ans = 1;\r\n        while (k > 0) {\r\n            if ((k & 1) == 1) {\r\n                ans = (ans * n) % m;\r\n            }\r\n            n = (n * n) % m;\r\n            k >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n\tprivate static long ceil(long n, long x) {\r\n\t\tlong div = n / x;\r\n        if(div * x != n) {\r\n            div++;\r\n        }\r\n        return div;\r\n\t}\r\n\t\r\n    private static int ceil(int n, int x) {\r\n        int div = n / x;\r\n        if(div * x != n) {\r\n            div++;\r\n        }\r\n        return div;\r\n    }\r\n\r\n    \r\n    private static int abs(int x) {\r\n        if (x < 0) {\r\n            return -x;\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    private static double abs(double x) {\r\n        if (x < 0) {\r\n            return -x;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    private static long abs(long x) {\r\n        if(x < 0) {\r\n            return -x;\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    private static long lcm(long a, long b) {\r\n        return (a * b) / gcd(a, b);\r\n    }\r\n\r\n    private static int lcm(int a, int b) {\r\n        return (a * b) / gcd(a, b);\r\n    }\r\n\r\n    private static int gcd(int a, int b) {\r\n        if (a == 0)\r\n            return b;\r\n        return gcd(b % a, a);\r\n    }\r\n    \r\n    private static long gcd(long a, long b) {\r\n        if (a == 0)\r\n            return b;\r\n        return gcd(b % a, a);\r\n    }\r\n\r\n    private static int log(long x, int base) {\r\n        return (int) (Math.log(x) / Math.log(base));\r\n    }\r\n\r\n    private static int log(long x, long base) {\r\n        return (int) (Math.log(x) / Math.log(base));\r\n    }\r\n    \r\n    private static long min(long a, long b) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    private static int min(int a, int b) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    private static long max(long a, long b) {\r\n        if (a < b) {\r\n            return b;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    private static int max(int a, int b) {\r\n        if (a < b) {\r\n            return b;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    private static class InputReader {\r\n        public BufferedReader reader;\r\n        public StringTokenizer tokenizer;\r\n\r\n        public InputReader(InputStream stream) {\r\n            reader = new BufferedReader(new InputStreamReader(stream));\r\n            tokenizer = null;\r\n        }\r\n\r\n        public String next() {\r\n            try {\r\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                    tokenizer = new StringTokenizer(reader.readLine());\r\n\r\n                }\r\n            } catch (IOException e) {\r\n                return null;\r\n            }\r\n            return tokenizer.nextToken();\r\n        }\r\n\r\n        public String nextLine() {\r\n            String line = null;\r\n            try {\r\n                tokenizer = null;\r\n                line = reader.readLine();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            return line;\r\n        }\r\n\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        public long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        public boolean hasNext() {\r\n            try {\r\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                    tokenizer = new StringTokenizer(reader.readLine());\r\n                }\r\n            } catch (Exception e) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        \r\n        public int[] nextIntArr(int n) {\r\n        \tint arr[] = new int[n];\r\n    \t\tfor(int i = 0; i < n; i++) {\r\n    \t\t\tarr[i] = nextInt();\r\n    \t\t}\r\n    \t\treturn arr;\r\n        }\r\n        \r\n        public long[] nextLongArr(int n) {\r\n        \tlong arr[] = new long[n];\r\n    \t\tfor(int i = 0; i < n; i++) {\r\n    \t\t\tarr[i] = nextLong();\r\n    \t\t}\r\n    \t\treturn arr;\r\n        }\r\n        \r\n        public int[] nextIntArr1(int n) {\r\n        \tint arr[] = new int[n + 1];\r\n    \t\tfor(int i = 1; i <= n; i++) {\r\n    \t\t\tarr[i] = nextInt();\r\n    \t\t}\r\n    \t\treturn arr;\r\n        }\r\n        \r\n        public long[] nextLongArr1(int n) {\r\n        \tlong arr[] = new long[n + 1];\r\n    \t\tfor(int i = 1; i <= n; i++) {\r\n    \t\t\tarr[i] = nextLong();\r\n    \t\t}\r\n    \t\treturn arr;\r\n        }\r\n       \r\n        public void close() {\r\n        \ttry {\r\n        \t\tif(reader != null) {\r\n        \t\t\treader.close();\r\n        \t\t}\r\n        \t}\r\n        \tcatch(Exception e) {\r\n        \t\t\r\n        \t}\r\n        \t\r\n        \t\r\n        }\r\n    }\r\n\r\n}"
}