{
    "id": 212167832,
    "contestId": 1821,
    "creationTimeSeconds": 1688531495,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "phtniit"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 99,
    "timeConsumedMillis": 1996,
    "memoryConsumedBytes": 37068800,
    "source": "// nowcoder multi 2022 addition L\n\n#include <bits/stdc++.h>\n\nnamespace atcoder {\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n\n// assume -P <= x < 2P\nint norm(int x) {\n  if (x < 0) {\n    x += P;\n  }\n  if (x >= P) {\n    x -= P;\n  }\n  return x;\n}\ntemplate<class T>\nT fpower(T a, i64 b) {\n  T res = 1;\n  for (; b; b /= 2, a *= a) {\n    if (b % 2) {\n      res *= a;\n    }\n  }\n  return res;\n}\nstruct Z {\n  int x;\n  Z(int v = 0) : x(norm(v)) {}\n  Z(i64 v) : x(norm(v%P)) {}\n  int val() const {\n    return x;\n  }\n  Z operator-() const {\n    return Z(x == 0 ? 0 : P-x);\n    //return Z(norm(P - x));\n  }\n  Z inv() const {\n    assert(x != 0);\n    return fpower(*this, P - 2);\n  }\n  Z &operator*=(const Z &rhs) {\n    x = i64(x) * rhs.x % P;\n    return *this;\n  }\n  Z &operator+=(const Z &rhs) {\n    x += rhs.x;\n    if (x >= P) x -= P;\n    //x = norm(x + rhs.x);\n    return *this;\n  }\n  Z &operator-=(const Z &rhs) {\n    x -= rhs.x;\n    if (x < 0) x += P;\n    //x = norm(x - rhs.x);\n    return *this;\n  }\n  Z &operator/=(const Z &rhs) {\n    return *this *= rhs.inv();\n  }\n  friend Z operator*(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res *= rhs;\n    return res;\n  }\n  friend Z operator+(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res += rhs;\n    return res;\n  }\n  friend Z operator-(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res -= rhs;\n    return res;\n  }\n  friend Z operator/(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res /= rhs;\n    return res;\n  }\n  friend std::istream &operator>>(std::istream &is, Z &a) {\n    i64 v;\n    is >> v;\n    a = Z(v);\n    return is;\n  }\n  friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n    return os << a.val();\n  }\n};\n\nstd::vector<int> rev;\nstd::vector<Z> roots{0, 1};\nvoid dft(std::vector<Z> &a) {\n  int n = a.size();\n\n  if (int(rev.size()) != n) {\n    int k = __builtin_ctz(n) - 1;\n    rev.resize(n);\n    for (int i = 0; i < n; i++) {\n      rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (rev[i] < i) {\n      std::swap(a[i], a[rev[i]]);\n    }\n  }\n  if (int(roots.size()) < n) {\n    int k = __builtin_ctz(roots.size());\n    roots.resize(n);\n    while ((1 << k) < n) {\n      Z e = fpower(Z(3), (P - 1) >> (k + 1));\n      for (int i = 1 << (k - 1); i < (1 << k); i++) {\n        roots[2 * i] = roots[i];\n        roots[2 * i + 1] = roots[i] * e;\n      }\n      k++;\n    }\n  }\n  for (int k = 1; k < n; k *= 2) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        Z u = a[i + j];\n        Z v = a[i + j + k] * roots[k + j];\n        a[i + j] = u + v;\n        a[i + j + k] = u - v;\n      }\n    }\n  }\n}\nvoid idft(std::vector<Z> &a) {\n  int n = a.size();\n  std::reverse(a.begin() + 1, a.end());\n  dft(a);\n  Z inv = (1 - P) / n;\n  for (int i = 0; i < n; i++) {\n    a[i] *= inv;\n  }\n}\nstruct Poly {\n  std::vector<Z> a;\n  Poly() {}\n  Poly(const std::vector<Z> &a) : a(a) {}\n  Poly(const std::initializer_list<Z> &a) : a(a) {}\n  int size() const {\n    return a.size();\n  }\n  void resize(int n) {\n    a.resize(n);\n  }\n  Z operator[](int idx) const {\n    if (idx < size()) {\n      return a[idx];\n    } else {\n      return 0;\n    }\n  }\n  Z &operator[](int idx) {\n    return a[idx];\n  }\n  Poly mulxk(int k) const {\n    auto b = a;\n    b.insert(b.begin(), k, 0);\n    return Poly(b);\n  }\n  Poly modxk(int k) const {\n    k = std::min(k, size());\n    return Poly(std::vector<Z>(a.begin(), a.begin() + k));\n  }\n  Poly divxk(int k) const {\n    if (size() <= k) {\n      return Poly();\n    }\n    return Poly(std::vector<Z>(a.begin() + k, a.end()));\n  }\n  friend Poly operator+(const Poly &a, const Poly &b) {\n    std::vector<Z> res(std::max(a.size(), b.size()));\n    for (int i = 0; i < int(res.size()); i++) {\n      res[i] = a[i] + b[i];\n    }\n    return Poly(res);\n  }\n  friend Poly operator-(const Poly &a, const Poly &b) {\n    std::vector<Z> res(std::max(a.size(), b.size()));\n    for (int i = 0; i < int(res.size()); i++) {\n      res[i] = a[i] - b[i];\n    }\n    return Poly(res);\n  }\n  friend Poly operator-(const Poly &a) {\n    std::vector<Z> res(a.size());\n    for (int i = 0; i < int(res.size()); i++) {\n      res[i] = -a[i];\n    }\n    return Poly(res);\n  }\n  friend Poly operator*(Poly a, Poly b) {\n    if (a.size() == 0 || b.size() == 0) {\n      return Poly();\n    }\n    int sz = 1, tot = a.size() + b.size() - 1;\n    while (sz < tot) {\n      sz *= 2;\n    }\n    a.a.resize(sz);\n    b.a.resize(sz);\n    dft(a.a);\n    dft(b.a);\n    for (int i = 0; i < sz; ++i) {\n      a.a[i] = a[i] * b[i];\n    }\n    idft(a.a);\n    a.resize(tot);\n    return a;\n  }\n  friend Poly operator*(Z a, Poly b) {\n    for (int i = 0; i < int(b.size()); i++) {\n      b[i] *= a;\n    }\n    return b;\n  }\n  friend Poly operator*(Poly a, Z b) {\n    for (int i = 0; i < int(a.size()); i++) {\n      a[i] *= b;\n    }\n    return a;\n  }\n  Poly &operator+=(Poly b) {\n    return (*this) = (*this) + b;\n  }\n  Poly &operator-=(Poly b) {\n    return (*this) = (*this) - b;\n  }\n  Poly &operator*=(Poly b) {\n    return (*this) = (*this) * b;\n  }\n  Poly deriv() const {\n    if (a.empty()) {\n      return Poly();\n    }\n    std::vector<Z> res(size() - 1);\n    for (int i = 0; i < size() - 1; ++i) {\n      res[i] = (i + 1) * a[i + 1];\n    }\n    return Poly(res);\n  }\n  Poly integr() const {\n    std::vector<Z> res(size() + 1);\n    for (int i = 0; i < size(); ++i) {\n      res[i + 1] = a[i] / (i + 1);\n    }\n    return Poly(res);\n  }\n  Poly inv(int m) const {\n    Poly x{a[0].inv()};\n    int k = 1;\n    while (k < m) {\n      k *= 2;\n      x = (x * (Poly{2} - modxk(k) * x)).modxk(k);\n    }\n    return x.modxk(m);\n  }\n  Poly log(int m) const {\n    return (deriv() * inv(m)).integr().modxk(m);\n  }\n  Poly exp(int m) const {\n    Poly x{1};\n    int k = 1;\n    while (k < m) {\n      k *= 2;\n      x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);\n    }\n    return x.modxk(m);\n  }\n  Poly pow(int k, int m) const {\n    int i = 0;\n    while (i < size() && a[i].val() == 0) {\n      i++;\n    }\n    if (i == size() || 1LL * i * k >= m) {\n      return Poly(std::vector<Z>(m));\n    }\n    Z v = a[i];\n    auto f = divxk(i) * v.inv();\n    return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * fpower(v, k);\n  }\n  Poly sqrt(int m) const {\n    Poly x{1};\n    int k = 1;\n    while (k < m) {\n      k *= 2;\n      x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2);\n    }\n    return x.modxk(m);\n  }\n  Poly mulT(Poly b) const {\n    if (b.size() == 0) {\n      return Poly();\n    }\n    int n = b.size();\n    std::reverse(b.a.begin(), b.a.end());\n    return ((*this) * b).divxk(n - 1);\n  }\n  std::vector<Z> eval(std::vector<Z> x) const {\n    if (size() == 0) {\n      return std::vector<Z>(x.size(), 0);\n    }\n    const int n = std::max(int(x.size()), size());\n    std::vector<Poly> q(4 * n);\n    std::vector<Z> ans(x.size());\n    x.resize(n);\n    std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n      if (r - l == 1) {\n        q[p] = Poly{1, -x[l]};\n      } else {\n        int m = (l + r) / 2;\n        build(2 * p, l, m);\n        build(2 * p + 1, m, r);\n        q[p] = q[2 * p] * q[2 * p + 1];\n      }\n    };\n    build(1, 0, n);\n    std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {\n      if (r - l == 1) {\n        if (l < int(ans.size())) {\n          ans[l] = num[0];\n        }\n      } else {\n        int m = (l + r) / 2;\n        work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));\n        work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));\n      }\n    };\n    work(1, 0, n, mulT(q[1].inv(n)));\n    return ans;\n  }\n};\n\nnamespace simp {\n  std::vector<Z> fac, ifac, invn;\n  void check(int x) {\n    if (fac.empty()) {\n      fac={Z(1), Z(1)};\n      ifac={Z(1), Z(1)};\n      invn={Z(0), Z(1)};\n    }\n    while (fac.size()<=x) {\n      int n = fac.size(), m = fac.size() * 2;\n      fac.resize(m);\n      ifac.resize(m);\n      invn.resize(m);\n      for (int i=n;i<m;i++) {\n        fac[i]=fac[i-1]*Z(i);\n        invn[i]=Z(P-P/i)*invn[P%i];\n        ifac[i]=ifac[i-1]*invn[i];\n      }\n    }\n  }\n  Z gfac(int x) {\n    check(x); return fac[x];\n  }\n  Z ginv(int x) {\n    check(x); return invn[x];\n  }\n  Z gifac(int x) {\n    check(x); return ifac[x];\n  }\n  Z binom(int n,int m) {\n    if (m < 0 || m > n) return Z(0);\n    return gfac(n)*gifac(m)*gifac(n - m);\n  }\n}\n\n}\n\nnamespace lagrange {\n\natcoder::Poly inter(const std::vector<atcoder::Z>& x, const std::vector<atcoder::Z>& y) { // atcoder::P can be any prime number\n  int n = x.size();\n  assert(n == y.size());\n  atcoder::Poly f;\n  f.resize(n+1);\n  f[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j > 0; --j) {\n      f[j] = f[j-1] - f[j] * x[i];\n    }\n    f[0] *= -x[i];\n  }\n\n  atcoder::Poly res;\n  res.resize(n);\n  for (int i = 0; i < n; ++i) {\n    auto a = f;\n    atcoder::Z invx = atcoder::fpower(-x[i], atcoder::P-2);\n    a[0] *= invx;\n    for (int i = 1; i < a.size(); ++i) {\n      a[i] -= a[i-1];\n      a[i] *= invx;\n    }\n    assert(a[n].x == 0);\n\n    atcoder::Z tmp = 1;\n    for (int j = 0; j < n; ++j) if (i != j) {\n      tmp *= (x[i] - x[j]);\n    }\n    auto vi = y[i] * atcoder::fpower(tmp, atcoder::P-2);\n\n    for (int j = 0; j < n; ++j) {\n      res[j] += a[j] * vi;\n    }\n  }\n  return res;\n}\n\natcoder::Poly interG(const std::vector<atcoder::Z>& x, int L, int R) {\n  if (L == R) {\n    atcoder::Poly p;\n    p.resize(2);\n    p[0] = -x[L];\n    p[1] = 1;\n    return p;\n  }\n  int m = (L+R) / 2;\n  return interG(x, L, m) * interG(x, m+1, R);\n}\nusing poly2 = std::pair<atcoder::Poly, atcoder::Poly>;\npoly2 interDaq(const std::vector<atcoder::Z>& v, const std::vector<atcoder::Z>& x, int L, int R) {\n  // first_[L,R] = \\sigma_[L<=i<=R]{v_i * \\prod_[L<=j<=R && j \\neq i]{(x-x_j)}}\n  // second_[L,R] = \\prod_[L<=i<=R]{(x-xi)}\n  if (L == R) {\n    poly2 res;\n    res.first.resize(1);\n    res.first[0] = v[L];\n    res.second.resize(2);\n    res.second[0] = -x[R];\n    res.second[1] = 1;\n    return res;\n  }\n  int m = (L+R) / 2;\n  auto lef = interDaq(v, x, L, m), rig = interDaq(v, x, m+1, R);\n  poly2 res;\n  res.first = lef.first * rig.second + rig.first * lef.second;\n  res.second = lef.second * rig.second;\n  return res;\n}\natcoder::Poly interFast(const std::vector<atcoder::Z>& x, const std::vector<atcoder::Z>& y) { // atcoder::P should be 998244353\n  int n = x.size();\n  assert(y.size() == n);\n  auto g = interG(x, 0, n-1).deriv(); // G = \\prod{(x-xi)}, g = G'\n  auto v = g.eval(x);\n  assert(v.size() == n);\n  for (int i = 0; i < n; ++i) {\n    v[i] = y[i] / v[i]; // v_i = y_i / g'(x_i)\n  }\n  return interDaq(v, x, 0, n-1).first;\n}\n\n}\n\ninline atcoder::Z C(int n, int m) {\n  return atcoder::simp::binom(n, m);\n}\ninline atcoder::Z fpow(long long a, long long b) {\n  return atcoder::fpower(atcoder::Z{a}, b);\n}\n\nusing namespace std;\nusing i64 = long long;\n\nconst int maxn = 500050;\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  atcoder::Poly p;\n  p.resize(n+1);\n  for (int i = k+1; i <= n; ++i) {\n    p[i] = 1;\n  }\n  for (int i = k+1; i <= k*2 && i <= n; ++i) {\n    p[i] += 1;\n  }\n  atcoder::Poly f;\n  f.resize(n+1);\n  for (int i = 0; i <= n; ++i) {\n    f[i] = 1;\n  }\n  f *= p.pow(m, n+1);\n  cout << f[n] << endl;\n  return 0;\n}\n"
}