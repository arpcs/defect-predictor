{
    "id": 204119227,
    "contestId": 1821,
    "creationTimeSeconds": 1682929860,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "Kodaman"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "// #define MULTI_TESTCASES\r\n// #define NDEBUG\r\n\r\n// Utility\r\n#include <algorithm>\r\n#include <chrono>\r\n#include <functional>\r\n#include <iterator>\r\n#include <limits>\r\n#include <memory>\r\n#include <numeric>\r\n#include <random>\r\n#include <type_traits>\r\n#include <utility>\r\n\r\n// I/O\r\n#include <fstream>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <sstream>\r\n\r\n// Data Structure\r\n#include <array>\r\n#include <bitset>\r\n#include <deque>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <stack>\r\n#include <string>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <vector>\r\n\r\n// Other Types\r\n#include <complex>\r\n#include <optional>\r\n#include <tuple>\r\n#include <variant>\r\n\r\n// C\r\n#include <cassert>\r\n#include <cmath>\r\n#include <cstddef>\r\n#include <cstdint>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n\r\nnamespace kod {\r\nnamespace util {\r\n\r\ntemplate <class F> class FixedPoint : private F {\r\n    constexpr FixedPoint(F&& f) : F(std::forward<F>(f)) {}\r\n    template <class G> friend constexpr decltype(auto) make_fixed(G&&);\r\n\r\n  public:\r\n    template <class... Args> constexpr decltype(auto) operator()(Args&&... args) const {\r\n        return F::operator()(*this, std::forward<Args>(args)...);\r\n    }\r\n};\r\n\r\ntemplate <class G> [[nodiscard]] constexpr decltype(auto) make_fixed(G&& g) {\r\n    using F = std::decay_t<G>;\r\n    return FixedPoint<F>(std::forward<F>(g));\r\n}\r\n\r\n}  // namespace util\r\n}  // namespace kod\r\n\r\nnamespace kod {\r\nnamespace util {\r\n\r\nclass ForwardLoop {\r\n    int src, dst;\r\n\r\n    constexpr ForwardLoop(const int x, const int y) : src(x), dst(y) {}\r\n    friend constexpr ForwardLoop rep(const int, const int);\r\n    friend constexpr ForwardLoop rep(const int);\r\n\r\n  public:\r\n    constexpr ForwardLoop begin() const { return *this; }\r\n    constexpr std::monostate end() const { return {}; }\r\n    constexpr bool operator!=(std::monostate) const { return src < dst; }\r\n    constexpr void operator++() const {}\r\n    constexpr int operator*() { return src++; }\r\n};\r\n\r\n[[nodiscard]] constexpr ForwardLoop rep(const int l, const int r) { return ForwardLoop(l, r); }\r\n[[nodiscard]] constexpr ForwardLoop rep(const int n) { return ForwardLoop(0, n); }\r\n\r\nclass BackwardLoop {\r\n    int src, dst;\r\n\r\n    constexpr BackwardLoop(const int x, const int y) : src(x), dst(y) {}\r\n    friend constexpr BackwardLoop revrep(const int, const int);\r\n    friend constexpr BackwardLoop revrep(const int);\r\n\r\n  public:\r\n    constexpr BackwardLoop begin() const { return *this; }\r\n    constexpr std::monostate end() const { return {}; }\r\n    constexpr bool operator!=(std::monostate) const { return src > dst; }\r\n    constexpr void operator++() const {}\r\n    constexpr int operator*() { return --src; }\r\n};\r\n\r\n[[nodiscard]] constexpr BackwardLoop revrep(const int l, const int r) { return BackwardLoop(r, l); }\r\n[[nodiscard]] constexpr BackwardLoop revrep(const int n) { return BackwardLoop(n, 0); }\r\n\r\ntemplate <class F> constexpr void repeat(int n, const F& f) {\r\n    assert(n >= 0);\r\n    while (n--) f();\r\n}\r\n\r\n}  // namespace util\r\n}  // namespace kod\r\n\r\nnamespace kod {\r\nnamespace util {\r\n\r\nstruct Int1 {};\r\nstruct Chars {};\r\n\r\nnamespace stdio_impl {\r\n\r\ntemplate <class T> struct InputTypeImpl {\r\n    using Type = T;\r\n};\r\ntemplate <> struct InputTypeImpl<Int1> {\r\n    using Type = int;\r\n};\r\ntemplate <> struct InputTypeImpl<Chars> {\r\n    using Type = std::vector<char>;\r\n};\r\n\r\ntemplate <class T> using InputType = typename InputTypeImpl<T>::Type;\r\n\r\n}  // namespace stdio_impl\r\n\r\ntemplate <class T> stdio_impl::InputType<T> scan() {\r\n    T x;\r\n    std::cin >> x;\r\n    return x;\r\n}\r\ntemplate <> int scan<Int1>() {\r\n    int x;\r\n    std::cin >> x;\r\n    return x - 1;\r\n}\r\ntemplate <> std::vector<char> scan<Chars>() {\r\n    std::string s;\r\n    std::cin >> s;\r\n    return std::vector<char>(std::cbegin(s), std::cend(s));\r\n}\r\n\r\ntemplate <class T, int N> std::array<stdio_impl::InputType<T>, N> scan_arr() {\r\n    std::array<stdio_impl::InputType<T>, N> a;\r\n    for (auto& x : a) x = scan<T>();\r\n    return a;\r\n}\r\ntemplate <class T> std::vector<stdio_impl::InputType<T>> scan_vec(int n) {\r\n    if (n == -1) n = scan<int>();\r\n    assert(n >= 0);\r\n    std::vector<stdio_impl::InputType<T>> v;\r\n    v.reserve(n);\r\n    while (n--) v.push_back(scan<T>());\r\n    return v;\r\n}\r\n\r\nvoid print() {}\r\ntemplate <class T, class... Args> void print(const T& x, const Args&... args) {\r\n    std::cout << x;\r\n    if (sizeof...(args) != 0) std::cout << ' ';\r\n    print(args...);\r\n}\r\ntemplate <class... Args> void println(const Args&... args) {\r\n    print(args...);\r\n    std::cout << '\\n';\r\n}\r\n\r\ntemplate <class C> void print_seq(const C& c, const char* sep = \" \", const char* end = \"\\n\") {\r\n    bool f = false;\r\n    for (const auto& x : c) {\r\n        if (f) {\r\n            std::cout << sep;\r\n        } else {\r\n            f = true;\r\n        }\r\n        std::cout << x;\r\n    }\r\n    std::cout << end;\r\n}\r\n\r\n}  // namespace util\r\n}  // namespace kod\r\n\r\nnamespace kod {\r\nnamespace sol {\r\n\r\nusing i32 = std::int32_t;\r\nusing i64 = std::int64_t;\r\nusing i128 = __int128_t;\r\nusing u32 = std::uint32_t;\r\nusing u64 = std::uint64_t;\r\nusing u128 = __uint128_t;\r\nusing f64 = double;\r\nusing f80 = long double;\r\n\r\nusing std::array;\r\nusing std::pair;\r\nusing std::string;\r\nusing std::tuple;\r\nusing std::vector;\r\n\r\nusing namespace util;\r\n\r\nconstexpr i32 inf32 = std::numeric_limits<i32>::max() / 2;\r\nconstexpr i64 inf64 = std::numeric_limits<i64>::max() / 2;\r\nconstexpr array<char, 2> sepl = {' ', '\\n'};\r\n\r\ni64 floor_div(const i64 x, const i64 y) {\r\n    assert(y != 0);\r\n    return x / y - ((x ^ y) < 0 && x % y != 0);\r\n}\r\ni64 ceil_div(const i64 x, const i64 y) {\r\n    assert(y != 0);\r\n    return x / y + ((x ^ y) >= 0 && x % y != 0);\r\n}\r\n\r\ntemplate <class T> constexpr bool setmin(T& lhs, const T& rhs) {\r\n    if (lhs > rhs) {\r\n        lhs = rhs;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\ntemplate <class T> constexpr bool setmax(T& lhs, const T& rhs) {\r\n    if (lhs < rhs) {\r\n        lhs = rhs;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid run();\r\n\r\n}  // namespace sol\r\n}  // namespace kod\r\n\r\nint main() {\r\n    std::ios_base::sync_with_stdio(false);\r\n    std::cin.tie(nullptr);\r\n    std::cout << std::fixed << std::setprecision(20);\r\n    int cases = 1;\r\n#ifdef MULTI_TESTCASES\r\n    std::cin >> cases;\r\n#endif\r\n    while (cases--) kod::sol::run();\r\n    return 0;\r\n}\r\n\r\n#ifdef KOD_LOCAL\r\n#define OJ_LOCAL(a, b) b\r\n#include <kodlib/misc/debug>\r\n#else\r\n#define OJ_LOCAL(a, b) a\r\n#define DBG(...)\r\n#endif\r\n\r\nnamespace kod {\r\nnamespace sol {\r\n\r\n#include <ostream>\r\n\r\nusing i32 = std::int32_t;\r\nusing u32 = std::uint32_t;\r\nusing i64 = std::int64_t;\r\nusing u64 = std::uint64_t;\r\nusing i128 = __int128_t;\r\nusing u128 = __uint128_t;\r\n\r\ntemplate <class T> constexpr T rem_euclid(T value, const T& mod) {\r\n    assert(mod > 0);\r\n    return (value %= mod) >= 0 ? value : value + mod;\r\n}\r\n\r\ntemplate <class T> constexpr T totient(T x) {\r\n    T ret = x;\r\n    for (T i = 2; i * i <= x; ++i) {\r\n        if (x % i == 0) {\r\n            ret /= i;\r\n            ret *= i - 1;\r\n            while (x % i == 0) x /= i;\r\n        }\r\n    }\r\n    if (x > 1) {\r\n        ret /= x;\r\n        ret *= x - 1;\r\n    }\r\n    return ret;\r\n}\r\n\r\ntemplate <u32 MOD, std::enable_if_t<((u32)1 <= MOD and MOD <= ((u32)1 << 31))>* = nullptr>\r\nclass StaticModint {\r\n    using Self = StaticModint;\r\n\r\n    static inline constexpr u32 PHI = totient(MOD);\r\n    u32 v;\r\n\r\n  public:\r\n    static constexpr u32 mod() noexcept { return MOD; }\r\n\r\n    template <class T, std::enable_if_t<std::is_integral_v<T>>* = nullptr>\r\n    static constexpr T normalize(const T& x) noexcept {\r\n        return rem_euclid<std::common_type_t<T, i64>>(x, MOD);\r\n    }\r\n\r\n    constexpr StaticModint() noexcept : v(0) {}\r\n    template <class T, std::enable_if_t<std::is_integral_v<T>>* = nullptr>\r\n    constexpr StaticModint(const T& x) noexcept : v(normalize(x)) {}\r\n    template <class T, std::enable_if_t<std::is_integral_v<T>>* = nullptr>\r\n    static constexpr Self raw(const T& x) noexcept {\r\n        Self ret;\r\n        ret.v = x;\r\n        return ret;\r\n    }\r\n\r\n    constexpr u32 val() const noexcept { return v; }\r\n    constexpr Self neg() const noexcept { return raw(v == 0 ? 0 : MOD - v); }\r\n    constexpr Self inv() const noexcept { return pow(PHI - 1); }\r\n    constexpr Self pow(u64 exp) const noexcept {\r\n        Self ret(1), mult(*this);\r\n        for (; exp > 0; exp >>= 1) {\r\n            if (exp & 1) ret *= mult;\r\n            mult *= mult;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    constexpr Self operator-() const noexcept { return neg(); }\r\n    constexpr Self operator~() const noexcept { return inv(); }\r\n\r\n    constexpr Self operator+(const Self& rhs) const noexcept { return Self(*this) += rhs; }\r\n    constexpr Self& operator+=(const Self& rhs) noexcept {\r\n        if ((v += rhs.v) >= MOD) v -= MOD;\r\n        return *this;\r\n    }\r\n\r\n    constexpr Self operator-(const Self& rhs) const noexcept { return Self(*this) -= rhs; }\r\n    constexpr Self& operator-=(const Self& rhs) noexcept {\r\n        if (v < rhs.v) v += MOD;\r\n        v -= rhs.v;\r\n        return *this;\r\n    }\r\n\r\n    constexpr Self operator*(const Self& rhs) const noexcept { return Self(*this) *= rhs; }\r\n    constexpr Self& operator*=(const Self& rhs) noexcept {\r\n        v = (u64)v * rhs.v % MOD;\r\n        return *this;\r\n    }\r\n\r\n    constexpr Self operator/(const Self& rhs) const noexcept { return Self(*this) /= rhs; }\r\n    constexpr Self& operator/=(const Self& rhs) noexcept { return *this *= rhs.inv(); }\r\n\r\n    constexpr bool operator==(const Self& rhs) const noexcept { return v == rhs.v; }\r\n    constexpr bool operator!=(const Self& rhs) const noexcept { return v != rhs.v; }\r\n    friend std::ostream& operator<<(std::ostream& stream, const Self& rhs) {\r\n        return stream << rhs.v;\r\n    }\r\n};\r\n\r\nusing Modint1000000007 = StaticModint<1000000007>;\r\nusing Modint998244353 = StaticModint<998244353>;\r\n\r\ntemplate <class M> struct FpUtil {\r\n    static M fact(const int n) {\r\n        static std::vector<M> vec;\r\n        assert(n >= 0);\r\n        if (vec.empty()) vec = {M(1)};\r\n        for (int i = vec.size(); i <= n; ++i) vec.push_back(vec.back() * M(i));\r\n        return vec[n];\r\n    }\r\n    static M inv(const int n) {\r\n        static std::vector<M> vec;\r\n        assert(n > 0);\r\n        if (vec.empty()) vec = {M(0), M(1)};\r\n        for (int i = vec.size(); i <= n; ++i) vec.push_back(-M(M::mod() / i) * vec[M::mod() % i]);\r\n        return vec[n];\r\n    }\r\n    static M inv_fact(const int n) {\r\n        static std::vector<M> vec;\r\n        assert(n >= 0);\r\n        if (vec.empty()) vec = {M(1)};\r\n        for (int i = vec.size(); i <= n; ++i) vec.push_back(vec.back() * inv(i));\r\n        return vec[n];\r\n    }\r\n    static M binom(const int n, const int k) {\r\n        assert(0 <= k and k <= n);\r\n        return fact(n) * inv_fact(n - k) * inv_fact(k);\r\n    }\r\n    static M factpow(const int n, const int k) {\r\n        assert(0 <= k and k <= n);\r\n        return fact(n) * inv_fact(n - k);\r\n    }\r\n    static M homo(const int n, const int k) {\r\n        assert((n == 0 and k == 0) or (n > 0 and k >= 0));\r\n        if (n == 0 and k == 0) return M(1);\r\n        return binom(n + k - 1, k);\r\n    }\r\n};\r\n\r\nusing Fp = Modint998244353;\r\nusing Util = FpUtil<Fp>;\r\n\r\nvoid run() {\r\n    const int n = scan<int>();\r\n    const int m = scan<int>();\r\n    const int k = scan<int>();\r\n    if (m > n / (k + 1)) {\r\n        println(0);\r\n        return;\r\n    }\r\n    Fp ans = 0;\r\n    vector<Fp> p2(n + 1);\r\n    p2[0] = 1;\r\n    for (const int i : rep(n)) {\r\n        p2[i + 1] = p2[i] * 2;\r\n    }\r\n    for (const int i : revrep(std::min(m, n / k) + 1)) {\r\n        const int j = n - i * k - m * (k + 1);\r\n        ans += p2[m - i] * ((i & 1) ? -1 : +1) * Util::binom(j + m, m) * Util::binom(m, i);\r\n    }\r\n    println(ans);\r\n}\r\n\r\n}  // namespace sol\r\n}  // namespace kod\r\n"
}