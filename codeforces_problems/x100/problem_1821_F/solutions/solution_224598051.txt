{
    "id": 224598051,
    "contestId": 1821,
    "creationTimeSeconds": 1695382303,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "talant"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 623,
    "memoryConsumedBytes": 62771200,
    "source": "#pragma GCC optimize(\"unroll-loops\")\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"sse,sse2,abm,mmx,popcnt\")\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#pragma GCC target(\"avx2\")\r\n// #pragma GCC\r\n// target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,abm,mmx,avx,avx2,popcnt,tune=native\")\r\n// #pragma comment(linker,\"/STACK:256777216\")\r\n/*\r\nMMMMMMMMNNNNNNNNNNNNNNNNNNmNNNNNNNNNNNmmmmmmmmNNMMMMNMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMNNMMMNMMMMMMMMMMMMMMMMMMMMMMNNMMNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMNNNNNNNNNNNmNNNMMMMMMMMMMMMNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMNNNNNNNNNNNNNNNNmmNNNNNNNNMMMMMMMMNmNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMNNNNNMMNNNNNNNNNNNNNNNNNNNNNMMMMMMMMNmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMNNNNNMMNNNNNNmNNNNNNNMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMNNNNNNNNNNNNNmNNNNNNNNNNMMMMMMMMMMMMMMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMNNNNNNNNNNNNNmNNNmNMMMMmMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMNNNNNNNNNNmmmmmNNNNMMNMMNNMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nNNNNNNNNNNNmmmmdddddmNNNNMNNMMNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMNNMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nNNNNNNNNNmmmddddhhhdNNNmmMMMMNmmNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMNMMMMMMMMMNMMMMMMMMMMMMMMMNMMNMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nNNNNNNNNmmddddhhhhhdmNNmNmNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMNMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMNMMMMMMMMMMMMMMMNMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nNNNNNNNmmddddhhhhhhhdNNmNNNNNNNNmmNNNNNNNNNNMMMMMMMMMMMMNMMNMMMMNMMMMMNMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMNMMMMMMMMMMMMMMNMNMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nNNNNNNNmddhhhhhhhyyyhmmNmmmNNMMMMNmNNNNNNNNNMMMMMMMMMMMNMMMNMMMMNMMMMNNMMMMNMMMNMMMMMMMMMMMMMMMMNMMNMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMNNMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nNNNNNNmdhhhhhhyyysssshmdmNMMNNNNNNNmmmmmmmmMMMMMMMMMMMMNMMMNMMMMMMMMMNNMMMMNMMMNMMMMMMMMMMMMMMMMNMMNMMMNMMMNMMMNMMMMMMMMNMMMMMMMMMMMMMMNMMMMMMNNNNNNNNNMMNNNNNNNNNNNNNNNMM\r\nMNNNNmdhyyyyyyysssssssdNNNNNNNNNNNNNNNNNNNmMMMMMMMMMMMMNMMMNMMMNMMMMMNNMMMMNMMMMMMMMMMMMMMMMMMMMNMMNMMMNMMMNMMMMNMMMMMMMNNNNMMMMMMMMMMMNMMMMMMMmmmmmNNNNmmmmmmmmmmmmmmmNNN\r\nMMNNmmdhsoooooooooooooohmNNNNNNNNNNNNNNNdNNMMMMMMMMMMMMNMMMNMMMNNMMMMNMNMMMNMMMMNMMMMMMMMMMMMMMMNMMNMMMNMMMNMMMMMNMMMMMMNNNMNNNMMMMMMMNmMMMMMMMmdddmmmdddddddddddddddddmmN\r\nMNNmmmdhsooooooooooo++ooshmNNNNNNNNNNmhysNNMMMMMMMMMMMNNMMMNMMMNNMMMMNMNMMMNMMMMNMMMMMMMMMMMMMMNMMNMMMNMMMMNNNMMMNMMMMMMNNNMMMMNNMMNNNMdMMMMNMMNmddddddddddddhhhhhhhhddmmN\r\nNmmddddhhhhhhhhhhhhyyyyyyyyhdddmmdddhsoosdNMMMMMMMMMMMNNMMMNMMMNNMMNNmNNMMMNNMMMNMMMMMMMMMMMMMMNMMNMMMNMNNmNMMMMMMNMMMMMMNNNMMmNNNNMMMMmNMMMNNMNmNNNNNNNNNNNmmmmmmmmmNNNMM\r\nmmdddddddddddddddddddhhyyyyyyyhhhyyyoooosdNMMMMMMMMMMMNNMMMNMMMNNMMMMNMNmNNMNMMMNMMMMMMMMMMMMMNNMNNMMNNNNNNMMMMMMMMNMMMMMNMMNMMmNNMmmMmNNMMMMNMMNNNNNNNNNNNNNNNNNNNNNNMMMM\r\nmmddddhdddddddddddddddhhhyyyhhhysssoooosshNMMMMMMMMMMMNNMMMNMMMNNMMMMNMMNMMNNmNNNmMMMMMMMMMMMMNMNmNNNNMMMNMMMMMMMMMMNMMMMNMMMNNMMMMNMNNMNMMMMNNMNNNNNNNNNNNNmmmNNNNNNMMMMM\r\ndddddhhhdddddddddddddddhhhhhhysosyoooosmsyNMMMMMMMMMMMNNMMMNMMMMNNMMMdMNNNMMMNNMMmNMMMMMMMMMMNMMNNMMNMMMNNNMNMMMMMMMMNMMMNMMNNNNNMMMmNMMNMMMMMNNNNNNNNNNNNNNmmNNNNNNMMMMMM\r\ndddddhhhddddddddddddddddhhhsoosyhooooodNssNMMMMMMMMMMMNNNMMNNMNmdhhysshmNNNNNMNNMNmMMMMMMMMMNNMNNMMNNNNmNNNmyhddmmNMMMNMMNMNmMNdNMMmNmNMNMMMMMNmMmNNNNNNMMNNNNNNNMMMMMMMMM\r\ndddddhhhddddddddddddddddysoooyhho++o+sNmosNMMMMMMMMMMMNNNMNdyhhhho////oyssydmmMNNMNNMMMMMMMMNMMNMMMNNNmdhyso++oosssyddNNNNMmMMNMNmNNmMmNmMMMMMMmmNmNNNNNNNNNNNNMMMMMMMMMMM\r\nhdddhhhhhhhddddddddddddsoooyhhho++ssodNmosMMMMMMMMMMMMmNmhddmNMNNy/////+mmy/hNMMMMMMMMMMMMMMMMMMMMMMNmsohdo:::::+mNNdhhmNNNNMMNmNNmNMMNmmMMMMMMNdNmmNNNNNNNNNNMMMMMMMMMMMM\r\nhhhhhyyyhhhhhdddddddddh++shhhho++shooNMdoyMMMMMMMMMMMMmMNdMMMMN+yy+sss++oMMdsmMMMMMMMMMMMMMMMMMMMMMMmyhNhmh+oo++:+MMMMNdNmmNNNNNMMNNmNMdmNMMMMMMNdNmNNNNNNNNMMMMMMMMMMMMMM\r\nhhhhhyyyyhhhhhddddddddy++hhhhs+/+ys+hNNyoyNMMMMMMMMMMMNMMNNMMMh-oshdddyy+NMMNhMMMMMMMMMMMMMMMMMMMMMMdNMM+/yyddhss:NMMMMNMmNMMMMMMMMMNmmdNNNMMMMMNmmNmmNNNMMMMMMMMMMMMMMMMM\r\nhhhhyyyyyyyhhhhddddddhs++hhhy+/:+o+smNNoodMMMMMMMMMMMMNMMMmMMMh-yydhddhhoNMMMNMMMMMMMMMMMMMMMMMMMMMMMMMM/oyddddydoNMMMmNMNMMMMMMMMMMMNNmNNNNNNNNNNdmmmNNNMMMMMMMMMMMMMMMMM\r\nhhhhyyyyyyyhhhhddddddhs++yyo+++///ohNNs+dmNNNNNNNMMMMNNMMMNmMMN/+dhdmmhmhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMs+hhddhdmmMMMNNMMNNNNNNNNNNNNNNNNNNNNNNNNNmmNmNNMMMMMMMMMMMMMMMMMM\r\nhhhyyyyyyyyhhhhhhhhdhhy//o+/+s////yhNy+yNmNNNNNNNNNNNNNMMMMNNMMNoodNNNdsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNohNNNmdyNMMNNMMMNNNNNNNNNNNNNNNNNNNNNNNNNmmmNmMMMMMMMMMMMMMMMMMMM\r\nhhhyyyyyyyyyhhhhhhhhhhh+//+sho/::/hhs+yNNmNNNNNNNNNNNNNMMMMMNNNNNmhdmddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmdmmmmNNNNNNNNNmNNNNNNNNNNNNNNNNNNNNNNNNNmNmmNMMMMMMMMMMMMMMMMMM\r\nhhhyyyyyhyyhhhhhhhhhhhhhhhhhh+/://+/+hNNNmNNNNNNNNNNNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNNmNNNNNNNNNNNNNNNmNNNNNNNNNmNNmmMMMMMMMMMMMMMMNMMM\r\nhhyyyyyyhhhhhhhhhhhhhhhhhhhho:/os//smNNNNmNNNNNNNNNNNNmNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMNNNNNNNNNNMNNmNNNNNNNNNNNNNNNmNNNNNNNNNNmNmmmMMMMMMMMMMNNMMMMM\r\nhyyyyyyyhhhhhhhhhhhhhhhhhhho://hhyyNNNNNNmNNNNNNNNNNNNmNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMNmMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNNdNNNNNNNNNNNNNNNmNNNNNNNNNNmMMmmNMMMMMMMMNNNMMMMM\r\nyyyyyyyhhhhhhhhhhhhhhhhhhho/:/+hhhhNNNNNmmNNNNNNNNNNNNmNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMNNNNNNNNNNNmmmdNNNNNNNNNNNNNNmmNNNNNNNNNNmNMMmmNMMMMMMMMMMMMMMM\r\nyysyyyyhhhhhhhhhhhhhhhhhho::::ohhhdNNNNNmmNNNNNNNNNNNNmNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNmdNNNNNNNNNNNNNNmmNNmNNNNNNNNmMMNmmNMMMMMMMMMMMMMM\r\nyssyyyyhhyyyyyhhhhhhhhhyo:/o::shhhdNNNNmNmNNNNNNNNNNNNyNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNmsNNNNNNNNNNNNNNmmNNmNNNNNNNNmNNNmmmNNMMMMMMMMMMMN\r\nssssssyyysssyyyyyyyyyyy+:/so::syyymNNNmmNdNNNNNNNNNNNNhdNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNhsNNNNNNNNNNNNNNmNNNdNNNNNNNNmddddhmdNNNNNMNNNNNNN\r\noo++++oooooossssssssso/:/os/::+oosNNNNdNNdNNNNNNNNNNNNhymNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNmyyNNNNNNNNNNNNNNmNNNdNNNNNNNNmyyyhhhmdmmmNNmmmmddd\r\n++////++oosssssssssso::/sss:::+++yNNNdNNNdNNNNNNNNNNNNhhyNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNyyyNNNNNNNNNNNNNNdNNNmmmmmmmmmmhdhddddmdddddddhhhhh\r\n////////+ossyysysss+::/ssss::+ssshmNmmNNNdNNNNNNNNNNNNhhhhNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNhhhymNNNNNNNNNNNmmdmmmmdmmmmmmmmdddddmddhddhhhhhhhhh\r\n//:::--:/+ssyyyyys/--+ssssy:-+sssmmmdmmNmdNNNNNNNNNNNNyyhyyNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNhyhhymNNNmmmmmmmmmmymmmmdmmmmmmmmdhhddddhdyhhhhhhhhhh\r\n///::---/+osssyys/--+ssyysy--+sssmmdmmmmmdmmmmmNmNNNmmhssyyymNNNNNNNNNNNNNNNNNNNNNmmmNmmNNmmmmmNNNNNNNNNNNNNNNNNNNNNhssyssmmmmmmmmmmmmmmydmmmhmmmmmmmmdhdddddhhdyyyyhhhhhh\r\n///::--:/+osssss:-:osssssys--+ssymdmmmmdmhmmmmmmmmmmmmhyyyyyohmNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNdyssssssmmmmmmmmmmmmmmshmmmhmmmmmmmddhddddhhyhhyyyyhhhhh\r\n///::--:/osssso--:ssssssyys--+ssyddmmmdmmhmmmmmmmmmmmmhsssssosshmNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNdyssssssssmmmmmmmmmmmmmmsymmmhdddddddddyddhhhhhhhyyyyhhhhh\r\n///::--:/osss+--:sssssssyss--+soydmmmhmmmhmmmmmmmmmmmmhsssssossssydNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNmhsssssosssssmmmmmmmmmmmmddosdddhdddddddddyhhhhhhyyyhsyyhhhhh\r\n////:--:+oss/--/sssssssyyss--+sohdddhddddddmmmmmmmmmmmysssssosssssoshNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNdyosossssosssssddmddddddddddhoodddhhddddddddydhhhyyyyyysyyhhhhh\r\n////:::/+os/../ssssssssysss--/osddddhdddddhdddddddddmdyssssoosssssoossydNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNmysosssoossooooooodddddddddddddsoohdddyddddddhhyhhhhhyyyhsyshddddd\r\n////:::/+o/../sssssssssssss--:sddddyddddddhdddddddddddyooooooooooooooo+syhmmmmmmmmmmmmmmmmmmmmmmmmmmmmhyy+oooooooooo+ooooodddddddddddddooohddhshhhhhhhhhyhhhhhhhhhssdmmmmm\r\n++//:::/+/../sssssssssyssss--:hhddyhhdddddydddddddddddyoooooooooooo+oo+yyysydmmmmmmmmmmmmmmmmmmmmmmdyyyys+oooooo+ooo+oooosdddddddddddhhoo+yhhhshhhhhhhhhshhhhhyyyysyyddddd\r\n++//::://../ssyyyyyysyyssss:.-hhhhyyhhdddyyhddddddddddyoooo+ooooooo+oo+sssysssyhdmmmmmmmmmmmmmmdhysssssso+oooooo+ooo+ooooshdddhhhhhhhhy+++yhhyohhhhhhhhhsyyyyysssysosyyhhh\r\n+++/:://..:ssyyyyyyyyyyyyss/.-hhhsyyhhhhhyhyhhhhhhhddhyoooo+ooooooyhhyosssssssssssyhdmmmmmmdhyssssssssssoooo+ooo+o+++++++shhhhhhhhhhhhs+++shhsshhhhyyyyyossssssssyyosoyyhh\r\n+++////..-ossyyyyyyyhyyyyyy+..shyyshhhhhhyhshhhhhhhhhhy++++++++ooddddddhssssssssssssssyhhysssssssssssoyhdddhyo++/++++++++shhhhhhhhhhhy++++syysoyyyyyyyyyosssssssssysooyyhh\r\n+++///-..+ossyyyyyyyhhhhyyss..oyssyhhhhhhyhshhhhhhhhhhy++++/++++++/:/oyddyossssssssssssossssssssssssoydho+++sy++/++/+++++yhhhhhhhhhyys/+//syyooyyyyyyyyyosssssssssysossyhh\r\n+++//-../ooossyyyyyyyhyyysyy-.:oysyyyyyyyyysyhhhhhhhhhy++++/++++--+oo/-+hdyssyyyyssoooooooooooossssshds--///::://++/++++/yyyyyyyyyyyy+////oyyooyyyyyyyysosssssssssyysooyyh\r\n++++/...+ooossyyyyyyyyyyssyy/..ooyyyyyyysyyysyyyyyyyyyy+++//++++:yhddhs-:yhhhhhhhddhooooooooyhhhhhhhho-+hhhhhy://///////+yyyyyyyyyyys/////oyssoyssssssss+ssssssssssyy+osyy\r\n////.``/+++ossyyyyyyyyyyosss+..+oyyyyyyyoyyysyyyyyyyyyy//////////yhhhhhy--:---:://shh+oooo+yhhs/:::::-+hhhhhh+//////////+yyyyyyyyyyyo/////osoyosssssssss+ssssssssyyyyoooyy\r\n/::-``-///++oossssssyyyosssso..-ssssyyyyoyyyssyyyyyyyyy//////////ohhhhhhyssoooo+:..+hy+oo+yhy:.:oyhhyshhhhhyo://////////+yyyyyyyysss/////:osohosssssssss+yyyyyyyyyhhhhoohh\r\n:::.``::://+++o++o++oo+osssss-.-ssssssssossssossssyyyyy+o+////////hhhhhhhhhhhhhhhs-.sy++++hs-.ohhhhhhhhhhyo+/:/:/://////osssssssssso::::::ssshossssssooooyyyyyyhhhhdmmo+hh\r\n//:--:////+++oo+++///++osssss:.-ooosssssossssosssosssysossyyssossossyyyyyyyyyyyyyyo-/so+/ss:-oyyyyysyyyyy++/-:::////++o+osossssssss///////ooos+ooooooooo+syyyyyyyyyyddo+yh\r\n*/\r\n\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <cassert>\r\n#include <chrono>\r\n#include <climits>\r\n#include <cmath>\r\n#include <complex>\r\n#include <cstdint>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n#include <deque>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <map>\r\n#include <numeric>\r\n#include <queue>\r\n#include <random>\r\n#include <set>\r\n#include <string>\r\n#include <time.h> //////////////\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing ld = long double;\r\nusing uint = unsigned int;\r\n\r\n#define all(a) (a).begin(), (a).end()\r\n#define pbc push_back\r\n#define pob pop_back()\r\n#define vin(a)                                                                 \\\r\n    for (auto &iuoyituytfuyguh : a)                                            \\\r\n    cin >> iuoyituytfuyguh\r\n#define sp system(\"pause\")\r\n#define mp make_pair\r\n// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\ntemplate <typename T1, typename T2> inline void chkmin(T1 &x, const T2 &y) {\r\n    if (y < x)\r\n        x = y;\r\n}\r\n\r\ntemplate <typename T1, typename T2> inline void chkmax(T1 &x, const T2 &y) {\r\n    if (x < y)\r\n        x = y;\r\n}\r\n\r\nmt19937_64 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\r\n// mt19937 rnd(123);\r\nld asdasdcl = 0;\r\ndouble getTime() { return (clock() - asdasdcl) / (double)CLOCKS_PER_SEC; }\r\npair<int, int> operator-(pair<int, int> a, pair<int, int> b) {\r\n    return {a.first - b.first, a.second - b.second};\r\n}\r\npair<int, int> operator+(pair<int, int> a, pair<int, int> b) {\r\n    return {a.first + b.first, a.second + b.second};\r\n}\r\n/*\r\n#define getchar_unlocked _getchar_nolock\r\ninline int readInt()\r\n{\r\n    char x;\r\n    while (x = getchar_unlocked())\r\n    {\r\n        if (x >= '0' && x <= '9')\r\n        {\r\n            int ans = x - '0';\r\n            while (x = getchar_unlocked())\r\n\r\n            {\r\n                if (!(x >= '0' && x <= '9')) return ans;\r\n                ans = ans * 10 + x - '0';\r\n            }\r\n        }\r\n    }\r\n}*/\r\nusing namespace __gnu_pbds;\r\n//\r\n// using ordered_set = tree<\r\n//     pair<int, int>,\r\n//     null_type,\r\n//     less<pair<int, int>>,\r\n//     rb_tree_tag,\r\n//     tree_order_statistics_node_update>;\r\nconst int inf = 1e9 + 20;\r\nconst ld EPS = 1e-8;\r\nconst ll INF = 1e18;\r\nconst ld PI = acos(-1.0);\r\nconst int mod = 998244353;\r\n\r\ntypedef unsigned int uint;\r\n#define int ll\r\nint n, m, k;\r\n\r\nconst uint MOD = 998244353;\r\ntemplate <uint mod = MOD> struct mint { // 1000000007 1000000009\r\n    uint x;\r\n    mint() : x(0) {}\r\n    mint(ll _x) {\r\n        _x %= mod;\r\n        if (_x < 0)\r\n            _x += mod;\r\n        x = _x;\r\n    }\r\n    mint &operator+=(const mint &a) {\r\n        x += a.x;\r\n        if (x >= mod)\r\n            x -= mod;\r\n        return *this;\r\n    }\r\n    mint &operator-=(const mint &a) {\r\n        x += mod - a.x;\r\n        if (x >= mod)\r\n            x -= mod;\r\n        return *this;\r\n    }\r\n    mint &operator*=(const mint &a) {\r\n        x = (ull)x * a.x % mod;\r\n        return *this;\r\n    }\r\n    mint pow(ll pw) const {\r\n        mint res = 1;\r\n        mint cur = *this;\r\n        while (pw) {\r\n            if (pw & 1)\r\n                res *= cur;\r\n            cur *= cur;\r\n            pw >>= 1;\r\n        }\r\n        return res;\r\n    }\r\n    mint inv() const {\r\n        assert(x != 0);\r\n        uint t = x;\r\n        uint res = 1;\r\n        while (t != 1) {\r\n            uint z = mod / t;\r\n            res = (ull)res * (mod - z) % mod;\r\n            t = mod - t * z;\r\n        }\r\n        return res;\r\n    }\r\n    mint &operator/=(const mint &a) { return *this *= a.inv(); }\r\n    mint operator+(const mint &a) const { return mint(*this) += a; }\r\n    mint operator-(const mint &a) const { return mint(*this) -= a; }\r\n    mint operator*(const mint &a) const { return mint(*this) *= a; }\r\n    mint operator/(const mint &a) const { return mint(*this) /= a; }\r\n    bool sqrt(mint &res) const {\r\n        if (mod == 2 || x == 0) {\r\n            res = *this;\r\n            return true;\r\n        }\r\n        if (pow((mod - 1) / 2) != 1)\r\n            return false;\r\n        if (mod % 4 == 3) {\r\n            res = pow((mod + 1) / 4);\r\n            return true;\r\n        }\r\n        int pw = (mod - 1) / 2;\r\n        int K = 30;\r\n        while ((1 << K) > pw)\r\n            K--;\r\n        while (true) {\r\n            mint t = rnd() % mod;\r\n            mint a = 0, b = 0, c = 1;\r\n            for (int k = K; k >= 0; k--) {\r\n                a = b * b;\r\n                b = b * c * 2;\r\n                c = c * c + a * *this;\r\n                if (((pw >> k) & 1) == 0)\r\n                    continue;\r\n                a = b;\r\n                b = b * t + c;\r\n                c = c * t + a * *this;\r\n            }\r\n            if (b == 0)\r\n                continue;\r\n            c -= 1;\r\n            c *= mint() - b.inv();\r\n            if (c * c == *this) {\r\n                res = c;\r\n                return true;\r\n            }\r\n        }\r\n        assert(false);\r\n    }\r\n    bool operator==(const mint &a) const { return x == a.x; }\r\n    bool operator!=(const mint &a) const { return x != a.x; }\r\n    bool operator<(const mint &a) const { return x < a.x; }\r\n};\r\ntemplate <uint mod = MOD> struct Factorials {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> f, fi;\r\n    Factorials() : f(), fi() {}\r\n    Factorials(int n) {\r\n        n += 10;\r\n        f = vector<Mint>(n);\r\n        fi = vector<Mint>(n);\r\n        f[0] = 1;\r\n        for (int i = 1; i < n; i++)\r\n            f[i] = f[i - 1] * i;\r\n        fi[n - 1] = f[n - 1].inv();\r\n        for (int i = n - 1; i > 0; i--)\r\n            fi[i - 1] = fi[i] * i;\r\n    }\r\n    Mint C(int n, int k) {\r\n        if (k < 0 || k > n)\r\n            return 0;\r\n        return f[n] * fi[k] * fi[n - k];\r\n    }\r\n};\r\ntemplate <uint mod = MOD> struct Powers {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> p, pi;\r\n    Powers() : p(), pi() {}\r\n    Powers(int n, Mint x) {\r\n        n += 10;\r\n        if (x == 0) {\r\n            p = vector<Mint>(n);\r\n            p[0] = 1;\r\n        } else {\r\n            p = vector<Mint>(n);\r\n            pi = vector<Mint>(n);\r\n            p[0] = pi[0] = 1;\r\n            Mint xi = x.inv();\r\n            for (int i = 1; i < n; i++) {\r\n                p[i] = p[i - 1] * x;\r\n                pi[i] = pi[i - 1] * xi;\r\n            }\r\n        }\r\n    }\r\n    Mint pow(int n) {\r\n        if (n >= 0)\r\n            return p[n];\r\n        else\r\n            return pi[-n];\r\n    }\r\n};\r\ntemplate <uint mod = MOD> struct Inverses {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> ii;\r\n    Inverses() : ii() {}\r\n    Inverses(int n) {\r\n        n += 10;\r\n        ii = vector<Mint>(n);\r\n        ii[1] = 1;\r\n        for (int x = 2; x < n; x++)\r\n            ii[x] = Mint() - ii[mod % x] * (mod / x);\r\n    }\r\n    Mint inv(Mint x) {\r\n        assert(x != 0);\r\n        uint t = x.x;\r\n        uint res = 1;\r\n        while (t >= (int)ii.size()) {\r\n            uint z = mod / t;\r\n            res = (ull)res * (mod - z) % mod;\r\n            t = mod - t * z;\r\n        }\r\n        return ii[t] * res;\r\n    }\r\n};\r\nusing Mint = mint<MOD>;\r\nconst int LOG = 21; // CHECK !!!!\r\nPowers<MOD> W;\r\nvector<int> binRev;\r\nvoid initFFT() {\r\n    binRev = vector<int>((1 << LOG) + 3, 0);\r\n    Mint w = 2;\r\n    while (true) {\r\n        Mint x = w;\r\n        for (int i = 1; i < LOG; i++)\r\n            x *= x;\r\n        if (x == -1)\r\n            break;\r\n        w += 1;\r\n    }\r\n    W = Powers<MOD>(1 << LOG, w);\r\n    for (int mask = 1; mask < (1 << LOG); mask++) {\r\n        binRev[mask] = (binRev[mask >> 1] >> 1) ^ ((mask & 1) << (LOG - 1));\r\n    }\r\n}\r\ntemplate <unsigned mod = MOD> struct Poly {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> a;\r\n    Poly() : a() {}\r\n    Poly(vector<Mint> _a) {\r\n        a = _a;\r\n        while (!a.empty() && a.back() == 0)\r\n            a.pop_back();\r\n    }\r\n    void print(int n = -1) {\r\n        if (n == -1)\r\n            n = (int)a.size();\r\n        for (int i = 0; i < n; i++)\r\n            printf(\"%u \", at(i).x);\r\n        printf(\"\\n\");\r\n    }\r\n    // void eprint() {\r\n    //     eprintf(\"[\");\r\n    //     for (int i = 0; i < (int)a.size(); i++)\r\n    //         eprintf(\"%u \", a[i].x);\r\n    //     eprintf(\"]\\n\");\r\n    // }\r\n    static void fft(vector<Mint> &A) {\r\n        int L = (int)A.size();\r\n        assert((L & (L - 1)) == 0);\r\n        int k = 0;\r\n        while ((1 << k) < L)\r\n            k++;\r\n        for (int i = 0; i < L; i++) {\r\n            int x = binRev[i] >> (LOG - k);\r\n            if (i < x)\r\n                swap(A[i], A[x]);\r\n        }\r\n        for (int lvl = 0; lvl < k; lvl++) {\r\n            int len = 1 << lvl;\r\n            for (int st = 0; st < L; st += (len << 1))\r\n                for (int i = 0; i < len; i++) {\r\n                    Mint x = A[st + i],\r\n                         y = A[st + len + i] * W.pow(i << (LOG - 1 - lvl));\r\n                    A[st + i] = x + y;\r\n                    A[st + len + i] = x - y;\r\n                }\r\n        }\r\n    }\r\n    Mint &operator[](const int i) {\r\n        assert(0 <= i && i <= deg());\r\n        return a[i];\r\n    }\r\n    Mint at(const int i) const {\r\n        if (i < 0 || i > deg())\r\n            return 0;\r\n        return a[i];\r\n    }\r\n    int deg() const { // deg of polynomial 0 is -1\r\n        return (int)a.size() - 1;\r\n    }\r\n    Mint eval(const Mint &x) const {\r\n        Mint res = 0;\r\n        for (int i = deg(); i >= 0; i--)\r\n            res = res * x + a[i];\r\n        return res;\r\n    }\r\n    Poly substr(const int &l, const int &r) const {\r\n        vector<Mint> f(r - l);\r\n        for (int i = l; i < r; i++)\r\n            f[i - l] = at(i);\r\n        return f;\r\n    }\r\n    Poly &operator+=(const Poly &A) {\r\n        if (deg() < A.deg())\r\n            a.resize(A.a.size());\r\n        for (int i = 0; i <= A.deg(); i++)\r\n            a[i] += A.a[i];\r\n        while (!a.empty() && a.back() == 0)\r\n            a.pop_back();\r\n        return *this;\r\n    }\r\n    Poly &operator-=(const Poly &A) {\r\n        if (deg() < A.deg())\r\n            a.resize(A.a.size());\r\n        for (int i = 0; i <= A.deg(); i++)\r\n            a[i] -= A.a[i];\r\n        while (!a.empty() && a.back() == 0)\r\n            a.pop_back();\r\n        return *this;\r\n    }\r\n    Poly &operator*=(const Mint &k) {\r\n        if (k == 0)\r\n            a.clear();\r\n        for (Mint &x : a)\r\n            x *= k;\r\n        return *this;\r\n    }\r\n    Poly &operator/=(const Mint &k) {\r\n        Mint ki = k.inv();\r\n        for (Mint &x : a)\r\n            x *= ki;\r\n        return *this;\r\n    }\r\n    Poly operator+(const Poly &A) const { return Poly(*this) += A; }\r\n    Poly operator-(const Poly &A) const { return Poly(*this) -= A; }\r\n    Poly operator*(const Mint &k) const { return Poly(*this) *= k; }\r\n    Poly operator/(const Mint &k) const { return Poly(*this) /= k; }\r\n    Poly &operator*=(const Poly &A) {\r\n        if (a.empty() || A.a.empty()) {\r\n            a.clear();\r\n            return *this;\r\n        }\r\n        int nd = deg() + A.deg();\r\n        if (deg() < LOG || A.deg() < LOG) {\r\n            vector<Mint> res(nd + 1, 0);\r\n            for (int i = 0; i <= deg(); i++)\r\n                for (int j = 0; j <= A.deg(); j++)\r\n                    res[i + j] += a[i] * A.a[j];\r\n            return *this = Poly(res);\r\n        }\r\n        int k = 0;\r\n        while ((1 << k) <= nd)\r\n            k++;\r\n        int L = 1 << k;\r\n        vector<Mint> f = a, g = A.a;\r\n        f.resize(L, 0);\r\n        g.resize(L, 0);\r\n        fft(f);\r\n        fft(g);\r\n        for (int i = 0; i < L; i++)\r\n            f[i] *= g[i];\r\n        fft(f);\r\n        reverse(f.begin() + 1, f.end());\r\n        return *this = (Poly(f) / L);\r\n    }\r\n    Poly operator*(const Poly &A) const { return Poly(*this) *= A; }\r\n    Poly inv(int n) const {\r\n        assert(deg() >= 0 && at(0) != 0);\r\n        if (n <= 0)\r\n            return Poly();\r\n        vector<Mint> res(n);\r\n        res[0] = a[0].inv();\r\n        vector<Mint> f, g;\r\n        for (int L = 1; L < n; L <<= 1) {\r\n            f = vector<Mint>(2 * L);\r\n            g = vector<Mint>(2 * L);\r\n            for (int i = 0; i < 2 * L && i <= deg(); i++)\r\n                f[i] = a[i];\r\n            for (int i = 0; i < L; i++)\r\n                g[i] = res[i];\r\n            fft(f);\r\n            fft(g);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            for (int i = 0; i < L; i++)\r\n                f[i] = 0;\r\n            for (int i = L; i < 2 * L; i++)\r\n                f[i] = Mint() - f[i];\r\n            fft(f);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Mint Li = Mint(2 * L).inv();\r\n            Li *= Li;\r\n            for (int i = L; i < 2 * L && i < n; i++)\r\n                res[i] = f[i] * Li;\r\n        }\r\n        return res;\r\n    }\r\n    static vector<Mint> div_stupid(vector<Mint> A, vector<Mint> B) {\r\n        int n = (int)A.size(), m = (int)B.size();\r\n        Mint Bi = B.back().inv();\r\n        for (auto &x : B)\r\n            x *= Bi;\r\n        vector<Mint> C(n - m + 1);\r\n        for (int i = n; i >= m; i--) {\r\n            C[i - m] = A[i - 1] * Bi;\r\n            for (int j = 0; j < m; j++)\r\n                A[i - m + j] -= B[j] * A[i - 1];\r\n        }\r\n        return C;\r\n    }\r\n    Poly &operator/=(const Poly &A) {\r\n        int d1 = deg(), d2 = A.deg();\r\n        assert(d2 >= 0);\r\n        if (d1 < d2)\r\n            return *this = Poly();\r\n        if (d2 < 4 * LOG || d1 - d2 < 4 * LOG)\r\n            return *this = div_stupid(a, A.a);\r\n        vector<Mint> f = a, g = A.a;\r\n        reverse(all(f));\r\n        reverse(all(g));\r\n        Poly H = Poly(vector<Mint>(f.begin(), f.begin() + d1 - d2 + 1)) *\r\n                 Poly(g).inv(d1 - d2 + 1);\r\n        vector<Mint> t = vector<Mint>(H.a.begin(), H.a.begin() + (d1 - d2 + 1));\r\n        reverse(all(t));\r\n        return *this = t;\r\n    }\r\n    Poly operator/(const Poly &A) const { return Poly(*this) /= A; }\r\n    Poly &operator%=(const Poly &A) {\r\n        assert(A.deg() >= 0);\r\n        if (deg() < A.deg())\r\n            return *this;\r\n        return *this -= A * (*this / A);\r\n    }\r\n    Poly operator%(const Poly &A) const { return Poly(*this) %= A; }\r\n    Poly derivate() const {\r\n        int n = deg();\r\n        if (n <= 0)\r\n            return Poly();\r\n        vector<Mint> f(n);\r\n        for (int i = 0; i < n; i++)\r\n            f[i] = a[i + 1] * (i + 1);\r\n        return f;\r\n    }\r\n    Poly integrate() const {\r\n        int n = deg();\r\n        if (n < 0)\r\n            return Poly();\r\n        n += 2;\r\n        vector<Mint> f(n);\r\n        Inverses<MOD> I = Inverses<MOD>(n);\r\n        for (int i = 1; i < n; i++)\r\n            f[i] = a[i - 1] * I.inv(i);\r\n        return f;\r\n    }\r\n    Poly log(int n) const {\r\n        if (n <= 1)\r\n            return Poly();\r\n        assert(deg() >= 0 && at(0) == 1);\r\n        return (derivate() * inv(n)).substr(0, n - 1).integrate();\r\n    }\r\n    Poly exp(int n) const {\r\n        if (n <= 0)\r\n            return Poly();\r\n        if (deg() < 0)\r\n            return Poly({1});\r\n        assert(at(0) == 0);\r\n        vector<Mint> res(n);\r\n        res[0] = 1;\r\n        vector<Mint> f, g;\r\n        for (int L = 1; L < n; L <<= 1) {\r\n            f = vector<Mint>(2 * L);\r\n            g = vector<Mint>(2 * L);\r\n            Poly LG =\r\n                Poly(vector<Mint>(res.begin(), res.begin() + L)).log(2 * L);\r\n            for (int i = 0; i < L; i++)\r\n                assert(at(i) == LG.at(i));\r\n            for (int i = 0; i < L; i++) {\r\n                f[i] = res[i];\r\n                g[i] = at(L + i) - LG.at(L + i);\r\n            }\r\n            fft(f);\r\n            fft(g);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Mint Li = Mint(2 * L).inv();\r\n            for (int i = L; i < 2 * L && i < n; i++)\r\n                res[i] = f[i - L] * Li;\r\n        }\r\n        return res;\r\n    }\r\n    Poly sqr(int n) const { return (*this * *this).substr(0, n); }\r\n    Poly pow_(Mint k, int n)\r\n        const { // k can be non - negative rational(k = 1 / 2 is sqrt), but\r\n        assert(a[0] == 1);\r\n        if (deg() < 0 || n <= 0)\r\n            return Poly();\r\n        return (log(n) * k).exp(n);\r\n    }\r\n    Poly pow(ll k, int n) const { // k is non - negative integer\r\n        if (n <= 0)\r\n            return Poly();\r\n        if (k == 0)\r\n            return Poly({1});\r\n        if (k == 1)\r\n            return substr(0, n);\r\n        if (k == 2)\r\n            return sqr(n);\r\n        if (k < LOG) {\r\n            Poly cur = substr(0, n);\r\n            Poly res = Poly({1});\r\n            while (k) {\r\n                if (k & 1)\r\n                    res = (res * cur).substr(0, n);\r\n                cur = cur.sqr(n);\r\n                k >>= 1;\r\n            }\r\n            return res;\r\n        }\r\n        int z = 0;\r\n        while (z * k < n && at(z) == 0)\r\n            z++;\r\n        if (z * k >= n)\r\n            return Poly();\r\n        Poly A = substr(z, z + n - z * k);\r\n        Mint cf = A[0].pow(k);\r\n        A /= A[0];\r\n        A = A.pow_(k, n - z * k) * cf;\r\n        return A.substr(-z * k, n - z * k);\r\n    }\r\n    Poly sqrt_(int n) const {\r\n        if (deg() < 0 || n <= 0)\r\n            return Poly();\r\n        assert(at(0) == 1);\r\n        // return pow_ ( Mint (2) .inv () , n);\r\n        vector<Mint> res(n);\r\n        res[0] = 1;\r\n        vector<Mint> f, g;\r\n        for (int L = 1; L < n; L <<= 1) {\r\n            f = vector<Mint>(2 * L);\r\n            g = vector<Mint>(2 * L);\r\n            for (int i = 0; i < L; i++)\r\n                f[i] = res[i];\r\n            fft(f);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= f[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Mint Li = Mint(2 * L).inv();\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= Li;\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] = at(i) - f[i];\r\n            for (int i = 0; i < L; i++)\r\n                assert(f[i] == 0);\r\n            for (int i = 0; i < L; i++) {\r\n                f[i] = f[i + L];\r\n                f[i + L] = 0;\r\n            }\r\n            Poly Q = Poly(vector<Mint>(res.begin(), res.begin() + L)).inv(L);\r\n            for (int i = 0; i < L; i++)\r\n                g[i] = Q.at(i);\r\n            fft(f);\r\n            fft(g);\r\n            for (int i = 0; i < 2 * L; i++)\r\n                f[i] *= g[i];\r\n            fft(f);\r\n            reverse(f.begin() + 1, f.end());\r\n            Li /= 2;\r\n            for (int i = L; i < 2 * L && i < n; i++)\r\n                res[i] = f[i - L] * Li;\r\n        }\r\n        return res;\r\n    }\r\n    bool sqrt(int n, Poly &R) const {\r\n        if (deg() < 0) {\r\n            R = Poly();\r\n            return true;\r\n        }\r\n        if (at(0) == 1) {\r\n            R = sqrt_(n);\r\n            return true;\r\n        }\r\n        int z = 0;\r\n        while (at(z) == 0)\r\n            z++;\r\n        if (z & 1)\r\n            return false;\r\n        Poly A = substr(z, n + z / 2);\r\n        Mint cf;\r\n        if (!A[0].sqrt(cf))\r\n            return false;\r\n        A /= A[0];\r\n        A = A.sqrt_(n - z / 2) * cf;\r\n        R = A.substr(-z / 2, n - z / 2);\r\n        return true;\r\n    }\r\n    static Poly multiply_all(vector<Poly> polys) {\r\n        if (polys.empty())\r\n            return Poly({1});\r\n        set<pair<int, int>> setik;\r\n        for (int i = 0; i < (int)polys.size(); i++)\r\n            setik.insert(mp(polys[i].deg(), i));\r\n        while ((int)setik.size() > 1) {\r\n            int p = setik.begin()->second;\r\n            setik.erase(setik.begin());\r\n            int q = setik.begin()->second;\r\n            setik.erase(setik.begin());\r\n            polys[p] *= polys[q];\r\n            setik.insert(mp(polys[p].deg(), p));\r\n        }\r\n        return polys[setik.begin()->second];\r\n    }\r\n    static Poly given_roots(const vector<Mint> &xs) {\r\n        int n = (int)xs.size();\r\n        vector<Poly> polys(n);\r\n        for (int i = 0; i < n; i++)\r\n            polys[i] = Poly({Mint() - xs[i], 1});\r\n        return multiply_all(polys);\r\n    }\r\n    vector<Mint> multipoint(const vector<Mint> &xs) const {\r\n        int n = (int)xs.size();\r\n        if (n == 0)\r\n            return {};\r\n        if (n == 1)\r\n            return {eval(xs[0])};\r\n        int L = n;\r\n        while (L & (L - 1))\r\n            L++;\r\n        vector<Poly> tree(2 * L);\r\n        for (int i = 0; i < n; i++)\r\n            tree[L + i] = Poly({Mint() - xs[i], 1});\r\n        for (int i = n; i < L; i++)\r\n            tree[L + i] = Poly({1});\r\n        for (int i = L - 1; i > 0; i--)\r\n            tree[i] = tree[2 * i] * tree[2 * i + 1];\r\n        tree[1] = *this % tree[1];\r\n        for (int i = 2; i < L + n; i++)\r\n            tree[i] = tree[i / 2] % tree[i];\r\n        vector<Mint> res(n);\r\n        for (int i = 0; i < n; i++)\r\n            res[i] = tree[L + i][0];\r\n        return res;\r\n    }\r\n    static pair<Poly, Poly> interpolate_(const vector<pair<Mint, Mint>> &vals,\r\n                                         int l, int r) {\r\n        if (r - l == 1)\r\n            return mp(Poly({vals[l].second}),\r\n                      Poly({Mint() - vals[l].first, 1}));\r\n        int m = (l + r) / 2;\r\n        auto L = interpolate_(vals, l, m), R = interpolate_(vals, m, r);\r\n        return mp(L.first * R.second + R.first * L.second, L.second * R.second);\r\n    }\r\n    static Poly interpolate(vector<pair<Mint, Mint>> vals) {\r\n        if (vals.empty())\r\n            return Poly();\r\n        int n = (int)vals.size();\r\n        vector<Mint> xs(n);\r\n        for (int i = 0; i < n; i++)\r\n            xs[i] = vals[i].first;\r\n        Poly P = given_roots(xs);\r\n        P = P.derivate();\r\n        vector<Mint> cf = P.multipoint(xs);\r\n        for (int i = 0; i < n; i++)\r\n            vals[i].second /= cf[i];\r\n        return interpolate_(vals, 0, (int)vals.size()).first;\r\n    }\r\n    Poly x_k_mod_this(ll k) const { // x^k % P\r\n        Poly res = Poly({1});\r\n        int t = 0;\r\n        while ((1LL << t) <= k)\r\n            t++;\r\n        for (int i = t - 1; i >= 0; i--) {\r\n            res *= res;\r\n            if ((k >> i) & 1)\r\n                res = res.substr(-1, res.deg() + 1);\r\n            res %= *this;\r\n        }\r\n        return res;\r\n    }\r\n    vector<Mint>\r\n    chirp_z(Mint z, int n) const { // eval at[z ^ 0, z ^ 1, ..., z ^ (n - 1)]\r\n        int m = deg();\r\n        if (m < 0 || n == 0)\r\n            return vector<Mint>(n);\r\n        if (z == 0) {\r\n            vector<Mint> res(n, at(0));\r\n            res[0] = eval(1);\r\n            return res;\r\n        }\r\n        Mint zi = z.inv();\r\n        vector<Mint> Z(n + m, 1), Zi(max(m + 1, n), 1);\r\n        Mint w = 1, wi = 1;\r\n        for (int i = 1; i < (int)Z.size(); i++) {\r\n            Z[i] = Z[i - 1] * w;\r\n            w *= z;\r\n        }\r\n        for (int i = 1; i < (int)Zi.size(); i++) {\r\n            Zi[i] = Zi[i - 1] * wi;\r\n            wi *= zi;\r\n        }\r\n        vector<Mint> f(m + 1);\r\n        for (int i = 0; i <= m; i++)\r\n            f[i] = at(i) * Zi[i];\r\n        reverse(all(Z));\r\n        Poly C = Poly(f) * Z;\r\n        vector<Mint> res(n);\r\n        for (int k = 0; k < n; k++)\r\n            res[k] = C.at(n + m - 1 - k) * Zi[k];\r\n        return res;\r\n    }\r\n    Poly shift_c(Mint c) const { // P(x + c)\r\n        int n = deg();\r\n        if (n < 0)\r\n            return Poly();\r\n        Factorials F(n);\r\n        Powers P(n, c);\r\n        vector<Mint> f(n + 1), g(n + 1);\r\n        for (int i = 0; i <= n; i++) {\r\n            f[i] = at(i) * F.f[i];\r\n            g[i] = P.pow(i) * F.fi[i];\r\n        }\r\n        reverse(all(g));\r\n        Poly C = Poly(f) * g;\r\n        for (int i = 0; i <= n; i++)\r\n            f[i] = C.at(n + i) * F.fi[i];\r\n        return f;\r\n    }\r\n};\r\ntemplate <uint mod = MOD>\r\nvector<mint<mod>> BerlekampMassey(vector<mint<mod>> x) {\r\n    using Mint = mint<mod>;\r\n    vector<Mint> ls, cur;\r\n    int lf;\r\n    Mint ld;\r\n    for (int i = 0; i < (int)x.size(); i++) {\r\n        Mint t = 0;\r\n        for (int j = 0; j < (int)cur.size(); j++)\r\n            t += cur[j] * x[i - j - 1];\r\n        if (t == x[i])\r\n            continue;\r\n        if (cur.empty()) {\r\n            cur.resize(i + 1);\r\n            lf = i;\r\n            ld = t - x[i];\r\n            continue;\r\n        }\r\n        Mint k = (t - x[i]) / ld;\r\n        vector<Mint> c(i - lf - 1);\r\n        c.push_back(k);\r\n        for (auto t : ls) {\r\n            c.push_back(Mint() - t * k);\r\n        }\r\n        if (c.size() < cur.size())\r\n            c.resize(cur.size());\r\n        for (int j = 0; j < (int)cur.size(); j++)\r\n            c[j] += cur[j];\r\n        if (i - lf + (int)ls.size() >= (int)cur.size()) {\r\n            ls = cur;\r\n            lf = i;\r\n            ld = t - x[i];\r\n        }\r\n        cur = c;\r\n    }\r\n    return cur;\r\n}\r\n// CALL initFFT () and CHECK LOG\r\n// initFFT();\r\nvoid solve() {\r\n    initFFT();\r\n    cin >> n >> m >> k;\r\n    if (n < m * (k + 1)) {\r\n        cout << 0 << '\\n';\r\n        return;\r\n    }\r\n    Factorials<mod> f(n + 1);\r\n    vector<Mint> coef(n + 1);\r\n    for (int j = 0; j < k; ++j)\r\n        coef[j] = Mint(2);\r\n    for (int j = k; j < coef.size(); ++j)\r\n        coef[j] = Mint(1);\r\n    Poly<mod> ppl = Poly<mod>(coef);\r\n    Poly<mod> fs;\r\n    fs.a.resize(n + 1);\r\n    // fs.a[0] = 2;\r\n    // fs.a[k] = Mint(-1);\r\n    // def = m\r\n    for (int j = 0; j <= m; ++j) {\r\n        int id = j * k;\r\n        if (id < fs.a.size()) {\r\n            fs.a[id] = Mint(2).pow(m - j);\r\n            fs.a[id] *= f.C(m, j);\r\n            if (j % 2) {\r\n                fs.a[id] *= Mint(-1);\r\n            }\r\n        }\r\n    }\r\n    // (2 + x ^ k) ^ m = 2 ^ m + C(m, 1) * x ^ k * 2 ^ (m - 1) P =\r\n    //                       1 + ....+ x ^ (k - 1) + 1 / 1 - x =\r\n    //                           (1 - x ^ k) / (1 - x) + 1 / 1 - x =\r\n    //                               2 - x ^ k / (1 - x) ppl =\r\n    //                                   binpow(ppl, (n - m * (k + 1)) + 1, m);\r\n    // for (int j = 0; j < fs.a.size(); ++j) {\r\n    //     cout << fs.a[j].x << ' ';\r\n    // }\r\n    // cout << endl;\r\n    Poly<mod> ss;\r\n    ss.a.resize(n + 1);\r\n    for (int j = 0; j < ss.a.size(); ++j) {\r\n        ss.a[j] = f.C(j + m - 1, j);\r\n    }\r\n    fs *= ss;\r\n    // n - m(k + 1);\r\n    Mint res = 0;\r\n    for (int j = 0; j <= n - m * (k + 1); ++j)\r\n        res += fs.a[j];\r\n    cout << res.x << '\\n';\r\n}\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\r\n    cout.precision(20), cout.setf(ios::fixed);\r\n    int t;\r\n    t = 1;\r\n    // cin >> t;\r\n    while (t--) {\r\n        solve();\r\n    }\r\n    // cout << (ld)clock() / CLOCKS_PER_SEC << '\\n';\r\n}"
}