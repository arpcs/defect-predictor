{
    "id": 205076775,
    "contestId": 1821,
    "creationTimeSeconds": 1683546709,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "yangjl"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 99,
    "timeConsumedMillis": 420,
    "memoryConsumedBytes": 36352000,
    "source": "#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<cassert>\r\n#include<string>\r\n#include<queue>\r\n#include<deque>\r\n#include<stack>\r\n#include<algorithm>\r\n#include<unordered_map>\r\n#include<map>\r\n#include<vector>\r\n#include<set>\r\n#include<unordered_set>\r\n#include<bitset>\r\n#include<climits>\r\n#include<numeric>\r\n#include<functional>\r\n#include<iomanip>\r\n#include<random>\r\n#ifdef YJL\r\n#include<debug.h>\r\n#else\r\n#define debug(args...)0\r\n#define debug_n(a,n)0\r\n#endif\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\n// \u6ce8\u610f\u4fee\u6539\u201c@\u201d\u8c03\u6574\u6700\u5927\u8303\u56f4\r\nnamespace ntt {\r\n////////////////////////////////////////////////////////////////////////////////\r\ntemplate <unsigned M_> struct ModInt {\r\n  static constexpr unsigned M = M_;\r\n  unsigned x;\r\n  constexpr ModInt() : x(0U) {}\r\n  constexpr ModInt(unsigned x_) : x(x_ % M) {}\r\n  constexpr ModInt(unsigned long long x_) : x(x_ % M) {}\r\n  constexpr ModInt(int x_) : x(((x_ %= static_cast<int>(M)) < 0) ? (x_ + static_cast<int>(M)) : x_) {}\r\n  constexpr ModInt(long long x_) : x(((x_ %= static_cast<long long>(M)) < 0) ? (x_ + static_cast<long long>(M)) : x_) {}\r\n  ModInt &operator+=(const ModInt &a) { x = ((x += a.x) >= M) ? (x - M) : x; return *this; }\r\n  ModInt &operator++() { x = ((x += 1) >= M) ? (x - M) : x; return *this; }\r\n  ModInt &operator-=(const ModInt &a) { x = ((x -= a.x) >= M) ? (x + M) : x; return *this; }\r\n  ModInt &operator*=(const ModInt &a) { x = (static_cast<unsigned long long>(x) * a.x) % M; return *this; }\r\n  ModInt &operator/=(const ModInt &a) { return (*this *= a.inv()); }\r\n  ModInt pow(long long e) const {\r\n    if (e < 0) return inv().pow(-e);\r\n    ModInt a = *this, b = 1U; for (; e; e >>= 1) { if (e & 1) b *= a; a *= a; } return b;\r\n  }\r\n  ModInt inv() const {\r\n    unsigned a = M, b = x; int y = 0, z = 1;\r\n    for (; b; ) { const unsigned q = a / b; const unsigned c = a - q * b; a = b; b = c; const int w = y - static_cast<int>(q) * z; y = z; z = w; }\r\n    assert(a == 1U); return ModInt(y);\r\n  }\r\n  ModInt operator+() const { return *this; }\r\n  ModInt operator-() const { ModInt a; a.x = x ? (M - x) : 0U; return a; }\r\n  ModInt operator+(const ModInt &a) const { return (ModInt(*this) += a); }\r\n  ModInt operator-(const ModInt &a) const { return (ModInt(*this) -= a); }\r\n  ModInt operator*(const ModInt &a) const { return (ModInt(*this) *= a); }\r\n  ModInt operator/(const ModInt &a) const { return (ModInt(*this) /= a); }\r\n  template <class T> friend ModInt operator+(T a, const ModInt &b) { return (ModInt(a) += b); }\r\n  template <class T> friend ModInt operator-(T a, const ModInt &b) { return (ModInt(a) -= b); }\r\n  template <class T> friend ModInt operator*(T a, const ModInt &b) { return (ModInt(a) *= b); }\r\n  template <class T> friend ModInt operator/(T a, const ModInt &b) { return (ModInt(a) /= b); }\r\n  explicit operator bool() const { return x; }\r\n  bool operator==(const ModInt &a) const { return (x == a.x); }\r\n  bool operator!=(const ModInt &a) const { return (x != a.x); }\r\n  friend std::istream &operator>>(std::istream &is, ModInt &a) { return is >> a.x; }\r\n  friend std::ostream &operator<<(std::ostream &os, const ModInt &a) { return os << a.x; }\r\n};\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nconstexpr unsigned MO = 998244353U;\r\nconstexpr unsigned MO2 = 2U * MO;\r\nconstexpr int FFT_MAX = 23;\r\nusing Mint = ModInt<MO>;\r\nconstexpr Mint FFT_ROOTS[FFT_MAX + 1] = {1U, 998244352U, 911660635U, 372528824U, 929031873U, 452798380U, 922799308U, 781712469U, 476477967U, 166035806U, 258648936U, 584193783U, 63912897U, 350007156U, 666702199U, 968855178U, 629671588U, 24514907U, 996173970U, 363395222U, 565042129U, 733596141U, 267099868U, 15311432U};\r\nconstexpr Mint INV_FFT_ROOTS[FFT_MAX + 1] = {1U, 998244352U, 86583718U, 509520358U, 337190230U, 87557064U, 609441965U, 135236158U, 304459705U, 685443576U, 381598368U, 335559352U, 129292727U, 358024708U, 814576206U, 708402881U, 283043518U, 3707709U, 121392023U, 704923114U, 950391366U, 428961804U, 382752275U, 469870224U};\r\nconstexpr Mint FFT_RATIOS[FFT_MAX] = {911660635U, 509520358U, 369330050U, 332049552U, 983190778U, 123842337U, 238493703U, 975955924U, 603855026U, 856644456U, 131300601U, 842657263U, 730768835U, 942482514U, 806263778U, 151565301U, 510815449U, 503497456U, 743006876U, 741047443U, 56250497U, 867605899U};\r\nconstexpr Mint INV_FFT_RATIOS[FFT_MAX] = {86583718U, 372528824U, 373294451U, 645684063U, 112220581U, 692852209U, 155456985U, 797128860U, 90816748U, 860285882U, 927414960U, 354738543U, 109331171U, 293255632U, 535113200U, 308540755U, 121186627U, 608385704U, 438932459U, 359477183U, 824071951U, 103369235U};\r\n\r\n// as[rev(i)] <- \\sum_j \\zeta^(ij) as[j]\r\nvoid fft(Mint *as, int n) {\r\n  assert(!(n & (n - 1))); assert(1 <= n); assert(n <= 1 << FFT_MAX);\r\n  int m = n;\r\n  if (m >>= 1) {\r\n    for (int i = 0; i < m; ++i) {\r\n      const unsigned x = as[i + m].x;  // < MO\r\n      as[i + m].x = as[i].x + MO - x;  // < 2 MO\r\n      as[i].x += x;  // < 2 MO\r\n    }\r\n  }\r\n  if (m >>= 1) {\r\n    Mint prod = 1U;\r\n    for (int h = 0, i0 = 0; i0 < n; i0 += (m << 1)) {\r\n      for (int i = i0; i < i0 + m; ++i) {\r\n        const unsigned x = (prod * as[i + m]).x;  // < MO\r\n        as[i + m].x = as[i].x + MO - x;  // < 3 MO\r\n        as[i].x += x;  // < 3 MO\r\n      }\r\n      prod *= FFT_RATIOS[__builtin_ctz(++h)];\r\n    }\r\n  }\r\n  for (; m; ) {\r\n    if (m >>= 1) {\r\n      Mint prod = 1U;\r\n      for (int h = 0, i0 = 0; i0 < n; i0 += (m << 1)) {\r\n        for (int i = i0; i < i0 + m; ++i) {\r\n          const unsigned x = (prod * as[i + m]).x;  // < MO\r\n          as[i + m].x = as[i].x + MO - x;  // < 4 MO\r\n          as[i].x += x;  // < 4 MO\r\n        }\r\n        prod *= FFT_RATIOS[__builtin_ctz(++h)];\r\n      }\r\n    }\r\n    if (m >>= 1) {\r\n      Mint prod = 1U;\r\n      for (int h = 0, i0 = 0; i0 < n; i0 += (m << 1)) {\r\n        for (int i = i0; i < i0 + m; ++i) {\r\n          const unsigned x = (prod * as[i + m]).x;  // < MO\r\n          as[i].x = (as[i].x >= MO2) ? (as[i].x - MO2) : as[i].x;  // < 2 MO\r\n          as[i + m].x = as[i].x + MO - x;  // < 3 MO\r\n          as[i].x += x;  // < 3 MO\r\n        }\r\n        prod *= FFT_RATIOS[__builtin_ctz(++h)];\r\n      }\r\n    }\r\n  }\r\n  for (int i = 0; i < n; ++i) {\r\n    as[i].x = (as[i].x >= MO2) ? (as[i].x - MO2) : as[i].x;  // < 2 MO\r\n    as[i].x = (as[i].x >= MO) ? (as[i].x - MO) : as[i].x;  // < MO\r\n  }\r\n}\r\n\r\n// as[i] <- (1/n) \\sum_j \\zeta^(-ij) as[rev(j)]\r\nvoid invFft(Mint *as, int n) {\r\n  assert(!(n & (n - 1))); assert(1 <= n); assert(n <= 1 << FFT_MAX);\r\n  int m = 1;\r\n  if (m < n >> 1) {\r\n    Mint prod = 1U;\r\n    for (int h = 0, i0 = 0; i0 < n; i0 += (m << 1)) {\r\n      for (int i = i0; i < i0 + m; ++i) {\r\n        const unsigned long long y = as[i].x + MO - as[i + m].x;  // < 2 MO\r\n        as[i].x += as[i + m].x;  // < 2 MO\r\n        as[i + m].x = (prod.x * y) % MO;  // < MO\r\n      }\r\n      prod *= INV_FFT_RATIOS[__builtin_ctz(++h)];\r\n    }\r\n    m <<= 1;\r\n  }\r\n  for (; m < n >> 1; m <<= 1) {\r\n    Mint prod = 1U;\r\n    for (int h = 0, i0 = 0; i0 < n; i0 += (m << 1)) {\r\n      for (int i = i0; i < i0 + (m >> 1); ++i) {\r\n        const unsigned long long y = as[i].x + MO2 - as[i + m].x;  // < 4 MO\r\n        as[i].x += as[i + m].x;  // < 4 MO\r\n        as[i].x = (as[i].x >= MO2) ? (as[i].x - MO2) : as[i].x;  // < 2 MO\r\n        as[i + m].x = (prod.x * y) % MO;  // < MO\r\n      }\r\n      for (int i = i0 + (m >> 1); i < i0 + m; ++i) {\r\n        const unsigned long long y = as[i].x + MO - as[i + m].x;  // < 2 MO\r\n        as[i].x += as[i + m].x;  // < 2 MO\r\n        as[i + m].x = (prod.x * y) % MO;  // < MO\r\n      }\r\n      prod *= INV_FFT_RATIOS[__builtin_ctz(++h)];\r\n    }\r\n  }\r\n  if (m < n) {\r\n    for (int i = 0; i < m; ++i) {\r\n      const unsigned y = as[i].x + MO2 - as[i + m].x;  // < 4 MO\r\n      as[i].x += as[i + m].x;  // < 4 MO\r\n      as[i + m].x = y;  // < 4 MO\r\n    }\r\n  }\r\n  const Mint invN = Mint(n).inv();\r\n  for (int i = 0; i < n; ++i) {\r\n    as[i] *= invN;\r\n  }\r\n}\r\n\r\nvoid fft(vector<Mint> &as) {\r\n  fft(as.data(), as.size());\r\n}\r\nvoid invFft(vector<Mint> &as) {\r\n  invFft(as.data(), as.size());\r\n}\r\n\r\nvector<Mint> convolve(vector<Mint> as, vector<Mint> bs) {\r\n  if (as.empty() || bs.empty()) return {};\r\n  const int len = as.size() + bs.size() - 1;\r\n  int n = 1;\r\n  for (; n < len; n <<= 1) {}\r\n  as.resize(n); fft(as);\r\n  bs.resize(n); fft(bs);\r\n  for (int i = 0; i < n; ++i) as[i] *= bs[i];\r\n  invFft(as);\r\n  as.resize(len);\r\n  return as;\r\n}\r\nvector<Mint> square(vector<Mint> as) {\r\n  if (as.empty()) return {};\r\n  const int len = as.size() + as.size() - 1;\r\n  int n = 1;\r\n  for (; n < len; n <<= 1) {}\r\n  as.resize(n); fft(as);\r\n  for (int i = 0; i < n; ++i) as[i] *= as[i];\r\n  invFft(as);\r\n  as.resize(len);\r\n  return as;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// inv: log, exp, pow\r\n// fac: shift\r\n// invFac: shift\r\nconstexpr int LIM_INV = 1 << 20;  // @\r\nMint inv[LIM_INV], fac[LIM_INV], invFac[LIM_INV];\r\nstruct ModIntPreparator {\r\n  ModIntPreparator() {\r\n    inv[1] = 1;\r\n    for (int i = 2; i < LIM_INV; ++i) inv[i] = -((Mint::M / i) * inv[Mint::M % i]);\r\n    fac[0] = 1;\r\n    for (int i = 1; i < LIM_INV; ++i) fac[i] = fac[i - 1] * i;\r\n    invFac[0] = 1;\r\n    for (int i = 1; i < LIM_INV; ++i) invFac[i] = invFac[i - 1] * inv[i];\r\n  }\r\n} preparator;\r\n\r\n// polyWork0: *, inv, div, divAt, log, exp, pow, sqrt, shift\r\n// polyWork1: inv, div, divAt, log, exp, pow, sqrt, shift\r\n// polyWork2: divAt, exp, pow, sqrt\r\n// polyWork3: exp, pow, sqrt\r\nstatic constexpr int LIM_POLY = 1 << 20;  // @\r\nstatic_assert(LIM_POLY <= 1 << FFT_MAX, \"Poly: LIM_POLY <= 1 << FFT_MAX must hold.\");\r\nstatic Mint polyWork0[LIM_POLY], polyWork1[LIM_POLY], polyWork2[LIM_POLY], polyWork3[LIM_POLY];\r\n\r\nstruct Poly : public vector<Mint> {\r\n  Poly() {}\r\n  explicit Poly(int n,Mint a=0) : vector<Mint>(n,a) {}\r\n  Poly(const vector<Mint> &vec) : vector<Mint>(vec) {}\r\n  Poly(std::initializer_list<Mint> il) : vector<Mint>(il) {}\r\n  int size() const { return vector<Mint>::size(); }\r\n  Mint at(long long k) const { return (0 <= k && k < size()) ? (*this)[k] : 0U; }\r\n  int ord() const { for (int i = 0; i < size(); ++i) if ((*this)[i]) return i; return -1; }\r\n  int deg() const { for (int i = size(); --i >= 0; ) if ((*this)[i]) return i; return -1; }\r\n  Poly mod(int n) const { return Poly(vector<Mint>(data(), data() + min(n, size()))); }\r\n  friend std::ostream &operator<<(std::ostream &os, const Poly &fs) {\r\n    os << \"[\";\r\n    for (int i = 0; i < fs.size(); ++i) { if (i > 0) os << \", \"; os << fs[i]; }\r\n    return os << \"]\";\r\n  }\r\n\r\n  Poly &operator+=(const Poly &fs) {\r\n    if (size() < fs.size()) resize(fs.size());\r\n    for (int i = 0; i < fs.size(); ++i) (*this)[i] += fs[i];\r\n    return *this;\r\n  }\r\n  Poly &operator-=(const Poly &fs) {\r\n    if (size() < fs.size()) resize(fs.size());\r\n    for (int i = 0; i < fs.size(); ++i) (*this)[i] -= fs[i];\r\n    return *this;\r\n  }\r\n  // 3 E(|t| + |f|)\r\n  Poly &operator*=(const Poly &fs) {\r\n    if (empty() || fs.empty()) return *this = {};\r\n    const int nt = size(), nf = fs.size();\r\n    int n = 1;\r\n    for (; n < nt + nf - 1; n <<= 1) {}\r\n    assert(n <= LIM_POLY);\r\n    resize(n);\r\n    fft(data(), n);  // 1 E(n)\r\n    memcpy(polyWork0, fs.data(), nf * sizeof(Mint));\r\n    memset(polyWork0 + nf, 0, (n - nf) * sizeof(Mint));\r\n    fft(polyWork0, n);  // 1 E(n)\r\n    for (int i = 0; i < n; ++i) (*this)[i] *= polyWork0[i];\r\n    invFft(data(), n);  // 1 E(n)\r\n    resize(nt + nf - 1);\r\n    return *this;\r\n  }\r\n  // 13 E(deg(t) - deg(f) + 1)\r\n  // rev(t) = rev(f) rev(q) + x^(deg(t)-deg(f)+1) rev(r)\r\n  Poly &operator/=(const Poly &fs) {\r\n    const int m = deg(), n = fs.deg();\r\n    assert(n != -1);\r\n    if (m < n) return *this = {};\r\n    Poly tsRev(m - n + 1), fsRev(min(m - n, n) + 1);\r\n    for (int i = 0; i <= m - n; ++i) tsRev[i] = (*this)[m - i];\r\n    for (int i = 0, i0 = min(m - n, n); i <= i0; ++i) fsRev[i] = fs[n - i];\r\n    const Poly qsRev = tsRev.div(fsRev, m - n + 1);  // 13 E(m - n + 1)\r\n    resize(m - n + 1);\r\n    for (int i = 0; i <= m - n; ++i) (*this)[i] = qsRev[m - n - i];\r\n    return *this;\r\n  }\r\n  // 13 E(deg(t) - deg(f) + 1) + 3 E(|t|)\r\n  Poly &operator%=(const Poly &fs) {\r\n    const Poly qs = *this / fs;  // 13 E(deg(t) - deg(f) + 1)\r\n    *this -= fs * qs;  // 3 E(|t|)\r\n    resize(deg() + 1);\r\n    return *this;\r\n  }\r\n  Poly &operator*=(const Mint &a) {\r\n    for (int i = 0; i < size(); ++i) (*this)[i] *= a;\r\n    return *this;\r\n  }\r\n  Poly &operator/=(const Mint &a) {\r\n    const Mint b = a.inv();\r\n    for (int i = 0; i < size(); ++i) (*this)[i] *= b;\r\n    return *this;\r\n  }\r\n  Poly operator+() const { return *this; }\r\n  Poly operator-() const {\r\n    Poly fs(size());\r\n    for (int i = 0; i < size(); ++i) fs[i] = -(*this)[i];\r\n    return fs;\r\n  }\r\n  Poly operator+(const Poly &fs) const { return (Poly(*this) += fs); }\r\n  Poly operator-(const Poly &fs) const { return (Poly(*this) -= fs); }\r\n  Poly operator*(const Poly &fs) const { return (Poly(*this) *= fs); }\r\n  Poly operator/(const Poly &fs) const { return (Poly(*this) /= fs); }\r\n  Poly operator%(const Poly &fs) const { return (Poly(*this) %= fs); }\r\n  Poly operator*(const Mint &a) const { return (Poly(*this) *= a); }\r\n  Poly operator/(const Mint &a) const { return (Poly(*this) /= a); }\r\n  friend Poly operator*(const Mint &a, const Poly &fs) { return fs * a; }\r\n\r\n  // 10 E(n)\r\n  // f <- f - (t f - 1) f\r\n  Poly inv(int n) const {\r\n    assert(!empty()); assert((*this)[0]); assert(1 <= n);\r\n    assert(n == 1 || 1 << (32 - __builtin_clz(n - 1)) <= LIM_POLY);\r\n    Poly fs(n);\r\n    fs[0] = (*this)[0].inv();\r\n    for (int m = 1; m < n; m <<= 1) {\r\n      memcpy(polyWork0, data(), min(m << 1, size()) * sizeof(Mint));\r\n      memset(polyWork0 + min(m << 1, size()), 0, ((m << 1) - min(m << 1, size())) * sizeof(Mint));\r\n      fft(polyWork0, m << 1);  // 2 E(n)\r\n      memcpy(polyWork1, fs.data(), min(m << 1, n) * sizeof(Mint));\r\n      memset(polyWork1 + min(m << 1, n), 0, ((m << 1) - min(m << 1, n)) * sizeof(Mint));\r\n      fft(polyWork1, m << 1);  // 2 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork1[i];\r\n      invFft(polyWork0, m << 1); // 2 E(n)\r\n      memset(polyWork0, 0, m * sizeof(Mint));\r\n      fft(polyWork0, m << 1); // 2 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork1[i];\r\n      invFft(polyWork0, m << 1); // 2 E(n)\r\n      for (int i = m, i0 = min(m << 1, n); i < i0; ++i) fs[i] = -polyWork0[i];\r\n    }\r\n    return fs;\r\n  }\r\n  // 9 E(n)\r\n  // Need (4 m)-th roots of unity to lift from (mod x^m) to (mod x^(2m)).\r\n  // f <- f - (t f - 1) f\r\n  // (t f^2) mod ((x^(2m) - 1) (x^m - 1^(1/4)))\r\n  /*\r\n  Poly inv(int n) const {\r\n    assert(!empty()); assert((*this)[0]); assert(1 <= n);\r\n    assert(n == 1 || 3 << (31 - __builtin_clz(n - 1)) <= LIM_POLY);\r\n    assert(n <= 1 << (FFT_MAX - 1));\r\n    Poly fs(n);\r\n    fs[0] = (*this)[0].inv();\r\n    for (int h = 2, m = 1; m < n; ++h, m <<= 1) {\r\n      const Mint a = FFT_ROOTS[h], b = INV_FFT_ROOTS[h];\r\n      memcpy(polyWork0, data(), min(m << 1, size()) * sizeof(Mint));\r\n      memset(polyWork0 + min(m << 1, size()), 0, ((m << 1) - min(m << 1, size())) * sizeof(Mint));\r\n      {\r\n        Mint aa = 1;\r\n        for (int i = 0; i < m; ++i) { polyWork0[(m << 1) + i] = aa * polyWork0[i]; aa *= a; }\r\n        for (int i = 0; i < m; ++i) { polyWork0[(m << 1) + i] += aa * polyWork0[m + i]; aa *= a; }\r\n      }\r\n      fft(polyWork0, m << 1);  // 2 E(n)\r\n      fft(polyWork0 + (m << 1), m);  // 1 E(n)\r\n      memcpy(polyWork1, fs.data(), min(m << 1, n) * sizeof(Mint));\r\n      memset(polyWork1 + min(m << 1, n), 0, ((m << 1) - min(m << 1, n)) * sizeof(Mint));\r\n      {\r\n        Mint aa = 1;\r\n        for (int i = 0; i < m; ++i) { polyWork1[(m << 1) + i] = aa * polyWork1[i]; aa *= a; }\r\n        for (int i = 0; i < m; ++i) { polyWork1[(m << 1) + i] += aa * polyWork1[m + i]; aa *= a; }\r\n      }\r\n      fft(polyWork1, m << 1);  // 2 E(n)\r\n      fft(polyWork1 + (m << 1), m);  // 1 E(n)\r\n      for (int i = 0; i < (m << 1) + m; ++i) polyWork0[i] *= polyWork1[i] * polyWork1[i];\r\n      invFft(polyWork0, m << 1);  // 2 E(n)\r\n      invFft(polyWork0 + (m << 1), m);  // 1 E(n)\r\n      // 2 f0 + (-f2), (-f1) + (-f3), 1^(1/4) (-f1) - (-f2) - 1^(1/4) (-f3)\r\n      {\r\n        Mint bb = 1;\r\n        for (int i = 0, i0 = min(m, n - m); i < i0; ++i) {\r\n          unsigned x = polyWork0[i].x + (bb * polyWork0[(m << 1) + i]).x + MO2 - (fs[i].x << 1);  // < 4 MO\r\n          fs[m + i] = Mint(static_cast<unsigned long long>(FFT_ROOTS[2].x) * x) - polyWork0[m + i];\r\n          fs[m + i].x = ((fs[m + i].x & 1) ? (fs[m + i].x + MO) : fs[m + i].x) >> 1;\r\n          bb *= b;\r\n        }\r\n      }\r\n    }\r\n    return fs;\r\n  }\r\n  */\r\n  // 13 E(n)\r\n  // g = (1 / f) mod x^m\r\n  // h <- h - (f h - t) g\r\n  Poly div(const Poly &fs, int n) const {\r\n    assert(!fs.empty()); assert(fs[0]); assert(1 <= n);\r\n    if (n == 1) return {at(0) / fs[0]};\r\n    // m < n <= 2 m\r\n    const int m = 1 << (31 - __builtin_clz(n - 1));\r\n    assert(m << 1 <= LIM_POLY);\r\n    Poly gs = fs.inv(m);  // 5 E(n)\r\n    gs.resize(m << 1);\r\n    fft(gs.data(), m << 1);  // 1 E(n)\r\n    memcpy(polyWork0, data(), min(m, size()) * sizeof(Mint));\r\n    memset(polyWork0 + min(m, size()), 0, ((m << 1) - min(m, size())) * sizeof(Mint));\r\n    fft(polyWork0, m << 1);  // 1 E(n)\r\n    for (int i = 0; i < m << 1; ++i) polyWork0[i] *= gs[i];\r\n    invFft(polyWork0, m << 1);  // 1 E(n)\r\n    Poly hs(n);\r\n    memcpy(hs.data(), polyWork0, m * sizeof(Mint));\r\n    memset(polyWork0 + m, 0, m * sizeof(Mint));\r\n    fft(polyWork0, m << 1);  // 1 E(n)\r\n    memcpy(polyWork1, fs.data(), min(m << 1, fs.size()) * sizeof(Mint));\r\n    memset(polyWork1 + min(m << 1, fs.size()), 0, ((m << 1) - min(m << 1, fs.size())) * sizeof(Mint));\r\n    fft(polyWork1, m << 1);  // 1 E(n)\r\n    for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork1[i];\r\n    invFft(polyWork0, m << 1);  // 1 E(n)\r\n    memset(polyWork0, 0, m * sizeof(Mint));\r\n    for (int i = m, i0 = min(m << 1, size()); i < i0; ++i) polyWork0[i] -= (*this)[i];\r\n    fft(polyWork0, m << 1);  // 1 E(n)\r\n    for (int i = 0; i < m << 1; ++i) polyWork0[i] *= gs[i];\r\n    invFft(polyWork0, m << 1);  // 1 E(n)\r\n    for (int i = m; i < n; ++i) hs[i] = -polyWork0[i];\r\n    return hs;\r\n  }\r\n  // (4 (floor(log_2 k) - ceil(log_2 |f|)) + 16) E(|f|)  for  |t| < |f|\r\n  // [x^k] (t(x) / f(x)) = [x^k] ((t(x) f(-x)) / (f(x) f(-x))\r\n  // polyWork0: half of (2 m)-th roots of unity, inversed, bit-reversed\r\n  Mint divAt(const Poly &fs, long long k) const {\r\n    assert(k >= 0);\r\n    if (size() >= fs.size()) {\r\n      const Poly qs = *this / fs;  // 13 E(deg(t) - deg(f) + 1)\r\n      Poly rs = *this - fs * qs;  // 3 E(|t|)\r\n      rs.resize(rs.deg() + 1);\r\n      return qs.at(k) + rs.divAt(fs, k);\r\n    }\r\n    int h = 0, m = 1;\r\n    for (; m < fs.size(); ++h, m <<= 1) {}\r\n    if (k < m) {\r\n      const Poly gs = fs.inv(k + 1);  // 10 E(|f|)\r\n      Mint sum;\r\n      for (int i = 0, i0 = min<int>(k + 1, size()); i < i0; ++i) sum += (*this)[i] * gs[k - i];\r\n      return sum;\r\n    }\r\n    assert(m << 1 <= LIM_POLY);\r\n    polyWork0[0] = Mint(2U).inv();\r\n    for (int hh = 0; hh < h; ++hh) for (int i = 0; i < 1 << hh; ++i) polyWork0[1 << hh | i] = polyWork0[i] * INV_FFT_ROOTS[hh + 2];\r\n    const Mint a = FFT_ROOTS[h + 1];\r\n    memcpy(polyWork2, data(), size() * sizeof(Mint));\r\n    memset(polyWork2 + size(), 0, ((m << 1) - size()) * sizeof(Mint));\r\n    fft(polyWork2, m << 1);  // 2 E(|f|)\r\n    memcpy(polyWork1, fs.data(), fs.size() * sizeof(Mint));\r\n    memset(polyWork1 + fs.size(), 0, ((m << 1) - fs.size()) * sizeof(Mint));\r\n    fft(polyWork1, m << 1);  // 2 E(|f|)\r\n    for (; ; ) {\r\n      if (k & 1) {\r\n        for (int i = 0; i < m; ++i) polyWork2[i] = polyWork0[i] * (polyWork2[i << 1 | 0] * polyWork1[i << 1 | 1] - polyWork2[i << 1 | 1] * polyWork1[i << 1 | 0]);\r\n      } else {\r\n        for (int i = 0; i < m; ++i) {\r\n          polyWork2[i] = polyWork2[i << 1 | 0] * polyWork1[i << 1 | 1] + polyWork2[i << 1 | 1] * polyWork1[i << 1 | 0];\r\n          polyWork2[i].x = ((polyWork2[i].x & 1) ? (polyWork2[i].x + MO) : polyWork2[i].x) >> 1;\r\n        }\r\n      }\r\n      for (int i = 0; i < m; ++i) polyWork1[i] = polyWork1[i << 1 | 0] * polyWork1[i << 1 | 1];\r\n      if ((k >>= 1) < m) {\r\n        invFft(polyWork2, m);  // 1 E(|f|)\r\n        invFft(polyWork1, m);  // 1 E(|f|)\r\n        // Poly::inv does not use polyWork2\r\n        const Poly gs = Poly(vector<Mint>(polyWork1, polyWork1 + k + 1)).inv(k + 1);  // 10 E(|f|)\r\n        Mint sum;\r\n        for (int i = 0; i <= k; ++i) sum += polyWork2[i] * gs[k - i];\r\n        return sum;\r\n      }\r\n      memcpy(polyWork2 + m, polyWork2, m * sizeof(Mint));\r\n      invFft(polyWork2 + m, m);  // (floor(log_2 k) - ceil(log_2 |f|)) E(|f|)\r\n      memcpy(polyWork1 + m, polyWork1, m * sizeof(Mint));\r\n      invFft(polyWork1 + m, m);  // (floor(log_2 k) - ceil(log_2 |f|)) E(|f|)\r\n      Mint aa = 1;\r\n      for (int i = m; i < m << 1; ++i) { polyWork2[i] *= aa; polyWork1[i] *= aa; aa *= a; }\r\n      fft(polyWork2 + m, m);  // (floor(log_2 k) - ceil(log_2 |f|)) E(|f|)\r\n      fft(polyWork1 + m, m);  // (floor(log_2 k) - ceil(log_2 |f|)) E(|f|)\r\n    }\r\n  }\r\n  // 13 E(n)\r\n  // D log(t) = (D t) / t\r\n  Poly log(int n) const {\r\n    assert(!empty()); assert((*this)[0].x == 1U); assert(n <= LIM_INV);\r\n    Poly fs = mod(n);\r\n    for (int i = 0; i < fs.size(); ++i) fs[i] *= i;\r\n    fs = fs.div(*this, n);\r\n    for (int i = 1; i < n; ++i) fs[i] *= ntt::inv[i];\r\n    return fs;\r\n  }\r\n  // (16 + 1/2) E(n)\r\n  // f = exp(t) mod x^m  ==>  (D f) / f == D t  (mod x^m)\r\n  // g = (1 / exp(t)) mod x^m\r\n  // f <- f - (log f - t) / (1 / f)\r\n  //   =  f - (I ((D f) / f) - t) f\r\n  //   == f - (I ((D f) / f + (f g - 1) ((D f) / f - D (t mod x^m))) - t) f  (mod x^(2m))\r\n  //   =  f - (I (g (D f - f D (t mod x^m)) + D (t mod x^m)) - t) f\r\n  // g <- g - (f g - 1) g\r\n  // polyWork1: DFT(f, 2 m), polyWork2: g, polyWork3: DFT(g, 2 m)\r\n  Poly exp(int n) const {\r\n    assert(!empty()); assert(!(*this)[0]); assert(1 <= n);\r\n    assert(n == 1 || 1 << (32 - __builtin_clz(n - 1)) <= min(LIM_INV, LIM_POLY));\r\n    if (n == 1) return {1U};\r\n    if (n == 2) return {1U, at(1)};\r\n    Poly fs(n);\r\n    fs[0].x = polyWork1[0].x = polyWork1[1].x = polyWork2[0].x = 1U;\r\n    int m;\r\n    for (m = 1; m << 1 < n; m <<= 1) {\r\n      for (int i = 0, i0 = min(m, size()); i < i0; ++i) polyWork0[i] = i * (*this)[i];\r\n      memset(polyWork0 + min(m, size()), 0, (m - min(m, size())) * sizeof(Mint));\r\n      fft(polyWork0, m);  // (1/2) E(n)\r\n      for (int i = 0; i < m; ++i) polyWork0[i] *= polyWork1[i];\r\n      invFft(polyWork0, m);  // (1/2) E(n)\r\n      for (int i = 0; i < m; ++i) polyWork0[i] -= i * fs[i];\r\n      memset(polyWork0 + m, 0, m * sizeof(Mint));\r\n      fft(polyWork0, m << 1);  // 1 E(n)\r\n      memcpy(polyWork3, polyWork2, m * sizeof(Mint));\r\n      memset(polyWork3 + m, 0, m * sizeof(Mint));\r\n      fft(polyWork3, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork3[i];\r\n      invFft(polyWork0, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m; ++i) polyWork0[i] *= ntt::inv[m + i];\r\n      for (int i = 0, i0 = min(m, size() - m); i < i0; ++i) polyWork0[i] += (*this)[m + i];\r\n      memset(polyWork0 + m, 0, m * sizeof(Mint));\r\n      fft(polyWork0, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork1[i];\r\n      invFft(polyWork0, m << 1);  // 1 E(n)\r\n      memcpy(fs.data() + m, polyWork0, m * sizeof(Mint));\r\n      memcpy(polyWork1, fs.data(), (m << 1) * sizeof(Mint));\r\n      memset(polyWork1 + (m << 1), 0, (m << 1) * sizeof(Mint));\r\n      fft(polyWork1, m << 2);  // 2 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] = polyWork1[i] * polyWork3[i];\r\n      invFft(polyWork0, m << 1);  // 1 E(n)\r\n      memset(polyWork0, 0, m * sizeof(Mint));\r\n      fft(polyWork0, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork3[i];\r\n      invFft(polyWork0, m << 1);  // 1 E(n)\r\n      for (int i = m; i < m << 1; ++i) polyWork2[i] = -polyWork0[i];\r\n    }\r\n    for (int i = 0, i0 = min(m, size()); i < i0; ++i) polyWork0[i] = i * (*this)[i];\r\n    memset(polyWork0 + min(m, size()), 0, (m - min(m, size())) * sizeof(Mint));\r\n    fft(polyWork0, m);  // (1/2) E(n)\r\n    for (int i = 0; i < m; ++i) polyWork0[i] *= polyWork1[i];\r\n    invFft(polyWork0, m);  // (1/2) E(n)\r\n    for (int i = 0; i < m; ++i) polyWork0[i] -= i * fs[i];\r\n    memcpy(polyWork0 + m, polyWork0 + (m >> 1), (m >> 1) * sizeof(Mint));\r\n    memset(polyWork0 + (m >> 1), 0, (m >> 1) * sizeof(Mint));\r\n    memset(polyWork0 + m + (m >> 1), 0, (m >> 1) * sizeof(Mint));\r\n    fft(polyWork0, m);  // (1/2) E(n)\r\n    fft(polyWork0 + m, m);  // (1/2) E(n)\r\n    memcpy(polyWork3 + m, polyWork2 + (m >> 1), (m >> 1) * sizeof(Mint));\r\n    memset(polyWork3 + m + (m >> 1), 0, (m >> 1) * sizeof(Mint));\r\n    fft(polyWork3 + m, m);  // (1/2) E(n)\r\n    for (int i = 0; i < m; ++i) polyWork0[m + i] = polyWork0[i] * polyWork3[m + i] + polyWork0[m + i] * polyWork3[i];\r\n    for (int i = 0; i < m; ++i) polyWork0[i] *= polyWork3[i];\r\n    invFft(polyWork0, m);  // (1/2) E(n)\r\n    invFft(polyWork0 + m, m);  // (1/2) E(n)\r\n    for (int i = 0; i < m >> 1; ++i) polyWork0[(m >> 1) + i] += polyWork0[m + i];\r\n    for (int i = 0; i < m; ++i) polyWork0[i] *= ntt::inv[m + i];\r\n    for (int i = 0, i0 = min(m, size() - m); i < i0; ++i) polyWork0[i] += (*this)[m + i];\r\n    memset(polyWork0 + m, 0, m * sizeof(Mint));\r\n    fft(polyWork0, m << 1);  // 1 E(n)\r\n    for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork1[i];\r\n    invFft(polyWork0, m << 1);  // 1 E(n)\r\n    memcpy(fs.data() + m, polyWork0, (n - m) * sizeof(Mint));\r\n    return fs;\r\n  }\r\n  // (29 + 1/2) E(n)\r\n  // g <- g - (log g - a log t) g\r\n  Poly pow(Mint a, int n) const {\r\n    assert(!empty()); assert((*this)[0].x == 1U); assert(1 <= n);\r\n    return (a * log(n)).exp(n);  // 13 E(n) + (16 + 1/2) E(n)\r\n  }\r\n  // (29 + 1/2) E(n - a ord(t))\r\n  Poly pow(long long a, int n) const {\r\n    assert(a >= 0); assert(1 <= n);\r\n    if (a == 0) { Poly gs(n); gs[0].x = 1U; return gs; }\r\n    const int o = ord();\r\n    if (o == -1 || o > (n - 1) / a) return Poly(n);\r\n    const Mint b = (*this)[o].inv(), c = (*this)[o].pow(a);\r\n    const int ntt = min<int>(n - a * o, size() - o);\r\n    Poly tts(ntt);\r\n    for (int i = 0; i < ntt; ++i) tts[i] = b * (*this)[o + i];\r\n    tts = tts.pow(Mint(a), n - a * o);  // (29 + 1/2) E(n - a ord(t))\r\n    Poly gs(n);\r\n    for (int i = 0; i < n - a * o; ++i) gs[a * o + i] = c * tts[i];\r\n    return gs;\r\n  }\r\n  // (10 + 1/2) E(n)\r\n  // f = t^(1/2) mod x^m,  g = 1 / t^(1/2) mod x^m\r\n  // f <- f - (f^2 - h) g / 2\r\n  // g <- g - (f g - 1) g\r\n  // polyWork1: DFT(f, m), polyWork2: g, polyWork3: DFT(g, 2 m)\r\n  Poly sqrt(int n) const {\r\n    assert(!empty()); assert((*this)[0].x == 1U); assert(1 <= n);\r\n    assert(n == 1 || 1 << (32 - __builtin_clz(n - 1)) <= LIM_POLY);\r\n    if (n == 1) return {1U};\r\n    if (n == 2) return {1U, at(1) / 2};\r\n    Poly fs(n);\r\n    fs[0].x = polyWork1[0].x = polyWork2[0].x = 1U;\r\n    int m;\r\n    for (m = 1; m << 1 < n; m <<= 1) {\r\n      for (int i = 0; i < m; ++i) polyWork1[i] *= polyWork1[i];\r\n      invFft(polyWork1, m);  // (1/2) E(n)\r\n      for (int i = 0, i0 = min(m, size()); i < i0; ++i) polyWork1[i] -= (*this)[i];\r\n      for (int i = 0, i0 = min(m, size() - m); i < i0; ++i) polyWork1[i] -= (*this)[m + i];\r\n      memset(polyWork1 + m, 0, m * sizeof(Mint));\r\n      fft(polyWork1, m << 1);  // 1 E(n)\r\n      memcpy(polyWork3, polyWork2, m * sizeof(Mint));\r\n      memset(polyWork3 + m, 0, m * sizeof(Mint));\r\n      fft(polyWork3, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork1[i] *= polyWork3[i];\r\n      invFft(polyWork1, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m; ++i) { polyWork1[i] = -polyWork1[i]; fs[m + i].x = ((polyWork1[i].x & 1) ? (polyWork1[i].x + MO) : polyWork1[i].x) >> 1; }\r\n      memcpy(polyWork1, fs.data(), (m << 1) * sizeof(Mint));\r\n      fft(polyWork1, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] = polyWork1[i] * polyWork3[i];\r\n      invFft(polyWork0, m << 1);  // 1 E(n)\r\n      memset(polyWork0, 0, m * sizeof(Mint));\r\n      fft(polyWork0, m << 1);  // 1 E(n)\r\n      for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork3[i];\r\n      invFft(polyWork0, m << 1);  // 1 E(n)\r\n      for (int i = m; i < m << 1; ++i) polyWork2[i] = -polyWork0[i];\r\n    }\r\n    for (int i = 0; i < m; ++i) polyWork1[i] *= polyWork1[i];\r\n    invFft(polyWork1, m);  // (1/2) E(n)\r\n    for (int i = 0, i0 = min(m, size()); i < i0; ++i) polyWork1[i] -= (*this)[i];\r\n    for (int i = 0, i0 = min(m, size() - m); i < i0; ++i) polyWork1[i] -= (*this)[m + i];\r\n    memcpy(polyWork1 + m, polyWork1 + (m >> 1), (m >> 1) * sizeof(Mint));\r\n    memset(polyWork1 + (m >> 1), 0, (m >> 1) * sizeof(Mint));\r\n    memset(polyWork1 + m + (m >> 1), 0, (m >> 1) * sizeof(Mint));\r\n    fft(polyWork1, m);  // (1/2) E(n)\r\n    fft(polyWork1 + m, m);  // (1/2) E(n)\r\n    memcpy(polyWork3 + m, polyWork2 + (m >> 1), (m >> 1) * sizeof(Mint));\r\n    memset(polyWork3 + m + (m >> 1), 0, (m >> 1) * sizeof(Mint));\r\n    fft(polyWork3 + m, m);  // (1/2) E(n)\r\n    // for (int i = 0; i < m << 1; ++i) polyWork1[i] *= polyWork3[i];\r\n    for (int i = 0; i < m; ++i) polyWork1[m + i] = polyWork1[i] * polyWork3[m + i] + polyWork1[m + i] * polyWork3[i];\r\n    for (int i = 0; i < m; ++i) polyWork1[i] *= polyWork3[i];\r\n    invFft(polyWork1, m);  // (1/2) E(n)\r\n    invFft(polyWork1 + m, m);  // (1/2) E(n)\r\n    for (int i = 0; i < m >> 1; ++i) polyWork1[(m >> 1) + i] += polyWork1[m + i];\r\n    for (int i = 0; i < n - m; ++i) { polyWork1[i] = -polyWork1[i]; fs[m + i].x = ((polyWork1[i].x & 1) ? (polyWork1[i].x + MO) : polyWork1[i].x) >> 1; }\r\n    return fs;\r\n  }\r\n  // (10 + 1/2) E(n)\r\n  // modSqrt must return a quadratic residue if exists, or anything otherwise.\r\n  // Return {} if *this does not have a square root.\r\n  template <class F> Poly sqrt(int n, F modSqrt) const {\r\n    assert(1 <= n);\r\n    const int o = ord();\r\n    if (o == -1) return Poly(n);\r\n    if (o & 1) return {};\r\n    const Mint c = modSqrt((*this)[o]);\r\n    cerr<<(*this)[o]<<endl;\r\n    cerr<<c<<endl;\r\n    if (c * c != (*this)[o]) return {};\r\n    if (o >> 1 >= n) return Poly(n);\r\n    const Mint b = (*this)[o].inv();\r\n    const int ntt = min(n - (o >> 1), size() - o);\r\n    Poly tts(ntt);\r\n    for (int i = 0; i < ntt; ++i) tts[i] = b * (*this)[o + i];\r\n    tts = tts.sqrt(n - (o >> 1));  // (10 + 1/2) E(n)\r\n    Poly gs(n);\r\n    for (int i = 0; i < n - (o >> 1); ++i) gs[(o >> 1) + i] = c * tts[i];\r\n    return gs;\r\n  }\r\n  // 6 E(|t|)\r\n  // x -> x + a\r\n  Poly shift(const Mint &a) const {\r\n    if (empty()) return {};\r\n    const int n = size();\r\n    int m = 1;\r\n    for (; m < n; m <<= 1) {}\r\n    for (int i = 0; i < n; ++i) polyWork0[i] = fac[i] * (*this)[i];\r\n    memset(polyWork0 + n, 0, ((m << 1) - n) * sizeof(Mint));\r\n    fft(polyWork0, m << 1);  // 2 E(|t|)\r\n    {\r\n      Mint aa = 1;\r\n      for (int i = 0; i < n; ++i) { polyWork1[n - 1 - i] = invFac[i] * aa; aa *= a; }\r\n    }\r\n    memset(polyWork1 + n, 0, ((m << 1) - n) * sizeof(Mint));\r\n    fft(polyWork1, m << 1);  // 2 E(|t|)\r\n    for (int i = 0; i < m << 1; ++i) polyWork0[i] *= polyWork1[i];\r\n    invFft(polyWork0, m << 1);  // 2 E(|t|)\r\n    Poly fs(n);\r\n    for (int i = 0; i < n; ++i) fs[i] = invFac[i] * polyWork0[n - 1 + i];\r\n    return fs;\r\n  }\r\n};\r\n\r\nMint linearRecurrenceAt(const vector<Mint> &as, const vector<Mint> &cs, long long k) {\r\n  assert(!cs.empty()); assert(cs[0]);\r\n  const int d = cs.size() - 1;\r\n  assert(as.size() >= static_cast<size_t>(d));\r\n  return (Poly(vector<Mint>(as.begin(), as.begin() + d)) * cs).mod(d).divAt(cs, k);\r\n}\r\n\r\nstruct SubproductTree {\r\n  int logN, n, nn;\r\n  vector<Mint> xs;\r\n  // [DFT_4((X-xs[0])(X-xs[1])(X-xs[2])(X-xs[3]))] [(X-xs[0])(X-xs[1])(X-xs[2])(X-xs[3])mod X^4]\r\n  // [         DFT_4((X-xs[0])(X-xs[1]))         ] [         DFT_4((X-xs[2])(X-xs[3]))         ]\r\n  // [   DFT_2(X-xs[0])   ] [   DFT_2(X-xs[1])   ] [   DFT_2(X-xs[2])   ] [   DFT_2(X-xs[3])   ]\r\n  vector<Mint> buf;\r\n  vector<Mint *> gss;\r\n  // (1 - xs[0] X) ... (1 - xs[nn-1] X)\r\n  Poly all;\r\n  // (ceil(log_2 n) + O(1)) E(n)\r\n  SubproductTree(const vector<Mint> &xs_) {\r\n    n = xs_.size();\r\n    for (logN = 0, nn = 1; nn < n; ++logN, nn <<= 1) {}\r\n    xs.assign(nn, 0U);\r\n    memcpy(xs.data(), xs_.data(), n * sizeof(Mint));\r\n    buf.assign((logN + 1) * (nn << 1), 0U);\r\n    gss.assign(nn << 1, nullptr);\r\n    for (int h = 0; h <= logN; ++h) for (int u = 1 << h; u < 1 << (h + 1); ++u) {\r\n      gss[u] = buf.data() + (h * (nn << 1) + ((u - (1 << h)) << (logN - h + 1)));\r\n    }\r\n    for (int i = 0; i < nn; ++i) {\r\n      gss[nn + i][0] = -xs[i] + 1;\r\n      gss[nn + i][1] = -xs[i] - 1;\r\n    }\r\n    if (nn == 1) gss[1][1] += 2;\r\n    for (int h = logN; --h >= 0; ) {\r\n      const int m = 1 << (logN - h);\r\n      for (int u = 1 << (h + 1); --u >= 1 << h; ) {\r\n        for (int i = 0; i < m; ++i) gss[u][i] = gss[u << 1][i] * gss[u << 1 | 1][i];\r\n        memcpy(gss[u] + m, gss[u], m * sizeof(Mint));\r\n        invFft(gss[u] + m, m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n        if (h > 0) {\r\n          gss[u][m] -= 2;\r\n          const Mint a = FFT_ROOTS[logN - h + 1];\r\n          Mint aa = 1;\r\n          for (int i = m; i < m << 1; ++i) { gss[u][i] *= aa; aa *= a; };\r\n          fft(gss[u] + m, m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n        }\r\n      }\r\n    }\r\n    all.resize(nn + 1);\r\n    all[0] = 1;\r\n    for (int i = 1; i < nn; ++i) all[i] = gss[1][nn + nn - i];\r\n    all[nn] = gss[1][nn] - 1;\r\n  }\r\n  // ((3/2) ceil(log_2 n) + O(1)) E(n) + 10 E(|f|) + 3 E(|f| + 2^(ceil(log_2 n)))\r\n  // y0 ~ yn-1 <- fs, x0 ~ xn-1\r\n  vector<Mint> multiEval(const Poly &fs) const {\r\n    vector<Mint> work0(nn), work1(nn), work2(nn);\r\n    {\r\n      const int m = max(fs.size(), 1);\r\n      auto invAll = all.inv(m);  // 10 E(|f|)\r\n      std::reverse(invAll.begin(), invAll.end());\r\n      int mm;\r\n      for (mm = 1; mm < m - 1 + nn; mm <<= 1) {}\r\n      invAll.resize(mm, 0U);\r\n      fft(invAll);  // E(|f| + 2^(ceil(log_2 n)))\r\n      vector<Mint> ffs(mm, 0U);\r\n      memcpy(ffs.data(), fs.data(), fs.size() * sizeof(Mint));\r\n      fft(ffs);  // E(|f| + 2^(ceil(log_2 n)))\r\n      for (int i = 0; i < mm; ++i) ffs[i] *= invAll[i];\r\n      invFft(ffs);  // E(|f| + 2^(ceil(log_2 n)))\r\n      memcpy(((logN & 1) ? work1 : work0).data(), ffs.data() + m - 1, nn * sizeof(Mint));\r\n    }\r\n    for (int h = 0; h < logN; ++h) {\r\n      const int m = 1 << (logN - h);\r\n      for (int u = 1 << h; u < 1 << (h + 1); ++u) {\r\n        Mint *hs = (((logN - h) & 1) ? work1 : work0).data() + ((u - (1 << h)) << (logN - h));\r\n        Mint *hs0 = (((logN - h) & 1) ? work0 : work1).data() + ((u - (1 << h)) << (logN - h));\r\n        Mint *hs1 = hs0 + (m >> 1);\r\n        fft(hs, m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n        for (int i = 0; i < m; ++i) work2[i] = gss[u << 1 | 1][i] * hs[i];\r\n        invFft(work2.data(), m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n        memcpy(hs0, work2.data() + (m >> 1), (m >> 1) * sizeof(Mint));\r\n        for (int i = 0; i < m; ++i) work2[i] = gss[u << 1][i] * hs[i];\r\n        invFft(work2.data(), m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n        memcpy(hs1, work2.data() + (m >> 1), (m >> 1) * sizeof(Mint));\r\n      }\r\n    }\r\n    work0.resize(n);\r\n    return work0;\r\n  }\r\n  // ((5/2) ceil(log_2 n) + O(1)) E(n)\r\n  // Poly f, f(x)=y <- x0 ~ xn-1,y0 ~ yn-1\r\n  Poly interpolate(const vector<Mint> &ys) const {\r\n    assert(static_cast<int>(ys.size()) == n);\r\n    Poly gs(n);\r\n    for (int i = 0; i < n; ++i) gs[i] = (i + 1) * all[n - (i + 1)];\r\n    const vector<Mint> denoms = multiEval(gs);  // ((3/2) ceil(log_2 n) + O(1)) E(n)\r\n    vector<Mint> work(nn << 1, 0U);\r\n    for (int i = 0; i < n; ++i) {\r\n      // xs[0], ..., xs[n - 1] are not distinct\r\n      assert(denoms[i]);\r\n      work[i << 1] = work[i << 1 | 1] = ys[i] / denoms[i];\r\n    }\r\n    for (int h = logN; --h >= 0; ) {\r\n      const int m = 1 << (logN - h);\r\n      for (int u = 1 << (h + 1); --u >= 1 << h; ) {\r\n        Mint *hs = work.data() + ((u - (1 << h)) << (logN - h + 1));\r\n        for (int i = 0; i < m; ++i) hs[i] = gss[u << 1 | 1][i] * hs[i] + gss[u << 1][i] * hs[m + i];\r\n        if (h > 0) {\r\n          memcpy(hs + m, hs, m * sizeof(Mint));\r\n          invFft(hs + m, m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n          const Mint a = FFT_ROOTS[logN - h + 1];\r\n          Mint aa = 1;\r\n          for (int i = m; i < m << 1; ++i) { hs[i] *= aa; aa *= a; };\r\n          fft(hs + m, m);  // ((1/2) ceil(log_2 n) + O(1)) E(n)\r\n        }\r\n      }\r\n    }\r\n    invFft(work.data(), nn);  // E(n)\r\n    return Poly(vector<Mint>(work.data() + nn - n, work.data() + nn));\r\n  }\r\n};\r\n////////////////////////////////////////////////////////////////////////////////\r\n}\r\nusing ntt::Poly;\r\nusing ntt::Mint;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\r\n    int n,m,k;\r\n    cin>>n>>m>>k;\r\n    Poly f(n+1);\r\n    for(int i=1; i<=n; ++i)\r\n        f[i]=(i>=k+1)+(k+1<=i && i<=2*k);\r\n    f=f.pow(m,n+1);\r\n    cout<<accumulate(f.begin(),f.end(),Mint());\r\n    // cout<<Z(2).pow(m)*binom(n-m*k,m)<<endl;\r\n    // dp[i][j]:\u8868\u793a\u524dj\u9897\u6811\u5360\u636e\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u4e3ai\u7684\u65b9\u6848\u6570\r\n    // vector<vector<Z>> dp(n+2,vector<Z>(m+2));\r\n    // dp[0][0]=1;\r\n    // for(int j=1; j<=m; ++j) {\r\n    //     for(int i=1; i<=n; ++i) {// \u679a\u4e3e\u7b2cj\u9897\u6811\u7684\u4f4d\u7f6e\r\n    //         for(int l=0; l<i; ++l) {// \u4e0a\u4e00\u9897\u6811\u5012\u4e0b\u7684\u4f4d\u7f6e\r\n    //             if(l+k<i)\r\n    //                 dp[i][j]+=dp[l][j-1];\r\n    //             else if(i+k<=n)\r\n    //                 dp[i+k][j]+=dp[l][j-1];\r\n    //         }\r\n    //     }\r\n    // }\r\n    // Z ans=0;\r\n    // for(int i=1; i<=n; ++i) \r\n    //     ans+=dp[i][m];\r\n    // cout<<ans;\r\n    return 0;\r\n}\r\n/*\r\n\r\n\r\n\r\n\r\n*/"
}