{
    "id": 205331658,
    "contestId": 1821,
    "creationTimeSeconds": 1683724818,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "koooooooooooooooo"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 99,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 8396800,
    "source": "#include <bits/stdc++.h>\r\n#define int128_t __int128\r\nusing namespace std ;\r\n\r\ntemplate <typename T>\r\nT inverse(T a, T m) {\r\n  T u = 0, v = 1;\r\n  while (a != 0) {\r\n    T t = m / a;\r\n    m -= t * a; swap(a, m);\r\n    u -= t * v; swap(u, v);\r\n  }\r\n  assert(m == 1);\r\n  return u;\r\n}\r\n\r\ntemplate <typename T>\r\nclass Modular {\r\n public:\r\n  using Type = typename decay<decltype(T::value)>::type;\r\n\r\n  constexpr Modular() : value() {}\r\n  template <typename U>\r\n  Modular(const U& x) {\r\n    value = normalize(x);\r\n  }\r\n\r\n  template <typename U>\r\n  static Type normalize(const U& x) {\r\n    Type v;\r\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\r\n    else v = static_cast<Type>(x % mod());\r\n    if (v < 0) v += mod();\r\n    return v;\r\n  }\r\n\r\n  const Type& operator()() const { return value; }\r\n  template <typename U>\r\n  explicit operator U() const { return static_cast<U>(value); }\r\n  constexpr static Type mod() { return T::value; }\r\n\r\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\r\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\r\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\r\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\r\n  Modular& operator++() { return *this += 1; }\r\n  Modular& operator--() { return *this -= 1; }\r\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\r\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\r\n  Modular operator-() const { return Modular(-value); }\r\n\r\n  template <typename U = T>\r\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n#ifdef _WIN32\r\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\r\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\r\n    asm(\r\n      \"divl %4; \\n\\t\"\r\n      : \"=a\" (d), \"=d\" (m)\r\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\r\n    );\r\n    value = m;\r\n#else\r\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\r\n#endif\r\n    return *this;\r\n  }\r\n  template <typename U = T>\r\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\r\n    value = normalize(value * rhs.value - q * mod());\r\n    return *this;\r\n  }\r\n  template <typename U = T>\r\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n    value = normalize(value * rhs.value);\r\n    return *this;\r\n  }\r\n\r\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\r\n\r\n  template <typename U>\r\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\r\n\r\n  template <typename U>\r\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\r\n\r\n  template <typename U>\r\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\r\n\r\n private:\r\n  Type value;\r\n};\r\n\r\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\r\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\r\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\r\n\r\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\r\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r\n\r\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\r\n\r\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r\n\r\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r\n\r\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r\n\r\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r\n\r\ntemplate<typename T, typename U>\r\nModular<T> power(const Modular<T>& a, const U& b) {\r\n  assert(b >= 0);\r\n  Modular<T> x = a, res = 1;\r\n  U p = b;\r\n  while (p > 0) {\r\n    if (p & 1) res *= x;\r\n    x *= x;\r\n    p >>= 1;\r\n  }\r\n  return res;\r\n}\r\n\r\ntemplate <typename T>\r\nstring to_string(const Modular<T>& number) {\r\n  return to_string(number());\r\n}\r\n\r\ntemplate <typename T>\r\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\r\n  return stream << number();\r\n}\r\n\r\ntemplate <typename T>\r\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\r\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\r\n  stream >> x;\r\n  number.value = Modular<T>::normalize(x);\r\n  return stream;\r\n}\r\n\r\n/*\r\nusing ModType = int;\r\n\r\nstruct VarMod { static ModType value; };\r\nModType VarMod::value;\r\nModType& md = VarMod::value;\r\nusing Mint = Modular<VarMod>;\r\n*/\r\n\r\nconstexpr int md = 998244353 ;\r\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\r\n\r\nnamespace simp {\r\n  vector<Mint> fac,ifac,invn;\r\n  void check(int x) {\r\n    if (fac.empty()) {\r\n      fac={Mint(1),Mint(1)};\r\n      ifac={Mint(1),Mint(1)};\r\n      invn={Mint(0),Mint(1)};\r\n    }\r\n    while (fac.size()<=x) {\r\n      int n = fac.size(), m = fac.size() * 2;\r\n      fac.resize(m);\r\n      ifac.resize(m);\r\n      invn.resize(m);\r\n      for (int i=n;i<m;i++) {\r\n        fac[i]=fac[i-1]*Mint(i);\r\n        invn[i]=Mint(md-md/i)*invn[md%i];\r\n        ifac[i]=ifac[i-1]*invn[i];\r\n      }\r\n    }\r\n  }\r\n  Mint gfac(int x) {\r\n    check(x); return fac[x];\r\n  }\r\n  Mint jie(int x) {\r\n    check(x); return fac[x];\r\n  }\r\n  Mint ginv(int x) {\r\n    check(x); return invn[x];\r\n  }\r\n  Mint gifac(int x) {\r\n    check(x); return ifac[x];\r\n  }\r\n  Mint fan(int x) {\r\n    check(x); return ifac[x];\r\n  }\r\n  Mint binom(int n,int m) {\r\n    if (m < 0 || m > n) return Mint(0);\r\n    return gfac(n)*gifac(m)*gifac(n - m);\r\n  }\r\n  Mint C(int n,int m) {\r\n    return binom(n,m);\r\n  }\r\n}\r\n\r\nint main(){\r\n  long long n ,m ,k ;\r\n  cin >> n >> m >> k ;\r\n  Mint ans = 0 ;\r\n  Mint step = 1 ;\r\n  for( int i = m ;i >= 0 ;i -- ){\r\n    if( n-i*k-(m-i)*2*k < 0 ) continue ;\r\n    ans += simp::C( n-i*k-(m-i)*2*k ,m ) * simp::C(m,i) * power( Mint(2) ,i ) * step ;\r\n    step *= -1 ;\r\n  }\r\n  cout << ans << endl ;\r\n}"
}