{
    "id": 218789403,
    "contestId": 1821,
    "creationTimeSeconds": 1692013718,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "tkacper"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 99,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 11980800,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n\r\n#ifdef DEBUG\r\n#include \"debug.h\"\r\n#else\r\n#define debug(...) 42\r\n#endif\r\n\r\n#define all(x) begin(x), end(x)\r\n#define rall(x) rbegin(x), rend(x)\r\n#define each(a, x) for(auto& a : (x))\r\n\r\n#define rep(i, n) for (int i = 0; i < (n); ++i)\r\n#define repp(i, n, m) for (int i = (n); i < (m); ++i)\r\n\r\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\r\n#define reppr(i, n, m) for (int i = (m) - 1; i >= (n); --i)\r\n\r\n#define sz(x) int((x).size())\r\n\r\nusing vi = vector<int>;\r\nusing vvi = vector<vi>;\r\nusing vll = vector<ll>;\r\nusing pi = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\n\r\ntemplate <typename T, typename V> void mini(T& a, V b) {if (b < a) a = b; }\r\ntemplate <typename T, typename V> void maxi(T& a, V b) {if (b > a) a = b; }\r\n\r\nconst int P = 998244353, phiP = P - 1;\r\nstruct modint {\r\n    int x = 0;\r\n    modint operator+(modint o) const {return {x + o.x >= P ? x + o.x - P : x + o.x}; }\r\n    modint operator-(modint o) const {return {x - o.x < 0 ? x - o.x + P : x - o.x}; }\r\n    modint operator+() const {return *this; }\r\n    modint operator-() const {return {x ? P - x : 0}; }\r\n    modint operator*(modint o) const {return {int(ll(x) * o.x % P)}; }\r\n    modint operator/(modint o) const {return *this * o.inv(); }\r\n    modint & operator+=(modint o) {return *this = *this + o; }\r\n    modint & operator-=(modint o) {return *this = *this - o; }\r\n    modint & operator*=(modint o) {return *this = *this * o; }\r\n    modint & operator/=(modint o) {return *this = *this / o; }\r\n    modint pow(ll e) const {\r\n        modint ret{1}, b(*this);\r\n        for (; e; e >>= 1) {\r\n            if (e & 1)\r\n                ret *= b;\r\n            b *= b;\r\n        }\r\n        return ret;\r\n    }\r\n    modint inv() const {return pow(phiP - 1); }\r\n    friend void __dbg(modint m) {\r\n        cout << m.x - P * (2 * m.x >= P);\r\n    }\r\n};\r\n\r\nvoid solve() {\r\n    vector<modint> fact = {modint{1}}, ifact = {modint{1}};\r\n    rep(_, 7e5) {\r\n        fact.push_back(fact.back() * modint{sz(fact)});\r\n        ifact.push_back(fact.back().inv());\r\n    }\r\n\r\n    int n, m, k;\r\n    cin >> n >> m >> k;\r\n    debug(n, m, k);\r\n\r\n    vector<modint> tp(n+1);\r\n    modint twopow{(P+1)/2};\r\n    for (int i = 0; i <= m; ++i) {\r\n        twopow *= modint{2};\r\n        ll exp = ll(2*k+1) * (m-i) + ll(k+1) * i;\r\n        debug(i, exp);\r\n        if (exp >= sz(tp))\r\n            continue;\r\n        modint coeff = fact[m] * ifact[i] * ifact[m-i] * modint{(m-i)%2 == 0 ? 1 : P-1} * twopow;\r\n        tp[exp] += coeff;\r\n    }\r\n\r\n    debug(tp);\r\n    for (int i = 1; i < sz(tp); ++i)\r\n        tp[i] += tp[i-1];\r\n    debug(tp);\r\n\r\n    modint ans;\r\n    for (int i = 0; i <= n; ++i) {\r\n        modint coeff = ifact[i] * fact[m+i-1] * ifact[m-1];\r\n        ans += coeff * tp[n-i];\r\n    }\r\n    cout << ans.x << '\\n';\r\n}\r\n\r\nint main() {\r\n#ifndef DEBUG\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n#endif\r\n    int z = 1;\r\n    // cin >> z;\r\n    while (z--)\r\n        solve();\r\n    return 0;\r\n}\r\n"
}