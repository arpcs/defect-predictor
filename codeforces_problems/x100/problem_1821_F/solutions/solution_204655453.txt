{
    "id": 204655453,
    "contestId": 1821,
    "creationTimeSeconds": 1683311329,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "michaleproff"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <iostream>\r\n#include <bits/stdc++.h>\r\n#include <string>\r\n#include <algorithm>\r\n#include <array>\r\n#include <vector>\r\n#include <math.h>\r\n#include <map>\r\n#include <bitset>\r\n\r\nusing namespace std;\r\n#define bb begin()\r\n#define ee end()\r\n#define Log(x) cout<<x<<endl\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define pll pair<ll, ll>\r\n/*Pascal's Triangle - calculate the number of combinations j in i for large numbers, also creates a array to keep accessing these values.\r\n\r\n*/\r\n\r\nint gcd(int a, int b)\r\n{\r\n\r\n    if(b == 0) {\r\n            return a;\r\n    }\r\n    else {\r\n        return gcd(b, a % b);\r\n    }\r\n}\r\n\r\nlong long powermod(long long a, long long b, long long m)\r\n{\r\n\tif (b == 0) return 1;\r\n\tunsigned long long k = powermod(a, b / 2, m);\r\n\tk = k * k;\r\n\tk %= m;\r\n\tif (b & 1) k = (k * a) % m;\r\n\treturn k;\r\n}\r\n\r\nlong wheel(long n) {\r\n    long ws[] = {1,2,2,4,2,4,2,4,6,2,6};\r\n    long f = 2; int w = 0;\r\n\r\n    while (f * f <= n) {\r\n        if (n % f == 0) {\r\n            return(f);\r\n            n /= f;\r\n        } else {\r\n            f += ws[w];\r\n            w = (w == 10) ? 3 : (w+1);\r\n        }\r\n    }\r\n    return(n);\r\n\r\n    return 0;\r\n}\r\n\r\ninline double fPow(double a, double b) {\r\n  union {\r\n    double d;\r\n    int x[2];\r\n  } u = { a };\r\n  u.x[1] = (int)(b * (u.x[1] - 1072632447) + 1072632447);\r\n  u.x[0] = 0;\r\n  return u.d;\r\n}\r\n\r\nconst int tab64[64] = {\r\n    63,  0, 58,  1, 59, 47, 53,  2,\r\n    60, 39, 48, 27, 54, 33, 42,  3,\r\n    61, 51, 37, 40, 49, 18, 28, 20,\r\n    55, 30, 34, 11, 43, 14, 22,  4,\r\n    62, 57, 46, 52, 38, 26, 32, 41,\r\n    50, 36, 17, 19, 29, 10, 13, 21,\r\n    56, 45, 25, 31, 35, 16,  9, 12,\r\n    44, 24, 15,  8, 23,  7,  6,  5};\r\n\r\nint log2_64 (uint64_t value)\r\n{\r\n    value |= value >> 1;\r\n    value |= value >> 2;\r\n    value |= value >> 4;\r\n    value |= value >> 8;\r\n    value |= value >> 16;\r\n    value |= value >> 32;\r\n    return tab64[((uint64_t)((value - (value >> 1))*0x07EDD5E59A4E28C2)) >> 58];\r\n}\r\n\r\ninline long long read() {\r\n    register long long x=0, f=1; register char c=getchar();\r\n    while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}\r\n    while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+c-48,c=getchar();}\r\n    return x*f;\r\n}\r\n\r\nstruct sort_pred {//sort via second in pair\r\n    bool operator()(const std::pair<int,int> &left, const std::pair<int,int> &right) {\r\n        return left.second < right.second;\r\n    }\r\n};\r\n\r\ntemplate<class T, class Fun = function<T(const T &, const T &)>>\r\nstruct SegTree {\r\n    Fun f;\r\n    vector<T> t;\r\n    ll n;\r\n\r\n    SegTree(ll sz, const Fun &g, T default_value = T()) : f(g) {\r\n        n = 1;\r\n        while (n < sz) n <<= 1;\r\n        t.resize(n * 2, default_value);\r\n    }\r\n\r\n    SegTree(vector<T> &a, const Fun &g, T default_value = T()) : SegTree(a.size(), g, default_value) {\r\n        for (ll i = 0; i < n; ++i) t[i + n] = a[i];\r\n        for (ll i = n - 1; i >= 1; --i) t[i] = f(t[i << 1], t[i << 1 | 1]);\r\n    }\r\n\r\n    void upd(ll i, T x) {\r\n        i += n;\r\n        t[i] = f(t[i], x);\r\n        for (i >>= 1; i > 1; i >>= 1) t[i] = f(t[i << 1], t[i << 1 | 1]);\r\n    }\r\n\r\n    T get(ll l, ll r) {\r\n        T resL = t[0], resR = t[0];\r\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\r\n            if (l & 1) resL = f(resL, t[l++]);\r\n            if (r & 1) resR = f(t[--r], resR);\r\n        }\r\n        return f(resL, resR);\r\n    }\r\n};\r\nconst ll THREE = 1000, INF = THREE * THREE * THREE * THREE * THREE * THREE * 9;\r\nstruct WeightedUnionFind{\r\n\tint size;\r\n\tvector<int> parent;\r\n\tvector<ll> weight;\r\n\r\n\tWeightedUnionFind(){}\r\n\tWeightedUnionFind(int size){\r\n\t\tthis->size = size;\r\n\t\tparent.resize(size+1);\r\n\t\tweight.resize(size+1);\r\n\t\tinit();\r\n\t}\r\n\tvoid init(){\r\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i, weight[i] = 0;\r\n\t}\r\n\tint root(int i){\r\n\t\tif(parent[i] == i) return i;\r\n\t\tint r = root(parent[i]);\r\n\t\tweight[i] = weight[parent[i]] ^ weight[i];\r\n\t\treturn parent[i] = r;\r\n\t}\r\n\tbool same(int i, int j){\r\n\t\treturn root(i) == root(j);\r\n\t}\r\n\tll get(int i, int j){\r\n\t\tif(!same(i, j)) return -INF;\r\n\t\treturn weight[j]^weight[i];\r\n\t}\r\n\tbool unite(int i, int j, ll x){\r\n\t\tint root_i = root(i), root_j = root(j);\r\n\t\tif(root_i == root_j){\r\n\t\t\treturn get(i, j) == x;\r\n\t\t}\r\n\t\tparent[root_i] = root_j;\r\n\t\tweight[root_i] = weight[j]^weight[i]^x;\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\nll lcm(ll a, ll b){\r\n    return a * b / gcd(a, b);\r\n}\r\n/*\r\nusing Hash = pair<int, int>;\r\n\r\nconst int p1 = 998'244'353, base1 = 131;\r\nconst int p2 = 1'000'000'007, base2 = 13331;\r\n\r\nint pw1[N], pw2[N];\r\n\r\nHash operator+(const Hash &a, const Hash &b) {\r\n    return {(a.first + b.first) % p1, (a.second + b.second) % p2};\r\n}\r\n\r\nHash operator-(const Hash &a, const Hash &b) {\r\n    return {(a.first - b.first + p1) % p1, (a.second - b.second + p2) % p2};\r\n}\r\n\r\nHash operator*(const Hash &a, int x) {\r\n    return {(ll) a.first * pw1[x] % p1, (ll) a.second * pw2[x] % p2};\r\n}\r\n*/\r\n/*\r\n pw1[0] = pw2[0] = 1;\r\n    for(i = 1; i < MAXN ; i++){\r\n        pw1[i] = (ll)pw1[i-1] * (ll)base1 % p1;\r\n        pw2[i] = (ll)pw2[i-1] * (ll)base2 % p2;\r\n    }\r\n*/\r\n//for(i = 2; i <= MAXN; i++) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;  modular inverse find\r\n\r\nconst ll M = 998244353;\r\n\r\nvoid solve(){\r\n    ll t, n, q, x, y, i, j, k, ans, m, tmp, l, r;\r\n    n = read(); m = read(); k = read(); ll f[m+1], g[m+1], pow[n+1], rev[n+1];\r\n    pow[0] = 1;\r\n    for(i = 1; i <= n; i++) pow[i] = (pow[i-1] * i) % M;\r\n    rev[n] = powermod(pow[n], M-2, M);\r\n    for(i = n-1; i >= 0; i--) rev[i] = rev[i+1] * (i+1) % M;\r\n    for(i = 0; i <= m; i++){\r\n        f[i] = 0;\r\n        tmp = n - (2*k+1) * i - (k+1) * (m-i);\r\n        if(tmp >= 0)f[i] = pow[tmp+m] * rev[m] % M * rev[tmp] % M;\r\n    }ans = 0; ll b = 1;\r\n    for(i = m; i >= 0; i--){\r\n        g[i] = 0;\r\n        for(j = 0; j <= m-i; j++){\r\n            tmp = pow[m-i]*rev[j] % M *rev[m-i-j] % M *f[i+j] % M;\r\n            if(j % 2) g[i] -= tmp;\r\n            else g[i] += tmp;\r\n            if(g[i] < 0) g[i] += M;\r\n            g[i] %= M;\r\n        }\r\n        ans = (ans + b * g[i] * pow[m] * rev[i] * rev[m-i]) % M;\r\n        b*=2; b%=M;\r\n    }\r\n    //acb.rehash(n);\r\n    cout<<ans<<endl;\r\n    return;\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    //ll t, n, q, x, y, i, j, k, ans, m, tmp, l, r;\r\n    ll t;\r\n\r\n    while(t--) solve();\r\n}\r\n"
}