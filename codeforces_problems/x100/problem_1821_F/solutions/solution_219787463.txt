{
    "id": 219787463,
    "contestId": 1821,
    "creationTimeSeconds": 1692619639,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1821,
        "index": "F",
        "name": "Timber",
        "type": "PROGRAMMING",
        "rating": 2600,
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math"
        ]
    },
    "author": {
        "contestId": 1821,
        "members": [
            {
                "handle": "ayingna"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682001300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 3584000,
    "source": "#include <bits/stdc++.h>\r\n#define endl '\\n'\r\nusing namespace std;\r\n\r\nusing LL = long long;\r\n\r\ntemplate<class T>\r\nconstexpr T power(T a, LL b) {\r\n    T res = 1;\r\n    for (; b; b /= 2, a *= a) {\r\n        if (b % 2) {\r\n            res *= a;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n \r\nconstexpr LL mul(LL a, LL b, LL p) {\r\n    LL res = a * b - LL(1.L * a * b / p) * p;\r\n    res %= p;\r\n    if (res < 0) {\r\n        res += p;\r\n    }\r\n    return res;\r\n}\r\ntemplate<LL P>\r\nstruct MLong {\r\n    LL x;\r\n    constexpr MLong() : x{} {}\r\n    constexpr MLong(LL x) : x{norm(x % getMod())} {}\r\n    \r\n    static LL Mod;\r\n    constexpr static LL getMod() {\r\n        if (P > 0) {\r\n            return P;\r\n        } else {\r\n            return Mod;\r\n        }\r\n    }\r\n    constexpr static void setMod(LL Mod_) {\r\n        Mod = Mod_;\r\n    }\r\n    constexpr LL norm(LL x) const {\r\n        if (x < 0) {\r\n            x += getMod();\r\n        }\r\n        if (x >= getMod()) {\r\n            x -= getMod();\r\n        }\r\n        return x;\r\n    }\r\n    constexpr LL val() const {\r\n        return x;\r\n    }\r\n    explicit constexpr operator LL() const {\r\n        return x;\r\n    }\r\n    constexpr MLong operator-() const {\r\n        MLong res;\r\n        res.x = norm(getMod() - x);\r\n        return res;\r\n    }\r\n    constexpr MLong inv() const {\r\n        assert(x != 0);\r\n        return power(*this, getMod() - 2);\r\n    }\r\n    constexpr MLong &operator*=(MLong rhs) & {\r\n        x = mul(x, rhs.x, getMod());\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator+=(MLong rhs) & {\r\n        x = norm(x + rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator-=(MLong rhs) & {\r\n        x = norm(x - rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MLong &operator/=(MLong rhs) & {\r\n        return *this *= rhs.inv();\r\n    }\r\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res *= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res += rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res -= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\r\n        MLong res = lhs;\r\n        res /= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\r\n        LL v;\r\n        is >> v;\r\n        a = MLong(v);\r\n        return is;\r\n    }\r\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\r\n        return os << a.val();\r\n    }\r\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\r\n        return lhs.val() == rhs.val();\r\n    }\r\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\r\n        return lhs.val() != rhs.val();\r\n    }\r\n};\r\n \r\ntemplate<>\r\nLL MLong<0LL>::Mod = 1;\r\n \r\ntemplate<int P>\r\nstruct MInt {\r\n    int x;\r\n    constexpr MInt() : x{} {}\r\n    constexpr MInt(LL x) : x{norm(x % getMod())} {}\r\n    \r\n    static int Mod;\r\n    constexpr static int getMod() {\r\n        if (P > 0) {\r\n            return P;\r\n        } else {\r\n            return Mod;\r\n        }\r\n    }\r\n    constexpr static void setMod(int Mod_) {\r\n        Mod = Mod_;\r\n    }\r\n    constexpr int norm(int x) const {\r\n        if (x < 0) {\r\n            x += getMod();\r\n        }\r\n        if (x >= getMod()) {\r\n            x -= getMod();\r\n        }\r\n        return x;\r\n    }\r\n    constexpr int val() const {\r\n        return x;\r\n    }\r\n    explicit constexpr operator int() const {\r\n        return x;\r\n    }\r\n    constexpr MInt operator-() const {\r\n        MInt res;\r\n        res.x = norm(getMod() - x);\r\n        return res;\r\n    }\r\n    constexpr MInt inv() const {\r\n        assert(x != 0);\r\n        return power(*this, getMod() - 2);\r\n    }\r\n    constexpr MInt &operator*=(MInt rhs) & {\r\n        x = 1LL * x * rhs.x % getMod();\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator+=(MInt rhs) & {\r\n        x = norm(x + rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator-=(MInt rhs) & {\r\n        x = norm(x - rhs.x);\r\n        return *this;\r\n    }\r\n    constexpr MInt &operator/=(MInt rhs) & {\r\n        return *this *= rhs.inv();\r\n    }\r\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res *= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res += rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res -= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\r\n        MInt res = lhs;\r\n        res /= rhs;\r\n        return res;\r\n    }\r\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\r\n        LL v;\r\n        is >> v;\r\n        a = MInt(v);\r\n        return is;\r\n    }\r\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\r\n        return os << a.val();\r\n    }\r\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\r\n        return lhs.val() == rhs.val();\r\n    }\r\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\r\n        return lhs.val() != rhs.val();\r\n    }\r\n};\r\n \r\ntemplate<>\r\nint MInt<0>::Mod = 1;\r\n \r\ntemplate<int V, int P>\r\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\r\n \r\nconstexpr int P = 998244353;\r\nusing Z = MInt<P>;\r\n \r\nstruct Comb {\r\n    int n;\r\n    std::vector<Z> _fac;\r\n    std::vector<Z> _invfac;\r\n    std::vector<Z> _inv;\r\n    \r\n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\r\n    Comb(int n) : Comb() {\r\n        init(n);\r\n    }\r\n    \r\n    void init(int m) {\r\n        if (m <= n) return;\r\n        _fac.resize(m + 1);\r\n        _invfac.resize(m + 1);\r\n        _inv.resize(m + 1);\r\n        \r\n        for (int i = n + 1; i <= m; i++) {\r\n            _fac[i] = _fac[i - 1] * i;\r\n        }\r\n        _invfac[m] = _fac[m].inv();\r\n        for (int i = m; i > n; i--) {\r\n            _invfac[i - 1] = _invfac[i] * i;\r\n            _inv[i] = _invfac[i] * _fac[i - 1];\r\n        }\r\n        n = m;\r\n    }\r\n    \r\n    Z fac(int m) {\r\n        if (m > n) init(2 * m);\r\n        return _fac[m];\r\n    }\r\n    Z invfac(int m) {\r\n        if (m > n) init(2 * m);\r\n        return _invfac[m];\r\n    }\r\n    Z inv(int m) {\r\n        if (m > n) init(2 * m);\r\n        return _inv[m];\r\n    }\r\n    Z binom(int n, int m) {\r\n        if (n < m || m < 0) return 0;\r\n        return fac(n) * invfac(m) * invfac(n - m);\r\n    }\r\n} comb;\r\n \r\nusing u64 = unsigned long long;\r\nstd::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nauto C(int a, int b) {\r\n\treturn comb.binom(a, b);\r\n}\r\nauto H(int a, int b) {\r\n\treturn comb.binom(a + b - 1, b);\r\n}\r\n\r\nint main() {\r\n#ifndef ONLINE_JUDGE\r\n\tfreopen(\"in.txt\", \"r\", stdin);\r\n#endif\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\r\n\tint n, m, k; cin >> n >> m >> k;\r\n\tn -= (k + 1) * m;\r\n\tZ sgn = 1;\r\n\tZ rlt = 0;\r\n\tfor (int i = 0; i <= m; i++) {\r\n\t\tif (n < 0) break;\r\n\t\trlt += sgn * H(m + 1, n) * power(2, m - i) * C(m, i);\r\n\t\tn -= k;\r\n\t\tsgn *= -1;\r\n\t}\r\n\t\r\n\tcout << rlt << endl;\r\n\r\n\treturn 0;\r\n}\r\n"
}