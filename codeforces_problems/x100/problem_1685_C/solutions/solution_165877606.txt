{
    "id": 165877606,
    "contestId": 1685,
    "creationTimeSeconds": 1658918496,
    "relativeTimeSeconds": 7296,
    "problem": {
        "contestId": 1685,
        "index": "C",
        "name": "Bring Balance",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2600,
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1685,
        "members": [
            {
                "handle": "cottoncotton"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1658911200
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 67276800,
    "source": "#![allow(unused_imports)]\nuse input::*;\nuse std::{\n    collections::*,\n    io::{self, BufWriter, Write},\n};\nfn run<I: Input, O: Write>(mut ss: I, mut out: O) {\n    let t: u32 = ss.parse();\n    for _ in 0..t {\n        case(&mut ss, &mut out);\n    }\n}\nfn case<I: Input, O: Write>(mut ss: I, mut out: O) {\n    let n: usize = ss.parse();\n    let s: Vec<u8> = ss.parse();\n    let mut d = 0;\n    let mut dmax = 0;\n    let mut lmax = 0;\n    let mut dmin = 0;\n    let mut neg = false;\n    let mut l = 0;\n    let mut r = 0;\n    let mut h = 0;\n    for (i, &c) in s.iter().enumerate() {\n        if c == b'(' {\n            d += 1;\n        } else {\n            d -= 1;\n        }\n        if !neg {\n            if d > lmax {\n                l = i + 1;\n                lmax = lmax.max(d);\n            }\n            if d < 0 {\n                neg = true;\n            }\n        }\n        dmin = dmin.min(d);\n        if d > dmax {\n            h = i + 1;\n            dmax = dmax.max(d);\n        }\n    }\n    let mut neg = false;\n    let mut rmax = 0;\n    let mut d = 0;\n    for (i, &c) in s.iter().enumerate().rev() {\n        if c == b'(' {\n            d -= 1;\n        } else {\n            d += 1;\n        }\n        if !neg {\n            if d > rmax {\n                rmax = rmax.max(d);\n                r = i;\n            }\n        }\n        if d < 0 {\n            neg = true;\n        }\n    }\n    d!(lmax, rmax, dmax);\n    if dmin >= 0 {\n        wln!(out, \"0\");\n        return;\n    } else if lmax + rmax - dmax >= 0 {\n        wln!(out, \"1\");\n        wln!(out, \"{} {}\", l + 1, r - 1 + 1);\n    } else {\n        wln!(out, \"2\");\n        wln!(out, \"{} {}\", 1, h);\n        wln!(out, \"{} {}\", h + 1, 2 * n);\n    }\n}\nfn main() {\n    let stdin = io::stdin();\n    let ss = SplitWs::new(stdin.lock());\n    let stdout = io::stdout();\n    let out = BufWriter::new(stdout.lock());\n    run(ss, out);\n}\npub mod input {\n    use std::{\n        io::{self, prelude::*},\n        marker::PhantomData,\n        mem,\n    };\n    pub trait Input {\n        fn bytes(&mut self) -> &[u8];\n        fn bytes_vec(&mut self) -> Vec<u8> {\n            self.bytes().to_vec()\n        }\n        fn str(&mut self) -> &str {\n            std::str::from_utf8(self.bytes()).unwrap()\n        }\n        fn parse<T: Parse>(&mut self) -> T {\n            self.parse_with(DefaultParser)\n        }\n        fn parse_with<T>(&mut self, mut parser: impl Parser<T>) -> T {\n            parser.parse(self)\n        }\n        fn seq<T: Parse>(&mut self) -> Seq<T, Self, DefaultParser> {\n            self.seq_with(DefaultParser)\n        }\n        fn seq_with<T, P: Parser<T>>(&mut self, parser: P) -> Seq<T, Self, P> {\n            Seq {\n                input: self,\n                parser,\n                marker: PhantomData,\n            }\n        }\n        fn collect<T: Parse, C: std::iter::FromIterator<T>>(&mut self, n: usize) -> C {\n            self.seq().take(n).collect()\n        }\n    }\n    impl<T: Input> Input for &mut T {\n        fn bytes(&mut self) -> &[u8] {\n            (**self).bytes()\n        }\n    }\n    pub trait Parser<T> {\n        fn parse<I: Input + ?Sized>(&mut self, s: &mut I) -> T;\n    }\n    impl<T, P: Parser<T>> Parser<T> for &mut P {\n        fn parse<I: Input + ?Sized>(&mut self, s: &mut I) -> T {\n            (**self).parse(s)\n        }\n    }\n    pub trait Parse {\n        fn parse<I: Input + ?Sized>(s: &mut I) -> Self;\n    }\n    pub struct DefaultParser;\n    impl<T: Parse> Parser<T> for DefaultParser {\n        fn parse<I: Input + ?Sized>(&mut self, s: &mut I) -> T {\n            T::parse(s)\n        }\n    }\n    pub struct Seq<'a, T, I: ?Sized, P> {\n        input: &'a mut I,\n        parser: P,\n        marker: PhantomData<*const T>,\n    }\n    impl<'a, T, I: Input + ?Sized, P: Parser<T>> Iterator for Seq<'a, T, I, P> {\n        type Item = T;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            Some(self.input.parse_with(&mut self.parser))\n        }\n        fn size_hint(&self) -> (usize, Option<usize>) {\n            (!0, None)\n        }\n    }\n    impl Parse for char {\n        #[inline]\n        fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n            let s = s.bytes();\n            debug_assert_eq!(s.len(), 1);\n            *s.first().expect(\"zero length\") as char\n        }\n    }\n    macro_rules ! tuple { ($ ($ T : ident) ,*) => { impl <$ ($ T : Parse) ,*> Parse for ($ ($ T ,) *) { # [inline] # [allow (unused_variables)] # [allow (clippy :: unused_unit)] fn parse < I : Input + ? Sized > (s : & mut I) -> Self { ($ ($ T :: parse (s) ,) *) } } } ; }\n    tuple!();\n    tuple!(A);\n    tuple!(A, B);\n    tuple!(A, B, C);\n    tuple!(A, B, C, D);\n    tuple!(A, B, C, D, E);\n    tuple!(A, B, C, D, E, F);\n    tuple!(A, B, C, D, E, F, G);\n    #[cfg(feature = \"newer\")]\n    impl<T: Parse, const N: usize> Parse for [T; N] {\n        fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n            use std::{mem::MaybeUninit, ptr};\n            struct Guard<T, const N: usize> {\n                arr: [MaybeUninit<T>; N],\n                i: usize,\n            }\n            impl<T, const N: usize> Drop for Guard<T, N> {\n                fn drop(&mut self) {\n                    unsafe {\n                        ptr::drop_in_place(&mut self.arr[..self.i] as *mut _ as *mut [T]);\n                    }\n                }\n            }\n            let mut g = Guard::<T, N> {\n                arr: unsafe { MaybeUninit::uninit().assume_init() },\n                i: 0,\n            };\n            while g.i < N {\n                g.arr[g.i] = MaybeUninit::new(s.parse());\n                g.i += 1;\n            }\n            unsafe { mem::transmute_copy(&g.arr) }\n        }\n    }\n    macro_rules! uint {\n        ($ ty : ty) => {\n            impl Parse for $ty {\n                #[inline]\n                fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n                    let s = s.bytes();\n                    s.iter().fold(0, |x, d| 10 * x + (0xf & d) as $ty)\n                }\n            }\n        };\n    }\n    macro_rules! int {\n        ($ ty : ty) => {\n            impl Parse for $ty {\n                #[inline]\n                fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n                    let f = |s: &[u8]| {\n                        s.iter()\n                            .fold(0 as $ty, |x, d| (10 * x).wrapping_add((0xf & d) as $ty))\n                    };\n                    let s = s.bytes();\n                    if let Some((b'-', s)) = s.split_first() {\n                        f(s).wrapping_neg()\n                    } else {\n                        f(s)\n                    }\n                }\n            }\n        };\n    }\n    macro_rules! float {\n        ($ ty : ty) => {\n            impl Parse for $ty {\n                fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n                    const POW: [$ty; 18] = [\n                        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13,\n                        1e14, 1e15, 1e16, 1e17,\n                    ];\n                    let s = s.bytes();\n                    let (minus, s) = if let Some((b'-', s)) = s.split_first() {\n                        (true, s)\n                    } else {\n                        (false, s)\n                    };\n                    let (int, fract) = if let Some(p) = s.iter().position(|c| *c == b'.') {\n                        (&s[..p], &s[p + 1..])\n                    } else {\n                        (s, &[][..])\n                    };\n                    let x = int\n                        .iter()\n                        .chain(fract)\n                        .fold(0u64, |x, d| 10 * x + (0xf & *d) as u64);\n                    let x = x as $ty;\n                    let x = if minus { -x } else { x };\n                    let exp = fract.len();\n                    if exp == 0 {\n                        x\n                    } else if let Some(pow) = POW.get(exp) {\n                        x / pow\n                    } else {\n                        x / (10.0 as $ty).powi(exp as i32)\n                    }\n                }\n            }\n        };\n    }\n    macro_rules! from_bytes {\n        ($ ty : ty) => {\n            impl Parse for $ty {\n                #[inline]\n                fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n                    s.bytes().into()\n                }\n            }\n        };\n    }\n    macro_rules! from_str {\n        ($ ty : ty) => {\n            impl Parse for $ty {\n                #[inline]\n                fn parse<I: Input + ?Sized>(s: &mut I) -> Self {\n                    s.str().into()\n                }\n            }\n        };\n    }\n    macro_rules ! impls { ($ m : ident , $ ($ ty : ty) ,*) => { $ ($ m ! ($ ty) ;) * } ; }\n    impls!(uint, usize, u8, u16, u32, u64, u128);\n    impls!(int, isize, i8, i16, i32, i64, i128);\n    impls!(float, f32, f64);\n    impls!(from_bytes, Vec<u8>, Box<[u8]>);\n    impls!(from_str, String);\n    #[derive(Clone)]\n    pub struct SplitWs<T> {\n        src: T,\n        buf: Vec<u8>,\n        pos: usize,\n        len: usize,\n    }\n    const BUF_SIZE: usize = 1 << 26;\n    impl<T: Read> SplitWs<T> {\n        pub fn new(src: T) -> Self {\n            Self {\n                src,\n                buf: vec![0; BUF_SIZE],\n                pos: 0,\n                len: 0,\n            }\n        }\n        #[inline(always)]\n        fn peek(&self) -> &[u8] {\n            unsafe { self.buf.get_unchecked(self.pos..self.len) }\n        }\n        #[inline(always)]\n        fn consume(&mut self, n: usize) -> &[u8] {\n            let pos = self.pos;\n            self.pos += n;\n            unsafe { self.buf.get_unchecked(pos..self.pos) }\n        }\n        fn read(&mut self) -> usize {\n            self.buf.copy_within(self.pos..self.len, 0);\n            self.len -= self.pos;\n            self.pos = 0;\n            if self.len == self.buf.len() {\n                self.buf.resize(2 * self.buf.len(), 0);\n            }\n            loop {\n                match self.src.read(&mut self.buf[self.len..]) {\n                    Ok(n) => {\n                        self.len += n;\n                        return n;\n                    }\n                    Err(e) if e.kind() == io::ErrorKind::WouldBlock => {}\n                    Err(e) => panic!(\"io error: {:?}\", e),\n                }\n            }\n        }\n    }\n    impl<T: Read> Input for SplitWs<T> {\n        #[inline]\n        fn bytes(&mut self) -> &[u8] {\n            loop {\n                if let Some(del) = self.peek().iter().position(|c| c.is_ascii_whitespace()) {\n                    if del > 0 {\n                        let s = self.consume(del + 1);\n                        return s.split_last().unwrap().1;\n                    } else {\n                        self.consume(1);\n                    }\n                } else if self.read() == 0 {\n                    return self.consume(self.len - self.pos);\n                }\n            }\n        }\n    }\n}\npub mod macros {\n    #[macro_export]\n    macro_rules ! w { ($ ($ arg : tt) *) => { write ! ($ ($ arg) *) . unwrap () ; } }\n    #[macro_export]\n    macro_rules ! wln { ($ dst : expr $ (, $ ($ arg : tt) *) ?) => { { writeln ! ($ dst $ (, $ ($ arg) *) ?) . unwrap () ; # [cfg (debug_assertions)] $ dst . flush () . unwrap () ; } } }\n    #[macro_export]\n    macro_rules! w_iter {\n        ($ dst : expr , $ fmt : expr , $ iter : expr , $ delim : expr) => {{\n            let mut first = true;\n            for elem in $iter {\n                if first {\n                    w!($dst, $fmt, elem);\n                    first = false;\n                } else {\n                    w!($dst, concat!($delim, $fmt), elem);\n                }\n            }\n        }};\n        ($ dst : expr , $ fmt : expr , $ iter : expr) => {\n            w_iter!($dst, $fmt, $iter, \" \")\n        };\n    }\n    #[macro_export]\n    macro_rules ! w_iter_ln { ($ dst : expr , $ ($ t : tt) *) => { { w_iter ! ($ dst , $ ($ t) *) ; wln ! ($ dst) ; } } }\n    #[macro_export]\n    macro_rules ! e { ($ ($ t : tt) *) => { # [cfg (debug_assertions)] eprint ! ($ ($ t) *) } }\n    #[macro_export]\n    macro_rules ! eln { ($ ($ t : tt) *) => { # [cfg (debug_assertions)] eprintln ! ($ ($ t) *) } }\n    #[macro_export]\n    #[doc(hidden)]\n    macro_rules ! __tstr { ($ h : expr $ (, $ t : expr) +) => { concat ! (__tstr ! ($ ($ t) ,+) , \", \" , __tstr ! (@)) } ; ($ h : expr) => { concat ! (__tstr ! () , \" \" , __tstr ! (@)) } ; () => { \"\\x1B[94m[{}:{}]\\x1B[0m\" } ; (@) => { \"\\x1B[1;92m{}\\x1B[0m = {:?}\" } }\n    #[macro_export]\n    macro_rules ! d { ($ ($ a : expr) ,*) => { if std :: env :: var (\"ND\") . map (| v | & v == \"0\") . unwrap_or (true) { eln ! (__tstr ! ($ ($ a) ,*) , file ! () , line ! () , $ (stringify ! ($ a) , $ a) ,*) ; } } ; }\n}\n"
}