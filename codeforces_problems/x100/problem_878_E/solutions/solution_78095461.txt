{
    "id": 78095461,
    "contestId": 878,
    "creationTimeSeconds": 1587888373,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 878,
        "index": "E",
        "name": "Numbers on the blackboard",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3300,
        "tags": [
            "combinatorics",
            "dp"
        ]
    },
    "author": {
        "contestId": 878,
        "members": [
            {
                "handle": "cwise"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1509029100
    },
    "programmingLanguage": "Java 8",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 108,
    "memoryConsumedBytes": 20582400,
    "source": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        long inf = (long) 1e18;\n        Modular mod = new Modular(1e9 + 7);\n        CachedPow cp = new CachedPow(2, mod);\n        int[] pre;\n\n        public int interval(int l, int r) {\n            int sum = pre[r];\n            if (l > 0) {\n                sum = mod.subtract(sum, pre[l - 1]);\n                sum = mod.mul(sum, cp.inverse(l));\n            }\n            return sum;\n        }\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int q = in.readInt();\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.readInt();\n            }\n            int[] left = new int[n];\n            long[] leftSum = new long[n];\n\n            for (int i = 0; i < n; i++) {\n                left[i] = i;\n                long sum = a[i];\n                while (left[i] > 0 && sum >= 0) {\n                    long pow2 = DigitUtils.limitPow(2, left[i] - left[left[i] - 1], inf);\n                    sum = DigitUtils.mul(sum, pow2, inf, inf);\n                    sum = Math.min(sum + leftSum[i], inf);\n                    left[i] = left[left[i] - 1];\n                }\n                leftSum[i] = sum;\n            }\n\n\n            pre = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    pre[i] = pre[i - 1];\n                }\n                pre[i] = mod.plus(pre[i], mod.mul(a[i], cp.pow(i)));\n            }\n\n            int log = 20;\n            int[][] jumpIndex = new int[n][log];\n            SequenceUtils.deepFill(jumpIndex, -1);\n            long[][] jumpSum = new long[n][log];\n            for (int i = 0; i < n; i++) {\n                jumpIndex[i][0] = left[i] - 1;\n                jumpSum[i][0] = interval(left[i], i);\n                for (int j = 0; jumpIndex[i][j] >= 0; j++) {\n                    jumpIndex[i][j + 1] = jumpIndex[jumpIndex[i][j]][j];\n                    jumpSum[i][j + 1] = mod.plus(jumpSum[i][j], jumpSum[jumpIndex[i][j]][j]);\n                }\n            }\n\n            while (q-- > 0) {\n                int l = in.readInt() - 1;\n                int r = in.readInt() - 1;\n\n                long ans = 0;\n                int index = r;\n                for (int i = log - 1; i >= 0; i--) {\n                    if (jumpIndex[index][i] >= l) {\n                        ans = mod.plus(ans, jumpSum[index][i]);\n                        index = jumpIndex[index][i];\n                    }\n                }\n\n                ans = mod.mul(ans, 2);\n                int extra = interval(l, index);\n                ans = mod.plus(ans, extra);\n\n                out.println(ans);\n            }\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static boolean isMultiplicationOverflow(long a, long b, long limit) {\n            if (limit < 0) {\n                limit = -limit;\n            }\n            if (a < 0) {\n                a = -a;\n            }\n            if (b < 0) {\n                b = -b;\n            }\n            if (a == 0 || b == 0) {\n                return false;\n            }\n            //a * b > limit => a > limit / b\n            return a > limit / b;\n        }\n\n        public static long mul(long a, long b, long limit, long overflowVal) {\n            return isMultiplicationOverflow(a, b, limit) ? overflowVal : a * b;\n        }\n\n        public static long limitPow(long x, long n, long limit) {\n            if (n == 0) {\n                return Math.min(1, limit);\n            }\n            long ans = limitPow(x, n / 2, limit);\n            ans = DigitUtils.mul(ans, ans, limit, limit);\n            if (n % 2 == 1) {\n                ans = DigitUtils.mul(ans, x, limit, limit);\n            }\n            return ans;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int mul(long x, long y) {\n            return valueOf(x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int plus(long x, long y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n        private static int step = 16;\n        private static int limit = 1 << step;\n        private static int mask = limit - 1;\n\n        public CachedPow(int x, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            first = new int[limit];\n            second = new int[Integer.MAX_VALUE / limit + 1];\n            first[0] = 1;\n            for (int i = 1; i < first.length; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[first.length - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp & mask], second[exp >> step]);\n        }\n\n        public int inverse(int exp) {\n            return pow(powMod.valueOf(-exp));\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n}\n\n"
}