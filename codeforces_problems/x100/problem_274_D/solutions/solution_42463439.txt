{
    "id": 42463439,
    "contestId": 274,
    "creationTimeSeconds": 1536072095,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 274,
        "index": "D",
        "name": "Lovely Matrix",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "dfs and similar",
            "graphs",
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 274,
        "members": [
            {
                "handle": "PrakharJain"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1361374200
    },
    "programmingLanguage": "Java 8",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 340,
    "memoryConsumedBytes": 0,
    "source": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        _247D solver = new _247D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class _247D {\n        List[] g;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            g = new List[m];\n\n            for (int i = 0; i < m; i++) {\n                g[i] = new ArrayList();\n            }\n\n            for (int i = 0; i < n; i++) {\n                List<num> nums = new ArrayList<>();\n\n                for (int j = 0; j < m; j++) {\n                    nums.add(new num(j, a[i][j]));\n                }\n\n                nums.sort((n1, n2) -> n1.num - n2.num);\n\n                int j = 0;\n                while (nums.get(j).num == -1) {\n                    j++;\n                }\n\n                int[] next = new int[m];\n\n                next[m - 1] = m;\n                for (int k = m - 2; k >= j; k--) {\n                    if (nums.get(k).num < nums.get(k + 1).num) {\n                        next[k] = k + 1;\n                    } else {\n                        next[k] = next[k + 1];\n                    }\n                }\n\n                for (; j < m; j++) {\n                    num cn = nums.get(j);\n                    if (next[j] < m) {\n                        num nn = nums.get(next[j]);\n                        g[cn.i].add(nn.i);\n                    }\n                }\n            }\n\n            CycleFinder cycle = new CycleFinder(g, m);\n\n            if (cycle.isCycleDirected()) {\n                out.println(-1);\n                return;\n            }\n\n            TopoSort topoSort = new TopoSort(m, g);\n            topoSort.topoSort();\n\n            List<Integer> topo = topoSort.topoOrder;\n\n            for (int i = 0; i < topo.size(); i++) {\n                out.print((topo.get(i) + 1) + \" \");\n            }\n\n        }\n\n        class num {\n            int i;\n            int num;\n\n            public num(int i, int num) {\n                this.i = i;\n                this.num = num;\n            }\n\n        }\n\n        class TopoSort {\n            int n;\n            List[] g;\n            List<Integer> topoOrder = new ArrayList<>();\n\n            public TopoSort(int n, List[] g) {\n                this.n = n;\n                this.g = g;\n            }\n\n            void topoSort() {\n\n                int[] in = new int[n];\n\n                ArrayDeque<Integer> q = new ArrayDeque<>();\n\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < g[i].size(); j++) {\n                        int v = (int) g[i].get(j);\n\n                        in[v]++;\n                    }\n                }\n\n                for (int i = 0; i < n; i++) {\n                    if (in[i] == 0) {\n                        q.addLast(i);\n                    }\n                }\n\n                while (!q.isEmpty()) {\n                    int ce = q.removeFirst();\n\n                    topoOrder.add(ce);\n                    for (int i = 0; i < g[ce].size(); i++) {\n                        int v = (int) g[ce].get(i);\n\n                        in[v]--;\n\n                        if (in[v] == 0) {\n                            q.addLast(v);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        class CycleFinder {\n            List[] g;\n            int n;\n            boolean isCycle;\n            boolean[] recstack;\n            boolean[] vis;\n\n            public CycleFinder(List[] g, int n) {\n                this.g = g;\n                this.n = n;\n                this.recstack = new boolean[n];\n                this.vis = new boolean[n];\n            }\n\n            boolean isCycleDirected() {\n                isCycle = false;\n\n\n                for (int i = 0; i < n; i++) {\n                    if (!vis[i]) {\n                        dfs(i);\n                    }\n                }\n\n                return isCycle;\n            }\n\n            private void dfs(int u) {\n                recstack[u] = true;\n\n                vis[u] = true;\n\n                for (int v : (List<Integer>) g[u]) {\n                    if (recstack[v]) {\n                        isCycle = true;\n                    }\n                    if (!vis[v]) {\n                        dfs(v);\n                    }\n                }\n\n                recstack[u] = false;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
}