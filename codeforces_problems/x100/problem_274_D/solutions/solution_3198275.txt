{
    "id": 3198275,
    "contestId": 274,
    "creationTimeSeconds": 1361874167,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 274,
        "index": "D",
        "name": "Lovely Matrix",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "dfs and similar",
            "graphs",
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 274,
        "members": [
            {
                "handle": "vanchope"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1361374200
    },
    "programmingLanguage": "Java 7",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 8,
    "timeConsumedMillis": 687,
    "memoryConsumedBytes": 21504000,
    "source": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n * @author Ivan Pryvalov ([email\u00a0protected])\n */\npublic class Codeforces_R168_Div1_D implements Runnable{\n\t\n\t\n\tstatic class Col{\n\t\tpublic final static Col NIL = new Col();\n\t\t\n\t\tint index;\n\t\t\n\t\tint[] val;\n\t\t\n\t\tCol next = NIL;\n\t\tCol prev = NIL;\n\t}\n\t\n\tprivate void solve() throws IOException {\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt(); // n*m <=10^5\n\t\t\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = scanner.loadIntArray(m);\n\t\t}\n\t\t\n\t\t\n\t\tCol[] cols = new Col[m];\n\t\tfor (int j = 0; j < cols.length; j++) {\n\t\t\tcols[j] = new Col();\n\t\t\tcols[j].index = j+1;\n\t\t\tcols[j].val = new int[n];\n\t\t\t\n\t\t\tfor (int row = 0; row < n; row++) {\n\t\t\t\tcols[j].val[row] = a[row][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//solve\n\t\t\n\t\tSet<Col> set = new TreeSet<Col>();\n\t\t\n\t\tfinal Comparator[] comp = new Comparator[n];\n\t\tfor (int i = 0; i < comp.length; i++) {\n\t\t\tfinal int Row = i;\n\t\t\tcomp[i] =  new Comparator<Col>() {\n\t\t\t\tpublic int compare(Col o1, Col o2) {\n\t\t\t\t\tif (o1.val[Row]==-1 || o2.val[Row]==-1){\n\t\t\t\t\t\tif (Row>0){\n\t\t\t\t\t\t\treturn comp[Row-1].compare(o1, o2);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn o1.val[Row] - o2.val[Row];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\n\t\t\n\t\tfor (int row = 0; row < n; row++) {\n\t\t\tfinal int Row = row; \n\t\t\tArrays.sort(cols, comp[Row]);\n\t\t\t\n//\t\t\tint prev = -1;\n//\t\t\tfor (int col = 0; col < m; col++) {\n//\t\t\t\t\n//\t\t\t\tint val = cols[col].val[row];\n//\t\t\t\tif (val==-1)\n//\t\t\t\t\tcontinue;\n//\t\t\t\t\n//\t\t\t\tif (prev == -1){\n//\t\t\t\t\tprev = val;\n//\t\t\t\t\tif (!set.contains(cols[col])){\n//\t\t\t\t\t\tset.add(cols[col]);\n//\t\t\t\t\t}\n//\t\t\t\t}else{\n//\t\t\t\t\t\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tboolean ok = true;\n\t\tfor (int row = 0; row < n && ok; row++) {\n\t\t\tint cur = 0;\n\t\t\tfor (int col = 0; col < m; col++) {\n\t\t\t\tint val = cols[col].val[row]; \n\t\t\t\tif (val != -1){\n\t\t\t\t\tif (val<cur){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (!ok){\n\t\t\tout.println(-1);\n\t\t}else{\n\t\t\tfor (int i = 0; i < cols.length; i++) {\n\t\t\t\tout.print(cols[i].index+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void printcols(PrintStream out, Col[] cols) {\n\t\tfor (int i = 0; i < cols.length; i++) {\n\t\t\tout.print(cols[i].index+\" \");\n\t\t}\n\t\tout.println();\t\t\n\t}\n\n\t/////////////////////////////////////////////////\n\tfinal int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n\tfinal int INPUT_BUFFER_SIZE = 1024 * 1024 * 8 ;\n\tfinal int BUF_SIZE_INPUT = 1024;\n\t\n\tfinal int BUF_SIZE_OUT = 1024;\n\t\n\tboolean inputFromFile = false;\n\tString filenamePrefix = \"A-small-attempt0\";\n\tString inSuffix = \".in\";\n\tString outSuffix = \".out\";\n\t\n\tPrintStream out;\n\tByteScanner scanner;\n\tByteWriter writer;\n\t\n\tpublic void run() {\n\t\ttry{\n\t\t\tInputStream bis = null;\n\t\t\tOutputStream bos = null;\n\t\t\t//PrintStream out = null;\n\t\t\tif (inputFromFile){\n\t\t\t\tFile baseFile = new File(getClass().getResource(\"/\").getFile());\n\t\t\t\tbis = new BufferedInputStream(\n\t\t\t\t\t\tnew FileInputStream(new File(\n\t\t\t\t\t\t\t\tbaseFile, filenamePrefix+inSuffix)),\n\t\t\t\t\t\t\t\tINPUT_BUFFER_SIZE);\n\t\t\t\tbos = new BufferedOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\n\t\t\t\t\t\t\t\tnew File(baseFile, filenamePrefix+outSuffix)));\n\t\t\t\tout = new PrintStream(bos);\n\t\t\t}else{\n\t\t\t\tbis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n\t\t\t\tbos = new BufferedOutputStream(System.out);\n\t\t\t\tout = new PrintStream(bos);\n\t\t\t}\n\t\t\tscanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\t\t\twriter = new ByteWriter(bos, BUF_SIZE_OUT);\n\t\t\t\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tpublic interface Constants{\n\t\tfinal static byte ZERO = '0';//48 or 0x30\n\t\tfinal static byte NINE = '9';\n\t\tfinal static byte SPACEBAR = ' '; //32 or 0x20\n\t\tfinal static byte MINUS = '-'; //45 or 0x2d\t\n\t\t\n\t\tfinal static char FLOAT_POINT = '.';\n\t}\n\t\n\tpublic static class EofException extends IOException{\n\t}\n\t\n\tpublic static class ByteWriter implements Constants {\n\t\t\n\t\tint bufSize = 1024;\n\t\tbyte[] byteBuf = new byte[bufSize];\n\t\tOutputStream os;\n\t\t\n\t\tpublic ByteWriter(OutputStream os, int bufSize){\n\t\t\tthis.os = os;\n\t\t\tthis.bufSize = bufSize;\n\t\t}\n\t\t\n\t\tpublic void writeInt(int num) throws IOException{\n\t         int byteWriteOffset = byteBuf.length;\n\t         if (num==0){\n\t        \t byteBuf[--byteWriteOffset] = ZERO;\n\t         }else{\n\t        \t int numAbs = Math.abs(num);\n\t        \t while (numAbs>0){\n\t        \t\t byteBuf[--byteWriteOffset] = (byte)((numAbs % 10) + ZERO);\n\t        \t\t numAbs /= 10;\n\t        \t }\n\t        \t if (num<0)\n\t        \t\t byteBuf[--byteWriteOffset] = MINUS;\n\t         }\n\t         os.write(byteBuf, byteWriteOffset, byteBuf.length - byteWriteOffset);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Please ensure ar.length <= byteBuf.length!\n\t\t * \n\t\t * @param ar\n\t\t * @throws IOException\n\t\t */\n\t\tpublic void writeByteAr(byte[] ar) throws IOException{\n\t\t\tfor (int i = 0; i < ar.length; i++) {\n\t\t\t\tbyteBuf[i] = ar[i];\n\t\t\t}\n\t\t\tos.write(byteBuf,0,ar.length);\n\t\t}\n\t\t\n\t\tpublic void writeSpaceBar() throws IOException{\n\t\t\tbyteBuf[0] = SPACEBAR;\n\t\t\tos.write(byteBuf,0,1);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static class ByteScanner implements Constants{\n\t\t\n\t\tInputStream is;\n\t\t\n\t\tpublic ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n\t\t\tthis.is = is;\n\t\t\tthis.bufSizeInput = bufSizeInput;\n\t\t\tthis.bufSize = bufSize;\n\t\t\t\n\t\t\tbyteBufInput = new byte[this.bufSizeInput];\n\t\t\tbyteBuf = new byte[this.bufSize];\n\t\t}\n\t\t\n\t\tpublic ByteScanner(byte[] data){\n\t\t\tbyteBufInput = data;\n\t\t\tbufSizeInput = data.length;\n\t\t\tbufSize = data.length;\n\t\t\tbyteBuf = new byte[bufSize];\n\t\t\tbyteRead = data.length;\n\t\t\tbytePos = 0;\n\t\t}\n\t\t\n\t\tprivate int bufSizeInput;\n\t\tprivate int bufSize;\n\t\t\n\t\tbyte[] byteBufInput;\n\t\tbyte by=-1;\n\t\tint byteRead=-1;\n\t\tint bytePos=-1;\n\n\t\tbyte[] byteBuf;\n\t\tint totalBytes;\n\t\t\n\t\tboolean eofMet = false;\n\t\t\n\t\tprivate byte nextByte() throws IOException{\n\t\t\t\n\t\t\tif (bytePos<0 || bytePos>=byteRead){\n\t\t\t\tbyteRead = is==null? -1: is.read(byteBufInput);\n\t\t\t\tbytePos=0;\n\t\t\t\tif (byteRead<0){\n\t\t\t\t\tbyteBufInput[bytePos]=-1;//!!!\n\t\t\t\t\tif (eofMet)\n\t\t\t\t\t\tthrow new EofException();\n\t\t\t\t\teofMet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn byteBufInput[bytePos++];\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns next meaningful character as a byte.<br>\n\t\t * \n\t\t * @return\n\t\t * @throws IOException\n\t\t */\n\t\tpublic byte nextChar() throws IOException{\n\t\t\twhile ((by=nextByte())<=0x20);\n\t\t\treturn by;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns next meaningful character OR space as a byte.<br>\n\t\t * \n\t\t * @return\n\t\t * @throws IOException\n\t\t */\n\t\tpublic byte nextCharOrSpacebar() throws IOException{\n\t\t\twhile ((by=nextByte())<0x20);\n\t\t\treturn by;\n\t\t}\n\t\t\n\t    /**\n\t     * Reads line.\n\t     * \n\t     * @return\n\t     * @throws IOException\n\t     */\n\t    public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n\t    }\n\t    \n\t    public byte[] nextLineAsArray() throws IOException {\n            readToken((byte)0x20);\n            byte[] out = new byte[totalBytes];\n            System.arraycopy(byteBuf, 0, out, 0, totalBytes);\n            return out;\n\t    }\n\t    \n\t\t\n\t    /**\n\t     * Reads token. Spacebar is separator char.\n\t     * \n\t     * @return\n\t     * @throws IOException\n\t     */\n\t    public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n\t    }\n\t    \n\t    /**\n\t     * Spacebar is included as separator char\n\t     * \n\t     * @throws IOException\n\t     */\n\t    private void readToken() throws IOException {\t    \t\n            readToken((byte)0x21);\n\t    }\n\t    \n\t    private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n\t    }\n\t\t\n\t    public int nextInt() throws IOException{\n\t\t\treadToken();\n\t\t\tint num=0, i=0;\n\t\t\tboolean sign=false;\n\t\t\tif (byteBuf[i]==MINUS){\n\t\t\t\tsign = true;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i<totalBytes; i++){\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=byteBuf[i]-ZERO;\n\t\t\t}\n\t\t\treturn sign?-num:num;\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\treadToken();\n\t\t\tlong num=0;\n\t\t\tint i=0;\n\t\t\tboolean sign=false;\n\t\t\tif (byteBuf[i]==MINUS){\n\t\t\t\tsign = true;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i<totalBytes; i++){\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=byteBuf[i]-ZERO;\n\t\t\t}\n\t\t\treturn sign?-num:num;\n\t\t}\n\t\t\n\t\t/*\n\t\t//TODO test Unix/Windows formats\n\t\tpublic void toNextLine() throws IOException{\n\t\t\twhile ((ch=nextChar())!='\\n');\n\t\t}\n\t\t*/\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\treadToken();\n\t\t\tchar[] token = new char[totalBytes];\n\t\t\tfor (int i = 0; i < totalBytes; i++) {\n\t\t\t\ttoken[i] = (char)byteBuf[i];\n\t\t\t}\n\t\t\treturn Double.parseDouble(new String(token));\n\t\t}\n\t\t\n\t\tpublic int[] loadIntArray(int size) throws IOException{\n\t\t\tint[] a = new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tpublic long[] loadLongArray(int size) throws IOException{\n\t\t\tlong[] a = new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t    \n\t}\n\t\n\t\n\tpublic static abstract class Timing{\n\t\tprivate static int counter = 0;\n\t\tprotected String name = \"Timing\"+(++counter);\n\t\tprivate boolean debug;\n\t\t\n\t\tpublic Timing(boolean debug) {\n\t\t\tsuper();\n\t\t\tthis.debug = debug;\n\t\t}\n\t\t\n\t\tpublic abstract void run();\n\t\tpublic void start(){\n\t\t\tlong time1 = System.currentTimeMillis();\n\t\t\trun();\n\t\t\tlong time2 = System.currentTimeMillis();\n\t\t\tif (debug)\n\t\t\t\tSystem.out.println(name+\" time = \"+(time2-time1)/1000.0+\" ms.\");\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static class Alg{\n\t\tpublic static interface BooleanChecker{\n\t\t\tpublic boolean check(long arg);\n\t\t}\n\t\t\n\t\tpublic static class BinarySearch{\n\t\t\t\t\t\n\t\t\t/**\n\t\t\t * This check returns boolean value, result of function.\n\t\t\t * It should be monotonic.\n\t\t\t * \n\t\t\t * @return\n\t\t\t */\n\t\t\tpublic BooleanChecker bc;\n\t\t\t\n\t\t\t\n\t\t\t/**\n\t\t\t * Returns following element: <pre> 0 0 [1] 1 1</pre>\n\t\t\t */\n\t\t\tpublic long search(long left, long right){\n\t\t\t\twhile (left<=right){\n\t\t\t\t\tlong mid = (left+right)/2;\n\t\t\t\t\tif (bc.check(mid)){\n\t\t\t\t\t\tright = mid-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tleft = mid+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\t\n\t\t\t/**\n\t\t\t * Optional.<br>\n\t\t\t * Returns following element: <pre> 1 1 [1] 0 0</pre>\n\t\t\t */\n\t\t\tpublic long searchInverted(long left, long right){\n\t\t\t\twhile (left<=right){\n\t\t\t\t\tlong mid = (left+right)/2;\n\t\t\t\t\tif (!bc.check(mid)){\n\t\t\t\t\t\tright = mid-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tleft = mid+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn left - 1; \n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Modulo{\n\t\tlong mod = (long)1e9+7;\n\t\t\n\t\tpublic Modulo(long mod) {\n\t\t\tsuper();\n\t\t\tthis.mod = mod;\n\t\t}\n\n\t\tpublic long inv(int a) {\n\t\t\tlong res =  pow(a, mod-2);\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long pow(long a, long x) {\n\t\t\tif (x==0)\n\t\t\t\treturn 1;\n\t\t\tlong part = 1;\n\t\t\tif ((x&1)!=0)\n\t\t\t\tpart = a;\n\t\t\treturn (part * pow((a*a)%mod, x>>1)) % mod;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Codeforces_R168_Div1_D().run();\n\t}\n\t\n}"
}