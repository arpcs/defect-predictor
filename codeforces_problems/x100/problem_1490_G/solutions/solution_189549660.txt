{
    "id": 189549660,
    "contestId": 1490,
    "creationTimeSeconds": 1673966659,
    "relativeTimeSeconds": 7159,
    "problem": {
        "contestId": 1490,
        "index": "G",
        "name": "Old Floppy Drive ",
        "type": "PROGRAMMING",
        "rating": 1900,
        "tags": [
            "binary search",
            "data structures",
            "math"
        ]
    },
    "author": {
        "contestId": 1490,
        "members": [
            {
                "handle": "sjNxksbzj"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1673959500
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 92,
    "memoryConsumedBytes": 5324800,
    "source": "import sys\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nfrom math import inf, gcd, lcm, log, log2, floor, ceil, sqrt, isqrt\r\nfrom collections import defaultdict, deque, Counter\r\nfrom heapq import heappush, heappop, heapify\r\nfrom functools import lru_cache\r\nfrom itertools import permutations, accumulate, groupby\r\nfrom bisect import insort, bisect_left, bisect_right\r\nimport random\r\n\r\n#template taken from https://codeforces.com/contest/1703/submission/164030692 - Author mkawa2\r\nclass DefaultDict:\r\n    def __init__(self, default=None):\r\n        self.default = default\r\n        self.x = random.randrange(1, 1 << 31)\r\n        self.dd = defaultdict(default)\r\n    def __repr__(self):\r\n        return \"{\"+\", \".join(f\"{k ^ self.x}: {v}\" for k, v in self.dd.items())+\"}\"\r\n    def __eq__(self, other):\r\n        for k in set(self) | set(other):\r\n            if self[k] != other[k]: return False\r\n        return True\r\n    def __or__(self, other):\r\n        res = DefaultDict(self.default)\r\n        for k, v in self.dd: res[k] = v\r\n        for k, v in other.dd: res[k] = v\r\n        return res\r\n    def __len__(self):\r\n        return len(self.dd)\r\n    def __getitem__(self, item):\r\n        return self.dd[item ^ self.x]\r\n    def __setitem__(self, key, value):\r\n        self.dd[key ^ self.x] = value\r\n    def __delitem__(self, key):\r\n        del self.dd[key ^ self.x]\r\n    def __contains__(self, item):\r\n        return item ^ self.x in self.dd\r\n    def items(self):\r\n        for k, v in self.dd.items(): yield (k ^ self.x, v)\r\n    def keys(self):\r\n        for k in self.dd: yield k ^ self.x\r\n    def values(self):\r\n        for v in self.dd.values(): yield v\r\n    def __iter__(self):\r\n        for k in self.dd: yield k ^ self.x\r\nclass CounterInt(DefaultDict):\r\n    def __init__(self, aa=[]):\r\n        super().__init__(int)\r\n        for a in aa: self.dd[a ^ self.x] += 1\r\n    def __add__(self, other):\r\n        res = CounterInt()\r\n        for k in set(self) | set(other):\r\n            v = self[k]+other[k]\r\n            if v > 0: res[k] = v\r\n        return res\r\n    def __sub__(self, other):\r\n        res = CounterInt()\r\n        for k in set(self) | set(other):\r\n            v = self[k]-other[k]\r\n            if v > 0: res[k] = v\r\n        return res\r\n    def __and__(self, other):\r\n        res = CounterInt()\r\n        for k in self:\r\n            v = min(self[k], other[k])\r\n            if v > 0: res[k] = v\r\n        return res\r\n    def __or__(self, other):\r\n        res = CounterInt()\r\n        for k in set(self) | set(other):\r\n            v = max(self[k], other[k])\r\n            if v > 0: res[k] = v\r\n        return res\r\nclass Set:\r\n    def __init__(self, aa=[]):\r\n        self.x = random.randrange(1, 1 << 31)\r\n        self.st = set()\r\n        for a in aa: self.st.add(a ^ self.x)\r\n    def __repr__(self):\r\n        return \"{\"+\", \".join(str(k ^ self.x) for k in self.st)+\"}\"\r\n    def __len__(self):\r\n        return len(self.st)\r\n    def add(self, item):\r\n        self.st.add(item ^ self.x)\r\n    def discard(self, item):\r\n        self.st.discard(item ^ self.x)\r\n    def __contains__(self, item):\r\n        return item ^ self.x in self.st\r\n    def __iter__(self):\r\n        for k in self.st: yield k ^ self.x\r\n    def pop(self):\r\n        return self.st.pop() ^ self.x\r\n    def __or__(self, other):\r\n        res = Set(self)\r\n        for a in other: res.add(a)\r\n        return res\r\n    def __and__(self, other):\r\n        res = Set()\r\n        for a in self:\r\n            if a in other: res.add(a)\r\n        for a in other:\r\n            if a in self: res.add(a)\r\n        return res\r\n    \r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n\r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n\r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n\r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n\r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n\r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n\r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n\r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n\r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n\r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n\r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n\r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n\r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n\r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n\r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n\r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n\r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n\r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n\r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n\r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n \r\n#https://leetcode.com/problems/create-sorted-array-through-instructions/discuss/1245397/C%2B%2BJavaPython-Binary-Indexed-Tree-Feel-free-to-reuse   \r\nclass BIT:\r\n    def __init__(self, size):\r\n        self.bit = [0] * (size + 1)\r\n\r\n    def getSum(self, idx):  # Get sum in range [0..idx], 1-based indexing\r\n        s = 0\r\n        while idx > 0:\r\n            s += self.bit[idx]\r\n            idx -= idx & (-idx)\r\n        return s\r\n\r\n    def getSumRange(self, left, right):  # left, right inclusive, 1-based indexing\r\n        return self.getSum(right) - self.getSum(left - 1)\r\n\r\n    def addValue(self, idx, val):  # 1-based indexing\r\n        while idx < len(self.bit):\r\n            self.bit[idx] += val\r\n            idx += idx & (-idx)\r\n            \r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = defaultdict(TrieNode)\r\n        self.word = None\r\n\r\n    def addWord(self, word):\r\n        cur = self\r\n        for c in word:\r\n            cur = cur.children[c]\r\n        cur.word = \"*\"\r\n\r\nclass UnionFind:\r\n    def __init__(self, n):\r\n        self.parent = list(range(n))\r\n        self.size = [1] * n\r\n        self.num_sets = n\r\n\r\n    def find(self, a):\r\n        acopy = a\r\n        while a != self.parent[a]:\r\n            a = self.parent[a]\r\n        while acopy != a:\r\n            self.parent[acopy], acopy = a, self.parent[acopy]\r\n        return a\r\n\r\n    def union(self, a, b):\r\n        a, b = self.find(a), self.find(b)\r\n        if a != b:\r\n            if self.size[a] < self.size[b]:\r\n                a, b = b, a\r\n\r\n            self.num_sets -= 1\r\n            self.parent[b] = a\r\n            self.size[a] += self.size[b]\r\n\r\n    def set_size(self, a):\r\n        return self.size[self.find(a)]\r\n\r\n    def __len__(self):\r\n        return self.num_sets\r\n    \r\nclass LazySegmentTree:\r\n    def __init__(self, data, default=0, func=max):\r\n        \"\"\"initialize the lazy segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n        self._lazy = [0] * (4 * _size)\r\n\r\n        self.data = [default] * (4 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def _push(self, idx):\r\n        \"\"\"push query on idx to its children\"\"\"\r\n        # Let the children know of the queries\r\n        q, self._lazy[idx] = self._lazy[idx], 0\r\n\r\n        self._lazy[2 * idx] += q\r\n        self._lazy[2 * idx + 1] += q\r\n        self.data[2 * idx] += q\r\n        self.data[2 * idx + 1] += q\r\n\r\n    def _update(self, idx):\r\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\r\n        for i in reversed(range(1, idx.bit_length())):\r\n            self._push(idx >> i)\r\n\r\n    def _build(self, idx):\r\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\r\n            idx >>= 1\r\n\r\n    def add(self, start, stop, value):\r\n        \"\"\"lazily add value to [start, stop)\"\"\"\r\n        start = start_copy = start + self._size\r\n        stop = stop_copy = stop + self._size\r\n        while start < stop:\r\n            if start & 1:\r\n                self._lazy[start] += value\r\n                self.data[start] += value\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                self._lazy[stop] += value\r\n                self.data[stop] += value\r\n            start >>= 1\r\n            stop >>= 1\r\n\r\n        # Tell all nodes above of the updated area of the updates\r\n        self._build(start_copy)\r\n        self._build(stop_copy - 1)\r\n\r\n    def query(self, start, stop, default=0):\r\n        \"\"\"func of data[start, stop)\"\"\"\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        # Apply all the lazily stored queries\r\n        self._update(start)\r\n        self._update(stop - 1)\r\n\r\n        res = default\r\n        while start < stop:\r\n            if start & 1:\r\n                res = self._func(res, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res = self._func(res, self.data[stop])\r\n            start >>= 1\r\n            stop >>= 1\r\n        return res\r\n\r\n    def __repr__(self):\r\n        return \"LazySegmentTree({0})\".format(self.data)\r\n    \r\n#Author: beethoven97\r\ndef sieve(n):\r\n    prim = [False] * (n + 1)\r\n    ret = []\r\n    for i in range(2, n + 1):\r\n        if not prim[i]:\r\n            ret.append(i)\r\n            for j in range(i, n + 1, i):\r\n                prim[j] = 1\r\n \r\n    return ret\r\n\r\n# find smallest prime factor for all numbers <= n\r\nclass Prime:\r\n    \r\n    def __init__(self,n):\r\n        self.n = n\r\n        self.smallest_prime = [0]*(self.n+5)\r\n\r\n        for i in range(2, self.n + 1):\r\n            if not self.smallest_prime[i]:\r\n                for j in range(i, self.n + 1, i):\r\n                    self.smallest_prime[j] = i\r\n                    \r\n    def factorise(self,num):\r\n        \r\n        ans = []\r\n        while self.smallest_prime[num] != 0:\r\n            k = self.smallest_prime[num]\r\n            ans.append(k)\r\n            while num % k == 0:\r\n                num //= k\r\n                \r\n        return ans\r\n    \r\n\r\n# Function to find the value of\r\n# P * Q^-1 mod 998244353 (G4G)\r\ndef mod_inverse(p, q, mod):\r\n    \r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\n\r\n#PyRival\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        to = f(*args, **kwargs)\r\n        while True:\r\n            if type(to) is GeneratorType:\r\n                stack.append(to)\r\n                to = next(to)\r\n            else:\r\n                stack.pop()\r\n                if not stack:\r\n                    break\r\n                to = stack[-1].send(to)\r\n        return to\r\n\r\n    return wrappedfunc\r\n\r\n#Author: huikang\r\ndef remove_consecutive_duplicates(lst):\r\n    res = []\r\n    for x in lst:\r\n        if res and x == res[-1]:\r\n            continue\r\n        res.append(x)\r\n    return res\r\n\r\n# nmax = (2*(10**3))+2\r\n \r\n# fact = [1] * (nmax+1)\r\n# for i in range(2, nmax+1):\r\n#     fact[i] = fact[i-1] * i % MOD\r\n    \r\n# inv = [1] * (nmax+1)\r\n# for i in range(2, nmax+1):\r\n#     inv[i] = pow(fact[i], MOD-2, MOD)\r\n \r\n \r\n# def C(n, m):\r\n#     return fact[n] * inv[m] % MOD * inv[n-m] % MOD if 0 <= m <= n else 0\r\n\r\ndef sumtoN(n):\r\n    return ((n)*(n+1)) // 2\r\n\r\ndef powerOf2(n):\r\n    return n > 0 and n & (n-1) == 0\r\n\r\ndef query(a,b):\r\n    print(\"? {} {}\".format(a,b), flush=True)\r\n    response = int(input())\r\n    return response\r\n \r\ndef alert(num):\r\n    print(\"! {}\".format(num), flush=True)\r\n\r\n# d4 = [(0, 1), (-1, 0), (0, -1), (1, 0)]\r\n# d8 = [(0, 1), (-1, 0), (0, -1), (1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\r\n#mod = 1000000007\r\n\r\n'''\r\nKey formulas:\r\n1 XOR n = n-1 when n is odd\r\n1 XOR n = n+1 when n is even\r\na|b = a + b - a & b\r\nXOR and AND is commutative\r\nWhen gcd appears also consider lcm\r\nlowest_ind = graph.index(min(graph, key = len)) #doesnt give the index with minimum length\r\nceiling more feasible to take (val+1)//2 instead of ceil(val/2)\r\n'''\r\n\r\n\r\n\r\ndef read_int(): return(int(input()))\r\ndef read_ints(): return(map(int,input().split()))\r\ndef read_list(): return(list(map(int,input().split())))\r\ndef read_matrix(m,n):\r\n    ans = []\r\n    for _ in range(m):\r\n        ans.append(read_list())\r\n    return ans\r\n\r\n#for Counter on integers use CounterInt, else use Counter\r\ndef solve(n,arr,queries):\r\n\r\n    #print(queries)\r\n    #print(\".....\")\r\n\r\n    accu = list(accumulate(arr))\r\n    cycle_sum = accu[-1]\r\n    #print(accu, cycle_sum)\r\n\r\n    ans = []\r\n    if cycle_sum == 0:\r\n        rem = DefaultDict(list)\r\n        for i,x in enumerate(accu):\r\n            rem[x].append(i)\r\n\r\n        for q in queries:\r\n            if q not in rem:\r\n                ans.append(-1)\r\n                continue\r\n            ans.append(rem[q][0])\r\n        \r\n    else:\r\n        rem = DefaultDict(list)\r\n        for i,x in enumerate(accu):\r\n            rem[x % cycle_sum].append((x,-i))\r\n\r\n        for x in rem:\r\n            rem[x] = sorted(rem[x])\r\n\r\n        #print(rem)\r\n        \r\n\r\n        for q in queries:\r\n            group = q % cycle_sum\r\n            if group not in rem:\r\n                ans.append(-1)\r\n                continue\r\n            group_idx_1 = bisect_right(rem[group],(q,10**10))\r\n            group_idx_2 = bisect_right(rem[group],(q,10**10)) - 1\r\n            found = False\r\n            for group_idx in [group_idx_1, group_idx_2]:\r\n                if group_idx >= len(rem[group]):\r\n                    continue\r\n                start, arr_index = rem[group][group_idx]\r\n                rounds = (q - start) // cycle_sum\r\n                if rounds >= 0:\r\n                    ans.append(rounds * n - arr_index)\r\n                    found = True\r\n            if not found:\r\n                ans.append(-1)\r\n                continue\r\n\r\n    assert len(ans) == m\r\n    return ans\r\n\r\n\r\n       \r\n \r\nt = read_int()\r\nfor _ in range(t):\r\n    n,m = read_ints()\r\n    #n,k = read_ints()\r\n    #arr = input()\r\n    arr = read_list()\r\n    queries = read_list()\r\n    print(*solve(n,arr,queries))\r\n    #if solve(n,arr):\r\n    #    print(\"YES\")\r\n    #else:\r\n    #    print(\"NO\")\r\n    "
}