{
    "id": 145930134,
    "contestId": 272,
    "creationTimeSeconds": 1644570131,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 272,
        "index": "C",
        "name": "Dima and Staircase",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1500,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 272,
        "members": [
            {
                "handle": "canhnam357"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1360769400
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "\ufeff//#pragma optimization_level 3\r\n//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\r\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\r\n//#pragma GCC optimize(\"Ofast\")//Comment optimisations for interactive problems (use endl)\r\n//#pragma GCC target(\"avx,avx2,fma\")\r\n//#pragma GCC optimization (\"unroll-loops\")\r\n//#include <bits/stdc++.h>\r\n//#include <unordered_map>\r\n//#include <unordered_set>\r\n//using namespace std;\r\n//typedef unsigned long long ull;\r\n//typedef long long ll;\r\n//typedef long double ld;\r\n//typedef vector <int> vi;\r\n//typedef vector <ll> vll;\r\n//typedef vector <string> vs;\r\n//typedef vector <vector <int>> vvi;\r\n//typedef vector <vll> vvll;\r\n//typedef map<int, int> mi;\r\n//typedef map<string, int> ms;\r\n//typedef map<char, int> mc;\r\n//typedef map <int, bool> mb;\r\n//typedef map<ll, ll> mll;\r\n//typedef unordered_map<int, int> umi;\r\n//typedef unordered_map<string, int> ums;\r\n//typedef unordered_map<char, int> umc;\r\n//typedef unordered_map <int, bool> umb;\r\n//typedef unordered_map<ll, ll> umll;\r\n//typedef vector <ld> vld;\r\n//typedef vector <bool> vb;\r\n//typedef pair <int, int> pii;\r\n//typedef pair<ll, ll> pll;\r\n//typedef vector <pii> vpii;\r\n//typedef vector <pll> vpll;\r\n//#define FOR(i,N) for(ll i = 0 ; i < N;i++)\r\n//#define eFOR(i,a,b) for(ll i = a; i <=b;i++)\r\n//#define dFOR(i,N) for(ll i = N - 1; i>=0;i--)\r\n//#define edFOR(i,b,a) for(ll i = b ; i >=a;i--)\r\n//#define all(x) x.begin(),x.end()\r\n//#define SORT(x) sort(all(x))\r\n//#define RSORT(x) sort(x.rbegin(), x.rend())\r\n//#define UNQ(x)  unique(all(x))\r\n//#define mine(x) min_element(all(x))\r\n//#define maxe(x) max_element(all(x))\r\n//#define lb(v, x) lower_bound(all(v) , x)\r\n//#define ub(v, x) upper_bound(all(v) , x)\r\n//#define FIX cout << fixed << setprecision(15)\r\n//const long double PI = 3.141592653589793;\r\n//const ll mod = 1e9 + 7;\r\n//bool prime(ll n)\r\n//{\r\n//\tif (n <= 1)\r\n//\t\treturn false;\r\n//\tif (n == 2 or n == 3)\r\n//\t\treturn true;\r\n//\tif (n % 2 == 0 or n % 3 == 0)\r\n//\t\treturn false;\r\n//\tfor (ll i = 5; i * i <= n; i += 6)\r\n//\t\tif (n % i == 0 || n % (i + 2) == 0)\r\n//\t\t\treturn false;\r\n//\treturn true;\r\n//}\r\n//ll __gcd(ll a, ll b)\r\n//{\r\n//\treturn !b ? a : __gcd(b, a % b);\r\n//}\r\n//ll power(ll a, ll b, ll m)\r\n//{\r\n//\tll x = a, res = 1, p = b;\r\n//\twhile (p > 0)\r\n//\t{\r\n//\t\tif (p & 1)\r\n//\t\t\tres *= x;\r\n//\t\tx *= x;\r\n//\t\tx %= m;\r\n//\t\tres %= m;\r\n//\t\tp >>= 1;\r\n//\t}\r\n//\treturn res;\r\n//}\r\n//template <class T>\r\n//void in(T &x)\r\n//{\r\n//\tbool neg = false;\r\n//\tregister T c;\r\n//\tx = 0;\r\n//\tc = getchar();\r\n//\tif (c == '-')\r\n//\t{\r\n//\t\tneg = true;\r\n//\t\tc = getchar();\r\n//\t}\r\n//\tfor (; (c > 47 && c < 58); c = getchar())\r\n//\t\tx = (x << 1) + (x << 3) + c - 48;\r\n//\tif (neg)\r\n//\t\tx *= -1;\r\n//}\r\n//const int base = 1000000000;\r\n//const int base_digits = 9;\r\n//struct bigint {\r\n//\tvector<int> a;\r\n//\tint sign;\r\n//\t/*<arpa>*/\r\n//\tint size() {\r\n//\t\tif (a.empty())return 0;\r\n//\t\tint ans = (a.size() - 1)*base_digits;\r\n//\t\tint ca = a.back();\r\n//\t\twhile (ca)\r\n//\t\t\tans++, ca /= 10;\r\n//\t\treturn ans;\r\n//\t}\r\n//\tbigint operator ^(const bigint &v) {\r\n//\t\tbigint ans = 1, a = *this, b = v;\r\n//\t\twhile (!b.isZero()) {\r\n//\t\t\tif (b % 2)\r\n//\t\t\t\tans *= a;\r\n//\t\t\ta *= a, b /= 2;\r\n//\t\t}\r\n//\t\treturn ans;\r\n//\t}\r\n//\tstring to_string() {\r\n//\t\tstringstream ss;\r\n//\t\tss << *this;\r\n//\t\tstring s;\r\n//\t\tss >> s;\r\n//\t\treturn s;\r\n//\t}\r\n//\tint sumof() {\r\n//\t\tstring s = to_string();\r\n//\t\tint ans = 0;\r\n//\t\tfor (auto c : s)  ans += c - '0';\r\n//\t\treturn ans;\r\n//\t}\r\n//\t/*</arpa>*/\r\n//\tbigint() :\r\n//\t\tsign(1) {\r\n//\t}\r\n//\r\n//\tbigint(long long v) {\r\n//\t\t*this = v;\r\n//\t}\r\n//\r\n//\tbigint(const string &s) {\r\n//\t\tread(s);\r\n//\t}\r\n//\r\n//\tvoid operator=(const bigint &v) {\r\n//\t\tsign = v.sign;\r\n//\t\ta = v.a;\r\n//\t}\r\n//\r\n//\tvoid operator=(long long v) {\r\n//\t\tsign = 1;\r\n//\t\ta.clear();\r\n//\t\tif (v < 0)\r\n//\t\t\tsign = -1, v = -v;\r\n//\t\tfor (; v > 0; v = v / base)\r\n//\t\t\ta.push_back(v % base);\r\n//\t}\r\n//\r\n//\tbigint operator+(const bigint &v) const {\r\n//\t\tif (sign == v.sign) {\r\n//\t\t\tbigint res = v;\r\n//\r\n//\t\t\tfor (int i = 0, carry = 0; i < (int)max(a.size(), v.a.size()) || carry; ++i) {\r\n//\t\t\t\tif (i == (int)res.a.size())\r\n//\t\t\t\t\tres.a.push_back(0);\r\n//\t\t\t\tres.a[i] += carry + (i < (int)a.size() ? a[i] : 0);\r\n//\t\t\t\tcarry = res.a[i] >= base;\r\n//\t\t\t\tif (carry)\r\n//\t\t\t\t\tres.a[i] -= base;\r\n//\t\t\t}\r\n//\t\t\treturn res;\r\n//\t\t}\r\n//\t\treturn *this - (-v);\r\n//\t}\r\n//\r\n//\tbigint operator-(const bigint &v) const {\r\n//\t\tif (sign == v.sign) {\r\n//\t\t\tif (abs() >= v.abs()) {\r\n//\t\t\t\tbigint res = *this;\r\n//\t\t\t\tfor (int i = 0, carry = 0; i < (int)v.a.size() || carry; ++i) {\r\n//\t\t\t\t\tres.a[i] -= carry + (i < (int)v.a.size() ? v.a[i] : 0);\r\n//\t\t\t\t\tcarry = res.a[i] < 0;\r\n//\t\t\t\t\tif (carry)\r\n//\t\t\t\t\t\tres.a[i] += base;\r\n//\t\t\t\t}\r\n//\t\t\t\tres.trim();\r\n//\t\t\t\treturn res;\r\n//\t\t\t}\r\n//\t\t\treturn -(v - *this);\r\n//\t\t}\r\n//\t\treturn *this + (-v);\r\n//\t}\r\n//\r\n//\tvoid operator*=(int v) {\r\n//\t\tif (v < 0)\r\n//\t\t\tsign = -sign, v = -v;\r\n//\t\tfor (int i = 0, carry = 0; i < (int)a.size() || carry; ++i) {\r\n//\t\t\tif (i == (int)a.size())\r\n//\t\t\t\ta.push_back(0);\r\n//\t\t\tlong long cur = a[i] * (long long)v + carry;\r\n//\t\t\tcarry = (int)(cur / base);\r\n//\t\t\ta[i] = (int)(cur % base);\r\n//\t\t\t//asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));\r\n//\t\t}\r\n//\t\ttrim();\r\n//\t}\r\n//\r\n//\tbigint operator*(int v) const {\r\n//\t\tbigint res = *this;\r\n//\t\tres *= v;\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\tvoid operator*=(long long v) {\r\n//\t\tif (v < 0)\r\n//\t\t\tsign = -sign, v = -v;\r\n//\t\tif (v > base) {\r\n//\t\t\t*this = *this * (v / base) * base + *this * (v % base);\r\n//\t\t\treturn;\r\n//\t\t}\r\n//\t\tfor (int i = 0, carry = 0; i < (int)a.size() || carry; ++i) {\r\n//\t\t\tif (i == (int)a.size())\r\n//\t\t\t\ta.push_back(0);\r\n//\t\t\tlong long cur = a[i] * (long long)v + carry;\r\n//\t\t\tcarry = (int)(cur / base);\r\n//\t\t\ta[i] = (int)(cur % base);\r\n//\t\t\t//asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));\r\n//\t\t}\r\n//\t\ttrim();\r\n//\t}\r\n//\r\n//\tbigint operator*(long long v) const {\r\n//\t\tbigint res = *this;\r\n//\t\tres *= v;\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\tfriend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\r\n//\t\tint norm = base / (b1.a.back() + 1);\r\n//\t\tbigint a = a1.abs() * norm;\r\n//\t\tbigint b = b1.abs() * norm;\r\n//\t\tbigint q, r;\r\n//\t\tq.a.resize(a.a.size());\r\n//\r\n//\t\tfor (int i = a.a.size() - 1; i >= 0; i--) {\r\n//\t\t\tr *= base;\r\n//\t\t\tr += a.a[i];\r\n//\t\t\tint s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];\r\n//\t\t\tint s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];\r\n//\t\t\tint d = ((long long)base * s1 + s2) / b.a.back();\r\n//\t\t\tr -= b * d;\r\n//\t\t\twhile (r < 0)\r\n//\t\t\t\tr += b, --d;\r\n//\t\t\tq.a[i] = d;\r\n//\t\t}\r\n//\r\n//\t\tq.sign = a1.sign * b1.sign;\r\n//\t\tr.sign = a1.sign;\r\n//\t\tq.trim();\r\n//\t\tr.trim();\r\n//\t\treturn make_pair(q, r / norm);\r\n//\t}\r\n//\r\n//\tbigint operator/(const bigint &v) const {\r\n//\t\treturn divmod(*this, v).first;\r\n//\t}\r\n//\r\n//\tbigint operator%(const bigint &v) const {\r\n//\t\treturn divmod(*this, v).second;\r\n//\t}\r\n//\r\n//\tvoid operator/=(int v) {\r\n//\t\tif (v < 0)\r\n//\t\t\tsign = -sign, v = -v;\r\n//\t\tfor (int i = (int)a.size() - 1, rem = 0; i >= 0; --i) {\r\n//\t\t\tlong long cur = a[i] + rem * (long long)base;\r\n//\t\t\ta[i] = (int)(cur / v);\r\n//\t\t\trem = (int)(cur % v);\r\n//\t\t}\r\n//\t\ttrim();\r\n//\t}\r\n//\r\n//\tbigint operator/(int v) const {\r\n//\t\tbigint res = *this;\r\n//\t\tres /= v;\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\tint operator%(int v) const {\r\n//\t\tif (v < 0)\r\n//\t\t\tv = -v;\r\n//\t\tint m = 0;\r\n//\t\tfor (int i = a.size() - 1; i >= 0; --i)\r\n//\t\t\tm = (a[i] + m * (long long)base) % v;\r\n//\t\treturn m * sign;\r\n//\t}\r\n//\r\n//\tvoid operator+=(const bigint &v) {\r\n//\t\t*this = *this + v;\r\n//\t}\r\n//\tvoid operator-=(const bigint &v) {\r\n//\t\t*this = *this - v;\r\n//\t}\r\n//\tvoid operator*=(const bigint &v) {\r\n//\t\t*this = *this * v;\r\n//\t}\r\n//\tvoid operator/=(const bigint &v) {\r\n//\t\t*this = *this / v;\r\n//\t}\r\n//\r\n//\tbool operator<(const bigint &v) const {\r\n//\t\tif (sign != v.sign)\r\n//\t\t\treturn sign < v.sign;\r\n//\t\tif (a.size() != v.a.size())\r\n//\t\t\treturn a.size() * sign < v.a.size() * v.sign;\r\n//\t\tfor (int i = a.size() - 1; i >= 0; i--)\r\n//\t\t\tif (a[i] != v.a[i])\r\n//\t\t\t\treturn a[i] * sign < v.a[i] * sign;\r\n//\t\treturn false;\r\n//\t}\r\n//\r\n//\tbool operator>(const bigint &v) const {\r\n//\t\treturn v < *this;\r\n//\t}\r\n//\tbool operator<=(const bigint &v) const {\r\n//\t\treturn !(v < *this);\r\n//\t}\r\n//\tbool operator>=(const bigint &v) const {\r\n//\t\treturn !(*this < v);\r\n//\t}\r\n//\tbool operator==(const bigint &v) const {\r\n//\t\treturn !(*this < v) && !(v < *this);\r\n//\t}\r\n//\tbool operator!=(const bigint &v) const {\r\n//\t\treturn *this < v || v < *this;\r\n//\t}\r\n//\r\n//\tvoid trim() {\r\n//\t\twhile (!a.empty() && !a.back())\r\n//\t\t\ta.pop_back();\r\n//\t\tif (a.empty())\r\n//\t\t\tsign = 1;\r\n//\t}\r\n//\r\n//\tbool isZero() const {\r\n//\t\treturn a.empty() || (a.size() == 1 && !a[0]);\r\n//\t}\r\n//\r\n//\tbigint operator-() const {\r\n//\t\tbigint res = *this;\r\n//\t\tres.sign = -sign;\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\tbigint abs() const {\r\n//\t\tbigint res = *this;\r\n//\t\tres.sign *= res.sign;\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\tlong long longValue() const {\r\n//\t\tlong long res = 0;\r\n//\t\tfor (int i = a.size() - 1; i >= 0; i--)\r\n//\t\t\tres = res * base + a[i];\r\n//\t\treturn res * sign;\r\n//\t}\r\n//\r\n//\tfriend bigint gcd(const bigint &a, const bigint &b) {\r\n//\t\treturn b.isZero() ? a : gcd(b, a % b);\r\n//\t}\r\n//\tfriend bigint lcm(const bigint &a, const bigint &b) {\r\n//\t\treturn a / gcd(a, b) * b;\r\n//\t}\r\n//\r\n//\tvoid read(const string &s) {\r\n//\t\tsign = 1;\r\n//\t\ta.clear();\r\n//\t\tint pos = 0;\r\n//\t\twhile (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {\r\n//\t\t\tif (s[pos] == '-')\r\n//\t\t\t\tsign = -sign;\r\n//\t\t\t++pos;\r\n//\t\t}\r\n//\t\tfor (int i = s.size() - 1; i >= pos; i -= base_digits) {\r\n//\t\t\tint x = 0;\r\n//\t\t\tfor (int j = max(pos, i - base_digits + 1); j <= i; j++)\r\n//\t\t\t\tx = x * 10 + s[j] - '0';\r\n//\t\t\ta.push_back(x);\r\n//\t\t}\r\n//\t\ttrim();\r\n//\t}\r\n//\r\n//\tfriend istream& operator>>(istream &stream, bigint &v) {\r\n//\t\tstring s;\r\n//\t\tstream >> s;\r\n//\t\tv.read(s);\r\n//\t\treturn stream;\r\n//\t}\r\n//\r\n//\tfriend ostream& operator<<(ostream &stream, const bigint &v) {\r\n//\t\tif (v.sign == -1)\r\n//\t\t\tstream << '-';\r\n//\t\tstream << (v.a.empty() ? 0 : v.a.back());\r\n//\t\tfor (int i = (int)v.a.size() - 2; i >= 0; --i)\r\n//\t\t\tstream << setw(base_digits) << setfill('0') << v.a[i];\r\n//\t\treturn stream;\r\n//\t}\r\n//\r\n//\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\r\n//\t\tvector<long long> p(max(old_digits, new_digits) + 1);\r\n//\t\tp[0] = 1;\r\n//\t\tfor (int i = 1; i < (int)p.size(); i++)\r\n//\t\t\tp[i] = p[i - 1] * 10;\r\n//\t\tvector<int> res;\r\n//\t\tlong long cur = 0;\r\n//\t\tint cur_digits = 0;\r\n//\t\tfor (int i = 0; i < (int)a.size(); i++) {\r\n//\t\t\tcur += a[i] * p[cur_digits];\r\n//\t\t\tcur_digits += old_digits;\r\n//\t\t\twhile (cur_digits >= new_digits) {\r\n//\t\t\t\tres.push_back(int(cur % p[new_digits]));\r\n//\t\t\t\tcur /= p[new_digits];\r\n//\t\t\t\tcur_digits -= new_digits;\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tres.push_back((int)cur);\r\n//\t\twhile (!res.empty() && !res.back())\r\n//\t\t\tres.pop_back();\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\ttypedef vector<long long> vll;\r\n//\r\n//\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {\r\n//\t\tint n = a.size();\r\n//\t\tvll res(n + n);\r\n//\t\tif (n <= 32) {\r\n//\t\t\tfor (int i = 0; i < n; i++)\r\n//\t\t\t\tfor (int j = 0; j < n; j++)\r\n//\t\t\t\t\tres[i + j] += a[i] * b[j];\r\n//\t\t\treturn res;\r\n//\t\t}\r\n//\r\n//\t\tint k = n >> 1;\r\n//\t\tvll a1(a.begin(), a.begin() + k);\r\n//\t\tvll a2(a.begin() + k, a.end());\r\n//\t\tvll b1(b.begin(), b.begin() + k);\r\n//\t\tvll b2(b.begin() + k, b.end());\r\n//\r\n//\t\tvll a1b1 = karatsubaMultiply(a1, b1);\r\n//\t\tvll a2b2 = karatsubaMultiply(a2, b2);\r\n//\r\n//\t\tfor (int i = 0; i < k; i++)\r\n//\t\t\ta2[i] += a1[i];\r\n//\t\tfor (int i = 0; i < k; i++)\r\n//\t\t\tb2[i] += b1[i];\r\n//\r\n//\t\tvll r = karatsubaMultiply(a2, b2);\r\n//\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\r\n//\t\t\tr[i] -= a1b1[i];\r\n//\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\r\n//\t\t\tr[i] -= a2b2[i];\r\n//\r\n//\t\tfor (int i = 0; i < (int)r.size(); i++)\r\n//\t\t\tres[i + k] += r[i];\r\n//\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\r\n//\t\t\tres[i] += a1b1[i];\r\n//\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\r\n//\t\t\tres[i + n] += a2b2[i];\r\n//\t\treturn res;\r\n//\t}\r\n//\r\n//\tbigint operator*(const bigint &v) const {\r\n//\t\tvector<int> a6 = convert_base(this->a, base_digits, 6);\r\n//\t\tvector<int> b6 = convert_base(v.a, base_digits, 6);\r\n//\t\tvll a(a6.begin(), a6.end());\r\n//\t\tvll b(b6.begin(), b6.end());\r\n//\t\twhile (a.size() < b.size())\r\n//\t\t\ta.push_back(0);\r\n//\t\twhile (b.size() < a.size())\r\n//\t\t\tb.push_back(0);\r\n//\t\twhile (a.size() & (a.size() - 1))\r\n//\t\t\ta.push_back(0), b.push_back(0);\r\n//\t\tvll c = karatsubaMultiply(a, b);\r\n//\t\tbigint res;\r\n//\t\tres.sign = sign * v.sign;\r\n//\t\tfor (int i = 0, carry = 0; i < (int)c.size(); i++) {\r\n//\t\t\tlong long cur = c[i] + carry;\r\n//\t\t\tres.a.push_back((int)(cur % 1000000));\r\n//\t\t\tcarry = (int)(cur / 1000000);\r\n//\t\t}\r\n//\t\tres.a = convert_base(res.a, 6, base_digits);\r\n//\t\tres.trim();\r\n//\t\treturn res;\r\n//\t}\r\n//};\r\n//int CASE = 1;\r\n//const int mxn = 1e5 + 5;\r\n//const ll infll = 1e18;\r\n//const int infi = 1e9;\r\n//void solve()\r\n//{\r\n//\r\n//}\r\n//int main()\r\n//{\r\n//\tios_base::sync_with_stdio(false);\r\n//\tcin.tie(0);\r\n//\tint T;\r\n//\tcin >> T;\r\n//\twhile (T--)\r\n//\t{\r\n//\t\tsolve();\r\n//\t}\r\n//\treturn 0;\r\n//}\r\n"
}