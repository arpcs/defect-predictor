{
    "id": 175306196,
    "contestId": 272,
    "creationTimeSeconds": 1665380162,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 272,
        "index": "C",
        "name": "Dima and Staircase",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1500,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 272,
        "members": [
            {
                "handle": "hayoung0_0"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1360769400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 13414400,
    "source": "#include <bits/stdc++.h>\r\n\r\n#pragma optimization_level 3\r\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\r\n#pragma GCC optimize(\"Ofast\")//Comment optimisations for interactive problems (use endl)\r\n#pragma GCC target(\"avx,avx2,fma\")\r\n#pragma GCC optimization (\"unroll-loops\")\r\n\r\nusing namespace std;\r\n\r\nstruct PairHash {inline std::size_t operator()(const std::pair<int, int> &v) const { return v.first * 31 + v.second; }};\r\n\r\n// speed\r\n#define Code ios_base::sync_with_stdio(false);\r\n#define By ios::sync_with_stdio(0);\r\n#define Sumfi cout.tie(NULL);\r\n\r\n// alias\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing ull = unsigned long long;\r\n\r\n// constants\r\nconst ld PI = 3.14159265358979323846;  /* pi */\r\nconst ll INF = 1e18;\r\nconst ld EPS = 1e-9;\r\nconst ll MAX_N = 101010;\r\nconst ll mod = 998244353;\r\n\r\n// typedef\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<pll> vpll;\r\ntypedef array<ll,3> all3;\r\ntypedef array<ll,5> all5;\r\ntypedef vector<all3> vall3;\r\ntypedef vector<all5> vall5;\r\ntypedef vector<ld> vld;\r\ntypedef vector<ll> vll;\r\ntypedef vector<vll> vvll;\r\ntypedef vector<int> vi;\r\ntypedef pair<string, string> pss;\r\ntypedef vector<pss> vpss;\r\ntypedef vector<string> vs;\r\ntypedef vector<vs> vvs;\r\ntypedef unordered_set<ll> usll;\r\ntypedef unordered_set<pll, PairHash> uspll;\r\ntypedef unordered_map<ll, ll> umll;\r\ntypedef unordered_map<pll, ll, PairHash> umpll;\r\n\r\n// macros\r\n#define rep(i,m,n) for(ll i=m;i<n;i++)\r\n#define rrep(i,m,n) for(ll i=n;i>=m;i--)\r\n#define all(a) begin(a), end(a)\r\n#define rall(a) rbegin(a), rend(a)\r\n#define ZERO(a) memset(a,0,sizeof(a))\r\n#define MINUS(a) memset(a,0xff,sizeof(a))\r\n#define INF(a) memset(a,0x3f3f3f3f3f3f3f3fLL,sizeof(a))\r\n#define ASCEND(a) iota(all(a),0)\r\n#define sz(x) ll((x).size())\r\n#define pyes cout<<\"YES\\n\";\r\n#define pno cout<<\"NO\\n\";\r\n#define pneg1 cout<<\"-1\\n\";\r\n#define ppossible cout<<\"Possible\\n\";\r\n#define pimpossible cout<<\"Impossible\\n\";\r\n#define TC(x) cout<<\"Case #\"<<x<<\": \";\r\n#define X first\r\n#define Y second\r\n\r\n// utility functions\r\ntemplate <typename T>\r\nvoid print(T &&t)  { cout << t << \"\\n\"; }\r\ntemplate<typename T>\r\nvoid printv(vector<T>v){ll n=v.size();rep(i,0,n)cout<<v[i]<<\" \";cout<<\"\\n\";}\r\nvoid fileIO() {freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);}\r\nvoid hackerCupIO() {freopen(\"/Users/summerflower/Downloads/worklife_balance_chapter_1_input (1).txt\", \"r\", stdin); freopen(\"/Users/summerflower/Downloads/solution.txt\",\"w\",stdout);}\r\nvoid readf() {freopen(\"\", \"rt\", stdin);}\r\ntemplate<typename T>\r\nvoid readv(vector<T>& v){rep(i,0,sz(v)) cin>>v[i];}\r\ntemplate<typename T, typename U>\r\nvoid readp(pair<T,U>& A) {cin>>A.first>>A.second;}\r\ntemplate<typename T, typename U>\r\nvoid readvp(vector<pair<T,U>>& A) {rep(i,0,sz(A)) readp(A[i]); }\r\nvoid readvall3(vall3& A) {rep(i,0,sz(A)) cin>>A[i][0]>>A[i][1]>>A[i][2];}\r\nvoid readvvll(vvll& A) {rep(i,0,sz(A)) readv(A[i]);}\r\n\r\nstruct Combination {\r\n    vll fac, inv;\r\n    ll n, MOD;\r\n\r\n    ll modpow(ll n, ll x, ll MOD = mod) { if(!x) return 1; ll res = modpow(n,x>>1,MOD); res = (res * res) % MOD; if(x&1) res = (res * n) % MOD; return res; }\r\n\r\n    Combination(ll _n, ll MOD = mod): n(_n + 1), MOD(MOD) {\r\n        inv = fac = vll(n,1);\r\n        rep(i,1,n) fac[i] = fac[i-1] * i % MOD;\r\n        inv[n - 1] = modpow(fac[n - 1], MOD - 2, MOD);\r\n        rrep(i,1,n - 2) inv[i] = inv[i + 1] * (i + 1) % MOD;\r\n    }\r\n\r\n    ll fact(ll n) {return fac[n];}\r\n    ll nCr(ll n, ll r) {\r\n        if(n < r or n < 0 or r < 0) return 0;\r\n        return fac[n] * inv[r] % MOD * inv[n-r] % MOD;\r\n    }\r\n};\r\n\r\n// geometry data structures\r\ntemplate <typename T>\r\nstruct Point {\r\n    T y,x;\r\n    Point(T y, T x) : y(y), x(x) {}\r\n    Point() {}\r\n    void input() {cin>>y>>x;}\r\n    friend ostream& operator<<(ostream& os, const Point<T>& p) { os<<p.y<<' '<<p.x<<'\\n'; return os;}\r\n    Point<T> operator+(Point<T>& p) {return Point<T>(y + p.y, x + p.x);}\r\n    Point<T> operator-(Point<T>& p) {return Point<T>(y - p.y, x - p.x);}\r\n    Point<T> operator*(ll n) {return Point<T>(y*n,x*n); }\r\n    Point<T> operator/(ll n) {return Point<T>(y/n,x/n); }\r\n\r\n    Point<T> rotate(Point<T> center, ld angle) {\r\n        ld si = sin(angle * PI / 180.), co = cos(angle * PI / 180.);\r\n        ld y = this->y - center.y;\r\n        ld x = this->x - center.x;\r\n\r\n        return Point<T>(y * co - x * si + center.y, y * si + x * co + center.x);\r\n    }\r\n};\r\n\r\ntemplate<typename T>\r\nstruct Circle {\r\n    Point<T> center;\r\n    T radius;\r\n    Circle(T y, T x, T radius) : center(Point<T>(y,x)), radius(radius) {}\r\n    Circle() {}\r\n\r\n    void input() {\r\n        center = Point<T>();\r\n        center.input();\r\n        cin>>radius;\r\n    }\r\n\r\n    bool circumference(Point<T> p) {\r\n        return (center.x - p.x) * (center.x - p.x) + (center.y - p.y) * (center.y - p.y) == radius * radius;\r\n    }\r\n\r\n    bool intersect(Circle<T> c) {\r\n        T d = (center.x - c.center.x) * (center.x - c.center.x) + (center.y - c.center.y) * (center.y - c.center.y);\r\n        return (radius - c.radius) * (radius - c.radius) <= d and d <= (radius + c.radius) * (radius + c.radius);\r\n    }\r\n};\r\n\r\nll __gcd(ll x, ll y) { return !y ? x : __gcd(y, x % y); }\r\nall3 __exgcd(ll x, ll y) { if(!y) return {x,1,0}; auto [g,x1,y1] = __exgcd(y, x % y); return {g, y1, x1 - (x/y) * y1}; }\r\nll __lcm(ll x, ll y) { return x / __gcd(x,y) * y; }\r\nll modpow(ll n, ll x, ll MOD = mod) { n%=MOD; if(!x) return 1; ll res = modpow(n,x>>1,MOD); res = (res * res) % MOD; if(x&1) res = (res * n) % MOD; return res; }\r\n\r\nll seg[MAX_N * 4], lazy[MAX_N * 4];\r\n\r\nvoid lazyQuery(ll u, ll s, ll e) {\r\n    if(!lazy[u]) return;\r\n    seg[u] = max(seg[u], lazy[u]);\r\n    if(s ^ e) {\r\n        lazy[u * 2] = lazy[u];\r\n        lazy[u * 2 + 1] = lazy[u];\r\n    }\r\n    lazy[u] = 0;\r\n}\r\n\r\nll query(ll u, ll s, ll e, ll l, ll r) {\r\n    lazyQuery(u,s,e);\r\n    if(r < s or e < l) return 0;\r\n    if(l <= s and e <= r) return seg[u];\r\n    ll m = s + (e - s) / 2;\r\n    return max(query(u * 2, s, m, l, r), query(u * 2 + 1, m + 1, e, l, r));\r\n}\r\n\r\nvoid update(ll u, ll s, ll e, ll l, ll r, ll v) {\r\n    lazyQuery(u,s,e);\r\n    if(r < s or e < l) return;\r\n    if(l <= s and e <= r) {\r\n        seg[u] = max(seg[u], v);\r\n        if(s ^ e) {\r\n            lazy[u * 2] = max(lazy[u * 2], v);\r\n            lazy[u * 2 + 1] = max(lazy[u * 2 + 1], v);\r\n        }\r\n        return;\r\n    }\r\n    ll m = s + (e - s) / 2;\r\n    update(u * 2, s, m, l, r, v);\r\n    update(u * 2 + 1, m + 1, e, l, r, v);\r\n    seg[u] = max(seg[u * 2], seg[u * 2 + 1]);\r\n}\r\n\r\nvll solve(vll A, vpll B) {\r\n    ll n = sz(A) + 1;\r\n    rep(i,0,sz(A)) update(1,1,n,i+1,i+1,A[i]);\r\n    vll res;\r\n    rep(i,0,sz(B)) {\r\n        auto [w,h] = B[i];\r\n        ll ma = query(1,1,n,1,w);\r\n        res.push_back(ma);\r\n        update(1,1,n,1,w,ma + h);\r\n    }\r\n    return res;\r\n}\r\n\r\nint main() {\r\n    Code By Sumfi\r\n    cout.precision(12);\r\n    ll tc = 1;\r\n    //cin>>tc;\r\n    rep(i,1,tc+1) {\r\n        ll n,m;\r\n        cin>>n;\r\n        vll A(n);\r\n        readv(A);\r\n        cin>>m;\r\n        vpll B(m);\r\n        readvp(B);\r\n        for(auto r : solve(A,B)) print(r);\r\n    }\r\n    return 0;\r\n}"
}