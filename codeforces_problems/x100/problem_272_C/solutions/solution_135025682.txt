{
    "id": 135025682,
    "contestId": 272,
    "creationTimeSeconds": 1636668755,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 272,
        "index": "C",
        "name": "Dima and Staircase",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1500,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 272,
        "members": [
            {
                "handle": "ArtemParkhomets"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1360769400
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 248,
    "memoryConsumedBytes": 1638400,
    "source": "\ufeff#define _CRT_SECURE_NO_WARNINGS\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <iterator>\r\n#include <cstdio>\r\n#include <vector>\r\n#include <string>\r\n#include <sstream>\r\n#include <regex>\r\n#include <numeric>\r\n#include <cmath>\r\n#include <algorithm>\r\n#include <set>\r\n#include <map>\r\n#include <deque>\r\n#include <queue>\r\n#include <stack>\r\n#include <utility>\r\n#include <random>\r\n#include <bitset>\r\n#include <list>\r\n#include <functional>\r\n#include <chrono>\r\n#include <fstream>\r\n#include <array>\r\n#include <tuple>\r\nusing namespace std;\r\ntemplate < class T, typename A = allocator<T> >\r\nclass Vector : public vector<T, A>\r\n{\r\npublic:\r\n\tusing vector<T, A>::vector;\r\n\tusing typename vector<T, A>::size_type;\r\n\tusing typename vector<T, A>::value_type;\r\n\tusing typename vector<T, A>::allocator_type;\r\n\tVector& operator()(size_type dummy_n, const value_type& val = value_type(), const allocator_type& alloc = allocator_type()) { return *this; }\r\n};\r\ntemplate<> class Vector<string> : public vector<string> { public:using vector<string>::vector; Vector& operator()(size_type dummy_n) { return *this; } };\r\ntypedef long long ll;            typedef unsigned int u;        typedef unsigned long long ull;\r\ntypedef pair<int, int> pii;      typedef pair<u, u> puu;\r\ntypedef Vector<bool> vb;// Vector\r\ntypedef Vector<int> vi;          typedef Vector<u> vu;\r\ntypedef Vector<ll> vll;\r\ntypedef Vector<string> vs;\r\ntypedef Vector<pii> vpii;        typedef Vector<puu> vpuu;\r\ntypedef Vector<Vector<int>> vvi; typedef Vector<Vector<u>> vvu;\r\ntypedef set<int> si;             typedef set<u> su;\r\ntypedef multiset<int> Si;        typedef multiset<u> Su;\r\ntypedef map<int, int> mi;        typedef map<u, u> mu;\r\ntypedef multimap<int, int> Mi;   typedef multimap<u, u> Mu;\r\ntemplate < typename Int = int > // only integral types // that can be {initialized} with int\r\ninline Int read() // \"([number][space or newline])*\" // reads -int_max but doesn't read int_min\r\n{\r\n\tint c{ getchar() };\r\n\tif (c == '-') {\r\n\t\tInt init{ getchar() & 15 };\r\n\t\twhile ((c = getchar()) & 16) init = (init << 3) + (init << 1) + (c & 15);\r\n\t\treturn ++(init = ~init);\r\n\t}\r\n\telse {\r\n\t\tInt init{ c & 15 };\r\n\t\twhile ((c = getchar()) & 16) init = (init << 3) + (init << 1) + (c & 15);\r\n\t\treturn init;\r\n\t}\r\n}\r\ninline void read(int& a) // \"([number][space or newline])*\" // reads -int_max but doesn't read int_min\r\n{\r\n\ta = getchar() & 15;\r\n\tif (a == 13) {\r\n\t\ta = getchar() & 15;\r\n\t\tfor (int c; (c = getchar()) & 16; a = (a << 3) + (a << 1) + (c & 15));\r\n\t\t++(a = ~a);\r\n\t}\r\n\telse\r\n\t\tfor (int c; (c = getchar()) & 16; a = (a << 3) + (a << 1) + (c & 15));\r\n}\r\ninline void read(unsigned int& a) // \"([number][space or newline])*\" \r\n{\r\n\ta = getchar() & 15;\r\n\tfor (int c; (c = getchar()) & 16; a = (a << 3) + (a << 1) + (c & 15));\r\n}\r\ninline void read(ull& a) // \"([number][space or newline])*\" \r\n{\r\n\ta = getchar() & 15;\r\n\tfor (int c; (c = getchar()) & 16; a = (a << 3) + (a << 1) + (c & 15));\r\n}\r\ninline void read(char& a) { scanf(\"%c%*c\", &a); } // \"([char][delim])*\"\r\ninline void read(string& a) { static char BUF[1234560]; scanf(\"%s%*c\", BUF); a = move(string(BUF)); } // \"([string][delim])*\"\r\ninline void read(ll& a) { a = read<ll>(); } // \"([number][space or newline])*\"\r\ninline void read(double& a) { scanf(\"%lf%*c\", &a); } // \"([double][delim])*\"\r\ntemplate < class T1, class T2 >\r\ninline void read(pair<T1, T2>& a) { read(a.first); read(a.second); } // \"([first][space or newline][second][space or newline])*\"\r\ntemplate<template<typename T, typename A = allocator<T> > class C, class T>\r\ninline void read(C<T>& a) { for (auto i = a.begin(); i != a.end(); ++i) read(*i); }\r\ntemplate < typename T, typename U, typename... ARGS >\r\ninline void read(T& t, U& u, ARGS&... args) {\r\n\tread(t);\r\n\tread(u, args...);\r\n}\r\ntemplate < typename Int > // only integral types\r\ninline void write(Int x)\r\n{\r\n\tstatic char BUF[64] = {};\r\n\tchar *pnt{ BUF + 64 };\r\n\tif (x < 0) {\r\n\t\tputchar('-');\r\n\t\t++(x = ~x);\r\n\t}\r\n\tdo\r\n\t\t*--pnt = x % 10 | 48;\r\n\twhile (x /= 10);\r\n\tprintf(\"%s\", pnt);\r\n}\r\ninline void write(unsigned int a)\r\n{\r\n\tstatic char BUF[16] = {};\r\n\tchar *pnt{ BUF + 16 };\r\n\tdo\r\n\t\t*--pnt = a % 10 | 48;\r\n\twhile (a /= 10);\r\n\tprintf(\"%s\", pnt);\r\n}\r\ninline void write(const char& a) { printf(\"%c\", a); }\r\ninline void write(const char* a) { printf(\"%s\", a); }\r\ninline void write(const string& a) { printf(\"%s\", a.c_str()); }\r\ninline void write(const double& a) { printf(\"%lf\", a); }\r\ntemplate < class T1, class T2 >\r\ninline void write(const pair<T1, T2>& a) { write(a.first); write(' '); write(a.second); }\r\ntemplate<template<typename T, typename A = allocator<T> > class C, class T>\r\ninline void write(const C<T>& a) { if (a.size()) { auto i = a.begin(); write(*i++); for (; i != a.end(); ++i) { write(' '); write(*i); } } }\r\ntemplate < typename T, typename U, typename... ARGS >\r\ninline void write(const T& t, const U& u, const ARGS&... args) {\r\n\twrite(t);\r\n\twrite(' ');\r\n\twrite(u, args...);\r\n}\r\ntemplate<template<typename T, typename A = allocator<T> > class C, class T>\r\ninline void sort(C<T>& a) { sort(a.begin(), a.end()); }\r\ninline void sort(string& a) { sort(a.begin(), a.end()); }\r\ntemplate<template<typename T, typename A = allocator<T> > class C, class T>\r\ninline void rsort(C<T>& a) { sort(a.rbegin(), a.rend()); }\r\ninline void rsort(string& a) { sort(a.rbegin(), a.rend()); }\r\ntemplate < template < class T, class Compare = less<T>, class Alloc = allocator<T> > class C, class T>\r\ninline bool in(const C<T>& c, const T& el) { return c.find(el) != c.end(); };\r\ntemplate < template < class Key, class T, class Compare = less<Key>, class Alloc = allocator<pair<const Key, T> > > class C, class Key, class T>\r\ninline bool in(const C<Key, T>& c, const Key& el) { return c.find(el) != c.end(); };\r\ntemplate < template<typename T, typename A = allocator<T> > class C, class T>\r\ninline bool in(const C<T>& c, const T& el) { return find(c.begin(), c.end(), el) != c.end(); };\r\ntemplate < template < class T, class Compare = less<T>, class Alloc = allocator<T> > class C, class T>\r\ninline bool out(const C<T>& c, const T& el) { return c.find(el) == c.end(); };\r\ntemplate < template < class Key, class T, class Compare = less<Key>, class Alloc = allocator<pair<const Key, T> > > class C, class Key, class T>\r\ninline bool out(const C<Key, T>& c, const Key& el) { return c.find(el) == c.end(); };\r\ntemplate < template<typename T, typename A = allocator<T> > class C, class T>\r\ninline bool out(const C<T>& c, const T& el) { return find(c.begin(), c.end(), el) == c.end(); }\r\n#define MX 1000000000\r\n#define all(a) (a).begin(),(a).end()\r\n#define rall(a) (a).rbegin(),(a).rend()\r\n#define T(n) for(decltype(n) _VARIABLE{(n) + 1}; --_VARIABLE;) // decltype(n) where n cannot be const\r\n#define F(b,e,i) for(auto _VAR1 = (decltype(e))(b), _VAR2 = (e), i = _VAR1; i != _VAR2; _VAR1 < _VAR2 ? ++i : --i)\r\n#define G(f,l,i) for(auto _VAR1 = (decltype(l))(f), _VAR2 = (l), _VAR3 = _VAR2+(_VAR1 < _VAR2 ? 1 : -1), i = _VAR1; i != _VAR3; _VAR1 < _VAR2 ? ++i : --i)\r\n#define M(f,l,i,j) for(auto i = (decltype(l))(f) , j = (l) ; i < j; ++i, --j)\r\n#define R(type, ...) type __VA_ARGS__; read(__VA_ARGS__)\r\n#define W(...) write(__VA_ARGS__), write('\\n')\r\n#define bgn begin()\r\n#define rbgn rbegin()\r\n#define nd end()\r\n#define rnd rend()\r\n#define pb push_back\r\n#define fnt front()\r\n#define bck back()\r\n#define sz size()\r\n#define x first\r\n#define y second\r\n\r\nint main()\r\n{\r\n#ifndef ONLINE_JUDGE\r\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\t// \u043a\u0438\u0434\u0430\u044e\u0442\u044c \u043f\u0440\u044f\u043c\u043e\u043a\u0443\u0442\u043d\u0456 \u043a\u043e\u0440\u043e\u0431\u043a\u0438 \u043d\u0430 \u0441\u0445\u043e\u0434\u0438\u043d\u043a\u0438 \u0440\u0456\u0437\u043d\u043e\u0457 \u0432\u0438\u0441\u043e\u0442\u0438\r\n\t// \u0430\u043b\u0435 \u043a\u043e\u0440\u043e\u0431\u043a\u0438 \u043f\u0430\u0434\u0430\u044e\u0442\u044c \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u043e \u0434\u043e \u043b\u0456\u0432\u043e\u0433\u043e \u043a\u0440\u0430\u044e\r\n\t//\r\n\t//  \r\n\t//====a=array====l=left====c=current====\r\n\tR(u, n);\r\n\tR(vu, a(n));\r\n\tR(u, m);\r\n\tu l{ a.fnt };\r\n\tT(m) {\r\n\t\tR(u, w, h);\r\n\t\tu c{ max(l, a[w - 1]) };\r\n\t\tW(c);\r\n\t\tl = c + h;\r\n\t}\r\n}\r\n// \r\n// ArtemParkhomets\r\n// "
}