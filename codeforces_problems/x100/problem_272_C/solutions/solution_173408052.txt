{
    "id": 173408052,
    "contestId": 272,
    "creationTimeSeconds": 1664098236,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 272,
        "index": "C",
        "name": "Dima and Staircase",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1500,
        "tags": [
            "data structures",
            "implementation"
        ]
    },
    "author": {
        "contestId": 272,
        "members": [
            {
                "handle": "imshubh7"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1360769400
    },
    "programmingLanguage": "Java 11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 592,
    "memoryConsumedBytes": 0,
    "source": "/*\r\n        @Author Shubham Chaudhari\r\n */\r\n\r\nimport java.io.*;\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.Parameter;\r\nimport java.util.*;\r\npublic class Main {\r\n\r\n    static FastReader in=new FastReader();\r\n    static final Random random=new Random();\r\n    static long mod=1000000007L;\r\n    static HashMap<String,Long>map=new HashMap<>();\r\n\r\n    public static void main(String[] args) {\r\n        int t=1;//in.nextInt();\r\n        StringBuilder res=new StringBuilder();\r\n        loop:\r\n        while(t-->0){\r\n            int n=in.nextInt();\r\n            int a[]=in.readintarray(n);\r\n            int m=in.nextInt();\r\n            int[] maxarr= new int[n];\r\n            int maxval=a[0];\r\n\r\n            for(int i=0;i<n;i++){\r\n                maxval=Math.max(a[i],maxval);\r\n                maxarr[i]=maxval;\r\n            }\r\n            int rightmost=0;\r\n            int zeroheight=a[0];\r\n            while (m-->0){\r\n                int w=in.nextInt();\r\n                int h=in.nextInt();\r\n                if(rightmost<w){\r\n                    int val=Math.max(zeroheight,maxarr[w-1]);\r\n                    zeroheight=val+h;\r\n                    res.append(val+\"\\n\");\r\n                }\r\n                else{\r\n                    res.append(zeroheight+\"\\n\");\r\n                    zeroheight+=h;\r\n                }\r\n            }\r\n        }\r\n        System.out.println(res);\r\n    }\r\n\r\n    static class Pair implements Comparable<Pair>{\r\n        int p;\r\n        int f;\r\n\r\n        public Pair(int p,int f){\r\n            this.p=p;\r\n            this.f=f;\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(Pair o) {\r\n            return f-o.f;\r\n        }\r\n    }\r\n    static class Pair2 {\r\n        int a,b;\r\n        int p;\r\n\r\n        public Pair2(int a,int b,int p){\r\n            this.a=a;\r\n            this.b=b;\r\n            this.p=p;\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    static boolean isPalindrome(int n){\r\n        int tmp=n;\r\n        int tmp2=0;\r\n        while (n>0){\r\n            tmp2=tmp2*10+n%10;\r\n            n/=10;\r\n        }\r\n        return tmp==tmp2;\r\n    }\r\n\r\n    static long calculateSum(long n)\r\n    {\r\n        if(n<0)\r\n        {\r\n            return 0;\r\n        }\r\n        return n*(n+1)/2;\r\n    }\r\n\r\n\r\n    static void ruffleSort(int[] a) {\r\n        int n=a.length;\r\n        for (int i=0; i<n; i++) {\r\n            int oi=random.nextInt(n), temp=a[oi];\r\n            a[oi]=a[i]; a[i]=temp;\r\n        }\r\n        Arrays.sort(a);\r\n    }\r\n    static void ruffleSort(long[] a) {\r\n        int n=a.length;\r\n        for (int i=0; i<n; i++) {\r\n            int oi=random.nextInt(n);\r\n            long temp=a[oi];\r\n            a[oi]=a[i]; a[i]=temp;\r\n        }\r\n        Arrays.sort(a);\r\n    }\r\n\r\n\r\n    static  int gcd(int a,int b)\r\n    {\r\n        if(b==0)\r\n        {\r\n            return a;\r\n        }\r\n        return gcd(b,a%b);\r\n    }\r\n\r\n    static int lcm(int a, int b)\r\n    {\r\n        return (a / gcd(a, b)) * b;\r\n    }\r\n\r\n\r\n    static int abs(int a)\r\n    {\r\n        if(a<0)\r\n            return -1*a;\r\n        return a;\r\n    }\r\n\r\n    static class FastReader\r\n    {\r\n        BufferedReader br;\r\n        StringTokenizer st;\r\n\r\n        public FastReader()\r\n        {\r\n            br = new BufferedReader(new\r\n                    InputStreamReader(System.in));\r\n        }\r\n\r\n        String next()\r\n        {\r\n            while (st == null || !st.hasMoreElements())\r\n            {\r\n                try\r\n                {\r\n                    st = new StringTokenizer(br.readLine());\r\n                }\r\n                catch (IOException  e)\r\n                {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            return st.nextToken();\r\n        }\r\n        int nextInt()\r\n        {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        long nextLong()\r\n        {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        double nextDouble()\r\n        {\r\n            return Double.parseDouble(next());\r\n        }\r\n        String nextLine()\r\n        {\r\n            String str = \"\";\r\n            try\r\n            {\r\n                str = br.readLine();\r\n            }\r\n            catch (IOException e)\r\n            {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n\r\n        int [] readintarray(int n) {\r\n            int res [] = new int [n];\r\n            for(int i = 0; i<n; i++)res[i] = nextInt();\r\n            return res;\r\n        }\r\n        long [] readlongarray(int n) {\r\n            long res [] = new long [n];\r\n            for(int i = 0; i<n; i++)res[i] = nextLong();\r\n            return res;\r\n        }\r\n    }\r\n    static class Node implements Comparable<Node>\r\n    {\r\n        int val;\r\n        long cost;\r\n        public Node(int val,long cost)\r\n        {\r\n            this.val=val;\r\n            this.cost=cost;\r\n        }\r\n        public int compareTo(Node x)\r\n        {\r\n            return Long.compare(this.cost,x.cost);\r\n        }\r\n    }\r\n\r\n    static class UWGraph{\r\n\r\n        public static ArrayList<WNode> graph[];\r\n        public int V;\r\n        public static PriorityQueue<WNode> pq;\r\n\r\n        public UWGraph(int V){\r\n            graph=new ArrayList[V];\r\n            for(int i=0;i<V;i++){\r\n                graph[i]=new ArrayList<WNode>();\r\n            }\r\n            this.V=V;\r\n        }\r\n\r\n        public void addEdge(int v,int u,int w){\r\n            graph[v].add(new WNode(u,w));\r\n            graph[u].add(new WNode(v,w));\r\n        }\r\n\r\n        public int[] dijkstra(int src)\r\n        {\r\n            int[] distance = new int[V];\r\n            for (int i = 0; i < V; i++)\r\n                distance[i] = Integer.MAX_VALUE;\r\n            distance[src] = 0;\r\n\r\n            pq = new PriorityQueue<>();\r\n            pq.add(new WNode(src, 0));\r\n            boolean done[]=new boolean[V];\r\n            while (pq.size() > 0) {\r\n\r\n                WNode current = pq.poll();\r\n                if(done[current.getVertex()])\r\n                    continue;\r\n                done[current.getVertex()]=true;\r\n                for (WNode n : graph[current.getVertex()]) {\r\n                    if (distance[current.getVertex()] + n.getWeight() < distance[n.getVertex()]) {\r\n                        distance[n.getVertex()] = n.getWeight() + distance[current.getVertex()];\r\n                        pq.add(new WNode(n.getVertex(), distance[n.getVertex()]));\r\n                    }\r\n                }\r\n            }\r\n            return distance;\r\n        }\r\n    }\r\n\r\n    static class WNode implements Comparable<WNode>{\r\n        public int vertex, weight;\r\n\r\n        WNode(int v, int w)\r\n        {\r\n            vertex = v;\r\n            weight = w;\r\n        }\r\n        int getVertex() { return vertex; }\r\n        int getWeight() { return weight; }\r\n\r\n        @Override\r\n        public int compareTo(WNode o) {\r\n            return weight-o.weight;\r\n        }\r\n    }\r\n\r\n    static class UNGraph{\r\n\r\n        public ArrayList<Integer> graph[];\r\n        public int V;\r\n\r\n        public UNGraph(int V){\r\n            graph=new ArrayList[V];\r\n            for(int i=0;i<V;i++){\r\n                graph[i]=new ArrayList<Integer>();\r\n            }\r\n            this.V=V;\r\n        }\r\n\r\n        public void addEdge(int v,int u){\r\n            graph[v].add(u);\r\n            graph[u].add(v);\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    static class SegmentTree{\r\n\r\n        long st[];\r\n        int minCount;\r\n        long minVal;\r\n\r\n        public SegmentTree(long arr[],int n){\r\n            int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\r\n            minCount=0;\r\n\r\n            //Maximum size of segment tree\r\n            int max_size = 2 * (int) Math.pow(2, x) - 1;\r\n\r\n            st = new long[max_size]; // Memory allocation\r\n\r\n            constructSTUtil(arr, 0, n - 1, 0);\r\n        }\r\n\r\n        long constructSTUtil(long arr[], int ss, int se, int si)\r\n        {\r\n            if (ss == se) {\r\n                st[si] = arr[ss];\r\n                return arr[ss];\r\n            }\r\n            int mid = getMid(ss, se);\r\n            st[si] = Math.min(constructSTUtil(arr, ss, mid, si * 2 + 1),\r\n                    constructSTUtil(arr, mid + 1, se, si * 2 + 2));\r\n            return st[si];\r\n        }\r\n\r\n        int getMid(int s, int e) {\r\n            return s + (e - s) / 2;\r\n        }\r\n        long updateValueUtil(int ss, int se, int i, long diff, int si)\r\n        {\r\n            // Base Case: If the input index lies outside the range of\r\n            // this segment\r\n            if (i < ss || i > se)\r\n                return st[si];\r\n\r\n            // If the input index is in range of this node, then update the\r\n            // value of the node and its children\r\n            if (se != ss) {\r\n                int mid = getMid(ss, se);\r\n                st[si] = Math.min(\r\n                        updateValueUtil(ss, mid, i, diff, 2 * si + 1),\r\n                        updateValueUtil(mid + 1, se, i, diff, 2 * si + 2));\r\n            }\r\n            else{\r\n                st[si]=diff;\r\n            }\r\n            return st[si];\r\n        }\r\n\r\n        // The function to update a value in input array and segment tree.\r\n        // It uses updateValueUtil() to update the value in segment tree\r\n        void updateValue(long arr[], int n, int i, int new_val)\r\n        {\r\n            // Check for erroneous input index\r\n            if (i < 0 || i > n - 1) {\r\n                return;\r\n            }\r\n\r\n            // Get the difference between new value and old value\r\n            long diff = new_val;\r\n\r\n            // Update the value in array\r\n            arr[i] = new_val;\r\n\r\n            // Update the values of nodes in segment tree\r\n            updateValueUtil(0, n - 1, i, diff, 0);\r\n        }\r\n\r\n        // End of template\r\n\r\n        public long getSum(int n,int l, int r){\r\n            minCount=0;\r\n            minVal= getSumUtil(0,n-1,l,r,0);\r\n            return minVal;\r\n        }\r\n\r\n        public long getSumUtil(int ss, int se,int l, int r, int si){\r\n\r\n            int mid = getMid(ss,se);\r\n\r\n            if(si>=st.length){\r\n                return Integer.MAX_VALUE;\r\n            }\r\n\r\n            if(ss>=l&&se<=r){\r\n                if(ss==se && minVal==st[si]){\r\n                    minCount++;\r\n                }\r\n                getSumUtil(ss,mid,l,r,2*si+1);\r\n                getSumUtil(mid+1,se,l,r,2*si+2);\r\n                return st[si];\r\n            }\r\n\r\n            if (se < l || ss > r)\r\n                return Integer.MAX_VALUE;\r\n\r\n            if(ss==se && minVal==st[si]){\r\n                minCount++;\r\n            }\r\n\r\n            return Math.min(getSumUtil(ss,mid,l,r,2*si+1),getSumUtil(mid+1,se,l,r,2*si+2));\r\n        }\r\n\r\n        void printSegmentTree(){\r\n            for(long x: st){\r\n                System.out.print(x+\" \");\r\n            }\r\n            System.out.println();\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}