{
    "id": 126426226,
    "contestId": 1178,
    "creationTimeSeconds": 1629364486,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1178,
        "index": "D",
        "name": "Prime Graph",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1500,
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1178,
        "members": [
            {
                "handle": "Its_Hard_To_Hit_Me"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1563636900
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 37,
    "timeConsumedMillis": 109,
    "memoryConsumedBytes": 20377600,
    "source": "import java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.*;\r\npublic class Main{\r\n    static int mod=(int)1e9+9;\r\n    static boolean isPerfectSquare(long x)\r\n    {\r\n        if (x >= 0) {\r\n           \r\n            // Find floating point value of\r\n            // square root of x.\r\n            long sr = (long)Math.sqrt(x);\r\n           \r\n            // if product of square root\r\n            // is equal, then\r\n            // return T/F\r\n \r\n            return ((sr * sr) == x);\r\n        }\r\n        return false;\r\n    }\r\n       public static void main(String args[]){\r\n              FastScanner in=new FastScanner();\r\n              boolean prime[]=new boolean[1100];\r\n              Arrays.fill(prime,true);\r\n              for(int i=2;i*i<1100;i++){\r\n                  if(prime[i]){\r\n                      for(int j=i+i;j<1100;j+=i)\r\n                          prime[j]=false;\r\n                  }\r\n              }\r\n              \r\n              int n=in.nextInt();\r\n              int index=0;\r\n              for(int i=2;i<1100;i++){\r\n                  if(prime[i] && i>=n){\r\n                      index=i;\r\n                      break;\r\n                  }\r\n              }\r\n              System.out.println(index);\r\n              StringBuilder sb=new StringBuilder();\r\n              int j=2;\r\n              int count=0;\r\n              for(int i=1;i<n;i++){\r\n                  sb.append(i+\" \"+j+\"\\n\");\r\n                  count++;\r\n                  j++;\r\n              }\r\n              sb.append(1+\" \"+n+\"\\n\");\r\n             \r\n                  for(int i=1;i<index-count;i++){\r\n                      sb.append(i+\" \"+(n-i)+\"\\n\");\r\n                  }\r\n              \r\n              System.out.println(sb.toString());\r\n              }\r\n              \r\n       public static int dfs(int n,int node,ArrayList<Pair> arr[],boolean visited[],int sum){\r\n          visited[node]=true;\r\n          if(node==n-1)\r\n              return sum;\r\n              \r\n          int max=Integer.MIN_VALUE;\r\n          for(Pair i:arr[node]){\r\n              int ans=0;\r\n              if(!visited[i.x])\r\n                 ans=dfs(n,i.x,arr,visited,sum+i.y);\r\n              \r\n              max=Math.max(ans,max);\r\n          }\r\n           return max;\r\n       }\r\n       public static void factor(long n,HashSet<Long> set){\r\n           for(long i=2;i*i<=n;i++){\r\n               if(n%i==0){\r\n                   set.add(i);\r\n                   while(n%i==0){\r\n                       n=n/i;\r\n                   }\r\n               }\r\n           }\r\n           if(n!=0 && n!=1)\r\n               set.add(n);\r\n       }\r\n       public static int bakchodi(int arr[],int dp[][],int n,int turn,int index){\r\n           if(index>=n)\r\n               return 0;\r\n           \r\n           if(dp[index][turn]!=-1)\r\n               return dp[index][turn];\r\n           \r\n           int ans1=Integer.MAX_VALUE;\r\n           int ans2=Integer.MAX_VALUE;\r\n           if(turn==0){\r\n               if(index<n)\r\n                   ans1=arr[index]+bakchodi(arr,dp,n,1-turn,index+1);\r\n               \r\n               if(index+1<n)\r\n                   ans2=arr[index]+arr[index+1]+bakchodi(arr,dp,n,1-turn,index+2);\r\n           }\r\n           else{\r\n               ans1=bakchodi(arr,dp,n,1-turn,index+1);\r\n               ans2=bakchodi(arr,dp,n,1-turn,index+2);\r\n           }\r\n            return dp[index][turn]=Math.min(ans1,ans2);\r\n       }\r\n       public static int rec1(int arr[],int turn,int index,int n){\r\n           int ans1=0;\r\n           int ans2=0;\r\n           if(index>=n)\r\n               return 0;\r\n           \r\n           if(turn==0){\r\n               if(index<n)\r\n               ans1=arr[index]+rec1(arr,1-turn,index+1,n);\r\n               \r\n               if(index+1<n)\r\n                   ans2=arr[index]+arr[index+1]+rec1(arr,1-turn,index+2,n);\r\n           }\r\n           else{\r\n               ans1=rec1(arr,1-turn,index+1,n);\r\n               ans2=rec1(arr,1-turn,index+2,n);\r\n           }\r\n           return Math.min(ans1,ans2);\r\n       }\r\n       public static int rec(int arr[][],int i,int j,int n){\r\n           int sum=0;\r\n           sum+=arr[i][j];\r\n           \r\n           int max=0;\r\n          for(int k=j+1;k<n;k++)\r\n              max=Math.max(max,rec(arr,1-i,k,n));\r\n          \r\n          sum+=max;\r\n          \r\n          return sum;\r\n       }\r\n      \r\n       public static void rec(int i,int n,int count){\r\n           if(i==n){\r\n               count++;\r\n               return;\r\n           }\r\n           if(i>n)\r\n               return;\r\n           \r\n           rec(i+1,n,count);\r\n           rec(i+2,n,count);\r\n       }\r\n       public static long lcm(long x, long y) {\r\n        return ((x * y) / gcd(x, y));\r\n    }\r\n       public static long gcd(long a,long b){\r\n           if(a==0)\r\n               return b;\r\n           \r\n           return gcd(b%a,a);\r\n       }\r\n       public static int bakloli(char ch[],char c,int k){\r\n           int n=ch.length;\r\n           int k1=0;\r\n           int i=0;\r\n           int j=0;\r\n           int ans=0;\r\n           while(i<n){\r\n               if(j>=n)\r\n                   break;\r\n               while(j<n && (ch[j]==c || k1<k)){\r\n                   if(ch[j]!=c){\r\n                       k1++;\r\n                       \r\n                   }\r\n                   j++;\r\n               }\r\n               ans=Math.max(j-i,ans);\r\n               if(ch[i]!=c)\r\n                   k1--;\r\n               \r\n               i++;\r\n           }\r\n           return ans;\r\n       }\r\n       \r\n       public static long power(long a,long b){\r\n          long ans=1;\r\n          while(b > 0) {\r\n    \t\tif((b&1) == 1) ans = (ans*a) % mod;\r\n    \t\ta = (a*a) % mod;\r\n    \t\tb >>= 1;\r\n    \t}\r\n          return ans;\r\n       }\r\n       public static int largestfactor(int n){\r\n          \r\n           for(int i=2;i*i<=n;i++){\r\n               if(n%i==0)\r\n                   return n/i;\r\n           }\r\n           return 1;\r\n       }\r\n      \r\n       public static int bs(int ele,int n,int arr[]){\r\n           int low=0;\r\n           int high=n-1;\r\n           while(low<=high){\r\n               int mid=(low+high)/2;\r\n               if(arr[mid]>=ele){\r\n                   low=mid+1;\r\n               }\r\n               else\r\n                   high=mid-1;\r\n           }\r\n           return low;\r\n       }\r\n       private static int mergeAndCount(long[] arr, int l,\r\n                                     int m, int r)\r\n    {\r\n \r\n        // Left subarray\r\n        long[] left = Arrays.copyOfRange(arr, l, m + 1);\r\n \r\n        // Right subarray\r\n        long[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\r\n \r\n        int i = 0, j = 0, k = l, swaps = 0;\r\n \r\n        while (i < left.length && j < right.length) {\r\n            if (left[i] <= right[j])\r\n                arr[k++] = left[i++];\r\n            else {\r\n                arr[k++] = right[j++];\r\n                swaps += (m + 1) - (l + i);\r\n            }\r\n        }\r\n        while (i < left.length)\r\n            arr[k++] = left[i++];\r\n        while (j < right.length)\r\n            arr[k++] = right[j++];\r\n        return swaps;\r\n    }\r\n \r\n    // Merge sort function\r\n    private static int mergeSortAndCount(long[] arr, int l,\r\n                                         int r)\r\n    {\r\n \r\n        // Keeps track of the inversion count at a\r\n        // particular node of the recursion tree\r\n        int count = 0;\r\n \r\n        if (l < r) {\r\n            int m = (l + r) / 2;\r\n \r\n            // Total inversion count = left subarray count\r\n            // + right subarray count + merge count\r\n \r\n            // Left subarray count\r\n            count += mergeSortAndCount(arr, l, m);\r\n \r\n            // Right subarray count\r\n            count += mergeSortAndCount(arr, m + 1, r);\r\n \r\n            // Merge count\r\n            count += mergeAndCount(arr, l, m, r);\r\n        }\r\n \r\n        return count;\r\n    }\r\n}\r\nclass FastScanner {\r\n\t\tjava.io.BufferedReader br = new java.io.BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st = new StringTokenizer(\"\");\r\n \r\n\t\tString next() {\r\n\t\t\twhile (!st.hasMoreTokens())\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n \r\n\t\tint nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n \r\n\t\tint[] readArray(int n) {\r\n\t\t\tint[] a = new int[n];\r\n\t\t\tfor (int i = 0; i < n; i++)\r\n\t\t\t\ta[i] = nextInt();\r\n\t\t\treturn a;\r\n\t\t}\r\n \r\n\t\tlong nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\t}\r\nclass Pair{\r\n    int x;\r\n    int y;\r\n    Pair(int x,int y){\r\n        this.x=x;\r\n        this.y=y;\r\n    }\r\n}\r\nclass Sorting implements Comparator<Pair>{\r\n    public int compare(Pair p1,Pair p2){\r\n       \r\n        return (int)(p2.x-p1.x);\r\n    }\r\n}"
}