{
    "id": 222436222,
    "contestId": 1742,
    "creationTimeSeconds": 1694166924,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1742,
        "index": "D",
        "name": "Coprime",
        "type": "PROGRAMMING",
        "rating": 1100,
        "tags": [
            "brute force",
            "greedy",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1742,
        "members": [
            {
                "handle": "Eslam7215"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1665671700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 296,
    "memoryConsumedBytes": 32051200,
    "source": "// Return Qualified\n#include <bits/stdc++.h>\nusing namespace std ;\n#define clo cout << \"Time execute: \" << clock() / (double)CLOCKS_PER_SEC << \" sec\" << endl;\n#define NB iostream::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n#define OUT  cout << setprecision(20) << fixed ;\n#define yes cout << \"valid\\n\" ;\n#define PI 3.14159265358979323846\n#define tan(x) tan((180 * x) / PI)\n#define no cout << \"invalid\\n\" ;\n#define all(ans) ans.begin() , ans.end()\n#define allr(ans) ans.rbegin() , ans.rend()\n#define N <<\"\\n\" ;\n#define S(c) string (1 , c)\n#define qualified 0 ;\ntypedef long long ll ;\ntypedef double long dll ;\ntypedef unsigned long long ull ;\nusing namespace std ;\ntemplate <typename t>\nistream & operator >> (istream & in, vector<t> & es){\n    for (auto & i : es){\n        in >> i ;\n    }\n    return in ;\n}\nconst ll MOD = 1e9 + 7 ;\nll mul (ll a , ll b){\n    return ((a % MOD) * (b % MOD) % MOD ) ;\n}\nll sum (ll a , ll b){\n    return ((a % MOD) + (b % MOD) % MOD ) ;\n}\nll minus (ll a  , ll b){\n    return ((a % MOD) - (b % MOD + MOD) % MOD ) ;\n}\null gcd(ull a , ull b){\n    if (b == 0)\n        return a ;\n    return gcd(b , a % b ) ;\n}\null lcm (ull a , ull b){\n    return a / gcd(a , b) * b ;\n}\nbool pal (string w ){\n    string ss = w;\n    reverse(ss.begin() , ss.end()) ;\n    if (w == ss)\n        return true;\n    else\n        return false;\n}\nbool isprime (ll a){\n    if (a == 1 || a == 0)\n        return false ;\n    if (a == 2)\n        return true ;\n    for (ll i = 2 ; i * i <= a ; i++){\n        if (a % i == 0)\n            return false ;\n    }\n    return true ;\n}\ntemplate <typename t>\nostream & operator << (ostream & out , vector<t> es){\n    for (auto i : es){\n        out << i << \" \";\n    }\n    out N\n    return out ;\n}\ntemplate <typename t>\nostream & operator << (ostream & out , vector<pair<t , t>> es){\n    for (auto i : es){\n        out << i.first << \" \" << i.second N\n    }\n    out N\n    return out ;\n}\nvoid clear (priority_queue<int> & uu){\n    while (!uu.empty()){\n        uu.pop() ;\n    }\n}\nll fastpow (ll n , ll m , ll c){\n    ll ans = 1 ;\n    while (m){\n        if (m % 2){\n            ans = (ans % c * n % c) % c ;\n        }\n        n = (n % c * n % c) % c ;\n        m /= 2 ;\n    }\n    return ans ;\n}\nll divisors1 (ll n){\n    ll cnt = 0 ;\n    for (int i = 1 ; i * i <= n ; i++){\n        if (n % i == 0){\n            if (n / i != i){\n                cnt += 2 ;\n            }else {\n                cnt ++ ;\n            }\n        }\n    }\n    return cnt ;\n}\nmap<ll , ll> primeFcat(ll n){\n    map<ll ,ll> mp ;\n    for (ll i = 2 ; i * i <= n ; i++){\n        while (n % i ==0){\n            mp[i] ++ ;\n            n /= i ;\n        }\n    }\n    if (n > 1){\n        mp[n] ++ ;\n    }\n    return mp ;\n}\nconst ll NN = 1e6 ;\n//ll spf [NN + 1] ;\n//void SPF (){\n//    for (int i = 1 ; i <= NN ; i++){\n//        spf[i] = i ;\n//    }\n//    for (ll i = 2 ; i <= NN ; i++){\n//        if (spf[i] == i){\n//            for (ll j = i * i ; j <= NN ; j += i ){\n//                if (spf[j] == j){\n//                    spf[j] = i ;\n//                }\n//            }\n//        }\n//    }\n//}\nvector<ll> primes ;\n//map<ll , ll> prime ;\nvoid cprimes (){\n    vector<bool> cc (NN + 1 , false) ;\n    for (ll i = 2 ; i <= NN ; i++){\n        if (!cc[i]){\n            primes.push_back(i) ;\n//            prime[i] = 1 ;\n            for (ll j = i * i ; j <= NN ; j += i){\n                cc[j] = true;\n            }\n        }\n    }\n}\n//map<ll , ll> primeFcat2(ll n){\n//    map<ll ,ll> mp ;\n//    while (n > 1){\n//        mp[spf[n]] ++ ;\n//        n /= spf[n] ;\n//    }\n//    return mp ;\n//}\n//ll sumO (ll n){\n//    ll a = n / 2 ;\n//    if (n % 2){\n//        a ++ ;\n//    }\n//    return a * a ;\n//}\n//ll sumE (ll n){\n//    ll a = n / 2 ;\n//    return a * a + a ;\n//}\n//vector<ll> divisor (NN + 1) ;\n//void divisors2 (){\n//    for (ll i = 1 ; i <= NN ; i++){\n//        for (ll j = i ; j <= NN ; j += i){\n//            divisor[j] ++ ;\n//        }\n//    }\n//}\n// gcd (x , y) = gcd (x , y - x )\n// sum first n evens = n * n + n ;\n// --- ----- - odd = n * n ;\n// __builtin_popcount(n) --> number of ones\n// __builtin_parity(n)   --> if number of ones % 2\n// __builtin_clz(n)      --> number of leading zeros\n// __builtin_ctz(n)      --> number of trailing zeros\nconst int MAX = 1e8 ;\n//#define int ll\n//struct item {\n//\n//    int n ;\n//};\n//struct tree {\n//    item NUTRAL = {-LONG_LONG_MAX};\n//    vector<item> data;\n//\n//    item single(int v) {\n//        return {v};\n//    }\n//\n//    item merge(item a, item b) {\n//        return {\n//                max(a.n , b.n)\n//        } ;\n//    }\n//    int size;\n//    void init(int n) {\n//        size = 1;\n//        while (size < n) {\n//            size *= 2;\n//        }\n//        data.resize(2 * size);\n//    }\n//\n//    void build(vector<int> &a, int x, int l, int r) {\n//        if (abs(l - r) == 1) {\n//            if (l < a.size()) {\n//                data[x] = single(a[l]);\n//            }\n//            return;\n//        }\n//        int m = (l + r) / 2;\n//        build(a, 2 * x + 1, l, m);\n//        build(a, 2 * x + 2, m, r);\n//        data[x] = merge(data[2 * x + 1], data[2 * x + 2]);\n//    }\n//    void build(vector<int> &a) {\n//        build(a, 0, 0, size);\n//    }\n//    void set(int i ,int  v, int x, int lx, int rx) {\n//        if (abs(lx - rx) == 1) {\n//            data[x] = single(v);\n//            return;\n//        }\n//        int m = (lx + rx) / 2;\n//        if (i < m) {\n//            set(i, v ,2 * x + 1, lx, m);\n//        } else {\n//            set(i, v, 2 * x + 2, m, rx);\n//        }\n//        data[x] = merge(data[2 * x + 1], data[2 * x + 2]);\n//    }\n//\n//    void set(int i , int v ) {\n//        set(i, v , 0, 0, size);\n//    }\n//\n//    item calc(int k , int l , int x , int lx , int rx) {\n//        if (rx <= l){\n//            return single(-1) ;\n//        }\n//        if (data[x].n < k){\n//            return  single(-1) ;\n//        }\n//        if (rx - lx == 1){\n//            return single(lx) ;\n//        }\n//        int m = (lx + rx ) / 2 ;\n//        item res = calc(k , l, 2 * x + 1 , lx , m) ;\n//        if (res.n == -1){\n//            res = calc(k , l, 2 * x + 2  , m , rx) ;\n//        }\n//        return res ;\n//\n//    }\n//    item calc(int k , int l) {\n//        return calc(k , l , 0 , 0 , size) ;\n//    }\n//} ;\n#define int ll\nconst int NNN=2e6+5;\n\nll fact[NNN],modinv[NNN];\n\nll fast_power(ll b, ll p)\n{\n    if(p==0)\n    {\n        return 1;\n    }\n    ll u=fast_power(b,p/2)%MOD;\n    u=(u*u)%MOD;\n    if(p%2)\n    {\n        u*=b;\n    }\n    u%=MOD;\n    return u;\n}\n\nvoid preprocess()\n{\n    fact[0]=1;\n    for(ll i=1; i<NNN; i++)\n    {\n        fact[i]=(i*fact[i-1])%MOD;\n    }\n    modinv[NNN-1]=fast_power(fact[NNN-1],MOD-2);\n    for(ll i=NNN-2; i>=0; i--)\n    {\n        modinv[i]=((i+1)*modinv[i+1])%MOD;\n    }\n}\n\nll nCr(ll n,ll r) {\n    if (r > n) {\n        return 0;\n    }\n    return ((fact[n] * modinv[r]) % MOD * modinv[n - r]) % MOD;\n}\nvoid Return_Qualified (){\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    OUT\n    NB\n}\nvoid Return_Qualified_Files (){\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n}\n// a ^ b % m\n// a ^ (b & phi(m)) % m\nvoid sol (){\n    int n ;\n    cin >> n ;\n    vector<int> es (1001) ;\n    int mx = 0 ;\n    for (int i = 0 ; i < n ; i ++){\n        int y ;\n        cin >> y ;\n        es[y] = i + 1 ;\n        mx = max(mx , y) ;\n    }\n    int ans = 0 ;\n    for (int i = 1 ; i <= mx ; i ++){\n        for (int j = 1 ; j <= mx ; j++){\n            if (gcd(i , j) == 1 && es[i] != 0 && es[j] != 0){\n                ans = max(ans , es[i] + es[j]) ;\n            }\n        }\n    }\n    if (ans == 0){\n        cout << -1 N\n        return;\n    }\n    cout << ans N\n}\n\nsigned main() {\n    Return_Qualified() ;\n    int t = 1 ;\n    cin >> t ;\n//    string w ;\n    while (t--) {\n//        if (w == \"end\") return 0 ;\n        sol();\n    }\n    return qualified\n}"
}