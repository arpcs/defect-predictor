{
    "id": 165410654,
    "contestId": 1706,
    "creationTimeSeconds": 1658570311,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1706,
        "index": "E",
        "name": "Qpwoeirut and Vertices",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "dsu",
            "greedy",
            "trees"
        ]
    },
    "author": {
        "contestId": 1706,
        "members": [
            {
                "handle": "Shukuang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1658154900
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 68710400,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nnamespace IO {\r\n    template <typename T>\r\n    inline void read(T &x) {\r\n        x = 0; T r = 1;\r\n        char ch = getchar();\r\n        while (!isdigit(ch)) r = ch == '-' ? -1 : 1, ch = getchar();\r\n        while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\r\n        x *= r;\r\n    }\r\n\r\n    template <typename T, typename ...Args>\r\n    void read(T &x, Args &...args) {\r\n        read(x), read(args...);\r\n    }\r\n\r\n    template <typename T>\r\n    inline void write(T x) {\r\n        if (x < 0) putchar('-'), x = -x;\r\n        if (x > 9) write(x / 10);\r\n        putchar(x % 10 + '0');\r\n    }\r\n}\r\n\r\nusing namespace IO;\r\n\r\nusing db = double;\r\nusing ll = long long;\r\nusing pii = pair<int, int>;\r\n\r\nconst int inf = 0x3f3f3f3f;\r\n\r\n#define fi first\r\n#define se second\r\n#define pc putchar\r\n#define eb emplace_back\r\n#define print(x, y) write(x), pc(y)\r\n\r\nconst int N = 3e5 + 10;\r\n\r\nint n, m, q;\r\n\r\nint fa[N];\r\nint find(int x) {\r\n\tif (x == fa[x]) return x;\r\n\treturn fa[x] = find(fa[x]);\r\n}\r\n\r\nbool merge(int x, int y) {\r\n\tint fx = find(x), fy = find(y);\r\n\tif (fx == fy) return false;\r\n\treturn fa[fx] = fy, true;\r\n}\r\n\r\nvector<pii> G[N];\r\n\r\nint dep[N];\r\nint anc[N][20], val[N][20];\r\n\r\nvoid dfs(int u, int fath) {\r\n\tdep[u] = dep[fath] + 1;\r\n\tfor (auto p : G[u]) {\r\n\t\tint v = p.fi, w = p.se;\r\n\t\tif (v == fath) continue;\r\n\t\tanc[v][0] = u;\r\n        val[v][0] = w;\r\n\t\tdfs(v, u);\r\n\t}\r\n}\r\n\r\n\r\nint qry(int x, int y) {\r\n\tint ans = 0;\r\n\tif (dep[x] < dep[y]) swap(x, y);\r\n\tfor (int i = 18; i >= 0; -- i) {\r\n\t\tif (dep[anc[x][i]] >= dep[y]) {\r\n\t\t\tans = max(ans, val[x][i]);\r\n\t\t\tx = anc[x][i];\r\n\t\t}\r\n\t}\r\n\tif (x == y) return ans;\r\n\tfor (int i = 18; i >= 0; -- i) {\r\n\t\tif (anc[x][i] != anc[y][i]) {\r\n\t\t\tans = max(ans, val[x][i]);\r\n\t\t\tans = max(ans, val[y][i]);\r\n\t\t}\r\n\t}\r\n\tans = max(ans, val[x][0]);\r\n\tans = max(ans, val[y][0]);\r\n\treturn ans;\r\n}\r\n\r\nstruct node {\r\n\tint l, r, val;\r\n} t[N << 2];\r\n\r\n#define ls (p << 1)\r\n#define rs (p << 1 | 1)\r\n\r\nvoid build(int p, int l, int r) {\r\n\tt[p].l = l; t[p].r = r;\r\n\tif (l == r) return t[p].val = qry(l, l + 1), void();\r\n\tint mid = (l + r) >> 1;\r\n\tbuild(ls, l, mid); build(rs, mid + 1, r);\r\n\tt[p].val = max(t[ls].val, t[rs].val);\r\n}\r\n\r\nint query(int p, int l, int r) {\r\n\tif (t[p].l > r || t[p].r < l) return 0;\r\n\tif (t[p].l >= l && t[p].r <= r) return t[p].val; \r\n\treturn max(query(ls, l, r), query(rs, l, r));\r\n}\r\n\r\nvoid Clear() {\r\n\tfor (int i = 0; i <= n; ++ i) {\r\n\t\tG[i].clear(); dep[i] = 0;\r\n\t\tfor (int j = 0; j <= 18; ++ j) {\r\n\t\t\tanc[i][j] = val[i][j] = 0;\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i <= n * 4; ++ i) t[i].l = t[i].r = t[i].val = 0;\r\n}\r\n\r\nvoid solve() {\r\n\tread(n, m, q);\r\n    for (int i = 1; i <= n; ++ i) fa[i] = i;\r\n    for (int i = 1; i <= m; ++ i) {\r\n    \tint u, v; read(u, v);\r\n    \tif (merge(u, v)) {\r\n    \t\tG[u].eb(pii(v, i));\r\n    \t\tG[v].eb(pii(u, i));\r\n    \t}\r\n    }\r\n    dfs(1, 0);\r\n    for (int j = 1; j <= 18; ++ j) {\r\n    \tfor (int i = 1; i <= n; ++ i) {\r\n    \t\tanc[i][j] = anc[anc[i][j - 1]][j - 1];\r\n    \t}\r\n    }\r\n    for (int j = 1; j <= 18; ++ j) {\r\n    \tfor (int i = 1; i <= n; ++ i) {\r\n    \t\tval[i][j] = max(val[i][j - 1], val[anc[i][j - 1]][j - 1]);\r\n    \t}\r\n    }\r\n    build(1, 1, n - 1);\r\n    for (int i = 1; i <= q; ++ i) {\r\n    \tint l, r; read(l, r);\r\n    \tif (l == r) print(0, ' ');\r\n    \telse print(query(1, l, r - 1), ' ');\r\n    }\r\n    puts(\"\"); Clear();\r\n    return;\r\n}\r\n\r\nsigned main() {\r\n    #ifndef ONLINE_JUDGE \r\n        freopen(\"test.in\", \"r\", stdin);\r\n        freopen(\"test.out\", \"w\", stdout);\r\n    #endif  \r\n    int T; read(T);\r\n    while (T --) solve();\r\n}",
    "suggested_categories": [
        "algorithm",
        "data structures",
        "c++",
        "code optimization",
        "graph algorithms",
        "dynamic programming",
        "input/output",
        "template metaprogramming",
        "mathematics",
        "complexity analysis",
        "code style",
        "version control",
        "test driven development",
        "software design",
        "hardware interfacing",
        "executable file management",
        "debugging",
        "task scheduling",
        "resource management",
        "error handling"
    ],
    "defect_evaluation_v4": {
        "good solution": 90,
        "wrong solution": 10,
        "compilation error": 0,
        "runtime error": 0
    },
    "category_evaluation": {
        "mathematics": 5,
        "dynamic programming": 5,
        "bit manipulation": 0,
        "greedy": 5,
        "brute force": 0,
        "graphs": 50,
        "sortings": 0,
        "search": 0,
        "trees": 20,
        "strings": 0,
        "number theory": 0,
        "combinatorics": 0,
        "two pointers": 0,
        "geometry": 0,
        "shortest paths": 20,
        "divide and conquer": 0,
        "probabilities": 0,
        "data structures": 20,
        "game theory": 0,
        "2d, 3d": 0,
        "recursive": 0,
        "well-commented": 20,
        "self-documenting": 0,
        "complex": 0,
        "readable": 20,
        "well-named": 20,
        "efficient": 20,
        "reusable": 20,
        "documented": 20,
        "good error-handling": 0,
        "good solution": 55,
        "compilation error": 0,
        "runtime error": 0
    }
}