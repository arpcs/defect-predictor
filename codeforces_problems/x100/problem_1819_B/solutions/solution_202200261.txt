{
    "id": 202200261,
    "contestId": 1819,
    "creationTimeSeconds": 1681552238,
    "relativeTimeSeconds": 2738,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "zkou"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 14,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 18,
    "timeConsumedMillis": 171,
    "memoryConsumedBytes": 5939200,
    "source": "#line 2 \"SPJ-Library/template/kuma.hpp\"\n\n#line 2 \"SPJ-Library/template/basic_func.hpp\"\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\ntemplate <class T0, class T1, class T2>\ninline bool in_range(T0 x, T1 lef, T2 rig) {\n\treturn ((lef <= x) && (x < rig));\n}\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid Yes(bool flag = true) { std::cout << (flag ? \"Yes\" : \"No\") << '\\n'; }\nvoid YES(bool flag = true) { std::cout << (flag ? \"YES\" : \"NO\") << '\\n'; }\n\ntemplate <class T>\nvoid drop(T answer) {\n\tstd::cout << answer << '\\n';\n\texit(0);\n}\n\ntemplate <class T>\nvoid vout(std::vector<T> const &v, bool vertically = 0) {\n\tif(vertically) {\n\t\tfor(auto const &a : v) {\n\t\t\tstd::cout << a << '\\n';\n\t\t}\n\t\treturn;\n\t}\n\tfor(auto it = v.begin(); it != v.end(); it++) {\n\t\tstd::cout << (*it);\n\t\tif(it != v.end() - 1) {\n\t\t\tstd::cout << ' ';\n\t\t}\n\t}\n\tstd::cout << '\\n';\n\treturn;\n}\n\ninline void print() { std::cout << '\\n'; }\ntemplate <class T>\ninline void print(const T &x) {\n\tstd::cout << x << '\\n';\n\treturn;\n}\ntemplate <typename Head, typename... Tail>\nvoid print(const Head &H, const Tail &... T) {\n\tstd::cout << H << \" \";\n\tprint(T...);\n}\n\ntemplate <class T>\nvoid add(std::vector<T> &v, T value) {\n\tfor(auto &a : v) a += value;\n\treturn;\n}\n\ntemplate <class T>\nT greatest_lower_multiple(T x, T d) {\n\tif(d == 0) return 0;\n\tif(d < 0) d *= -1;\n\tT y = x % d;\n\tif(y < 0) y += d;\n\treturn x - y;\n}\n\ntemplate <class T>\nT least_upper_multiple(T x, T d) {\n\treturn -greatest_lower_multiple(-x, d);\n}\n\n// ceil(a / b);\ntemplate <class T>\nT dup(T a, T b) {\n\tassert(b);\n\tif(b < 0) {\n\t\ta *= -1;\n\t\tb *= -1;\n\t}\n\treturn least_upper_multiple(a, b) / b;\n}\n\nlong long pow_ll(long long a, long long n) {\n\tassert(n >= 0LL);\n\tif(n == 0) return 1LL;\n\tif(a == 0) return 0LL;\n\tif(a == 1) return 1LL;\n\tif(a == -1) return (n & 1LL) ? -1LL : 1LL;\n\tlong long res = 1;\n\twhile(n > 1LL) {\n\t\tif(n & 1LL) res *= a;\n\t\ta *= a;\n\t\tn >>= 1;\n\t}\n\treturn res * a;\n}\n\n// @return: x  s.t. x == a^n, 0 <= x < abs(mod)\n// @require: mod != 0, abs(mod) < 2e9\nlong long modpow(long long a, long long n, long long mod) {\n\tassert(n >= 0 && mod);\n\tmod = mod > 0 ? mod : -mod;\n\tif(mod == 1) return 0LL;\n\tlong long res = 1;\n\ta %= mod;\n\twhile(n) {\n\t\tif(n & 1) (res *= a) %= mod;\n\t\t(a *= a) %= mod;\n\t\tn >>= 1;\n\t}\n\treturn res < 0 ? res + mod : res;\n}\n\n// @return: x  s.t. a * x % mod == gcd(a, mod), 0 <= x < mod\n// @require: a % mod != 0\nlong long modinv(long long a, long long mod) {\n\tassert(mod && a % mod);\n\tmod = mod > 0 ? mod : -mod;\n\tlong long b = mod, u = 1, v = 0;\n\twhile(b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tstd::swap(a, b);\n\t\tu -= t * v;\n\t\tstd::swap(u, v);\n\t}\n\tu %= mod;\n\treturn u < 0 ? u + mod : u;\n}\n\ntemplate <class T>\nint lb(const std::vector<T> &a, const T &x) {\n\treturn (int)std::distance(a.begin(), std::lower_bound(a.begin(), a.end(), x));\n}\ntemplate <class T>\nint ub(const std::vector<T> &a, const T &x) {\n\treturn (int)std::distance(a.begin(), std::upper_bound(a.begin(), a.end(), x));\n}\ntemplate <class T>\nvoid unq_sort(std::vector<T> &a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <class T>\nstd::vector<int> press(const std::vector<T> &a) {\n\tstd::vector<T> vec = a;\n\tunq_sort(vec);\n\tstd::vector<int> ret;\n\tfor(const auto &v : a) ret.push_back(lb(vec, v));\n\treturn ret;\n}\n#line 1 \"SPJ-Library/template/header.hpp\"\n#include <bits/stdc++.h>\n#line 2 \"SPJ-Library/template/io.hpp\"\n\n#line 4 \"SPJ-Library/template/io.hpp\"\n\n#line 8 \"SPJ-Library/template/debug.hpp\"\n\n#line 3 \"SPJ-Library/template/constants.hpp\"\n\nconstexpr int inf = 1000'000'000;\nconstexpr long long INF = 1'000'000'000'000'000'000LL;\nconstexpr int mod_1000000007 = 1000000007;\nconstexpr int mod_998244353 = 998244353;\nconst long double pi = acosl(-1.);\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#line 10 \"SPJ-Library/template/debug.hpp\"\n\nnamespace viewer {\n\ntemplate <typename T, typename U>\nvoid view(const std::pair<T, U> &p);\n\ntemplate <class T0, class T1, class T2>\nvoid view(const std::tuple<T0, T1, T2> &p);\n\ntemplate <class T0, class T1, class T2, class T3>\nvoid view(const std::tuple<T0, T1, T2, T3> &p);\n\nvoid view(const long long &e);\n\nvoid view(const int &e);\n\ntemplate <typename T>\nvoid view(const T &e);\n\ntemplate <typename T>\nvoid view(const std::set<T> &s);\n\ntemplate <typename T>\nvoid view(const std::unordered_set<T> &s);\n\ntemplate <typename T>\nvoid view(const std::multiset<T> &s);\n\ntemplate <typename T>\nvoid view(const std::unordered_multiset<T> &s);\n\ntemplate <typename T>\nvoid view(const std::vector<T> &v);\n\ntemplate <typename T, std::size_t ary_size>\nvoid view(const std::array<T, ary_size> &v);\n\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv);\n\ntemplate <typename T, typename U>\nvoid view(const std::vector<std::pair<T, U>> &v);\n\ntemplate <class T0, class T1, class T2>\nvoid view(const std::vector<std::tuple<T0, T1, T2>> &v);\n\ntemplate <class T0, class T1, class T2, class T3>\nvoid view(const std::vector<std::tuple<T0, T1, T2, T3>> &v);\n\ntemplate <typename map_type>\nvoid view_map_container(const map_type &m);\n\ntemplate <typename T, typename U>\nvoid view(const std::map<T, U> &m);\n\ntemplate <typename T, typename U>\nvoid view(const std::unordered_map<T, U> &m);\n\ntemplate <typename container_type>\nvoid view_container(const container_type &c, bool vertically = false) {\n\ttypename container_type::const_iterator begin = c.begin();\n\tconst typename container_type::const_iterator end = c.end();\n\tif(vertically) {\n\t\tstd::cerr << \"{\\n\";\n\t\twhile(begin != end) {\n\t\t\tstd::cerr << '\\t';\n\t\t\tview(*(begin++));\n\t\t\tif(begin != end) std::cerr << ',';\n\t\t\tstd::cerr << '\\n';\n\t\t}\n\t\tstd::cerr << '}';\n\t\treturn;\n\t}\n\tstd::cerr << \"{ \";\n\twhile(begin != end) {\n\t\tview(*(begin++));\n\t\tif(begin != end) std::cerr << ',';\n\t\tstd::cerr << ' ';\n\t}\n\tstd::cerr << '}';\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::pair<T, U> &p) {\n\tstd::cerr << '(';\n\tview(p.first);\n\tstd::cerr << \", \";\n\tview(p.second);\n\tstd::cerr << ')';\n}\n\ntemplate <class T0, class T1, class T2>\nvoid view(const std::tuple<T0, T1, T2> &p) {\n\tstd::cerr << '(';\n\tview(std::get<0>(p));\n\tstd::cerr << \", \";\n\tview(std::get<1>(p));\n\tstd::cerr << \", \";\n\tview(std::get<2>(p));\n\tstd::cerr << ')';\n}\n\ntemplate <class T0, class T1, class T2, class T3>\nvoid view(const std::tuple<T0, T1, T2, T3> &p) {\n\tstd::cerr << '(';\n\tview(std::get<0>(p));\n\tstd::cerr << \", \";\n\tview(std::get<1>(p));\n\tstd::cerr << \", \";\n\tview(std::get<2>(p));\n\tstd::cerr << \", \";\n\tview(std::get<3>(p));\n\tstd::cerr << ')';\n}\n\nvoid view(const long long &e) {\n\tif(e == INF)\n\t\tstd::cerr << \"INF\";\n\telse if(e == -INF)\n\t\tstd::cerr << \"-INF\";\n\telse\n\t\tstd::cerr << e;\n}\n\nvoid view(const int &e) {\n\tif(e == inf)\n\t\tstd::cerr << \"inf\";\n\telse if(e == -inf)\n\t\tstd::cerr << \"-inf\";\n\telse\n\t\tstd::cerr << e;\n}\n\ntemplate <typename T>\nvoid view(const T &e) {\n\tstd::cerr << e;\n}\n\ntemplate <typename T>\nvoid view(const std::set<T> &s) {\n\tview_container(s);\n}\n\ntemplate <typename T>\nvoid view(const std::unordered_set<T> &s) {\n\tview_container(s);\n}\n\ntemplate <typename T>\nvoid view(const std::multiset<T> &s) {\n\tview_container(s);\n}\n\ntemplate <typename T>\nvoid view(const std::unordered_multiset<T> &s) {\n\tview_container(s);\n}\n\ntemplate <typename T>\nvoid view(const std::vector<T> &v) {\n\tview_container(v);\n}\n\ntemplate <typename T, std::size_t ary_size>\nvoid view(const std::array<T, ary_size> &v) {\n\tview_container(v);\n}\n\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv) {\n\tview_container(vv, true);\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::vector<std::pair<T, U>> &v) {\n\tview_container(v, true);\n}\n\ntemplate <class T0, class T1, class T2>\nvoid view(const std::vector<std::tuple<T0, T1, T2>> &v) {\n\tview_container(v, true);\n}\n\ntemplate <class T0, class T1, class T2, class T3>\nvoid view(const std::vector<std::tuple<T0, T1, T2, T3>> &v) {\n\tview_container(v, true);\n}\n\ntemplate <typename map_type>\nvoid view_map_container(const map_type &m) {\n\tstd::cerr << \"{\\n\";\n\tfor(typename map_type::const_iterator it = m.begin(); it != m.end(); it++) {\n\t\tstd::cerr << \"\\t[\";\n\t\tview(it->first);\n\t\tstd::cerr << \"] : \";\n\t\tview(it->second);\n\t\tstd::cerr << '\\n';\n\t}\n\tstd::cerr << \"}\";\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::map<T, U> &m) {\n\tview_map_container(m);\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::unordered_map<T, U> &m) {\n\tview_map_container(m);\n}\n\n}  // namespace viewer\n\n// when compiling : g++ foo.cpp -DLOCAL\n#ifdef LOCAL\nvoid debug_out() {}\ntemplate <typename T>\nvoid debug_out(const T &x) {\n\tviewer::view(x);\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(const Head &H, const Tail &... T) {\n\tviewer::view(H);\n\tstd::cerr << \", \";\n\tdebug_out(T...);\n}\n#define debug(...)                                                \\\n\tdo {                                                          \\\n\t\tstd::cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"] : [\"; \\\n\t\tdebug_out(__VA_ARGS__);                                   \\\n\t\tstd::cerr << \"]\\n\";                                       \\\n\t} while(0)\n#else\n#define debug(...) (void(0))\n#endif\n#line 2 \"SPJ-Library/template/scanner.hpp\"\n\n#line 6 \"SPJ-Library/template/scanner.hpp\"\n\nnamespace scanner {\ntemplate <class T>\nvoid scan(T &a) {\n\tstd::cin >> a;\n}\n\ntemplate <class T, class L>\nvoid scan(std::pair<T, L> &p) {\n\tscan(p.first);\n\tscan(p.second);\n}\n\ntemplate <class T0, class T1, class T2>\nvoid scan(std::tuple<T0, T1, T2> &p) {\n\tT0 t0;\n\tT1 t1;\n\tT2 t2;\n\tscan(t0);\n\tscan(t1);\n\tscan(t2);\n\tp = std::make_tuple(t0, t1, t2);\n}\n\ntemplate <class T0, class T1, class T2, class T3>\nvoid scan(std::tuple<T0, T1, T2, T3> &p) {\n\tT0 t0;\n\tT1 t1;\n\tT2 t2;\n\tT3 t3;\n\tscan(t0);\n\tscan(t1);\n\tscan(t2);\n\tscan(t3);\n\tp = std::make_tuple(t0, t1, t2, t3);\n}\n\ntemplate <class T>\nvoid scan(std::vector<T> &a) {\n\tfor(auto &i : a) scan(i);\n}\n\nvoid INPUT() {}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head &head, Tail &... tail) {\n\tscan(head);\n\tINPUT(tail...);\n}\n}  // namespace scanner\n#line 7 \"SPJ-Library/template/io.hpp\"\n\n#define VEC(type, name, size) \\\n\tvector<type> name(size);  \\\n\tscanner::INPUT(name)\n#define VVEC(type, name, h, w)                     \\\n\tvector<vector<type>> name(h, vector<type>(w)); \\\n\tscanner::INPUT(name)\n#define INT(...)     \\\n\tint __VA_ARGS__; \\\n\tscanner::INPUT(__VA_ARGS__)\n#define LL(...)            \\\n\tlong long __VA_ARGS__; \\\n\tscanner::INPUT(__VA_ARGS__)\n#define STR(...)        \\\n\tstring __VA_ARGS__; \\\n\tscanner::INPUT(__VA_ARGS__)\n#define CHR(...)      \\\n\tchar __VA_ARGS__; \\\n\tscanner::INPUT(__VA_ARGS__)\n#define DBL(...)        \\\n\tdouble __VA_ARGS__; \\\n\tscanner::INPUT(__VA_ARGS__)\n#define LD(...)              \\\n\tlong double __VA_ARGS__; \\\n\tscanner::INPUT(__VA_ARGS__)\n#define TPL3(type0, type1, type2, name)   \\\n\tstd::tuple<type0, type1, type2> name; \\\n\tscanner::INPUT(name);\n#define TPL4(type0, type1, type2, type3, name)   \\\n\tstd::tuple<type0, type1, type2, type3> name; \\\n\tscanner::INPUT(name);\n\ntemplate <typename T1, typename T2>\nstd::istream &operator>>(std::istream &is, std::pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\n\ntemplate <typename T1, typename T2>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &p) {\n\tos << p.first << ' ' << p.second;\n\treturn os;\n}\n\nstruct fast_io {\n\tfast_io() {\n\t\tstd::ios::sync_with_stdio(false);\n\t\tstd::cin.tie(nullptr);\n\t\tstd::cout << std::fixed << std::setprecision(15);\n\t\tsrand((unsigned)time(NULL));\n\t}\n} fast_io_;\n#line 2 \"SPJ-Library/template/macros.hpp\"\n\n#define foa(s, v) for(auto &s : v)\n#define sz(v) int(v.size())\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pcnt(n) __builtin_popcountll((long long)n)\n\n#define REPname(a, b, c, d, e, ...) e\n#define rep(...) REPname(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define REP0(x) for(int Counter_in_rep_macro = 0; Counter_in_rep_macro < (x); ++Counter_in_rep_macro)\n#define REP1(i, x) for(int i = 0; i < (x); ++i)\n#define REP2(i, l, r) for(int i = (l); i < (r); ++i)\n#define REP3(i, l, r, c) for(int i = (l); i < (r); i += (c))\n#define DREPname(a, b, c, d, e, ...) e\n#define drep(...) DREPname(__VA_ARGS__, DREP3, DREP2, DREP1)(__VA_ARGS__)\n#define DREP1(i, x) for(int i = (x)-1; i >= 0; --i)\n#define DREP2(i, l, r) for(int i = (r)-1; i >= (l); --i)\n#define DREP3(i, l, r, c) for(int i = (r)-1; i >= (l); i -= (c))\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing vi = std::vector<int>;\nusing vvi = std::vector<std::vector<int>>;\nusing vvvi = std::vector<std::vector<std::vector<int>>>;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\ntemplate <class T = ll>\nusing V = std::vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\ntemplate <class T = ll>\nusing pqmin = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T = ll>\nusing pqmax = std::priority_queue<T>;\n#line 7 \"SPJ-Library/template/kuma.hpp\"\n\nusing namespace std;\n#line 2 \"b.cpp\"\n\nbool solve_with_fixed_size(ll n, vector<ll> &as, vector<ll> &bs, ll h, ll w) {\n    vector<int> used(n);\n    vector<int> indices_sorted_by_a(n);\n    iota(indices_sorted_by_a.begin(), indices_sorted_by_a.end(), 0);\n    vector<int> indices_sorted_by_b(n);\n    iota(indices_sorted_by_b.begin(), indices_sorted_by_b.end(), 0);\n\n    sort(indices_sorted_by_a.begin(), indices_sorted_by_a.end(),\n         [&](int i, int j) -> bool { return as[i] < as[j]; });\n    sort(indices_sorted_by_b.begin(), indices_sorted_by_b.end(),\n         [&](int i, int j) -> bool { return bs[i] < bs[j]; });\n    // debug(indices_sorted_by_a, indices_sorted_by_b);\n\n    for (int i = 0; i < n; i++) {\n        while (used[indices_sorted_by_a.back()]) {\n            indices_sorted_by_a.pop_back();\n        }\n        while (used[indices_sorted_by_b.back()]) {\n            indices_sorted_by_b.pop_back();\n        }\n        int a_index = indices_sorted_by_a.back();\n        if (as[a_index] > h) {\n            return false;\n        } else if (as[a_index] == h) {\n            used[a_index] = true;\n            w -= bs[a_index];\n            continue;\n        }\n        int b_index = indices_sorted_by_b.back();\n        if (bs[b_index] > w) {\n            return false;\n        } else if (bs[b_index] == w) {\n            used[b_index] = true;\n            h -= as[b_index];\n            continue;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nset<pair<ll, ll>> solve(ll n, vector<ll> &as, vector<ll> &bs) {\n    ll max_h = *max_element(as.begin(), as.end());\n    ll max_w = *max_element(bs.begin(), bs.end());\n    ll area = 0;\n    for (int i = 0; i < n; i++) {\n        area += as[i] * bs[i];\n    }\n    set<pair<ll, ll>> answer;\n    if (area % max_h == 0) {\n        ll h = max_h;\n        ll w = area / h;\n        if (solve_with_fixed_size(n, as, bs, h, w)) {\n            answer.insert({h, w});\n        }\n    }\n    if (area % max_w == 0) {\n        ll w = max_w;\n        ll h = area / w;\n        if (solve_with_fixed_size(n, as, bs, h, w)) {\n            answer.insert({h, w});\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    for (int ii = 0; ii < t; ii++) {\n        ll n;\n        cin >> n;\n        vector<ll> as(n), bs(n);\n        for (int i = 0; i < n; i++) {\n            cin >> as[i];\n            cin >> bs[i];\n        }\n        auto answer = solve(n, as, bs);\n        cout << answer.size() << '\\n';\n        for (auto &&[h, w] : answer) {\n            cout << h << ' ' << w << '\\n';\n        }\n    }\n    return 0;\n}\n"
}