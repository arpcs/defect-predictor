{
    "id": 202228453,
    "contestId": 1819,
    "creationTimeSeconds": 1681556555,
    "relativeTimeSeconds": 7055,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "Blitztage"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 8,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "PRETESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "// Problem: B. The Butcher\r\n// Contest: Codeforces - Codeforces Round 866 (Div. 1)\r\n// URL: https://codeforces.com/contest/1819/problem/B\r\n// Memory Limit: 256 MB\r\n// Time Limit: 2000 ms\r\n// \r\n// Powered by CP Editor (https://cpeditor.org)\r\n\r\n// #pragma GCC target (\"avx2\")\r\n#pragma GCC optimize (\"O3\")\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize (\"unroll-loops\")\r\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\n#include <bits/stdc++.h>   //Blitztage\r\nusing namespace std;\r\n \r\n//for loop macros\r\n#define fo(i,n) for(int i = 0; i < n; i++)\r\n#define foL(i,n) for(long long i = 0; i < n; i++)\r\n#define foa(i,k,n) for(int i = k; i < n; i++)\r\n#define fob(i,k,n) for(int i = k; i >= n; i--)\r\n#define foaL(i,k,n) for(long long i = k; i < n; i++)\r\n#define fobL(i,k,n) for(long long i = k; i >= n; i--)\r\n \r\nconstexpr int bits(int x) {return x == 0 ? 0 : 31-__builtin_clz(x);}\r\n \r\n//template -> AnandOza && bqi343 Github\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define mp make_pair\r\n#define F first\r\n#define S second\r\n#define resz resize\r\n \r\n#define sz(x) int((x).size())\r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define trav(a, x) for (auto &a : x)\r\n \r\n#define L1(u, ...) [&](auto &&u) { return __VA_ARGS__; }\r\n#define L2(u, v, ...) [&](auto &&u, auto &&v) { return __VA_ARGS__; }\r\n \r\n#define sort_by(x, y) sort(all(x), [&](const auto &l, const auto &r) { return y; })\r\n\r\n#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}\r\n\r\n#define uniq(v) {v.erase(unique(v.begin(), v.end()), v.end());}\r\n \r\nusing ld = long double; \r\nusing ll = long long;\r\nusing vi = vector<int>;\r\nusing vvi = vector<vi>;\r\nusing vll = vector<ll>;\r\nusing vvll = vector<vll>;\r\nusing vb = vector<bool>;\r\nusing vvb = vector<vb>;\r\nusing vs = vector<string>;\r\n \r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\n \r\nusing vpii = vector<pii>;\r\nusing vpll = vector<pll>;\r\n \r\ntemplate <typename T> void ckmin(T &a, const T &b) { a = min(a, b); }\r\ntemplate <typename T> void ckmax(T &a, const T &b) { a = max(a, b); }\r\n \r\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n \r\nnamespace __input {\r\n    template <class T1, class T2> void re(pair<T1, T2> &p);\r\n    template <class T> void re(vector<T> &a);\r\n    template <class T, size_t SZ> void re(array<T, SZ> &a);\r\n \r\n    template <class T> void re(T &x) { cin >> x; }\r\n    void re(double &x) { string t; re(t); x = stod(t); }\r\n    template <class Arg, class... Args> void re(Arg &first, Args &...rest) { re(first); re(rest...); }\r\n \r\n    template <class T1, class T2> void re(pair<T1, T2> &p) { re(p.f, p.s); }\r\n    template <class T> void re(vector<T> &a) { for (int i = 0; i < sz(a); i++) re(a[i]); }\r\n    template <class T, size_t SZ> void re(array<T, SZ> &a) { for (int i = 0; i < SZ; i++) re(a[i]); }\r\n}\r\nusing namespace __input;\r\n \r\nnamespace __output {\r\n    template <typename T> struct is_outputtable { template <typename C> static constexpr decltype(declval<ostream &>() << declval<const C &>(), bool()) test(int) { return true; } template <typename C> static constexpr bool test(...) { return false; } static constexpr bool value = test<T>(int()); };\r\n    template <class T, typename V = decltype(declval<const T &>().begin()), typename S = typename enable_if<!is_outputtable<T>::value, bool>::type> void pr(const T &x);\r\n \r\n    template <class T, typename V = decltype(declval<ostream &>() << declval<const T &>())> void pr(const T &x) { cout << x; }\r\n    template <class T1, class T2> void pr(const pair<T1, T2> &x);\r\n    template <class Arg, class... Args> void pr(const Arg &first, const Args &...rest) { pr(first); pr(rest...); }\r\n \r\n    template <class T, bool pretty = true> void prContain(const T &x) { if (pretty) pr(\"{\"); bool fst = 1; for (const auto &a : x) pr(!fst ? pretty ? \", \" : \" \" : \"\", a), fst = 0; if (pretty) pr(\"}\"); }\r\n \r\n    template <class T> void pc(const T &x) { prContain<T, false>(x); pr(\"\\n\"); }\r\n    template <class T1, class T2> void pr(const pair<T1, T2> &x) { pr(\"{\", x.f, \", \", x.s, \"}\"); }\r\n    template <class T, typename V, typename S> void pr(const T &x) { prContain(x); }\r\n \r\n    void ps() { pr(\"\\n\"); }\r\n    template <class Arg> void ps(const Arg &first) { pr(first); ps(); }\r\n    template <class Arg, class... Args> void ps(const Arg &first, const Args &...rest) { pr(first, \" \"); ps(rest...); }\r\n}\r\nusing namespace __output;\r\n \r\n#define __pn(x) pr(#x, \" = \")\r\n#ifdef ANAND_LOCAL\r\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\r\n#else\r\n#define pd(...)\r\n#endif\r\n \r\nnamespace __algorithm {\r\n    template <typename T> void dedup(vector<T> &v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }\r\n    template <typename T> typename vector<T>::const_iterator find(const vector<T> &v, const T &x) { auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end(); }\r\n    template <typename T> size_t index(const vector<T> &v, const T &x) { auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin(); }\r\n    template <typename I> struct _reversed_struct { I &v_; explicit _reversed_struct(I &v) : v_{v} {} typename I::reverse_iterator begin() const { return v_.rbegin(); } typename I::reverse_iterator end() const { return v_.rend(); } };\r\n    template <typename I> _reversed_struct<I> reversed(I &v) { return _reversed_struct<I>(v); }\r\n}\r\nusing namespace __algorithm;\r\n \r\nnamespace __io {\r\n    void setIO() { ios_base::sync_with_stdio(0); cin.tie(0); cout << setprecision(15); }\r\n}\r\nusing namespace __io;\r\n\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\n \r\nuint64_t random_address() { char *p = new char; delete p; return uint64_t(p); }\r\n \r\nstruct safe_hash {\r\n    static unsigned hash32(unsigned x) {\r\n        x = (x ^ (x >> 16)) * 0x45d9f3b;\r\n        x = (x ^ (x >> 16)) * 0x45d9f3b;\r\n        return x ^ (x >> 16);\r\n    }\r\n \r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n \r\n    template<typename T>\r\n    uint64_t operator()(T x) const {\r\n        static const uint64_t FIXED_RANDOM = splitmix64(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));\r\n        return sizeof(x) <= 4 ? hash32(unsigned(x ^ FIXED_RANDOM)) : splitmix64(x ^ FIXED_RANDOM);\r\n    }\r\n};\r\n  \r\n#define noo {ps(\"NO\");return;}\r\n#define yess {ps(\"YES\");return;}\r\n\r\n#define GOOGLE 0\r\nconst ld pi = 3.14159265358979323846;\r\nconst ll N = 3e5; \r\nconst ll mod = 1000000007;\r\n\r\n//#define int long long\r\nstring s, t; \r\n#define Multitests 1\r\n\r\nvvi forw(12);\r\nvvi forh(12);\r\n\r\nvoid solve(){\r\n\tll n;\r\n\tcin >> n;\r\n\tvector<array<ll,2>> v(n);\r\n\tre(v);\r\n\tsort(all(v), [](auto x, auto y){\r\n\t\tif(x[1] == y[1]) return x[0] < y[0];\r\n\t\treturn x[1] < y[1];\r\n\t});\r\n\t// ps(v);\r\n\tll lw = 0;\r\n\tll lh = 0;\r\n\tll area = 0;\r\n\tfo(i,n){\r\n\t\tarea += v[i][0] * v[i][1];\r\n\t\tckmax(lw, v[i][0]);\r\n\t\tckmax(lh, v[i][1]);\r\n\t}\r\n\t// pair 1, lw, area/lw\r\n\t// pair 2, lh, area/lh\r\n\tvector<array<ll,2>> ans;\r\n\t\r\n\tauto check = [&](ll a, ll b, auto& check)->bool{\r\n\t\t// pd(a, b);\r\n\t\tif(!forw[a].empty()){\r\n\t\t\tll p = forw[a].back();\r\n\t\t\tforw[a].pop_back();\r\n\t\t\tif(p == b) return true;\r\n\t\t\tif(p > b) return false;\r\n\t\t\treturn check(a, b-p, check);\r\n\t\t}\r\n\t\tif(!forh[b].empty()){\r\n\t\t\tll p = forh[b].back();\r\n\t\t\tforh[b].pop_back();\r\n\t\t\tif(p == a) return true;\r\n\t\t\tif(p > a) return false;\r\n\t\t\treturn check(a-p, b, check);\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\t\r\n\tfo(i,n){\r\n\t\tforw[v[i][0]].pb(v[i][1]);\r\n\t\tforh[v[i][1]].pb(v[i][0]);\r\n\t}\r\n\t\r\n\tif(area % lw == 0 && check(lw, area/lw, check)) ans.pb({lw, area/lw});\r\n\t\r\n\tbool ok = true;\r\n\tfo(i,n){\r\n\t\tif(!forw[v[i][0]].empty()) ok = 1;\r\n\t\tif(!forh[v[i][1]].empty()) ok = 1;\r\n\t}\r\n\t\r\n\tassert((sz(ans) == 0) || ok);\r\n\t\r\n\tfo(i,n){\r\n\t\tif(!forw[v[i][0]].empty()) forw[v[i][0]].pop_back();\r\n\t\tif(!forh[v[i][1]].empty()) forh[v[i][1]].pop_back();\r\n\t}\r\n\t\r\n\tfo(i,n){\r\n\t\tforw[v[i][0]].pb(v[i][1]);\r\n\t\tforh[v[i][1]].pb(v[i][0]);\r\n\t}\r\n\t\r\n\tif(area % lh == 0 && check(area/lh, lh, check)) ans.pb({area/lh, lh});\r\n\t\r\n\tfo(i,n){\r\n\t\tif(!forw[v[i][0]].empty()) forw[v[i][0]].pop_back();\r\n\t\tif(!forh[v[i][1]].empty()) forh[v[i][1]].pop_back();\r\n\t}\r\n\t\r\n\tgetunique(ans);\r\n\t\r\n\tps(sz(ans));\r\n\tfor(auto x : ans){\r\n\t\tps(x[0], x[1]);\r\n\t}\r\n\t\r\n}\r\n \r\n \r\nint32_t main(){\r\n\t//sieve();\r\n    setIO();\r\n\t#if Multitests\r\n\t\tint t; cin >> t; \r\n\t\tfor(int i = 0; i < t; i++){\r\n\t\t\t#if GOOGLE\r\n       \t\t cout<<\"Case #\"<<i + 1<<\": \";\r\n\t\t\t#endif\r\n\t\t\t solve();\r\n\t\t}\r\n\t#else \r\n\t\tsolve();\r\n\t#endif\r\n    return 0;\r\n}"
}