{
    "id": 202341244,
    "contestId": 1819,
    "creationTimeSeconds": 1681633703,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "NiqqaNotHere"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 19,
    "timeConsumedMillis": 436,
    "memoryConsumedBytes": 24473600,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define gc getchar_unlocked\r\n#define fo(i,n) for(i=0;i<n;i++)\r\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\r\n#define ll long long\r\n#define si(x)\tscanf(\"%d\",&x)\r\n#define sl(x)\tscanf(\"%lld\",&x)\r\n#define ss(s)\tscanf(\"%s\",s)\r\n#define pi(x)\tprintf(\"%d\\n\",x)\r\n#define pl(x)\tprintf(\"%lld\\n\",x)\r\n#define ps(s)\tprintf(\"%s\\n\",s)\r\n#define deb(x) cout << #x << \"=\" << x << endl\r\n#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\r\n#define pb push_back\r\n#define mp make_pair\r\n#define F first\r\n#define S second\r\n#define all(x) x.begin(), x.end()\r\n#define clr(x) memset(x, 0, sizeof(x))\r\n#define sortall(x) sort(all(x))\r\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\r\n#define PI 3.1415926535897932384626\r\ntypedef pair < int, int >pii;\r\ntypedef pair < ll, ll > pl;\r\ntypedef vector < int >vi;\r\ntypedef vector < ll > vl;\r\ntypedef vector < pii > vpii;\r\ntypedef vector < pl > vpl;\r\ntypedef vector < vi > vvi;\r\ntypedef vector < vl > vvl;\r\nmt19937_64 rang (chrono::high_resolution_clock::now ().time_since_epoch ().\r\n\t\t count ());\r\nint\r\nrng (int lim)\r\n{\r\n  uniform_int_distribution < int >uid (0, lim - 1);\r\n  return uid (rang);\r\n}\r\n \r\nint mpow (int base, int exp);\r\nvoid ipgraph (int n, int m);\r\n\r\nconst int mod = 998244353;\r\nconst int N = 3e5, M = N;\r\n//=======================\r\n \r\nvi g[N];\r\nint a[N];\r\n \r\nvoid build(vl& a, vl& segtree, ll lo, ll hi, ll ind)\r\n{\r\n    if(lo==hi)\r\n    {\r\n        segtree[ind] = a[lo];\r\n        return;\r\n    }\r\n    ll mid=(lo+hi)/2;\r\n    build(a,segtree,lo,mid,2*ind+1);\r\n    build(a,segtree,mid+1,hi,2*ind+2);\r\n    segtree[ind] = max(segtree[2*ind+1],segtree[2*ind+2]);\r\n}\r\nvoid update(vector<int>& segtree, int aind, int val, int lo, int hi, int ind)\r\n{\r\n    if(hi==lo && hi==aind)\r\n    {\r\n        segtree[ind]=val;\r\n        int cur=(ind-1)/2;\r\n        while(cur>=0)\r\n        {\r\n            segtree[cur]=max(segtree[cur*2+1], segtree[cur*2+2]);\r\n            if(cur==0)\r\n            break;\r\n            cur=(cur-1)/2;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        int m=(lo+hi)/2;\r\n        if(aind<=m)\r\n        update(segtree, aind, val, lo, m, 2*ind+1);\r\n        else\r\n        update(segtree, aind, val, m+1, hi, 2*ind+2);\r\n    }\r\n}\r\nll query(vl& segtree, ll l, ll r, ll lo, ll hi, ll ind)\r\n{\r\n    ll mid;\r\n    if(r<lo || l>hi)\r\n    {\r\n        return 0;\r\n    }\r\n    else if(lo>=l && hi<=r)\r\n    {\r\n        return segtree[ind];\r\n    }\r\n    else \r\n    {\r\n        mid = (lo+hi)/2;\r\n        return max(query(segtree,l,r,lo,mid,2*ind+1) , query(segtree,l,r,mid+1,hi,2*ind+2));\r\n    }\r\n}\r\n \r\nbool isadj(ll l, ll r, vector<string>& a){\r\n    int i,j,n=a.size(),m=a[0].size();\r\n    bool flag = 0;\r\n    for(i=l-1;i<=l+1;i++)\r\n    {\r\n        for(j=r-1;j<=r+1;j++)\r\n        {\r\n            if(i==l && j==r)\r\n            continue;\r\n            \r\n            if(i<0 || j<0 || i>=n || j>=m)\r\n            continue;\r\n            \r\n            if(a[i][j]=='0')\r\n            flag=1;\r\n        }\r\n    }\r\n    return flag;\r\n}\r\n \r\nint power(long long x, unsigned int y, int p)\r\n{\r\n    int res = 1;     // Initialize result\r\n \r\n    x = x % p; // Update x if it is more than or\r\n                // equal to p\r\n  \r\n    if (x == 0) return 0; // In case x is divisible by p;\r\n \r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result\r\n        if (y & 1)\r\n            res = (res*x) % p;\r\n \r\n        // y must be even now\r\n        y = y>>1; // y = y/2\r\n        x = (x*x) % p;\r\n    }\r\n    return res;\r\n}\r\n \r\nll find(ll u, vl& parent)\r\n{\r\n    stack<ll> stk;\r\n    while(u!=parent[u])\r\n    {\r\n        stk.push(u);\r\n        u = parent[u];\r\n    }\r\n    while(!stk.empty())\r\n    {\r\n        parent[stk.top()] = u;\r\n        stk.pop();\r\n    }\r\n    return u;\r\n}\r\n \r\nvoid uni(ll u, ll v, vl& parent, vl& rank)\r\n{\r\n    ll paru = find(u,parent), parv = find(v,parent);\r\n    if(paru==parv)\r\n    return;\r\n    if(rank[paru]>rank[parv])\r\n    {\r\n        parent[parv] = paru;\r\n        rank[paru]+=rank[parv];\r\n    }\r\n    else\r\n    {\r\n        parent[paru] = parv;\r\n        rank[parv]+=rank[paru];\r\n    }\r\n}\r\n\r\nll lcm(ll a , ll b){\r\n    return (a/gcd(a,b))*b;\r\n}\r\nvoid app(vl& res, vl& a)\r\n{\r\n    for(ll x: a)\r\n    {\r\n        res.pb(x);\r\n    }\r\n}\r\nbool fun(vl& h, vl& w, ll rh, ll rw)\r\n{\r\n    // deb2(rh, rw);\r\n    ll i,j,n=h.size(),flag;\r\n    multiset<pl> st1, st2;\r\n    fo(i,n)\r\n    {\r\n        st1.insert({h[i], w[i]});\r\n        st2.insert({w[i], h[i]});\r\n    }\r\n    while(st1.size())\r\n    {\r\n        flag = 0;\r\n        auto it1  = st1.upper_bound({rh, 0});\r\n        if(it1 != st1.end() && it1->F == rh && it1->S <= rw)\r\n        {\r\n            // deb2(it->F, it->S);\r\n            flag=1;\r\n            rw-=(it1->S);\r\n            st2.erase({it1->S, it1->F});\r\n            st1.erase(it1);\r\n        }\r\n        if(flag==0)\r\n        {\r\n            auto it2 = st2.upper_bound({rw, 0});\r\n            if(it2 != st2.end() && it2->F == rw && it2->S <= rh)\r\n            {\r\n                // deb2(it->F, it->S);\r\n                flag=1;\r\n                rh-=(it2->S);\r\n                st1.erase({it2->S, it2->F});\r\n                st2.erase(it2);\r\n            }\r\n        }\r\n        if(flag==0)\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid solve() {\r\n    ll mex=-1,i,j,n,m,k=0,th1,th2,h1=0,h2=LLONG_MAX,temp1=0,temp2,u,v,ctr=0,l,r,area=0,mh,mw;\r\n    cin>>n;\r\n    vl h(n), w(n);\r\n    vpl res;\r\n    fo(i,n)\r\n    {\r\n        cin>>h[i]>>w[i];\r\n        area+=h[i]*w[i];\r\n    }\r\n    mh = *max_element(h.begin(), h.end());\r\n    mw = *max_element(w.begin(), w.end());\r\n    if(area%mh==0 && fun(h,w,mh,area/mh))\r\n    {\r\n        res.pb({mh, area/mh});\r\n    }\r\n    if(area%mw==0 && fun(h,w,area/mw, mw))\r\n    {\r\n        res.pb({area/mw, mw});\r\n    }\r\n    if(res.size()==2 && res[0] == res[1])\r\n    res.pop_back();\r\n    cout<<res.size()<<endl;\r\n    for(auto x:res)\r\n    {\r\n        cout<<x.F<<\" \"<<x.S<<endl;\r\n    }\r\n}\r\n\r\n\r\n \r\nint main() {\r\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\r\n    srand(chrono::high_resolution_clock::now().time_since_epoch().count());\r\n \r\n    ll t = 1;\r\n    cin >> t;\r\n    while(t--) {\r\n      solve();\r\n    }\r\n \r\n    return 0;\r\n}\r\n \r\nint mpow(int base, int exp) {\r\n  base %= mod;\r\n  int result = 1;\r\n  while (exp > 0) {\r\n    if (exp & 1) result = ((ll)result * base) % mod;\r\n    base = ((ll)base * base) % mod;\r\n    exp >>= 1;\r\n  }\r\n  return result;\r\n}\r\n \r\nvoid ipgraph(int n, int m){\r\n\tint i, u, v;\r\n\twhile(m--){\r\n\t\tcin>>u>>v;\r\n    u--, v--;\r\n\t\tg[u].pb(v);\r\n\t\tg[v].pb(u);\r\n\t}\r\n}"
}