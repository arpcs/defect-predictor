{
    "id": 205996244,
    "contestId": 1819,
    "creationTimeSeconds": 1684160823,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "codnokers"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 23,
    "timeConsumedMillis": 545,
    "memoryConsumedBytes": 29286400,
    "source": "////#include<iostream>\r\n////using namespace std;\r\n////static class RaceCars\r\n////{\r\n////private:\r\n////\tint num_of_cars = 0; //only one data item for all objects\r\n////\tint score  = 0;\r\n////\tstring name;\r\n////public:\r\n////\tRaceCars() { num_of_cars++; score++; }\r\n////\tint getcount() { return num_of_cars; }\r\n////\tint getScore() { return score; }\r\n////\tvoid display() {\r\n////\t\tcout << name << endl;\r\n////\t}\r\n////\tvoid setName(string name) {\r\n////\t\tthis->name = name;\r\n////\t}\r\n////\tvoid nonStaticFunc()\r\n////\t{\r\n////\t\tcout << num_of_cars << endl;\r\n////\t\tcout << score << endl;\r\n////\t}\r\n////\tvoid setcount(int s) { score = s; }\r\n////};\r\n////int main()\r\n////{\r\n////\tRaceCars c1, c2;\r\n////\tc1.setName(\"HI\");\r\n////\tc1.display();\r\n////\tc2.display();\r\n////\tcout << c1.getcount() << endl;\r\n////\tcout << c2.getcount() << endl;\r\n////\treturn 0;\r\n////}\r\n//////\r\n//////#include<iostream>\r\n//////using namespace std;\r\n//////class Distance\r\n//////{\r\n//////private:\r\n//////\tint feet;\r\n//////\tdouble inches;\r\n//////public:\r\n//////\tDistance()\r\n//////\t{\r\n//////\t\tfeet = 0; inches = 0.0;\r\n//////\t}\r\n//////\tDistance(int ft, double in)\r\n//////\t{\r\n//////\t\tfeet = ft; inches = in;\r\n//////\t}\r\n//////\tconst Distance add_dist(Distance* d2) const\r\n//////\t{\r\n//////\t\tDistance temp; //temporary variable\r\n//////\t\t// feet = 0; //ERROR: can\ufffdt modify this\r\n//////\t\t//d2.feet = 0; //No ERROR: can modify d2\r\n//////\r\n//////\t\ttemp.inches = inches + d2->inches; //add the inches\r\n//////\t\ttemp.feet = feet + d2->feet; //add the feet\r\n//////\t\td2->inches += 1;\r\n//////\t\td2->feet += 1;\r\n//////\t\treturn temp;\r\n//////\t}\r\n//////\tvoid display() {\r\n//////\t\tcout << feet << endl;\r\n//////\t\tcout << inches << endl;\r\n//////\t}\r\n//////\tvoid change() {\r\n//////\t\tfeet++;\r\n//////\t}\r\n//////\t\r\n//////};\r\n//////int main()\r\n//////{\r\n//////\t/*Distance d1(5,3);\r\n//////\tDistance d2(1, 2);\r\n//////\tconst Distance d3(9, 9);\r\n//////\td3.display();*/\r\n//////\t//Distance* ptr[3];\r\n//////\t////ptr = new Distance[3];\r\n//////\t//int n = 0;\r\n//////\t//do {\r\n//////\t//\tptr[n] = new Distance;\r\n//////\t//\tptr[n]->display();\r\n//////\t//\tn++;\r\n//////\t//\t\r\n//////\t//} while (n < 3);\r\n//////\t//return 0;\r\n//////\r\n//////\r\n//////\tDistance d1(5,3);\r\n//////\tDistance d2(1, 2);\r\n//////\tDistance d3 = d1.add_dist(&d2);\r\n//////\td3.change();\r\n//////\td3.display();\r\n//////}\r\n//#include<iostream>\r\n//using namespace std;\r\n//\r\n//class Dummy{\r\n//public:\r\n//\tint* x;\r\n//\tDummy(int m)\r\n//\t{\r\n//\t\tx = new int;\r\n//\t\t*x = m;\r\n//\t}\r\n//\tint get() const\r\n//\t{\r\n//\t\treturn *x;\r\n//\t}\r\n//\tvoid set(int m)\r\n//\t{\r\n//\t\t*x = m;\r\n//\t}\r\n//\tvoid display()\r\n//\t{\r\n//\t\tcout << \"Value of ptr : \" << *x << endl;\r\n//\t\t\tcout << \"Address of ptr : \" << x << endl;\r\n//\t}\r\n//\tDummy(const Dummy &obj) {\r\n//\t\tx = new int;\r\n//\t\t*(this->x) = *(obj.x);\r\n//\t}\r\n//\tDummy operator+(Dummy& obj) {\r\n//\t\tDummy temp(*this->x);\r\n//\t\t*(temp.x) += *(obj.x);\r\n//\t\treturn temp;\r\n//\t}\r\n//};\r\n//int main()\r\n//{\r\n//\tDummy d1(4);\r\n//\tDummy d2 = d1; //Copy constructor\r\n//\td1.display();\r\n//\td2.display();\r\n//\td1.set(11);\r\n//\td1.display();\r\n//\td2.display();\r\n//\tDummy d3 = d1 + d2;\r\n//\td3.display();\r\n//\treturn 0;\r\n//}\r\n//#pragma GCC target(\"trapv\")\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <set>\r\n#include <string>\r\n#include <cmath>\r\n#include <map>\r\n#include <iostream>\r\n#include <list>\r\n#include <stack>\r\n#include <cassert>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef long double ld;\r\n\r\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\r\n\r\nconst ll INF = 1e9 * 1e9 + 100, SZ = 1100;\r\n\r\nll n;\r\nvector<pair<ll, ll>> vec;\r\nmap<ll, pair<ll, ll>> blocks;\r\n\r\npair<ll, ll> solve() {\r\n\tset<pair<ll, ll>> widest, longest;\r\n\r\n\tfor (size_t i = 0; i < vec.size(); i++) {\r\n\t\twidest.insert({ vec[i].first, i });\r\n\t\tlongest.insert({ vec[i].second, i });\r\n\r\n\t\tblocks[i] = vec[i];\r\n\t}\r\n\r\n\tpair<ll, ll> ans = { -1, -1 };\r\n\tbool mode = 0;\r\n\tll prevw = INF, prevh = INF, prv = -1;\r\n\tbool cringe = 0;\r\n\twhile (widest.size() != 0) {\r\n\t\tif (mode == 0) {\r\n\t\t\tll cur = (*widest.rbegin()).first, sum = 0;\r\n\t\t\tif (ans.second == -1) ans.second = cur;\r\n\t\t\tprv = blocks[(*widest.rbegin()).second].second;\r\n\r\n\t\t\twhile (widest.size() > 0 && (*widest.rbegin()).first == cur) {\r\n\t\t\t\tauto it = (--widest.end());\r\n\t\t\t\tlongest.erase({ blocks[it->second].second, it->second });\r\n\t\t\t\tsum += blocks[it->second].second;\r\n\t\t\t\twidest.erase(it);\r\n\t\t\t}\r\n\r\n\t\t\tif (!cringe) ans.first = sum;\r\n\t\t\tprv = sum;\r\n\t\t\tif (prevw == INF) {\r\n\t\t\t\tprevh = cur;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprevw -= sum;\r\n\t\t\t\tif (prevh != cur) return { -1, -1 };\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tll cur = (*longest.rbegin()).first, sum = 0;\r\n\t\t\tif (!cringe) {\r\n\t\t\t\tans.first = cur + prv;\r\n\t\t\t\tcringe = 1;\r\n\t\t\t}\r\n\r\n\t\t\twhile (longest.size() > 0 && (*longest.rbegin()).first == cur) {\r\n\t\t\t\tauto it = (--longest.end());\r\n\t\t\t\twidest.erase({ blocks[it->second].first, it->second });\r\n\t\t\t\tsum += blocks[it->second].first;\r\n\t\t\t\tlongest.erase(it);\r\n\t\t\t}\r\n\r\n\t\t\tif (prevw == INF) {\r\n\t\t\t\tprevw = cur;\r\n\t\t\t\tprevh -= sum;\r\n\t\t\t\tif (prevw != cur) return { -1, -1 };\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprevh -= sum;\r\n\t\t\t\tif (prevw != cur) return { -1, -1 };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmode ^= 1;\r\n\t}\r\n\r\n\tif (prevh == 0 || prevw == 0 || prevh == INF || prevw == INF) {\r\n\t\treturn ans;\r\n\t}\r\n\telse {\r\n\t\treturn { -1, -1 };\r\n\t}\r\n}\r\n\r\nsigned main() {\r\n\tfastInp;\r\n\r\n\tll t;\r\n\tcin >> t;\r\n\r\n\twhile (t--) {\r\n\t\tvec.clear();\r\n\t\tblocks.clear();\r\n\t\tcin >> n;\r\n\r\n\t\tvec.resize(n);\r\n\t\tfor (auto& c : vec) cin >> c.first >> c.second;\r\n\r\n\t\tvector<pair<ll, ll>> ans;\r\n\r\n\t\tans.push_back(solve());\r\n\t\tswap(ans.back().first, ans.back().second);\r\n\t\tif (ans.back().first == -1) ans.pop_back();\r\n\r\n\t\tfor (auto& c : vec) swap(c.first, c.second);\r\n\r\n\t\tans.push_back(solve());\r\n\t\tif (ans.back().first == -1) ans.pop_back();\r\n\r\n\t\tif (ans.size() == 2 && ans[0] == ans[1]) {\r\n\t\t\tans.pop_back();\r\n\t\t}\r\n\t\tcout << ans.size() << \"\\n\";\r\n\r\n\t\tfor (auto c : ans) cout << c.first << \" \" << c.second << \"\\n\";\r\n\t}\r\n\r\n\treturn 0;\r\n}"
}