{
    "id": 202486408,
    "contestId": 1819,
    "creationTimeSeconds": 1681734168,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "debdhriti"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 23,
    "timeConsumedMillis": 389,
    "memoryConsumedBytes": 59084800,
    "source": "#include <bits/stdc++.h>\r\n//for segment tree only\r\n#define left(i) (2*i + 1)\r\n#define right(i) (2*i + 2)\r\n#define parent(i) ((i-1)/2)\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\n#define FAST                      \\\r\nios_base::sync_with_stdio(0); \\\r\ncin.tie(0);                   \\\r\ncout.tie(0)\r\n#define pb push_back\r\n#define fixx(n) fixed << setprecision(n)\r\n#define ff first\r\n#define MAXN   1000001\r\n#define pii pair<int, int>\r\n#define INF 1e18\r\n#define NIL 0\r\n#define ss second\r\n#define PI 3.14159265358979323846\r\n#define ll long long int\r\n#define ain(a,n) for(ll i=0;i<(n);++i)  cin>>(a)[i];\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n// Pragmas\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\nint spf[MAXN];\r\n//-------------------------------------------------------------------------------\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n//if you make it less equal\r\n//lower_bound and upper_bound are exchanged\r\n//erase can be done by s.erase(s.upper_bound(value))\r\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update > pbds; // find_by_order, order_of_key\r\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update > pbdsl; // find_by_order, order_of_key\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr << #x<<\" \"; _print(x); cerr << endl;\r\n#else\r\n#define debug(x);\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << fixx(10) << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\"<<endl;}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(unordered_set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T , greater<T>> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\nvoid _print(pbds v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\nvoid _print(pbdsl v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n//-------------------------------------------------------------------------------\r\nconst vector<pair<ll,ll>> coords{{1,0},{0,1},{0,-1},{-1,0}};\r\nvoid sieve()\r\n{\r\n    spf[1] = 1;\r\n    for (int i=2; i<MAXN; i++)\r\n        spf[i] = i;\r\n    for (int i=4; i<MAXN; i+=2)\r\n        spf[i] = 2;\r\n\r\n    for (int i=3; i*i<MAXN; i++)\r\n    {\r\n        if (spf[i] == i)\r\n        {\r\n            for (int j=i*i; j<MAXN; j+=i)\r\n                if (spf[j]==j)\r\n                    spf[j] = i;\r\n            }\r\n        }\r\n    }\r\n    ll CeilIndex(std::vector<ll>& v, ll l, ll r, ll key)\r\n{\r\n    while (r - l > 1) {\r\n        ll m = l + (r - l) / 2;\r\n        if (v[m] >= key)\r\n            r = m;\r\n        else\r\n            l = m;\r\n    }\r\n  \r\n    return r;\r\n}\r\n  \r\nll lis(vector<ll>& v)\r\n{\r\n    if (v.size() == 0)\r\n        return 0;\r\n  \r\n    std::vector<ll> tail(v.size(), 0);\r\n    ll length = 1; // always polls empty slot in tail\r\n  \r\n    tail[0] = v[0];\r\n    for (size_t i = 1; i < v.size(); i++) {\r\n  \r\n        // new smallest value\r\n        if (v[i] < tail[0])\r\n            tail[0] = v[i];\r\n  \r\n        // v[i] extends largest subsequence\r\n        else if (v[i] > tail[length - 1])\r\n            tail[length++] = v[i];\r\n  \r\n        // v[i] will become end candidate of an existing\r\n        // subsequence or Throw away larger elements in all\r\n        // LIS, to make room for upcoming greater elements\r\n        // than v[i] (and also, v[i] would have already\r\n        // appeared in one of LIS, identify the location\r\n        // and replace it)\r\n        else\r\n            tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i];\r\n    }\r\n  \r\n    return length;\r\n}\r\n    vector<ll> getFact(ll x)\r\n{\r\n    vector<ll> ret;\r\n    while (x != 1)\r\n    {\r\n        ret.push_back(spf[x]);\r\n        x = x / spf[x];\r\n    }\r\n    return ret;\r\n}\r\n \r\n    map<ll , ll> getFactm(ll x)\r\n{\r\n    map<ll , ll> ret;\r\n    while (x != 1)\r\n    {\r\n        ret[spf[x]]++;\r\n        x = x / spf[x];\r\n    }\r\n    return ret;\r\n}\r\n\r\n    ll gcd(ll a, ll b)\r\n    {\r\n        if (b > a)\r\n        {\r\n            return gcd(b, a);\r\n        }\r\n        if (b == 0)\r\n        {\r\n            return a;\r\n        }\r\n        return gcd(b, a % b);\r\n    }\r\n    ll expo(ll a, ll b, ll mod)\r\n    {\r\n        if(b == 0)\r\n            return 1;\r\n        ll res = 1;\r\n        while (b > 0)\r\n        {\r\n            if (b & 1)\r\n                res = (res * a) % mod;\r\n            a = (a * a) % mod;\r\n            b = b >> 1;\r\n        }\r\n        return res;\r\n    }\r\n    void extendgcd(ll a, ll b, ll *v)\r\n    {\r\n        if (b == 0)\r\n        {\r\n            v[0] = 1;\r\n            v[1] = 0;\r\n            v[2] = a;\r\n            return;\r\n        }\r\n        extendgcd(b, a % b, v);\r\n        ll x = v[1];\r\n        v[1] = v[0] - v[1] * (a / b);\r\n        v[0] = x;\r\n        return;\r\n} //pass an arry of size1 3\r\nll mminv(ll a, ll b)\r\n{\r\n    ll arr[3];\r\n    extendgcd(a, b, arr);\r\n    return arr[0];\r\n} //for non prime b\r\nll mminvprime(ll a, ll b) { return expo(a, b - 2, b); }\r\nbool revsort(ll a, ll b) { return a > b; }\r\nvoid swap(int &x, int &y)\r\n{\r\n    int temp = x;\r\n    x = y;\r\n    y = temp;\r\n}\r\nll combination(ll n, ll r, ll m, ll *fact, ll *ifact)\r\n{\r\n    ll val1 = fact[n];\r\n    ll val2 = ifact[n - r];\r\n    ll val3 = ifact[r];\r\n    return (((val1 * val2) % m) * val3) % m;\r\n}\r\nvoid google(int t) { cout << \"Case #\" << t << \": \"; }\r\nvector<ll> sieve(ll n)\r\n{\r\n    ll *arr = new ll[n + 1]();\r\n    vector<ll> vect;\r\n    for (ll i = 2; i <= n; i++)\r\n        if (arr[i] == 0)\r\n        {\r\n            vect.push_back(i);\r\n            for (ll j = (i * i); j <= n; j += i)\r\n                arr[j] = 1;\r\n        }\r\n        return vect;\r\n    }\r\n    set<ll> sieves(ll n)\r\n    {\r\n        ll *arr = new ll[n + 1]();\r\n        set<ll> s;\r\n        for (ll i = 2; i <= n; i++)\r\n            if (arr[i] == 0)\r\n            {\r\n                s.insert(i);\r\n                for (ll j = (i * i); j <= n; j += i)\r\n                    arr[j] = 1;\r\n            }\r\n            return s;\r\n        }\r\n        ll mod_add(ll a, ll b, ll m)\r\n        {\r\n            a = a % m;\r\n            b = b % m;\r\n            return (((a + b) % m) + m) % m;\r\n        }\r\n        ll mod_mul(ll a, ll b, ll m)\r\n        {\r\n            a = a % m;\r\n            b = b % m;\r\n            return (((a * b) % m) + m) % m;\r\n        }\r\n        ll mod_sub(ll a, ll b, ll m)\r\n        {\r\n            a = a % m;\r\n            b = b % m;\r\n            return (((a - b) % m) + m) % m;\r\n        }\r\n        ll mod_div(ll a, ll b, ll m)\r\n        {\r\n            a = a % m;\r\n            b = b % m;\r\n            return (mod_mul(a, mminvprime(b, m), m) + m) % m;\r\n} //only for prime m\r\nll mod_inv(ll a, ll mod){\r\n    return expo(a,mod-2,mod);\r\n} \r\nll harmonic_sum(ll n) {\r\n    ll ans = 0;\r\n    if (n == 1) {\r\n      return 1;\r\n  }\r\n  ans += 1 + n;\r\n  for (ll i = 2; i * i <= n; i++) {\r\n      if (i != n / i) {\r\n        ans += (i + n / i);\r\n    } else {\r\n        ans += i;\r\n    }\r\n    ll l = (n / i) + 1;\r\n    ll h = (n / (i - 1)) - 1;\r\n    if (l <= h) {\r\n        ans += (h-l+1)*(i-1);\r\n    }\r\n\r\n}\r\nreturn ans;\r\n}\r\nll harmonic_util(ll x,ll y) {\r\n    ll ans = 0,n=x;\r\n    if (n == 1) {\r\n      return 1;\r\n  }\r\n  ans += 1;\r\n  for (ll i = 2; i * i <= n; i++) {\r\n      if (i != n / i) {\r\n        if(i>=2 && i<=y+1) ans += i;\r\n        if(n/i>=2 && n/i<=y+1) ans+= n/i;\r\n    } else {\r\n        if(i>=2 && i<=y+1) ans += i;\r\n    }\r\n    ll l = (n / i) + 1;\r\n    ll h = (n / (i - 1)) - 1;\r\n    if (l <= h) {\r\n        ans += (h-l+1)*(i-1);\r\n    }\r\n\r\n}\r\nreturn ans;\r\n}\r\n\r\nll nCrFermat(ll n, ll r,int fact[], ll mod){\r\n//if n<r ncr should be 0\r\n    if(n<r || r < 0) return 0;\r\n    if(n == r)\r\n        return 1;\r\n//trivial reason\r\n    if(r==0) return 1;\r\n    return mod_mul((ll)fact[n] , mod_mul(mod_inv((ll)fact[n-r],mod) , mod_inv((ll)fact[r],mod) , mod) , mod);\r\n    return (fact[n]*((mod_inv(fact[n-r],mod)*mod_inv(fact[r],mod))%mod))%mod;\r\n}\r\nll phin(ll n)\r\n{\r\n    ll number = n;\r\n    if (n % 2 == 0)\r\n    {\r\n        number /= 2;\r\n        while (n % 2 == 0)\r\n            n /= 2;\r\n    }\r\n    for (ll i = 3; i <= sqrt(n); i += 2)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            while (n % i == 0)\r\n                n /= i;\r\n            number = (number / i * (i - 1));\r\n        }\r\n    }\r\n    if (n > 1)\r\n        number = (number / n * (n - 1));\r\n    return number;\r\n} //O(sqrt(N))\r\nvoid precision(int a) { cout << setprecision(a) << fixed; }\r\nvector<ll> sosq(ll n){\r\n    ll chk = n*n;\r\n    unordered_set<ll> s;\r\n    vector<ll> res;\r\n    for(ll i=1;i<n;i++){\r\n        s.insert(i*i);\r\n        if(s.find(chk-i*i)!=s.end()){\r\n            res.pb(sqrt(chk-i*i));\r\n            res.pb(i);\r\n            return res;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nbool nc(string a,string b){\r\n    if(a.length()==b.length()) return (a.compare(b)>=0);\r\n    return a.length()>b.length();\r\n}\r\nstring maxnum(string a, string b){\r\n    vector<ll> v;\r\n    for(ll i=0;i<a.length();i++) v.pb(a[i]-'0');\r\n        for(ll i=0;i<b.length();i++) v.pb(b[i]-'0');\r\n            sort(v.rbegin(),v.rend());\r\n        string res=\"\";\r\n        for(ll i=0;i<v.size();i++) res+=(v[i]+'0');\r\n            return res;\r\n    }\r\n//returns something other than that character\r\n    char retrand(char a, char b){\r\n        if(a==b) return (a=='z')?'y':(char)a+1;\r\n        else if(a==b+1){\r\n            return (a=='z')?'x':(char)a+1;\r\n        }else if(b==a+1) return (b=='z')?'x':(char)b+1;\r\n        else return (char)((a+b)/2);\r\n    }\r\nll mod =1e9+7;\r\nll modp=998244353;\r\n    ll getqb(ll n){\r\n        ll f=0,c=0;\r\n        while(n>0){\r\n            f+=((n&1)*expo(10,c,mod));\r\n            n>>=1;\r\n            ++c;\r\n        }\r\n        return f;\r\n    }\r\n//(0,1,2)-->rgb\r\n    ll po2(ll n){\r\n        ll c=0;\r\n        while(n>1){\r\n            n>>=1;\r\n            ++c;\r\n        }\r\n        return c;\r\n    }\r\n    ll ncr(ll n, ll r, ll m){\r\n        r=min(n-r,r);\r\n        if(r==0) return 1;\r\n        return mod_div(mod_mul(n-r+1,ncr(n,r-1,m),m),r,m);\r\n    }\r\n    \r\nvoid getScc(ll i, set<ll> adj[] ,vector<ll>&vis, set<ll>&s){\r\n    //To find SCC\r\n    //1: Get TopoSort\r\n    //2: Reverse Edges\r\n    //3: call this dfs-like function in-order of finishing tym(last-finish=>st.top() first)\r\n    vis[i]=1;\r\n    for(auto x:adj[i]){\r\n        if(!vis[x]) getScc(x,adj,vis,s);\r\n    }\r\n    s.insert(i);\r\n}\r\nclass Histogram{\r\npublic:\r\n    vector<ll> hist;\r\n  vector<ll> nextSmallerElements(vector<ll>&a, ll&n){\r\n        vector<ll>  nse(n,n);\r\n        stack<ll> st;\r\n        for(ll i=0;i<n;i++){\r\n            if(st.empty()) st.push(i);\r\n            else{\r\n                if(a[i]>a[st.top()]){\r\n                    st.push(i);\r\n                }else{\r\n                    while(!st.empty()&&a[i]<=a[st.top()]){\r\n                        nse[st.top()] = i;\r\n                        st.pop();\r\n                    }\r\n                    st.push(i);\r\n                }\r\n            }\r\n        }\r\n        return nse;\r\n    }\r\n    vector<ll> nextGreaterElements(vector<ll>&a, ll&n){\r\n        vector<ll>  nge(n,n);\r\n        stack<ll> st;\r\n        for(ll i=0;i<n;i++){\r\n            if(st.empty()) st.push(i);\r\n            else{\r\n                if(a[i]<=a[st.top()]){\r\n                    st.push(i);\r\n                }else{\r\n                    while(!st.empty()&&a[i]>a[st.top()]){\r\n                        nge[st.top()] = i;\r\n                        st.pop();\r\n                    }\r\n                    st.push(i);\r\n                }\r\n            }\r\n        }\r\n        return nge;\r\n    }\r\n       vector<ll> previousSmallerElements(vector<ll>&a, ll&n){\r\n        vector<ll>  pse(n,-1);\r\n        stack<ll> st;\r\n        for(ll i=n-1;i>=0;i--){\r\n            if(st.empty()) st.push(i);\r\n            else{\r\n                if(a[i]>a[st.top()]){\r\n                    st.push(i);\r\n                }else{\r\n                    while(!st.empty()&&a[i]<=a[st.top()]){\r\n                        pse[st.top()] = i;\r\n                        st.pop();\r\n                    }\r\n                    st.push(i);\r\n                }\r\n            }\r\n        }\r\n        return pse;\r\n    }\r\n    vector<ll> previousGreaterElements(vector<ll>&a, ll&n){\r\n        vector<ll>  pse(n,-1);\r\n        stack<ll> st;\r\n        for(ll i=n-1;i>=0;i--){\r\n            if(st.empty()) st.push(i);\r\n            else{\r\n                if(a[i]<=a[st.top()]){\r\n                    st.push(i);\r\n                }else{\r\n                    while(!st.empty()&&a[i]>a[st.top()]){\r\n                        pse[st.top()] = i;\r\n                        st.pop();\r\n                    }\r\n                    st.push(i);\r\n                }\r\n            }\r\n        }\r\n        return pse;\r\n    }\r\n    ll maxAreaHistogram(vector<ll>&a, ll&n){\r\n        vector<ll> nse(n), pse(n);\r\n        nse = nextSmallerElements(a,n);\r\n        pse = previousSmallerElements(a,n);\r\n        ll maxArea = 0;\r\n        for(ll i=0;i<n;i++){\r\n            maxArea = max(maxArea, (nse[i]-pse[i]-1)*a[i]);\r\n        }\r\n        return maxArea;\r\n    }\r\n};\r\nvoid bip(ll i , vector<pair<ll , ll>> adj[] , vector<ll> &vis , vector<ll> &clr , ll &cnt){\r\n    ++cnt;\r\n    vis[i] = 1;\r\n    for(auto &x : adj[i]){\r\n        if(!vis[x.ff])\r\n            bip(x.ff , adj , vis , clr , cnt);\r\n    }\r\n}\r\nconst ll BASE = 31;\r\n//const ll MOD = 28116440335967;\r\n// long long getHash(ll l , ll r , vector<ll> &hash , vector<ll> &pows){\r\n//     return (hash[r] - (hash[l] * pows[r - l]) % MOD + MOD) % MOD;\r\n// }\r\nstring ts(ll x){\r\n    string ans = \"\";\r\n    while(x){\r\n        ans += (x % 10 + '0');\r\n        x /= 10;\r\n    }\r\n    reverse(ans.begin() , ans.end());\r\n    return ans;\r\n}\r\nvoid topoSort(ll i, vector<pair<ll , vector<pair<ll , ll>>>> adj[], vector<ll>&vis, stack<ll>&st){\r\n    vis[i]=1;\r\n    for(auto x:adj[i]){\r\n        if(!vis[x.ff]) topoSort(x.ff,adj,vis,st);\r\n    }\r\n    st.push(i);\r\n}\r\n\r\n\r\n\r\n\r\n/////////////////////////longest_path////////////////\r\n////////////////////////////////////////////////////////\r\n\r\n///////////////////////cycle/////////////////////\r\n///////////////////////////////////////////////\r\n\r\n//////////////////////exist////////////////////////////\r\n//////////////////////////////////////////////////////\r\n\r\n//////////////lca///////////////////////////\r\n////////////////////////////////////////////\r\n\r\n\r\n\r\n//////////////seg//////////////////////////////////////\r\ntemplate <typename T, class F = function<T(const T&, const T&)>>\r\nclass lazySeg{\r\n    vector < T > seg , lazy;\r\n    ll n;\r\n    T ini , ret;\r\n    F merge;\r\n    bool isSum;\r\n    void propogate(ll no , ll st , ll en){\r\n        if(st == en || lazy[no] == -1) return ;\r\n        ll lc = no << 1 | 1, rc = lc + 1;\r\n        ll mid = (st + en) >> 1;\r\n        T l1 = mid - st + 1 , l2 = en - mid;\r\n        lazy[lc] = lazy[no];\r\n        lazy[rc] = lazy[no];\r\n        seg[lc] = lazy[no] * l1;\r\n        seg[rc] = lazy[no] * l2;\r\n        lazy[no] = -1;\r\n    }\r\n    void upd(ll l ,ll r, T val , ll no, ll st , ll en){\r\n        propogate(no , st, en);\r\n        if(st > en || st > r || en < l) return ;\r\n        if(st >= l && en <= r){\r\n            seg[no] = val * (en - st + 1);\r\n            lazy[no] = val;\r\n            return ;\r\n        }\r\n        ll mid = (st + en) >> 1;\r\n        upd(l,r,val,2*no+1,st,mid);\r\n        upd(l,r,val,2*no+2,mid+1,en);\r\n        seg[no] = merge(seg[2 * no + 1] ,seg[2 * no + 2]);\r\n    }\r\n    T get(ll l , ll r , ll no , ll st, ll en){\r\n        propogate(no,st,en);\r\n        if(st > en || st > r || en < l) return ret;   \r\n        if(st >= l && en <= r) return seg[no];\r\n        ll mid = (st + en) >> 1;\r\n        return merge(get(l,r,2*no+1,st,mid), get(l,r,2*no+2,mid+1,en));\r\n    }\r\n    public :\r\n    lazySeg(const ll &n , const T &ini , const T &ret , const F& f , bool isSum = 0) : merge(f) {\r\n        this -> n = n;\r\n        this -> ini = ini;\r\n        this -> ret = ret;\r\n        this -> isSum = isSum;\r\n        seg.assign(4 * n , ini);\r\n        lazy.assign(4*n, -1);\r\n    }\r\n    void upd(ll l , ll r , T val){\r\n        upd(l,r,val,0,0,n - 1);\r\n    }\r\n    T get(ll l , ll r){\r\n        return get(l,r,0,0,n - 1);\r\n    }\r\n    void reset(){\r\n        seg.assign(4 * n , ini);\r\n        lazy = seg;\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////\r\n\r\nll get(ll a , vector<ll> &par){\r\n    return par[a] = ((a == par[a]) ? a : get(par[a] , par));\r\n}\r\nvoid Union(ll a , ll b , vector<ll> &par , vector<ll> &rank){\r\n    a = get(a , par);\r\n    b = get(b , par);\r\n    if(rank[a] == rank[b])\r\n        ++rank[a];\r\n    if(rank[a] < rank[b])\r\n        par[a] = b;\r\n    else\r\n        par[b] = a;\r\n}\r\n\r\n\r\nmain()\r\n{\r\n        #ifndef ONLINE_JUDGE\r\n\r\n//     // For getting input from input.txt file\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n//     // For getting the error\r\nfreopen(\"error.txt\", \"w\", stderr);\r\n//     // Printing the Output to output.txt file\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n #endif\r\n// //----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    FAST;\r\n// int fact[500001];\r\n// fact[0]=1;\r\n// // filling the factorial array\r\n// for(int i=1;i<=500000;i++){\r\n// fact[i]=mod_mul((ll)fact[i-1],(ll)i,modp);\r\n// }\r\n/*\r\nGOAL: possible whole rectangles\r\nALLOWED: O(N)\r\n-> area of the rectangles are conserved\r\n-> cut into two unequal parts in each move\r\na*b = {a1*b1 , a2*b2 , .... an*bn}\r\n1: either {a , x} thakbe or {y , b}\r\n-> what rectangles can be formed joining the peices\r\n-> always forms atleast a rectangle\r\n\r\n{a1 , b1} -> if u take {a1 , area / a1}\r\nrem -> {a1 , area / a1 - b1} -> rem\r\n-> take the largest length pieces or the larges width pieces\r\n\r\npossible rectangles -> {l , ar/l} or {ar/w , w}\r\nfor a rectangle -> only one of those conditions are true\r\ncheck whether {l , ar/l} can be made\r\n-> as many with length l can be removed -> {l , ar/l - sum(w)}\r\n-> largest width as many times as possble\r\n\r\n\r\n*/\r\nll t,tn;\r\ncin>>t;\r\ntn = t;\r\nwhile(t--){\r\n    ll n , l = 0 , w = 0 , ar = 0;\r\n    cin >> n;\r\n    vector<pair<ll , ll>> v(n) , ans;\r\n    multiset<pair<ll , ll> , greater<pair<ll , ll>>> lw , wl , m1 , m2;\r\n    for(auto &x : v){\r\n        cin >> x.ff >> x.ss;\r\n        l = max(l , x.ff);\r\n        w = max(w , x.ss);\r\n        ar += (x.ff * x.ss);\r\n        lw.insert({x.ff , x.ss});\r\n        wl.insert({x.ss , x.ff});\r\n    }\r\n    m1 = lw , m2 = wl;\r\n    if(ar % l == 0){\r\n        debug(l)\r\n        //check if {l , ar / l} can be made\r\n        ll f = 0 , v , rl = l , rw = ar / l;\r\n        while(!lw.empty()){\r\n            debug(lw)\r\n            if(!f){\r\n                ll c = 0;\r\n                while(!lw.empty() && lw.begin()->ff == rl){\r\n                    ++c;\r\n                    rw -= lw.begin()->ss;\r\n                    wl.erase(wl.find({lw.begin()->ss , lw.begin()->ff}));\r\n                    lw.erase(lw.begin());\r\n                }\r\n                if(!c)\r\n                    break;\r\n            }else{\r\n                ll c = 0;\r\n                while(!wl.empty() && wl.begin()->ff == rw){\r\n                    ++c;\r\n                    rl -= wl.begin()->ss;\r\n                    lw.erase(lw.find({wl.begin()->ss , wl.begin()->ff}));\r\n                    wl.erase(wl.begin());\r\n                }\r\n                if(!c)\r\n                    break;\r\n            }\r\n            f = 1 - f;\r\n        }\r\n        if(lw.empty() && wl.empty()){\r\n            ans.pb({l , ar/l});\r\n        }\r\n    }\r\n    if(ar % w == 0){\r\n        debug(w)\r\n        lw = m1 , wl = m2;\r\n        ll f = 1 , v , rl = ar / w , rw = w;\r\n        debug(rl)\r\n        debug(rw)\r\n        while(!lw.empty()){\r\n            debug(lw)\r\n            debug(wl)\r\n            if(!f){\r\n                ll c = 0;\r\n                while(!lw.empty() && lw.begin()->ff == rl){\r\n                    ++c;\r\n                    rw -= lw.begin()->ss;\r\n                    wl.erase(wl.find({lw.begin()->ss , lw.begin()->ff}));\r\n                    lw.erase(lw.begin());\r\n                }\r\n                if(!c)\r\n                    break;\r\n            }else{\r\n                ll c = 0;\r\n                while(!wl.empty() && wl.begin()->ff == rw){\r\n                    ++c;\r\n                    rl -= wl.begin()->ss;\r\n                    lw.erase(lw.find({wl.begin()->ss , wl.begin()->ff}));\r\n                    wl.erase(wl.begin());\r\n                }\r\n                if(!c)\r\n                    break;\r\n            }\r\n            f = 1 - f;\r\n        }\r\n\r\n        pair<ll , ll> p = {ar / w , w};\r\n        if(lw.empty() && wl.empty() && (ans.empty() || p != ans.back())){\r\n            ans.pb(p);\r\n        }\r\n    }\r\n    cout << ans.size() << endl;\r\n    for(auto &x : ans)\r\n        cout << x.ff << \" \" << x.ss << endl;\r\n    label:\r\n    continue;\r\n}\r\n\r\n //SIMPLIFYYY\r\n //ALL POSSIBILITIES\r\n //ORDER OF OPERATIONS\r\n //PROPER STATES FOR DP\r\n //ALLOT TYM TO ELIMINATE COMPLICATION\r\n //A MUST 1-2\r\n //CHECK CONSTRAINTS\r\n //CHECK TCs\r\n //AVOID LOOPS IN DP AFAP\r\n //DRY RUN GIVEN TCs\r\n //BRUTE FORCE\r\n //INVENT TCs\r\n}"
}