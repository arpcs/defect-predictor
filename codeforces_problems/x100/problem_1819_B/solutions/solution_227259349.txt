{
    "id": 227259349,
    "contestId": 1819,
    "creationTimeSeconds": 1696808477,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "ProGamer"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntemplate<typename T>\r\nusing orderedMultiset = tree<T ,null_type,std::less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;\r\ntypedef long long ll;\r\ntypedef pair<int, int> pi;\r\ntypedef vector<int> vi;\r\n#define f first\r\n#define s second\r\n#define pb push_back\r\n#define rep(i, a, b) for(int i = a; i < (b); ++i) \r\n#define all(x) (x).begin(), (x).end()\r\nll MOD = 1000000007;\r\n \r\nmt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nll add(ll x, ll y)\r\n{\r\n    x += y;\r\n    while(x >= MOD) x -= MOD;\r\n    while(x < 0) x += MOD;\r\n    return x;\r\n}  \r\n \r\nll mult(ll x, ll y)\r\n{\r\n    return (x * 1ll * y) % MOD;\r\n}\r\nll lpow(ll x, ll y)\r\n{\r\n    if(y == 0){\r\n        return 1;\r\n    }\r\n    ll z = 1;\r\n    while(y)\r\n    {\r\n        if(y & 1) z = mult(z, x);\r\n        x = mult(x, x);\r\n        y >>= 1;\r\n    }\r\n    return z;\r\n}\r\nbool prime(int x)\r\n{\r\n    for(int i = 2; i * 1ll * i <= x; i++)\r\n        if(x % i == 0)\r\n            return false;\r\n    return true;    \r\n}\r\n \r\nll inv(ll x) {\r\n\treturn lpow(x, MOD - 2);\r\n}\r\nll qexp(ll a, ll b, ll m) {\r\n    ll res = 1;\r\n    while (b) {\r\n        if (b % 2) res = res * a % m;\r\n        a = a * a % m;\r\n        b /= 2;\r\n    }\r\n    return res;\r\n}\r\nll divide(ll x, ll y)\r\n{\r\n    return mult(x, inv(y));\r\n}\r\nlong long gcd(long long int a, long long int b)\r\n{\r\n  if (b == 0)\r\n    return a;\r\n  return gcd(b, a % b);\r\n}\r\n \r\n// Function to return LCM of two numbers\r\nlong long lcm(int a, int b)\r\n{\r\n    return (a / gcd(a, b)) * b;\r\n}\r\n//math\r\n \r\n \r\nvector <ll> ar;\r\nvector <ll> br;\r\nvoid printDivisors(ll n)\r\n{\r\n    // Note that this loop runs till square root\r\n    for (ll i=1; i<=sqrt(n); i++)\r\n    {\r\n        if (n%i == 0)\r\n        {\r\n            // If divisors are equal, print only one\r\n            if (n/i == i){\r\n                ar.pb(i);\r\n            }\r\n                \r\n  \r\n            else{\r\n                ar.pb(i);\r\n                ar.pb(n/i);\r\n            } // Otherwise print both\r\n                \r\n               \r\n        }\r\n    }\r\n}\r\nvoid bprintDivisors(ll n)\r\n{\r\n    // Note that this loop runs till square root\r\n    for (ll i=1; i<=sqrt(n); i++)\r\n    {\r\n        if (n%i == 0)\r\n        {\r\n            // If divisors are equal, print only one\r\n            if (n/i == i){\r\n                br.pb(i);\r\n            }\r\n                \r\n  \r\n            else{\r\n                br.pb(i);\r\n                br.pb(n/i);\r\n            } // Otherwise print both\r\n                \r\n               \r\n        }\r\n    }\r\n}\r\n \r\nvector<ll> fact, invf;\r\n \r\nvoid precompute(int n) {\r\n    fact.assign(n + 1, 1); \r\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;\r\n    invf.assign(n + 1, 1);\r\n    invf[n] = qexp(fact[n], MOD - 2, MOD);\r\n    for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;\r\n}\r\n \r\nll nCk(ll n,ll k) {\r\n    if (k < 0 || k > n) return 0;\r\n    return fact[n] * invf[k] % MOD * invf[n - k] % MOD;\r\n    // return fact[n] * qexp(fact[k], MOD - 2, MOD) % MOD * qexp(fact[n - k], MOD - 2, MOD) % MOD;\r\n}\r\n \r\nstruct DSU {\r\n\tvector<int> e;\r\n\tDSU(int N) { e = vector<int>(N, -1); }\r\n \r\n\t// get representive component (uses path compression)\r\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\r\n \r\n\tbool same_set(int a, int b) { return get(a) == get(b); }\r\n \r\n\tint size(int x) { return -e[get(x)]; }\r\n \r\n\tbool unite(int x, int y) {  // union by size\r\n\t\tx = get(x), y = get(y);\r\n\t\tif (x == y) return false;\r\n\t\tif (e[x] > e[y]) swap(x, y);\r\n\t\te[x] += e[y]; e[y] = x; return true;\r\n\t}\r\n};\r\n\r\nmultiset<pi> msx;\r\nmultiset<pi> msy;\r\nbool valid(int h, int w){\r\n    //cout<<h<<\" \"<<w<<endl;\r\n    \r\n\r\n    auto it = msx.end();\r\n    --it;\r\n    pi osa = *it;\r\n    auto itr = msy.end();\r\n    --itr;\r\n    pi nosa = *itr;\r\n    if(osa.first == h && osa.second == w && msx.size() == 1){\r\n        return true;\r\n    }\r\n    else if(osa.first == h && nosa.first != w){\r\n        int pp = w - osa.second;\r\n        msx.erase(msx.find({osa.first, osa.second}));\r\n        msy.erase(msy.find({osa.second, osa.first}));\r\n        return valid(h, pp);\r\n    }\r\n    else if(osa.first != h && nosa.first == w){\r\n        int pp = h - nosa.second;\r\n        msy.erase(msy.find({nosa.first, nosa.second}));\r\n        msx.erase(msx.find({nosa.second, nosa.first}));\r\n        return valid(pp, w);\r\n    }\r\n    else{\r\n        return false;\r\n    }\r\n}\r\n\r\nvoid solve(){\r\n    int n;\r\n    cin>>n;\r\n    vector <pi> ans;\r\n    vector <pi> a;\r\n    vector <pi> b;\r\n    msx.clear();\r\n        msy.clear();\r\n    rep(i,0,n){\r\n        int x,y;\r\n        cin>>x>>y;\r\n        msx.insert({x,y});\r\n        msy.insert({y,x});\r\n        a.pb({x,y});\r\n        b.pb({y,x});\r\n    }\r\n    sort(a.rbegin(),a.rend());\r\n    int ansx = a[0].first;\r\n    int ansy = 0;\r\n    int br = -1;\r\n    rep(i,0,n){\r\n        if(a[i].first != a[0].first){\r\n            br = i;\r\n            break;\r\n        }\r\n        ansy += a[i].second;\r\n        msx.erase(msx.find({a[i].first, a[i].second}));\r\n        msy.erase(msy.find({a[i].second, a[i].first}));\r\n    }\r\n    \r\n    if(br != -1){\r\n        auto it = msy.end();\r\n        --it;\r\n        pi lo = *it;\r\n        int h = b[0].first - lo.second;\r\n        int w = lo.first;\r\n         ansy += lo.first;\r\n         //cout<<ansx<<\" \"<<ansy<<\" \"<<h<<\" \"<<w<<endl;\r\n        msx.erase(msx.find({lo.second, lo.first}));\r\n        msy.erase(msy.find({lo.first, lo.second}));\r\n        //cout<<n<<\" \"<<h<<\" \"<<w<<endl;\r\n        bool ok = valid(h,w);\r\n        //cout<<ok<<endl;\r\n        if(ok){\r\n            ans.pb({ansx,ansy});\r\n        }\r\n    }\r\n    else{\r\n        ans.pb({ansx,ansy});\r\n    }\r\n    // other case\r\n      msx.clear();\r\n        msy.clear();\r\n    rep(i,0,n){\r\n \r\n        msx.insert({b[i].first,b[i].second});\r\n        msy.insert({b[i].second,b[i].first});\r\n       \r\n    }\r\n    sort(b.rbegin(),b.rend());\r\n\r\n    ansx = b[0].first;\r\n    ansy = 0;\r\n    br = -1;\r\n    rep(i,0,n){\r\n        if(b[i].first != b[0].first){\r\n            br = i;\r\n            break;\r\n        }\r\n        ansy += b[i].second;\r\n        msx.erase(msx.find({b[i].first, b[i].second}));\r\n        msy.erase(msy.find({b[i].second, b[i].first}));\r\n    }\r\n\r\n    if(br != -1){\r\n        auto it = msy.end();\r\n        --it;\r\n        pi lo = *it;\r\n        int h = b[0].first - lo.second;\r\n        int w = lo.first;\r\n         ansy += lo.first;\r\n         //cout<<ansx<<\" \"<<ansy<<\" \"<<h<<\" \"<<w<<endl;\r\n        msx.erase(msx.find({lo.second, lo.first}));\r\n        msy.erase(msy.find({lo.first, lo.second}));\r\n        //cout<<n<<\" \"<<h<<\" \"<<w<<endl;\r\n        bool ok = valid(h,w);\r\n        //cout<<ok<<endl;\r\n        if(ok){\r\n            ans.pb({ansy,ansx});\r\n        }\r\n    }\r\n    else{\r\n        ans.pb({ansy,ansx});\r\n    }\r\n    set <pi> st;\r\n    rep(i,0,ans.size()){\r\n        st.insert({ans[i].first,ans[i].second});\r\n        \r\n    }\r\n    cout<<st.size()<<endl;\r\n    for(auto it = st.begin();it != st.end();++it){\r\n        pi lohs = *it;\r\n        cout<<lohs.first<<\" \"<<lohs.second<<endl;\r\n    }\r\n  \r\n}   \r\n\r\n\r\n\r\nint main(){\r\n\tauto begin = std::chrono::high_resolution_clock::now();\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    int t;\r\n    cin>>t;\r\n    \r\n    while(t--){\r\n        solve();\r\n    }\r\n  \r\n    \r\n\t\t\r\n \r\n    \r\n\tauto end = std::chrono::high_resolution_clock::now();\r\n    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);\r\n   cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\";\r\n\treturn 0;\r\n}   "
}