{
    "id": 202450381,
    "contestId": 1819,
    "creationTimeSeconds": 1681716406,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1819,
        "index": "B",
        "name": "The Butcher",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1900,
        "tags": [
            "geometry",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1819,
        "members": [
            {
                "handle": "MeowMcgrath"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1681549500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 140,
    "memoryConsumedBytes": 4710400,
    "source": "#include\"bits/stdc++.h\"\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nusing namespace std; \r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ins insert\r\n#define all(x) x.begin(),x.end()\r\n#define rall(x) x.rbegin(),x.rend()\r\n#define rep(i,a,b) for(int i=a;i<=b;i++)\r\n#define repr(i,a,b) for(int i=a;i>=b;i--)\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#ifndef ONLINE_JUDGE\r\n#define _getchar_nolock getchar_unlocked\r\n#define pc putchar_unlocked\r\n#else \r\n#define pc _putchar_nolock\r\n#endif\r\n#define mp make_pair\r\n#define gl getline\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ob pop_back\r\n#define sz(x) ((int)(x.size()))\r\n#define UM unordered_map\r\n#define US unordered_set\r\n#define X first\r\n#define Y second\r\n#define whole(x) x.begin(), x.end()\r\n#define F1 Flusher(); pc(' ');\r\n#define F2 Flusher(); pc('\\n');\r\n#define pii pair<int,int>\r\n#define fir first\r\n#define sec second\r\n#define popcount __builtin_popcountll \r\n#define table gp_hash_table\r\n#pragma GCC target (\"avx2\")\r\n#pragma GCC optimization (\"O3\")\r\n#pragma GCC optimization (\"unroll-loops\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\nusing ll=long long int;\r\nusing ld=long double;\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define bit(x,j) (((ll)x>>j)&1)\r\n#define um unordered_map \r\n#define mem(a,val) memset(a,val,sizeof(a))\r\ntemplate<typename T> using pq = priority_queue<T>;\r\ntemplate<class T> using min_pq=priority_queue<T, vector<T>, greater<T>>;\r\ntemplate<typename T> using matrix = vector<vector<T> >;\r\ntemplate<typename T> using rubik = vector<vector<vector<T> > >;\r\ntemplate<typename T> using ordered_set=tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>; \r\ntemplate<typename T> using ordered_multiset = tree<T, null_type,less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;\r\nvoid __print(int x) {cerr << x;} \r\nvoid __print(long x) {cerr << x;}\r\nvoid __print(long long x) {cerr << x;}\r\nvoid __print(unsigned x) {cerr << x;}\r\nvoid __print(unsigned long x){cerr << x;}\r\nvoid __print(unsigned long long x) {cerr << x;}\r\nvoid __print(float x) {cerr << x;} \r\nvoid __print(double x) {cerr << x;}\r\nvoid __print(long double x){cerr << x;} \r\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\r\nvoid __print(const char *x){cerr<<'\\\"'<<x<<'\\\"';}\r\nvoid __print(const string &x) {cerr<<'\\\"'<<x<<'\\\"';}\r\nvoid __print(bool x){cerr<<(x?\"true\":\"false\");}\r\ntemplate<typename T, typename V>\r\nvoid __print(const pair<T, V> &x){cerr<<'{'; __print(x.first);cerr<<','; __print(x.second); cerr << '}';}\r\ntemplate<typename T>\r\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\r\nvoid _print() {cerr << \"]\\n\";}\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\r\ntemplate <typename A, typename B, typename C>\r\nstring to_string(tuple<A, B, C> p) \r\n{ return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}\r\ntemplate <typename A, typename B, typename C, typename D>\r\nstring to_string(tuple<A, B, C, D> p) \r\n{ return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\"; } \r\nvoid debug_out() { cerr << endl; } \r\ntemplate <typename Head, typename... Tail>\r\nvoid debug_out(Head H, Tail... T) \r\n{\r\n  cerr << \" \" << to_string(H);\r\n  debug_out(T...);\r\n}\r\n#ifndef ONLINE_JUDGE \r\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\r\n#else\r\n#define debug(x...)\r\n#endif\r\n#ifndef ONLINE_JUDGE \r\n#define debugt(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\r\n#else\r\n#define debugt(...) 42\r\n#endif\r\ntemplate<typename T> int SIZE(T (&t)){ return t.size(); }\r\ntemplate<typename T, size_t N> int SIZE(T (&t)[N]){ return N; }\r\nstring to_string(char t){ return \"'\" + string({t}) + \"'\"; }\r\nstring to_string(bool t){ return t ? \"true\" : \"false\"; }\r\nstring to_string(const string &t, int x1=0, int x2=1e9){\r\n    string ret = \"\";\r\n    for(int i = min(x1,SIZE(t)), _i = min(x2,SIZE(t)-1); i <= _i; ++i){ ret += t[i]; }\r\n    return '\"' + ret + '\"'; }\r\nstring to_string(const char* t){ string ret(t); return to_string(ret); }\r\n\r\ntemplate<size_t N>\r\nstring to_string(const bitset<N> &t, int x1=0, int x2=1e9){\r\n    string ret = \"\";\r\n    for(int i = min(x1,SIZE(t)); i <= min(x2,SIZE(t)-1); ++i){ ret+=t[i]+'0'; }\r\n    return to_string(ret); }\r\ntemplate<typename T, typename... Coords>\r\nstring to_string(const T (&t), int x1=0, int x2=1e9, Coords... C);\r\ntemplate<typename T, typename S>\r\nstring to_string(const pair<T, S> &t){\r\n    return \"(\" + to_string(t.first) + \", \" + to_string(t.second) + \")\"; }\r\ntemplate<typename T, typename... Coords>\r\nstring to_string(const T (&t), int x1, int x2, Coords... C){\r\n    string ret = \"[\"; x1=min(x1, SIZE(t));\r\n    auto e = begin(t);\r\n    advance(e,x1);\r\n    for(int i = x1, _i = min(x2,SIZE(t)-1); i <= _i; ++i){\r\n        ret += to_string(*e, C...) + (i != _i ? \", \" : \"\");\r\n        e = next(e);\r\n    }\r\n    return ret + \"]\";\r\n}\r\n\r\ntemplate<int Index, typename... Ts>\r\nstruct print_tuple{\r\n    string operator() (const tuple<Ts...>& t) {\r\n        string ret = print_tuple<Index - 1, Ts...>{}(t);\r\n        ret += (Index ? \", \" : \"\");\r\n        return ret + to_string(get<Index>(t));\r\n    }\r\n};\r\n\r\ntemplate<typename... Ts>\r\nstruct print_tuple<0, Ts...> {\r\n    string operator() (const tuple<Ts...>& t) {\r\n        return to_string(get<0>(t));\r\n    }\r\n};\r\n\r\ntemplate<typename... Ts>\r\nstring to_string(const tuple<Ts...>& t) {\r\n    const auto Size = tuple_size<tuple<Ts...>>::value;\r\n    return print_tuple<Size - 1, Ts...>{}(t);\r\n}\r\n\r\nvoid dbgr(){;}\r\ntemplate<typename Heads, typename... Tails>\r\nvoid dbgr(Heads H, Tails... T){\r\n    cout << to_string(H) << \" | \";\r\n    dbgr(T...);\r\n}\r\n\r\nvoid dbgs(){;}\r\ntemplate<typename Heads, typename... Tails>\r\nvoid dbgs(Heads H, Tails... T){\r\n    cout << H << \" \";\r\n    dbgs(T...);\r\n}\r\n#define dbgv(...) cout << to_string(__VA_ARGS__) << endl;\r\n#define dbg(...) cout << \"[\" << #__VA_ARGS__ << \"]: \"; dbgv(__VA_ARGS__);\r\n#define dbgr(...) dbgr(__VA_ARGS__); cout << endl;\r\n#define dbgm(...) cout << \"[\" << #__VA_ARGS__ << \"]: \"; dbgr(__VA_ARGS__);\r\nnamespace FastIO {\r\nstruct Reader {\r\nprivate: FILE* file; std::vector<char> buffer; int pos; bool was;\r\nvoid read(){ if(!buffer.empty()) {buffer.resize(fread(&buffer[0],1,(int)buffer.size(),file));pos=0;}}\r\npublic:\r\nReader(FILE* file_=stdin,const int size_=1<<16):file(file_),buffer(size_,'\\0'),pos(size_),was(true){ }\r\noperator bool() const {return was;}\r\nchar getChar(){ if(pos==(int)buffer.size()) { read();}\r\nif(pos==(int)buffer.size()) { was=false; return EOF; } \r\nelse{ was=true; return buffer[pos++]; } }\r\nstring getStr() {char c=' '; while(std::isspace(c)){ c=getChar(); }\r\nstring answ; while(c!=EOF&&!std::isspace(c)){answ.push_back(c); c= getChar();}\r\nwas=!answ.empty(); return answ; }\r\nstring getLine() { char c='\\n'; string answ; \r\nwhile(c=='\\n'){c=getChar();} \r\nwhile(c!='\\n'&& c!=EOF){ answ.push_back(c);c=getChar(); }\r\nwas=!answ.empty(); return answ; }\r\ntemplate<typename T> T getInt(){char c='?'; \r\nwhile(!(c=='-'||('0'<=c&&c<='9')||c==EOF)){c=getChar();} bool positive=true; \r\nif(c=='-'){ positive=false; c=getChar(); } T answ(0); bool flag=false;\r\nwhile('0'<=c && c<='9'){ flag=true;(answ*=10)+=(c-'0'); c= getChar(); }\r\nwas=flag; return positive?answ:-answ;}\r\ntemplate<typename T> T getReal(){ bool flag=false; char c='?';\r\nwhile(!(c=='-'||('0'<=c&&c<='9')||c==EOF)){ c=getChar(); }\r\nbool positive=(c!='-'); if(c=='-'){ c=getChar(); } ll first=0;\r\nwhile('0'<=c&&c<='9'){ flag=true; (first*=10)+=(c-'0'); c= getChar(); }\r\nwas=flag; if(c!='.'){ return T(positive?first:-first); }\r\nc=getChar(); ll second=0,pow=1;\r\nwhile('0'<=c&&c<='9') { (second*=10)+=(c-'0'); c=getChar(); pow*=10; }\r\nT answ=first+(T)second/(T)pow; return positive?answ:-answ; }    \r\n};\r\nReader& operator>>(Reader& reader, char& c) { return c = reader.getChar(), reader; }\r\nReader& operator>>(Reader& reader, std::string& s) { return s = reader.getStr(), reader; }\r\ntemplate<class T> typename std::enable_if<std::is_floating_point<T>::value, Reader&>::type\r\noperator>>(Reader& reader, T& t) { return t = reader.getReal<T>(), reader; }\r\ntemplate<class T> typename std::enable_if<std::is_integral<T>::value, Reader&>::type\r\noperator>>(Reader& reader, T& t) { return t = reader.getInt<T>(), reader; }\r\ntemplate<class T> Reader& operator>>(Reader& reader, std::vector<T>& vec) {\r\nfor (auto &it : vec) { reader >> it; } return reader; }\r\nstruct Writer {\r\nprivate: FILE* file; std::vector<char> buffer; int pos,defaultPrecision,defaultWidth; char defaultFill;\r\npublic: Writer(FILE* file_ = stdout, const int size_ = 1 << 16) \r\n: file(file_), buffer(size_, '\\0'), pos(0), defaultPrecision(6), defaultWidth(0), defaultFill(' ') { }\r\n~Writer() { flush(); }\r\nvoid flush() { putChar(EOF); }\r\nvoid setprecision(int precision) { defaultPrecision = precision; }\r\nvoid setw(int width) { defaultWidth = width; }\r\nvoid setfill(char fill) { defaultFill = fill; }\r\nint getPrecision() const { return defaultPrecision; }\r\nint getWidth() const { return defaultWidth; }\r\nchar getFill() const { return defaultFill; }\r\nvoid putChar(char c) { if(pos==(int)buffer.size()||c==EOF){fwrite(&buffer[0],1,pos,file);pos=0;}\r\nif(c!=EOF){ buffer[pos++]=c; } } void putStr(const std::string& s) { for (auto it : s) putChar(it); }\r\ntemplate<typename T> void putInt(T value, int width = 0, char fill = ' ') {\r\nbool positive=!(value<0); if(value<0) { value=-value; } char buf[24]; int p=0;\r\ndo {buf[p++]=char(value % 10 + '0'); value /= 10; } while(value>0);\r\nif(!positive){buf[p++]='-';} while(p<width) buf[p++]=fill; \r\nwhile(p>0)putChar(buf[--p]); }\r\ntemplate<typename T> void putReal(T value,int precision=6,int width=0,char fill=' ') {\r\nputInt((long long)value,width-precision-1,fill); value=std::abs(value-(long long)value);\r\nif (precision==0){ return; } putChar('.');\r\n#define PRINT_PART(cnt, pow) while(precision>=cnt){value*=pow; putInt((int)value,cnt,'0'); value-=(int)value; precision-=cnt; }\r\nPRINT_PART(6,1000000) PRINT_PART(3,1000) PRINT_PART(1,10) \r\n#undef PRINT_PART \r\n} };\r\nWriter& operator<<(Writer& writer, const char c) { return writer.putChar(c), writer; }\r\nWriter& operator<<(Writer& writer, const std::string& s) { return writer.putStr(s), writer; }\r\ntemplate<class T> typename std::enable_if<std::is_floating_point<T>::value, Writer&>::type\r\noperator<<(Writer& writer, const T& t){writer.putReal(t,writer.getPrecision(),writer.getWidth(),writer.getFill());\r\nreturn writer; }\r\ntemplate<class T> typename std::enable_if<std::is_integral<T>::value, Writer&>::type\r\noperator<<(Writer& writer, const T& t){writer.putInt(t,writer.getWidth(),writer.getFill());\r\nreturn writer; } }\r\ntemplate<typename V>\r\ninline void rd(V &x) { char c; while(c=_getchar_nolock(),c<=' '); bool sign(c=='-');\r\nif(sign){ c=_getchar_nolock(); } x=(c-'0');\r\nwhile(c=_getchar_nolock(),!((c<'0')|(c>'9'))) {x=10*x+c-'0';} if(sign) x=-x; }\r\ntemplate<typename H,typename... T>\r\nvoid rd(H& h, T&... t) { rd(h); rd(t...); }\r\nstatic const int buf_len=(1<<14); static const int buf_max=(1<<04);\r\nstatic char buf_out[buf_len]; static char buf_num[buf_max];\r\nstatic int buf_pos = 0;\r\ntemplate <typename T>\r\ninline void writeChar(T x){ if(buf_pos==buf_len)fwrite(buf_out,1,buf_len,stdout),buf_pos=0;\r\nbuf_out[buf_pos++]=x; }\r\ntypedef long long ll;\r\ntypedef unsigned long long ul;\r\ntypedef long double ld;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<pii> vpii;\r\ntypedef vector<vpii> vvpii;\r\ntypedef pair<double, double> pdd;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vll;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<vvi> vvvi;\r\ntypedef vector<bool> vb;\r\ntypedef vector<vb> vvb;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<ll> vl;\r\ntypedef vector<vl> vvl;\r\ntypedef pair<bool, ll> pbl;\r\ntypedef vector<pbl> vpbl;\r\ntypedef vector<double> vd;\r\ntypedef vector<vd> vvd;\r\ntypedef vector<pdd> vpdd;\r\ntypedef vector<string> vs;\r\ntypedef pair<ul, int> pui;\r\ntypedef vector<pui> vpui;\r\ntypedef vector<ul> vu;\r\nmt19937 rng(2391);\r\nmt19937 gnr(chrono::high_resolution_clock::now().time_since_epoch().count());\r\ntemplate<typename A>\r\nistream& operator>>(istream& fin, vector<A>& v)\r\n{\r\n    for (auto it = v.begin(); it != v.end(); ++it)\r\n        fin >> *it;\r\n    return fin;\r\n}\r\ntemplate<typename A, typename B>\r\nistream& operator>>(istream& fin, pair<A, B>& p)\r\n{\r\n    fin >> p.X >> p.Y;\r\n    return fin;\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator+(const pair<A, B>& a, const pair<A, B>& b)\r\n{\r\n    return mp(a.X + b.X, a.Y + b.Y);\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator+=(pair<A, B>& a, const pair<A, B>& b)\r\n{\r\n    a.X += b.X;\r\n    a.Y += b.Y;\r\n    return a;\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator-(const pair<A, B>& a, const pair<A, B>& b)\r\n{\r\n    return mp(a.X - b.X, a.Y - b.Y);\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator-(const pair<A, B>& a)\r\n{\r\n    return mp(-a.X, -a.Y);\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B>& operator++(pair<A, B>& a)\r\n{\r\n    ++a.X;\r\n    ++a.Y;\r\n    return a;\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B>& operator--(pair<A, B>& a)\r\n{\r\n    --a.X;\r\n    --a.Y;\r\n    return a;\r\n}\r\ntemplate<typename A>\r\nvector<A>& operator++(vector<A>& a)\r\n{\r\n    for (auto it = a.begin(); it != a.end(); ++it)\r\n        ++* it;\r\n    return a;\r\n}\r\ntemplate<typename A>\r\nvector<A>& operator--(vector<A>& a)\r\n{\r\n    for (auto it = a.begin(); it != a.end(); ++it)\r\n        --* it;\r\n    return a;\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator++(pair<A, B>& a, int)\r\n{\r\n    pair<A, B> b = a;\r\n    ++a;\r\n    return b;\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator--(pair<A, B>& a, int)\r\n{\r\n    pair<A, B> b = a;\r\n    --a;\r\n    return b;\r\n}\r\ntemplate<typename A>\r\nvector<A>& operator++(vector<A>& a, int)\r\n{\r\n    vector<A> b = a;\r\n    ++a;\r\n    return b;\r\n}\r\ntemplate<typename A>\r\nvector<A>& operator--(vector<A>& a, int)\r\n{\r\n    vector<A> b = a;\r\n    --a;\r\n    return b;\r\n}\r\nvvi adjlist_from_edgelist(const vpii& e, const int& n)\r\n{\r\n    vvi g(n);\r\n    for (auto it = e.begin(); it != e.end(); ++it)\r\n    {\r\n        g[it->X].pb(it->Y);\r\n        g[it->Y].pb(it->X);\r\n    }\r\n    return g;\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> operator-=(pair<A, B>& a, const pair<A, B>& b)\r\n{\r\n    a.X -= b.X;\r\n    a.Y -= b.Y;\r\n    return a;\r\n}\r\ntemplate<typename A>\r\nA operator*(const pair<A, A>& p, const pair<A, A>& q)\r\n{\r\n    return p.X * q.X + p.Y * q.Y;\r\n}\r\ntemplate<typename A>\r\npair<A, A> operator*(const pair<A, A>& p, const A& q)\r\n{\r\n    return mp(p.X * q, p.Y * q);\r\n}\r\ntemplate<typename A>\r\nA operator%(const pair<A, A>& p, const pair<A, A>& q)\r\n{\r\n    return p.X * q.Y - p.Y * q.X;\r\n}\r\ntemplate<typename A>\r\nA sq_len(const pair<A, A>& p)\r\n{\r\n    return p * p;\r\n}\r\ntemplate<typename A>\r\nA sq_dist(const pair<A, A>& p, const pair<A, A>& q)\r\n{\r\n    return sq_len(p - q);\r\n}\r\ntemplate<typename A>\r\ndouble len(const pair<A, A>& p)\r\n{\r\n    return sqrt(sq_len(p));\r\n}\r\ntemplate<typename A>\r\ndouble dist(const pair<A, A>& p, const pair<A, A>& q)\r\n{\r\n    return len(p - q);\r\n}\r\ntemplate<typename A>\r\nbool is_rhombus(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    A x = sq_dist(a, b);\r\n    A y = sq_dist(b, c);\r\n    A z = sq_dist(c, d);\r\n    A t = sq_dist(d, a);\r\n    return ((x == y) && (y == z) && (z == t));\r\n}\r\ntemplate<typename A>\r\nbool is_rectangle(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    pair<A, A> x = a - b,\r\n        y = b - c,\r\n        z = c - d,\r\n        t = d - a;\r\n    return ((x * y == 0) && (y * z == 0) && (z * t == 0) && (t * x == 0));\r\n}\r\ntemplate<typename A>\r\nbool are_parallel(const pair<A, A>& a, const pair<A, A>& b)\r\n{\r\n    return (a % b == 0);\r\n}\r\ntemplate<typename A>\r\nbool are_orthogonal(const pair<A, A>& a, const pair<A, A>& b)\r\n{\r\n    return (a * b == 0);\r\n}\r\ntemplate<typename A>\r\nbool are_codirected(const pair<A, A>& a, const pair<A, A>& b)\r\n{\r\n    return (are_parallel(a, b) && (a * b >= 0));\r\n}\r\ntemplate<typename A>\r\nbool is_parallelogram(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    return ((a - b) == (d - c));\r\n}\r\ntemplate<typename A>\r\nbool is_trapezoid(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    pair<A, A> x = a - b, z = d - c;\r\n    return are_codirected(x, z);\r\n}\r\ntemplate<typename A>\r\nbool is_convex_polygon(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    pair<A, A> x = a - b,\r\n        y = b - c,\r\n        z = c - d,\r\n        t = d - a;\r\n    A p = x % y, q = y % z, r = z % t, s = t % x;\r\n    return (((p >= 0) && (q >= 0) && (r >= 0) && (s >= 0)) ||\r\n        ((p <= 0) && (q <= 0) && (r <= 0) && (s <= 0)));\r\n}\r\n// nestrogo protiv chasovoj strelki\r\ntemplate<typename A>\r\nbool nprcs(const pair<A, A>& a, const pair<A, A>& c)\r\n{\r\n    return ((a % c) >= 0);\r\n}\r\ntemplate<typename A>\r\nbool nprcs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c)\r\n{\r\n    return nprcs(a - b, a - c);\r\n}\r\n// nestrogo po chasovoj strelke\r\ntemplate<typename A>\r\nbool npocs(const pair<A, A>& a, const pair<A, A>& c)\r\n{\r\n    return ((a % c) <= 0);\r\n}\r\ntemplate<typename A>\r\nbool npocs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c)\r\n{\r\n    return npocs(a - b, a - c);\r\n}\r\n// strogo protiv chasovoj strelki\r\ntemplate<typename A>\r\nbool prcs(const pair<A, A>& a, const pair<A, A>& c)\r\n{\r\n    return ((a % c) > 0);\r\n}\r\ntemplate<typename A>\r\nbool prcs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c)\r\n{\r\n    return prcs(a - b, a - c);\r\n}\r\n// strogo po chasovoj strelke\r\ntemplate<typename A>\r\nbool pocs(const pair<A, A>& a, const pair<A, A>& c)\r\n{\r\n    return ((a % c) < 0);\r\n}\r\ntemplate<typename A>\r\nbool pocs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c)\r\n{\r\n    return pocs(a - b, a - c);\r\n}\r\ntemplate<typename A>\r\nbool different_sides(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    pair<A, A> x = b - a;\r\n    A p = x % (c - b), q = x % (d - b);\r\n    return (((p >= 0) && (q <= 0)) ||\r\n        ((p <= 0) && (q >= 0)));\r\n}\r\ntemplate<typename A>\r\nbool sharply_different_sides(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d)\r\n{\r\n    pair<A, A> x = b - a;\r\n    A p = x % (c - b), q = x % (d - b);\r\n    return (((p > 0) && (q < 0)) ||\r\n        ((p < 0) && (q > 0)));\r\n}\r\ntemplate<typename A>\r\npair<A, A> rot_90(const pair<A, A>& p)\r\n{\r\n    return mp(-p.Y, p.X);\r\n}\r\ntemplate<typename A>\r\npair<A, A> rot_90(const pair<A, A>& p, const pair<A, A>& c)\r\n{\r\n    return c + rot_90(p - c);\r\n}\r\ntemplate<typename A>\r\nbool intersecting_segments(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d) // true if two segs on one line\r\n{\r\n    return different_sides(a, b, c, d) && different_sides(c, d, a, b);\r\n}\r\ntemplate<typename A>\r\nbool sharply_intersecting_segments(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c, const pair<A, A>& d) // true if two segs on one line\r\n{\r\n    return sharply_different_sides(a, b, c, d) && sharply_different_sides(c, d, a, b);\r\n}\r\ntemplate <typename A>\r\npair<pair<A, A>, A> line_with_normal_vector_through_point(const pair<A, A>& normal, const pair<A, A>& point)\r\n{\r\n    return mp(normal, -(normal * point));\r\n}\r\ntemplate <typename A>\r\npair<pair<A, A>, A> serper(const pair<A, A>& a, const pair<A, A>& b)\r\n{\r\n    //pdd q = (a + b) * .5;\r\n    //pdd p = b - a;\r\n    //return line_with_normal_vector_through_point(p, q);\r\n    ////////// instead of (p, -(p * q)), we take (p * 2, -(p * (q * 2))\r\n    pair<A, A> p = b - a;\r\n    return mp(p + p, -(p * (a + b)));\r\n}\r\npdd ints(const pdd& p, const double& a,\r\n    const pdd& q, const double& b)\r\n{\r\n    double D = p % q;\r\n    double E = pdd(-a, p.Y) % pdd(-b, q.Y);\r\n    double F = pdd(p.X, -a) % pdd(q.X, -b);\r\n    return pdd(E / D, F / D);\r\n}\r\npdd circumcenter(const pdd& x, const pdd& y, const pdd& z)\r\n{\r\n    auto p1 = serper(x, y),\r\n        p2 = serper(x, z);\r\n    return ints(p1.X, p1.Y, p2.X, p2.Y);\r\n}\r\ntemplate<typename A>\r\npair<pair<A, A>, A> l_th_2(const pair<A, A>& p, const pair<A, A>& q)\r\n{\r\n    return mp(mp(q.Y - p.Y, p.X - q.X), -p % q);\r\n}\r\ntemplate<typename A>\r\nvector<pdd> circle_intersection(const pair<pair<A, A>, A>& a, const pair<pair<A, A>, A>& b)\r\n{\r\n    pair<A, A> c = b.X - a.X;\r\n    A rr1 = a.Y * a.Y, rr2 = b.Y * b.Y, cc = c * c,\r\n        rrrr1 = rr1 * rr1, rrrr2 = rr2 * rr2, cccc = cc * cc,\r\n        D = 2 * (rr1 * rr2 + rr2 * cc + cc * rr1) - (rrrr1 + rrrr2 + cccc);\r\n    if (D >= 0)\r\n    {\r\n        double E = (((double)(rr1 - rr2)) / cc + 1) / 2;\r\n        pdd baza = pdd(a.X.X, a.X.Y) + pdd(c.X, c.Y) * E;\r\n        if (D)\r\n        {\r\n            double lll = sqrt((double)(D)) / (2 * cc);\r\n            pair<A, A> cr = rot_90(c);\r\n            pdd pmm = pdd(cr.X, cr.Y) * lll;\r\n            return{ baza + pmm, baza - pmm };\r\n        }\r\n        else\r\n            return vector<pdd>(1, baza);\r\n    }\r\n    else\r\n        return vector<pdd>();\r\n}\r\ntemplate<typename A, typename B>\r\npair<A, B> sopr(const pair<A, B>& p)\r\n{\r\n    return mp(p.X, -p.Y);\r\n}\r\ntemplate<typename A>\r\nbool on_segment(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c)\r\n{\r\n    return are_codirected(b - a, c - b);\r\n}\r\ntemplate<typename A>\r\npair<pair<A, A>, A> perpendicular(const pair<A, A>& line, const pair<A, A>& point)\r\n{\r\n    return line_with_normal_vector_through_point(rot_90(line), point);\r\n}\r\npdd projection(const pair<pdd, double>& line, const pdd& point)\r\n{\r\n    pair<pdd, double> temp = perpendicular(line.X, point);\r\n    return ints(line.X, line.Y, temp.X, temp.Y);\r\n}\r\npdd height(const pdd& a, const pdd& b, const pdd& c)\r\n{\r\n    return projection(l_th_2(a, c), b);\r\n}\r\npdd unitvector(const pdd& a)\r\n{\r\n    return a * (1 / len(a));\r\n}\r\ntemplate<typename T>\r\nvi z_function(const vector<T>& s)\r\n{\r\n    int n = sz(s);\r\n    vi z(n);\r\n    int l = 0, r = 1;\r\n    for (int i = 1; i < n; ++i)\r\n    {\r\n        z[i] = max(0, min(r - i, z[i - l]));\r\n        while (i + z[i] < n && (s[i + z[i]] == s[z[i]]))\r\n            ++z[i];\r\n        if (r < i + z[i])\r\n        {\r\n            l = i;\r\n            r = i + z[i];\r\n        }\r\n    }\r\n    return z;\r\n}\r\npii euc(const int& m, const int& n)\r\n{\r\n    if (n == 0)\r\n        return pii((m >= 0) ? 1 : -1, 0);\r\n    int t = m / n;\r\n    pii ans1 = euc(n, m - t * n);\r\n    return pii(ans1.Y, ans1.X - ans1.Y * t);\r\n}\r\nint prod(const int& a, const int& b, const int& M)\r\n{\r\n    return ((ll)(a)) * b % M;\r\n}\r\nint sum(const int& a, const int& b, const int& M)\r\n{\r\n    int c = a + b;\r\n    return c >= M ? c - M : c;\r\n}\r\nint raz(const int& a, const int& b, const int& M)\r\n{\r\n    int c = a - b;\r\n    return c < 0 ? c + M : c;\r\n}\r\nconst int LITTLE_BORDER = 400;\r\nstruct factorizator\r\n{\r\n    int N;\r\n    vi pr;\r\n    vi md;\r\n    vi pw;\r\n    vi without_md;\r\n    factorizator(const int& n) : N(n), md(n), pw(n), without_md(n, 1)\r\n    {\r\n        for (int i = 2; i < N; ++i)\r\n            md[i] = i;\r\n        for (int i = 2; i < N; ++i)\r\n        {\r\n            if (md[i] == i)\r\n                pr.pb(i);\r\n            bool worth = true;\r\n            for (int j = 0; worth && (j < sz(pr)) && (pr[j] <= md[i]); ++j)\r\n            {\r\n                ll temp = ((ll)(pr[j])) * i;\r\n                if (temp < N)\r\n                    md[((int)temp)] = pr[j];\r\n                else\r\n                    worth = false;\r\n            }\r\n        }\r\n        for (int i = 2; i < N; ++i)\r\n        {\r\n            int t = md[i], s = i / t;\r\n            if (md[s] == t)\r\n            {\r\n                pw[i] = 1 + pw[s];\r\n                without_md[i] = without_md[s];\r\n            }\r\n            else\r\n            {\r\n                pw[i] = 1;\r\n                without_md[i] = s;\r\n            }\r\n        }\r\n    }\r\n    void known_factorization(int n, vpui& v)\r\n    {\r\n        while (n > 1)\r\n        {\r\n            v.eb(md[n], pw[n]);\r\n            n = without_md[n];\r\n        }\r\n    }\r\n    vpui pollardRho(const ul& n);\r\n    vpui factor(ul n);\r\n    template<typename T>\r\n    vector<pair<T, int>> merge(const vector<pair<T, int>>& p1, const vector<pair<T, int>>& p2)\r\n    {\r\n        vector<pair<T, int>> ans;\r\n        int m = sz(p1);\r\n        int n = sz(p2);\r\n        int i = 0; int j = 0;\r\n        while ((i < m) || (j < n))\r\n        {\r\n            if (i < m)\r\n            {\r\n                if (j < n)\r\n                {\r\n                    if (p1[i].X < p2[j].X)\r\n                        ans.pb(p1[i++]);\r\n                    else if (p1[i].X > p2[j].X)\r\n                        ans.pb(p2[j++]);\r\n                    else\r\n                    {\r\n                        ans.eb(p1[i].X, p1[i].Y + p2[j].Y);\r\n                        ++i; ++j;\r\n                    }\r\n                }\r\n                else\r\n                    ans.pb(p1[i++]);\r\n            }\r\n            else\r\n                ans.pb(p2[j++]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n#ifdef BIG_FACTORIZATOR\r\nfactorizator fac(2000000);\r\n#else\r\nfactorizator fac(LITTLE_BORDER);\r\n#endif\r\nul experimental_prodll(const ul& a, const ul& b, const ul& M, const int& helper)\r\n{\r\n    if (M == 0)\r\n        return 0;\r\n    ul q = ((ld)a) * b / M;\r\n    ul a1 = a * b - q * M;\r\n    ul a2 = a1;\r\n    int rm = M % helper;\r\n    int ra = a % helper;\r\n    int rb = b % helper;\r\n    int rq = q % helper;\r\n    int r1 = raz(prod(ra, rb, helper), prod(rq, rm, helper), helper);\r\n    int r2 = r1;\r\n    while (true)\r\n    {\r\n        if (a1 % helper == r1 && a1 < M)\r\n            return a1;\r\n        a1 -= M;\r\n        r1 = raz(r1, rm, helper);\r\n\r\n        a2 += M;\r\n        r2 = sum(r2, rm, helper);\r\n        if (a2 % helper == r2 && a2 < M)\r\n            return a2;\r\n    }\r\n}\r\ninline int find_helper(const ul& M)\r\n{\r\n    int i = 30;\r\n    while (M % fac.pr[i] == 0)\r\n        ++i;\r\n    return fac.pr[i];\r\n}\r\nul prodll(const ul& a, const ul& b, const ul& M)\r\n{\r\n    if (M == 0)\r\n        return 0;\r\n    ul helper = find_helper(M);\r\n    return experimental_prodll(a, b, M, helper);\r\n}\r\nul sumll(const ul& a, const ul& b, const ul& M)\r\n{\r\n    if (a < M - b)\r\n        return a + b;\r\n    else\r\n        return a + b - M;\r\n}\r\nul razll(const ul& a, const ul& b, const ul& M)\r\n{\r\n    if (a >= b)\r\n        return a - b;\r\n    else\r\n        return a + M - b;\r\n}\r\ntemplate<typename T>\r\nT diff(const T& a, const T& b) {\r\n    return (a > b) ? (a - b) : (b - a);\r\n}\r\n// comparator of {angle, distance}\r\ntemplate<typename A>\r\nbool angdis_cmp(const pair<A, A>& a, const pair<A, A>& b)\r\n{\r\n    A p;\r\n    if (p = a % b)\r\n        return (p > 0);\r\n    else\r\n        return sq_len(a) < sq_len(b);\r\n}\r\ntemplate<typename T>\r\nint find_min_idx(const vector<T>& v)\r\n{\r\n    int ans = 0, n = sz(v);\r\n    for (int i = 1; i < n; ++i)\r\n        if (v[i] < v[ans])\r\n            ans = i;\r\n    return ans;\r\n}\r\n// indices of convex hull vertices in counterclockwise order, starting from the bottom of leftmost\r\ntemplate<typename T>\r\nvi convex_hull(vector<pair<T, T>>& a)\r\n{\r\n    int n = sz(a);\r\n    if (n)\r\n    {\r\n        int mt = find_min_idx(a);\r\n        pair<T, T> d = a[mt];\r\n        for (int i = 0; i < n; ++i)\r\n            a[i] -= d;\r\n\r\n        vi idx(n);\r\n        for (int i = 0; i < n; ++i)\r\n            idx[i] = i;\r\n        sort(idx.begin(), idx.end(), [&](const int& l, const int& r) {return angdis_cmp(a[l], a[r]); });\r\n\r\n        vi h(1, idx.front());\r\n        for (auto it = idx.begin() + 1; it != idx.end(); ++it)\r\n        {\r\n            auto temp = a.begin() + *it;\r\n            if (sz(h) >= 2)\r\n            {\r\n                if (are_parallel(a[h.back()], *temp))\r\n                    h.pop_back();\r\n                while ((sz(h) >= 3) && npocs(a[h[sz(h) - 2]], a[h.back()], *temp))\r\n                    h.pop_back();\r\n            }\r\n            h.push_back(*it);\r\n        }\r\n\r\n        for (int i = 0; i < n; ++i)\r\n            a[i] += d;\r\n        return h;\r\n    }\r\n    else\r\n        return vi();\r\n}\r\npii cool_gcd(const int& a, const int& b)\r\n{\r\n    if (b)\r\n    {\r\n        int c = a / b;\r\n        pii ans1 = cool_gcd(b, a - b * c);\r\n        return pll(ans1.Y, ans1.X - ans1.Y * c);\r\n    }\r\n    else\r\n        return pii(1, 0);\r\n}\r\npll cool_gcdll(const ll& a, const ll& b)\r\n{\r\n    if (b)\r\n    {\r\n        ll c = a / b;\r\n        pll ans1 = cool_gcdll(b, a - b * c);\r\n        return pll(ans1.Y, ans1.X - ans1.Y * c);\r\n    }\r\n    else\r\n        return pll(1ll, 0ll);\r\n}\r\ntemplate<typename T>\r\nT gcd(T a, T b)\r\n{\r\n    while (b)\r\n    {\r\n        a %= b;\r\n        swap(a, b);\r\n    }\r\n    return a;\r\n}\r\n// everything is not larger that 1e12\r\nll pr_p(const ll& a, const ll& b, const ll& p)\r\n{\r\n    if (b < 1000000)\r\n        return (a * b) % p;\r\n    ll temp = pr_p(a, b >> 1ll, p);\r\n    temp = sumll(temp, temp, p);\r\n    if (b & 1ll)\r\n        return sumll(temp, a, p);\r\n    else\r\n        return temp;\r\n}\r\nll po_p(const ll& a, const ll& b, const ll& p)\r\n{\r\n    if (b < 2)\r\n    {\r\n        if (b == 0)\r\n            return 1;\r\n        else\r\n            return a;\r\n    }\r\n    ll temp = po_p(a, b >> 1ll, p);\r\n    temp = pr_p(temp, temp, p);\r\n    if (b & 1ll)\r\n        return pr_p(temp, a, p);\r\n    else\r\n        return temp;\r\n}\r\nint pow_mod(const int& a, const int& b, const int& p)\r\n{\r\n    if (b < 2)\r\n    {\r\n        if (b == 0)\r\n            return 1;\r\n        else\r\n            return a;\r\n    }\r\n    int temp = pow_mod(a, b >> 1, p);\r\n    temp = prod(temp, temp, p);\r\n    if (b & 1)\r\n        return prod(temp, a, p);\r\n    else\r\n        return temp;\r\n}\r\nll pow_modll(const ll& a, const ll& b, const ll& p)\r\n{\r\n    if (b < 2)\r\n    {\r\n        if (b == 0)\r\n            return 1;\r\n        else\r\n            return a;\r\n    }\r\n    ll temp = pow_modll(a, b >> 1ll, p);\r\n    temp = prodll(temp, temp, p);\r\n    if (b & 1ll)\r\n        return prodll(temp, a, p);\r\n    else\r\n        return temp;\r\n}\r\nint inverse(int a, int n)\r\n{\r\n    int c = cool_gcd(a, n).X;\r\n    if (c < 0)\r\n        c += n;\r\n    return c;\r\n}\r\nll inversell(ll a, ll n)\r\n{\r\n    ll c = cool_gcdll(a, n).X;\r\n    if (c < 0)\r\n        c += n;\r\n    return c;\r\n}\r\ntemplate<typename A>\r\npii equal_elements(const vector<A>& u, const vector<A>& v)\r\n{\r\n    pii ans(INT_MAX, INT_MAX);\r\n    int m = sz(u), n = sz(v);\r\n    vi id_u(m);\r\n    for (int i = 1; i < m; ++i)\r\n        id_u[i] = i;\r\n    vi id_v(n);\r\n    for (int i = 1; i < n; ++i)\r\n        id_v[i] = i;\r\n    sort(id_u.begin(), id_u.end(), [&](const int& x, const int& y) {return u[x] < u[y]; });\r\n    sort(id_v.begin(), id_v.end(), [&](const int& x, const int& y) {return v[x] < v[y]; });\r\n    int i = 0; int j = 0;\r\n    while ((i < m) && (j < n))\r\n    {\r\n        if (u[id_u[i]] < v[id_v[j]])\r\n            ++i;\r\n        else if (v[id_v[j]] < u[id_u[i]])\r\n            ++j;\r\n        else\r\n        {\r\n            ans = min(ans, pii(id_v[j], id_u[i]));\r\n            ++j;\r\n        }\r\n    }\r\n    if (ans.X == INT_MAX)\r\n        return pii(-1, -1);\r\n    else\r\n        return pii(ans.Y, ans.X);\r\n}\r\nll discr_log(ll a, ll b, ll n)\r\n{\r\n    int k = ((int)(sqrt((long double)n)));\r\n    ll a1 = inversell(a, n);\r\n    int l = k + 20;\r\n    ll a2 = po_p(a1, k, n);\r\n    vl seq1(k), seq2(l);\r\n    seq1.front() = 1;\r\n    for (int i = 1; i < k; ++i)\r\n        seq1[i] = pr_p(seq1[i - 1], a, n);\r\n    seq2.front() = b;\r\n    for (int i = 1; i < l; ++i)\r\n        seq2[i] = pr_p(seq2[i - 1], a2, n);\r\n    pll e = equal_elements(seq1, seq2);\r\n    if (e.X == -1)\r\n        return -1;\r\n    else\r\n        return e.X + e.Y * k;\r\n}\r\nll common_discr_log(ll a, ll b, ll n)\r\n{\r\n    const int C = 70;\r\n    a %= n;\r\n    b %= n;\r\n    if (gcd(n, a) != 1)\r\n    {\r\n        for (int i = 0; i < C; ++i)\r\n        {\r\n            if (po_p(a, i, n) == b)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        ll multp = po_p(a, C, n);\r\n        ll g = gcd(multp, n);\r\n        if (b % g)\r\n        {\r\n            return -1;\r\n        }\r\n        else\r\n        {\r\n            b /= g;\r\n            n /= g;\r\n            multp /= g;\r\n            ll ob = inversell(multp, n);\r\n            b = pr_p(b, ob, n);\r\n            ll ans = discr_log(a, b, n);\r\n            if (ans == -1)\r\n                return -1;\r\n            else\r\n                return ans + C;\r\n        }\r\n    }\r\n    else\r\n        return discr_log(a, b, n);\r\n}\r\nconst ul minimum_composites[] =\r\n{\r\n    1ull,\r\n    2046ull,\r\n    1373652ull,\r\n    25326000ull,\r\n    3215031750ull,\r\n    2152302898746ull,\r\n    3474749660382ull,\r\n    341550071728320ull,\r\n    341550071728320ull,\r\n    3825123056546413050ull,\r\n    3825123056546413050ull,\r\n    18446744073709551615ull\r\n};\r\nconst int little_primes[] =\r\n{\r\n    2,\r\n    3,\r\n    5,\r\n    7,\r\n    11,\r\n    13,\r\n    17,\r\n    19,\r\n    23,\r\n    29,\r\n    31,\r\n    37\r\n};\r\nbool miller_rabin_check(const ul& n, const ul& prime, const ul& odd, const ul& pot, const ul& nmo)\r\n{\r\n    long long x = pow_modll(prime, odd, n);\r\n    if ((x == nmo) || (x == 1))\r\n        return true;\r\n    for (int i = 1; i < pot; ++i)\r\n    {\r\n        x = prodll(x, x, n);\r\n        if (x == nmo)\r\n            return true;\r\n        if (x == 1)\r\n            return false;\r\n    }\r\n    return false;\r\n}\r\nbool is_prime(const ul& n)\r\n{\r\n    if (n <= 2)\r\n        return (n == 2);\r\n    ul odd, pot, nmo;\r\n    nmo = n - 1;\r\n    odd = nmo;\r\n    pot = 0;\r\n    while ((odd & 1ll) == 0)\r\n    {\r\n        odd >>= 1ll;\r\n        ++pot;\r\n    }\r\n    int i = 0;\r\n    while (n > minimum_composites[i])\r\n    {\r\n        if (miller_rabin_check(n, little_primes[i], odd, pot, nmo) == false)\r\n            return false;\r\n        ++i;\r\n    }\r\n    return true;\r\n}\r\n\r\nvpui factorizator::pollardRho(const ul& n)\r\n{\r\n    if (is_prime(n))\r\n        return vpui(1, pui(n, 1));\r\n    int step = 1;\r\n    while (true)\r\n    {\r\n        step <<= 1;\r\n        ul a = rng();\r\n        ul b = a;\r\n        ul d = 1;\r\n        for (int j = 0; j < step; ++j)\r\n        {\r\n            a = sumll(1, prodll(a, a, n), n);\r\n            b = sumll(1, prodll(b, b, n), n);\r\n            b = sumll(1, prodll(b, b, n), n);\r\n            d = gcd(diff(a, b), n);\r\n            if (d > 1) {\r\n                break;\r\n            }\r\n        }\r\n        if (1 < d && d < n)\r\n            return merge(pollardRho(d), pollardRho(n / d));\r\n    }\r\n    return vpui();\r\n}\r\nvpui factorizator::factor(ul n)\r\n{\r\n    vpui ans;\r\n    for (int i = 0; n >= N && i < sz(pr) && pr[i] < LITTLE_BORDER; ++i)\r\n        while (n % pr[i] == 0)\r\n        {\r\n            if (sz(ans) && ans.back().X == pr[i])\r\n                ++ans.back().Y;\r\n            else\r\n                ans.eb(pr[i], 1);\r\n            n /= pr[i];\r\n        }\r\n    if (n < N)\r\n    {\r\n        known_factorization(n, ans);\r\n        return ans;\r\n    }\r\n    else\r\n        return merge(ans, pollardRho(n));\r\n}\r\ntemplate<typename T>\r\nT phi(const vector<pair<T, int>>& v)\r\n{\r\n    T ans = 1;\r\n    for (int i = 0; i < sz(v); ++i)\r\n    {\r\n        ans *= v[i].X - 1;\r\n        for (int j = 1; j < v[i].Y; ++j)\r\n            ans *= v[i].X;\r\n    }\r\n    return ans;\r\n}\r\nul phi(const ul& n)\r\n{\r\n    return phi(fac.factor(n));\r\n}\r\nbool check_primitive_root(const int& ph, const vi& to_check, const int& r, const int& n)\r\n{\r\n    for (int i = 0; i < sz(to_check); ++i)\r\n        if (pow_mod(r, to_check[i], n) == 1)\r\n            return false;\r\n    return (pow_mod(r, ph, n) == 1);\r\n}\r\nint primitive_root(const int& n)\r\n{\r\n    if (n < 3)\r\n        return n - 1;\r\n    int p = phi(n);\r\n    vpui f = fac.factor(p);\r\n    vi to_check(sz(f));\r\n    for (int i = 0; i < sz(f); ++i)\r\n        to_check[i] = p / f[i].X;\r\n    for (int i = 2; i < n; ++i)\r\n        if (check_primitive_root(p, to_check, i, n))\r\n            return i;\r\n    return -1;\r\n}\r\nint unite_mod(const int& a, const int& p, const int& b, const int& q)\r\n{\r\n    pii c = cool_gcd(p, q);\r\n    int pr = p * q;\r\n    int ans = ((a * c.Y * q + b * c.X * p) % pr + pr) % pr;\r\n    return ans;\r\n}\r\nll unite_modll(const ll& a, const ll& p, const ll& b, const ll& q)\r\n{\r\n    pll c = cool_gcdll(p, q);\r\n    ll pr = p * q;\r\n    ll ans = ((a * c.Y * q + b * c.X * p) % pr + pr) % pr;\r\n    return ans;\r\n}\r\npii power_v(int n, const int& p)\r\n{\r\n    int ans = 0;\r\n    while (n % p == 0)\r\n    {\r\n        n /= p;\r\n        ++ans;\r\n    }\r\n    return pii(ans, n);\r\n}\r\nint square_root_prime_modulo(int c, int n, const int& pr, const int& k)\r\n{\r\n    c %= n;\r\n    if (c)\r\n    {\r\n        pii kek = power_v(c, pr);\r\n        int l = kek.X;\r\n        if (l & 1)\r\n            return -1;\r\n        if (l > 0)\r\n        {\r\n            int pwl = 1;\r\n            for (int i = 0; i < l; ++i)\r\n                pwl *= pr;\r\n            n /= pwl;\r\n            c /= pwl;\r\n            int ans1 = square_root_prime_modulo(c, n, pr, k - l);\r\n            if (ans1 == -1)\r\n                return -1;\r\n            for (int i = 0; i < (l >> 1); ++i)\r\n                ans1 *= pr;\r\n            return ans1;\r\n        }\r\n        else\r\n        {\r\n            int primitive;\r\n            if (n & 1)\r\n                primitive = primitive_root(n);\r\n            else\r\n                primitive = 5;\r\n            int u = ((int)discr_log(primitive, c, n));\r\n            if (u == -1)\r\n                return -1;\r\n            if (u & 1)\r\n                return -1;\r\n            return pow_mod(primitive, u >> 1, n);\r\n        }\r\n    }\r\n    else\r\n        return 0;\r\n}\r\nint square_root_modulo(const int& c, const int& n)\r\n{\r\n    vpui f = fac.factor(n);\r\n    int a = 0, p = 1;\r\n    for (int i = 0; i < sz(f); ++i)\r\n    {\r\n        int q = 1;\r\n        for (int j = 0; j < f[i].Y; ++j)\r\n            q *= f[i].X;\r\n        int b = square_root_prime_modulo(c, q, f[i].X, f[i].Y);\r\n        if (b == -1)\r\n            return -1;\r\n        a = unite_mod(a, p, b, q);\r\n        p *= q;\r\n    }\r\n    return a;\r\n}\r\n\r\nnamespace BGF\r\n{\r\n    inline int cntd(unsigned x)\r\n    {\r\n        int ans = 0;\r\n        while (x)\r\n        {\r\n            if (x & 1)\r\n                ++ans;\r\n            x >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n    inline ll cntdll(ul x)\r\n    {\r\n        ll ans = 0;\r\n        while (x)\r\n        {\r\n            if (x & 1)\r\n                ++ans;\r\n            x >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n    inline int clzd(unsigned x)\r\n    {\r\n        int ans = 32;\r\n        while (x)\r\n        {\r\n            --ans;\r\n            x >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n    inline ll clzdll(ul x)\r\n    {\r\n        ll ans = 64;\r\n        while (x)\r\n        {\r\n            --ans;\r\n            x >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n    inline int ctzd(unsigned x)\r\n    {\r\n        if (x == 0)\r\n            return 32;\r\n        int ans = 0;\r\n        while ((x & 1) == 0)\r\n        {\r\n            ++ans;\r\n            x >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n    inline ll ctzdll(ul x)\r\n    {\r\n        if (x == 0)\r\n            return 64;\r\n        ll ans = 0;\r\n        while ((x & 1) == 0)\r\n        {\r\n            ++ans;\r\n            x >>= 1;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n#ifdef FAST_BUILTINS\r\nnamespace BGF // builtin gnu c++ functions\r\n{\r\n    const unsigned BHC = 65535u;\r\n    const ul BHCL = 65535ull;\r\n    const unsigned BHN = 65536u;\r\n    const unsigned BHL = 16u;\r\n    const unsigned LH = 4294901760u;\r\n    const unsigned RH = 65535u;\r\n    const ul BHLL1 = 16ull;\r\n    const ul BHLL2 = 32ull;\r\n    const ul BHLL3 = 48ull;\r\n    const ul LHL = 18446744069414584320ull;\r\n    const ul RHL = 4294967295ull;\r\n    int CNT[BHN];\r\n    int CLZ[BHN];\r\n    int CTZ[BHN];\r\n    inline void initialize()\r\n    {\r\n        CNT[0] = 0;\r\n        CLZ[0] = BHL + BHL;\r\n        CTZ[0] = BHL;\r\n        for (unsigned i = 1; i < BHN; ++i)\r\n        {\r\n            CNT[i] = cntd(i);\r\n            CLZ[i] = clzd(i);\r\n            CTZ[i] = ctzd(i);\r\n        }\r\n    }\r\n    inline int cntc(const unsigned& x)\r\n    {\r\n        return CNT[x & BHC] + CNT[(x >> BHL) & BHC];\r\n    }\r\n    inline ll cntcll(const ul& x)\r\n    {\r\n        return CNT[x & BHCL] + CNT[(x >> BHLL1) & BHCL] + CNT[(x >> BHLL2) & BHCL] + CNT[(x >> BHLL3) & BHCL];\r\n    }\r\n    inline int clzc(const unsigned& x)\r\n    {\r\n        if (x & LH)\r\n            return CLZ[x >> BHL] - BHL;\r\n        else\r\n            return CLZ[x];\r\n    }\r\n    inline ll clzcll(const ul& x)\r\n    {\r\n        if (x & LHL)\r\n            return clzc(x >> BHLL2);\r\n        else\r\n            return clzc(x) + BHLL2;\r\n    }\r\n    inline int ctzc(const unsigned& x)\r\n    {\r\n        if (x & RH)\r\n            return CTZ[x & RH];\r\n        else\r\n            return CTZ[x >> BHL] + BHL;\r\n    }\r\n    inline ll ctzcll(const ul& x)\r\n    {\r\n        if (x & RHL)\r\n            return ctzc(x);\r\n        else\r\n            return ctzc(x >> BHLL2) + BHLL2;\r\n    }\r\n}\r\n#define __builtin_popcount BGF::cntc\r\n#define __builtin_popcountll BGF::cntcll\r\n#define __builtin_ctzll BGF::ctzcll\r\n#if !defined(__GNUC__)\r\n#define __builtin_ctz BGF::ctzc\r\n#define __builtin_clz BGF::clzc\r\n#define __builtin_clzll BGF::clzcll\r\n#endif\r\n#elif !defined(__GNUC__)\r\n#define __builtin_popcount BGF::cntd\r\n#define __builtin_popcountll BGF::cntdll\r\n#define __builtin_ctzll BGF::ctzdll\r\n#define __builtin_ctz BGF::ctzd\r\n#define __builtin_clz BGF::clzd\r\n#define __builtin_clzll BGF::clzdll\r\n#endif\r\n\r\n// #define FILES\r\n#define ONPC_FILES\r\nconst string INPUT_FILE = \"input.txt\";\r\nconst string OUTPUT_FILE = \"output.txt\";\r\nint sum(const int a, const int b)\r\n{\r\n    return min(1 + (int)1e9, a + b);\r\n}\r\nstruct st\r\n{\r\n    int n;\r\n    vi mn;\r\n    vi mx;\r\n    vi s;\r\n    vi p;\r\n    st(const vi& a) : n(sz(a))\r\n    {\r\n        p.resize(n * 4);\r\n        mn.resize(n * 4);\r\n        mx.resize(n * 4);\r\n        s.resize(n * 4);\r\n        construct(0, 0, n, a);\r\n    }\r\n    void construct(const int v, const int vx, const int vy, const vi& a)\r\n    {\r\n        if (vy - vx == 1)\r\n        {\r\n            mn[v] = a[vx];\r\n            mx[v] = a[vx];\r\n            s[v] = a[vx];\r\n        }\r\n        else\r\n        {\r\n            int vz = (vx + vy) / 2;\r\n            construct(v * 2 + 1, vx, vz, a);\r\n            construct(v * 2 + 2, vz, vy, a);\r\n            s[v] = sum(s[2 * v + 1], s[2 * v + 2]);\r\n            mn[v] = mn[2 * v + 2];\r\n            mx[v] = mx[2 * v + 1];\r\n        }\r\n    }\r\n    pii eat(const int v, const int vx, const int vy, const int x, int y)\r\n    {\r\n        push(v, vx, vy);\r\n        if (x >= vy || y < mn[v])\r\n            return pii(0, 0);\r\n        if (x <= vx && y >= s[v])\r\n            return pii(s[v], vy - vx);\r\n        int vz = (vx + vy) / 2;\r\n        pii e = eat(2 * v + 1, vx, vz, x, y);\r\n        y -= e.X;\r\n        e += eat(2 * v + 2, vz, vy, x, y);\r\n        return e;\r\n    }\r\n    int eat(const int x, const int y)\r\n    {\r\n        return eat(0, 0, n, x, y).Y;\r\n    }\r\n    void push(const int v, const int vx, const int vy)\r\n    {\r\n        if (p[v])\r\n        {\r\n            mn[v] = p[v];\r\n            mx[v] = p[v];\r\n            s[v] = min(1 + (ll)1e9, (ll)p[v] * (vy - vx));\r\n            if (2 * v + 2 < sz(p))\r\n            {\r\n                p[2 * v + 1] = p[v];\r\n                p[2 * v + 2] = p[v];\r\n            }\r\n            p[v] = 0;\r\n        }\r\n    }\r\n    void up(const int v, const int vx, const int vy, const int x, const int y)\r\n    {\r\n        push(v, vx, vy);\r\n        if (x <= vx || mn[v] >= y)\r\n            return;\r\n        if (x >= vy && mx[v] <= y)\r\n        {\r\n            p[v] = y;\r\n            return;\r\n        }\r\n        int vz = (vx + vy) / 2;\r\n        up(2 * v + 1, vx, vz, x, y);\r\n        up(2 * v + 2, vz, vy, x, y);\r\n        push(2 * v + 1, vx, vz);\r\n        push(2 * v + 2, vz, vy);\r\n        s[v] = sum(s[2 * v + 1], s[2 * v + 2]);\r\n        mn[v] = mn[2 * v + 2];\r\n        mx[v] = mx[2 * v + 1];\r\n    }\r\n    void up(const int x, const int y)\r\n    {\r\n        up(0, 0, n, x, y);\r\n    }\r\n};\r\n//////////////////////////////My Stuff///////////////////////////////////////////////////\r\nconstexpr ll inf=2223372036854775807;\r\nconstexpr int mod1=(1e9+7);\r\nconstexpr int mod2=(998244353);\r\nconstexpr int MAX=(1e5+3);\r\nconstexpr int MOD=1e9+7; \r\nstruct mint\r\n{\r\n  public:\r\n    int v;\r\n    mint(int _v=0):v(_v){}\r\n    explicit operator int() const {return v;}\r\n    mint& operator += (const mint& o) {if((v+=o.v)>=MOD) v-=MOD; return *this;}\r\n    mint& operator -= (const mint& o) {if((v-=o.v)<0) v+=MOD; return *this;}\r\n    mint& operator *= (const mint& o) {v=(ll)v*o.v%MOD; return *this;}\r\n    friend mint operator + (mint a, const mint& b) {return a+=b;}\r\n    friend mint operator - (mint a, const mint& b) {return a-=b;}\r\n    friend mint operator * (mint a, const mint& b) {return a*=b;}\r\n    friend mint pow(mint b, ll p)\r\n    { mint f(1); for(;p;p>>=1, b*=b) if(p&1) f*=b; return f; }\r\n};\r\ntemplate <typename L>\r\ninline void print(L x, char end=0){  if(abs(x)>1000000000000000){ cout<<x; return; }  if(x<0) writeChar('-'), x=-x; int n=0;\r\ndo buf_num[n++]=x%10+'0'; while(x/=10); while (n--) writeChar(buf_num[n]); if(end) writeChar(end);}\r\nstruct Flusher{~Flusher(){if(buf_pos)fwrite(buf_out,1,buf_pos,stdout),buf_pos=0;}}flusher;\r\ntemplate<typename H,typename... T> void print(H h, T... t) { print(h); F1; print(t...); }\r\ntemplate<typename T> void print(vector<T>v){ for(auto i:v){ print(i); F1; } }\r\ntemplate<typename T> void print(set<T>v){ for(auto i:v){ print(i); F1; } }\r\ntemplate<typename R> void input(vector<R>&a,int n){ rep(i,0,n-1) cin>>a[i]; }\r\ntemplate<typename T,typename V> T ce(T a,V b){ if(a<0) return a/b; T res;if(a%b==0)res=a/b; else res=a/b+1; return res; }\r\ntemplate<typename W,typename F> W fl(W a,F b){ if(abs(a)%abs(b)==0) return a/b; if(a<0) return a/b-1; return a/b; }\r\nll multiplym2(ll a,ll b){ ll res=0; while(b) { if(b&1) res=(res+a)%mod2; b>>=1;a=(a*2)%mod2; } return res; }\r\nll multiplym1(ll a,ll b){ ll res=0; while(b) { if(b&1) res=(res+a)%mod1; b>>=1;a=(a*2)%mod1; } return res; }\r\nll multiply(ll a,ll b){ ll res=0; while(b) { if(b&1) res+=a; b>>=1;a=(a<<1); } return res; }\r\nll powerm2(ll a,ll b){ ll res=1; while(b) { if(b&1) res=(res*a)%mod2; a=(a*a)%mod2; b>>=1; } return res; }\r\nll powerm1(ll a,ll b){ ll res=1; while(b) { if(b&1) res=(res*a)%mod1; a=(a*a)%mod1; b>>=1; } return res; }\r\nll power(ll a,ll b){ ll res=1; while(b) { if(b&1) res=(res*a); a=(a*a); b>>=1; } return res; }\r\nll fact[MAX+7];\r\nvoid facto(){ fact[0]=1; fact[1]=1; rep(i,2,MAX-1) fact[i]=(fact[i-1]*i)%mod1; }\r\nll modInv(int n){ return powerm1(n,mod1-2); }\r\nll ncr(int n,int r){ if (r==0) return 1; return (fact[n]*modInv(fact[r])%mod1*modInv(fact[n-r])%mod1)%mod1; }\r\ntemplate<typename T,typename V>\r\nint find_divisor_power(T n,V a){ T res=1; int p=-1; while(n%res==0){ p++; res*=a; } return p; }\r\ntemplate<typename T,typename V> T find_exponent(T n,V p){ T x=0; while(n){ n/=p; x+=n; } return x; }\r\ntemplate<typename L>void factorise(L a,vector<L>&f){ int limit=sqrt(a); rep(i,1,limit) { if(a%i==0) { f.push_back(i); if(i!=a/i) f.push_back(a/i); } } }\r\nvector<int>prime; \r\nvoid sieve(int limit){prime.eb(2);prime.eb(3);bool sieve[limit];for(int i=0;i<limit;i++)sieve[i]=false; \r\nfor(int x=1; x*x<limit;x++) \r\n{ \r\n    for(int y=1;y*y<limit;y++){int n=(4*x*x)+(y*y);\r\n    if(n<=limit&&(n%12==1||n%12==5)){sieve[n]^=true;}n=(3*x*x)+(y*y);if(n<=limit&&n%12==7){ sieve[n]^=true; }\r\n    n=(3*x*x)-(y*y);if(x>y&&n<=limit&&n%12==11){sieve[n]^=true;} } } \r\n    for(int r=5;r*r<limit;r++){ if(sieve[r]) { for(int i=r*r;i<limit;i+=r*r) sieve[i]=false; } } \r\n    for(int a=5;a<limit;a++) { if(sieve[a]) prime.eb(a); }\r\n} \r\nvoid dfs(int s,vector<vector<int>>v,vector<int>f)\r\n{\r\n    stack<int>q; q.push(s); while(!q.empty()){ int m=q.top(); q.pop(); f[m]=1; \r\n    for(auto i=v[m].begin();i!=v[m].end();++i){ if(!f[*i]) { q.push(*i); f[*i]=1; } } }\r\n}\r\nvoid bfs(int s,vector<vector<int>>v,vector<int>f)\r\n{\r\n    queue<int>q; q.push(s); f[s]=1; while(!q.empty()) { int m=q.front(); q.pop();\r\n    for(auto i=v[m].begin();i!=v[m].end();++i){ if(!f[*i]) { f[*i]=1; q.push(*i); } } }\r\n}\r\ntemplate<typename G>void primeFactors(G n,vector<G>&pf){if(n%2==0) pf.eb(2); while(n%2==0)n=n/2;\r\nint limit=sqrt(n);for(int i=3;i<=limit;i=i+2){ if(n%i==0) pf.eb(i); while(n%i==0) n=n/i;}if(n>2) pf.eb(n);}  \r\ntemplate<typename T> int highest_set_bit(T n){repr(i,60,0) { if(bit(n,i)) return i; } return -1; }\r\ntemplate<typename T> int lowest_set_bit(T n){rep(i,0,60) { if(bit(n,i)) return i; } return -1; }\r\nvector<int> divisor[MAX+7];void sieve(){ rep(i,1,MAX){ for(int j=i;j<=MAX;j+=i) divisor[j].eb(i); } }\r\ntemplate <typename T> bool ispowertwo (T x) { return x&&(!(x&(x-1))); }\r\ntemplate <typename T> bool isPrime(T n){ if(n<=1) return false; if(n<=3) return true; \r\nif(n%2==0||n%3==0) {return false;} for(int i=5;i*i<=n;i=i+6) if(n%i==0||n%(i+2)==0) {return false;} return true; }\r\nvoid getZarr(string str,vector<int>&Z)\r\n{\r\n    int n=str.length(),L,R,k; L=R=0;\r\n    for(int i=1;i<n;++i){ if(i>R){ L=R=i; while(R<n && str[R-L]==str[R]) R++; Z[i]=R-L; R--;}\r\n    else{ k=i-L; if(Z[k]<R-i+1) Z[i]=Z[k]; else{L=i; while(R<n && str[R-L]==str[R]) R++; Z[i]=R-L; R--;} } }\r\n}\r\nvoid zfunc(string text,string pattern,vector<int>&index)\r\n{\r\n    string concat=pattern+\"$\"+text; int l=concat.length(); vector<int>Z(l); getZarr(concat,Z);\r\n    rep(i,0,l-1){ if(Z[i]==(int)pattern.length()) index.eb(i-pattern.length()-1); }\r\n}\r\ntemplate<typename A,typename B> B largest_power_less_than(A n,B a){ A res=1; B p=-1; while(n>res){ res*=a; p++; } return p; } \r\ntemplate<typename A,typename B> B largest_power_less_or_equal_to(A n,B a){ A res=1; B p=-1; while(n>=res){ res*=a; p++; } return p; } \r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        x+=0x9e3779b97f4a7c15; x=(x^(x>>30))*0xbf58476d1ce4e5b9; x=(x^(x>>27))*0x94d049bb133111eb; return x^(x>>31);\r\n    }\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x+FIXED_RANDOM);\r\n    }\r\n};\r\nstruct HASH{\r\n  size_t operator()(const pair<int,int>&x)const{\r\n    return hash<long long>()(((long long)x.first)^(((long long)x.second)<<32));\r\n  }\r\n};\r\nstruct vectorHash {\r\n    int operator()(const vector<int> &V) const {\r\n        int hash = V.size();\r\n        for(auto &i : V) {\r\n            hash ^= i + 0x9e3779b9 + (hash << 6) + (hash >> 2);\r\n        }\r\n        return hash;\r\n    }\r\n};\r\nint spf[MAX+10];\r\nvoid spf_compute(){\r\n    for (int i = 2; i < MAX; i += 2) spf[i]=2;\r\n    for (ll i = 3;i<MAX;i+=2){\r\n        if (!spf[i]){\r\n            spf[i]=i;\r\n            for(ll j=i;(j*i)<MAX;j+=2){ spf[j*i] = i; }\r\n        }\r\n    }\r\n}\r\nvector<int>getPF(int k)\r\n{ \r\n    vector<int>ans; um<int,int,custom_hash>g; \r\n    while(k>1)\r\n    {   \r\n        if(!g[spf[k]])\r\n        ans.eb(spf[k]); g[spf[k]]=1; \r\n        k/=spf[k];\r\n    }\r\n    return ans;\r\n} \r\ntemplate<typename T>ll sumy(vector<T>&v){ ll s=0; for(auto i:v)s+=i; return s; }\r\ntemplate<typename T>T max_ele(vector<T>v){ T m=v[0]; int n=sz(v); if(n>1){ rep(i,1,n-1)m=max(m,v[i]); } return m; }\r\ntemplate<typename T>T min_ele(vector<T>v){ T m=v[0]; int n=sz(v); if(n>1){ rep(i,1,n-1)m=min(m,v[i]); } return m; }\r\ntemplate<typename T>int max_ele_ind(vector<T>v){ T m=v[0]; int ind=0,n=sz(v); if(n>1){ rep(i,1,n-1){if(m<v[i]){ m=v[i]; ind=i;} } } return ind; }\r\ntemplate<typename T>int min_ele_ind(vector<T>v){ T m=v[0]; int ind=0,n=sz(v); if(n>1){ rep(i,1,n-1){if(v[i]<m){ m=v[i]; ind=i; }} } return ind; }\r\nlong long gcd_ext(long long a, long long b,long long &xp,long long &yp) {\r\n    if(!a) { xp=0; yp=1; return b; }\r\n    long long x,y;\r\n    long long d=gcd_ext(b%a,a,x,y);\r\n    yp=x;\r\n    xp=y-(b/a)*x;\r\n    return d;\r\n}\r\nlong long revMod(long long a, long long p){\r\n    long long x, y;\r\n    gcd_ext(a,p,x,y);\r\n    if (x<0LL) return (p-((-x)%p))%p;\r\n    return x%p;\r\n}\r\nconst int dx4[4] = {1,0,-1,0}, dy4[4] = {0,1,0,-1};\r\nconst int dx8[8] = {1, 0, -1, 0, 1, 1, -1, -1}, dy8[8] = {0, 1, 0, -1, -1, 1, -1, 1};\r\nint n; multiset<pair<int,int>,greater<pair<int,int>>>s1,s2; set<pair<int,int>>s; int y; \r\nvoid cal(int i,int turn,int x,int remH,int remW)\r\n{\r\n    if(s1.empty())\r\n    {\r\n      if(remH==0 and remW==0) s.emplace(x,y); \r\n      return; \r\n    }\r\n    if(!turn) \r\n    {\r\n        auto it=*s2.begin(); s2.erase(it); s1.erase({it.second,it.first}); \r\n        \r\n    }\r\n}\r\nvoid solve()\r\n{\r\n cin>>n; vector<pair<int,int>>a(n); long long A=0; int mxW=0,mxH=0; \r\n s1.clear(); s2.clear(); s.clear(); \r\n for(int i=0;i<=n-1;i++)\r\n { \r\n    cin>>a[i].first>>a[i].second; // w x h  \r\n    A+=a[i].first*1LL*a[i].second; \r\n    mxW=max(mxW,a[i].first); \r\n    mxH=max(mxH,a[i].second); \r\n    s1.emplace(a[i].first,a[i].second); \r\n    s2.emplace(a[i].second,a[i].first); \r\n } \r\n auto temp1=s1,temp2=s2; \r\n if(A%mxW==0)\r\n { \r\n    long long H=A/mxW,W=mxW; debug(H,W); \r\n    while(true)\r\n    {\r\n        if(s1.empty())\r\n        {\r\n            s.emplace(mxW,A/mxW);\r\n            break;  \r\n        }\r\n        auto it=*s1.begin();\r\n        if(it.first==W)\r\n        {\r\n           debug(it); \r\n           H-=it.second;\r\n           debug(W,H);\r\n           s1.erase(s1.lower_bound(it)); \r\n           s2.erase(s2.lower_bound({it.second,it.first})); \r\n           continue; \r\n        }\r\n        it=*s2.begin();\r\n        if(it.first==H)\r\n        {\r\n            debug(it.second,it.first); \r\n            W-=it.second; \r\n            debug(W,H); \r\n            s1.erase(s1.lower_bound({it.second,it.first}));\r\n            s2.erase(s2.lower_bound(it)); \r\n            continue;\r\n        }\r\n        break; \r\n    }\r\n }\r\n swap(temp1,s1); swap(temp2,s2); \r\n if(A%mxH==0)\r\n {\r\n    long long W=A/mxH,H=mxH; \r\n    while(true)\r\n    {\r\n        if(s1.empty())\r\n        {\r\n            s.emplace(A/mxH,mxH);\r\n            break;  \r\n        }\r\n        auto it=*s1.begin();\r\n        if(it.first==W)\r\n        {\r\n           H-=it.second;\r\n           s1.erase(s1.lower_bound(it)); \r\n           s2.erase(s2.lower_bound({it.second,it.first})); \r\n           continue; \r\n        }\r\n        it=*s2.begin();\r\n        if(it.first==H)\r\n        {\r\n            W-=it.second; \r\n            s1.erase(s1.lower_bound({it.second,it.first}));\r\n            s2.erase(s2.lower_bound(it));\r\n            continue;\r\n        }\r\n        break;        \r\n    }\r\n }\r\n cout<<(int)s.size()<<\"\\n\"; \r\n for(auto it: s) cout<<it.first<<\" \"<<it.second<<\"\\n\"; \r\n return;  \r\n} \r\nint32_t main() \r\n{\r\n  ios_base::sync_with_stdio(false); \r\n  cin.tie(0); \r\n    #ifndef ONLINE_JUDGE\r\n    if(fopen(\"input.txt\",\"r\"))\r\n    {\r\n       freopen(\"input.txt\",\"r\",stdin);\r\n       freopen(\"output.txt\",\"w\",stdout);\r\n       cerr<<(\"///////////////////////////////////////////Error Stream//////////////////////////////////////////\")<<\"\\n\"; \r\n    }\r\n  #endif\r\n  int t=1,c=1; cin>>t; \r\n  while(t--)\r\n  { \r\n    solve(); c++; \r\n  }\r\n  return 0;\r\n}     \r\n/*\r\n===%@%=====@@@@@%**@##@@%%@%@@@@%%%%@@@@@@@@@@@@@@@@@@@@@%%%%%+*::::::::::::::::::::::::::::::::::::::::::\r\n=====%@@%=%@@@@@%*%###@@@@@@@@@@%%%@@@@@@@@@@@@@@@@@@@@@@@@%======+:::::::::::::::::::::::::::::::::::::::\r\n=======%@@@@@@@@%*@###@@@@@@@@@@%%%%%%@@@@@@@@@@@@@@@@@@@@@%%%==%===*:::::::::::::::::::::::::::::::::::::\r\n#%=======%@@@@@@==####@@@@@@@@%%%%%%%+%%@@@@@@@@@@@@@@@@@@#%%%=%=+=%=+::::::::::::::::::::::::::::::::::::\r\n+:::*======%@@@@=@####@@@@@@@%%+=%=+=%%%%@@@@@@@@@@@@@@@@@@#%%%%=%%==%*:::::::::::::::::::::::::::::::::::\r\n*::::::*=====@@@=#####@@@@@@%%%%=++%%%%%%@@@@@@@@@@@@@@@@@@@#@%%%%=%%%=:::::::::::::::::::::::::::::::::::\r\n=:::::::**======@#####@@@@@@%%%++%=++%%%@@@@@@@@@@@@@@@@@@@@@@##@%%%%%=:::::::::::::::::::::::::::::::::::\r\n%+*::::****+====#######@@@@@%=+=%%%%%%%@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%%*:::::::::::::::::::::::::::::::::\r\n%=***********+=%#######@@@@@@%%%%%%%%%##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%**::::::::::::**************:::::\r\n%%+***::::::::*=#######@@@@@@@#@@@@##@@@@@@@@@@@@@@@@@@@@%%%%%%%%%%%%%%%%%==:::::::::::*************::::::\r\n%%@%%+:::::::::%########@@@@@@@@@@@@@%%%%%%%%%%%%%%%%=====+++++++%%%%%%=+++++::::::::::**********:::::::::\r\n+=%%%%%=*:::::*@########@@@@@@@%%%%%%==++++=%%%%%%%=++++++++++++%%%+++=%%=+*+=*:::::::::::::::::::::::::::\r\n+%%@%%%%%=::::+@########@@@%%%%=+++++++++=%%%=+++=%%%%+++++++++%%=++++++=%%=+%=:::::::::::::::::::::::::::\r\n%%%%@@@%%%%*::=##########%%=+++++++++++=%%%=++++++++=%%%=++++=%%=+++++++++%%%%%=*::::::::::::::::::::::::*\r\n@@@@@@@@@%%=::%##########@%%%=+++++++=%%%=+++++++++++++=%%%==%%=+++++++=+++=%%%++*:::::::::::::::::::::::-\r\n@@@@@@@@@@@@+*@#########@%==%%%%%%=+%%%=++=====+++++===%%%%%%%%%%%%%%%%%%%%%%%%%%%=+::::::::::::::::::::--\r\n@@@@@@@@%@@@=*@#####@@#@%%%++++=%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+:::::::::::::::::::---\r\n@@@@@@@@@@@#=*@##@%%@#@%%%%%=%%%%%%%%@@@@@@@@@@@@@#########@@@@@@@@@@@@@@@@@@@@@@@@%*:::::::::::::::::----\r\n@@@@@@@@@##@+=##%%%@#@%%%@##@%%@@@@@@@###########@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%+*:::::::::*-----\r\n@@@@@@#####%++##@%@#@%%%@################@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%=+*:*:-----\r\n@#########@++=@####@@@#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%=*::\r\n#########%+++=%@##############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%=++******************************++==%%%@@@\r\n#######@++*++%@##########@@@@@@@@@@@@@@@@@@@@@@@@@@@@%=+******************++++================++++********\r\n###@@=+****+@########@@@@@@@@@@@@@@@@@@@@@@@@@@%=+***********+=%@@######################@@@@@@@@@@@@@@@@@@\r\n=++********+@####@@@@@@@@@@@@@@@@@@@@@@@@@%+**********+=@###############################@@@@@@@@@@@@@@@@@@\r\n****:::::*=@#@@@@@@@@@@@@@@@@@@@@@@@@@=*********++++++@##############@##################@@@@@@@@@@@@@@@@@@\r\n:::::::=@@@@@@@@@@@@@@@@@@@@@@@@@%=*********=@##=+++++@##############+%#################@@@@@@@@@@@@@@@@@@\r\n::::=@@@@@@@@@@@@@@@@@@@@@@@@%=********+%=++@###%=++++%@@###########@++@##@%############@@@@@@@@@@@@@@@@@@\r\n:+@@@@@@@@@@@@@@@@@@@@@@@%+*******+%@###=+++=#@%+++=%==%%###########%=+*%%=:=%%%%%@%@@##@@@@@@@@@@@@@@@%=+\r\n@@@@@@@@@@@@@@@@@@@@@=+******+=@#######%+++++@@++*****+%+@#@@@%%%%%%:---*=+-:%%%%%@%%%%%@@@@@@@@%%=:******\r\n@@@@@@@@@@@@@@@@%=******+=@###########@+++++++@+++****:***%%%%%%%%%*-----+:--+%%%%@%%%%%@@==+*::::*:******\r\n@@@@@@@@@@@@=+*****+=@################=++++++++++*::------+=%%%%%==*::---:---:=%%%@%%%%%%+:::::-::::+*****\r\n@@@@@@@%+*****+%@####################%@#@@@@@@@@@@%%*--------------@@@@@@@@=---+%%%@%%%%%%=:::::::::*+::***\r\n@@%+*****+%@@@######################@*:+:-%@@@@@@------------------@@@@@@----:%@%%@%%%%%%=:------::**:****\r\n+=++=%@@@@@@@@#########%#######@@%%%=:----=@@@@@@-----------------=@@@@@-----=@@%%@@%%%%%=:------::*::****\r\n+=%%@@@@@@@@@##########=##@@@%%%%%%%%:------@@@@@------------------@@@@----+@##%%#@%%%%%%*------*:*-:****\r\n+@%===%%+*:=%*:@#####@@*%%%%%%%%%%%%%+-------------------------------------*@###@@#@%%%%%%*:-----**:-:****\r\n%@========*::::+##@@%%%==%@@%%%%%%%%%%:-----------------------------------:@@###@@##%%%%%%+------**--:****\r\n@%===========+::=%=%%%%@@@@@%@@%%%%%%%+-----------------------------------=@####@###@%%%%%*------**--:****\r\n@%============+::*+=%%@@@@@@@@@@@@%%%%%*---------------------------------:%#########@%%%%%*-----:+:--:****\r\n@%===========%=:::*%@@@@@@@@@@@@@@%%%%%=:--------------------------------*@#########@%%=%=:-----**---:****\r\n@%==========%==:::+@@@@@@@@@@@@@@@@@@%%%*-------------------------------:%@#####+##@%%=:==:----*+*---:****\r\n@%=========%%@=*:*=@@@@@@@#@@@@@@@@@@%@@%*-------------\\_______/---------*@######=:@@@%%:-++----*+=----:****\r\n@%========%%@@=***%@@@@@@@@#@@@@@@@@@@@#@%*--------------------------*@#######@*-=@@%*--**---*+=*---:::*:*\r\n@@@%====%%@@#@%+*+@@@@@@@@@@#@@@@@@@@@@##@%+*:--------------------:=@#########%--+@%=---*:---:*+:--::--:**\r\n*%@@@===%@@@#@%*:=@@@@@@@@@@@#@@@@@@@@@@#@+%+++*::-------------:*%@#########@%*--+%=----:--::::--.......-\r\n-:+@@@@@@@@@#@%**@@@@@@@@@@@@@#@@@@@@@@@##=++***+++**:-------:=%@@@########@%=:::+=:---.-.........----::--\r\n---:%@@@@@@@#@%*%@@@@@@@@@@@@@@#@@#@@@@@@##=++++++++++++++*+%@@@@@@#######@%%--.-*:------.----::---.......\r\n-::::=@@@@@@#@%%@@@@@@@@@@@@@@@@@####@@@@##########@@%%%%%@@@@@@@@######@@%%+::*****:---:::::--...........\r\n:::::*@@@@@@@@%%==%%@@@@@@@@@@@@@@#####@@@############@%###@@@@@@@#####@@%%=*-:*:---:::::::::-----........\r\n--::::%@@@@@%%==************+=%%@@@######@@###########@@##@@@@@@@@@###@@%%%**--..--------.................\r\n------*@@%======@@@@%%=+++*********=@########@++++++==%%%@%@@@@@@%%##@@@%@=**-..............-.............\r\n:-----:%@%======@@@@@@@@@@@@@@@@%%==@@@#######%+++++***:--::=@%%%%%#@@@@@#@**:-.........---...............\r\n*/"
}