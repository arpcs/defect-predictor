{
    "id": 139393285,
    "contestId": 959,
    "creationTimeSeconds": 1639573275,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 959,
        "index": "D",
        "name": "Mahmoud and Ehab and another array construction task",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1900,
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 959,
        "members": [
            {
                "handle": "m_scofield"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1522771500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 9625600,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define vi vector<int>\r\n#define ff first\r\n#define ss second\r\n#define pb push_back\r\n#define mp make_pair\r\n#define pi 3.141592653589793238\r\n#define rep(i,a,b) for (int i = a; i <= b; i++)\r\n#define zip(i,a,b) for(int i=a;i<b;i++)\r\n#define rzip(i,a,b) for(int i=a;i>=b;i--)\r\n#define ll unsigned int\r\n#define test int t;cin>>t; while(t--)\r\n#define en '\\n'\r\ntypedef pair<int, int>     pii;\r\ntypedef pair<char, int>    pci;\r\ntypedef pair<char, char>   pcc;\r\ntypedef vector<pii>       vii;\r\ntypedef long double ld;\r\n#define all(v) v.begin(), v.end()\r\n#define rall(v) v.rbegin(),v.rend()\r\n#define sz(x) (int)x.size()\r\n#define INF (1e18+5)\r\n#define inf (1e9+5)\r\n#define mod 1000000007\r\n\r\n\r\n\r\n\r\nvoid __print(int x) {cerr << x;}\r\nvoid __print(float x) {cerr << x;}\r\nvoid __print(double x) {cerr << x;}\r\nvoid __print(long double x) {cerr << x;}\r\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\r\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\r\n// You should only debug a pair of simple data types. For example,\r\n// the debug won't work if one of pair's elements is collection type\r\n// (std::vector, std::map, std::set...).\r\ntemplate<typename T, typename V>\r\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\r\ntemplate<typename T>\r\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\r\nvoid _print() {cerr << \"]\\n\";}\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\r\n#else\r\n#define debug(x...)\r\n#endif\r\ntemplate<int D, typename T>\r\nstruct vec : public vector < vec < D - 1, T >> {\r\n\tstatic_assert(D >= 1, \"Vector dimension must be greater than zero!\");\r\n\ttemplate<typename... Args>\r\n\tvec(int n = 0, Args... args) : vector < vec < D - 1, T >> (n, vec < D - 1, T > (args...)) {\r\n\t}\r\n};\r\ntemplate<typename T>\r\nstruct vec<1, T> : public vector<T> {\r\n\tvec(int n = 0, const T& val = T()) : vector<T>(n, val) {\r\n\t}\r\n};\r\n/* Vec<2, int> a(10, 50); // int a[10][50] initialized with zero\r\nVec<3, double> b(n, m, k, 3.14); // double b[n][m][k] initialized with 3.14\r\nVec<3, long long> c(5, 5); // the third dimension has no value yet\r\nc[0][0].push_back(100); // now c[0][0][0] has a value (100) but others don't\r\nVec<4, int> d(10, 10);\r\nd[2][3].push_back(Vec<1, int>(100, 12345)); // now d[2][3][0] is a vector with 100 values of 12345\r\nVec<1, string> e; // just blank vector of strings            */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// bool check_prime(int n)  return whether a number is prime or not O(sqrt(N));\r\n// int BE(int x,int n,int m)  return x^n%m; O(logN);\r\n// void sieve()  from number 1-1000001 saare prime store kar lega  in bool is_prime[1000001] array\r\n// vector<int> z_array(string s)  return vector which is Z-array of string s;\r\n// vector<int> lps(string s)      return vector which is lps array of string s;\r\n// int power(int x,int n) return x^n; O(logN);\r\n// using_ordered_set (template for using ordered set , replace first 2 lines of this page with this code..);\r\nconst int gf = 1e6 + 9;\r\n\r\n// sieve for prime factorisation\r\nint arr[1000001];\r\nvoid sieve2()\r\n{\r\n\tint mx = 1000000;\r\n\trep(i, 1, mx)arr[i] = -1;\r\n\trep(i, 2, mx)\r\n\t{\r\n\t\tif (arr[i] == -1)\r\n\t\t{\r\n\t\t\tfor (int j = i; j <= mx; j += i)\r\n\t\t\t{\r\n\t\t\t\tif (arr[j] == -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tarr[j] = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nmap<int, int>m1;\r\nset<int> getfac(int x)\r\n{\r\n\tset<int>get;\r\n\twhile (x != 1)\r\n\t{\r\n\t\tget.insert(arr[x]);\r\n\t\tx /= arr[x];\r\n\t}\r\n\treturn get;\r\n}\r\n\r\nbool is_prime[1000001];\r\nvoid sieve()\r\n{\r\n\tint maxN = 1000000;\r\n\tfor (int i = 1; i <= maxN; i++) is_prime[i] = true;\r\n\tis_prime[0] = is_prime[1] = false;\r\n\r\n\tfor (int i = 2; i * i <= maxN; i++)\r\n\t{\r\n\t\tif (is_prime[i])\r\n\t\t{\r\n\t\t\tfor (int j = i * i; j <= maxN; j += i)\r\n\t\t\t{\r\n\t\t\t\tis_prime[j] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool check(int x) {\r\n\tset<int>s = getfac(x);\r\n\tfor (int x : s)if (m1[x])return 0;\r\n\treturn 1;\r\n}\r\n\r\nint32_t main()\r\n{\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(0);\r\n#ifndef ONLINE_JUDGE\r\n\tif (fopen(\"input.txt\", \"r\"))\r\n\t{\r\n\t\tfreopen (\"input.txt\" , \"r\" , stdin);\r\n\t\tfreopen (\"output.txt\" , \"w\" , stdout);\r\n\t}\r\n#endif\r\n\t//_______________________________-code start\r\n\tsieve2();\r\n\tsieve();\r\n\tint n;\r\n\tcin >> n;\r\n\tint a[n];\r\n\tvi prime;\r\n\tset<int>pr;\r\n\trep(i, 2, 1e5) {\r\n\t\tif (is_prime[i]) {\r\n\t\t\tprime.pb(i);\r\n\t\t\tpr.insert(i);\r\n\t\t}\r\n\t}\r\n\tdebug(sz(prime));\r\n\r\n\tzip(i, 0, n)cin >> a[i];\r\n\tint b[n];\r\n\tint ultra_flag = 0;\r\n\tzip(i, 0, n) {\r\n\t\tset<int>s = getfac(a[i]);\r\n\t\tint flag = 0;\r\n\t\tint loru = 0;\r\n\t\tfor (int x : s)\r\n\t\t\tif (m1[x]) {\r\n\t\t\t\tflag = 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpr.erase(x);\r\n\t\t\t\tm1[x]++;\r\n\t\t\t}\r\n\t\tint x = a[i];\r\n\t\tif (flag) { // then we have to start changing from ith row itself\r\n\t\t\t///ultra_flag = 1;\r\n\r\n\t\t\tfor (int val : s) {\r\n\t\t\t\twhile (x % val == 0) {\r\n\t\t\t\t\tx /= val;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint ans;\r\n\t\t\trep(j, a[i] + 1, 1e5) {\r\n\t\t\t\tif (check(j)) {\r\n\t\t\t\t\tans = j;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint x1 = ans;\r\n\t\t\tset<int>s = getfac(x1);\r\n\t\t\tdebug(ans, i);\r\n\t\t\tfor (int x11 : s) {\r\n\t\t\t\tif (m1[x11]) {\r\n\t\t\t\t\tflag = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tpr.erase(x11);\r\n\t\t\t\t\tm1[x11]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tb[i] = ans;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tb[i] = a[i];\r\n\t\t}\r\n\t\tint val = *pr.begin();\r\n\t\tloru = val;\r\n\t\tdebug(loru);\r\n\t\tif (ultra_flag) {\r\n\t\t\tb[i] = loru;\r\n\t\t\tdebug(loru, i, i);\r\n\t\t\tm1[loru]++;\r\n\t\t\tpr.erase(loru);\r\n\t\t}\r\n\t\tif (flag)ultra_flag = 1;\r\n\t}\r\n\tzip(i, 0, n)cout << b[i] << \" \";\r\n\tcout << en;\r\n\r\n\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\n"
}