{
    "id": 211256917,
    "contestId": 1352,
    "creationTimeSeconds": 1687877954,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1352,
        "index": "D",
        "name": "Alice, Bob and Candies",
        "type": "PROGRAMMING",
        "rating": 1300,
        "tags": [
            "implementation"
        ]
    },
    "author": {
        "contestId": 1352,
        "members": [
            {
                "handle": "jagjeet"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1589034900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 61,
    "memoryConsumedBytes": 160460800,
    "source": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include <bits/stdc++.h>\r\n#define ll long long int\r\n/**\r\n *ASCII VALUES\r\n *[0, 9] --> [48, 57]\r\n *[A, Z] --> [65, 90]\r\n *[a, z] --> [97, 122]\r\n */\r\n//constants\r\nconst ll MOD = 1e9 + 7;\r\nconst ll INF = 1e18;\r\nconst ll N = 2e5 + 2;\r\nusing namespace std;\r\n// typedef long long ll;\r\n// typedef unsigned long long ull;\r\n// typedef long double lld;\r\n#define unq(v)  v.resize(distance(v.begin(), unique(v.begin(), v.end())));\r\n// make sure to sort before applying unique // else only consecutive duplicates would be removed \r\n#define ull unsigned long long\r\n#define lld long double\r\n#define pb push_back\r\n#define mp make_pair\r\n// #define mod 1e9+7;\r\n#define enld endl\r\n#define PI 3.1415926535897932384626\r\n#define inf (1LL << 60)\r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define triplet pair<ll, pair<ll, ll>>\r\n#define pp pair<ll, ll>\r\n#define endl \"\\n\"\r\n#define ff first\r\n#define ss second\r\n#define sp(x, y) fixed << setprecision(y) << x\r\n#define hmap unordered_map\r\n#define hset unordered_set\r\n#define haa cout << \"YES\" << endl\r\n#define nahi cout << \"NO\" << endl\r\n#define pf(x) cout << x << endl\r\n#define sz(x) (long long int)x.size()\r\ntypedef pair<int, int> pii;\r\ntypedef pair<ll, ll> pll;\r\ntypedef pair<string, string> pss;\r\ntypedef vector<int> vi;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<pii> vpi;\r\ntypedef vector<pll> vpl;\r\ntypedef vector<ll> vl;\r\ntypedef vector<vl> vvl;\r\n\r\n// Loops-\r\n#define fn(a, b, c) for (int(a) = (b); (a) < (c); ++(a)) // Normal for\r\n#define fo(i, n) for (int i = 0; i < n; i++)             // initialized to 0\r\n#define feach(a, b) for (auto &(a) : (b))                // for maps using auto\r\n\r\n// custom hash for unordered hmap,hset\r\nstruct chash\r\n{\r\n    static uint64_t splitmix64(uint64_t x)\r\n    {\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n \r\n    size_t operator()(uint64_t x) const\r\n    {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\n//debugger\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\n//overloaded\r\ntemplate <typename T1, typename T2> // cin >> pair<T1, T2>\r\nistream &operator>>(istream &istream, pair<T1, T2> &p)\r\n{\r\n    return (istream >> p.first >> p.second);\r\n}\r\n \r\ntemplate <typename T> // cin >> vector<T>\r\nistream &operator>>(istream &istream, vector<T> &v)\r\n{\r\n    for (auto &it : v)\r\n        cin >> it;\r\n    return istream;\r\n}\r\n \r\ntemplate <typename T1, typename T2> // cout << pair<T1, T2>\r\nostream &operator<<(ostream &ostream, const pair<T1, T2> &p)\r\n{\r\n    return (ostream << p.first << \" \" << p.second << \", \");\r\n}\r\ntemplate <typename T> // cout << vector<T>\r\nostream &operator<<(ostream &ostream, const vector<T> &c)\r\n{\r\n    for (auto &it : c)\r\n        cout << it << \" \";\r\n    return ostream;\r\n}\r\n\r\n\r\n//prints the given decimal no into binary form\r\nvoid PrintBinary(int n)\r\n{\r\n    for (ll i = 31; i >= 0; i--)\r\n    {\r\n        cout << ((n >> i) & 1);\r\n    }\r\n    cout << \"\\n\";\r\n}\r\n\r\n//convert given decimal number in binary form\r\n// better approacch\r\n// const int m=10;\r\n// x=30;\r\n// bitset<m> a(x)\r\nstring convbinary(int x){\r\n    string ans=\"\";\r\n    while(x>0){\r\n        if(x%2){\r\n            ans+='1';\r\n        }\r\n        else{\r\n            ans+='0';\r\n        }\r\n        x/=2;\r\n    }\r\n    reverse(ans.begin(),ans.end());\r\n    return ans;\r\n}\r\n\r\n\r\nll BinExpo(ll x, ll y) // gives \"x\" raised to the power of \"y\"\r\n{\r\n    ll ans = 1;\r\n    ll multiply = x;\r\n\r\n    while (y != 0)\r\n    {\r\n        ll RightMostBit = (y & 1);\r\n        if (RightMostBit == 1)\r\n        {\r\n            ans = ans * multiply;\r\n        }\r\n        multiply = multiply * multiply;\r\n        y = (y >> 1);\r\n    }\r\n    return ans;\r\n}\r\n\r\n\r\nll modinv(ll p,ll q)\r\n{\r\n    ll mod =1000000007,ex;\r\n    ex=mod-2;\r\n    while (ex) {\r\n \r\n        if (ex & 1) {\r\n            p = (p * q) % mod;\r\n        }\r\n        \r\n        q = (q * q) % mod;\r\n        ex>>= 1;\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\n//imp function\r\nint modInverse(int n, int m)\r\n{\r\n    for (int i = 1; i < m;i++) \r\n    {\r\n        if (((n % m) * (i % m)) % m == 1) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n//optimised check prime no.\r\nbool prime(int num)\r\n{\r\n    if (num == 1) return false;\r\n    int ch = 2;\r\n    while (ch * ch <= num)\r\n    {\r\n        if (!(num % ch)) return false;\r\n        ch++;\r\n    }return true;\r\n}\r\n\r\n//to check prime number or not\r\nbool CheckPrime(ll x)\r\n{\r\n    if (x == 2)\r\n        return true;\r\n    else\r\n    {\r\n        if (x == 1)\r\n            return false;\r\n        else\r\n        {\r\n            ll done = 0;\r\n            for (ll i = 2; i <= sqrt(x); i++)\r\n            {\r\n                if (x % i == 0)\r\n                {\r\n                    done = 1;\r\n                    break;\r\n                }\r\n            }\r\n            if (done == 0)\r\n                return true;\r\n            else\r\n                return false;\r\n        }\r\n    }\r\n}\r\n\r\n//gcd of whole vector\r\nll GiveGCD(vector<ll> &v)\r\n{\r\n    ll gcd = v[0];\r\n    for (ll i = 0; i < v.size(); i++)\r\n    {\r\n        gcd = __gcd(v[i], gcd);\r\n    }\r\n    return gcd;\r\n}\r\n\r\nint maxThree(int a,int b,int c){\r\n    return max(max(a,b),c);\r\n}\r\nint minThree(int a,int b,int c){\r\n    return min(min(a,b),c);\r\n}\r\nvoid printvec(vector<int> arr){\r\n    for (int i = 0; i < arr.size(); i++)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n    cout<<endl;\r\n}\r\n\r\nint convbinarytoint(string s){\r\n  int n=s.length();\r\nint ans=0;\r\nfor(int i=0;i<n;i++){\r\nif(s[i]=='1') ans|=(1<<(n-i-1));\r\n}\r\nreturn ans;\r\n}\r\n\r\nint maxMap(map<int,int> arr){\r\n    int maxNo = INT_MIN;\r\n    for (map<int,int>::iterator i = arr.begin(); i != arr.end(); i++)\r\n    {\r\n        maxNo = max(maxNo,i->second);\r\n    }\r\n    return maxNo;\r\n}\r\n\r\nint findDuplicate(vector<int>& nums) {\r\n    // return max occurance element which is present in the vector valid only for permutations\r\n        while(nums[0]!= nums[nums[0]]) swap(nums[0],nums[nums[0]]);\r\n        return nums[0];\r\n}\r\n\r\nint minMap(map<int,int> arr){\r\n    int minNo = INT_MIN;\r\n    for (map<int,int>::iterator i = arr.begin(); i != arr.end(); i++)\r\n    {\r\n        minNo = min(minNo,i->second);\r\n    }\r\n    return minNo;\r\n}\r\n\r\nvoid printMap(map<int,int> arr){\r\n    for (map<int,int>::iterator i = arr.begin(); i != arr.end(); i++)\r\n    {\r\n        cout<<i->first<<\" \"<<i->second<<endl;\r\n    }\r\n}\r\n\r\nll kadane(vector<int> c){\r\n    ll s=0;\r\n    ll ans1=0;\r\n    for(int i=0;i<c.size();i++){\r\n       s+=c[i];\r\n       ans1=max(ans1,s);\r\n       if(s<=0){\r\n           s=0;\r\n       }\r\n    }\r\n    return ans1;\r\n}\r\n\r\nll prime_no_returns(ll n){\r\n   ll a = 1;\r\n    for (int g = 2; g * g <= n; ++g) {\r\n      if (n % g == 0) {\r\n        a = n / g;\r\n        break;\r\n      }\r\n    }\r\n    return a;\r\n}\r\n\r\n//  mod of given solving type\r\nll mul(ll x, ll y) {ll res=x*y; return(res>=MOD?res%MOD:res);}\r\nll add(ll x, ll y) {ll res=x+y; return(res>=MOD?res-MOD:res);}\r\nll power(ll a,ll b,ll m=MOD){ ll ans=1; a=a%m;  while(b>0) {  if(b&1)  ans=(1ll*a*ans)%m; b>>=1;a=(1ll*a*a)%m;}return ans;}\r\nll sub(ll x, ll y) {ll res=x-y; return(res<0?res+MOD:res);}\r\n\r\nll prefix[10000000];\r\nll surfix[10000000];\r\n\r\n// partial_sum(v.begin(), v.end(), pre.begin());\r\nvoid prefix_of(vector<int>v){\r\n    prefix[0]=v[0];\r\n     for(int i=1;i<v.size();i++){\r\n        prefix[i]=prefix[i-1]+v[i];\r\n    }\r\n    \r\n}\r\n\r\n// partial_sum(v.rbegin(),v.rend(),s.rbegin());\r\nvoid surfix_of(vector<int>v){\r\n    surfix[v.size()-1]=v[v.size()-1];\r\n        for(int i=v.size()-2;i>=0;i--){\r\n        surfix[i]=surfix[i+1]+v[i];\r\n    }\r\n}\r\n\r\nll sqrt_(ll x) {\r\n        ll left = 0, right = 2000000123;\r\n        while (right > left) {\r\n            ll mid = (left + right) / 2;\r\n\r\n            if (mid * mid > x)\r\n                right = mid;\r\n            else\r\n                left = mid + 1;\r\n        }\r\n        return left - 1;\r\n    }\r\n\r\nvector<ll> getFactors(ll n){\r\n    vector<ll> v;\r\n    for(ll i=2; i*i <= n; i++){\r\n        if(n%i == 0){\r\n            v.push_back(i);\r\n            if(i != n/i)\r\n                v.push_back(n/i);\r\n        }\r\n    }\r\n    return v;\r\n}\r\n\r\n\r\nint findmex(vector<ll> v, int n)\r\n{\r\n    unordered_set<int> s;\r\n    for(int i=0;i<n+2; i++){\r\n        s.insert(i);\r\n    }\r\n    for(auto val:v) if (s.find(val)!=s.end()) s.erase(val);\r\n    return *min_element(all(s));\r\n}\r\n\r\n// check whether a particular string is present in given string\r\n// ex- s= aahhheelloou find= hello so present otherwise use greedy approach\r\nbool ispresentinstring(string s,string find){\r\nint index = 0;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        if (s[i] == find[index]) {\r\n            index++;\r\n        }\r\n        if (index == find.length()) { \r\n            return true;\r\n        }\r\n    }\r\nreturn false;\r\n}\r\n\r\nvoid swap(ll &x,ll &y){\r\n      x = x ^ y;// xis x^y and y is y\r\n      y = x ^ y;// now y=(x^y)^y==> y=x\r\n      x = x ^ y;//now x=(x^y)^(x)==>y so swapped \r\n}\r\n\r\n\r\nvector<ll> factorization_basic(ll n){\r\n    vector<ll> factorization;\r\n    for(ll i=2;i*i<=n;i++){\r\n        while(n%i==0){\r\n            factorization.push_back(i);\r\n            n/=i;\r\n        }\r\n    }\r\n    if(n>1){\r\n        factorization.push_back(n);\r\n    }\r\n    return factorization;\r\n}\r\n\r\n\r\nll ceil(ll n,ll k){\r\nreturn (n-1+k)/k;\r\n}\r\n\r\n\r\nbool checkkthbitset(ll x,ll k){\r\n    return x&(1<<k);\r\n    //to toggle kth bit you can use \r\n    // x^(1<<k)\r\n    //to set kth bit we can Use\r\n    // x|(1<<k)\r\n    // unset the kth bit \r\n    // x&!(1<<k)\r\n}\r\n\r\nbool checkpowerof2(ll x){\r\n    if(x==0){\r\n        return false;\r\n    }\r\n    return x && !(x&(x-1));\r\n}\r\n\r\nll powof2(ll y)//2 raise to y\r\n{\r\n    return 1<<y;\r\n}\r\n\r\n//to find x% 2pow(k)\r\nll modulofinder(ll x,ll k)// this x %2 to pow k\r\n{\r\n        return x&((1<<k)-1);\r\n}\r\n\r\n//a+b=(a^b)+2(a&b)\r\n//a+b=(a|b)+(a&b)\r\n\r\n\r\n\r\nvoid solve(){\r\n   ll n;\r\n   cin>>n;\r\n   vl v(n);\r\n   cin>>v;\r\n   ll l=0;\r\n   ll r=n-1;\r\n   ll alice=0;\r\n   ll bob=0;\r\n   ll aliceneed=0;\r\n   ll bobneed=0;\r\n   ll turn=0;//even toh alice odd toh bob\r\n   while(l<=r){\r\n    if(!(turn&1)){\r\n        ll sum_of_alice_eaten_in_this_turn=0;\r\n        while(l<=r and sum_of_alice_eaten_in_this_turn<=aliceneed){\r\n          sum_of_alice_eaten_in_this_turn+=v[l++];\r\n        }\r\n        alice+=sum_of_alice_eaten_in_this_turn;\r\n        bobneed=sum_of_alice_eaten_in_this_turn;\r\n        turn++;\r\n    }\r\n    else{\r\n        ll sum_of_bob_eaten_in_this_turn=0;\r\n        while(l<=r and sum_of_bob_eaten_in_this_turn<=bobneed){\r\n            sum_of_bob_eaten_in_this_turn+=v[r--];\r\n        }\r\n        bob+=sum_of_bob_eaten_in_this_turn;\r\n        aliceneed=sum_of_bob_eaten_in_this_turn;\r\n        turn++;\r\n    }\r\n   }\r\ncout<<turn<<\" \"<<alice<<\" \"<<bob<<endl;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n    freopen(\"error.txt\", \"w\", stderr);\r\n#endif\r\n    int t;\r\n    cin>>t;\r\n\r\n    while(t-- >0)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "suggested_categories": [
        "algorithm",
        "optimization",
        "mathematics",
        "debugging",
        "data structures",
        "input/output",
        "bit manipulation",
        "number theory",
        "math library",
        "modular arithmetic",
        "dynamic programming",
        "code structure",
        "error handling",
        "performance tuning",
        "programming language features",
        "file handling",
        "randomized algorithms",
        "recursion",
        "sorting",
        "binary search"
    ]
}