{
    "id": 33581236,
    "contestId": 910,
    "creationTimeSeconds": 1514074796,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 910,
        "index": "C",
        "name": "Minimum Sum",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1700,
        "tags": [
            "constructive algorithms",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 910,
        "members": [
            {
                "handle": "Logicer"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1513940700
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <string>\r\n#include <vector>\r\n#include <map>\r\n#include <list>\r\n#include <iterator>\r\n#include <cassert>\r\n#include <set>\r\n#include <string.h>\r\n#include <queue>\r\n#include <iostream>\r\n#include <sstream>\r\n#include <stack>\r\n#include <deque>\r\n#include <cmath>\r\n#include <memory.h>\r\n#include <cstdlib>\r\n#include <cstdio>\r\n#include <cctype>\r\n#include <algorithm>\r\n#include <utility>\r\n#include <time.h>\r\n#include <complex>\r\n#include <climits>\r\n#include <stdarg.h>\r\n#include <iomanip>\r\n#include <initializer_list>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\n#define fill(A, val) memset(A,val,sizeof(A))\r\n#define rep(i, a, n) for (long long (i)=a;(i)<n;++(i))\r\n#define per(i, n, a) for (long long (i)=n-1;(i)>=a;--(i))\r\n#define all(V) V.begin(),(V).end()\r\n#define SZ(V) (int)(V).size()\r\n#define pb push_back\r\n#define ff first\r\n#define ss second\r\n#define min3(a, b, c)     min(a,min(b,c))\r\n#define max3(a, b, c)     max(a,max(b,c))\r\n#define min4(a, b, c, d)   min(min(a,b),min(c,d))\r\n#define max4(a, b, c, d)   max(max(a,b),max(c,d))\r\n#define max5(a, b, c, d, e) max(max3(a,b,c),max(d,e))\r\n#define min5(a, b, c, d, e) min(min3(a,b,c),min(d,e))\r\n#define max6(a, b, c, d, e, f) max(max3(a,b,c),max3(d,e,f))\r\n#define min6(a, b, c, d, e, f) min(min3(a,b,c),min3(d,e,f))\r\n\r\ntypedef long long LL;\r\ntypedef long double DD;\r\ntypedef unsigned long long ULL;\r\ntypedef vector<int> VI;\r\ntypedef pair<int, int> PII;\r\ntypedef pair<LL, LL> PLL;\r\ntypedef pair<DD, DD> PDD;\r\ntypedef map<int, int> MII;\r\ntypedef map<LL, LL> MLL;\r\n\r\nconst double eps = 1e-8;\r\nconst double Pi = 3.14159265358979323846264338327950288419716939937510;\r\nconst long long INF = 1LL << 60;\r\n//const int INF=10000000000;\r\nconst long long MAX5 = 100001;\r\nconst long long MAX6 = 1000001;\r\nconst long long MOD = 1e9 + 7;\r\n\r\nlong long minn(initializer_list<LL> list) {\r\n    long long mn = INF;\r\n    for (LL e: list)mn = min(mn, e);\r\n    return mn;\r\n}\r\n\r\nlong long maxn(initializer_list<LL> list) {\r\n    long long mx = -INF;\r\n    for (LL e: list)mx = max(mx, e);\r\n    return mx;\r\n}\r\n\r\nLL maxSumSub(const LL a[], LL size) {\r\n    LL mxSum = INT_MIN, mxHere = 0;\r\n\r\n    for (int i = 1; i < size; ++i) {\r\n        mxHere = mxHere + a[i];\r\n        if (mxSum < mxHere)\r\n            mxSum = mxHere;\r\n\r\n        if (mxHere < 0)\r\n            mxHere = 0;\r\n    }\r\n    return mxSum;\r\n}\r\n\r\nLL maxMulSub(const LL arr[], LL n) {\r\n    LL mxHere = 1;\r\n    LL mnHere = 1;\r\n    LL mxSum = 1;\r\n    for (int i = 0; i < n; i++) {\r\n        if (arr[i] > 0) {\r\n            mxHere = mxHere * arr[i];\r\n            mnHere = min(mnHere * arr[i], 1LL);\r\n        } else if (arr[i] == 0) {\r\n            mxHere = 1;\r\n            mnHere = 1;\r\n        } else {\r\n            LL temp = mxHere;\r\n            mxHere = max(mnHere * arr[i], 1LL);\r\n            mnHere = temp * arr[i];\r\n        }\r\n        if (mxSum < mxHere)\r\n            mxSum = mxHere;\r\n    }\r\n    return mxSum;\r\n}\r\n\r\nLL nextPow2(LL n) {\r\n    n--;\r\n    n |= n >> 1;\r\n    n |= n >> 2;\r\n    n |= n >> 4;\r\n    n |= n >> 8;\r\n    n |= n >> 16;\r\n    n |= n >> 32;\r\n    return n + 1;\r\n}\r\n\r\n//ax+by=gcd(a,b)\r\ninline LL egcd(LL a, LL b, LL &x, LL &y) {\r\n    if (!a) {\r\n        x = 0;\r\n        y = 1;\r\n        return b;\r\n    }\r\n    LL x1, y1;\r\n    LL d = egcd(b % a, a, x1, y1);\r\n    x = y1 - (b / a) * x1;\r\n    y = x1;\r\n    return d;\r\n}\r\n\r\ninline LL addMod(LL a, LL b, LL m = MOD) {\r\n    return ((int64_t) a + b) % m;\r\n}\r\n\r\ninline LL mulMod(LL a, LL b, LL m = MOD) {\r\n    return ((int64_t) a * b) % m;\r\n}\r\n\r\ninline LL divMod(LL a, LL b, const LL m = MOD) {\r\n    LL x, y;\r\n    LL g = egcd(b, m, x, y);\r\n    if (g != 1) {\r\n        cerr << \"Bad gcd!\" << endl;\r\n    }\r\n    x = (x % m + m) % m;\r\n    return mulMod(a, x, m);\r\n}\r\n\r\nLL gcd(LL a, LL b) { if (!a)return b; else return gcd(b % a, a); }\r\n\r\nLL lcm(LL a, LL b) { return a / gcd(a, b) * b; }\r\n\r\nLL bas(LL a) {\r\n    if (a < 0)return -a;\r\n    return a;\r\n}\r\n\r\nLL min(LL a, LL b) { return a < b ? a : b; }\r\n\r\nLL max(LL a, LL b) { return a < b ? b : a; }\r\n\r\nstring ekv(string a) {\r\n    if (a.size() & 1)return a;\r\n    string x = ekv(a.substr(0, a.size() / 2));\r\n    string y = ekv(a.substr(a.size() / 2));\r\n    return min(x + y, y + x);\r\n}\r\n\r\nstring ups(string s) {\r\n    transform(s.begin(), s.end(), s.begin(), ::toupper);\r\n    return s;\r\n}\r\n\r\nstring lows(string s) {\r\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\r\n    return s;\r\n}\r\n\r\nLL poww(LL a, LL b) {\r\n    if (b == 0)return 1;\r\n    if (b % 2 == 0)return poww(a, b / 2) * poww(a, b / 2);\r\n    else return poww(a, b - 1) * a;\r\n}\r\n\r\nbool isPow2(LL a) { return !(a & (a - 1)); }\r\n\r\nbool isPerfectSquare(int x) {\r\n    int s = sqrt(x);\r\n    return (s * s == x);\r\n}\r\n\r\nLL kBit(LL x, unsigned int k) { return x & (1 << (k - 1)); }\r\n\r\nbool isFibonacci(int n) { return isPerfectSquare(5 * n * n + 4) || isPerfectSquare(5 * n * n - 4); }\r\n\r\ninline LL bSearch(const LL *arr, LL v, LL l, LL r) {\r\n    LL m;\r\n    while (l < r) {\r\n        m = l + (r - l) / 2;\r\n        v <= arr[m] ? r = m : l = m + 1;\r\n    }\r\n    if (arr[r] == v)return r; else return -1;\r\n}\r\n\r\ntemplate<class T>\r\nT low_bound(T *a, unsigned int l, unsigned int r, T v) {\r\n    T p = lower_bound(a + l, a + r, v) - a - l;\r\n    if (p == 0)return -1;\r\n    else return p - 1 + l;\r\n}\r\n\r\ntemplate<class T>\r\nT low_bound(vector<T> a, unsigned int l, unsigned int r, T v) {\r\n    T p = lower_bound(a.begin() + l, a.end() + r, v) - a.begin() - l;\r\n    if (p == 0)return -1;\r\n    else return p - 1 + l;\r\n}\r\n\r\ntemplate<class T>\r\nT up_bound(T *a, unsigned int l, unsigned int r, T v) {\r\n    T p = upper_bound(a + l, a + r, v) - a - l;\r\n    if (p == r)return -1;\r\n    else return p + l;\r\n}\r\n\r\ntemplate<class T>\r\nT up_bound(vector<T> a, unsigned int l, unsigned int r, T v) {\r\n    T p = upper_bound(a.begin() + l, a.end() + r, v) - a.begin() - l;\r\n    if (p == r)return -1;\r\n    else return p + l;\r\n}\r\n\r\nvector<char> getPrimes(unsigned n) {\r\n    vector<char> prime(n + 1, true);\r\n    prime[0] = prime[1] = false;\r\n    for (int i = 2; i * i <= n; ++i)\r\n        if (prime[i])\r\n            if (i * 1LL * i <= n)\r\n                for (int j = i * i; j <= n; j += i)\r\n                    prime[j] = false;\r\n    return prime;\r\n}\r\n\r\nlong long divpole(LL a, LL b) { return a * poww(b, MOD - 2) % MOD; }\r\n\r\nLL rndUp(LL a, LL b) { return (a + b - 1) / b; }\r\n\r\nbool isInteger(DD d) { return !(ceil(d) - LL(d)); }\r\n\r\nLL mod(LL a) {\r\n    a %= MOD;\r\n    if (a < 0)a += MOD;\r\n    return a;\r\n}\r\n\r\ninline bool isPrime(LL n) {\r\n    for (int i = 2; i * i <= n; ++i)if (n % i == 0)return false;\r\n    return true;\r\n}\r\n\r\nstruct node {\r\n    int val;\r\n    node *left, *right;\r\n\r\n    node() : left(nullptr), right(nullptr) {}\r\n\r\n    node(int v) : left(nullptr), right(nullptr), val(v) {}\r\n//    node(int w, int f) : w(w), f(f) {}\r\n    //bool operator<(node a) const { return w < a.w; }\r\n//    bool operator>(node a) const { return f > a.f; }\r\n};\r\n\r\nbool is_cbrt(LL a, LL b) {\r\n    LL prod = a * b;\r\n    LL p = (LL) round(exp((log(a) + log(b)) / 3));\r\n    return p * p * p == prod;\r\n}\r\n\r\nLL cubic_root(LL x) {\r\n    LL l = 0, r = MAX6;\r\n    while (l != r) {\r\n        LL m = (l + r + 1) / 2;\r\n        if (m * m * m > x) r = m - 1; else l = m;\r\n    }\r\n    return l;\r\n}\r\n\r\nbool cmpr(LL a, LL b) {\r\n    return a > b;\r\n}\r\n\r\nbool cmpr2(PLL a, PLL b) {\r\n    return a.ss < b.ss;\r\n}\r\n\r\n\r\nLL A[MAX6];\r\nLL B[MAX6];\r\n\r\nLL d[101][101];\r\n\r\n\r\n//void bfs(LL v){\r\n//\r\n//    queue<LL> q;\r\n//    q.push(v);\r\n//    was2[v] = true;\r\n//    while (!q.empty()) {\r\n//\r\n//        v = q.front();\r\n//        q.pop();\r\n//        if (B[v] != A[v]) {\r\n//            res++;\r\n//            fill(was1, 0);\r\n//            paint(v, A[v]);\r\n//        }\r\n//        for (int i = 0; i < g[v].size(); ++i)\r\n//            if (!was2[g[v][i]]) {\r\n//                was2[g[v][i]] = true;\r\n//                q.push(g[v][i]);\r\n//            }\r\n//    }\r\n//}\r\n\r\n\r\nint solution() {\r\n\r\n    int n;\r\n    PLL a[11];\r\n    bool zer0[11];\r\n\r\n    cin >> n;\r\n    for (int i = 0; i <= 9; ++i)\r\n        a[i].second = i;\r\n\r\n    string s;\r\n    for (int i = 1; i <= n; ++i) {\r\n        cin >> s;\r\n        int mul = 1;\r\n        for (int j = s.size() - 1; j >= 0; --j) {\r\n            a[s[j] - 'a'].first += mul;\r\n            mul *= 10;\r\n        }\r\n        zer0[s[0] - 'a'] = true;\r\n    }\r\n\r\n    sort(a, a + 10, greater<>());\r\n    int res = 0, cur = 1;\r\n    bool check = false;\r\n    for (int i = 0; i <= 9; ++i)\r\n        if (!check && !zer0[a[i].second])\r\n            check = true;\r\n        else {\r\n            res += cur * a[i].first;\r\n            cur++;\r\n        }\r\n    cout << res;\r\n\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    //cin.tie();\r\n#ifdef Logicer\r\n    //freopen(\"input.txt\", \"r\", stdin);\r\n    //freopen(\"output.txt\", \"w\", stdout);\r\n    DD bTime = clock();\r\n#endif\r\n    int t = 1;\r\n//    cin>>t;\r\n    rep(i, 0, t)solution();\r\n#ifdef Logicer\r\n    DD eTime = clock();\r\n    cout << \"\\n** Time: \" << fixed << setprecision(4) << (eTime - bTime) / CLOCKS_PER_SEC << \" **\";\r\n#endif\r\n\r\n}"
}