{
    "id": 218681936,
    "contestId": 1842,
    "creationTimeSeconds": 1691935235,
    "relativeTimeSeconds": 335,
    "problem": {
        "contestId": 1842,
        "index": "A",
        "name": "Tenzing and Tsondu",
        "type": "PROGRAMMING",
        "points": 250.0,
        "rating": 800,
        "tags": [
            "games",
            "math"
        ]
    },
    "author": {
        "contestId": 1842,
        "members": [
            {
                "handle": "1_Hypex_"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1691934900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 8,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define int long long\r\n#define endl \"\\n\"\r\nconst int mod = 998244353;\r\nconst int N = 3e5+5;\r\n//int n,m,sx,sy,d;\r\n//vector<int>dx={1,-1,0,0};\r\n//vector<int>dy = {0,0,1,-1};\r\nint ans=0;\r\n\r\n\r\n\r\nlong long power(long long x, \r\n                                  int y, int p)\r\n{\r\n    long long res = 1; // Initialize result\r\n  \r\n    x = x % p; // Update x if it is more than or\r\n    // equal to p\r\n  \r\n    while (y > 0) \r\n    {\r\n      \r\n        // If y is odd, multiply x with result\r\n        if (y & 1)\r\n            res = (res * x) % p;\r\n  \r\n        // y must be even now\r\n        y = y >> 1; // y = y/2\r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\n\r\nint power1(int x,int p){\r\n\tint ans = 1;\r\n\tfor(int i=0;i<p;i++){\r\n\t\tans  = ans*x;\r\n\t}\r\n\treturn ans;\r\n}\r\n  \r\n// Returns n^(-1) mod p\r\nunsigned long long modInverse(unsigned long long n,  \r\n                                            int p)\r\n{\r\n    return power(n, p - 2, p);\r\n}\r\n  \r\n// Returns nCr % p using Fermat's little\r\n// theorem.\r\nunsigned long long nCrModPFermat(unsigned long long n,\r\n                                 int r, int p)\r\n{\r\n    // If n<r, then nCr should return 0\r\n    if (n < r)\r\n        return 0;\r\n    // Base case\r\n    if (r == 0)\r\n        return 1;\r\n  \r\n    // Fill factorial array so that we\r\n    // can find all factorial of r, n\r\n    // and n-r\r\n    unsigned long long fac[n + 1];\r\n    fac[0] = 1;\r\n    for (int i = 1; i <= n; i++)\r\n        fac[i] = (fac[i - 1] * i) % p;\r\n  \r\n    return (fac[n] * modInverse(fac[r], p) % p\r\n            * modInverse(fac[n - r], p) % p)\r\n           % p;\r\n}\r\n\r\n\r\n\r\n\r\nvoid init_code(){\r\n\r\n\t#ifndef ONLINE_JUDGE\r\n\tfreopen(\"input.txt\", \"r\", stdin);\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n\t#endif // ONLINE_JUDGE\r\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n}\r\n\r\n\r\nint get(vector<int>&x,vector<int>&y){\r\n\tint cnt = 0;\r\n\twhile(cnt<(int)x.size() && x[cnt] == y[cnt]) cnt++;\r\n\treturn cnt; \r\n}\r\n\r\nbool f(vector<int>& t,int n,int k,int d,int w){\r\n\tbool f = true;\r\n\tfor(int i=0;i<n;i+=k){\r\n\t\tint a = t[i];\r\n\t\tint b = t[i+k-1];\r\n\r\n\r\n\r\n\t\tint open = a+w;\r\n\r\n\t\tfor(int j=i;j<i+k;j++){\r\n\t\t\tif((t[i]+w)<(open+d)){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n\r\n}\r\n\r\n\r\n\r\nbool check(vector<string>& a,char ch){\r\n\tfor(int i=0;i<3;i++){\r\n\t\tif(a[i][0] == ch && a[i][1] == ch && a[i][2] == ch){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<3;i++){\r\n\t\tif(a[0][i] == ch && a[1][i] == ch && a[2][i] == ch){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\tif(a[0][0] == a[1][1] && a[1][1] == a[2][2] && a[0][0] == ch){\r\n\t\treturn true;\r\n\t}\r\n\tif(a[0][2] == a[1][1] && a[1][1] == a[2][0] && a[1][1] == ch){\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n\t\r\n}\r\n\r\nint gcd(int a, int b, int& x, int& y) {\r\n    if (b == 0) {\r\n        x = 1;\r\n        y = 0;\r\n        return a;\r\n    }\r\n    int x1, y1;\r\n    int d = gcd(b, a % b, x1, y1);\r\n    x = y1;\r\n    y = x1 - y1 * (a / b);\r\n    return d;\r\n}\r\n/*\r\nvector<vector<vector<int>>>table(1000,vector<vector<int>>(1000,vector<int>(25,0)));\r\n\r\nclass SparseTable{\r\n\tSparseTable(vector<vector<int>>& a,int n,int m){\r\n\t\t//table[i][j] = table[i][j-1] + table[i+ (1<<j)][j-1]\r\n\r\n\t\tfor(int i=n-1;i>=0;i--){\r\n\t\t\tfor(int j=m-1;j>=0;j--){\r\n\t\t\t\tfor(int k=0;k<25;k++){\r\n\t\t\t\t\tif(i+(1<<k) >n || j+(1<<k) >n) break;\r\n\t\t\t\t\tif(k == 0) table[i][j][k] = a[i][j];\r\n\t\t\t\t\telse table[i][j][k] = min(min(table[i][j][k-1],table[i+(1<<(k-1))][j][k-1]),min(table[i][j+(1<<(k-1))][k-1],table[i+(1<<(k-1))][j+(1<<(k-1))][k-1]));\r\n\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tint getsparsetablemin(int i,int j,int w){\r\n\t\tint mn = 1e10;\r\n\t\tint p = log2(w);\r\n\t\tint mn1  = min(table[i][j][p],table[i+w-(1<<p)][j][p]);\r\n\t\tint mn2 = min(table[i][j+w-(1<<p)][p],table[i+w-(1<<p)][j+w-(1<<p)][p]);\r\n\t\treturn min(mn1,mn2);\r\n\t\t//i,j,p\r\n\t\t//i+w-(1<<p),j,p\r\n\t\t//i,j+w-(1<<p),p\r\n\t\t//i+w-(1<<p),j+w-(1<<p)\r\n\r\n\t\t//w = 12\r\n\t\t//i = 2,j=2\r\n\t\t//p = 3\r\n\t\t//(2,2,3),(6,2,3),(2,6,3),(6,6,3) -->covers full block of size 12 x 12\r\n\r\n\r\n\r\n\t}\r\n};\r\n*/\r\n\r\nint sz(int v,vector<bool> &used,vector<vector<int>> &g){\r\n\tused[v] = true;\r\n\tint s = 1;\r\n\tfor(int i=0;i<(int)g[v].size();i++){\r\n\t\tif(!used[g[v][i]]) s+= sz(g[v][i],used,g);\r\n\t}\r\n\treturn s;\r\n}\r\nvoid depth(int v,int p,vector<int>& d,vector<vector<int>>& g){\r\n\tif(p>=0) d[v] = d[p] +1;\r\n\tfor(auto u:g[v]){\r\n\t\tif(u!=p) depth(u,v,d,g);\r\n\t}\r\n}\r\n\r\nvoid dfs(int u,int p,vector<vector<int>>& g,bool f,int cur,int& ans){\r\n\t//cout<<u<<\" \"<<max_d[u]<<endl;\r\n\tif(u == cur) f = true;\r\n\tif(f && g[u].size() == 1){\r\n\t\tif(u!=1)ans++;\r\n\t} \r\n\tfor(auto v: g[u]){\r\n\t\tif(v == p) continue;\r\n\r\n\r\n\r\n\t\tdfs(v,u,g,f,cur,ans);\r\n\r\n\t//\tcout<<u<<\"--> \"<<v<<endl;\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\nvoid dfs2(int u,int p,vector<bool>& taken,vector<vector<int>>& g,vector<pair<int,int>>& dp0,vector<pair<int,int>>& dp1,vector<int>&ans){\r\n\tif((p>=0 && taken[p]) || dp0[u] > dp1[u]){\r\n\t\tans[u] = 1;\r\n\t}\r\n\telse{\r\n\t\ttaken[u] = 1;\r\n\t\tans[u] = (int)g[u].size();\r\n\t}\r\n\r\n\tfor(auto v: g[u]){\r\n\t\tif(v == p) continue;\r\n\t\tdfs2(v,u,taken,g,dp0,dp1,ans);\r\n\t}\r\n}\r\nvoid primeFactors(int n,map<int,int>& cnt)\r\n{\r\n    // Print the number of 2s that divide n\r\n    while (n % 2 == 0)\r\n    {\r\n        cnt[2]++;\r\n        n = n/2;\r\n    }\r\n \r\n    // n must be odd at this point. So we can skip\r\n    // one element (Note i = i +2)\r\n    for (int i = 3; i <= sqrt(n); i = i + 2)\r\n    {\r\n        // While i divides n, print i and divide n\r\n        while (n % i == 0)\r\n        {\r\n            cnt[i]++;\r\n            n = n/i;\r\n        }\r\n    }\r\n \r\n    // This condition is to handle the case when n\r\n    // is a prime number greater than 2\r\n    if (n > 2)\r\n        cnt[n]++;\r\n}\r\n/*\r\nvoid primeFactors(int n,map<int,int>& cnt)\r\n{\r\n    int c=2;\r\n    while(n>1)\r\n    {\r\n        if(n%c==0){\r\n        cnt[c]++;\r\n        n/=c;\r\n        }\r\n        else c++;\r\n    }\r\n}\r\n*/\r\n\r\nint dx[] = {1,-1,0,0};\r\nint dy[]= {0,0,1,-1};\r\nint s;\r\n\r\nbool isValid(int x,int y,int n,int m){\r\n\tif(x<n && x>=0 && y<m && y>=0) return true;\r\n\treturn false;\r\n}\r\n\r\nint nod(int n){\r\n\tint ans = 0;\r\n\twhile(n>0){\r\n\t\tn/=10;\r\n\t\tans++;\r\n\t}\r\n\treturn ans;\r\n}\r\n\r\nclass UnionFind{\r\n    public:\r\n        int n, *rank, *par,*maxi;\r\n        UnionFind (int N){\r\n            n = N+1;\r\n            par = new int[n];\r\n            rank = new int[n];\r\n            maxi = new int[n];\r\n            for(int i = 0; i < n; i++){\r\n                par[i] = i;\r\n                rank[i] = 1;\r\n                maxi[i] = 0;\r\n            }\r\n        }\r\n \r\n    \r\n        int getPar(int x){\r\n            if(x == par[x]) return x;\r\n            par[x] = getPar(par[x]);\r\n            return par[x];\r\n        }\r\n \r\n        void merge(int x, int y,int val){\r\n            x = getPar(x);\r\n            y = getPar(y);\r\n            if(rank[x] < rank[y]){\r\n                swap(x, y);\r\n            }\r\n            maxi[x] = max({maxi[x],maxi[y],val});\r\n            maxi[y] = 0;\r\n\r\n            int tempx = rank[x];\r\n            int tempy = rank[y];\r\n \r\n            par[y] = x;\r\n            rank[x] += rank[y];\r\n            rank[y] = 0;\r\n\r\n            int range = s-maxi[x];\r\n        \tint tot = tempx*tempy-1LL;\r\n        \t(ans *= power(1+range, tot,mod))%=mod;\r\n\r\n\r\n        }\r\n};\r\n\r\nint rec(int idx,vector<int>& arr,vector<int>&a,int& n,int& sum,int& cur){\r\n\r\n\t//cout<<sum<<endl;\r\n\t//base case\r\n\tif(arr.size() == n){\r\n\t\t\r\n\t\tint sum2 = sum - cur;\r\n\t//\tcout<<idx<<\" \"<<sum1<<\" \"<<sum2<<endl;\r\n\r\n\t\treturn abs(cur-sum2);\r\n\r\n\t}\r\n\tif(idx == 2*n) return 1e10;\r\n\t//recursion\r\n\tint a1 = rec(idx+1,arr,a,n,sum,cur);\r\n\t\r\n\tarr.push_back(a[idx]);\r\n\tcur+=a[idx];\r\n\tint a2 = rec(idx+1,arr,a,n,sum,cur);\r\n\tarr.pop_back();\r\n\tcur-=a[idx];\r\n\treturn min(a1,a2);\r\n\r\n}\r\n\r\nint32_t main() {\r\n\tinit_code();\r\n//\tfac();\r\n\tint _;\r\n\t_=1;\r\n\tcin>>_;\r\n\t//_=1;\r\n\twhile(_--){\r\n\t\tint n,m;\r\n\t\tcin>>n>>m;\r\n\t\tint s1=0;\r\n\t\tint s2=0;\r\n\t\tfor(int i=0;i<n;i++){\r\n\t\t\tint x;\r\n\t\t\tcin>>x;\r\n\t\t\ts1+=x;\r\n\t\t}\r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tint x;\r\n\t\t\tcin>>x;\r\n\t\t\ts2+=x;\r\n\t\t}\r\n\t\tif(s1 == s2){\r\n\t\t\tcout<<\"Draw\";\r\n\t\t}\r\n\t\telse if(s1>s2){\r\n\t\t\tcout<<\"Tsondu\";\r\n\t\t}\r\n\t\telse cout<<\"Tenzing\";\r\n\r\n\t\tcout<<endl;\r\n\r\n\t}\r\n\t\r\n\r\n\treturn 0;\r\n\t}\r\n\t\t"
}