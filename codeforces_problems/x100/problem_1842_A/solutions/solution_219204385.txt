{
    "id": 219204385,
    "contestId": 1842,
    "creationTimeSeconds": 1692257933,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1842,
        "index": "A",
        "name": "Tenzing and Tsondu",
        "type": "PROGRAMMING",
        "points": 250.0,
        "rating": 800,
        "tags": [
            "games",
            "math"
        ]
    },
    "author": {
        "contestId": 1842,
        "members": [
            {
                "handle": "Sambath_S"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1687615500
    },
    "programmingLanguage": "Java 17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 217,
    "memoryConsumedBytes": 0,
    "source": "import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Solution{\r\n\r\n    static class FastReader{\r\n        BufferedReader br;\r\n        StringTokenizer st;\r\n        public FastReader(){\r\n            br=new BufferedReader(new InputStreamReader(System.in));\r\n        }\r\n        String next(){\r\n            while(st==null || !st.hasMoreTokens()){\r\n                try {\r\n                    st=new StringTokenizer(br.readLine());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            return st.nextToken();\r\n        }\r\n        int nextInt(){\r\n            return Integer.parseInt(next());\r\n        }\r\n        long nextLong(){\r\n            return Long.parseLong(next());\r\n        }\r\n        double nextDouble(){\r\n            return Double.parseDouble(next());\r\n        }\r\n        String nextLine(){\r\n            String str=\"\";\r\n            try {\r\n                str=br.readLine().trim();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n    }\r\n    static class FastWriter {\r\n        private final BufferedWriter bw;\r\n\r\n        public FastWriter() {\r\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\r\n        }\r\n\r\n        public void print(Object object) throws IOException {\r\n            bw.append(\"\" + object);\r\n        }\r\n\r\n        public void println(Object object) throws IOException {\r\n            print(object);\r\n            bw.append(\"\\n\");\r\n        }\r\n        public void println() throws IOException{\r\n            bw.append(\"\\n\");\r\n        }\r\n\r\n        public void close() throws IOException {\r\n            bw.close();\r\n        }\r\n    }\r\n    static class BinaryLifting{\r\n        ArrayList<ArrayList<Integer>> adj;\r\n        int root,n;\r\n        int up[][];\r\n        int depth[];\r\n        BinaryLifting(ArrayList<ArrayList<Integer>> adj,int root){\r\n            this.adj=adj;\r\n            this.root=root;\r\n            n=adj.size();\r\n            up=new int[n+2][log2(n+2)+2];\r\n            depth=new int[n+3];\r\n            for(int i[]:up) Arrays.fill(i,-1);\r\n            initialization1(root,-1);\r\n            initialization2();\r\n        }\r\n        private void initialization1(int node,int par){\r\n            up[node][0]=par;\r\n            if(par==-1) depth[node]=0;\r\n            else depth[node]=depth[par]+1;\r\n            for(int i:adj.get(node)){\r\n                if(i==par) continue;\r\n                initialization1(i,node);\r\n            }\r\n        }\r\n        private void initialization2(){\r\n            for(int i=1;i<=log2(n+2)+1;i++){\r\n                for(int j=0;j<=n;j++){\r\n                    if(up[j][i-1]==-1) up[j][i]=-1;\r\n                    else up[j][i]=up[up[j][i-1]][i-1];\r\n                }\r\n            }\r\n        }\r\n        public int kthAncestor(int node,int k){\r\n            if(k==0||node==-1) return node;\r\n            return kthAncestor(up[node][log2(k)],k-(int)(Math.pow(2,log2(k))));\r\n        }\r\n        public int lca(int node1,int node2){\r\n            if(depth[node1]<depth[node2]) return lca(node2,node1);\r\n            while(depth[node1]-depth[node2]!=0){\r\n                node1=up[node1][log2(depth[node1]-depth[node2])];\r\n            }\r\n            if(node1==node2) return node1;\r\n            for(int i=log2(n)+1;i>=0;i--){\r\n                if(up[node1][i]!=up[node2][i]){\r\n                    node1=up[node1][i];\r\n                    node2=up[node2][i];\r\n                }\r\n            }\r\n            return up[node1][0];\r\n        }\r\n        public int distance(int node1,int node2){\r\n            int root=lca(node1,node2);\r\n            return depth[node1]+depth[node2]-2*depth[root];\r\n        }\r\n        private int log2(int n){\r\n            return (int)(Math.log(n)/Math.log(2));\r\n        }\r\n    }\r\n    static class SegmentTree{\r\n        static int seg[]=new int[(int)1e6];\r\n        public static int build(int lo,int hi,int arr[],int ind){\r\n            if(lo==hi) {seg[ind]=arr[lo];return arr[lo];}\r\n            int mid=(lo+hi)/2;\r\n            return seg[ind]=build(lo,mid,arr,2*ind+1)+build(mid+1,hi,arr,2*ind+2);\r\n        }\r\n        public static int update(int lo,int hi,int arr[],int ind,int up){\r\n            if(lo>up || hi<up) return seg[ind];\r\n            if(lo==hi){\r\n                seg[ind]=arr[lo];\r\n                return seg[ind];\r\n            }\r\n            int mid=(lo+hi)/2;\r\n            return seg[ind]=update(lo,mid,arr,2*ind+1,up)+update(mid+1,hi,arr,2*ind+2,up);\r\n        }\r\n        public static int query(int lo,int hi,int ind1,int ind2,int ind){\r\n            if(hi<ind1||lo>ind2) return 0;\r\n            if(lo>=ind1 && hi<=ind2) return seg[ind];\r\n            int mid=(lo+hi)/2;\r\n            return query(lo,mid,ind1,ind2,2*ind+1)+query(mid+1,hi,ind1,ind2,2*ind+2);\r\n        }\r\n    }\r\n    static long gcd1(long a, long b) {\r\n        if (a == 0)\r\n            return b;\r\n        if (b == 0)\r\n            return a;\r\n        long k;\r\n        for (k = 0; ((a | b) & 1) == 0; ++k) {\r\n            a >>= 1;\r\n            b >>= 1;\r\n        }\r\n        while ((a & 1) == 0)\r\n            a >>= 1;\r\n        do {\r\n            while ((b & 1) == 0)\r\n                b >>= 1;\r\n            if (a > b) {\r\n                long temp = a;\r\n                a = b;\r\n                b = temp;\r\n            }\r\n\r\n            b = (b - a);\r\n        } while (b != 0);\r\n        return a << k;\r\n    }\r\n    static long longSqrt(long n){\r\n        long temp=(long)Math.sqrt(n);\r\n        if(temp*temp>n) return temp-1;\r\n        return temp;\r\n    }\r\n    static int gcd(int a, int b) {\r\n        if(b==0)\r\n            return a;\r\n        return gcd(b,a%b);\r\n    }\r\n    static int[] sieveOfEratosthenes(int n){\r\n        int arr[]=new int[n+1];\r\n        for(int i=2;i<=n;i++){\r\n            if(arr[i]!=0) continue;\r\n            for(int j=i;j<=n;j+=i){\r\n                if(arr[j]==0) arr[j]=i;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    static int smallestPrimeFactor(int k){\r\n        for(int i=2;i*i<=k;i++){\r\n            if(k%i==0) return i;\r\n        }\r\n        return 1;\r\n    }\r\n    // modulo value is set 1e9+7\r\n    static long power(long x,long n){\r\n        long div=(long)1e9+7;\r\n        //long div=(long)998244353;\r\n        if(n==0) return 1L;\r\n        if(n==1) return x;\r\n        long temp=power(x,n/2)%div;\r\n        long l = ((temp % div) * (temp % div)) % div;\r\n        if(n%2==0) return l;\r\n        return (l * x)%div;\r\n    }\r\n    public static long a_div_b(long p, long q) {\r\n        // remember (a/b) mod m == (a%m/b%m) mod m\r\n        long mod=1000000007;\r\n        if(p==0) return 0;\r\n        //long mod=(long)998244353;\r\n        long ex = mod-2;\r\n        while(ex != 0) {\r\n            if((ex & 1) == 1) p = (p*q) % mod;\r\n            q = (q*q) % mod;\r\n            ex >>= 1;\r\n        }\r\n        return p;\r\n    }\r\n    static long factorial(long b){\r\n        long temp=1;\r\n        long div=(long)1e9+7;\r\n        //long div=(long)998244353;\r\n        for(long i=1;i<=b;i++){\r\n            temp*=i;\r\n            temp=temp%div;\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    /**************************GLOBAL_VAR**************************************/\r\n\r\n    /*************************************************************************/\r\n    public static int calc(int x,int y,int d){\r\n        return (y-x+d-1)/d;\r\n    }\r\n    public static void main(String[] args) {\r\n        try {\r\n            //Scanner in=new Scanner(System.in);\r\n            FastReader in = new FastReader();\r\n            FastWriter out = new FastWriter();\r\n            /*************************************************************************/\r\n            long div = (int) 1e9 + 7;\r\n            //long div=(long)998244353;\r\n\r\n            int t = in.nextInt();\r\n            //int T=1;\r\n\r\n            while (t-- > 0) {\r\n                int nx=in.nextInt();\r\n                int ny=in.nextInt();\r\n                int sum1=0,sum2=0;\r\n                for(int i=0;i<nx;i++){\r\n                    sum1+=in.nextInt();\r\n                }\r\n                for(int i=0;i<ny;i++){\r\n                    sum2+=in.nextInt();\r\n                }\r\n                if(sum1==sum2) System.out.println(\"Draw\");\r\n                else System.out.println(sum1>sum2?\"Tsondu\":\"Tenzing\");\r\n\r\n            }\r\n            out.close();\r\n        }\r\n        /*************************************************************************/\r\n        catch (IOException e){\r\n            return;\r\n        }\r\n    }\r\n    public static boolean isPossible(int ar[],int i,long mid,long k){\r\n        long count=mid-ar[i];\r\n        int a[]=ar.clone();\r\n        a[i]=(int)mid;\r\n        int n=ar.length;\r\n        while(i<n-1){\r\n            if(a[i]-1<=a[i+1]){\r\n               break;\r\n            }\r\n            else{\r\n                count+=(a[i]-a[i+1]-1);\r\n                a[i+1]=a[i]-1;\r\n            }\r\n            i++;\r\n        }\r\n        return  i<(n-1) && count<=k;\r\n    }\r\n\r\n    /***********************************FUNCTIONS*********************************/\r\n\r\n\r\n    /*****************************************************************************/\r\n\r\n    static class Pair\r\n    {\r\n        int s;\r\n        int e;\r\n        Pair(int s,int e)\r\n        {\r\n            this.s=s;\r\n            this.e=e;\r\n        }\r\n    }\r\n}"
}