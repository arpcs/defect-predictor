{
    "id": 198430510,
    "contestId": 1491,
    "creationTimeSeconds": 1679361813,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1491,
        "index": "F",
        "name": "Magnets",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2700,
        "tags": [
            "binary search",
            "constructive algorithms",
            "interactive"
        ]
    },
    "author": {
        "contestId": 1491,
        "members": [
            {
                "handle": "cmk666"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1614519300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 79,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 0,
    "source": "// LUOGU_RID: 105374144\n/*\r\n * @Author:             cmk666\r\n * @Created time:       2023-03-21 09:11:34\r\n * @Last Modified time: 2023-03-21 09:22:46\r\n */\r\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\r\n#include<bits/stdc++.h>\r\nusing namespace std; using ll = long long;\r\n#define For(i, j, k) for ( int i = (j) ; i <= (k) ; i++ )\r\n#define Fol(i, j, k) for ( int i = (j) ; i >= (k) ; i-- )\r\nnamespace FastIO\r\n{\r\n// ------------------------------\r\n// #define IN_HAS_NEG\r\n// #define OUT_HAS_NEG\r\n// #define CHK_EOF\r\n// ------------------------------\r\n#if __cplusplus < 201400\r\n#error Please use C++14 or higher.\r\n#endif\r\n#define IL inline __attribute__((always_inline))\r\n#ifndef _WIN32\r\n#include<sys/mman.h>\r\n#include<fcntl.h>\r\n#endif\r\n#ifdef LOCAL\r\n\tIL void gc(char &c) { c = getchar(); }\r\n\tIL void pc(const char &c) { putchar(c); }\r\n#else\r\n\tIL void gc(char &c)\r\n\t{\r\n#ifdef _WIN32\r\n\t\tconstexpr int IN_SIZE = 1 << 18; static char i[IN_SIZE], *p = i, *q = i;\r\n\t\tif ( __builtin_expect(p == q, false) )\r\n\t\t{\r\n\t\t\tq = i + fread(p = i, 1, IN_SIZE, stdin);\r\n#ifdef CHK_EOF\r\n\t\t\tif ( __builtin_expect(p == q, false) ) { c = EOF; return; }\r\n#endif\r\n\t\t}\r\n#else\r\n\t\tstatic char *p = (char *)mmap(0, INT_MAX, 1, 1, fileno(stdin), 0);\r\n#endif\r\n\t\tc = *p++;\r\n\t}\r\n\tIL void pc(const char &c)\r\n\t{\r\n\t\tconstexpr int OUT_SIZE = 1 << 13; static char o[OUT_SIZE], *p = o;\r\n\t\tif ( __builtin_expect(c == EOF, false) ) { fwrite(o, 1, p - o, stdout); return; }\r\n\t\t*p++ = c;\r\n\t\tif ( __builtin_expect(o + OUT_SIZE == p, false) ) fwrite(o, 1, p - o, stdout), p = o;\r\n\t}\r\n\tstruct _auto_flush { ~_auto_flush() { pc(EOF); } } _auto_flusher;\r\n#endif\r\n#ifdef CHK_EOF\r\n\tIL bool _isdigit(const char &c) { return ( c & 16 ) && c != EOF; }\r\n\tIL bool _isgraph(const char &c) { return c > 32 && c != EOF; }\r\n#else\r\n\tIL bool _isdigit(const char &c) { return c & 16; }\r\n\tIL bool _isgraph(const char &c) { return c > 32; }\r\n#endif\r\n\tIL void read(char &c) { gc(c); while ( !_isgraph(c) ) gc(c); }\r\n\tIL void read_cstr(char *s)\r\n\t{\r\n\t\tchar c; gc(c);\r\n\t\twhile ( !_isgraph(c) ) gc(c);\r\n\t\twhile ( _isgraph(c) ) *s++ = c, gc(c);\r\n\t\t*s = 0;\r\n\t}\r\n\tIL void read(string &s)\r\n\t{\r\n\t\tchar c; gc(c), s.clear();\r\n\t\twhile ( !_isgraph(c) ) gc(c);\r\n\t\twhile ( _isgraph(c) ) s.push_back(c), gc(c);\r\n\t}\r\n\ttemplate < class T, typename enable_if < is_integral < T >::value, int >::type = 0 >\r\n\tIL void uread(T &x)\r\n\t{\r\n\t\tchar c; x = 0, gc(c);\r\n\t\twhile ( !_isdigit(c) ) gc(c);\r\n\t\twhile ( _isdigit(c) ) x = x * 10 + ( c & 15 ), gc(c);\r\n\t}\r\n\tIL void uread(__int128 &x)\r\n\t{\r\n\t\tchar c; x = 0, gc(c);\r\n\t\twhile ( !_isdigit(c) ) gc(c);\r\n\t\twhile ( _isdigit(c) ) x = x * 10 + ( c & 15 ), gc(c);\r\n\t}\r\n\tIL void uread(__uint128_t &x)\r\n\t{\r\n\t\tchar c; x = 0, gc(c);\r\n\t\twhile ( !_isdigit(c) ) gc(c);\r\n\t\twhile ( _isdigit(c) ) x = x * 10 + ( c & 15 ), gc(c);\r\n\t}\r\n\ttemplate < class T, typename enable_if < is_unsigned < T >::value, int >::type = 0 >\r\n\tIL void read(T &x) { uread(x); }\r\n\tIL void read(__uint128_t &x) { uread(x); }\r\n\ttemplate < class T, typename enable_if < is_signed < T >::value, int >::type = 0 >\r\n\tIL void read(T &x)\r\n\t{\r\n#ifdef IN_HAS_NEG\r\n\t\tchar c; bool flag = false; x = 0, gc(c);\r\n\t\twhile ( !_isdigit(c) ) flag |= c == 45, gc(c);\r\n\t\twhile ( _isdigit(c) ) x = x * 10 + ( c & 15 ), gc(c);\r\n\t\tif ( flag ) x = -x;\r\n#else\r\n\t\turead(x);\r\n#endif\r\n\t}\r\n\tIL void read(__int128 &x)\r\n\t{\r\n#ifdef IN_HAS_NEG\r\n\t\tchar c; bool flag = false; x = 0, gc(c);\r\n\t\twhile ( !_isdigit(c) ) flag |= c == 45, gc(c);\r\n\t\twhile ( _isdigit(c) ) x = x * 10 + ( c & 15 ), gc(c);\r\n\t\tif ( flag ) x = -x;\r\n#else\r\n\t\turead(x);\r\n#endif\r\n\t}\r\n\ttemplate < int N, class ...T > struct _tuple_reader\r\n\t{ static IL void _read(tuple < T... > &x) { _tuple_reader < N - 1, T... >::_read(x), read(get < N - 1 > (x)); } };\r\n\ttemplate < class ...T > struct _tuple_reader < 0, T... > { static IL void _read(tuple < T... > &x) {} };\r\n\ttemplate < class ...T > IL void read(tuple < T... > &x) { _tuple_reader < sizeof...(T), T... >::_read(x); }\r\n\ttemplate < class T, class TT > IL void read(pair < T, TT > &x) { read(x.first), read(x.second); }\r\n\ttemplate < class T, class ...TT > IL void read(T &x, TT &...y) { read(x), read(y...); }\r\n\ttemplate < class T, class ...TT > IL void uread(T &x, TT &...y) { uread(x), uread(y...); }\r\n\ttemplate < class ...TT > IL void read_cstr(char *x, TT *...y) { read_cstr(x), read_cstr(y...); }\r\n\tIL void write(const char &c) { pc(c); }\r\n\tIL void write_cstr(const char *s) { while ( *s ) pc(*s++); }\r\n\tIL void write(const string &s) { for ( char c : s ) pc(c); }\r\n\ttemplate < class T, typename enable_if < is_integral < T >::value, int >::type = 0 >\r\n\tinline void uwrite(const T &x) { if ( x > 9 ) uwrite(x / 10); pc(( x % 10 ) | 48); }\r\n\tinline void uwrite(const __int128 &x) { if ( x > 9 ) uwrite(x / 10); pc(( x % 10 ) | 48); }\r\n\tinline void uwrite(const __uint128_t &x) { if ( x > 9 ) uwrite(x / 10); pc(( x % 10 ) | 48); }\r\n\ttemplate < class T, typename enable_if < is_unsigned < T >::value, int >::type = 0 >\r\n\tIL void write(const T &x) { uwrite(x); }\r\n\tIL void write(const __uint128_t &x) { uwrite(x); }\r\n\ttemplate < class T, typename enable_if < is_signed < T >::value, int >::type = 0 >\r\n\tIL void write(const T &x)\r\n\t{\r\n#ifdef OUT_HAS_NEG\r\n\t\tif ( x < 0 ) { pc(45); uwrite(-x); return; }\r\n#endif\r\n\t\tuwrite(x);\r\n\t}\r\n\tIL void write(const __int128 &x)\r\n\t{\r\n#ifdef OUT_HAS_NEG\r\n\t\tif ( x < 0 ) { pc(45); uwrite(-x); return; }\r\n#endif\r\n\t\tuwrite(x);\r\n\t}\r\n\ttemplate < int N, class ...T > struct _tuple_writer\r\n\t{ static IL void _write(const tuple < T... > &x) { _tuple_writer < N - 1, T... >::_write(x), write(N == 1 ? \"\"s : \" \"s), write(get < N - 1 > (x)); } };\r\n\ttemplate < class ...T > struct _tuple_writer < 0, T... > { static IL void _write(const tuple < T... > &x) {} };\r\n\ttemplate < class ...T > IL void write(const tuple < T... > &x) { _tuple_writer < sizeof...(T), T... >::_write(x); }\r\n\ttemplate < class T, class TT > IL void write(const pair < T, TT > &x) { write(x.first), write(' '), write(x.second); }\r\n\ttemplate < class T, class ...TT > IL void write(const T &x, const TT &...y) { write(x), write(y...); }\r\n\ttemplate < class T, class ...TT > IL void uwrite(const T &x, const TT &...y) { uwrite(x), uwrite(y...); }\r\n\ttemplate < class ...TT > IL void write_cstr(const char *x, const TT *...y) { write_cstr(x), write_cstr(y...); }\r\n\ttemplate < class T > IL void print(const T &x) { write(x); }\r\n\ttemplate < class T > IL void uprint(const T &x) { uwrite(x); }\r\n\tIL void print_cstr(const char *x) { write_cstr(x); }\r\n\ttemplate < class T, class ...TT > IL void print(const T &x, const TT &...y) { write(x, ' '), print(y...); }\r\n\ttemplate < class T, class ...TT > IL void uprint(const T &x, const TT &...y) { uwrite(x), write(' '), uprint(y...); }\r\n\ttemplate < class ...TT > IL void print_cstr(const char *x, const TT *...y) { write_cstr(x), write(' '), print_cstr(y...); }\r\n\tIL void println() { write('\\n'); }\r\n\tIL void uprintln() { write('\\n'); }\r\n\tIL void println_cstr() { write('\\n'); }\r\n\ttemplate < class ...T > IL void println(const T &...x) { print(x...), write('\\n'); }\r\n\ttemplate < class ...T > IL void uprintln(const T &...x) { uprint(x...), write('\\n'); }\r\n\ttemplate < class ...T > IL void println_cstr(const T *...x) { print_cstr(x...), write('\\n'); }\r\n}\r\nusing namespace FastIO;\r\nint n, pos, l, r, md; vector < int > qwq, ans;\r\ninline int query(const vector < int > &x, const vector < int > &y)\r\n{\r\n\tcout << \"? \" << x.size() << ' ' << y.size() << '\\n';\r\n\tfor ( int i : x ) cout << i << ( i == x.back() ? '\\n' : ' ' );\r\n\tfor ( int i : y ) cout << i << ( i == y.back() ? '\\n' : ' ' );\r\n\tint ret; cout.flush(), cin >> ret; return ret;\r\n}\r\ninline void answer(const vector < int > &x)\r\n{\r\n\tcout << \"! \" << x.size() << ' ';\r\n\tfor ( int i : x ) cout << i << ( i == x.back() ? '\\n' : ' ' );\r\n\tcout.flush();\r\n}\r\ninline void work()\r\n{\r\n\tcin >> n, ans.clear(), qwq.clear();\r\n\tFor(i, 2, n)\r\n\t{\r\n\t\tqwq.push_back(i - 1);\r\n\t\tif ( query(qwq, { i }) ) { pos = i; break; }\r\n\t}\r\n\tFor(i, pos + 1, n) if ( !query({ pos }, { i }) ) ans.push_back(i);\r\n\tfor ( l = 1, r = pos - 1 ; l < r ; )\r\n\t{\r\n\t\tmd = ( l + r ) >> 1, qwq.clear();\r\n\t\tFor(i, l, md) qwq.push_back(i);\r\n\t\tquery(qwq, { pos }) ? r = md : l = md + 1;\r\n\t}\r\n\tFor(i, 1, pos - 1) if ( i != l ) ans.push_back(i);\r\n\tsort(ans.begin(), ans.end()), answer(ans);\r\n}\r\nint main() { int t; cin >> t; For(tt, 1, t) work(); return 0; }\r\n// \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f"
}