{
    "id": 193703608,
    "contestId": 1157,
    "creationTimeSeconds": 1676458989,
    "relativeTimeSeconds": 1149,
    "problem": {
        "contestId": 1157,
        "index": "A",
        "name": "Reachable Numbers",
        "type": "PROGRAMMING",
        "rating": 1100,
        "tags": [
            "implementation"
        ]
    },
    "author": {
        "contestId": 1157,
        "members": [
            {
                "handle": "Codey_Bryant"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1676457840
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 130,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 102400,
    "source": "/*\r\n    \u0915\u0930\u094d\u092e\u0923\u094d\u092f\u0947\u0935\u093e\u0927\u093f\u0915\u093e\u0930\u0938\u094d\u0924\u0947 \u092e\u093e \u092b\u0932\u0947\u0937\u0941 \u0915\u0926\u093e\u091a\u0928 \u0964\r\n    \u092e\u093e \u0915\u0930\u094d\u092e\u092b\u0932\u0939\u0947\u0924\u0941\u0930\u094d\u092d\u0941\u0930\u094d\u092e\u093e \u0924\u0947 \u0938\u0902\u0917\u094b\u093d\u0938\u094d\u0924\u094d\u0935\u0915\u0930\u094d\u092e\u0923\u093f \u0965\r\n\u0905\u0930\u094d\u0925:- \u0924\u0947\u0930\u093e \u0915\u0930\u094d\u092e \u0915\u0930\u0928\u0947 \u092e\u0947\u0902 \u0905\u0927\u093f\u0915\u093e\u0930 \u0939\u0948 \u0907\u0928\u0915\u0947 \u092b\u0932\u094b \u092e\u0947\u0902 \u0928\u0939\u0940. \u0924\u0942 \u0915\u0930\u094d\u092e \u0915\u0947 \u092b\u0932 \u092a\u094d\u0930\u0924\u093f \u0905\u0938\u0915\u094d\u0924 \u0928 \u0939\u094b \u092f\u093e \u0915\u0930\u094d\u092e \u0928 \u0915\u0930\u0928\u0947 \u0915\u0947 \u092a\u094d\u0930\u0924\u093f \u092a\u094d\u0930\u0947\u0930\u093f\u0924 \u0928 \u0939\u094b.\r\n*/\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <climits>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\r\n             tree_order_statistics_node_update>\r\n    new_data_set;\r\n\r\n#define int long long int\r\n#define F first\r\n#define MP make_pair\r\n#define S second\r\n#define pb push_back\r\n#define si set<int>\r\n#define usi unordered_set<int>\r\n#define umsi unordered_multiset<int>\r\n#define msi multiset<int>\r\n#define vi vector<int>\r\n#define vvi vector<vector<int>>\r\n#define pii pair<int, int>\r\n#define vpi vector<pii>\r\n#define vpp vector<pair<int, pii>>\r\n#define mii map<int, int>\r\n#define umii unordered_map<int, int>\r\n#define mpi map<pii, int>\r\n#define umpi unordered_map<pii, int>\r\n#define spi set<pii>\r\n#define endl \"\\n\"\r\n#define sz(x) ((int)x.size())\r\n#define all(p) p.begin(), p.end()\r\n#define double long double\r\n#define que_max priority_queue<int>\r\n#define countSetBits(a) __builtin_popcount(a)\r\n#define que_min priority_queue<int, vi, greater<int>>\r\n#define bug(...) __f(#__VA_ARGS__, __VA_ARGS__)\r\n#define print(a)          \\\r\n    for (auto x : a)      \\\r\n        cout << x << \" \"; \\\r\n    cout << endl\r\n#define print1(a)    \\\r\n    for (auto x : a) \\\r\n    cout << x.F << \" \" << x.S << endl\r\n#define print2(a, x, y)         \\\r\n    for (int i = x; i < y; i++) \\\r\n        cout << a[i] << \" \";    \\\r\n    cout << endl\r\n\r\nconst int N = 200005;\r\nconst int mod = 1000000007;\r\nconstexpr int inf = numeric_limits<int>::max() / 2;\r\n\r\ninline int power(int a, int b)\r\n{\r\n    int x = 1;\r\n    while (b)\r\n    {\r\n        if (b & 1)\r\n            x *= a;\r\n        a *= a;\r\n        b >>= 1;\r\n    }\r\n    return x;\r\n}\r\n//for modular multiplicative inverse pass expo as mod-2\r\nint modularPower(int base, int expo)\r\n{\r\n    int res = 1;\r\n    while (expo > 0)\r\n    {\r\n        if (expo % 2 == 1)\r\n        {\r\n            res = (res * base) % mod;\r\n        }\r\n        expo >>= 1;\r\n        base = (base * base) % mod;\r\n    }\r\n    return res % mod;\r\n}\r\n\r\nint isSubstring(string s2, string s1)\r\n{\r\n    if (s2.find(s1) != string::npos)\r\n        return s2.find(s1);\r\n    return -1;\r\n}\r\n\r\ntemplate <typename Arg1>\r\nvoid __f(const char *name, Arg1 &&arg1) { cout << name << \" : \" << arg1 << endl; }\r\ntemplate <typename Arg1, typename... Args>\r\nvoid __f(const char *names, Arg1 &&arg1, Args &&...args)\r\n{\r\n    const char *comma = strchr(names + 1, ',');\r\n    cout.write(names, comma - names) << \" : \" << arg1 << \" | \";\r\n    __f(comma + 1, args...);\r\n}\r\n\r\nvi factorial;\r\n\r\nvoid init_factorial()\r\n{\r\n    factorial.resize(300005);\r\n    factorial[0] = 1ll;\r\n    for (int n = 1; n <= 300000; ++n)\r\n    {\r\n        factorial[n] = (factorial[n - 1] * n) % mod;\r\n    }\r\n}\r\n\r\nclass SegmentTree\r\n{\r\nprivate:\r\n    vi st, A, lazy;\r\n    int n;\r\n    int left(int p) { return p << 1; }\r\n    int right(int p) { return (p << 1) + 1; }\r\n    void build(int p, int L, int R)\r\n    {\r\n        if (L == R)\r\n            st[p] = A[L];\r\n        else\r\n        {\r\n            build(left(p), L, (L + R) / 2);\r\n            build(right(p), (L + R) / 2 + 1, R);\r\n            int p1 = left(p), p2 = right(p);\r\n            st[p] = min(st[p1], st[p2]);\r\n        }\r\n    }\r\n    int rsq(int node, int start, int endd, int l, int r)\r\n    {\r\n        if (start > endd or start > r or endd < l)\r\n            return 10000000;\r\n        if (lazy[node] != 0)\r\n        {\r\n            st[node] += lazy[node];\r\n            if (start != endd)\r\n            {\r\n                lazy[node * 2] += lazy[node];\r\n                lazy[node * 2 + 1] += lazy[node];\r\n            }\r\n            lazy[node] = 0;\r\n        }\r\n        if (start >= l and endd <= r)\r\n            return st[node];\r\n        int mid = (start + endd) / 2;\r\n        int p1 = rsq(node * 2, start, mid, l, r);\r\n        int p2 = rsq(node * 2 + 1, mid + 1, endd, l, r);\r\n        return min(p1, p2);\r\n    }\r\n    void updateRange(int node, int start, int endd, int l, int r, int val)\r\n    {\r\n        if (lazy[node] != 0)\r\n        {\r\n            st[node] += lazy[node];\r\n            if (start != endd)\r\n            {\r\n                lazy[node * 2] += lazy[node];\r\n                lazy[node * 2 + 1] += lazy[node];\r\n            }\r\n            lazy[node] = 0;\r\n        }\r\n        if (start > endd or start > r or endd < l)\r\n            return;\r\n        if (start >= l and endd <= r)\r\n        {\r\n            st[node] += val;\r\n            if (start != endd)\r\n            {\r\n                lazy[node * 2] += val;\r\n                lazy[node * 2 + 1] += val;\r\n            }\r\n            return;\r\n        }\r\n        int mid = (start + endd) / 2;\r\n        updateRange(node * 2, start, mid, l, r, val);\r\n        updateRange(node * 2 + 1, mid + 1, endd, l, r, val);\r\n        st[node] = min(st[node * 2], st[node * 2 + 1]);\r\n    }\r\n\r\npublic:\r\n    SegmentTree(const vi &_A)\r\n    {\r\n        A = _A;\r\n        n = (int)A.size();\r\n        st.assign(4 * n, 0);\r\n        lazy.assign(4 * n, 0);\r\n        build(1, 0, n - 1);\r\n    }\r\n    int rsq(int i, int j) { return rsq(1, 0, n - 1, i, j); }\r\n    void updateRange(int i, int j, int v) { updateRange(1, 0, n - 1, i, j, v); }\r\n};\r\n\r\nvoid solve()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    mii mp;\r\n    int x = n;\r\n    n = n + 1;\r\n    while (n % 10 == 0)\r\n    {\r\n        n = n / 10;\r\n    }\r\n    int ans = 0;\r\n    while (1)\r\n    {\r\n        if (mp.count(n))\r\n        {\r\n            break;\r\n        }\r\n        // cout << n << \"\\n\";\r\n        mp[n]++;\r\n        ans++;\r\n        n = n + 1;\r\n        while (n % 10 == 0)\r\n        {\r\n            n = n / 10;\r\n        }\r\n    }\r\n    if (mp.count(x) == 0)\r\n    {\r\n        cout << mp.size() + 1;\r\n    }\r\n    else\r\n    {\r\n        cout << mp.size();\r\n    }\r\n}\r\n\r\nint32_t main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\r\n    clock_t z = clock();\r\n\r\n    int t = 1;\r\n    // cin >> t;\r\n    while (t--)\r\n        solve();\r\n\r\n    cerr << \"Run Time : \" << ((double)(clock() - z) / CLOCKS_PER_SEC);\r\n\r\n    return 0;\r\n}"
}