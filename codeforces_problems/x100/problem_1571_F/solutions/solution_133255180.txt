{
    "id": 133255180,
    "contestId": 1571,
    "creationTimeSeconds": 1635342103,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1571,
        "index": "F",
        "name": "Kotlinforces",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "*special",
            "constructive algorithms",
            "dp"
        ]
    },
    "author": {
        "contestId": 1571,
        "members": [
            {
                "handle": "ShlokG"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1633617300
    },
    "programmingLanguage": "Kotlin 1.4",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 88,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 40652800,
    "source": "import Main.IO\r\nimport java.io.*\r\nimport java.lang.Exception\r\nimport java.util.*\r\nimport kotlin.Throws\r\nimport kotlin.jvm.JvmStatic\r\n\r\nobject Main {\r\n    var `in`: IO? = null\r\n    var out: PrintWriter? = null\r\n    @Throws(Exception::class)\r\n    fun init_io(filename: String) {\r\n        if (filename == \"\") {\r\n            `in` = IO(System.`in`)\r\n            out = PrintWriter(BufferedWriter(OutputStreamWriter(System.out)), true)\r\n        } else {\r\n            `in` = IO(FileInputStream(\"$filename.in\"))\r\n            out = PrintWriter(BufferedWriter(FileWriter(\"$filename.out\")), true)\r\n        }\r\n    }\r\n\r\n    const val mod: Long = 1000000007\r\n\r\n    /*\r\nfun main(args: Array<String>) {\r\n    Main.main(args);\r\n}\r\n*/\r\n    /* todo list\r\n- stick main snippet at bottom\r\n- remove \"internal\" from IO class (and all static classes)\r\n- remove question marks (?) from comparable stuff (ex: <Edge?> -> <Edge>)\r\n*/\r\n    @Throws(Exception::class)\r\n    fun solve(tc: Int) {\r\n        val n = `in`!!.nint()\r\n        val m = `in`!!.nint()\r\n        val ans = IntArray(n + 1)\r\n        val a = IntArray(n + 1)\r\n        val arr = ArrayList<pair>()\r\n        var cnt = 0\r\n        var tot = 0\r\n        for (i in 1..n) {\r\n            val k = `in`!!.nint()\r\n            val t = `in`!!.nint()\r\n            a[i] = k\r\n            tot += k\r\n            if (t == 1) {\r\n                ans[i] = cnt + 1\r\n                cnt += k\r\n            } else {\r\n                arr.add(pair(k, i))\r\n            }\r\n        }\r\n        if (tot > m) {\r\n            out!!.println(-1)\r\n            return\r\n        }\r\n        val odd = (m - cnt + 1) / 2\r\n        val even = m - cnt - odd\r\n        tot -= cnt\r\n        val n1 = arr.size\r\n        val pos = Array(n1 + 1) { IntArray(odd + 1) }\r\n        for (i in 0..n1) {\r\n            for (j in 0..odd) {\r\n                pos[i][j] = -1\r\n            }\r\n        }\r\n        pos[0][0] = 1\r\n        for (i in 0 until n1) {\r\n            val x = arr[i].first\r\n            val ind = arr[i].second\r\n            for (j in odd downTo x) {\r\n                if (pos[i][j - x] != -1 && pos[i][j] == -1) {\r\n                    pos[i + 1][j] = ind\r\n                } else {\r\n                    pos[i + 1][j] = pos[i][j]\r\n                }\r\n            }\r\n            for (j in x - 1 downTo 0) {\r\n                pos[i + 1][j] = pos[i][j]\r\n            }\r\n        }\r\n        for (i in odd downTo 0) {\r\n            if (pos[n1][i] != -1) {\r\n                if (tot - i > even) {\r\n                    out!!.println(-1)\r\n                    return\r\n                }\r\n                var rem = i\r\n                var cur = 1\r\n                while (rem > 0) {\r\n                    ans[pos[n1][rem]] = cnt + cur\r\n                    cur += 2 * a[pos[n1][rem]]\r\n                    rem -= a[pos[n1][rem]]\r\n                }\r\n                cnt++\r\n                cur = 1\r\n                for (j in 1..n) {\r\n                    if (ans[j] != 0) continue\r\n                    ans[j] = cnt + cur\r\n                    cur += 2 * a[j]\r\n                }\r\n                for (j in 1..n) {\r\n                    out!!.print(ans[j].toString() + \" \")\r\n                }\r\n                out!!.println()\r\n                return\r\n            }\r\n        }\r\n        out!!.println(-1)\r\n    }\r\n\r\n    @Throws(Exception::class)\r\n    @JvmStatic\r\n    fun main(_u_n_u_s_e_d_: Array<String>) {\r\n        init_io(\"\")\r\n        val t = 1\r\n        //t = in.nint();\r\n        for (tc in 0 until t) {\r\n            solve(tc)\r\n        }\r\n    }\r\n\r\n    fun minv(v: Long): Long {\r\n        return mpow(v, mod - 2)\r\n    }\r\n\r\n    fun mpow(base: Long, exp: Long): Long {\r\n        var base = base\r\n        var exp = exp\r\n        var res: Long = 1\r\n        while (exp > 0) {\r\n            if (exp and 1 == 1L) {\r\n                res = res * base % mod\r\n            }\r\n            base = base * base % mod\r\n            exp = exp shr 1\r\n        }\r\n        return res\r\n    }\r\n\r\n    fun gcd(x: Int, y: Int): Int {\r\n        if (x == 0) return y\r\n        return if (y == 0) x else gcd(y % x, x)\r\n    }\r\n\r\n    fun rsort(arr: LongArray) {\r\n        val r = Random()\r\n        for (i in arr.indices) {\r\n            val j = i + r.nextInt(arr.size - i)\r\n            val t = arr[i]\r\n            arr[i] = arr[j]\r\n            arr[j] = t\r\n        }\r\n        Arrays.sort(arr)\r\n    }\r\n\r\n    fun rsort(arr: IntArray) {\r\n        val r = Random()\r\n        for (i in arr.indices) {\r\n            val j = i + r.nextInt(arr.size - i)\r\n            val t = arr[i]\r\n            arr[i] = arr[j]\r\n            arr[j] = t\r\n        }\r\n        Arrays.sort(arr)\r\n    }\r\n\r\n    /* static void qsort(long[] arr) {\r\n    Long[] oarr = new Long[arr.length];\r\n    for (int i = 0; i < arr.length; i++) {\r\n      oarr[i] = arr[i];\r\n    }\r\n\r\n    ArrayList<Long> alist = new ArrayList<Long>(Arrays.asList(oarr));\r\n    Collections.sort(alist);\r\n\r\n    for (int i = 0; i < arr.length; i++) {\r\n      arr[i] = (long)alist.get(i);\r\n    }\r\n  } */\r\n    fun reverse(arr: LongArray) {\r\n        for (i in 0 until arr.size / 2) {\r\n            val temp = arr[i]\r\n            arr[i] = arr[arr.size - 1 - i]\r\n            arr[arr.size - 1 - i] = temp\r\n        }\r\n    }\r\n\r\n    fun atos(arr: LongArray?): String {\r\n        var s = Arrays.toString(arr)\r\n        s = s.substring(1, s.length - 1)\r\n        return s.replace(\",\", \"\")\r\n    }\r\n\r\n    class IO(x: InputStream?) {\r\n        var `in`: BufferedReader\r\n        var tokens: StringTokenizer\r\n        @Throws(Exception::class)\r\n        fun nint(): Int {\r\n            return nstr().toInt()\r\n        }\r\n\r\n        @Throws(Exception::class)\r\n        fun nlong(): Long {\r\n            return nstr().toLong()\r\n        }\r\n\r\n        @Throws(Exception::class)\r\n        fun ndouble(): Double {\r\n            return nstr().toDouble()\r\n        }\r\n\r\n        @Throws(Exception::class)\r\n        fun nstr(): String {\r\n            if (!tokens.hasMoreTokens()) tokens = StringTokenizer(`in`.readLine())\r\n            return tokens.nextToken()\r\n        }\r\n\r\n        @Throws(Exception::class)\r\n        fun nla(n: Int): LongArray {\r\n            val arr = LongArray(n)\r\n            for (i in 0 until n) {\r\n                arr[i] = nlong()\r\n            }\r\n            return arr\r\n        }\r\n\r\n        init {\r\n            `in` = BufferedReader(InputStreamReader(x))\r\n            tokens = StringTokenizer(`in`.readLine())\r\n        }\r\n    } // static class Pair<A extends Comparable<A>, B extends Comparable<B>> implements Comparable<Pair<A, B>> {\r\n    // public A f;\r\n    // public B s;\r\n    // public Pair(A a, B b) {\r\n    // f = a;\r\n    // s = b;\r\n    // }\r\n    // public int compareTo(Pair<A, B> other) {\r\n    // int v = f.compareTo(other.f);\r\n    // if (v != 0) return v;\r\n    // return s.compareTo(other.s);\r\n    // }\r\n    // public String toString() {\r\n    // return \"(\" + f.toString() + \", \" + s.toString() + \")\";\r\n    // }\r\n    // }\r\n}\r\n\r\ninternal class pair(x: Int, y: Int) {\r\n    var first = 0\r\n    var second = 0\r\n\r\n    init {\r\n        first = x\r\n        second = y\r\n    }\r\n}\r\n\r\ninternal class Comp : Comparator<pair> {\r\n    override fun compare(\r\n        a: pair,\r\n        b: pair\r\n    ): Int {         //override. must be public. cannot reduce the visibility (this method is public in Comparator)\r\n        return if (a.first === b.first) {\r\n            a.second.compareTo(b.second)\r\n        } else a.first.compareTo(b.first)\r\n        //a<b        //Integer objects have natural ordering(i.e., they implement Comparable)\r\n    }\r\n}\r\n\r\nfun main(args: Array<String>) {\r\n    Main.main(args);\r\n}"
}