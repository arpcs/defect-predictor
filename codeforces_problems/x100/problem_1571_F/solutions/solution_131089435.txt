{
    "id": 131089435,
    "contestId": 1571,
    "creationTimeSeconds": 1633625142,
    "relativeTimeSeconds": 7842,
    "problem": {
        "contestId": 1571,
        "index": "F",
        "name": "Kotlinforces",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "*special",
            "constructive algorithms",
            "dp"
        ]
    },
    "author": {
        "contestId": 1571,
        "members": [
            {
                "handle": "songsinger"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1633617300
    },
    "programmingLanguage": "Kotlin 1.4",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 88,
    "timeConsumedMillis": 1669,
    "memoryConsumedBytes": 254976000,
    "source": "import java.io.InputStreamReader\r\nimport java.io.PrintWriter\r\nimport java.util.*\r\nimport kotlin.math.*\r\n\r\nfun main() {\r\n    val tests = 1\r\n\r\n    for (test in 1 .. tests) {\r\n        val n = readInt()\r\n        val m = readInt()\r\n        val kt = (1..n).map { readInt() to readInt() }\r\n        val kt1 = kt.filter { it.second == 1 }.map { it.first }.sum()\r\n        val kti = kt.mapIndexed { i, v -> v to i }.filter { it.first.second == 2 }.map { it.second }\r\n        val kt2 = kt.filter { it.second == 2 }.map { it.first }\r\n\r\n        val (p, res) = solve(m - kt1, kt2, kti, n)\r\n\r\n        if (!p) {\r\n            writeln(-1)\r\n        } else {\r\n            var max = m - kt1 + 1\r\n            for (i in 0 until n) {\r\n                if (kt[i].second == 1) {\r\n                    res[i] = max\r\n                    max += kt[i].first\r\n                }\r\n            }\r\n            writeln(res.joinToString(\" \"))\r\n        }\r\n\r\n    }\r\n\r\n    closeWriter()\r\n}\r\n\r\nfun solve(m: Int, kt: List<Int>, idx: List<Int>, n: Int): Pair<Boolean, IntArray> {\r\n    if (kt.isEmpty()) {\r\n        return (m >= 0) to IntArray(n)\r\n    }\r\n    if (m < 0) {\r\n        return false to IntArray(n)\r\n    }\r\n    val g1 = m / 2\r\n    val g2 = m - g1\r\n    val s = kt.sum()\r\n\r\n    val dp = BooleanArray(m + 1)\r\n    val from = Array(m + 1) { mutableSetOf<Int>() }\r\n    dp[0] = true\r\n\r\n    for ((i, v) in kt.withIndex()) {\r\n        for (j in m - v downTo 0) {\r\n            if (dp[j]) {\r\n                dp[j + v] = true\r\n                from[j + v].add(i)\r\n            }\r\n        }\r\n    }\r\n\r\n    val res1 = mutableSetOf<Int>()\r\n    val res2 = (0 until kt.size).toMutableSet()\r\n    var possible = false\r\n    for (i in 0 until m + 1) {\r\n        if (dp[i] && i <= g1 && s - i <= g2) {\r\n            possible = true\r\n\r\n            var t = i\r\n            while (t > 0) {\r\n                for (ix in from[t]) {\r\n                    if (ix !in res1) {\r\n                        res1.add(ix)\r\n                        res2.remove(ix)\r\n                        t -= kt[ix]\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            break\r\n        }\r\n        if (dp[i] && i <= g2 && s - i <= g1) {\r\n            possible = true\r\n\r\n            var t = i\r\n            while (t > 0) {\r\n                for (ix in from[t]) {\r\n                    if (ix !in res1) {\r\n                        res1.add(ix)\r\n                        res2.remove(ix)\r\n                        t -= kt[ix]\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            break\r\n        }\r\n    }\r\n\r\n    val s1 = res1.map { kt[it] }.sum()\r\n    val res = IntArray(n)\r\n    if (possible && s1 >= s - s1) {\r\n        var first = 1\r\n        for (v in res1) {\r\n            res[idx[v]] = first\r\n            first += 2 * kt[v]\r\n        }\r\n        var second = 2\r\n        for (v in res2) {\r\n            res[idx[v]] = second\r\n            second += 2 * kt[v]\r\n        }\r\n    } else {\r\n        if (possible && s1 < s - s1) {\r\n            var first = 1\r\n            for (v in res2) {\r\n                res[idx[v]] = first\r\n                first += 2 * kt[v]\r\n            }\r\n            var second = 2\r\n            for (v in res1) {\r\n                res[idx[v]] = second\r\n                second += 2 * kt[v]\r\n            }\r\n        }\r\n    }\r\n    return possible to res\r\n}\r\n\r\nfun gcd(a: Long, b: Long) : Long {\r\n    if (b == 0L) {\r\n        return a\r\n    }\r\n    return gcd(b, a % b)\r\n}\r\n\r\nfun gcd(a: Int, b: Int) : Int {\r\n    if (b == 0) {\r\n        return a\r\n    }\r\n    return gcd(b, a % b)\r\n}\r\n\r\nfun readListInt(n: Int) = (1..n).map { readInt() }\r\n\r\nfun readListLong(n: Int) = (1..n).map { readLong() }\r\n\r\nfun readListString(n: Int) = (1..n).map { read() }\r\n\r\nfun zFunc(s: String): IntArray {\r\n    val z = IntArray(s.length)\r\n\r\n    var l = 0\r\n    var r = 0\r\n    for (i in 1 until s.length) {\r\n        if (i < r) {\r\n            z[i] = minOf(r - i + 1, z[i - l])\r\n        }\r\n        while (i + z[i] < s.length && s[z[i]] == s[i + z[i]]) {\r\n            z[i]++\r\n        }\r\n\r\n        if (r < i + z[i] - 1) {\r\n            r = i + z[i] - 1\r\n            l = i\r\n        }\r\n    }\r\n\r\n    return z\r\n}\r\n\r\nfun String.fastContains(p: String): Boolean {\r\n    if (p.length > this.length) {\r\n        return false\r\n    }\r\n    val s = \"$p\\u0001$this\"\r\n    return zFunc(s).contains(p.length)\r\n}\r\n\r\nclass Graph(size: Int) {\r\n    private val g = Array(size) { mutableListOf<Edge>() }\r\n\r\n    fun addEdge(from: Int, to: Int, w: Int = 1) = g[from].add(Edge(from, to, w))\r\n\r\n    fun getEdges(from: Int) = g[from]\r\n\r\n    fun getAllEdges() = g.flatMap { it }\r\n}\r\n\r\ndata class Edge(val from: Int, val to: Int, val w: Int = 1)\r\n\r\ndata class FlowEdge(val from: Int, val to: Int, val capacity: Int) {\r\n    var flow = 0\r\n\r\n    fun residual() = capacity - flow\r\n}\r\n\r\nclass FlowGraph(val n: Int) {\r\n    val from = Array(n) { mutableListOf<FlowEdge>() }\r\n    val to = Array(n) { mutableListOf<FlowEdge>() }\r\n\r\n    fun addEdge(f: Int, t: Int, c: Int = 1): FlowEdge {\r\n        val e = FlowEdge(f, t, c)\r\n        from[f].add(e)\r\n        to[t].add(e)\r\n        return e\r\n    }\r\n\r\n    fun findMaxFlow(source: Int, sink: Int): Int {\r\n        while (tryToAddFlow(source, sink)) {\r\n            //do nothing\r\n        }\r\n\r\n        return from[source].sumBy { it.flow }\r\n    }\r\n\r\n    private fun tryToAddFlow(source: Int, sink: Int): Boolean {\r\n        val visited = BooleanArray(n)\r\n        val cameByEdge = Array<FlowEdge?>(n) { null }\r\n        visited[source] = true\r\n        val queue = LinkedList<Int>()\r\n        queue.add(source)\r\n\r\n        while (queue.isNotEmpty()) {\r\n            val v = queue.poll()\r\n\r\n            for (e in from[v]) {\r\n                if (!visited[e.to] && e.residual() > 0) {\r\n                    visited[e.to] = true\r\n                    cameByEdge[e.to] = e\r\n                    queue.add(e.to)\r\n                }\r\n            }\r\n\r\n            for (e in to[v]) {\r\n                if (!visited[e.from] && e.flow > 0) {\r\n                    visited[e.from] = true\r\n                    cameByEdge[e.from] = e\r\n                    queue.add(e.from)\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!visited[sink]) {\r\n            return false\r\n        }\r\n\r\n        var v = sink\r\n        var maxFlow = Int.MAX_VALUE\r\n        while (cameByEdge[v] != null) {\r\n            val e = cameByEdge[v]!!\r\n            if (e.to == v) {\r\n                maxFlow = minOf(maxFlow, e.residual())\r\n                v = e.from\r\n            } else {\r\n                maxFlow = minOf(maxFlow, e.flow)\r\n                v = e.to\r\n            }\r\n        }\r\n\r\n        v = sink\r\n        while (cameByEdge[v] != null) {\r\n            val e = cameByEdge[v]!!\r\n            if (e.to == v) {\r\n                e.flow += maxFlow\r\n                v = e.from\r\n            } else {\r\n                e.flow -= maxFlow\r\n                v = e.to\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n}\r\n\r\nclass SegmentTree(n: Int) {\r\n\r\n    private val base = (2.0.pow(ceil(log2(n.toDouble())))).toInt()\r\n    private val a = LongArray(base * 2)\r\n\r\n    fun agg(left: Int, right: Int): Long {\r\n        var l = left + base\r\n        var r = right + base\r\n\r\n        var agg = 0L\r\n        while (l < r) {\r\n            if (l % 2 != 0) {\r\n                agg += a[l++]\r\n            }\r\n            if (r % 2 == 0) {\r\n                agg += a[r--]\r\n            }\r\n            l /= 2\r\n            r /= 2\r\n        }\r\n\r\n        if (l == r) {\r\n            agg += a[l]\r\n        }\r\n        return agg\r\n    }\r\n\r\n    fun set(pos: Int, v: Long) {\r\n        var i = pos + base\r\n        a[i] = v\r\n        i /= 2\r\n        while (i > 0) {\r\n            a[i] = a[i * 2] + a[i * 2 + 1]\r\n            i /= 2\r\n        }\r\n    }\r\n}\r\n\r\nfun writeln(obj: Any) {\r\n    writer.writeln(obj)\r\n}\r\n\r\nfun writeln() {\r\n    writer.writeln()\r\n}\r\n\r\nfun closeWriter() {\r\n    writer.close()\r\n}\r\n\r\nobject writer {\r\n    private val writer = PrintWriter(System.out)\r\n\r\n    fun writeln(obj: Any) {\r\n        writer.println(obj)\r\n        //writer.flush()\r\n    }\r\n\r\n    fun writeln() {\r\n        writer.println()\r\n        //writer.flush()\r\n    }\r\n\r\n    fun close() {\r\n        writer.close()\r\n    }\r\n}\r\n\r\nfun read() = reader.next()\r\n\r\nfun readInt() = reader.nextInt()\r\n\r\nfun readLong() = reader.nextLong()\r\n\r\nfun readDouble() = reader.nextDouble()\r\n\r\nfun readLn() = reader.nextLine()\r\n\r\nobject reader {\r\n    private var tokens: StringTokenizer? = null\r\n    private val reader = InputStreamReader(System.`in`).buffered()\r\n\r\n    fun next(): String {\r\n        var hasNext = tokens?.hasMoreElements() ?: false\r\n        while (!hasNext) {\r\n            tokens = StringTokenizer(reader.readLine())\r\n            hasNext = tokens?.hasMoreElements() ?: false\r\n        }\r\n\r\n        return tokens!!.nextToken()\r\n    }\r\n\r\n    fun nextLine(): String {\r\n        tokens = null\r\n        return reader.readLine()\r\n    }\r\n\r\n    fun nextInt() = next().toInt()\r\n\r\n    fun nextLong() = next().toLong()\r\n\r\n    fun nextDouble() = next().toDouble()\r\n}"
}