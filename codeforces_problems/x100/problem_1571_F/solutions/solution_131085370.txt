{
    "id": 131085370,
    "contestId": 1571,
    "creationTimeSeconds": 1633621562,
    "relativeTimeSeconds": 4262,
    "problem": {
        "contestId": 1571,
        "index": "F",
        "name": "Kotlinforces",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "*special",
            "constructive algorithms",
            "dp"
        ]
    },
    "author": {
        "contestId": 1571,
        "members": [
            {
                "handle": "arvindf232"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1633617300
    },
    "programmingLanguage": "Kotlin 1.5",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 88,
    "timeConsumedMillis": 248,
    "memoryConsumedBytes": 33382400,
    "source": "import java.io.BufferedInputStream\r\nimport java.io.PrintWriter\r\nimport kotlin.system.measureTimeMillis\r\n\r\ninline fun TIME(f:()->Unit){\r\n\tval t = measureTimeMillis(){\r\n\t\tf()\r\n\t}\r\n\tprintln(t)\r\n}\r\n\r\nobject IO{\r\n\tprivate const val BS = 1 shl 16\r\n\tprivate const val NC = 0.toChar()\r\n\tprivate val buf = ByteArray(BS)\r\n\tprivate var bId = 0\r\n\tprivate var size = 0\r\n\tprivate var c = NC\r\n\r\n\tvar warningActive = true\r\n\tvar fakein = StringBuilder()\r\n\r\n\tprivate var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)\r\n\tval OUT: PrintWriter = PrintWriter(System.out)\r\n\r\n\tprivate val char: Char\r\n\t\tget() {\r\n\t\t\twhile (bId == size) {\r\n\t\t\t\tsize = IN.read(buf) // no need for checked exceptions\r\n\t\t\t\tif (size == -1) return NC\r\n\t\t\t\tbId = 0\r\n\t\t\t}\r\n\t\t\treturn buf[bId++].toChar()\r\n\t\t}\r\n\r\n\tfun nextInt(): Int {\r\n\t\tvar neg = false\r\n\t\tif (c == NC) c = char\r\n\t\twhile (c < '0' || c > '9') {\r\n\t\t\tif (c == '-') neg = true\r\n\t\t\tc = char\r\n\t\t}\r\n\t\tvar res = 0\r\n\t\twhile (c in '0'..'9') {\r\n\t\t\tres = (res shl 3) + (res shl 1) + (c - '0')\r\n\t\t\tc = char\r\n\t\t}\r\n\t\treturn if (neg) -res else res\r\n\t}\r\n\tfun nextLong(): Long {\r\n\t\tvar neg = false\r\n\t\tif (c == NC) c = char\r\n\t\twhile (c < '0' || c > '9') {\r\n\t\t\tif (c == '-') neg = true\r\n\t\t\tc = char\r\n\t\t}\r\n\t\tvar res = 0L\r\n\t\twhile (c in '0'..'9') {\r\n\t\t\tres = (res shl 3) + (res shl 1) + (c - '0')\r\n\t\t\tc = char\r\n\t\t}\r\n\t\treturn if (neg) -res else res\r\n\t}\r\n\tfun nextString():String{\r\n\t\tif (c == NC) c = char\r\n\t\tval ret = StringBuilder()\r\n\t\twhile (true){\r\n\t\t\tc = char\r\n\t\t\tif(!isWhitespace(c)){ break}\r\n\t\t}\r\n\t\tret.append(c)\r\n\t\twhile (true){\r\n\t\t\tc = char\r\n\t\t\tif(isWhitespace(c)){ break}\r\n\t\t\tret.append(c)\r\n\t\t}\r\n\t\treturn ret.toString()\r\n\t}\r\n\tfun isWhitespace(c:Char):Boolean{\r\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t'\r\n\t}\r\n\tfun rerouteInput(){\r\n\t\tif(warningActive){\r\n\t\t\tSystem.err.println(\"Not accepting inputs!\")\r\n\t\t\twarningActive = false\r\n\t\t}\r\n\t\tIN = BufferedInputStream(fakein.toString().byteInputStream(),BS)\r\n\t}\r\n\r\n//    init {\r\n//        IN = BufferedInputStream(System.`in`, BS)\r\n//    }\r\n}\r\n//class reading{\r\n//    companion object{\r\n//        var jin = FastScanner()\r\n//        var pw = PrintWriter(System.out)\r\n//    }\r\n//}\r\nfun put(aa:Any){ IO.OUT.println(aa)}\r\nfun done(){ IO.OUT.close() }\r\nfun share(aa:Any){\r\n\tif(aa is IntArray){IO.fakein.append(aa.joinToString(\" \"))}\r\n\telse if(aa is LongArray){IO.fakein.append(aa.joinToString(\" \"))}\r\n\telse if(aa is List<*>){IO.fakein.append(aa.toString())}\r\n\telse{IO.fakein.append(aa.toString())}\r\n\tIO.fakein.append(\"\\n\")\r\n}\r\n\r\nfun getint():Int{ return IO.nextInt() }\r\nfun getlong():Long{ return IO.nextLong() }\r\nfun getline(n:Int):List<Int>{ return (1..n).map{IO.nextInt()} }\r\nfun getlineL(n:Int):List<Long>{return (1..n).map{IO.nextLong()} }\r\nfun getstr():String{ return IO.nextString() }\r\nfun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}\r\nfun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}\r\ninline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }}\r\n\r\nval List<Char>.ret:String\r\n\tget() = this.joinToString(\"\")\r\ninfix fun Any.dei(a:Any){\r\n\t//does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators\r\n\tvar str = \"\"\r\n\tif(this is String){ str = this\r\n\t}else if(this is Int){ str = this.toString()\r\n\t}else if(this is Long){ str = this.toString()\r\n\t}\r\n\tif(a is List<*>){ println(\"$str : ${a.joinToString(\" \")}\")\r\n\t}else if(a is IntArray){ println(\"$str : ${a.joinToString(\" \")}\")\r\n\t}else if(a is LongArray){ println(\"$str : ${a.joinToString(\" \")}\")\r\n\t}else{ println(\"$str : $a\")\r\n\t}\r\n}\r\nval just = \" \" // usage: just dei x , where x is the debug variable\r\nfun crash(){throw Exception(\"Bad programme\")} // because assertion does not work\r\nfun assert(a:Boolean){if(!a){throw Exception(\"Failed Assertion\")}}\r\nenum class solveMode {\r\n\treal, rand, tc\r\n}\r\nobject solve{\r\n\tvar mode:solveMode = solveMode.real\r\n\tvar tcNum:Int = 0\r\n\tvar rand:()->Unit = {}\r\n\tvar TC:MutableMap<Int,()->Unit> = mutableMapOf()\r\n\tvar answersChecked = 0\r\n\tinline fun cases(a:solve.()->Unit){\r\n\t\tval t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount\r\n\t\trepeat(t){\r\n\t\t\tif(mode == solveMode.tc){\r\n\t\t\t\tTC[tcNum]?.let { it() }\r\n\t\t\t\tIO.rerouteInput()\r\n\t\t\t}else if(mode == solveMode.rand){\r\n\t\t\t\trand()\r\n\t\t\t\tIO.rerouteInput()\r\n\t\t\t}\r\n\t\t\tcurrentAnswer = null\r\n\t\t\tcurrentBruteAnswer = null\r\n\t\t\ta()\r\n\t\t}\r\n\t\tif(withBruteForce){\r\n\t\t\tput(\"Checked ${answersChecked}\")\r\n\t\t}\r\n\t}\r\n\tinline fun singleCase(a:solve.()->Unit){\r\n\t\tval t = if(mode != solveMode.rand){1} else randCount\r\n\t\trepeat(t) { a() }\r\n\t}\r\n\tfun rand(a:()->Unit){\r\n\t\tthis.rand = a\r\n\t}\r\n\tfun tc(id:Int = 0,a:()->Unit){\r\n\t\tTC[id] = a\r\n\t}\r\n\tinline fun brute(a:()->Unit){\r\n\t\tif(withBruteForce){\r\n\t\t\ta()\r\n\t\t}\r\n\t}\r\n\tfun usetc(a:Int = 0 ){\r\n\t\tthis.tcNum = a\r\n\t\tthis.mode = solveMode.tc\r\n\t}\r\n\tfun userand(){\r\n\t\tthis.mode = solveMode.rand\r\n\t}\r\n\r\n\r\n\tvar currentAnswer:String? = null\r\n\tvar currentBruteAnswer:String? = null\r\n\tfun answer(a:Any){\r\n\t\tcurrentAnswer = a.toString()\r\n\t\tif(currentBruteAnswer != null){\r\n\t\t\tcheckAnswer()\r\n\t\t}\r\n\t}\r\n\tfun put2(a:Any){answer(a);put(a) }\r\n\r\n\tfun bruteAnswer(a:Any){\r\n\t\tcurrentBruteAnswer = a.toString()\r\n\t\tif(currentAnswer != null){\r\n\t\t\tcheckAnswer()\r\n\t\t}\r\n\t}\r\n\tfun checkAnswer(){\r\n\t\tif(currentAnswer != currentBruteAnswer){\r\n\t\t\tthrow Exception(\"Failed Test: BF $currentBruteAnswer Current $currentAnswer\")\r\n\t\t}\r\n\t\tanswersChecked ++\r\n\t}\r\n}\r\nfun Int2(a:Int,b:Int) = List(a){IntArray(b)}\r\nfun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}\r\nconst val p = 1000000007L\r\nconst val pI = p.toInt()\r\nfun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }\r\nfun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }\r\n\r\nconst val singleCase = true\r\nconst val withBruteForce = false\r\nconst val randCount = 100\r\n\r\ndata class entries(val ID:Int,val len:Int, val sep:Int)\r\n\r\n\r\nfun packer(a:IntArray, sizeMin:Int,sizeMax:Int):List<Int>?{\r\n\tval size = sizeMax\r\n\tval DP = List(a.size + 1){BooleanArray(size + 1)}\r\n\tvar p = 1\r\n\tDP[0][0] = true\r\n\tfor(c in a){\r\n\t\tfor(i in 0..size){\r\n\t\t\tif(DP[p-1][i]) {\r\n\t\t\t\tif(i + c <= size){ DP[p][i + c] = true}\r\n\t\t\t\tDP[p][i] = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tp ++\r\n\t}\r\n\tp = DP.lastIndex - 1\r\n\tvar unpackedList = mutableListOf<Int>()\r\n\tvar target = -1\r\n\tvar currentPack = -1\r\n\tfor(i in sizeMin..sizeMax){\r\n\t\tif(DP.last()[i]){\r\n\t\t\tcurrentPack = i\r\n\t\t\ttarget = i\r\n\t\t}\r\n\t}\r\n\tif(currentPack == -1){\r\n\t\treturn null\r\n\t}\r\n\tfor(i in a.lastIndex downTo 0){\r\n\t\tval c = a[i]\r\n\t\tval want = currentPack - c\r\n\t\tif(want < 0) continue\r\n\t\tif(DP[p][want]){\r\n\t\t\tunpackedList.add(i)\r\n\t\t\tcurrentPack = want\r\n\t\t}\r\n\t\tp--\r\n\t}\r\n\tassert(unpackedList.sumOf { a[it] } == target)\r\n\treturn unpackedList\r\n}\r\n\r\nclass data(val n:Int, var m :Int, val items:List<entries>){\r\n\tval ret = IntArray(n)\r\n\tvar bad = false\r\n\r\n\tinit{\r\n\t\tval one = items.filter{it.sep == 1}\r\n\t\tval two = items.filter{it.sep == 2}\r\n\t\tfor(a in one){\r\n\t\t\tval start = m - a.len\r\n\t\t\tret[a.ID] = start\r\n\t\t\tm -= a.len\r\n\t\t}\r\n\t\tval needToPack = m/2\r\n\t\tval len = two.map { it.len }.toIntArray()\r\n\t\tval sum = len.sum()\r\n\t\tval ok = (0..needToPack).filter{\r\n\t\t\tval remaining = sum - it\r\n\t\t\tremaining <= (m - needToPack)\r\n\t\t}\r\n\t\tval minOK = ok.minOrNull()\r\n\t\tval twoUsed = BooleanArray(two.size)\r\n\t\tif(minOK == null){bad = true }else{\r\n\t\t\tval packed = packer(len,minOK,needToPack)\r\n\t\t\tif(packed == null){bad = true}else{\r\n\t\t\t\tvar here = 1\r\n\t\t\t\tfor(i in packed){\r\n\t\t\t\t\tret[two[i].ID] = here\r\n\t\t\t\t\there += two[i].len * 2\r\n\t\t\t\t\ttwoUsed[i] = true\r\n\t\t\t\t}\r\n\t\t\t\there = 0\r\n\t\t\t\tfor(i in twoUsed.indices){\r\n\t\t\t\t\tif(twoUsed[i]) continue\r\n\t\t\t\t\tret[two[i].ID] = here\r\n\t\t\t\t\there += two[i].len * 2\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\nfun main(){\r\n//\tval a = packer(intArrayOf(3,2,2),3,3)\r\n//\tjust dei a!!\r\n\tsolve.cases{\r\n\t\tval n = getint()\r\n\t\tval m = getint()\r\n\t\tval En = mutableListOf<entries>()\r\n\t\trepeat(n){\r\n\t\t\tval new = entries(it,getint(),getint())\r\n\t\t\tEn.add(new)\r\n\t\t}\r\n\t\tval R = data(n,m,En)\r\n\t\tif(R.bad){\r\n\t\t\tput(\"-1\")\r\n\t\t}else{\r\n\t\t\tfor(a in R.ret){\r\n\t\t\t\tput(a + 1)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdone()\r\n}\r\n"
}