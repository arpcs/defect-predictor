{
    "id": 131088551,
    "contestId": 1571,
    "creationTimeSeconds": 1633623781,
    "relativeTimeSeconds": 6481,
    "problem": {
        "contestId": 1571,
        "index": "F",
        "name": "Kotlinforces",
        "type": "PROGRAMMING",
        "rating": 2000,
        "tags": [
            "*special",
            "constructive algorithms",
            "dp"
        ]
    },
    "author": {
        "contestId": 1571,
        "members": [
            {
                "handle": "jvmusin"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1633617300
    },
    "programmingLanguage": "Kotlin 1.5",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 88,
    "timeConsumedMillis": 217,
    "memoryConsumedBytes": 25497600,
    "source": "@file:Suppress(\"EXPERIMENTAL_API_USAGE\")\r\n\r\nimport ModInt.Companion.sum\r\nimport ModInt.Companion.sumOfM\r\nimport Utils.ArrayUtils.Companion.arrayOfNullsSafe\r\nimport Utils.ArrayUtils.Companion.makeDistinct\r\nimport Utils.ArrayUtils.Companion.toNotNulls\r\nimport Utils.ArrayUtils.Prints.Companion.println\r\nimport Utils.ArrayUtils.Sorts.Companion.countSort\r\nimport Utils.ArrayUtils.Sorts.Companion.shuffleSort\r\nimport Utils.ArrayUtils.Swaps.Companion.swap\r\nimport Utils.BinarySearchUtils.Companion.binarySearch\r\nimport Utils.BinarySearchUtils.Companion.binarySearchDouble\r\nimport Utils.BinarySearchUtils.Companion.binarySearchLong\r\nimport Utils.BitUtils.Companion.flip\r\nimport Utils.BitUtils.Companion.get\r\nimport Utils.BitUtils.Companion.set\r\nimport Utils.BitUtils.Companion.submaskOf\r\nimport Utils.FastReader\r\nimport Utils.GeneralUtils.Companion.catch\r\nimport Utils.GeneralUtils.Companion.length\r\nimport Utils.GeneralUtils.Companion.rnd\r\nimport Utils.MathUtils.Companion.compareDoubles\r\nimport Utils.MathUtils.Companion.gcd\r\nimport Utils.MathUtils.Companion.log2\r\nimport Utils.Pairs.Companion.ComparablePair\r\nimport Utils.Pairs.Companion.IntPair\r\nimport Utils.Pairs.Companion.LongPair\r\nimport java.io.*\r\nimport java.util.*\r\nimport kotlin.collections.ArrayDeque\r\nimport kotlin.math.*\r\nimport kotlin.random.Random\r\nimport kotlin.time.ExperimentalTime\r\n\r\n\r\nconst val YANDEX = false\r\nconst val FORCE_LOCAL = false\r\nval OJ = !FORCE_LOCAL && (YANDEX || System.getProperty(\"ONLINE_JUDGE\") != null)\r\n\r\n@Suppress(\"unused\")\r\nval LOCAL = !OJ\r\n\r\n@ExperimentalStdlibApi\r\n@ExperimentalTime\r\n@ExperimentalUnsignedTypes\r\nfun main() {\r\n    Locale.setDefault(Locale.US)\r\n    val fin = if (OJ) {\r\n//        @Suppress(\"UNUSED_VARIABLE\", \"RedundantNullableReturnType\") val name: String? = \"cinema\"\r\n//        System.setOut(PrintStream(BufferedOutputStream(FileOutputStream(\"$name.out\"))))\r\n//        FastReader(\"$name.in\")\r\n        System.setOut(PrintStream(BufferedOutputStream(System.out)))\r\n        FastReader()\r\n    } else {\r\n        FastReader()\r\n    }\r\n    Task(fin).solve()\r\n    System.out.flush()\r\n}\r\n\r\nconst val eps = 1e-8\r\n\r\n@ExperimentalTime\r\n@ExperimentalStdlibApi\r\nclass Task(private val fin: FastReader = FastReader()) {\r\n    class Fail : Exception()\r\n\r\n    fun solve1() {\r\n        val n = fin.readInt()\r\n        val m = fin.readInt()\r\n        val len = IntArray(n)\r\n        val step = IntArray(n)\r\n        repeat(n) {\r\n            len[it] = fin.readInt()\r\n            step[it] = fin.readInt()\r\n        }\r\n\r\n        var daysUsed = 0\r\n        val ids = mutableListOf<Int>()\r\n        val ans = IntArray(n)\r\n        for (i in 0 until n) {\r\n            if (step[i] == 1) {\r\n                ans[i] = daysUsed\r\n                daysUsed += len[i]\r\n            } else {\r\n                ids += i\r\n            }\r\n        }\r\n\r\n        val lensLeft = ids.sumOf { len[it] }\r\n        if (daysUsed + lensLeft > m) {\r\n            println(-1)\r\n            return\r\n        }\r\n\r\n        val daysLeft = m - daysUsed\r\n        val usedBy = IntArray(daysLeft + 1) { -1 }\r\n        usedBy[0] = -2\r\n        for (id in ids) {\r\n            for (i in (len[id]..daysLeft).reversed()) {\r\n                if (usedBy[i] == -1 && usedBy[i - len[id]] != -1) {\r\n                    usedBy[i] = id\r\n                }\r\n            }\r\n        }\r\n\r\n        val maxFirstPart = (0..daysLeft).first { i -> usedBy[i] != -1 && i >= lensLeft - i }\r\n        val maxSecondPart = lensLeft - maxFirstPart\r\n        // first >= second\r\n        val usedDaysFirst = maxFirstPart * 2 - 1\r\n        val usedDaysSecond = 1 + maxSecondPart * 2 - 1\r\n        if (maxOf(usedDaysFirst, usedDaysSecond) > daysLeft) {\r\n            println(-1)\r\n            return\r\n        }\r\n\r\n        val firstPartDays = mutableListOf<Int>()\r\n        var szFirst = maxFirstPart\r\n        while (szFirst > 0) {\r\n            val id = usedBy[szFirst]\r\n            firstPartDays += id\r\n            szFirst -= len[id]\r\n        }\r\n\r\n        var nextUse = daysUsed\r\n        for (id in firstPartDays) {\r\n            ans[id] = nextUse\r\n            nextUse += len[id] * 2\r\n        }\r\n        nextUse = daysUsed + 1\r\n        val secondPartDays = ids.filter { it !in firstPartDays }\r\n        for (id in secondPartDays) {\r\n            ans[id] = nextUse\r\n            nextUse += len[id] * 2\r\n        }\r\n\r\n        println(ans.map { it + 1 })\r\n    }\r\n\r\n    fun solve() {\r\n        solve1()\r\n    }\r\n}\r\n\r\n@Suppress(\"MemberVisibilityCanBePrivate\", \"unused\")\r\n@ExperimentalStdlibApi\r\n@ExperimentalUnsignedTypes\r\nclass Utils {\r\n    class GeneralUtils {\r\n        companion object {\r\n            val rnd = Random(239)\r\n            val IntRange.length get() = maxOf(last - first + 1, 0)\r\n\r\n            @Suppress(\"UNREACHABLE_CODE\", \"ControlFlowWithEmptyBody\")\r\n            fun <R> catch(throwMLE: Boolean = false, f: () -> R): R {\r\n                try {\r\n                    return f()\r\n                } catch (e: Exception) {\r\n                    if (throwMLE) throw OutOfMemoryError()\r\n                    while (true) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    class MathUtils {\r\n        companion object {\r\n            tailrec fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\r\n            tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\r\n            fun lcm(a: Long, b: Long) = a / gcd(a, b) * b\r\n\r\n            fun Int.log2(): Int {\r\n                var log = 0\r\n                while (1 shl log < this) log++\r\n                return log\r\n            }\r\n\r\n            fun Long.log2(): Int {\r\n                var log = 0\r\n                while (1L shl log < this) log++\r\n                return log\r\n            }\r\n\r\n            fun compareDoubles(x: Double, y: Double) =\r\n                if (abs(x - y) < eps) 0 else if (x < y) -1 else +1\r\n\r\n            fun isZero(x: Double) = abs(x) < eps\r\n        }\r\n    }\r\n\r\n    class BitUtils {\r\n        companion object {\r\n            operator fun Int.get(bit: Int) = (this shr bit) and 1\r\n            operator fun Long.get(bit: Int) = ((this shr bit) and 1).toInt()\r\n            fun Int.set(bit: Int) = this or (1 shl bit)\r\n            fun Long.set(bit: Int) = this or (1L shl bit)\r\n            fun Int.flip(bit: Int) = this xor (1 shl bit)\r\n            fun Long.flip(bit: Int) = this xor (1L shl bit)\r\n            infix fun Int.submaskOf(x: Int) = (this and x) == this\r\n            infix fun Long.submaskOf(x: Long) = (this and x) == this\r\n        }\r\n    }\r\n\r\n    class ArrayUtils {\r\n        companion object {\r\n            fun <T : Comparable<T>> MutableList<T>.makeDistinct() {\r\n                if (size <= 1) return\r\n                sort()\r\n                var sz = 1\r\n                for (i in 1 until size) {\r\n                    if (this[i] != this[i - 1]) {\r\n                        this[sz++] = this[i]\r\n                    }\r\n                }\r\n                while (size > sz) removeAt(lastIndex)\r\n            }\r\n\r\n            @Suppress(\"UNCHECKED_CAST\")\r\n            fun <T> Array<T?>.toNotNulls() = this as Array<T>\r\n\r\n            @Suppress(\"UNCHECKED_CAST\")\r\n            inline fun <reified T> arrayOfNullsSafe(size: Int): Array<T> =\r\n                arrayOfNulls<T>(size).toNotNulls()\r\n        }\r\n\r\n        class Swaps {\r\n            companion object {\r\n                fun <T> Array<T>.swap(i: Int, j: Int) {\r\n                    val x = this[i]\r\n                    this[i] = this[j]\r\n                    this[j] = x\r\n                }\r\n\r\n                fun <T> MutableList<T>.swap(i: Int, j: Int) {\r\n                    val x = this[i]\r\n                    this[i] = this[j]\r\n                    this[j] = x\r\n                }\r\n\r\n                fun IntArray.swap(i: Int, j: Int) {\r\n                    val x = this[i]\r\n                    this[i] = this[j]\r\n                    this[j] = x\r\n                }\r\n\r\n                fun LongArray.swap(i: Int, j: Int) {\r\n                    val x = this[i]\r\n                    this[i] = this[j]\r\n                    this[j] = x\r\n                }\r\n\r\n                fun DoubleArray.swap(i: Int, j: Int) {\r\n                    val x = this[i]\r\n                    this[i] = this[j]\r\n                    this[j] = x\r\n                    sort()\r\n                }\r\n\r\n                fun CharArray.swap(i: Int, j: Int) {\r\n                    val x = this[i]\r\n                    this[i] = this[j]\r\n                    this[j] = x\r\n                    sort()\r\n                }\r\n            }\r\n        }\r\n\r\n        class Sorts {\r\n            companion object {\r\n                fun IntArray.shuffleSort() {\r\n                    for (i in 1 until size) swap(i, rnd.nextInt(i + 1))\r\n                    sort()\r\n                }\r\n\r\n                fun LongArray.shuffleSort() {\r\n                    for (i in 1 until size) swap(i, rnd.nextInt(i + 1))\r\n                    sort()\r\n                }\r\n\r\n                fun DoubleArray.shuffleSort() {\r\n                    for (i in 1 until size) swap(i, rnd.nextInt(i + 1))\r\n                    sort()\r\n                }\r\n\r\n                fun CharArray.shuffleSort() {\r\n                    for (i in 1 until size) swap(i, rnd.nextInt(i + 1))\r\n                    sort()\r\n                }\r\n\r\n                @Suppress(\"DuplicatedCode\")\r\n                inline fun <reified T> Array<T>.countSort(\r\n                    inPlace: Boolean = true,\r\n                    type: (T) -> Int = { (it as Number).toInt() }\r\n                ): Array<T> {\r\n                    if (isEmpty()) return if (inPlace) this else emptyArray()\r\n                    val types = IntArray(size) { type(this[it]) }\r\n                    val min = types.minOrNull()!!\r\n                    val max = types.maxOrNull()!!\r\n                    val count = IntArray(max - min + 1)\r\n                    for (t in types) count[t - min]++\r\n                    var sum = 0\r\n                    for (i in count.indices) {\r\n                        val shift = count[i]\r\n                        count[i] = sum\r\n                        sum += shift\r\n                    }\r\n                    val sorted = arrayOfNullsSafe<T>(size)\r\n                    for (i in 0 until size) sorted[count[types[i] - min]++] = this[i]\r\n                    return if (inPlace) {\r\n                        this.also { sorted.copyInto(this) }\r\n                    } else {\r\n                        sorted\r\n                    }\r\n                }\r\n\r\n                @Suppress(\"DuplicatedCode\")\r\n                inline fun <reified T> List<T>.countSort(\r\n                    inPlace: Boolean = true,\r\n                    type: (T) -> Int = { (it as Number).toInt() }\r\n                ): List<T> {\r\n                    if (isEmpty()) return if (inPlace) this else emptyList()\r\n                    val types = IntArray(size) { type(this[it]) }\r\n                    val min = types.minOrNull()!!\r\n                    val max = types.maxOrNull()!!\r\n                    val count = IntArray(max - min + 1)\r\n                    for (t in types) count[t - min]++\r\n                    var sum = 0\r\n                    for (i in count.indices) {\r\n                        val shift = count[i]\r\n                        count[i] = sum\r\n                        sum += shift\r\n                    }\r\n                    val sorted = arrayOfNullsSafe<T>(size)\r\n                    for (i in 0 until size) sorted[count[types[i] - min]++] = this[i]\r\n                    return if (inPlace) {\r\n                        return (this as MutableList<T>).apply {\r\n                            for (i in indices) this[i] = sorted[i]\r\n                        }\r\n                    } else {\r\n                        sorted.asList()\r\n                    }\r\n                }\r\n\r\n                @Suppress(\"DuplicatedCode\")\r\n                inline fun IntArray.countSort(\r\n                    inPlace: Boolean = true,\r\n                    type: (Int) -> Int = { it -> it }\r\n                ): IntArray {\r\n                    if (isEmpty()) return if (inPlace) this else intArrayOf()\r\n                    val types = IntArray(size) { type(this[it]) }\r\n                    val min = types.minOrNull()!!\r\n                    val max = types.maxOrNull()!!\r\n                    val count = IntArray(max - min + 1)\r\n                    for (t in types) count[t - min]++\r\n                    var sum = 0\r\n                    for (i in count.indices) {\r\n                        val shift = count[i]\r\n                        count[i] = sum\r\n                        sum += shift\r\n                    }\r\n                    val sorted = IntArray(size)\r\n                    for (i in 0 until size) sorted[count[types[i] - min]++] = this[i]\r\n                    return if (inPlace) {\r\n                        this.also { sorted.copyInto(this) }\r\n                    } else {\r\n                        sorted\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        class Prints {\r\n            companion object {\r\n                fun println(a: IntArray) {\r\n                    if (a.isNotEmpty()) {\r\n                        print(a[0])\r\n                        for (i in 1 until a.size) {\r\n                            print(' ')\r\n                            print(a[i])\r\n                        }\r\n                    }\r\n                    println()\r\n                }\r\n\r\n                fun println(a: LongArray) {\r\n                    if (a.isNotEmpty()) {\r\n                        print(a[0])\r\n                        for (i in 1 until a.size) {\r\n                            print(' ')\r\n                            print(a[i])\r\n                        }\r\n                    }\r\n                    println()\r\n                }\r\n\r\n                fun println(a: CharArray, printSpace: Boolean = false) {\r\n                    if (a.isNotEmpty()) {\r\n                        print(a[0])\r\n                        for (i in 1 until a.size) {\r\n                            if (printSpace) print(' ')\r\n                            print(a[i])\r\n                        }\r\n                    }\r\n                    println()\r\n                }\r\n\r\n                fun println(a: Array<*>) {\r\n                    if (a.isNotEmpty()) {\r\n                        print(a[0])\r\n                        for (i in 1 until a.size) {\r\n                            print(' ')\r\n                            print(a[i])\r\n                        }\r\n                    }\r\n                    println()\r\n                }\r\n\r\n                fun println(a: List<*>) {\r\n                    if (a.isNotEmpty()) {\r\n                        print(a[0])\r\n                        for (i in 1 until a.size) {\r\n                            print(' ')\r\n                            print(a[i])\r\n                        }\r\n                    }\r\n                    println()\r\n                }\r\n\r\n                fun println(a: Iterable<*>) {\r\n                    val it = a.iterator()\r\n                    if (it.hasNext()) {\r\n                        print(it.next())\r\n                        while (it.hasNext()) {\r\n                            print(' ')\r\n                            print(it.next())\r\n                        }\r\n                    }\r\n                    println()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    class BinarySearchUtils {\r\n        companion object {\r\n            @Suppress(\"DuplicatedCode\")\r\n            inline fun binarySearch(from: Int, to: Int, f: (Int) -> Boolean): Int {\r\n                var l = from\r\n                var r = to + 1\r\n                while (r - l > 1) {\r\n                    val m = (l + r) / 2\r\n                    if (f(m)) l = m\r\n                    else r = m\r\n                }\r\n                return l\r\n            }\r\n\r\n            inline fun binarySearch(from: Int = 0, f: (Int) -> Boolean): Int {\r\n                var len = 1\r\n                while (f(from + len)) len *= 2\r\n                return binarySearch(from + len / 2, from + len - 1, f)\r\n            }\r\n\r\n            @Suppress(\"DuplicatedCode\")\r\n            inline fun binarySearchLong(from: Long, to: Long, f: (Long) -> Boolean): Long {\r\n                var l = from\r\n                var r = to + 1\r\n                while (r - l > 1) {\r\n                    val m = (l + r) / 2\r\n                    if (f(m)) l = m\r\n                    else r = m\r\n                }\r\n                return l\r\n            }\r\n\r\n            inline fun binarySearchLong(from: Long = 0, f: (Long) -> Boolean): Long {\r\n                var len = 1L\r\n                while (f(from + len)) len *= 2\r\n                return binarySearchLong(from + len / 2, from + len - 1, f)\r\n            }\r\n\r\n            @Suppress(\"DuplicatedCode\")\r\n            inline fun binarySearchDouble(\r\n                from: Double,\r\n                to: Double,\r\n                times: Int = 200,\r\n                f: (Double) -> Boolean\r\n            ): Double {\r\n                var l = from\r\n                var r = to\r\n                repeat(times) {\r\n                    val m = (l + r) / 2\r\n                    if (f(m)) l = m\r\n                    else r = m\r\n                }\r\n                return l\r\n            }\r\n\r\n            inline fun binarySearchDouble(\r\n                from: Double = 0.0,\r\n                times: Int = 200,\r\n                f: (Double) -> Boolean\r\n            ): Double {\r\n                var len = 1.0\r\n                while (f(from + len)) len *= 2\r\n                return binarySearchDouble(from, from + len, times, f)\r\n            }\r\n        }\r\n    }\r\n\r\n    class Pairs {\r\n        companion object {\r\n            data class ComparablePair<T1 : Comparable<T1>, T2 : Comparable<T2>>(\r\n                val first: T1,\r\n                val second: T2\r\n            ) :\r\n                Comparable<ComparablePair<T1, T2>> {\r\n                override fun compareTo(other: ComparablePair<T1, T2>): Int {\r\n                    var c = first.compareTo(other.first)\r\n                    if (c == 0) c = second.compareTo(other.second)\r\n                    return c\r\n                }\r\n            }\r\n\r\n            data class IntPair(val first: Int, val second: Int) : Comparable<IntPair> {\r\n                override fun compareTo(other: IntPair): Int {\r\n                    var c = first.compareTo(other.first)\r\n                    if (c == 0) c = second.compareTo(other.second)\r\n                    return c\r\n                }\r\n\r\n                fun swap() = IntPair(second, first)\r\n            }\r\n\r\n            data class LongPair(val first: Long, val second: Long) : Comparable<LongPair> {\r\n                override fun compareTo(other: LongPair): Int {\r\n                    var c = first.compareTo(other.first)\r\n                    if (c == 0) c = second.compareTo(other.second)\r\n                    return c\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    class UtilsImports {\r\n        fun importDependencies() {\r\n            check(gcd(4, 6) == 2)\r\n            check(rnd.nextInt(10) in 0 until 10)\r\n            check(mutableListOf(1, 3, 2, 2, 1).apply { makeDistinct() } == listOf(1, 2, 3))\r\n            check((5..10).length == 6)\r\n            check(intArrayOf(3, 4).apply { swap(0, 1) }.contentEquals(intArrayOf(4, 3)))\r\n            check(\r\n                intArrayOf(5, 6, 2, 1, 5).apply { shuffleSort() }\r\n                    .contentEquals(intArrayOf(1, 2, 5, 5, 6))\r\n            )\r\n            check(binarySearch { it < 10 } == 9)\r\n            check(binarySearchLong { it < 1e13.toLong() } == 1e13.toLong() - 1)\r\n            binarySearchDouble { true }\r\n            println(intArrayOf())\r\n            ArrayDeque<Int>()\r\n            listOf<ModInt>().sumOfM { it }\r\n            listOf<ModInt>().sum()\r\n            abs(1)\r\n            sin(1.0)\r\n            cos(1.0)\r\n            hypot(1.0, 1.0)\r\n            catch {}\r\n            ComparablePair(1, 2)\r\n            IntPair(1, 2)\r\n            arrayOfNulls<Int>(0).toNotNulls()\r\n            arrayOfNullsSafe<Int>(0)\r\n            5.log2()\r\n            @Suppress(\"ReplaceGetOrSet\")\r\n            5.get(3)\r\n            5.sign\r\n            5 submaskOf 3\r\n            5.set(3)\r\n            5.flip(3)\r\n            compareDoubles(0.0, 1.0)\r\n            arrayOf(1, 2).countSort { it.countOneBits() }\r\n            LongPair(1, 2)\r\n        }\r\n    }\r\n\r\n    class FastReader(fileName: String? = null) {\r\n        @JvmField\r\n        val br =\r\n            BufferedReader(if (fileName != null) FileReader(fileName) else InputStreamReader(System.`in`))\r\n\r\n        @JvmField\r\n        var st = StringTokenizer(\"\")\r\n\r\n        fun readString(): String {\r\n            while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())\r\n            return st.nextToken()\r\n        }\r\n\r\n        fun readInt() = readString().toInt()\r\n        fun readLong() = readString().toLong()\r\n        fun readDouble() = readString().toDouble()\r\n\r\n        fun readIntArray(n: Int) = IntArray(n) { readInt() }\r\n        fun readLongArray(n: Int) = LongArray(n) { readLong() }\r\n        fun readStringArray(n: Int) = Array(n) { readString() }\r\n        fun readDoubleArray(n: Int) = DoubleArray(n) { readDouble() }\r\n\r\n        fun readInts(n: Int) = MutableList(n) { readInt() }\r\n        fun readLongs(n: Int) = MutableList(n) { readLong() }\r\n        fun readStrings(n: Int) = MutableList(n) { readString() }\r\n        fun readDoubles(n: Int) = MutableList(n) { readDouble() }\r\n    }\r\n}\r\n\r\n@Suppress(\"MemberVisibilityCanBePrivate\", \"unused\")\r\ninline class ModInt(private val x: Int) {\r\n    companion object {\r\n        // private const val mod = 998_244_353\r\n        const val mod = 1e9.toInt() + 7\r\n        fun Int.toModInt() = ModInt(this)\r\n        fun Int.toModIntSafe() = ModInt((this % mod + mod) % mod)\r\n        fun Long.toModIntSafe() = ModInt(((this % mod + mod) % mod).toInt())\r\n        val ZERO = ModInt(0)\r\n        val ONE = ModInt(1)\r\n        val TWO = ModInt(2)\r\n        val TEN = ModInt(10)\r\n\r\n        fun Iterable<ModInt>.sum() = fold(ZERO, ModInt::plus)\r\n        fun Array<ModInt>.sum() = fold(ZERO, ModInt::plus)\r\n\r\n        inline fun <T> Iterable<T>.sumOfM(f: (T) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }\r\n        inline fun <T> Array<T>.sumOfM(f: (T) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }\r\n    }\r\n\r\n    operator fun plus(k: ModInt) = ModInt((x + k.x).let { if (it >= mod) it - mod else it })\r\n    operator fun minus(k: ModInt) = ModInt((x - k.x).let { if (it < 0) it + mod else it })\r\n    operator fun times(k: ModInt) = ModInt((x * k.x.toLong() % mod).toInt())\r\n    operator fun div(k: ModInt) = this * k.inv()\r\n    operator fun unaryMinus() = if (x == 0) this else ModInt(mod - x)\r\n    fun inv() = pow(mod - 2)\r\n    fun pow(p: Int): ModInt =\r\n        if (p == 0) ONE else pow(p / 2).let { if (p % 2 == 1) it * it * this else it * it }\r\n\r\n    fun toInt() = x\r\n    override fun toString() = x.toString()\r\n}\r\n\r\n@Suppress(\"MemberVisibilityCanBePrivate\")\r\n@ExperimentalStdlibApi\r\ndata class Rational(val x: Long, val y: Long) {\r\n    operator fun plus(other: Rational) = makeRational(x * other.y + other.x * y, y * other.y)\r\n    operator fun minus(other: Rational) = makeRational(x * other.y - other.x * y, y * other.y)\r\n    operator fun times(other: Rational) = makeRational(x * other.x, y * other.y)\r\n    operator fun div(other: Rational) = this * other.inv()\r\n    fun inv() = if (x == 0L) this else makeRational(y, x)\r\n    operator fun unaryMinus() = makeRational(x, -y)\r\n\r\n    companion object {\r\n        fun makeRational(x: Long, y: Long): Rational {\r\n            if (x == 0L) return Rational(0L, 1L)\r\n            if (x < 0) return makeRational(-x, -y)\r\n            val g = gcd(x, abs(y))\r\n            return Rational(x / g, y / g)\r\n        }\r\n    }\r\n}\r\n"
}