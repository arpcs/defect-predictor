{
    "id": 193276002,
    "contestId": 180,
    "creationTimeSeconds": 1676188181,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 180,
        "index": "E",
        "name": "Cubes",
        "type": "PROGRAMMING",
        "rating": 1800,
        "tags": [
            "binary search",
            "dp",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 180,
        "members": [
            {
                "handle": "mbug7588"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1335078000
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 50,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 34918400,
    "source": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define f first\n#define s second\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define vll vector<ll>\n#define vb vector<bool>\n#define vvll vector<vll>\n#define pll pair<ll, ll>\n#define lb lower_bound\n#define ub upper_bound\n#define fr(a,b) for(ll i=a;i<=b;i++)\n#define loop(k,a,b) for(int k=a;k<b;k++)\n#define endl \"\\n\"\n//#define mod 998244353  //10^9+7\n#define alln(v,n) fr(0,n-1)cin>>(v)[i]\n//#define mod 998244353\n#define ep 0.0001\nconst ll N=1e6+10;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;   \nvector<ll>divisor(N,-1);\nvector<bool>isprime(N,1);\nvll lp(N,0);\nvll hp(N,0);\nvector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\nvoid prime(){\n  isprime[0]=isprime[1]=0;\n\n  for(int i=2;i<N;i++){\n  \n     if(isprime[i]){\n      hp[i]=lp[i]=i;\n      for(int j=2*i;j<N;j+=i){\n        isprime[j]=false; \n        hp[j]=i;\n        if(lp[j]==0)\n          lp[j]=i;        \n       }\n     }\n      \n  }\n}\nvoid primefacts(ll n,ll &p,ll& oc){\n  unordered_map<ll,ll>pf;\n   oc=0;\n   while(n>1){\n      ll pff=hp[n];\n      while(n%pff==0)\n      {\n        n=n/pff;\n        pf[pff]++;\n      }\n      if(oc<pf[pff]){\n        oc=pf[pff];\n        p=pff;\n      }\n   }\n/*\n     for(auto [key,value]:pf)\n        cout<<key<<\"^\"<<value<<\" \";\n      cout<<endl;\n */\n}\nll max(ll a,ll b){\n   return (a>b)?a:b;\n}\nll min(ll a,ll b){\n  return (a>b)?b:a;\n}\nll lg(ll a,ll n){\n    return log10(n)/log10(a);\n}\nbool ispower(ll a,ll n){\n    ll c1=log(n)/log(a);\n    double c2=log(n)/log(a);\n  // cout<<c1<<\"->\"<<c2<<endl;\n    return c1==c2;\n}\nll gcd(ll a,ll b){\n     if(a==0)\n         return b;\n  return gcd(b%a,a);\n}\nvoid swap(ll*p1,ll*p2){\n    ll t=*p1;\n    *p1=*p2;\n    *p2=t;\n}\nll sum(ll n){\n  ll ans=0;\n   while(n>0){\n     ans++;\n     n=n/10;\n   }\n ll t=0;\n while(ans--){\n\n   t=t*10+1;\n }\n  return t;\n}\nll digit(ll n){\n  ll c=0;\n  ll sum=0;\n  set<ll>st;\n  bool ok=1;\n   while(n>0){\n     sum+=n%10;\n     if(st.count(n%10)){\n        ok=0;\n        break;\n     }\n     st.insert(n%10);\n     n=n/10;\n      c++;\n   }\n   if(!ok){\n     return -1;\n   }\n   return sum;\n}\n\nbool cmpv(ll a,ll b){\n   return a>b;\n}\n//ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\n//ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\n\n//--------modular math\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll pow_mod(ll a,ll b,ll m){\n  a=a%m;\n  ll res=1;\n  while(b>0){\n    if(b&1)\n      res=(res*a)%m;\n    a=(a*a)%m;\n    b=b>>1;\n  }\n  return res;\n}\nll inv(ll x,ll mod)\n{\n    return pow_mod(x, mod - 2,mod);\n}\nint divide(int x, int y,ll mod)\n{\n    return mod_mul(x, inv(y,mod),mod);//  x/y--->x*(y^-1)\n}\n//--------modular math\n\n\n//vector<ll>v(sieve(20000));\n//set<ll>st(all(v));\nbool pali(string str){\n   int i=0;\n   int j=str.size()-1;\n   while(i<j){\n     if(str[i]!=str[j])\n       return false;\n     i++;\n     j--;\n   }\n\n   return 1;\n}\nint64_t*fact=new int64_t[200000+10];\nint64_t ncr(int64_t n,int64_t r){\n  int64_t ans=fact[n]/(fact[n-r]*fact[r]);\n   return ans;\n}\n\n\nll C(ll n, ll k,ll mod)\n{  // f(n)/(f(n-r)*f(r))---->f(n)*((f(r)*f(n-r))^-1)\n    return divide(fact[n], mod_mul(fact[k], fact[n - k],mod),mod);\n}\nbool check_vowel(char ch){\n    return ch=='A'||ch=='O'||ch=='Y'||ch=='E'||ch=='U'||ch=='I'||ch=='o'||ch=='e';\n}\n//s=64-__builtin_clzll(mx);  19=0000010011-->s=5\nvoid rotate(string &str,int shift,int pos,int l,int r){\n   vector<char>temp(pos);\n   \n   \n   fr(l,r){\n      int j=(i-l+shift)%pos;\n      \n      temp[j]=str[i];\n   }\n   fr(l,r){\n    str[i]=temp[i-l];\n   }\n  //cout<<str<<endl;\n}\nll mull(ll n,ll x){\n  ll m=1;\n  fr(1,x)m*=n;\n  return m;\n}\nll pos(string str,ll mask,ll m){\n  string temp=\"\";\n  ll cnt=0;\n  for(int i=0;i<m;i++){\n       if(mask&(1<<i)){\n          temp+=str[i];\n       }\n       else{\n         cnt++;\n       }\n\n         \n  }\n  \n  ll n=temp.size();\n  \n  if(n&1)return -1;\n  for(int i=0;i<n-1;i+=2){\n\n      if(temp[i]!=temp[i+1])return -1;\n  }\n\n\n   return cnt;\n}\nbool check(string str,char ch){\n    bool ok=1;\n    for(auto a:str){\n         ok=ok&(a==ch); \n    }\n\n    return ok;\n}\nll poW(ll p,ll x){\n    if(x==1)return p;\n    if(x==0)return 1;\n\n    ll m=poW(p,x/2);\n\n    if(x&1)return p*m*m;\n    return m*m;\n}\n\nbool valid(string str){\n    int p=0;\n    for(auto a:str){\n          p+=(a=='(');\n          p-=(a==')');\n          if(p<0)return 0;\n    }\n    return true;\n}\nbool cmp(string&a,string&b){\n    return a.size()>b.size();\n}\nll fac(ll n);\n \nll f(ll n,ll r)\n{\n    return fac(n) / (fac(r) * fac(n - r));\n}\n \n// Returns factorial of n\nll fac(ll n)\n{\n      if(n==0)\n      return 1;\n    ll res = 1;\n    for (ll i = 2; i <= n; i++)\n        res = res * i;\n    return res;\n}\n/* \n//-----DSU\n\nvector<ll>parent;\nvector<ll>size;\nvoid make(ll node){\n   parent[node]=node;\n   size[node]=1;\n}\nll find(ll node){\n      if(node==parent[node])return node;\n      return parent[node]=find(parent[node]);\n}\nvoid Union(ll a,ll b){\n    a=find(a);\n    b=find(b);\n    if(a!=b){\n     // if(size[a]<size[b])swap(a,b);\n     // parent[b]=a;\n     // size[a]+=size[b];\n        parent[a]=b;\n    }\n}\n\n\n//---DSU\n*/\n\nclass SgTree{\n        \n        public:\n         vector<ll>seg;\n         ll N;\n           SgTree(ll n){\n            N=n;\n               seg=vector<ll>(4*n);\n           } \n        void Build(vll&ar,ll idx,ll low,ll high,ll level){\n            ll n=ar.size();\n            n=log2(n);\n            if(low==high){\n              seg[idx]=ar[low];\n              return; \n            }\n            \n            ll mid=(low+high)>>1;\n\n            Build(ar,2*idx+1,low,mid,level+1);\n            Build(ar,2*idx+2,mid+1,high,level+1);\n\n            \n                if((level&1 and n%2==0) or (level%2==0 and n&1)){\n                   seg[idx]=(seg[2*idx+1]|seg[2*idx+2]);\n                }\n                else{\n                   seg[idx]=(seg[2*idx+1]^seg[2*idx+2]); \n                }\n           \n\n        }\n        // ll Query(ll idx,ll l,ll r,ll low,ll high){\n        //      //case 1:  No overlap [l r] [low high]  OR [low high] [l r]\n        //       if(r<low or high<l)return 0;\n         \n        //     // case 2:  Full overlap [l low high r]\n\n        //      if(l<=low and high<=r){\n        //        // cout<<seg[idx][0]<<endl;\n        //        return seg[idx][0];} \n\n        //      ll mid=low+(high-low)/2;\n\n        //     // case 3: partial overlap\n            \n        //     ll left=Query(2*idx+1,l,r,low,mid);\n        //     ll right=Query(2*idx+2,l,r,mid+1,high);\n\n           \n        //     if(a!=b){\n        //       if(mid<=r and mid+1<=r and mid>=l and mid+1>=l)\n        //       return left+right+1;\n\n        //     } \n           \n        //     return left+right;  \n        // }\n        void Update(ll pos,ll val,ll idx,ll low,ll high,ll level){\n            if(low==high){\n                 seg[idx]=val;\n                  return;\n            }\n\n            ll mid=(low+high)>>1;\n\n            if(pos<=mid){\n                Update(pos,val,2*idx+1,low,mid,level+1);\n            }\n            else{\n                Update(pos,val,2*idx+2,mid+1,high,level+1); \n            }\n\n             ll n=log2(N);\n\n                if((level&1 and n%2==0) or (level%2==0 and n&1)){\n                   seg[idx]=(seg[2*idx+1]|seg[2*idx+2]);\n                }\n                else{\n                   seg[idx]=(seg[2*idx+1]^seg[2*idx+2]); \n                }\n            \n        }\n        \n};\n\n\nvoid solve(){\n   ll n,m,k;\n   cin>>n>>m>>k;\n\n   vll v(n);\n   alln(v,n);\n\n   map<ll,vector<ll>>pos;\n\n   fr(0,n-1){\n      pos[v[i]].push_back(i);\n   }  \n\n   ll ans=0;\n\n   fr(1,m){\n      vll&pos_vec=pos[i];\n       \n      int a=0;\n      int b=0;\n      while(b<pos_vec.size()){\n        while((pos_vec[b]-pos_vec[a])-(b-a)>k)a++;\n        ans=max(ans,b-a+1);\n        b++;\n      }\n   }\n\n   cout<<ans<<endl;\n} \n\n\nint main(){\n   \n  ios_base::sync_with_stdio(false);\n     cin.tie(NULL); \n    \n   \n     #ifndef ONLINE_JUDGE\n     freopen(\"input.txt\",\"r\",stdin);\n     freopen(\"tt.txt\",\"w\",stdout);\n     #endif\n\n      \n    // prime();\n    //  vll dif_primes;\n\n    //  fr(2,N-1){\n    //      if(isprime[i])dif_primes.pb(i);\n    //  }\n\n     ll t;\n    // cin>>t;\n\n     t=1;\n\n       while(t--){\n         solve();\n       }\n    \n   \n return 0;\n}   \n\n/* \n   L=3 R=5\n  0 1 2 3 4 5 6 7 8 9\n  a b c d e f g h i j\n\n  5-5-1 \n  [abc abcd abcde]\n  \n\n   a+b+c+d+e+f\n  presum= a+b+c+d+e  set{0,a,b} \n \n\n   3  4 5  6\n   a1 b1  c1 \n   a1 b1  c1  \n   a1     c1 -->{3 3 3}-->{ d1 d1}+{c1}->{r1}\n   3       6 -->{a1 a1 a1}-->{s1 s1}+{e1}-->{w1} \n   3\n\n   1 1 1 10 10 10 10 10\n\n\n   1->x 10\n   10->y 20\n   11->z 30 \n\n   x<y<z\n\n   z/2 + z/2\n\n   3 ->a   b      d        y \n   3   a   b      d        d\n   3   a   b      b        b\n   3   a     a      v      e  \n   3   a     a      v      v       {d v s f }\n   3   a     a      a      a \n       \n       3   c        s      t      4  12\n       3   c        s      s\n       3   c        c      c\n       3     3        f    w \n       3     3        f    f\n       3     3        r    r\n   \n\n     10    100    1000    10000\n     x      y     z         w\n\n\n     10\n\n     19\n     20\n\n\n     29 \n     30\n\n\n     7     12\n     1    1    2     1     1\n     7-8  8-9 9-10  10-11 11-12\n\n     a+b=a^b+2(a&b)\n     a^b=a+b-2(a&b)\n\n     a^b<=a+b as min(a&b)=0\n     now a^b<=a+b<=a*b\n*/\n\n\n"
}