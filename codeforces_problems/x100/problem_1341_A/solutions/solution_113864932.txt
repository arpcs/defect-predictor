{
    "id": 113864932,
    "contestId": 1341,
    "creationTimeSeconds": 1619082475,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1341,
        "index": "A",
        "name": "Nastya and Rice",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 900,
        "tags": [
            "math"
        ]
    },
    "author": {
        "contestId": 1341,
        "members": [
            {
                "handle": "Jarvis_sharma"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1587653100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp> // Common file\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <functional> // for less\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> indset;\r\n#define fo(i, n) for (ll i = 0; i < n; ++i)\r\n#define ll long long\r\n#define mod 1000000007\r\n#define inf 1ll << 62\r\n\r\nll power(ll x, ll y, ll modd)\r\n{\r\n    if (y == 0)\r\n    {\r\n        return 1;\r\n    }\r\n    else if (y == 1)\r\n    {\r\n        return (x % modd);\r\n    }\r\n    ll z = power(x % modd, y / 2, modd) % modd;\r\n    if ((y % modd) % 2)\r\n    {\r\n        return (((((z % modd) * (x % modd)) % modd) * (z % modd)) % modd);\r\n    }\r\n    else\r\n    {\r\n        return (((z % modd) * (z % modd)) % modd);\r\n    }\r\n}\r\nvoid sor(vector<ll> &x)\r\n{\r\n\r\n    sort(x.begin(), x.end());\r\n}\r\n\r\nvoid rev(vector<ll> &x)\r\n{\r\n    reverse(x.begin(), x.end());\r\n}\r\n\r\nll gcd(ll x, ll y)\r\n{\r\n    if (y == 0)\r\n    {\r\n        return x;\r\n    }\r\n    return gcd(y, x % y);\r\n}\r\n\r\nll max(ll x, ll y)\r\n{\r\n    if (x > y)\r\n    {\r\n        return x;\r\n    }\r\n    else\r\n    {\r\n        return y;\r\n    }\r\n}\r\n\r\nll min(ll x, ll y)\r\n{\r\n    if (x > y)\r\n    {\r\n        return y;\r\n    }\r\n    else\r\n    {\r\n        return x;\r\n    }\r\n}\r\n\r\nll lcm(ll x, ll y)\r\n{\r\n    return x * y / gcd(x, y);\r\n}\r\n\r\nll bina(vector<ll> a, ll n, ll m)\r\n{\r\n    ll start = 0, end = n - 1;\r\n    ll c = 0;\r\n    if (m >= a[n - 1])\r\n    {\r\n        return n;\r\n    }\r\n    while (start <= end)\r\n    {\r\n        ll mid = (start + end) / 2;\r\n        if (m >= a[mid])\r\n        {\r\n            c = mid + 1;\r\n            start = mid + 1;\r\n        }\r\n        else\r\n        {\r\n            end = mid - 1;\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\nll binarySearch(vector<ll> arr, ll l, ll r, ll x)\r\n{\r\n    if (r >= l)\r\n    {\r\n        ll mid = l + (r - l) / 2;\r\n        if (arr[mid] == x)\r\n            return mid;\r\n        if (arr[mid] > x)\r\n            return binarySearch(arr, l, mid - 1, x);\r\n        return binarySearch(arr, mid + 1, r, x);\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nll prime(ll n)\r\n{\r\n    for (ll i = 2; i <= sqrt(n); i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nll countBits(ll number)\r\n{\r\n    return (ll)log2(number) + 1;\r\n}\r\n\r\nll countDivisors(ll n)\r\n{\r\n    ll cnt = 0;\r\n    for (ll i = 1; i <= sqrt(n); i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            if (n / i == i)\r\n                cnt++;\r\n\r\n            else // Otherwise count both\r\n                cnt = cnt + 2;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\nll fact(ll n)\r\n{\r\n    ll res = 1;\r\n    for (int i = 2; i <= n; i++)\r\n        res = res * i;\r\n    return res;\r\n}\r\n\r\nll nCr(ll n, ll r)\r\n{\r\n    return fact(n) / (fact(r) * fact(n - r));\r\n}\r\n\r\nll nCrModp(ll n, ll r)\r\n{\r\n    if (r > n - r)\r\n        r = n - r;\r\n\r\n    ll C[r + 1];\r\n    memset(C, 0, sizeof(C));\r\n\r\n    C[0] = 1;\r\n\r\n    for (ll i = 1; i <= n; i++)\r\n    {\r\n        for (ll j = min(i, r); j > 0; j--)\r\n            C[j] = (C[j] + C[j - 1]) % mod;\r\n    }\r\n    return C[r];\r\n}\r\n/*\r\nconst ll mxn = (2 * 100000) + 1;\r\nvector<ll> pr;\r\nbool pri[mxn + 1];\r\nvector<ll> no;\r\nvector<ll> cop(10000001, 1);\r\nvector<ll> pp;\r\nvoid SieveOfEratosthenes(int n)\r\n{\r\n\r\n    memset(pri, true, sizeof(pri));\r\n    pri[1] = false;\r\n    pri[0] = false;\r\n    fo(i, 10000001)\r\n    {\r\n        cop[i] = i;\r\n    }\r\n    for (int p = 2; p <= n; p++)\r\n    {\r\n\r\n        if (pri[p] == true)\r\n        {\r\n            //cop[p] = p - 1;\r\n            for (int i = p; i <= n; i += p)\r\n            {\r\n                pri[i] = false;\r\n            }\r\n        }\r\n    }\r\n    fo(i, 10000001)\r\n    {\r\n        if (pri[i] == true)\r\n        {\r\n            pp.push_back(i);\r\n        }\r\n    }\r\n}\r\n\r\nvector<vector<ll>> expo(ll n, vector<vector<ll>> a, vector<vector<ll>> one)\r\n{\r\n    if (n <= 0)\r\n    {\r\n        return one;\r\n    }\r\n    else if (n == 1)\r\n    {\r\n        return a;\r\n    }\r\n    vector<vector<ll>> mat = expo(n / 2, a, one);\r\n    if (n % 2)\r\n    {\r\n        vector<vector<ll>> ans2;\r\n        fo(i, mat.size())\r\n        {\r\n            vector<ll> temp(mat.size(), 0);\r\n            ans2.push_back(temp);\r\n        }\r\n        fo(i, mat.size())\r\n        {\r\n\r\n            fo(j, mat.size())\r\n            {\r\n\r\n                fo(k, mat.size())\r\n                {\r\n                    ans2[i][j] += mat[i][k] * a[k][j];\r\n                    ans2[i][j] %= mod;\r\n                }\r\n                ans2[i][j] %= mod;\r\n            }\r\n        }\r\n        vector<vector<ll>> ans3;\r\n        fo(i, mat.size())\r\n        {\r\n            vector<ll> temp(mat.size(), 0);\r\n            ans3.push_back(temp);\r\n        }\r\n        fo(i, mat.size())\r\n        {\r\n\r\n            fo(j, mat.size())\r\n            {\r\n\r\n                fo(k, mat.size())\r\n                {\r\n                    ans3[i][j] += ans2[i][k] * mat[k][j];\r\n                    ans3[i][j] %= mod;\r\n                }\r\n                ans3[i][j] %= mod;\r\n            }\r\n        }\r\n        return ans3;\r\n    }\r\n    else\r\n    {\r\n        vector<vector<ll>> ans2;\r\n        fo(i, mat.size())\r\n        {\r\n            vector<ll> temp(mat.size(), 0);\r\n            ans2.push_back(temp);\r\n        }\r\n        fo(i, mat.size())\r\n        {\r\n            fo(j, mat.size())\r\n            {\r\n                fo(k, mat.size())\r\n                {\r\n                    ans2[i][j] += mat[i][k] * mat[k][j];\r\n                    ans2[i][j] %= mod;\r\n                }\r\n                ans2[i][j] %= mod;\r\n            }\r\n        }\r\n        return ans2;\r\n    }\r\n}\r\n\r\nvector<int> ninjaChess2021(string king, string ninja) {\r\n\r\n}\r\n\r\n\r\n\r\nll v, source, graph[100][100];\r\nvector<ll> dist(100, INT64_MAX);\r\nll vis[100];\r\nll parent[100];\r\nvoid dijktras()\r\n{\r\n    fo(i, v)\r\n    {\r\n        parent[i] = i;\r\n    }\r\n    dist[0] = 0;\r\n    fo(i, v)\r\n    {\r\n        ll mi = INT64_MAX;\r\n        ll minnode = 0;\r\n        fo(j, v)\r\n        {\r\n            if (!vis[j] && dist[j] < mi)\r\n            {\r\n                mi = dist[j];\r\n                minnode = j;\r\n            }\r\n        }\r\n        vis[minnode] = 1;\r\n        fo(j, v)\r\n        {\r\n            if (graph[minnode][j] != INT64_MAX && dist[j] < dist[minnode] + graph[minnode][j])\r\n            {\r\n                dist[j] = dist[minnode] + graph[minnode][j];\r\n                parent[j] = minnode;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//vector<ll> a;\r\nvector<ll> adj[1000001];\r\nqueue<ll> q;\r\nvector<bool> used(1000001);\r\nvector<int> d(1000001);\r\nvector<ll> level(1000001);\r\n\r\nvoid bfs(ll s)\r\n{\r\n    q.push(s);\r\n    used[s] = true;\r\n    d[s] = 0;\r\n    while (!q.empty())\r\n    {\r\n        int v = q.front();\r\n        q.pop();\r\n        for (int u : adj[v])\r\n        {\r\n            if (!used[u])\r\n            {\r\n                used[u] = true;\r\n                q.push(u);\r\n                d[u] = d[v] + 1;\r\n                level[d[u]]++;\r\n                //cout << u << \" \";\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid dfs(ll s, ll dd)\r\n{\r\n    used[s] = 1;\r\n    d[s] = dd;\r\n    for (auto child : adj[s])\r\n    {\r\n        if (used[child] == 0)\r\n        {\r\n            dfs(child, dd);\r\n        }\r\n    }\r\n}\r\n\r\nvoid swap(char *x, char *y)\r\n{\r\n    char temp;\r\n    temp = *x;\r\n    *x = *y;\r\n    *y = temp;\r\n}\r\n\r\nvoid perm(char *s, ll l, ll r)\r\n{\r\n    if (l == r)\r\n    {\r\n        cout << s[l];\r\n    }\r\n    else\r\n    {\r\n        for (int i = l; i <= r; i++)\r\n        {\r\n            swap(s + l, s + i);\r\n            perm(s, l + 1, r);\r\n            swap(s + l, s + i);\r\n            cout << endl;\r\n        }\r\n    }\r\n}\r\n\r\n*/\r\n\r\nvoid solve()\r\n{\r\n    ll n, a, b, c, d;\r\n    cin >> n >> a >> b >> c >> d;\r\n    ll flag = 0;\r\n    for (int i = a - b; i <= a + b; i++)\r\n    {\r\n        if ((i * n) >= (c - d) && (i * n) <= (c + d))\r\n        {\r\n            flag = 1;\r\n            break;\r\n        }\r\n    }\r\n    if (flag == 1)\r\n    {\r\n        cout << \"Yes\";\r\n    }\r\n    else\r\n    {\r\n        cout << \"No\";\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    ios::sync_with_stdio(0), cout.tie(0), cin.tie(0);\r\n    // freopen(\"A.TXT\", \"r\", stdin);\r\n    //freopen(\"A.OUT\", \"w\", stdout);\r\n    //freopen(\"INPUT.TXT\", \"r\", stdin);\r\n    //freopen(\"OUTPUT.TXT\", \"w\", stdout);\r\n    //SieveOfEratosthenes();\r\n    ll t = 1;\r\n    cin >> t;\r\n    fo(tt, t)\r\n    {\r\n        solve();\r\n        //cout << ((2 >> 4) & 1) << \" \" << (2 >> 4) << \" \" << (2 & (1 << 4)) << !!(2 & (1 << 4));\r\n    }\r\n    return 0;\r\n}\r\n/*\r\n10 9\r\n0 1\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n5 6\r\n4 7\r\n7 8\r\n8 9\r\nsuffix array\r\nstring s;\r\n    cin >> s;\r\n    ll n = s.size() + 1;\r\n    s += '$';\r\n    vector<int> p(n), c(n), cnt(max(256, n), 0);\r\n    for (int i = 0; i < n; i++)\r\n        cnt[s[i]]++;\r\n    for (int i = 1; i < 256; i++)\r\n        cnt[i] += cnt[i - 1];\r\n    for (int i = 0; i < n; i++)\r\n        p[--cnt[s[i]]] = i;\r\n    c[p[0]] = 0;\r\n    int classes = 1;\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        if (s[p[i]] != s[p[i - 1]])\r\n            classes++;\r\n        c[p[i]] = classes - 1;\r\n    }\r\n    vector<int> pn(n), cn(n);\r\n    for (int h = 0; (1 << h) < n; ++h)\r\n    {\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            pn[i] = p[i] - (1 << h);\r\n            if (pn[i] < 0)\r\n                pn[i] += n;\r\n        }\r\n        fill(cnt.begin(), cnt.begin() + classes, 0);\r\n        for (int i = 0; i < n; i++)\r\n            cnt[c[pn[i]]]++;\r\n        for (int i = 1; i < classes; i++)\r\n            cnt[i] += cnt[i - 1];\r\n        for (int i = n - 1; i >= 0; i--)\r\n            p[--cnt[c[pn[i]]]] = pn[i];\r\n        cn[p[0]] = 0;\r\n        classes = 1;\r\n        for (int i = 1; i < n; i++)\r\n        {\r\n            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\r\n            pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};\r\n            if (cur != prev)\r\n                ++classes;\r\n            cn[p[i]] = classes - 1;\r\n        }\r\n        c.swap(cn);\r\n    }\r\n    fo(i, p.size())\r\n    {\r\n        cout << p[i] << \" \";\r\n    }\r\n*/\r\n"
}