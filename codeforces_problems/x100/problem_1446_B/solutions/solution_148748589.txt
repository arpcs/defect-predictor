{
    "id": 148748589,
    "contestId": 1446,
    "creationTimeSeconds": 1646702589,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1446,
        "index": "B",
        "name": "Catching Cheaters",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1800,
        "tags": [
            "dp",
            "strings"
        ]
    },
    "author": {
        "contestId": 1446,
        "members": [
            {
                "handle": "lucasaires"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1605450900
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 108,
    "timeConsumedMillis": 405,
    "memoryConsumedBytes": 145510400,
    "source": "import java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.PrintWriter;\r\nimport java.math.BigInteger;\r\nimport java.util.*;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\n \r\n//import com.sun.tools.javac.code.Attribute.Array;\r\n \r\npublic class c731 {\r\n \r\n\tpublic static void main(String[] args) throws IOException {\r\n   \r\n//\t\ttry {\r\n \r\n\t\t\r\n\t\tBufferedWriter out = new BufferedWriter(\r\n\t            new OutputStreamWriter(System.out));\r\n\t\tBufferedReader br = new BufferedReader(\r\n\t\t        new InputStreamReader(System.in));\r\n\t\tPrintWriter pt = new PrintWriter(System.out);\r\n\t\tFastReader sc = new FastReader();\r\n \r\n//\t\tint t = sc.nextInt();\r\n//for(int o = 0; o<t;o++) {\r\n//\r\n//}\r\n\t\t\r\n\t\tint n = sc.nextInt();\r\n\t\tint m = sc.nextInt();\r\n\t\tString s1 = sc.next();\r\n\t\tString s2 = sc.next();\r\n\t\tint[][] dp = new int[n+1][m+1];\r\n\t\tfor(int i = 0 ; i<=n;i++) {\r\n\t\t\tfor(int j = 0 ; j<=m;j++) {\r\n\t\t\t\tif(i == 0 || j == 0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\tif(s1.charAt(i-1) == s2.charAt(j-1)) {\r\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 2;\r\n\t\t\t}else {\r\n\t\t\t\tdp[i][j] = Math.max(0, Math.max(dp[i-1][j] -1 , dp[i][j-1]-1));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tint max = 0;\r\n\t\t\r\n\t\tfor(int i = 0 ; i<=n;i++) {\r\n\t\t\tfor(int j = 0 ; j<=m;j++) {\r\n//\t\t\t\tSystem.out.print(dp[i][j] + \" \");\r\n\t\t\tmax = Math.max(max, dp[i][j]);\r\n\t\t\t}\r\n//\t\tSystem.out.println();\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(max);\r\n\t\t\r\n//\t}\r\n\t\t\r\n//out.flush();\r\n \r\n//     }catch(Exception e) {\r\n//    \t return;\r\n//     }\r\n\t}\r\n     \r\n     \r\n//------------------------------------------------------------------------------------------------------------------------------------------------\r\n \r\n \r\npublic static boolean solve(int[] arr, int s ){\r\n        int n = arr.length+1;\r\n        int m = s+1;\r\n        boolean[][] dp = new boolean[arr.length+1][s+1];\r\n        dp[0][0] = true;\r\n        for(int i = 1 ; i<n;i++){\r\n                for(int j = 0 ; j<m;j++){\r\n                        if(j==0){\r\n                                dp[i][j] = true;\r\n                        }\r\n                if(j-arr[i-1]>=0){\r\n                        dp[i][j] = dp[i-1][j] || dp[i-1][j-arr[i-1]];\r\n                }else{\r\n                        dp[i][j] = dp[i-1][j];\r\n                }\r\n                \r\n                \r\n                }\r\n        }\r\nreturn dp[n-1][m-1];        \r\n        \r\n}\r\n \r\n\t\r\npublic static int lis(int[] arr) {\r\n\tint n = arr.length;\r\n\tArrayList<Integer> al = new ArrayList<Integer>();\r\n\tal.add(arr[0]);\r\n\tfor(int i = 1 ; i<n;i++) {\r\n\t\tint x = al.get(al.size()-1);\r\n\t\tif(arr[i]>=x) {\r\n\t\t\tal.add(arr[i]);\r\n\t\t}else {\r\n\t\t\tint v = upper_bound(al, 0, al.size(), arr[i]);\r\n\t\t\tal.set(v, arr[i]);\r\n\t\t}\r\n\t}\r\nreturn al.size();\r\n}\r\n \r\nstatic int cntDivisors(int n){\r\n        int cnt = 0;\r\n\t\tfor (int i=1; i<=Math.sqrt(n); i++)\r\n        {\r\n            if (n%i==0)\r\n            {\r\n                if (n/i == i)\r\n                \tcnt++;\r\n                \t\r\n                else \r\n                \tcnt+=2;\r\n            }\r\n        }\r\n    \r\n    return cnt;\r\n    }\r\n\t\r\n\t\r\n\t\r\nstatic long power(long x, long y, long p){\r\n  long res = 1;\r\n \r\n  x = x % p;\r\n \r\n  if (x == 0)\r\n    return 0; \r\n \r\n  while (y > 0){\r\n \r\n    if ((y & 1) != 0)\r\n      res = (res * x) % p;\r\n \r\n    y = y >> 1;\r\n    x = (x * x) % p;\r\n  \r\n  }\r\n  return res;\r\n}\r\n \r\n\t\r\n\t\r\n \r\n\tpublic static long ncr(long[] fac, int n , int r , long m) {\r\n\t\treturn fac[n]*(modInverse(fac[r], m))%m *(modInverse(fac[n-r], m))%m; \r\n\t}\r\n\t\r\n\t\r\n\tpublic static void build(int [][] seg,char []arr,int idx, int lo , int hi) {\r\n\tif(lo == hi) {\r\n//\t\tseg[idx] = arr[lo];\r\n\t\tseg[idx][(int)arr[lo]-'a'] = 1;\r\n\t\t\r\n\t\treturn;\r\n\t}\r\n\tint mid = (lo + hi)/2;\r\nbuild(seg,arr,2*idx+1, lo, mid);\r\nbuild(seg,arr,idx*2+2, mid +1, hi);\r\n//seg[idx] = Math.min(seg[2*idx+1],seg[2*idx+2]);\r\nfor(int i = 0 ; i<27;i++) {\r\n\tseg[idx][i] = seg[2*idx+1][i] + seg[2*idx + 2][i];\r\n}\r\n\t}\r\n//for f/inding minimum in range \r\npublic static void query(int[][]seg,int[]ans,int idx , int lo , int hi , int l , int r) {\r\n\tif(lo>=l && hi<=r) {\r\n\t\tfor(int i = 0 ; i<27;i++) {\r\n\t\t\tans[i]+= seg[idx][i];\r\n\t\t}\r\n\t\treturn ;\r\n\t}\r\nif(hi<l || lo>r) {\r\n\treturn;\r\n}\r\nint mid = (lo + hi)/2;\r\nquery(seg,ans,idx*2 +1, lo, mid, l, r);\r\nquery(seg,ans,idx*2 + 2, mid + 1, hi, l, r);\r\n//return Math.min(left, right);\r\n}\r\n//// for sum\r\n//\r\npublic static void update(int[][]seg,char[]arr,int idx, int lo , int hi , int node , char val) {\r\nif(lo == hi) {\r\n//\tseg[idx] += val;\r\nseg[idx][val-'a']++;\r\nseg[idx][arr[node]-'a']--;\r\n \r\n}else {\r\nint mid = (lo + hi )/2;\r\nif(node<=mid && node>=lo) {\r\nupdate(seg,arr, idx * 2 +1, lo, mid, node, val);\r\n}else {\r\nupdate(seg,arr, idx*2 + 2, mid + 1, hi, node, val);\r\n}\r\n//seg[idx] = seg[idx*2 + 1] + seg[idx*2 + 2];\r\nfor(int i = 0 ; i<27;i++) {\r\n\tseg[idx][i] = seg[2*idx+1][i] + seg[2*idx + 2][i];\r\n}\r\n}\r\n \r\n}\r\n\t\r\n\t\r\n\t\r\npublic static int lower_bound(ArrayList<Integer> ar,int lo , int hi , int k)\r\n{\r\n    int s=lo;\r\n    int e=hi;\r\n    while (s !=e)\r\n    {\r\n        int mid = s+e>>1;\r\n        if (ar.get(mid) <k)\r\n        {\r\n            s=mid+1;\r\n        }\r\n        else\r\n        {\r\n            e=mid;\r\n        }\r\n    }\r\n    if(s==ar.size())\r\n    {\r\n        return -1;\r\n    }\r\n    return s;\r\n}\t\r\n\t\r\npublic static int upper_bound(ArrayList<Integer> ar,int lo , int hi, int k)\r\n{\r\n    int s=lo;\r\n    int e=hi;\r\n    while (s !=e)\r\n    {\r\n        int mid = s+e>>1;\r\n        if (ar.get(mid) <=k)\r\n        {\r\n            s=mid+1;\r\n        }\r\n        else\r\n        {\r\n            e=mid;\r\n        }\r\n    }\r\n    if(s==ar.size())\r\n    {\r\n        return -1;\r\n    }\r\n    return s;\r\n}\t\r\n \r\n//\t-----------------------------------------------------------------------------------------------------------------------------------------------\r\n\tpublic static int gcd(int a, int b){\r\n        if (a == 0)\r\n            return b;\r\n        return gcd(b % a, a);\r\n    }\r\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\tpublic static long modInverse(long a, long m){\r\n        long m0 = m;\r\n        long y = 0, x = 1;\r\n \r\n        if (m == 1)\r\n            return 0;\r\n \r\n        while (a > 1) {\r\n            // q is quotient\r\n            long q = a / m;\r\n \r\n            long t = m;\r\n \r\n            // m is remainder now, process\r\n            // same as Euclid's algo\r\n            m = a % m;\r\n            a = t;\r\n            t = y;\r\n \r\n            // Update x and y\r\n            y = x - q * y;\r\n            x = t;\r\n        }\r\n \r\n        // Make x positive\r\n        if (x < 0)\r\n            x += m0;\r\n \r\n        return x;\r\n    }\r\n \r\n\t\t\r\n \r\n//-----------------------------------------------------------------------------------------------------------------------------------\r\n \r\n\t//segment tree\r\n\t//for finding minimum in range \r\n//\tpublic static void build(int [] seg,int []arr,int idx, int lo , int hi) {\r\n//\t\tif(lo == hi) {\r\n//\t\t\tseg[idx] = arr[lo];\r\n//\t\t\treturn;\r\n//\t\t}\r\n//\t\tint mid = (lo + hi)/2;\r\n//\tbuild(seg,arr,2*idx+1, lo, mid);\r\n//\tbuild(seg,arr,idx*2+2, mid +1, hi);\r\n//\tseg[idx] = Math.min(seg[2*idx+1],seg[2*idx+2]);\r\n//\t}\r\n////for finding minimum in range \r\n//public static int query(int[]seg,int idx , int lo , int hi , int l , int r) {\r\n//\t\tif(lo>=l && hi<=r) {\r\n//\t\t\treturn seg[idx];\r\n//\t\t}\r\n//\tif(hi<l || lo>r) {\r\n//\t\treturn Integer.MAX_VALUE;\r\n//\t}\r\n//\tint mid = (lo + hi)/2;\r\n//\tint left = query(seg,idx*2 +1, lo, mid, l, r);\r\n//\tint right = query(seg,idx*2 + 2, mid + 1, hi, l, r);\r\n//\treturn Math.min(left, right);\r\n//}\r\n//\t// for sum\r\n//\r\n//public static void update(int[]seg,int idx, int lo , int hi , int node , int val) {\r\n//\tif(lo == hi) {\r\n//\t\tseg[idx] += val;\r\n//\t}else {\r\n//int mid = (lo + hi )/2;\r\n//if(node<=mid && node>=lo) {\r\n//\tupdate(seg, idx * 2 +1, lo, mid, node, val);\r\n//}else {\r\n//\tupdate(seg, idx*2 + 2, mid + 1, hi, node, val);\r\n//}\r\n//seg[idx] = seg[idx*2 + 1] + seg[idx*2 + 2];\r\n//\r\n//}\r\n \r\n//}\r\n \r\n//---------------------------------------------------------------------------------------------------------------------------------------\r\n \r\n \r\n//\tstatic void shuffleArray(int[] ar)\r\n//\t  {\r\n//\t    // If running on Java 6 or older, use `new Random()` on RHS here\r\n//\t    Random rnd = ThreadLocalRandom.current();\r\n//\t    for (int i = ar.length - 1; i > 0; i--)\r\n//\t    {\r\n//\t      int index = rnd.nextInt(i + 1);\r\n//\t      // Simple swap\r\n//\t      int a = ar[index];\r\n//\t      ar[index] = ar[i];\r\n//\t      ar[i] = a;\r\n//\t    }\r\n//\t  }\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------\r\n \r\n}\r\n \r\n \r\nclass FastReader {\r\n    BufferedReader br;\r\n    StringTokenizer st;\r\n \r\n    public FastReader()\r\n    {\r\n        br = new BufferedReader(\r\n            new InputStreamReader(System.in));\r\n    }\r\n \r\n    String next()\r\n    {\r\n        while (st == null || !st.hasMoreElements()) {\r\n            try {\r\n                st = new StringTokenizer(br.readLine());\r\n \r\n            \r\n            \r\n            \r\n            \r\n            }\r\n            catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return st.nextToken();\r\n    }\r\n \r\n    int nextInt() { return Integer.parseInt(next()); }\r\n \r\n    long nextLong() { return Long.parseLong(next()); }\r\n \r\n    double nextDouble()\r\n    {\r\n        return Double.parseDouble(next());\r\n    }\r\n \r\n    String nextLine()\r\n    {\r\n        String str = \"\";\r\n        try {\r\n            str = br.readLine();\r\n        }\r\n        catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return str;\r\n    }\r\n}\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nclass SegmentTree{\r\n\t\r\nint n;\r\n\tpublic SegmentTree(int[] arr,int n) {\r\n\t\tthis.arr = arr;\r\n\t\tthis.n = n;\r\n\t}\r\n\tint[] arr = new int[n];\r\n//\tint n = arr.length;\r\n\tint[] seg = new int[4*n];\r\n\tvoid build(int idx, int lo , int hi) {\r\n\t\tif(lo == hi) {\r\n\t\t\tseg[idx] = arr[lo];\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint mid = (lo + hi)/2;\r\n\tbuild(2*idx+1, lo, mid);\r\n\tbuild(idx*2+2, mid +1, hi);\r\n\tseg[idx] = Math.min(seg[2*idx+1],seg[2*idx+2]);\r\n\t}\r\n\tint query(int idx , int lo , int hi , int l , int r) {\r\n\t\tif(lo<=l && hi>=r) {\r\n\t\t\treturn seg[idx];\r\n\t\t}\r\n\tif(hi<l || lo>r) {\r\n\t\treturn Integer.MAX_VALUE;\r\n\t}\r\n\tint mid = (lo + hi)/2;\r\n\tint left = query(idx*2 +1, lo, mid, l, r);\r\n\tint right = query(idx*2 + 2, mid + 1, hi, l, r);\r\n\treturn Math.min(left, right);\r\n\t}\r\n\t\r\n\t\r\n}\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------\r\nclass coup{\r\n\tint a; \r\n\tint b;\r\n\tpublic coup(int a , int b) {\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t}\r\n}\r\n \r\nclass trip{\r\n\tint a , b, c;\r\n\tpublic trip(int a , int b, int c) {\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t}\r\n}"
}