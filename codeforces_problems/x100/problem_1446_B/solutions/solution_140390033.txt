{
    "id": 140390033,
    "contestId": 1446,
    "creationTimeSeconds": 1640294148,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1446,
        "index": "B",
        "name": "Catching Cheaters",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1800,
        "tags": [
            "dp",
            "strings"
        ]
    },
    "author": {
        "contestId": 1446,
        "members": [
            {
                "handle": "munditva"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1605450900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\n#define MOD (lli)(1e9+7)\n#define PR 998244353\n#define INF LLONG_MAX\n#define newl cout<<'\\n'\n#define space cout<<' '\n#define bar cout<<'-'\n#define mt make_tuple \n#define pb push_back\n#define pob pop_back\n#define ff first\n#define ss second\n#define vi vector<lli>\n#define pll pair <lli,lli>\n#define vpi vector<pll >\n#define all(p) p.begin(),p.end()\n#define lli long long\n#define sz(a) (lli)((a).size())\n#define form(i, l, r) for (lli i = l; i > r; --i)\n#define forl(i, l, r) for (lli i = l; i < r; ++i)\n#define pat(i, l, r, a); for (lli i = l; i < r; ++i){cout<<a[i]<<\" \";}cout<<endl;\n#define ppt(i, l, r, a); for (lli i = l; i < r; ++i){cout<<a[i].ff<<\"-\"<<a[i].ss<<\" \";}cout<<endl;\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n \n// typedef tree<lli,null_type,less<lli>,rb_tree_tag,\n// tree_order_statistics_node_update> ordered_set;\n \n// unordered_map<lli, lli, custom_hash> mp;\n// gp_hash_table<lli,lli, custom_hash> mp;\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n \n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n \n// 10 power 8 operations is the current industry standard (remember !)\n//at max arrays of 10e6 can only be declared inside main()  // At global scope the upper bound is 10e7\n \n//vector front back push_back pop_back\n//dequeue has both push_back and push_front and same for pop functions\n//vector init can be done  as vi v{23,34,23,4}or v{arr,arr+n} or v{vec2.begin(),vec2.end()}\n//or v(length_to_be_initialized,initialization_value )\n \n//set find end insert erase //does not allow duplicates //use multiset for duplicates \n//implemented as red black binary search tree\n//unordered_multiset or just multiset both have a function count //syntax set_name.count(element)\n \n//prio q top push pop size empty emplace swap erase //allows duplic ates// implemented as max heap-\n//use - minus distances for min heap\n \n//lb lower_bound gives the position of the first element which is more than  or equal to the input \n//ub or upper_bound gives the postion of the first element which is more than the input.\n//syntax for both : lower_bound(v,begin(), v.wnd(),input)\n \n//make_tuple for more than a pair of values // get <index> (tuple_name) //indices are 0-indexed\n//__builtin_popcount(element) gives no. of set bits in element\n//Set operations like union, intersection, complement, difference : a|b,a&b,~(tilde)a, a&-(tilde)b.\n \n//common error in code: \n//bitwise operators and referencing should always be used with brackets\n//loops or condtional statements should not have the semicolon at the end\n//look for equals to or double equals to carefully \n//check the prime number again for prime mod problems\n//don't change loop varible or loop limits inside the loop  \n//ctrl bv lines (remember the lazy sum jhol) don't cpy bllindly !!\n//right shift 1 is division by 2\n// const int N=1000; \n// for interactive problems print all queries using a single cout ending with endl\n\ninline lli powmod(lli base,lli exponent,lli mod=MOD)\n{ \n\tlli ans=1;\n\twhile(exponent)\n\t{\n\t\tif(exponent&1) ans=(ans*base)%mod;\n\t\tbase=(base*base)%mod;\n\t\texponent>>=1;\n\t}\n\treturn ans;\n}\n\n// lli fs[N][N]={{1,1,1},{1,0,0},{0,1,0}};\n// lli cs[N][N]={{1,1,1,2,-4},{1,0,0,0,0},{0,1,0,0,0},{0,0,0,1,1},{0,0,0,0,1}};\n// // lli f2[N][N]={{1,1},{1,0}};\n// //lli ars[N][N]={{1,1},{1,0}};\n\n// lli temp[N][N];\n// lli ret[N][N];\n\n// void matmod(lli n,lli exponent,lli arr[N][N])\n// {\n// \tlli i,j,k,ans,mod=MOD-1;\n// \twhile(exponent>0)\n// \t{\n// \t\tif(exponent&1) \n// \t\t{\n// \t\t\tforl(i,0,n)\n// \t\t\t{\n// \t\t\t\tforl(j,0,n)\n// \t\t\t\t{\n// \t\t\t\t\tans=0;\n// \t\t\t\t\tforl(k,0,n)\n// \t\t\t\t\t{\n// \t\t\t\t\t\tans+=ret[i][k]*(arr)[k][j];\n// \t\t\t\t\t\tans%=mod;\n// \t\t\t\t\t}\n// \t\t\t\t\ttemp[i][j]=ans;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tforl(i,0,n)\n// \t\t\t{\n// \t\t\t\tforl(j,0,n) ret[i][j]=temp[i][j];\n// \t\t\t}\n// \t\t}\n\n// \t\texponent>>=1;\n// \t\tforl(i,0,n)\n// \t\t{\n// \t\t\tforl(j,0,n)\n// \t\t\t{\n// \t\t\t\tans=0;\n// \t\t\t\tforl(k,0,n)\n// \t\t\t\t{\n// \t\t\t\t\tans+=(arr)[i][k]*(arr)[k][j];\n// \t\t\t\t\tans%=mod;\n// \t\t\t\t}\n// \t\t\t\ttemp[i][j]=ans;\n// \t\t\t}\n// \t\t}\n// \t\tforl(i,0,n)\n// \t\t{\n// \t\t\tforl(j,0,n) (arr)[i][j]=temp[i][j];\n// \t\t}\n// \t}\n// }\n\n// // vi v[N];\n// // lli ans[N]={0};\n// // lli vis[N]={0};\n// // lli mx[N]={0};\n// // lli val[N]={0};\n// // lli dep=0;\n\n// // void dfs2(lli ch,lli p)\n// // {\n// // \tvis[ch]=0;\n// // \tif(mx[ch]<0) mx[ch]=max((lli)-1,mx[p]-1);\n// // \telse \n// // \t{\n// // \t\tmx[ch]=max(mx[ch],mx[p]);\n// // \t}\n// // \tfor(auto x: v[ch])\n// // \t{\n// // \t\tif(vis[x])\n// // \t\t{\n// // \t\t\tdfs2(x,ch);\n// // \t\t\t// mx[]+=max(dfs(p),0);\n// // \t\t}\n// // \t}\n// // }\n// // // <lli> st[100005];\n// vi Pr;\n// vector<vector<int>> vst(200009);\n// inline void siv(lli n)\n// {\n// \tlli i,p;\n// \tvector <bool> prime(n,1);\n\n// \tfor (p=2; p<=n; p++) \n// \t{ \n// \t\tif (prime[p] == true)\n// \t\t{ \n// \t\t\tPr.push_back(p);\n// \t\t\tfor (i=p; i<=n; i += p)//do i=p*p if you just want to find primes \n// \t\t\t{\n// \t\t\t\tprime[i] = false;\n// \t\t\t\tvst[i].pb(p);\n// \t\t\t} \n// \t\t} \n// \t} \n// \t// for (i=p; i<=n; i++)\n// \t// {\n// \t// \tif (prime[i] == true)\n// \t// \t{ \n// \t// \t\tPr.push_back(i);\n// \t// \t\tvst[i].pb(i);\n// \t// \t}\n// \t// }\n// }\n\n// // vi v[100005];\n// // inline void fac(lli n)\n// // {\n// // \tlli i,j,k,p;\n// // \tforl(i,1,n)\n// // \t{\n// // \t\tfor(j=i;j<n;j+=i)\n// // \t\t{\n// // \t\t\tv[j].pb(i);\n// // \t\t}\n// // \t}\n// // }\n\n\n// // lli vis[N]={0};\n// // lli ar[N];\n// // unordered_map<lli,lli> mp;\n// // void dfs(lli p,lli ch)\n// // {\n// // \tvis[p]=1;\n// // \tfor(auto x: v[p])\n// // \t{\n// // \t\tif(!mp[ar[x]])\n// // \t\t{\n// // \t\t\tcontinue;\n// // \t\t}\n// // \t\tlli tp=ar[p]-ar[x];\n// // \t\tif(mp[tp])\n// // \t\t{\n// // \t\t\tmp[tp]--;\n// // \t\t}\n// // \t\tdfs(x,ch); \n// // \t}\n// // }\n\n// vpi so;\n// int inv(int l,int m,int r)\n// {\n// \tlli n=r-l,a=l,b=m,c,d;\n// \tpll tp[n];\n// \tlli ct=0;\n// \tforl(i,l,r)\n// \t{\n// \t\t// j=i-l;\n// \t\tif(a>=m)\n// \t\t{\n// \t\t\tc=so[b].ff;\n// \t\t\td=so[b].ss;\n// \t\t\tb++;\n// \t\t}\n// \t\telse if(b>=r)\n// \t\t{\n// \t\t\tc=so[a].ff;\n// \t\t\td=so[a].ss;\n// \t\t\ta++;\n// \t\t}\n// \t\telse\n// \t\t{\n// \t\t\tif(so[a].ff<=so[b].ff)\n// \t\t\t{\n// \t\t\t\tc=so[a].ff;\n// \t\t\t\td=so[a].ss;\n// \t\t\t\ta++;\n// \t\t\t}\n// \t\t\telse \n// \t\t\t{\n// \t\t\t\tc=so[b].ff;\n// \t\t\t\td=so[b].ss;\n// \t\t\t\tb++;\n// \t\t\t\t// c=so[b++];\n// \t\t\t\tct+=m-a;\n// \t\t\t}\n// \t\t}\n// \t\ttp[i-l]={c,d};\n// \t}\n// \tforl(i,l,r)\n// \t{\n// \t\tso[i]=tp[i-l];\n// \t}\n// \treturn ct;\n// }\n\n// lli msort(int l,int r)\n// {\n// \tif(r-l<=1) return 0;\n// \telse \n// \t{\n// \t\tlli mid=(l+r)/2;\n// \t\tlli inv1=msort(l,mid);\n// \t\tlli inv2=msort(mid,r);\n// \t\tlli ct=inv(l,mid,r);\n// \t\t// pat(i,l,r,so);\n// \t\treturn inv1+inv2+ct;\n// \t}\n// }\n\n\n\n\n// lli par[N]={0};\n// lli rk[N]={0};\n// int find(int a)\n// {\n// \tif(a==par[a]) return a;\n// \telse\n// \t{\n// \t\tpar[a] = find(par[a]);\n// \t\treturn par[a];\n// \t}\n// }\n// int unite(int a,int b)\n// {\n// \tlli pa=find(a);\n// \tlli pb=find(b);\n// \t// return 1;\n// \tif(pa==pb)\n// \t{\n// \t\treturn 0;\n// \t}\n// \telse\n// \t{\n// \t\tif(rk[pa]<rk[pb])\n// \t\t{\n// \t\t\tswap(pa,pb);\n// \t\t}\n// \t\trk[pa]=max(rk[pa],rk[pb]+1);\n// \t\tpar[pb]=pa;\n// \t\t// cout<<pa;\n// \t\treturn 1; \n// \t}\n// }\n\n// int n;\n// const lli M=200005;\n// vi g[M], gt[M];\n// vector<bool> used;\n// vector<int> order, comp;\n// vector<bool> assignment;\n\n// void dfs1(int v) {\n//     used[v] = true;\n//     for (int u : g[v]) {\n//         if (!used[u])\n//             dfs1(u);\n//     }\n//     order.push_back(v);\n// }\n\n// void dfs2(int v, int cl) {\n//     comp[v] = cl;\n//     for (int u : gt[v]) {\n//         if (comp[u] == -1)\n//             dfs2(u, cl);\n//     }\n// }\n\n// bool solve_2SAT() {\n//     used.assign(n, false);\n//     for (int i = 0; i < n; ++i) {\n//         if (!used[i])\n//             dfs1(i);\n//     }\n\n//     comp.assign(n, -1);\n//     for (int i = 0, j = 0; i < n; ++i) {\n//         int v = order[n - i - 1];\n//         if (comp[v] == -1)\n//             dfs2(v, j++);\n//     }\n\n//     assignment.assign(n / 2, false);\n//     for (int i = 0; i < n; i += 2) {\n//         if (comp[i] == comp[i + 1])\n//             return false;\n//         assignment[i / 2] = comp[i] > comp[i + 1];\n//     }\n//     return true;\n// }\n// lli dp[3][100002];\n\n// lli dp1[20][20];\n// lli dp2[20][20];\n// lli s[20];\n// lli upt(lli num)\n// {\n\n// \tlli n=0;\n// \tlli d=0;\n// \tlli tp=num;\n// \twhile(num)\n// \t{\n// \t\ts[n++]=num%10;\n// \t\tnum/=10;\n// \t}\n// \tmemset(dp1,0,sizeof(dp1));\n// \tmemset(dp2,0,sizeof(dp2));\n\n// \tdp1[0][0]=9;\n// \tdp1[0][1]=1;\n\n// \tdp2[0][0]=s[0];\n// \tdp2[0][1]=1;\n\t\n// \tforl(i,1,n)\n// \t{\n// \t\tforl(j,0,n-3)\n// \t\t{\n// \t\t\tdp1[i][j]=9*dp1[i-1][j];\n// \t\t\tif(j) dp1[i][j]+=dp1[i-1][j-1];\n\n// \t\t\tlli a=0;\n// \t\t\tif(d>s[i])\n// \t\t\t{\n// \t\t\t\ta=dp1[i-1][j]*s[i];\n// \t\t\t\ta+=dp2[i-1][j];\n// \t\t\t}\n// \t\t\telse if(d==s[i])\n// \t\t\t{\n\t\t\t\n// \t\t\t\ta=dp1[i-1][j]*s[i];\n// \t\t\t\tif(j) a+=dp2[i-1][j-1];\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tif(s[i]) a=dp1[i-1][j]*(s[i]-1);\n// \t\t\t\tif(j) a+=dp1[i-1][j-1];\n// \t\t\t\ta+=dp2[i-1][j];\n// \t\t\t}\n// \t\t\tdp2[i][j]=a;\n// \t\t}\n// \t}\n// \tlli ans=0;\n// \tforl(i,0,n-3)\n// \t{\n// \t\tans+=dp2[n-1][i];\n// \t\t// cout<<dp2[n-1][i];space;\n// \t}\n// \treturn (tp-ans);\t\t\n// }\n\n\n\n// lli val[205];\n// lli vis[205];\n// lli dp[205];\n// pll pr[105];\n// lli n;\n// void find(lli cur,lli pos)\n// {\n// \t// dp[cur]=val[cur];\n// \tlli sc=pr[pos].ss;\n// \tlli tp=(cur-n)/sc;\n// \tif(tp)\n// \t{\n// \t\tvis[cur]=1;\n// \t\tif(!vis[cur-tp*sc]) find(cur-tp*sc,pos+1);\n// \t\tdp[cur]=min(val[cur],dp[cur-tp*sc]+tp*val[sc]);\n// \t}\n// \telse\n// \t{\n// \t\tif(!vis[cur]) find(cur,pos+1);\n// \t}\n// \t// return dp[cur];\n// }\n\n\n\n\n// const lli N=200005;\n// vi v[N];\n// lli unq[N]={0};\n// lli vis1[N]={0};\n// lli vis2[N]={0};\n// lli depth[N]={0};\n// lli dist[N]={0};\n// lli fork[N]={0};\n\n// lli dfs1(lli ch,lli d)\n// {\n// \tvis1[ch]=1;\n// \tdepth[ch]=d;\n// \td++;\n// \tlli mx=-1;\n// \tfor(auto x: v[ch])\n// \t{\n// \t\tif(!vis1[x])\n// \t\t{\n// \t\t\tlli tp=dfs1(x,d);\n// \t\t\tmx=max(tp,mx);\n// \t\t}\n// \t}\n// \tif(unq[ch]) \n// \t{\n// \t\treturn ch;\n// \t}\n// \telse\n// \t{\n// \t\tunq[ch]=mx;\n// \t\treturn mx;\n// \t}\n// }\n\n// void dfs2(lli ch,lli p,lli f,lli d)\n// {\n// \tvis2[ch]=1;\n// \td++;\n// \tif(unq[ch]>0)\n// \t{\n// \t\tdist[ch]=depth[ch];\n// \t\tfork[ch]=unq[ch];\n// \t}\n// \telse \n// \t{\n// \t\tdist[ch]=depth[p]-d;\n// \t\t// cout<<ch;bar;cout<<f;bar;cout<<p;bar;cout<<d;space;\n// \t\tfork[ch]=unq[f];\n// \t}\n// \tfor(auto x: v[ch])\n// \t{\n// \t\tif(!vis2[x])\n// \t\t{\n// \t\t\tif(unq[ch]>0)\n// \t\t\t{\n// \t\t\t\tdfs2(x,ch,unq[ch],0);\n// \t\t\t}\n// \t\t\telse\n// \t\t\t{\n// \t\t\t\tdfs2(x,p,f,d);\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n\n// const lli M=2e5;\n// vi v[M+5];\n// lli vis[M+5]={0};\n// vi whi;\n// vi bla;\n// lli val[M+5];\n// vi cw,cb;\n\n\n// void dfs1(lli ch,lli col)\n// {\n// \tvis[ch]=1;\n// \t// cout<<ch;bar;cout<<col;space;\n// \tif(col)\n// \t{\n// \t\tcb.pb(ch);\n// \t}\n// \telse\n// \t{\n// \t\tcw.pb(ch);\n// \t}\n\n// \tcol=1-col;\n// \tfor(auto x : v[ch])\n// \t{\n// \t\tif(!vis[x])\n// \t\t{\n// \t\t\tdfs1(x,col);\n// \t\t}\n// \t}\n// }\n\n\n\nmap<pll,lli> tot;\nmap<pll,pll> parent;\nmap<pll,lli> mini;\n// lli parent[M+5];\n// vpi ej;\n\npll find(pll v) \n{\n    if (v == parent[v]) return v;\n   \tparent[v] = find(parent[v]);\n   \treturn parent[v];\n}\n\nvoid uni(pll a, pll b) \n{\n    a = find(a);\n    b = find(b);\n    if (a != b) \n    {\n        if (tot[a] < tot[b]) swap(a, b);\n        parent[b] = a;\n        tot[a] += tot[b];\n        mini[a]=min(mini[a],mini[b]);\n    }\n}\n\n\n// void dfs(lli ch)\n// {\n// \tvis[ch]=1;\n// \tfor(auto x: v[ch])\n// \t{\n// \t\tif(!vis[x])\n// \t\t{\n// \t\t\tej.pb({ch,x});\n// \t\t\tuni(x,ch);\n// \t\t\tdfs(x);\n// \t\t}\n// \t}\n// }\n\n// lli dist(pll a,pll b)\n// {\n// \treturn (lli)(abs(a.ff-b.ff)+abs(a.ss-b.ss));\n// }\n\n// bool manhat(pll a,pll b, pll c)\n// {\n// \tif(dist(a,b)+dist(b,c)==dist(a,c))\n// \treturn true;\n// \telse \n// \treturn false;\n// }\n\n// lli lev[100];\n// lli calc(lli *ar,lli sz,lli num,lli * teams,lli A,lli h)\n// {\n// \tlli ans=0;\n// \tlli pr=PR;\n// \tfor(lli i=sz-2;i>=0;i-=2)\n// \t{\n// \t\tlli val=num&1;\n// \t\tnum=num>>1;\n// \t\tif(val)\n// \t\t{\n// \t\t\tswap(ar[i+1],ar[i]);\n// \t\t}\n// \t\tar[i/2]=ar[i];\n// \t\tans=(ans+(ar[i+1]*powmod(A,lev[i+1],pr))%pr)%pr;\n// \t\tteams[ar[i+1]]=lev[i+1];\n\n// \t\tif(val)\n// \t\t{\n// \t\t\tswap(ar[i+1],ar[i]);\n// \t\t}\n// \t}\n// \tteams[ar[0]]=1;\n// \tans=(ans+ar[0]*A)%pr;\n// \tif(ans==h)\n// \t{\n// \t\treturn 1;\n// \t}\n// \telse\n// \t{\n// \t\treturn 0;\n// \t}\n// }\n// lli mxf(lli *ar, lli sz)\n// {\n// \tfor(lli i=sz/2;i<sz;i+=2)\n// \t{\n// \t\tar[i/2]=min()\n// \t}\n// }\n\nconst lli M=5e5;\n\nint main() \n{\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlli a,b,c,d,e,q,h,i,j,k,m,n,n1,n2,n3;\n\tlli t,tt;\n\tlli mod=MOD, inf=LLONG_MAX;\n\tlli pr=998244353;\n\n\tsrand(time(NULL));\n\t// use rand() for getting random values uptil?\n\t// time_t begin,end;\n\t// time(&begin);\n\t// time(&end);\n\t// double difference = difftime (end,begin);\n\t// cout<<difference;\n\n\t// memset(vis,0,sizeof(vis));\n\t// memset(col,0,sizeof(col));\n\n\t// memset(vis,0,sizeof(vis));\n\n\t// const lli M=1e6;\n\n\t// lli fac[M+5];\n\t// lli inv[M+5];\n\t// memset(fac,0,sizeof(fac));\n\n\t// fac[0]=1;\n\t// inv[0]=1;\n\n\t// forl(i,1,M+5)\n\t// {\n\t// \tfac[i]=fac[i-1]*i;\n\t// \tfac[i]%=pr;\n\t// }\t\n\t// inv[M+1]=powmod(fac[M+1],pr-2,pr);\n\t// form(i,M,-1)\n\t// {\n\t// \tinv[i]=inv[i+1]*(i+1);\n\t// \tinv[i]%=pr;\n\t// }\n\n\t// lli cur=-1;\n\t// lev[1]=1;\n\t// forl(i,2,101)\n\t// {\n\t// \tif((i&(-i))==i)\n\t// \t{\n\t// \t\tcur++;\n\t// \t}\n\t// \tlev[i]=(1<<cur)+1;\n\t// }\n\n\t// lli near[M+5];\n\t// lli ct=-1;\n\t// forl(i,1,M)\n\t// {\n\t// \tif((i&(-i))==i)\n\t// \t{\n\t// \t\tct++;\n\t// \t}\n\t// \tnear[i]=ct;\n\t// }\n\n\t// lli primes[M+5];\n\t// memset(primes,1,sizeof(primes));\n\n\t// vi op;\n\t// forl(i,2,M+5)\n\t// {\n\t// \tif(primes[i])\n\t// \t{\n\t// \t\top.pb(i);\n\t// \t\t// if(i<=100) cout<<i,space;\n\t// \t\tfor(lli j=2*i;j<=M;j+=i)\n\t// \t\t{\n\t// \t\t\tprimes[j]=0;\n\t// \t\t}\t\t\t\n\t// \t}\n\t// }\n\n\n\n\tfor(t=1,tt=1;tt<=t;tt++,newl)\n\t{\n\n\t\tcin>>n>>m;\n\n\t\tlli dp[n+5][m+5];\n\t\tmemset(dp,0,sizeof(dp));\n\n\t\tstring s1,s2;\n\t\tcin>>s1>>s2;\n\n\t\tlli ans=0;\n\t\tforl(i,1,n+1)\n\t\t{\n\t\t\tforl(j,1,m+1)\n\t\t\t{\n\t\t\t\ta=dp[i-1][j-1];\n\t\t\t\tif(s1[i-1]==s2[j-1]) a+=2;\n\t\t\t\t// else \n\t\t\t\tdp[i][j]=max(dp[i][j],a);\n\t\t\t\tdp[i][j]=max(dp[i][j],max(dp[i][j-1],dp[i-1][j])-1);\n\t\t\t\tans=max(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans;\n\t\t// cin>>n;\n\n\t\t// lli ar[n];\n\n\t\t// forl(i,0,n)\n\t\t// {\n\t\t// \tcin>>ar[i];\n\t\t// }\n\t\t// // sort(ar,ar+n);\n\t\t// lli flag=0;\n\t\t// forl(i,0,n-1)\n\t\t// {\n\t\t// \tif(ar[i]!=ar[i+1])\n\t\t// \t{\n\t\t// \t\tflag=i+1;\n\t\t// \t\ta=ar[i];\n\t\t// \t\tb=ar[i+1];\n\t\t// \t\tbreak;\n\t\t// \t}\n\t\t// }\n\t\t// if(flag)\n\t\t// {\n\t\t// \tcout<<\"YES\";newl;\n\t\t// \tforl(i,0,n)\n\t\t// \t{\n\t\t// \t\tif(ar[i]!=a)\n\t\t// \t\t{\n\t\t// \t\t\tcout<<flag;space;\n\t\t// \t\t\tcout<<i+1;space;\n\t\t// \t\t\tnewl;\n\t\t// \t\t}\n\t\t// \t\telse\n\t\t// \t\t{\n\t\t// \t\t\tif(i+1!=flag)\n\t\t// \t\t\t{\n\t\t// \t\t\t\tcout<<flag+1;space;\n\t\t// \t\t\t\tcout<<i+1;space;\n\t\t// \t\t\t\tnewl;\t\t\t\t\t\t\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\t// else cout<<\"NO\";\n\n\t\t// vi arp,arn;\n\t\t// forl(i,0,n)\n\t\t// {\n\t\t// \tcin>>a;\n\t\t// \tif(a>0)\n\t\t// \t{\n\t\t// \t\tarp.pb(a);\n\t\t// \t}\n\t\t// \telse if(a<0) arn.pb(a);\n\t\t// }\n\t\t// a=0;\n\t\t// b=0;\n\t\t// forl(i,0,sz(arp))\n\t\t// {\n\t\t// \ta=__gcd(a,arp[i]);\n\t\t// }\n\t\t// forl(i,0,sz(arn))\n\t\t// {\n\t\t// \tb=__gcd(-b,-arn[i]);\n\t\t// }\n\n\t\t// lli ans=0;\n\t\t// if(sz(arp)==0)\n\t\t// {\n\t\t// \tans=b;\n\t\t// }\n\t\t// else if(sz(arn)==0)\n\t\t// {\n\t\t// \tans=a;\n\t\t// }\n\t\t// else if(sz(arp)==1 and sz(arn)==1 and n==2)\n\t\t// {\n\t\t// \tans=arp[0]-arn[0];\n\t\t// }\n\t\t// else\n\t\t// {\n\t\t// \tc=__gcd(a,b);\n\t\t// \tans=2*c;\n\t\t// }\n\n\t\t// cout<<ans;\n\n\n\n\n\t\t// cin>>n>>m;\n\n\t\t// vi v1;\n\t\t// vi v2;\n\n\t\t// forl(i,0,n)\n\t\t// {\n\t\t// \tcin>>a;\n\t\t// \tv1.pb(a);\n\t\t// }\n\t\t// v1.pb(0);\n\n\t\t// forl(i,0,m)\n\t\t// {\n\t\t// \tcin>>a;\n\t\t// \tv2.pb(a);\n\t\t// }\n\n\t\t// reverse(all(v1));\n\t\t// sort(all(v2));\n\t\t\n\t\t// reverse(all(v2));\n\t\t// v2.pb(0);\n\n\t\t// pll ar[n+1];\n\t\t// ar[0]={0,1};\n\t\t// forl(i,1,n+1)\n\t\t// {\n\t\t// \tif(ar[i-1].ff<v1[i])\n\t\t// \t{\n\t\t// \t\tar[i]={v1[i],n+1-i};\n\t\t// \t}\n\t\t// \telse\n\t\t// \t{\n\t\t// \t\tar[i]=ar[i-1];\n\t\t// \t}\n\t\t// \t// else if(ar[i-1].ff==v1[i])\n\t\t// \t// {\n\t\t// \t// \tar[i]={v1[i],ar[i-1].ss+1};\n\t\t// \t// }\n\t\t// }\n\n\t\t// lli ct=1;\n\t\t// vpi mx;\n\n\t\t// forl(i,0,m)\n\t\t// {\n\t\t// \tif(ar[i]!=ar[i+1])\n\t\t// \t{\n\t\t// \t\tmx.pb(ar[i],ct);\n\t\t// \t\tct=1;\n\t\t// \t}\n\t\t// \telse ct++;\n\t\t// }\n\n\t\t// reverse(ar,ar+n+1);\n\n\t\t// lli j=0;\n\n\t\t// forl()\n\n\n\t\t// cin>>n;\n\n\t\t// lli ar[n+5];\n\n\t\t// forl(i,1,n-1)\n\t\t// {\n\t\t// \tcout<<'?'<<' '<<i<<' '<<i+1<<' '<<i+2<<endl;\n\t\t// \tcin>>ar[i];\n\t\t// }\n\n\t\t// forl(i,1,n-1-2)\n\t\t// {\n\t\t// \tlli sum=0;\n\t\t// \tforl(j,0,3)\n\t\t// \t{\n\t\t// \t\tsum+=ar[i+j];\n\t\t// \t}\n\t\t// \tif(sum==1)\n\t\t// \t{\n\t\t// \t\tif(ar[i+1]==1)\n\t\t// \t\t{\n\t\t// \t\t\ta=i;\n\t\t// \t\t\tb=i+1;\n\t\t// \t\t}\n\t\t// \t\telse if(ar[i]==1)\n\t\t// \t\t{\n\t\t// \t\t\ta=i+4;\n\t\t// \t\t\tb=i;\n\t\t// \t\t}\n\t\t// \t\telse\n\t\t// \t\t{\n\t\t// \t\t\ta=i;\n\t\t// \t\t\tb=i+4;\t\t\t\t\t\n\t\t// \t\t}\n\t\t// \t\tbreak;\n\t\t// \t}\n\t\t// \tif(sum==2)\n\t\t// \t{\n\t\t// \t\tif(ar[i+1]==0)\n\t\t// \t\t{\n\t\t// \t\t\ta=i+1;\n\t\t// \t\t\tb=i;\n\t\t// \t\t}\n\t\t// \t\telse if(ar[i]==0)\n\t\t// \t\t{\n\t\t// \t\t\ta=i;\n\t\t// \t\t\tb=i+4;\n\t\t// \t\t}\n\t\t// \t\telse\n\t\t// \t\t{\n\t\t// \t\t\ta=i+4;\t\t\t\t\t\n\t\t// \t\t\tb=i;\n\t\t// \t\t}\n\t\t// \t\tbreak;\n\t\t// \t}\n\t\t// }\n\n\t\t// lli ans=1;\n\t\t// vi ind;\n\t\t// ind.pb(a);\n\t\t// forl(i,1,n+1)\n\t\t// {\n\t\t// \tif(i!=a and i!=b)\n\t\t// \t{\t\t\t\n\t\t// \t\tcout<<'?'<<' '<<a<<' '<<b<<' '<<i<<endl;\n\t\t// \t\tcin>>c;\n\t\t// \t\tif(c==0)\n\t\t// \t\t{\n\t\t// \t\t\tind.pb(i);\n\t\t// \t\t\tans++;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// cout<<'!'<<' '<<ans<<' ';\n\t\t// forl(i,0,ans)\n\t\t// {\n\t\t// \tcout<<ind[i]<<' ';\n\t\t// }\n\t\t// cout<<endl;\n\n\n\t\t// cin>>n;\n\t\t// lli row=log2(n)+1;\n\n\t\t// lli inp[n+5];\n\t\t// forl(i,0,n)\n\t\t// {\n\t\t// \tcin>>inp[i+1];\n\t\t// }\n\n\t\t// lli ar[row][n+5];\n\n\t\t// forl(i,0,n)\n\t\t// {\n\t\t// \tar[0][i+1]=inp[i+1]+i+1;\n\t\t// }\n\n\t\t// forl(i,1,row)\n\t\t// {\n\t\t// \tfor(lli j=1;j<=n-(1<<i)+1;j++)\n\t\t// \t{\n\t\t// \t\tar[i][j]=max(ar[i-1][j],ar[i-1][j+(1<<(i-1))]);\n\t\t// \t}\n\t\t// }\n\n\t\t// lli dp[n+5];\n\t\t// lli ans[n+5]={0};\n\t\t// lli fans[n+5]={0};\n\n\t\t// lli pts[n+5];\n\n\t\t// dp[0]=0;\n\t\t// forl(i,1,n+1)\n\t\t// {\n\t\t// \tif(dp[i-1]>=i)\n\t\t// \t{\n\t\t// \t\tdp[i]=max(dp[i-1],i+inp[i]);\n\t\t// \t\tpts[i]=i-1;\n\t\t// \t\tans[i]=1;\n\t\t// \t\tcontinue;\n\t\t// \t}\n\t\t// \tlli find=max(i-inp[i]-1,(lli)0);\n\t\t// \tif(dp[i-1]<find)\n\t\t// \t{\n\t\t// \t\tdp[i]=dp[i-1];\n\t\t// \t\tpts[i]=i-1;\n\t\t// \t\tans[i]=1;\n\t\t// \t\tcontinue;\n\t\t// \t}\n\t\t// \tlli val=0;\n\t\t// \tif(find==0)\n\t\t// \t{\n\t\t// \t\tval=0;\n\t\t// \t}\n\t\t// \telse\n\t\t// \t{\n\t\t// \t\tlli ct=30;\n\t\t// \t\twhile(ct>=0)\n\t\t// \t\t{\n\t\t// \t\t\tlli temp=val+(1<<ct);\n\t\t// \t\t\tct--;\n\t\t// \t\t\tif(temp>=i) continue;\n\t\t// \t\t\tif(dp[temp]<find)\n\t\t// \t\t\t{\n\t\t// \t\t\t\tval=temp;\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t\tval++;\n\t\t// \t}\n\t\t// \tlli el=i-(val+1);\n\t\t// \tpts[i]=val;\n\t\t// \tans[i]=0;\n\t\t// \tif(!el)\n\t\t// \t{\n\t\t// \t\tdp[i]=i-1;\n\t\t// \t\tcontinue;\n\t\t// \t}  \n\t\t// \tlli r=near[el];\n\t\t// \tlli mx=max(ar[r][val+1],ar[r][i-(1<<r)]);\n\t\t// \tdp[i]=mx;\n\t\t// }\n\n\n\t\t// lli curr=n;\n\t\t// while(curr)\n\t\t// {\n\t\t// \tif(ans[curr]==0) fans[curr]=1;\n\t\t// \tif(curr>n or curr<0)\n\t\t// \t{\n\t\t// \t\tcout<<-1;\n\t\t// \t\tbreak;\n\t\t// \t}\n\t\t// \telse\n\t\t// \t{\n\t\t// \t\tcurr=pts[curr];\n\n\t\t// \t}\n\t\t// }\n\n\t\t// if(dp[n]>=n)\n\t\t// {\n\t\t// \tcout<<\"YES\";newl;\n\t\t// \tforl(i,1,n+1)\n\t\t// \t{\n\t\t// \t\tif(fans[i]==0) cout<<'R';\n\t\t// \t\telse cout<<'L';\n\n\t\t// \t}\n\t\t// } \n\t\t// else cout<<\"NO\";\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}