{
    "id": 140838276,
    "contestId": 26,
    "creationTimeSeconds": 1640633802,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 26,
        "index": "D",
        "name": "Tickets",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2400,
        "tags": [
            "combinatorics",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 26,
        "members": [
            {
                "handle": "anurat123"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1281970800
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "/*\n           .--.                  Try not.\n ::\\`--._,'.::.`._.--'/::     Do or do not.\n ::::.  ` __::__ '  .::::    There is no try.\n ::::::-:.`'..`'.:-::::::\n ::::::::\\ `--' /::::::::              -Yoda\n \n-->Take care regarding graph questions while taking input 1/0 indexed\n-->Always use (ll)round() after doing fft to get correct result and make \n   sure it fits within ll\n////////////////|!!!!ALERT!!!!|\\\\\\\\\\\\\\\\\\\n--!!!!!>DONT FORGET TO SWITCH OFF DB BEFORE SUBMISSION<!!!!----\n-->TO handle overflow use difference in comparison\n-->Subarray Max prop think kadanes\n-->Try to avoid default string comparator\n-->Questions are not complicated(except those [implementation])\n-->Codes are short and simple\n-->Thats the charm of CP\n-->Do not overthink\n-->Find an invariant\n-->If you think there is any monotonicity==>binary search\n-->Optimal substructure with low constraints==>dp\n-->Grids==>Maybe Graph\n-->very large contraints:Either simple math or log complexity\n-->For greedy invariant identification is the most imp step\n-->Enjoy while u code\n-->Follow 20-20-20 rule(v.v imp)\n-->Beware of Seg Fault in Seg Tree(2*n/4*n)\n-->Dont Hip Hop between problems\n-->For segfault first check if you have alloted enough memory\n-->Use fast pow even when base is 2 and not '<<' operator to prevent overflow\n-->Have fun,this is after all a mind sport\n                                  */\n\n#include<bits/stdc++.h>\n#define ll long long int\n#define vl vector<ll>\n#define vpl vector<pair<ll,ll>>\n#define vvl vector<vl>\n#define pl pair<ll,ll>\n#define mpl map<ll,ll>\n#define umpl unordered_map<ll,ll>\n#define umplc unordered_map<char,ll>\n#define hf 31\n#define f first\n#define s second\n#define pb push_back\n#define pp pop_back\n//#define file_ipop\n#define MOD\n#define M 1000000007\n#define fr(i,str,n) for(ll i=str;i<n;++i)\n#define nl cout<<endl\n//#define DB\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi; \ntypedef vector<pair<int,int>> vpi;\n\n#ifdef DB\n#define debug(x) cerr << #x << '=' << (x) << endl;\n#define debugBIT(bit)                               \\\n    {                                               \\\n        cerr << \"BIT: \";                            \\\n        for (int i = 0; i < bit.size() - 1; i++)    \\\n        {                                           \\\n            if (i == 0)                             \\\n                cerr << qry(i) << \" \";              \\\n            else                                    \\\n                cerr << qry(i) - qry(i - 1) << \" \"; \\\n        }                                           \\\n        cerr << endl;                               \\\n    }\n\n#else\n#define debug(x) \n#define debugBIT(bit)\n#endif\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef uniform_int_distribution<ll> uni_dist;\nll abss(ll a)\n{\n    if(a<0)\treturn -a;\n    return a;\n}\nll ones(ll a)\n{\n  ll cnt = 0;\n  while(a>0)\n  {\n    if(a&1) cnt++;\n    a>>=1;\n  }\n  return cnt;\n}\n#ifdef MOD\nll fast_pow(ll b, ll e,ll width=M)\n{\n  if(e==0)\n  {\n    return 1;\n  }\n  else if(e==1)\n  {\n    return b%width;\n  }\n  b = b%width;\n  ll ans = 1;\n  while(e>0)\n  {\n    if((e&1)==1)\n    {\n      ans = (ans*b)%width;\n    }\n    e>>=1;\n    b = (b*b)%width;\n  }\n  return ans;\n}\nll mod_inv(ll a,ll width=M)\n{\n  return fast_pow(a,width-2,width);\n}\ntemplate<typename Number,Number width>\nclass ModularArithmetic\n{\n  private :\n    Number n;\n  public:\n    friend ostream& operator<<(ostream& os, ModularArithmetic const & num) {\n        return os << num.n;\n      }\n    friend istream& operator>>(istream &is,ModularArithmetic  & num)\n    {\n      is>>num.n;return is;\n    }\n    ModularArithmetic() : n(0){}\n    ModularArithmetic(Number n) : n(n % width){if(this->n<0)this->n+=width;}\n    Number get() const {return n;}\n    ModularArithmetic operator+(const ModularArithmetic &b){Number t = (n+b.get())%width;if(t<0)return ModularArithmetic(width+t);return ModularArithmetic(t);}\n    ModularArithmetic operator-(const ModularArithmetic &b){Number t = (n-b.get())%width;if(t<0)return ModularArithmetic(width+t);return ModularArithmetic(t);}\n    ModularArithmetic operator*(const ModularArithmetic &b){Number t = (n*b.get())%width;if(t<0)return ModularArithmetic(width+t);return ModularArithmetic(t);}\n    ModularArithmetic operator/(const ModularArithmetic &b)\n    {\n        assert(b.get()!=0);\n        Number ans = n*mod_inv(b.get(),width);\n        if((ans)<0)return ModularArithmetic(width+(ans)%width);return ModularArithmetic(ans%width);\n    }\n    ModularArithmetic &operator+=(const ModularArithmetic &b){n = (n+b.get())%width;if(n<0)n=n+width;return *this;}\n    ModularArithmetic &operator-=(const ModularArithmetic &b){n = (n-b.get())%width;if(n<0)n=n+width;return *this;}\n    ModularArithmetic &operator*=(const ModularArithmetic &b){n = (n*b.get())%width;if(n<0)n=n+width;return *this;}\n    ModularArithmetic &operator/=(const ModularArithmetic &b)\n    {\n      assert(b.get()!=0);\n        n = (n*mod_inv(b.get(),width))%width;if(n<0)n=n+width;return *this;\n    }\n};\ntypedef ModularArithmetic<ll,M> lm;\ntypedef vector<lm> vlm;\n#endif\n\n\ntemplate<class T,size_t N>ostream &operator<<(ostream &os,const array<T,N> &p){os<<\"<\";for(auto&it:p)os<<it<<\" \";return os<<\">\";}\ntemplate<class S,class T>ostream &operator<<(ostream &os,const pair<S,T> &p){return os<<\"(\"<<p.f<<\",\"<<p.s<<\")\";}\ntemplate<class S,class T>istream &operator>>(istream &is,pair<S,T> &p){return is>>p.f>>p.s;}\ntemplate<class T>ostream &operator<<(ostream &os,const vector<T> &p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T,typename Cmp>ostream &operator<<(ostream &os,const set<T,Cmp>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>ostream &operator<<(ostream &os,const multiset<T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class S,class T,typename Cmp>ostream &operator<<(ostream &os,const map<S,T,Cmp>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class S,class T>istream &operator>>(istream &is,const pair<S,T> &p){return is>>p.f>>p.s;}\ntemplate<class T> istream &operator>>(istream &is, vector<T> &p){for(auto&itr:p)is>>itr;return is;}\ntemplate<class T>void dbs(string str,T t){cerr<<str<<\":\"<<t<<\"\\n\";}\ntemplate<class T,class...S>void dbs(string str,T t,S... s){ll idx=str.find(',');cerr<<str.substr(0,idx)<<\":\"<<t<<\",\";dbs(str.substr(idx+1),s...);}\n#ifdef DB\n#define debarr(a,n)cerr<<#a<<\":\";for(ll i=0;i<n;i++)cerr<<a[i]<<\" \";cerr<<endl;\n#define debmat(mat,row,col)cerr<<#mat<<\":\\n\";for(ll i=0;i<row;i++){for(ll j=0;j<col;j++)cerr<<mat[i][j]<<\" \";cerr<<endl;}\n#define pr(...)dbs(#__VA_ARGS__,__VA_ARGS__)\n#else\n#define pr(...){}\n#define debarr(a,n){}\n#define debmat(mat,row,col){}\n#endif\ntemplate<class T>\nvoid print(T t)  {\n    cout<<t<<\"\\n\";    \n}\ntemplate<class T,class...S>\nvoid print(T t,S... ss)  {\n    cout<<t<<\" \";\n    print(ss...);\n}\ndouble  nCr(ll n,ll r){\n    if(n<r) return 0;\n    if(r<0) return 0;\n    if(r>(n/2)) r = n-r;\n    double ans = 1;\n    while(r>0){\n        ans*=n;\n        ans/=r;\n        n--;r--;\n    } \n    return ans;\n}\nvoid solve()\n{\n    //Write code here\n    ll n,m,k;\n    cin>>n>>m>>k;\n    cout<<setprecision(8)<<fixed;\n    double ans = 1;\n    n+=(k+1);\n    for(int i=0;i<(k+1);i++){\n        ans*=((double)m/n);\n        m--;n--;\n    }\n    ans = 1-ans;\n    cout<<ans<<\"\\n\";\n}\n\nint main()\n{\n    freopen(\"err.txt\",\"w\",stderr);\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#ifdef file_ipop\n    freopen(\"filename.in\",\"r\",stdin);\n    freopen(\"filename.out\",\"w\",stdout);\n#endif\n   // ll t;cin>>t;while(t--)\n    solve();\n    return 0;\n}"
}