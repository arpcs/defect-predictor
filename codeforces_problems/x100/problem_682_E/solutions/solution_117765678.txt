{
    "id": 117765678,
    "contestId": 682,
    "creationTimeSeconds": 1622287923,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 682,
        "index": "E",
        "name": "Alyona and Triangles",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2600,
        "tags": [
            "geometry",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 682,
        "members": [
            {
                "handle": "the0dd1out"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1466181300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 66,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 204800,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst double pi = 4 * atan(1);\r\nconst double eps = 1e-9;\r\n\r\ninline int dcmp (double x) { if (fabs(x) < eps) return 0; else return x < 0 ? -1 : 1; }\r\ndouble fix_acute(double th) {return th<-pi ? (th+2*pi): th>pi ? (th-2*pi) : th;}\r\n\r\ninline double getDistance (double x, double y) { return sqrt(x * x + y * y); }\r\ninline double torad(double deg) { return deg / 180 * pi; }\r\n\r\nstruct Point {\r\n    double x, y;\r\n    Point (double x = 0, double y = 0): x(x), y(y) {}\r\n    void read () { scanf(\"%lf%lf\", &x, &y); }\r\n    void write () { printf(\"%lf %lf\", x, y); }\r\n\r\n    bool operator == (const Point& u) const { return dcmp(x - u.x) == 0 && dcmp(y - u.y) == 0; }\r\n    bool operator != (const Point& u) const { return !(*this == u); }\r\n    bool operator < (const Point& u) const { return dcmp(x - u.x) < 0 || (dcmp(x-u.x)==0 && dcmp(y-u.y) < 0); }\r\n    bool operator > (const Point& u) const { return u < *this; }\r\n    bool operator <= (const Point& u) const { return *this < u || *this == u; }\r\n    bool operator >= (const Point& u) const { return *this > u || *this == u; }\r\n    Point operator + (const Point& u) { return Point(x + u.x, y + u.y); }\r\n    Point operator - (const Point& u) { return Point(x - u.x, y - u.y); }\r\n    Point operator * (const double u) { return Point(x * u, y * u); }\r\n    Point operator / (const double u) { return Point(x / u, y / u); }\r\n    double operator * (const Point& u) { return x*u.y - y*u.x; }\r\n};\r\ntypedef Point Vector;\r\ntypedef vector<Point> Polygon;\r\n\r\nstruct Line {\r\n    double a, b, c;\r\n    Line (double a = 0, double b = 0, double c = 0): a(a), b(b), c(c) {}\r\n};\r\n\r\nstruct Segment{\r\n    Point a;\r\n    Point b;\r\n    Segment(){}\r\n    Segment(Point aa,Point bb) {a=aa,b=bb;}\r\n};\r\n\r\nstruct DirLine {\r\n    Point p;\r\n    Vector v;\r\n    double ang;\r\n    DirLine () {}\r\n    DirLine (Point p, Vector v): p(p), v(v) { ang = atan2(v.y, v.x); }\r\n    bool operator < (const DirLine& u) const { return ang < u.ang; }\r\n};\r\n\r\nnamespace Punctual {\r\n    double getDistance (Point a, Point b) { double x=a.x-b.x, y=a.y-b.y; return sqrt(x*x + y*y); }\r\n};\r\n\r\nnamespace Vectorial {\r\n    double getDot (Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\r\n    double getCross (Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\r\n    double getLength (Vector a) { return sqrt(getDot(a, a)); }\r\n    double getPLength (Vector a) { return getDot(a, a); }\r\n    double getAngle (Vector u) { return atan2(u.y, u.x); }\r\n    double getSignedAngle (Vector a, Vector b) {return getAngle(b)-getAngle(a);}\r\n    Vector rotate (Vector a, double rad) { return Vector(a.x*cos(rad)-a.y*sin(rad), a.x*sin(rad)+a.y*cos(rad)); }\r\n    Vector ccw(Vector a, double co, double si) {return Vector(a.x*co-a.y*si, a.y*co+a.x*si);}\r\n    Vector cw (Vector a, double co, double si) {return Vector(a.x*co+a.y*si, a.y*co-a.x*si);}\r\n    Vector scale(Vector a, double s = 1.0) {return a / getLength(a) * s;}\r\n    Vector getNormal (Vector a) { double l = getLength(a); return Vector(-a.y/l, a.x/l); }\r\n};\r\n\r\nnamespace ComplexVector {\r\n    typedef complex<double> Point;\r\n    typedef Point Vector;\r\n\r\n    double getDot(Vector a, Vector b) { return real(conj(a)*b); }\r\n    double getCross(Vector a, Vector b) { return imag(conj(a)*b); }\r\n    Vector rotate(Vector a, double rad) { return a*exp(Point(0, rad)); }\r\n};\r\n\r\nnamespace Linear {\r\n    using namespace Vectorial;\r\n\r\n    Line getLine (double x1, double y1, double x2, double y2) { return Line(y2-y1, x1-x2, y1*x2-x1*y2); }\r\n    Line getLine (double a, double b, Point u) { return Line(a, -b, u.y * b - u.x * a); }\r\n\r\n    bool getIntersection (Line p, Line q, Point& o) {\r\n        if (fabs(p.a * q.b - q.a * p.b) < eps)\r\n            return false;\r\n        o.x = (q.c * p.b - p.c * q.b) / (p.a * q.b - q.a * p.b);\r\n        o.y = (q.c * p.a - p.c * q.a) / (p.b * q.a - q.b * p.a);\r\n        return true;\r\n    }\r\n\r\n    bool getIntersection (Point p, Vector v, Point q, Vector w, Point& o) {\r\n        if (dcmp(getCross(v, w)) == 0) return false;\r\n        Vector u = p - q;\r\n        double k = getCross(w, u) / getCross(v, w);\r\n        o = p + v * k;\r\n        return true;\r\n    }\r\n\r\n    double getDistanceToLine (Point p, Point a, Point b) { return fabs(getCross(b-a, p-a) / getLength(b-a)); }\r\n    double getDistanceToSegment (Point p, Point a, Point b) {\r\n        if (a == b) return getLength(p-a);\r\n        Vector v1 = b - a, v2 = p - a, v3 = p - b;\r\n        if (dcmp(getDot(v1, v2)) < 0) return getLength(v2);\r\n        else if (dcmp(getDot(v1, v3)) > 0) return getLength(v3);\r\n        else return fabs(getCross(v1, v2) / getLength(v1));\r\n    }\r\n\r\n    double getDistanceSegToSeg (Point a,Point b,Point c,Point d){\r\n        double Ans=INT_MAX;\r\n        Ans=min(Ans,getDistanceToSegment(a,c,d));\r\n        Ans=min(Ans,getDistanceToSegment(b,c,d));\r\n        Ans=min(Ans,getDistanceToSegment(c,a,b));\r\n        Ans=min(Ans,getDistanceToSegment(d,a,b));\r\n        return Ans;\r\n    }\r\n\r\n    Point getPointToLine (Point p, Point a, Point b) { Vector v = b-a; return a+v*(getDot(v, p-a) / getDot(v,v)); }\r\n    bool onSegment (Point p, Point a, Point b) { return dcmp(getCross(a-p, b-p)) == 0 && dcmp(getDot(a-p, b-p)) <= 0; }\r\n\r\n    bool haveIntersection (Point a1, Point a2, Point b1, Point b2) {\r\n        if(onSegment(a1,b1,b2)) return true;\r\n        if(onSegment(a2,b1,b2)) return true;\r\n        if(onSegment(b1,a1,a2)) return true;\r\n        if(onSegment(b2,a1,a2)) return true;  //Case of touch\r\n\r\n        double c1=getCross(a2-a1, b1-a1), c2=getCross(a2-a1, b2-a1), c3=getCross(b2-b1, a1-b1), c4=getCross(b2-b1,a2-b1);\r\n        return dcmp(c1)*dcmp(c2) < 0 && dcmp(c3)*dcmp(c4) < 0;\r\n    }\r\n    bool onLeft(DirLine l, Point p) { return dcmp(l.v * (p-l.p)) >= 0; }\r\n}\r\n\r\nnamespace Triangular {\r\n    using namespace Vectorial;\r\n\r\n    double getAngle (double a, double b, double c) { return acos((a*a+b*b-c*c) / (2*a*b)); }\r\n    double getArea (double a, double b, double c) { double s =(a+b+c)/2; return sqrt(s*(s-a)*(s-b)*(s-c)); }\r\n    double getArea (double a, double h) { return a * h / 2; }\r\n    double getArea (Point a, Point b, Point c) { return fabs(getCross(b - a, c - a)) / 2; }\r\n    double getDirArea (Point a, Point b, Point c) { return getCross(b - a, c - a) / 2;}\r\n\r\n    //ma/mb/mc = length of median from side a/b/c\r\n    double getArea_(double ma,double mb,double mc) {double s=(ma+mb+mc)/2; return 4/3.0 * sqrt(s*(s-ma)*(s-mb)*(s-mc));}\r\n\r\n    //ha/hb/hc = length of perpendicular from side a/b/c\r\n    double get_Area(double ha,double hb,double hc){\r\n        double H=(1/ha+1/hb+1/hc)/2; double _A_ = 4 * sqrt(H * (H-1/ha)*(H-1/hb)*(H-1/hc)); return 1.0/_A_;\r\n    }\r\n\r\n    bool pointInTriangle(Point a, Point b, Point c, Point p){\r\n        double s1 = getArea(a,b,c);\r\n        double s2 = getArea(p,b,c) + getArea(p,a,b) + getArea(p,c,a);\r\n        return dcmp(s1 - s2) == 0;\r\n    }\r\n};\r\n\r\nnamespace Polygonal {\r\n    using namespace Vectorial;\r\n    using namespace Linear;\r\n    using namespace Triangular;\r\n\r\n    double getSignedArea (Point* p, int n) {\r\n        double ret = 0;\r\n        for (int i = 0; i < n-1; i++)\r\n            ret += (p[i]-p[0]) * (p[i+1]-p[0]);\r\n        return ret/2.0;\r\n    }\r\n\r\n    long long pointsOnPolygon(Point* p, int n)\r\n    {\r\n        long long ret= 0;\r\n        for(int i=0; i<n; i++)\r\n        {\r\n            Point a= p[(i+1)%n]-p[i];\r\n            long long g= abs(__gcd((long long)a.x, (long long)a.y));\r\n            ret+= g;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    int getConvexHull (Point* p, int n, Point* ch) {\r\n        sort(p, p + n);\r\n\r\n        /// preparing lower hull\r\n        int m = 0;\r\n        for (int i = 0; i < n; i++){\r\n            while (m > 1 && dcmp(getCross(ch[m-1]-ch[m-2], p[i]-ch[m-1])) <= 0) m--;\r\n            ch[m++] = p[i];\r\n        }\r\n\r\n        /// preparing upper hull\r\n        int k = m;\r\n        for (int i = n-2; i >= 0; i--){\r\n            while (m > k && dcmp(getCross(ch[m-1]-ch[m-2], p[i]-ch[m-2])) <= 0) m--;\r\n            ch[m++] = p[i];\r\n        }\r\n        if (n > 1) m--;\r\n        return m;\r\n    }\r\n\r\n    int isPointInPolygon(Point o, Point* p, int n) {\r\n        int wn = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            int j = (i + 1) % n;\r\n            if (onSegment(o, p[i], p[j]) || o == p[i]) return 0;\r\n            int k = dcmp(getCross(p[j] - p[i], o-p[i]));\r\n            int d1 = dcmp(p[i].y - o.y);\r\n            int d2 = dcmp(p[j].y - o.y);\r\n            if (k > 0 && d1 <= 0 && d2 > 0) wn++;\r\n            if (k < 0 && d2 <= 0 && d1 > 0) wn--;\r\n        }\r\n        return wn ? -1 : 1;\r\n    }\r\n\r\n    Polygon biggestTriangle(Point* p, int n)/// p is a array containing Points of convexHull\r\n    {\r\n        Polygon ret;\r\n        if(n<3)return ret;\r\n\r\n        double res= 0.0;\r\n        for(int i=0, j=1, k=2; i<n; i++)\r\n        {\r\n            if(i==j)j= (j+1)%n;\r\n            if(j==k)k= (k+1)%n;\r\n            double area= getArea(p[i], p[j], p[k]);\r\n\r\n            while(true)\r\n            {\r\n                while(true)\r\n                {\r\n                    int nk= (k+1)%n;\r\n                    double narea= getArea(p[i], p[j], p[nk]);\r\n\r\n                    if(dcmp(narea-area)>=0)area= narea, k= nk;\r\n                    else break;\r\n                }\r\n\r\n                int nj= (j+1)%n;\r\n                double narea= getArea(p[i], p[nj], p[k]);\r\n\r\n                if(dcmp(narea-area)>=0)area= narea, j= nj;\r\n                else break;\r\n            }\r\n\r\n            if(dcmp(area-res)>0)res= area, ret.clear(),\r\n            ret.push_back(p[i]), ret.push_back(p[j]), ret.push_back(p[k]);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    void rotatingCalipers(Point *p, int n, vector<Segment>& sol) {\r\n        sol.clear();\r\n        int j = 1; p[n] = p[0];\r\n        for (int i = 0; i < n; i++) {\r\n            while (getCross(p[j+1]-p[i+1], p[i]-p[i+1]) > getCross(p[j]-p[i+1], p[i]-p[i+1]))\r\n                j = (j+1) % n;\r\n            sol.push_back(Segment(p[i],p[j]));\r\n            sol.push_back(Segment(p[i + 1],p[j + 1]));\r\n        }\r\n    }\r\n\r\n    void rotatingCalipersGetRectangle (Point *p, int n, double& area, double& perimeter) {\r\n        p[n] = p[0];\r\n        int l = 1, r = 1, j = 1;\r\n        area = perimeter = 1e20;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            Vector v = (p[i+1]-p[i]) / getLength(p[i+1]-p[i]);\r\n            while (dcmp(getDot(v, p[r%n]-p[i]) - getDot(v, p[(r+1)%n]-p[i])) < 0) r++;\r\n            while (j < r || dcmp(getCross(v, p[j%n]-p[i]) - getCross(v,p[(j+1)%n]-p[i])) < 0) j++;\r\n            while (l < j || dcmp(getDot(v, p[l%n]-p[i]) - getDot(v, p[(l+1)%n]-p[i])) > 0) l++;\r\n            double w = getDot(v, p[r%n]-p[i])-getDot(v, p[l%n]-p[i]);\r\n            double h = getDistanceToLine (p[j%n], p[i], p[i+1]);\r\n            area = min(area, w * h);\r\n            perimeter = min(perimeter, 2 * w + 2 * h);\r\n        }\r\n    }\r\n\r\n    Polygon cutPolygon (Polygon u, Point a, Point b) {\r\n        Polygon ret;\r\n        int n = u.size();\r\n        for (int i = 0; i < n; i++) {\r\n            Point c = u[i], d = u[(i+1)%n];\r\n            if (dcmp((b-a)*(c-a)) >= 0) ret.push_back(c);\r\n            if (dcmp((b-a)*(d-c)) != 0) {\r\n                Point t;\r\n                getIntersection(a, b-a, c, d-c, t);\r\n                if (onSegment(t, c, d))\r\n                    ret.push_back(t);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    int halfPlaneIntersection(DirLine* li, int n, Point* poly) {\r\n        sort(li, li + n);\r\n\r\n        int first, last;\r\n        Point* p = new Point[n];\r\n        DirLine* q = new DirLine[n];\r\n        q[first=last=0] = li[0];\r\n\r\n        for (int i = 1; i < n; i++) {\r\n            while (first < last && !onLeft(li[i], p[last-1])) last--;\r\n            while (first < last && !onLeft(li[i], p[first])) first++;\r\n            q[++last] = li[i];\r\n\r\n            if (dcmp(q[last].v * q[last-1].v) == 0) {\r\n                last--;\r\n                if (onLeft(q[last], li[i].p)) q[last] = li[i];\r\n            }\r\n\r\n            if (first < last)\r\n                getIntersection(q[last-1].p, q[last-1].v, q[last].p, q[last].v, p[last-1]);\r\n        }\r\n\r\n        while (first < last && !onLeft(q[first], p[last-1])) last--;\r\n        if (last - first <= 1) { delete [] p; delete [] q; return 0; }\r\n        getIntersection(q[last].p, q[last].v, q[first].p, q[first].v, p[last]);\r\n\r\n        int m = 0;\r\n        for (int i = first; i <= last; i++) poly[m++] = p[i];\r\n        delete [] p; delete [] q;\r\n        return m;\r\n    }\r\n\r\n    Polygon simplify (const Polygon& poly) {\r\n        Polygon ret;\r\n        int n = poly.size();\r\n        for (int i = 0; i < n; i++) {\r\n            Point a = poly[i];\r\n            Point b = poly[(i+1)%n];\r\n            Point c = poly[(i+2)%n];\r\n            if (dcmp((b-a)*(c-b)) != 0 && (ret.size() == 0 || b != ret[ret.size()-1]))\r\n                ret.push_back(b);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    Point ComputeCentroid( Point* p,int n){\r\n        Point c(0,0);\r\n        double scale = 6.0 * getSignedArea(p,n);\r\n        for (int i = 0; i < n; i++){\r\n            int j = (i+1) % n;\r\n            c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);\r\n        }\r\n        return c / scale;\r\n    }\r\n\r\n    /// Tested : https://www.spoj.com/problems/INOROUT\r\n    /// pt must be in ccw order with no three collinear points\r\n    /// returns inside = 1, on = 0, outside = -1\r\n    int pointInConvexPolygon(Point* pt, int n, Point p){\r\n        assert(n >= 3);\r\n        int lo = 1 , hi = n - 1 ;\r\n        while(hi - lo > 1){\r\n            int mid = (lo + hi) / 2;\r\n            if(getCross(pt[mid] - pt[0], p - pt[0]) > 0) lo = mid;\r\n            else hi = mid;\r\n        }\r\n\r\n        bool in = pointInTriangle(pt[0], pt[lo], pt[hi], p);\r\n        if(!in) return -1;\r\n\r\n\r\n        if(getCross(pt[lo] - pt[lo-1], p - pt[lo-1]) == 0) return 0;\r\n        if(getCross(pt[hi] - pt[lo], p - pt[lo]) == 0) return 0;\r\n        if(getCross(pt[hi] - pt[(hi+1)%n], p - pt[(hi+1)%n]) == 0) return 0;\r\n\r\n\r\n        return 1;\r\n    }\r\n\r\n    // Tested : https://toph.co/p/cover-the-points\r\n    // Calculate [ACW, CW] tangent pair from an external point\r\n    #define CW \t\t-1\r\n    #define ACW\t \t 1\r\n    int direction(Point st, Point ed, Point q)       {return dcmp(getCross(ed - st, q - ed));}\r\n    bool isGood(Point u, Point v, Point Q, int dir)  {return direction(Q, u, v) != -dir;}\r\n    Point better(Point u, Point v, Point Q, int dir) {return direction(Q, u, v) == dir ? u : v;}\r\n\r\n    Point tangents(Point* pt, Point Q, int dir, int lo, int hi){\r\n        while(hi - lo > 1){\r\n            int mid = (lo + hi)/2;\r\n            bool pvs = isGood(pt[mid], pt[mid - 1], Q, dir);\r\n            bool nxt = isGood(pt[mid], pt[mid + 1], Q, dir);\r\n\r\n            if(pvs && nxt) return pt[mid];\r\n            if(!(pvs || nxt)){\r\n                Point p1 = tangents(pt, Q, dir, mid+1, hi);\r\n                Point p2 = tangents(pt, Q, dir, lo, mid - 1);\r\n                return better(p1, p2, Q, dir);\r\n            }\r\n\r\n            if(!pvs){\r\n                if(direction(Q, pt[mid], pt[lo]) == dir)  hi = mid - 1;\r\n                else if(better(pt[lo], pt[hi], Q, dir) == pt[lo]) hi = mid - 1;\r\n                else lo = mid + 1;\r\n            }\r\n            if(!nxt){\r\n                if(direction(Q, pt[mid], pt[lo]) == dir)  lo = mid + 1;\r\n                else if(better(pt[lo], pt[hi], Q, dir) == pt[lo]) hi = mid - 1;\r\n                else lo = mid + 1;\r\n            }\r\n        }\r\n\r\n        Point ret = pt[lo];\r\n        for(int i = lo + 1; i <= hi; i++) ret = better(ret, pt[i], Q, dir);\r\n        return ret;\r\n    }\r\n\r\n    // [ACW, CW] Tangent\r\n    pair<Point, Point> get_tangents(Point* pt, int n, Point Q){\r\n        Point acw_tan = tangents(pt, Q, ACW, 0, n - 1);\r\n        Point cw_tan = tangents(pt, Q, CW, 0, n - 1);\r\n        return make_pair(acw_tan, cw_tan);\r\n    }\r\n};\r\n\r\nstruct Circle {\r\n    Point o;\r\n    double r;\r\n    Circle () {}\r\n    Circle (Point o, double r = 0): o(o), r(r) {}\r\n    void read () { o.read(), scanf(\"%lf\", &r); }\r\n    Point point(double rad) { return Point(o.x + cos(rad)*r, o.y + sin(rad)*r); }\r\n    double getArea (double rad) { return rad * r * r / 2; }\r\n    //area of the circular sector cut by a chord with central angle alpha\r\n    double sector(double alpha) {return r * r * 0.5 * (alpha - sin(alpha));}\r\n};\r\n\r\nnamespace Circular {\r\n    using namespace Linear;\r\n    using namespace Vectorial;\r\n    using namespace Triangular;\r\n\r\n    int getLineCircleIntersection(Point p, Point q, Circle O, double& t1, double& t2, vector<Point>& sol) {\r\n        Vector v = q-p;\r\n        //sol.clear();\r\n        double a = v.x, b = p.x - O.o.x, c = v.y, d = p.y - O.o.y;\r\n        double e = a*a+c*c, f = 2*(a*b+c*d), g = b*b+d*d-O.r*O.r;\r\n        double delta = f*f - 4*e*g;\r\n        if (dcmp(delta) < 0) return 0;\r\n        if (dcmp(delta) == 0) {\r\n            t1 = t2 = -f / (2 * e);\r\n            sol.push_back(p + v * t1);\r\n            return 1;\r\n        }\r\n\r\n        t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(p + v * t1);\r\n        t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(p + v * t2);\r\n        return 2;\r\n    }\r\n\r\n    /// signed area of intersection of circle(c.o, c.r) and\r\n    /// triangle(c.o, s.a, s.b) [cross(a-o, b-o)/2]\r\n    double areaCircleTriIntersection(Circle c, Segment s){\r\n        using namespace Linear;\r\n        double OA = getLength(c.o - s.a);\r\n        double OB = getLength(c.o - s.b);\r\n\r\n        // sector\r\n        if (dcmp(getDistanceToSegment(c.o, s.a, s.b) - c.r) >= 0)\r\n            return fix_acute(getSignedAngle(s.a - c.o, s.b - c.o)) * (c.r*c.r) / 2.0;\r\n\r\n        // triangle\r\n        if (dcmp(OA - c.r) <= 0 && dcmp(OB - c.r) <= 0)\r\n            return getCross(c.o-s.b,s.a-s.b) / 2.0;\r\n\r\n        // three part: (A, a) (a, b) (b, B)\r\n        vector<Point>Sect; double t1,t2;\r\n        getLineCircleIntersection(s.a, s.b, c, t1, t2, Sect);\r\n        return areaCircleTriIntersection(c, Segment(s.a, Sect[0]))\r\n            + areaCircleTriIntersection(c, Segment(Sect[0], Sect[1]))\r\n            + areaCircleTriIntersection(c, Segment(Sect[1], s.b));\r\n    }\r\n\r\n    // area of intersection of circle(c.o, c.r) and simple polygon(p[])\r\n    // Tested : ZOJ 2675 - Little Mammoth\r\n    double areaCirclePolygon(Circle c, Polygon p){\r\n        double res = 0.0;\r\n        int n = p.size();\r\n        for(int i=0; i<n; ++i)\r\n        res += areaCircleTriIntersection(c, Segment(p[i], p[(i+1)%n]));\r\n        return fabs(res);\r\n    }\r\n\r\n    // interior          (d < R - r)         ----> -2\r\n    // interior tangents (d = R - r)         ----> -1\r\n    // concentric        (d = 0)\r\n    // secants           (R - r < d < R + r) ---->  0\r\n    // exterior tangents (d = R + r)         ---->  1\r\n    // exterior          (d > R + r)         ---->  2\r\n    int getPos(Circle o1, Circle o2) {\r\n        using namespace Vectorial;\r\n        double d = getLength(o1.o - o2.o);\r\n        int in = dcmp(d - fabs(o1.r - o2.r)), ex = dcmp(d - (o1.r + o2.r));\r\n        return in<0 ? -2 : in==0? -1 : ex==0 ? 1 : ex>0? 2 : 0;\r\n    }\r\n\r\n    int getCircleCircleIntersection (Circle o1, Circle o2, vector<Point>& sol) {\r\n        double d = getLength(o1.o - o2.o);\r\n        if (dcmp(d) == 0) {\r\n            if (dcmp(o1.r - o2.r) == 0) return -1;\r\n            return 0;\r\n        }\r\n        if (dcmp(o1.r + o2.r - d) < 0) return 0;\r\n        if (dcmp(fabs(o1.r-o2.r) - d) > 0) return 0;\r\n\r\n        Vector v = o2.o - o1.o;\r\n        double co = (o1.r*o1.r + getPLength(v) - o2.r*o2.r) / (2 * o1.r * getLength(v));\r\n        double si = sqrt(fabs(1.0 - co*co));\r\n        Point p1 = scale(cw(v,co, si), o1.r) + o1.o;\r\n        Point p2 = scale(ccw(v,co, si), o1.r) + o1.o;\r\n\r\n        sol.push_back(p1);\r\n        if (p1 == p2) return 1;\r\n        sol.push_back(p2);\r\n        return 2;\r\n    }\r\n\r\n    double areaCircleCircle(Circle o1, Circle o2){\r\n        Vector AB = o2.o - o1.o;\r\n        double d = getLength(AB);\r\n        if(d >= o1.r + o2.r) return 0;\r\n        if(d + o1.r <= o2.r) return pi * o1.r * o1.r;\r\n        if(d + o2.r <= o1.r) return pi * o2.r * o2.r;\r\n\r\n        double alpha1 = acos((o1.r * o1.r + d * d - o2.r * o2.r) / (2.0 * o1.r * d));\r\n        double alpha2 = acos((o2.r * o2.r + d * d - o1.r * o1.r) / (2.0 * o2.r * d));\r\n        return o1.sector(2*alpha1) + o2.sector(2*alpha2);\r\n    }\r\n\r\n    int getTangents (Point p, Circle o, Vector* v) {\r\n        Vector u = o.o - p;\r\n        double d = getLength(u);\r\n        if (d < o.r) return 0;\r\n        else if (dcmp(d - o.r) == 0) {\r\n            v[0] = rotate(u, pi / 2);\r\n            return 1;\r\n        } else {\r\n            double ang = asin(o.r / d);\r\n            v[0] = rotate(u, -ang);\r\n            v[1] = rotate(u, ang);\r\n            return 2;\r\n        }\r\n    }\r\n    int getTangentPoints (Point p, Circle o, vector<Point>& v) {\r\n        Vector u = p - o.o ;\r\n        double d = getLength(u);\r\n        if (d < o.r) return 0;\r\n        else if (dcmp(d - o.r) == 0) {\r\n            v.push_back(o.o+u);\r\n            return 1;\r\n        } else {\r\n            double ang = acos(o.r / d);\r\n            u = u / getLength(u) * o.r;\r\n            v.push_back(o.o+rotate(u, -ang));\r\n            v.push_back(o.o+rotate(u, ang));\r\n            return 2;\r\n        }\r\n    }\r\n\r\n    int getTangents (Circle o1, Circle o2, Point* a, Point* b) {\r\n        int cnt = 0;\r\n        if (dcmp(o1.r-o2.r) < 0) { swap(o1, o2); swap(a, b); }\r\n        double d2 = getPLength(o1.o - o2.o);\r\n        double rdif = o1.r - o2.r, rsum = o1.r + o2.r;\r\n        if (dcmp(d2 - rdif * rdif) < 0) return 0;\r\n        if (dcmp(d2) == 0 && dcmp(o1.r - o2.r) == 0) return -1;\r\n\r\n        double base = getAngle(o2.o - o1.o);\r\n        if (dcmp(d2 - rdif * rdif) == 0) {\r\n            a[cnt] = o1.point(base); b[cnt] = o2.point(base); cnt++;\r\n            return cnt;\r\n        }\r\n\r\n        double ang = acos( (o1.r - o2.r) / sqrt(d2) );\r\n        a[cnt] = o1.point(base+ang); b[cnt] = o2.point(base+ang); cnt++;\r\n        a[cnt] = o1.point(base-ang); b[cnt] = o2.point(base-ang); cnt++;\r\n\r\n        if (dcmp(d2 - rsum * rsum) == 0) {\r\n            a[cnt] = o1.point(base); b[cnt] = o2.point(pi+base); cnt++;\r\n        }\r\n        else if (dcmp(d2 - rsum * rsum) > 0) {\r\n            double ang = acos( (o1.r + o2.r) / sqrt(d2) );\r\n            a[cnt] = o1.point(base+ang); b[cnt] = o2.point(pi+base+ang); cnt++;\r\n            a[cnt] = o1.point(base-ang); b[cnt] = o2.point(pi+base-ang); cnt++;\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    Circle CircumscribedCircle(Point p1, Point p2, Point p3) {\r\n        double Bx = p2.x - p1.x, By = p2.y - p1.y;\r\n        double Cx = p3.x - p1.x, Cy = p3.y - p1.y;\r\n        double D = 2 * (Bx * Cy - By * Cx);\r\n        double cx = (Cy * (Bx * Bx + By * By) - By * (Cx * Cx + Cy * Cy)) / D + p1.x;\r\n        double cy = (Bx * (Cx * Cx + Cy * Cy) - Cx * (Bx * Bx + By * By)) / D + p1.y;\r\n        Point p = Point(cx, cy);\r\n        return Circle(p, getLength(p1 - p));\r\n    }\r\n\r\n    Circle InscribedCircle(Point p1, Point p2, Point p3) {\r\n        double a = getLength(p2 - p3);\r\n        double b = getLength(p3 - p1);\r\n        double c = getLength(p1 - p2);\r\n        Point p = (p1 * a + p2 * b + p3 * c) / (a + b + c);\r\n        return Circle(p, getDistanceToLine(p, p1, p2));\r\n    }\r\n\r\n    /// distance From P : distance from Q =  rp : rq\r\n    Circle getApolloniusCircle(const Point& P,const Point& Q, double rp, double rq ){\r\n        rq *= rq ;\r\n        rp *= rp ;\r\n        double a = rq - rp ;\r\n        assert(dcmp(a));\r\n        double g = rq * P.x - rp * Q.x ; g /= a ;\r\n        double h = rq * P.y - rp * Q.y ; h /= a ;\r\n        double c = rq*P.x*P.x-rp*Q.x*Q.x+rq*P.y*P.y-rp*Q.y*Q.y ;\r\n        c /= a ;\r\n        Point o(g,h);\r\n        double R = g*g +h*h - c ;\r\n        R = sqrt(R);\r\n        return Circle(o,R);\r\n    }\r\n};\r\n\r\nstruct Star{\r\n    int n;    /// number of side of the star\r\n    double r; /// radius of the circum-circle\r\n    Star(int n,double r) {this->n=n; this->r=r;}\r\n\r\n    double getArea(){\r\n        double theta=pi/n;\r\n        double s=2*r*sin(theta);\r\n        double R=0.5*s/tan(theta);\r\n        double a=0.5*n*s*R;\r\n        double a2=0.25*s*s/tan(1.5*theta);\r\n        return a-n*a2;\r\n    }\r\n};\r\nPoint p[5003], ch[5003];\r\nint main()\r\n{\r\n    using namespace Polygonal;\r\n\r\n    int n;\r\n    long long s;\r\n    scanf(\"%d %lld\", &n, &s);\r\n    for(int i=0; i<n; i++)p[i].read();\r\n    n= getConvexHull(p, n, ch);\r\n\r\n    Polygon temp= biggestTriangle(ch, n);\r\n\r\n    Point A, B, C, a= temp[0], b= temp[1], c= temp[2];\r\n    A= (a+b-c);\r\n    B= (a+c-b);\r\n    C= (b+c-a);\r\n    printf(\"%.0f %.0f\\n\", A.x, A.y);\r\n    printf(\"%.0f %.0f\\n\", B.x, B.y);\r\n    printf(\"%.0f %.0f\\n\", C.x, C.y);\r\n\r\n    return 0;\r\n}"
}