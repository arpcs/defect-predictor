{
    "id": 57767873,
    "contestId": 1192,
    "creationTimeSeconds": 1564091741,
    "relativeTimeSeconds": 41,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Xellos"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 1294,
    "memoryConsumedBytes": 224051200,
    "points": 100.0,
    "source": "/* Constructs the minimum required grid graph.\r\n   Tracks connected components using union-find.\r\n   Decides which cells may be deleted based on neighbourhoods,\r\n   updates that information when necessary and keeps these cells\r\n   in a set<>.\r\n   O(N log N)\r\n*/\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nclass HashPair {\r\n    static inline size_t hash_combine(size_t h_first, size_t h_second) {\r\n        return h_first ^ (h_second + 0x9e3779b9 + (h_first << 6) + (h_second >> 2));\r\n    }\r\n \r\n    static inline size_t hash_int(unsigned int x) {\r\n        x = ((x >> 16) ^ x) * 0x45d9f3b;\r\n        x = ((x >> 16) ^ x) * 0x45d9f3b;\r\n        x = (x >> 16) ^ x;\r\n        return x;\r\n    }\r\n \r\npublic:\r\n    size_t operator() (const pair<int, int> & p) const {\r\n        size_t h_first  = hash_int(p.first);\r\n        size_t h_second = hash_int(p.second);\r\n \r\n        return hash_combine(h_first, h_second);\r\n    }\r\n};\r\n \r\nclass lego {\r\n    int N, V;\r\n    vector< pair<int, int> > cells, empty_cells;\r\n    unordered_map< pair<int, int>, int, HashPair> cell_indices, empty_cell_indices;\r\n    vector<char> removed;\r\n \r\n    set<int> removable;\r\n    vector<char> is_removable;\r\n \r\n    vector< vector<int> > G4, G8;\r\n \r\n    void construct_graphs(bool only_solvability = false) {\r\n        constexpr static int dx[8] = {-1, -1, -1,  0,  1, 1, 1, 0};\r\n        constexpr static int dy[8] = { 1,  0, -1, -1, -1, 0, 1, 1};\r\n \r\n        if(!init_solvability_done) {\r\n            for(int i = 0; i < N; i++) for(int j = 0; j < 8; j++) {\r\n                pair<int, int> p = {cells[i].first + dx[j], cells[i].second + dy[j]};\r\n                auto it = cell_indices.find(p);\r\n                int cell_id = (it == end(cell_indices)) ? -1 : it->second;\r\n                if(cell_id == -1) {\r\n                    auto jt = empty_cell_indices.find(p);\r\n                    if(jt == end(empty_cell_indices)) {\r\n                        empty_cell_indices[p] = empty_cells.size();\r\n                        cell_id = N + empty_cells.size();\r\n                        empty_cells.push_back(p);\r\n                        G4.push_back({});\r\n                        G8.push_back(vector<int>(8, cell_id));\r\n                    }\r\n                    else cell_id = N + jt->second;\r\n                    G8[cell_id][4^j] = i;\r\n                    if(j % 2) G4[cell_id].push_back(i);\r\n                }\r\n                G8[i][j] = cell_id;\r\n                if(j % 2) G4[i].push_back(cell_id);\r\n            }\r\n        }\r\n        if(!init_done && !only_solvability) {\r\n            for(int i = 0; i < (int)empty_cells.size(); i++) for(int j = 0; j < 8; j++) {\r\n                if(G8[N+i][j] != N+i) continue;\r\n                pair<int, int> p = {empty_cells[i].first + dx[j], empty_cells[i].second + dy[j]};\r\n                auto it = empty_cell_indices.find(p);\r\n                if(it == end(empty_cell_indices)) continue;\r\n                int cell_id = N + it->second;\r\n                G8[N+i][j] = cell_id;\r\n                if(j % 2) G4[N+i].push_back(cell_id);\r\n            }\r\n        }\r\n    }\r\n \r\n    int outer_component;\r\n    vector< vector<int> > components4, components8;\r\n    vector<int> comp4, comp8;\r\n    vector<int> deg4, deg8; // degree = number of full neighbouring cells\r\n \r\n    void find_components(bool only_solvability = false) {\r\n        queue<int> q;\r\n \r\n        if(!init_solvability_done) {\r\n            components4.clear(); components4.resize(V);\r\n            components8.clear(); components8.resize(V);\r\n            comp4.clear(); comp4.resize(V, -1);\r\n            comp8.clear(); comp8.resize(V, -1);\r\n            deg4.clear(); deg4.resize(V, 0);\r\n            deg8.clear(); deg8.resize(V, 0);\r\n            for(int i = 0; i < V; i++) if(comp8[i] == -1 && !is_empty(i)) {\r\n                comp8[i] = i;\r\n                components8[i] = {i};\r\n                q.push(i);\r\n                while(!q.empty()) {\r\n                    for(auto v : G8[q.front()]) if(comp8[v] == -1 && !is_empty(v)) {\r\n                        comp8[v] = i;\r\n                        components8[i].push_back(v);\r\n                        q.push(v);\r\n                    } \r\n                    q.pop();\r\n                }\r\n            }\r\n        }\r\n        if(!init_done && !only_solvability) {\r\n            for(int i = 0; i < V; i++) if(comp4[i] == -1 && is_empty(i)) {\r\n                comp4[i] = i;\r\n                components4[i] = {i};\r\n                q.push(i);\r\n                while(!q.empty()) {\r\n                    for(auto v : G4[q.front()]) if(comp4[v] == -1 && is_empty(v)) {\r\n                        comp4[v] = i;\r\n                        components4[i].push_back(v);\r\n                        q.push(v);\r\n                    } \r\n                    q.pop();\r\n                }\r\n            }\r\n            for(int i = 0; i < V; i++) {\r\n                for(auto v : G4[i]) if(!is_empty(v)) deg4[i]++;\r\n                for(auto v : G8[i]) if(!is_empty(v)) deg8[i]++;\r\n            }\r\n        }\r\n    }\r\n \r\n    void add_edge(int v1, int v2) {\r\n        int c1 = comp4[v1], c2 = comp4[v2];\r\n        if(c1 == c2) return;\r\n        if(components4[c1].size() < components4[c2].size()) swap(c1, c2);\r\n        for(auto v : components4[c2]) {\r\n            comp4[v] = c1;\r\n            components4[c1].push_back(v);\r\n        }\r\n        if(c2 == outer_component) outer_component = c1;\r\n        for(auto v : components4[c2])\r\n            for(auto f : G8[v]) if(!is_empty(f)) update(f);\r\n    }\r\n \r\n    void update(int v) {\r\n        static vector<char> seen = vector<char>(V, 0);\r\n \r\n        bool reachable = false, articulation = false;\r\n \r\n        for(auto adj : G4[v]) if(is_empty(adj))\r\n            if(comp4[adj] == outer_component) reachable = true;\r\n \r\n        if(deg8[v] <= 1) {\r\n            if(reachable) {\r\n                if(!is_removable[v]) {\r\n                    removable.insert(v);\r\n                    is_removable[v] = 1;\r\n                }\r\n            }\r\n            else if(is_removable[v]) {\r\n                removable.erase(v);\r\n                is_removable[v] = 0;\r\n            }\r\n            return;\r\n        }\r\n \r\n        for(int j = 0; j < 8; j++) if(is_empty(G8[v][j])) {\r\n            if(is_empty(G8[v][(j+1)%8])) continue; // 1 cell per region\r\n            if(j % 2 == 0 && !is_empty(G8[v][(j+7)%8])) continue; // ignore corner gaps\r\n            int c = comp4[G8[v][j]];\r\n            if(seen[c]) {\r\n                articulation = true;\r\n                break;\r\n            }\r\n            seen[c]++;\r\n        }\r\n        for(int j = 0; j < 8; j++) if(is_empty(G8[v][j]))\r\n            seen[comp4[G8[v][j]]] = 0;\r\n \r\n        if(reachable && !articulation) {\r\n            if(!is_removable[v]) {\r\n                removable.insert(v);\r\n                is_removable[v] = 1;\r\n            }\r\n        }\r\n        else if(is_removable[v]) {\r\n            removable.erase(v);\r\n            is_removable[v] = 0;\r\n        }\r\n    }\r\n \r\n    inline bool is_empty(int cell) {\r\n        return (cell >= N || removed[cell]);\r\n    }\r\n \r\n    bool init_done, init_solvability_done;\r\n \r\n    void init_solvability() {\r\n        if(init_solvability_done) return;\r\n        construct_graphs(true);\r\n        V = G4.size();\r\n        removed.resize(V, false);\r\n        find_components(true);\r\n        init_solvability_done = true;\r\n    }\r\n \r\n    void init() {\r\n        if(init_done) return;\r\n \r\n        construct_graphs();\r\n        if(!init_solvability_done) {\r\n            V = G4.size();\r\n            removed.resize(V, false);\r\n        }\r\n \r\n        find_components();\r\n        int min_coord = cells[0].first;\r\n        for(int i = N; i < V; i++) if(min_coord >= empty_cells[i-N].first) {\r\n            min_coord = empty_cells[i-N].first;\r\n            outer_component = comp4[i];\r\n        }\r\n \r\n        is_removable.resize(N, 0);\r\n        for(int i = 0; i < N; i++) update(i);\r\n        \r\n        init_done = init_solvability_done = true;\r\n    }\r\n \r\n  public:\r\n    lego(vector< pair<int, int> > cells_) : N(cells_.size()), cells(cells_) {\r\n        for(int i = 0; i < N; i++) cell_indices[cells[i]] = i;\r\n        G4.resize(N);\r\n        G8.resize(N, vector<int>(8));\r\n        G4.reserve(9*N);\r\n        G8.reserve(9*N);\r\n        cell_indices.reserve(N);\r\n        empty_cell_indices.reserve(8*N);\r\n        \r\n        init_done = init_solvability_done = false;\r\n    }\r\n    \r\n    bool solvable() {\r\n        init_solvability();\r\n        return ((int)components8[comp8[0]].size() == N);\r\n    }\r\n \r\n    int remove() {\r\n        init();\r\n        if(removable.empty()) return -1;\r\n        int rm_id = *rbegin(removable);\r\n \r\n        removable.erase(--end(removable));\r\n        removed[rm_id] = true;\r\n \r\n        components4[rm_id] = {rm_id};\r\n        comp4[rm_id] = rm_id;\r\n        for(auto f : G4[rm_id]) if(!is_empty(f)) update(f);\r\n        for(auto v : G4[rm_id]) {\r\n            if(is_empty(v)) add_edge(rm_id, v);\r\n            else deg4[v]--;\r\n        }\r\n        for(auto v : G8[rm_id]) {\r\n            deg8[v]--;\r\n            if(!is_empty(v)) update(v);\r\n        }\r\n \r\n        return rm_id;\r\n    }\r\n};\r\n \r\nint main() {\r\n    cin.sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int N, t;\r\n    cin >> N >> t;\r\n    vector< pair<int, int> > cells(N);\r\n    for(int i = 0; i < N; i++) cin >> cells[i].first >> cells[i].second;\r\n \r\n    lego solver(cells);\r\n \r\n    if(!solver.solvable()) {\r\n        cout << \"NO\\n\";\r\n        return 0;\r\n    }\r\n \r\n    cout << \"YES\\n\";\r\n    vector<int> build;\r\n    for(int i = 0; i < N; i++) {\r\n        int removed_cell_id = solver.remove();\r\n        assert(removed_cell_id != -1);\r\n        build.push_back(removed_cell_id+1);\r\n    }\r\n    reverse(begin(build), end(build));\r\n    for(int i = 0; i < N; i++) cout << build[i] << \"\\n\";\r\n}"
}