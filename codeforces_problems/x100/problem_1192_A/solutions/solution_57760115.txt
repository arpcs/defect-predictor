{
    "id": 57760115,
    "contestId": 1192,
    "creationTimeSeconds": 1564076449,
    "relativeTimeSeconds": 12949,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "dacin21"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "PARTIAL",
    "testset": "TESTS",
    "passedTestCount": 29,
    "timeConsumedMillis": 3500,
    "memoryConsumedBytes": 748236800,
    "points": 8.0,
    "source": "// is_cut_vertex could be implemented by looking at a 3x3 square\r\n// but why write a simple solution when you can use heavy tools...\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing fl = long double;\r\ntemplate<typename T>\r\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\r\ntemplate<typename S, typename T>\r\nvoid xmin(S&a, T const&b){if(b<a) a=b;}\r\ntemplate<typename S, typename T>\r\nvoid xmax(S&a, T const&b){if(b>a) a=b;}\r\n\r\ntemplate<bool enabled>\r\nstruct Debug{\r\n    template<typename S, typename T = void> struct Tag_Printable : false_type {};\r\n    template<typename S> struct Tag_Printable<S, decltype((void)(cerr << declval<S>()))> : true_type {};\r\n    template<typename S, typename T = void> struct Tag_Iterable: false_type {};\r\n    template<typename S> struct Tag_Iterable<S, decltype((void)(begin(declval<S>()), end(declval<S>())))> : true_type {};\r\n    template<typename T, typename... Args>\r\n    Debug& print(T const&x, true_type, Args...){\r\n        #ifdef LOCAL_RUN\r\n        if(enabled){\r\n            cerr << boolalpha << x;\r\n        }\r\n        #endif // LOCAL_RUN\r\n        return *this;\r\n    }\r\n    template<typename T>\r\n    Debug& print(T const&x, false_type, true_type){\r\n        *this << \"[\";\r\n        bool first = true;\r\n        for(auto &e:x){\r\n            if(!first) *this << \", \";\r\n            *this << e;\r\n            first = false;\r\n        }\r\n        return *this << \"]\";\r\n    }\r\n    template<typename S, typename T>\r\n    Debug& print(pair<S, T> const&x, false_type, false_type){\r\n        return *this << \"(\" << x.first << \", \" << x.second << \")\";\r\n    }\r\n    template<typename T>\r\n    Debug& operator<<(T const&x){\r\n        return print(x, Tag_Printable<T>{}, Tag_Iterable<T>{});\r\n    }\r\n};\r\n Debug<true> debug;\r\n// Debug<false> debug; // disable debug printing\r\n#define named(x) string(#x) << \" : \" <<  x\r\n\r\n\r\n/*\r\n *\tFully dynamic connectiviy\r\n *\tadd or remove edges in O(log n^2)\r\n *\tquery connectivity in O(log n)\r\n *\tcode by dacin21, got cleaned up in september 2017\r\n *\t0.33 seconds for n=m=1e5 on spoj\r\n */\r\n\r\n#ifdef LOCAL_RUN\r\n#define asser(x) do{if(1){assert(x);}}while(0)\r\n#define asser2(x) do{if(1){assert(x);}}while(0)\r\n#else\r\n#define asser(x) do{if(0){assert(x);}}while(0)\r\n#define asser2(x) do{if(0){assert(x);}}while(0)\r\n#endif\r\n\r\nstruct Treap{\r\n    struct Node{\r\n\t\tstatic mt19937 rng;\r\n\t\tstatic bool rng_init;\r\n        Node*l, *r, *p;\r\n        size_t y;\r\n        unsigned int size;\r\n        //int from, to;\r\n        char mark, sub_mark; // used to find edges on current level\r\n        Node():l(0), r(0), p(0), y(rng()), size(1), mark(0), sub_mark(0){if(!rng_init) rng = mt19937(std::chrono::duration_cast<std::chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count()); rng_init=1;}\r\n        //Node(int _from, int _to):Node(){from=_from; to=_to;}\r\n        Node* recalc(){\r\n            sub_mark = mark;\r\n            size = 1;\r\n            if(l){\r\n                sub_mark|=l->sub_mark;\r\n                size+=l->size;\r\n            }\r\n            if(r){\r\n                sub_mark|=r->sub_mark;\r\n                size+=r->size;\r\n            }\r\n            return this;\r\n        }\r\n        Node* set_l(Node*_l){\r\n            l = _l;\r\n            if(l) l->p = this;\r\n            return recalc();\r\n        }\r\n        Node* set_r(Node*_r){\r\n            r = _r;\r\n            if(r) r->p = this;\r\n            return recalc();\r\n        }\r\n        Node* set_ch(Node*_l, Node*_r){\r\n            l = _l; r = _r;\r\n            if(l) l->p = this;\r\n            if(r) r->p = this;\r\n            return recalc();\r\n        }\r\n    };\r\n    static Node* root(Node*a){\r\n        if(!a) return a;\r\n        while(a->p) a = a->p;\r\n        return a;\r\n    }\r\n    static unsigned int size(Node*n){\r\n        return n?n->size:0;\r\n    }\r\n    // splits tree into <c, =c, >c\r\n    static pair<Node*, Node*> split(Node* c){\r\n        Node*l = c->l, *r = c->r;\r\n        if(l) l->p = 0;\r\n        if(r) r->p = 0;\r\n        c->set_ch(0, 0);\r\n        while(c->p){\r\n            Node* p = c->p;\r\n            c->p = 0;\r\n            if(p->l == c){\r\n                r = p->set_l(r);\r\n            } else {\r\n                l = p->set_r(l);\r\n            }\r\n            c = p;\r\n        }\r\n        return make_pair(l, r);\r\n    }\r\n    // splits tree into <c, >=c\r\n    static pair<Node*, Node*> lower_split(Node*c){\r\n        Node*l = c->l, *r = c;\r\n        if(l) l->p = 0;\r\n        c->set_l(0);\r\n        while(c->p){\r\n            Node* p = c->p;\r\n            c->p = 0;\r\n            if(p->l == c){\r\n                r = p->set_l(r);\r\n            } else {\r\n                l = p->set_r(l);\r\n            }\r\n            c = p;\r\n        }\r\n        return make_pair(l, r);\r\n    }\r\n    static Node* join(Node*l, Node*r){\r\n        if(!l) return r;\r\n        if(!r) return l;\r\n        unsigned int depth;\r\n        // bit-mask is used to reduce recursion depth, idea from anta (codeforces)\r\n        unsigned long long path_mask = 0;\r\n        Node*m = 0;\r\n        for(depth=1;;++depth){\r\n            // with high probability, this does not get called\r\n            if(depth+1>= sizeof(path_mask) * CHAR_BIT){\r\n                m = join(l->r, r->l);\r\n                ++depth;\r\n                path_mask = path_mask<<2|1<<(l->y>=r->y);\r\n                break;\r\n            }\r\n            if(l->y < r->y){\r\n                path_mask = path_mask<<1;\r\n                Node*c = l->r;\r\n                if(!c){\r\n                    m = r;\r\n                    r = r->p;\r\n                    break;\r\n                }\r\n                l = c;\r\n            } else {\r\n                path_mask = path_mask<<1|1;\r\n                Node*c = r->l;\r\n                if(!c){\r\n                    m = l;\r\n                    l = l->p;\r\n                    break;\r\n                }\r\n                r = c;\r\n            }\r\n        }\r\n        // m: middle tree, l: next left ancestor, r: next right ancestor\r\n        while(depth--){\r\n            if(path_mask&1){\r\n                m = r->set_l(m);\r\n                r = r->p;\r\n            } else {\r\n                m = l->set_r(m);\r\n                l = l->p;\r\n            }\r\n            path_mask>>=1;\r\n        }\r\n        return m;\r\n    }\r\n    // move a to the front\r\n    static Node* evert(Node*a){\r\n        pair<Node*, Node*> t = lower_split(a);\r\n        return join(t.second, t.first);\r\n    }\r\n    static Node* push_front(Node*t, Node*l){\r\n        t = root(t);\r\n        asser(l->size == 1);\r\n        if(!t) return l;\r\n        for(;;){\r\n            if(l->y < t->y){\r\n                Node* tp = t->p;\r\n                l->set_r(t);\r\n                t = tp;\r\n                break;\r\n            }\r\n            if(!t->l){\r\n                break;\r\n            }\r\n            t = t->l;\r\n        }\r\n        while(t){\r\n            l = t->set_l(l);\r\n            t = t->p;\r\n        }\r\n        return l;\r\n    }\r\n    static Node* push_back(Node*t, Node*r){\r\n        t = root(t);\r\n        asser(r->size == 1);\r\n        if(!t) return r;\r\n        for(;;){\r\n            if(r->y < t->y){\r\n                Node* tp = t->p;\r\n                r->set_l(t);\r\n                t = tp;\r\n                break;\r\n            }\r\n            if(!t->r){\r\n                break;\r\n            }\r\n            t = t->r;\r\n        }\r\n        while(t){\r\n            r = t->set_r(r);\r\n            t = t->p;\r\n        }\r\n        return r;\r\n    }\r\n    static Node* begin(Node*a){\r\n        a = root(a);\r\n        while(a->l) a = a->l;\r\n        return a;\r\n    }\r\n    static Node* end(Node*a){\r\n        a = root(a);\r\n        while(a->r) a = a->r;\r\n        return a;\r\n    }\r\n    static unsigned int lower_cnt(Node*a){\r\n        unsigned int ret = size(a->l);\r\n        for(Node*p = a->p;p;p=a->p){\r\n            if(a==p->r){\r\n                ret+=size(p->l)+1;\r\n            }\r\n            a = p;\r\n        }\r\n        return ret;\r\n    }\r\n\tstatic Node* get(Node*a, unsigned int ind){\r\n\t    assert(ind<size(a));\r\n\t\tfor(;;){\r\n\t\t\tassert(a);\r\n\t\t\tif(ind == size(a->l)) return a;\r\n\t\t\tif(ind < size(a->l)) a = a->l;\r\n\t\t\telse {\r\n\t\t\t\tind-=size(a->l)+1;\r\n\t\t\t\ta = a->r;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n    static void re_path(Node*a){\r\n        for(;a;a=a->p){\r\n            a->recalc();\r\n        }\r\n    }\r\n};\r\nmt19937 Treap::Node::rng = mt19937(83466);\r\nbool Treap::Node::rng_init = false;\r\n\r\nstruct Euler_Tour_Tree{\r\n    vector<tuple<int, int, bool> > const&graph;\r\n    vector<Treap::Node> edges;\r\n    vector<Treap::Node> first_edge;\r\n    Euler_Tour_Tree(int n, int m, vector<tuple<int, int, bool> >&_graph):graph(_graph), edges(2*m), first_edge(n){\r\n        for(int i=0;i<n;++i){\r\n            first_edge[i] = Treap::Node();\r\n        }\r\n    }\r\n    bool is_single(int a){\r\n        return first_edge[a].size == 0 && !first_edge[a].p;\r\n    }\r\n    bool connected(int a, int b){\r\n        return Treap::root(&first_edge[a]) == Treap::root(&first_edge[b]);\r\n    }\r\n    void reroot(int a){\r\n        Treap::evert(&first_edge[a]);\r\n    }\r\n    void link(int edge_index, char mark){\r\n        int a = get<0>(graph[edge_index]), b = get<1>(graph[edge_index]);\r\n        Treap::Node* e_ab = new (edges.data()+2*edge_index) Treap::Node();\r\n        Treap::Node* e_ba = new (edges.data()+2*edge_index+1) Treap::Node();\r\n        e_ab->mark = mark;\r\n        e_ab->recalc();\r\n        Treap::evert(&first_edge[a]);\r\n        Treap::push_back(&first_edge[a], e_ab);\r\n        Treap::evert(&first_edge[b]);\r\n        Treap::push_back(&first_edge[b], e_ba);\r\n        Treap::join(Treap::root(&first_edge[a]), Treap::root(&first_edge[b]));\r\n    }\r\n    void cut(int edge_index){\r\n        Treap::Node* e_ab = &edges[2*edge_index], *e_ba = &edges[2*edge_index|1];\r\n        pair<Treap::Node*, Treap::Node*> ta = Treap::split(e_ab);\r\n        unsigned int tar_size = Treap::size(ta.second);\r\n        pair<Treap::Node*, Treap::Node*> tb = Treap::split(e_ba);\r\n        // ensure ta is to the left of tb\r\n        if(ta.second != e_ba && tar_size==Treap::size(ta.second)){\r\n            swap(e_ab, e_ba);\r\n            swap(ta, tb);\r\n        }\r\n        // order is ta.first, e_ab, ta.second or tb.first, e_ba, tb.second\r\n        Treap::join(Treap::root(tb.second), Treap::root(ta.first));\r\n    }\r\n    unsigned int size(int a){\r\n        if(is_single(a)) return 1;\r\n        return (Treap::size(Treap::root(&first_edge[a]))+2)/3;\r\n    }\r\n    void set_mark(int a, char mark){\r\n        first_edge[a].mark = mark;\r\n        Treap::re_path(&first_edge[a]);\r\n    }\r\n    void set_edge_mark(int edge_index, char mark){\r\n        edges[2*edge_index].mark = mark;\r\n        Treap::re_path(&edges[2*edge_index]);\r\n    }\r\n    void set_edge_mark(Treap::Node*c, char mark){\r\n        asser(c);\r\n        if((c-edges.data())%2) return set_edge_mark((c-edges.data())/2, mark);\r\n        c->mark = mark;\r\n        Treap::re_path(c);\r\n    }\r\n    // calls op on marked nodes until op returns true or there are no such nodes\r\n    template<char mark_mask, class OP>\r\n    bool call_on_nodes(int a, OP &&op){\r\n        Treap::Node*c = &first_edge[a];\r\n        while(c->p && !(c->sub_mark&mark_mask)) c = c->p;\r\n        while(c->sub_mark&mark_mask){\r\n            if(c->mark&mark_mask){\r\n                if(op(c)) return true;\r\n            }\r\n            // escape subtree if mark got unset\r\n            while(c->p && !(c->sub_mark&mark_mask)) c = c->p;\r\n            // find successor with mark_mask set in sub_mark\r\n            if(c->r && c->r->sub_mark&mark_mask){\r\n                c = c->r;\r\n                while(c->l && c->l->sub_mark&mark_mask) c = c->l;\r\n            } else {\r\n                while(c->p && c == c->p->r) c = c->p;\r\n                if(!c->p){\r\n                    while(c->l && c->l->sub_mark&mark_mask) c = c->l;\r\n                } else {\r\n                    c = c->p;\r\n                }\r\n            }\r\n        }\r\n        asser(!(Treap::root(&first_edge[a])->sub_mark & mark_mask));\r\n        return false;\r\n    }\r\n    unsigned int index_edge(Treap::Node* n){\r\n        return (n-edges.data())/2;\r\n    }\r\n    unsigned int index_vertex(Treap::Node*n){\r\n        return n - first_edge.data();\r\n    }\r\n};\r\n\r\nstruct Layer_Structure{\r\n    int logn, n, m;\r\n    vector<Euler_Tour_Tree> levels;\r\n    vector<tuple<int, int, bool> > edges;\r\n    vector<unsigned int> free_edges;\r\n    // stores all edge and their index\r\n    vector<map<int, int> > graph;\r\n    Layer_Structure(int _n, int _m):n(_n), m(_m){\r\n        for(logn=1;1ll<<logn<=n;++logn);\r\n        levels.reserve(logn);\r\n        levels.emplace_back(n, m, edges);\r\n        edges.reserve(m);\r\n        graph.resize(n*logn);\r\n    }\r\n    int calc_graph_pos(int level, int vertex){\r\n        return level*n+vertex;\r\n    }\r\n    bool connected(int a, int b){\r\n        return levels[0].connected(a, b);\r\n    }\r\n    void insert_edge(int edge_index, int level){\r\n        int a = get<0>(edges[edge_index]), b = get<1>(edges[edge_index]);\r\n        bool add_to_forest = get<2>(edges[edge_index]);\r\n        asser(a!=b);\r\n        int x = calc_graph_pos(level, a);\r\n        int y = calc_graph_pos(level, b);\r\n        asser(graph[x].find(b) == graph[x].end());\r\n        asser(graph[y].find(a) == graph[y].end());\r\n        if(add_to_forest){\r\n            levels[level].link(edge_index, 2);\r\n        }\r\n        if(graph[x].empty()){\r\n            levels[level].set_mark(a, 1);\r\n        }\r\n        if(graph[y].empty()){\r\n            levels[level].set_mark(b, 1);\r\n        }\r\n        graph[x][b] = edge_index;\r\n        graph[y][a] = edge_index;\r\n    }\r\n    void remove_edge(unsigned int edge_index, int level){\r\n        int a = get<0>(edges[edge_index]), b = get<1>(edges[edge_index]);\r\n        int x = calc_graph_pos(level, a), y = calc_graph_pos(level, b);\r\n        asser(graph[x].find(b)!=graph[x].end());\r\n        asser(graph[y].find(a)!=graph[y].end());\r\n        asser(graph[x][b] == graph[y][a]);\r\n        graph[x].erase(b);\r\n        if(graph[x].empty()) levels[level].set_mark(a, 0);\r\n        graph[y].erase(a);\r\n        if(graph[y].empty()) levels[level].set_mark(b, 0);\r\n    }\r\n    void link(int a,int b){\r\n        bool is_tree = !levels[0].connected(a, b);\r\n        unsigned int edge_index;\r\n        if(!free_edges.empty()){\r\n            edge_index = free_edges.back();\r\n            free_edges.pop_back();\r\n        } else {\r\n            edge_index = edges.size();\r\n            edges.emplace_back();\r\n        }\r\n        edges[edge_index] = make_tuple(a, b, is_tree);\r\n        insert_edge(edge_index, 0);\r\n    }\r\n    void push_edge(unsigned int edge_index, int level){\r\n        asser(level+1<logn);\r\n        if(level+1== (int)levels.size()) levels.emplace_back(n, m, edges);\r\n\r\n        remove_edge(edge_index, level);\r\n        insert_edge(edge_index, level+1);\r\n    }\r\n    // returns true if #components increased\r\n    bool cut(int a, int b){\r\n        int level = (int)levels.size()-1;\r\n        while(graph[calc_graph_pos(level, a)].find(b) == graph[calc_graph_pos(level, a)].end()){\r\n            asser(level>0);\r\n            --level;\r\n        }\r\n        unsigned int edge_index = graph[calc_graph_pos(level, a)][b];\r\n        asser2(levels[level].connected(a, b));\r\n        bool was_in_forest = get<2>(edges[edge_index]);\r\n        remove_edge(edge_index, level);\r\n        free_edges.push_back(edge_index);\r\n        if(!was_in_forest) return false;\r\n        asser2(level+1 == (int)levels.size() || !levels[level+1].connected(a, b));\r\n        for(int i=level;i>=0;--i){\r\n            levels[i].cut(edge_index);\r\n            int small = a, big = b;\r\n            if(levels[i].size(small)>levels[i].size(b)){\r\n                swap(small, big);\r\n            }\r\n            // push tree edges first\r\n            levels[i].call_on_nodes<2>(small, [this, i](Treap::Node*c){\r\n                auto const& edge = edges[levels[i].index_edge(c)];\r\n                int x = calc_graph_pos(i, get<0>(edge));\r\n                if(graph[x].find(get<1>(edge))!=graph[x].end()){\r\n                    push_edge(levels[i].index_edge(c), i);\r\n                }\r\n                levels[i].set_edge_mark(c, 0);\r\n                if(graph[x].empty()){\r\n                    levels[i].set_mark(get<0>(edge), 0);\r\n                }\r\n                return false;\r\n            });\r\n            // search for non-tree edges\r\n            if(levels[i].call_on_nodes<1>(small, [this, a, b, i, small, edge_index](Treap::Node*c){\r\n                int from = levels[i].index_vertex(c);\r\n                int x = calc_graph_pos(i, from);\r\n                asser(!graph[x].empty());\r\n                for(auto it = graph[x].begin();it!=graph[x].end();){\r\n                    // edge in same tree\r\n                    if(levels[i].connected(small, it->first)){\r\n                        unsigned int pushed_edge_index = it->second;\r\n                        ++it;\r\n                        push_edge(pushed_edge_index, i);\r\n                    // replacement edge\r\n                    } else {\r\n                        get<2>(edges[it->second]) = true;\r\n                        levels[i].link(it->second, 2);\r\n                        for(int j=i-1;j>=0;--j){\r\n                            levels[j].cut(edge_index);\r\n                            levels[j].link(it->second, 0);\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n                asser(graph[x].empty());\r\n                levels[i].set_mark(from, 0);\r\n                return false;\r\n            })){\r\n                return false;\r\n                break;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n\r\n\r\n\r\nvoid solve(){\r\n    /// SOLVE HERE\r\n\r\n    int n, t;\r\n    cin >> n >> t;\r\n    vector<vector<int> > g(n);\r\n    int m = 0;\r\n    map<pair<int, int>, int> decode;\r\n    auto add = [&](int i, int x, int y){\r\n        decode[make_pair(x, y)] = i;\r\n        for(int dx = -1;dx<=1;++dx){\r\n            for(int dy=-1;dy<=1;++dy){\r\n                if(abs(dx) + abs(dy) >= 1){\r\n                    auto it = decode.find(make_pair(x+dx, y+dy));\r\n                    if(it != decode.end()){\r\n                        g[i].push_back(it->second);\r\n                        g[it->second].push_back(i);\r\n                        ++m;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    for(int i=0;i<n;++i){\r\n        int x, y;\r\n        cin >> x >> y;\r\n        add(i, x, y);\r\n    }\r\n\r\n    Layer_Structure l(n, 2*m+10);\r\n\r\n    for(int i=0;i<n;++i){\r\n        for(auto const&e:g[i]) if(e<i){\r\n            l.link(i, e);\r\n        }\r\n    }\r\n\r\n    for(int i=1;i<n;++i){\r\n        if(!l.connected(0, i)){\r\n            cout << \"NO\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    vector<char> vis(n, 0);\r\n    auto remove = [&](int u){\r\n        int ret = 0;\r\n        for(auto const&e:g[u]) if(!vis[e]){\r\n            ret += l.cut(u, e);\r\n        }\r\n        vis[u] = 1;\r\n        return ret;\r\n    };\r\n\r\n    auto add_back = [&](int u){\r\n        for(auto const&e:g[u]) if(!vis[e]){\r\n            l.link(u, e);\r\n        }\r\n        vis[u] = 0;\r\n    };\r\n\r\n\r\n    auto is_cut_vertex = [&](int u){\r\n        int new_components = remove(u);\r\n        bool ret = new_components > 1;\r\n        if(ret){\r\n            add_back(u);\r\n        }\r\n        //cerr << u << \" \" << new_components << \"\\n\";\r\n        return ret;\r\n    };\r\n\r\n    priority_queue<int> pq;\r\n    for(int i=0;i<n;++i){\r\n        if((int)g[i].size() < 4){\r\n            pq.emplace(i);\r\n        }\r\n    }\r\n    vector<int> out;\r\n    while(!pq.empty()){\r\n        int u = pq.top();\r\n        pq.pop();\r\n        if(vis[u]) continue;\r\n        if(is_cut_vertex(u)) continue;\r\n        out.push_back(u);\r\n        for(auto const&e:g[u]) pq.push(e);\r\n    }\r\n    reverse(out.begin(), out.end());\r\n    cout << \"YES\\n\";\r\n    for(auto const&e:out){\r\n        cout << e+1 << \"\\n\";\r\n    }\r\n\r\n\r\n}\r\n\r\nsigned gen(int T){\r\n    mt19937 rng(43151);\r\n    auto get_rand = [&](int64_t l, int64_t r){\r\n        return uniform_int_distribution<int64_t>(l, r)(rng);\r\n    }; (void) get_rand;\r\n    auto get_double = [&](double l, double r){\r\n        return uniform_real_distribution<double>(l, r)(rng);\r\n    };  (void) get_double;\r\n    ofstream o(\"gen.txt\");\r\n    o << T << \"\\n\";\r\n    for(int cas=0;cas<T;++cas){\r\n        /// GEN HERE\r\n\r\n        o << \"\\n\";\r\n    }\r\n    o << endl;\r\n    o.close();\r\n    return 0;\r\n}\r\n\r\nsigned main()\r\n{\r\n    #ifdef LOCAL_RUN\r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    //freopen(\"out.txt\", \"w\", stdout);\r\n    cin.exceptions(ios::badbit | ios::eofbit | ios::failbit);\r\n    cin.tie(0); ios_base::sync_with_stdio(false);\r\n    int TTT; cin >> TTT;\r\n\tif(TTT < 0) return gen(-TTT);\r\n\twhile(TTT--){\r\n    #else\r\n    cin.tie(0); ios_base::sync_with_stdio(false);\r\n    #endif // LOCAL_RUN\r\n\r\n    solve();\r\n\r\n    #ifdef LOCAL_RUN\r\n    cout << flush;\r\n    }\r\n    #endif // LOCAL_RUN\r\n    return 0;\r\n}\r\n"
}