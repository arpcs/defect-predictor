{
    "id": 165123924,
    "contestId": 1192,
    "creationTimeSeconds": 1658408359,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "M_8625"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 1606,
    "memoryConsumedBytes": 224358400,
    "points": 100.0,
    "source": "/* Constructs the minimum required grid graph.\n   Tracks connected components using union-find.\n   Decides which cells may be deleted based on neighbourhoods,\n   updates that information when necessary and keeps these cells\n   in a set<>.\n   O(N log N)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass HashPair {\n    static inline size_t hash_combine(size_t h_first, size_t h_second) {\n        return h_first ^ (h_second + 0x9e3779b9 + (h_first << 6) + (h_second >> 2));\n    }\n\n    static inline size_t hash_int(unsigned int x) {\n        x = ((x >> 16) ^ x) * 0x45d9f3b;\n        x = ((x >> 16) ^ x) * 0x45d9f3b;\n        x = (x >> 16) ^ x;\n        return x;\n    }\n\npublic:\n    size_t operator() (const pair<int, int> & p) const {\n        size_t h_first  = hash_int(p.first);\n        size_t h_second = hash_int(p.second);\n\n        return hash_combine(h_first, h_second);\n    }\n};\n\nclass lego {\n    int N, V;\n    vector< pair<int, int> > cells, empty_cells;\n    unordered_map< pair<int, int>, int, HashPair> cell_indices, empty_cell_indices;\n    vector<char> removed;\n\n    set<int> removable;\n    vector<char> is_removable;\n\n    vector< vector<int> > G4, G8;\n\n    void construct_graphs(bool only_solvability = false) {\n        constexpr static int dx[8] = {-1, -1, -1,  0,  1, 1, 1, 0};\n        constexpr static int dy[8] = { 1,  0, -1, -1, -1, 0, 1, 1};\n\n        if(!init_solvability_done) {\n            for(int i = 0; i < N; i++) for(int j = 0; j < 8; j++) {\n                pair<int, int> p = {cells[i].first + dx[j], cells[i].second + dy[j]};\n                auto it = cell_indices.find(p);\n                int cell_id = (it == end(cell_indices)) ? -1 : it->second;\n                if(cell_id == -1) {\n                    auto jt = empty_cell_indices.find(p);\n                    if(jt == end(empty_cell_indices)) {\n                        empty_cell_indices[p] = empty_cells.size();\n                        cell_id = N + empty_cells.size();\n                        empty_cells.push_back(p);\n                        G4.push_back({});\n                        G8.push_back(vector<int>(8, cell_id));\n                    }\n                    else cell_id = N + jt->second;\n                    G8[cell_id][4^j] = i;\n                    if(j % 2) G4[cell_id].push_back(i);\n                }\n                G8[i][j] = cell_id;\n                if(j % 2) G4[i].push_back(cell_id);\n            }\n        }\n        if(!init_done && !only_solvability) {\n            for(int i = 0; i < (int)empty_cells.size(); i++) for(int j = 0; j < 8; j++) {\n                if(G8[N+i][j] != N+i) continue;\n                pair<int, int> p = {empty_cells[i].first + dx[j], empty_cells[i].second + dy[j]};\n                auto it = empty_cell_indices.find(p);\n                if(it == end(empty_cell_indices)) continue;\n                int cell_id = N + it->second;\n                G8[N+i][j] = cell_id;\n                if(j % 2) G4[N+i].push_back(cell_id);\n            }\n        }\n    }\n\n    int outer_component;\n    vector< vector<int> > components4, components8;\n    vector<int> comp4, comp8;\n    vector<int> deg4, deg8; // degree = number of full neighbouring cells\n\n    void find_components(bool only_solvability = false) {\n        queue<int> q;\n\n        if(!init_solvability_done) {\n            components4.clear(); components4.resize(V);\n            components8.clear(); components8.resize(V);\n            comp4.clear(); comp4.resize(V, -1);\n            comp8.clear(); comp8.resize(V, -1);\n            deg4.clear(); deg4.resize(V, 0);\n            deg8.clear(); deg8.resize(V, 0);\n            for(int i = 0; i < V; i++) if(comp8[i] == -1 && !is_empty(i)) {\n                comp8[i] = i;\n                components8[i] = {i};\n                q.push(i);\n                while(!q.empty()) {\n                    for(auto v : G8[q.front()]) if(comp8[v] == -1 && !is_empty(v)) {\n                        comp8[v] = i;\n                        components8[i].push_back(v);\n                        q.push(v);\n                    } \n                    q.pop();\n                }\n            }\n        }\n        if(!init_done && !only_solvability) {\n            for(int i = 0; i < V; i++) if(comp4[i] == -1 && is_empty(i)) {\n                comp4[i] = i;\n                components4[i] = {i};\n                q.push(i);\n                while(!q.empty()) {\n                    for(auto v : G4[q.front()]) if(comp4[v] == -1 && is_empty(v)) {\n                        comp4[v] = i;\n                        components4[i].push_back(v);\n                        q.push(v);\n                    } \n                    q.pop();\n                }\n            }\n            for(int i = 0; i < V; i++) {\n                for(auto v : G4[i]) if(!is_empty(v)) deg4[i]++;\n                for(auto v : G8[i]) if(!is_empty(v)) deg8[i]++;\n            }\n        }\n    }\n\n    void add_edge(int v1, int v2) {\n        int c1 = comp4[v1], c2 = comp4[v2];\n        if(c1 == c2) return;\n        if(components4[c1].size() < components4[c2].size()) swap(c1, c2);\n        for(auto v : components4[c2]) {\n            comp4[v] = c1;\n            components4[c1].push_back(v);\n        }\n        if(c2 == outer_component) outer_component = c1;\n        for(auto v : components4[c2])\n            for(auto f : G8[v]) if(!is_empty(f)) update(f);\n    }\n\n    void update(int v) {\n        static vector<char> seen = vector<char>(V, 0);\n\n        bool reachable = false, articulation = false;\n\n        for(auto adj : G4[v]) if(is_empty(adj))\n            if(comp4[adj] == outer_component) reachable = true;\n\n        if(deg8[v] <= 1) {\n            if(reachable) {\n                if(!is_removable[v]) {\n                    removable.insert(v);\n                    is_removable[v] = 1;\n                }\n            }\n            else if(is_removable[v]) {\n                removable.erase(v);\n                is_removable[v] = 0;\n            }\n            return;\n        }\n\n        for(int j = 0; j < 8; j++) if(is_empty(G8[v][j])) {\n            if(is_empty(G8[v][(j+1)%8])) continue; // 1 cell per region\n            if(j % 2 == 0 && !is_empty(G8[v][(j+7)%8])) continue; // ignore corner gaps\n            int c = comp4[G8[v][j]];\n            if(seen[c]) {\n                articulation = true;\n                break;\n            }\n            seen[c]++;\n        }\n        for(int j = 0; j < 8; j++) if(is_empty(G8[v][j]))\n            seen[comp4[G8[v][j]]] = 0;\n\n        if(reachable && !articulation) {\n            if(!is_removable[v]) {\n                removable.insert(v);\n                is_removable[v] = 1;\n            }\n        }\n        else if(is_removable[v]) {\n            removable.erase(v);\n            is_removable[v] = 0;\n        }\n    }\n\n    inline bool is_empty(int cell) {\n        return (cell >= N || removed[cell]);\n    }\n\n    bool init_done, init_solvability_done;\n\n    void init_solvability() {\n        if(init_solvability_done) return;\n        construct_graphs(true);\n        V = G4.size();\n        removed.resize(V, false);\n        find_components(true);\n        init_solvability_done = true;\n    }\n\n    void init() {\n        if(init_done) return;\n\n        construct_graphs();\n        if(!init_solvability_done) {\n            V = G4.size();\n            removed.resize(V, false);\n        }\n\n        find_components();\n        int min_coord = cells[0].first;\n        for(int i = N; i < V; i++) if(min_coord >= empty_cells[i-N].first) {\n            min_coord = empty_cells[i-N].first;\n            outer_component = comp4[i];\n        }\n\n        is_removable.resize(N, 0);\n        for(int i = 0; i < N; i++) update(i);\n        \n        init_done = init_solvability_done = true;\n    }\n\n  public:\n    lego(vector< pair<int, int> > cells_) : N(cells_.size()), cells(cells_) {\n        for(int i = 0; i < N; i++) cell_indices[cells[i]] = i;\n        G4.resize(N);\n        G8.resize(N, vector<int>(8));\n        G4.reserve(9*N);\n        G8.reserve(9*N);\n        cell_indices.reserve(N);\n        empty_cell_indices.reserve(8*N);\n        \n        init_done = init_solvability_done = false;\n    }\n    \n    bool solvable() {\n        init_solvability();\n        return ((int)components8[comp8[0]].size() == N);\n    }\n\n    int remove() {\n        init();\n        if(removable.empty()) return -1;\n        int rm_id = *rbegin(removable);\n\n        removable.erase(--end(removable));\n        removed[rm_id] = true;\n\n        components4[rm_id] = {rm_id};\n        comp4[rm_id] = rm_id;\n        for(auto f : G4[rm_id]) if(!is_empty(f)) update(f);\n        for(auto v : G4[rm_id]) {\n            if(is_empty(v)) add_edge(rm_id, v);\n            else deg4[v]--;\n        }\n        for(auto v : G8[rm_id]) {\n            deg8[v]--;\n            if(!is_empty(v)) update(v);\n        }\n\n        return rm_id;\n    }\n};\n\nint main() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    int N, t;\n    cin >> N >> t;\n    vector< pair<int, int> > cells(N);\n    for(int i = 0; i < N; i++) cin >> cells[i].first >> cells[i].second;\n\n    lego solver(cells);\n\n    if(!solver.solvable()) {\n        cout << \"NO\\n\";\n        return 0;\n    }\n\n    cout << \"YES\\n\";\n    vector<int> build;\n    for(int i = 0; i < N; i++) {\n        int removed_cell_id = solver.remove();\n        assert(removed_cell_id != -1);\n        build.push_back(removed_cell_id+1);\n    }\n    reverse(begin(build), end(build));\n    for(int i = 0; i < N; i++) cout << build[i] << \"\\n\";\n}\n"
}