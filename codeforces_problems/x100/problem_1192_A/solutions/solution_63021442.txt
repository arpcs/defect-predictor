{
    "id": 63021442,
    "contestId": 1192,
    "creationTimeSeconds": 1571582544,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "rama_pang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 2620,
    "memoryConsumedBytes": 163225600,
    "points": 100.0,
    "source": "#pragma comment(linker, \"/STACK:2000000\")\r\n#pragma comment(linker, \"/HEAP:2000000\")\r\n#pragma GCC optimize (\"Ofast\")\r\n#pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma,mmx,tune=native\")\r\n#pragma GCC optimize (\"unroll-loops\")\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int dr[] = {-1, -1, -1,  0, +1, +1, +1,  0};\r\nconst int dc[] = {-1,  0, +1, +1, +1,  0, -1, -1};\r\nsize_t key = 31415926;\r\nsize_t shift = 27182818284;\r\n\r\n/*  Solve the problem in reverse: find and remove a non-8-articulation 4-reachable from infinity \r\n    cell N times, and restore the order in reverse order (or report that it is impossible).\r\n \r\n    If cells are all 8-connected, then there is a non-8-articulation 4-reachable from infinity cell.\r\n    \r\n    Let the region of a c0 = 4-reachable empty cells surrounding this cell, and different cell c1\r\n    and c2 are in one region if there are 4-paths only using 8-negihbours of c0. (c1 and c2 are\r\n    4-reachable negihbours of c0)\r\n\r\n    For all 4-reachable from infinity full cells, if it is a non-articulation, then all regioin\r\n    must belong to different components. If two regions belong to the same component, then there\r\n    are no alternate paths connecting some 8-reachable cells through c0 in the graph.\r\n*/\r\n \r\nstruct Hash {\r\n\r\n    inline size_t HashInt(size_t x) const {\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    inline size_t HashCombine(size_t a, size_t b) const {\r\n        return a ^ (b + shift + (a << 7ll)) + a << 5ll + b >> 2ll;\r\n    }\r\n\r\n    size_t operator () (const pair<int, int> &o) const {\r\n        size_t a = HashInt(o.first), b = HashInt(o.second);\r\n        return HashCombine(a, b);\r\n    }\r\n\r\n};\r\n\r\nstruct DisjointSet {\r\n\r\n    vector<int> p;\r\n    vector<vector<int>> members;\r\n    vector<int> set_size;\r\n    int size;\r\n    bool need_members;\r\n\r\n    DisjointSet(bool yes = 0): need_members(yes) {}\r\n    \r\n    void init(int n) {\r\n        p.resize(n);\r\n        iota(p.begin(), p.end(), 0);\r\n        if (need_members) {\r\n            members.resize(n);\r\n            for (int i = 0; i < n; i++) members[i].push_back(i);\r\n        } else {\r\n            set_size.assign(n, 1);\r\n        }\r\n        size = n;\r\n    }\r\n\r\n    int find(int n) {\r\n        return (p[n] == n)? n : p[n] = find(p[n]);\r\n    }\r\n    \r\n    inline bool join(int a, int b) {\r\n        a = find(a), b = find(b);\r\n        if (a == b) return false;\r\n\r\n        if (need_members) {\r\n            if (members[a].size() < members[b].size()) swap(a, b);\r\n            for (auto i : members[b]) members[a].push_back(i);\r\n            members[b].clear();\r\n        } else {\r\n            if (set_size[a] < set_size[b]) swap(a, b);\r\n            set_size[a] += set_size[b];\r\n            set_size[b] = 0;\r\n        }\r\n\r\n        p[b] = a;\r\n        size--;\r\n        return true;\r\n    }\r\n\r\n    inline vector<int> get_members(int n) {\r\n        return members[find(n)];\r\n    }\r\n    \r\n    inline int get_size(int n) {\r\n        return members[find(n)].size();\r\n    }\r\n\r\n};\r\n\r\nint N;\r\nmap<pair<int, int>, int> full_cell, empty_cell, cell;\r\nvector<pair<int, int>> cell_id;\r\nDisjointSet component(1); //connected components of empty cells\r\n\r\nnamespace validity_check {\r\n    /*  Run DFS on 8-reachable graph of full cells. It can be proven that\r\n        if the given graph is 8-connected, then there is at least one cell\r\n        which is non-8-articulation 4-reachable from infinity. Thus a solution\r\n        exists if and only if the graph is 8-connected.\r\n    */\r\n\r\n    vector<vector<int>> G;\r\n    vector<int> vis;\r\n    \r\n    int flood(pair<int, int> n) {\r\n        int id = cell[n];\r\n        if (vis[id]) return 0;\r\n        vis[id] = 1;\r\n        int res = 1;\r\n\r\n        for (int d = 0; d < 8; d++) {\r\n            int tr = n.first + dr[d], tc = n.second + dc[d];\r\n            if (full_cell.find({tr, tc}) == full_cell.end()) continue;\r\n            res += flood({tr, tc});\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    bool solution_exists() {\r\n        G.resize(full_cell.size()), vis.resize(full_cell.size());\r\n        int connected_size = flood(cell_id[0]);\r\n        return (connected_size == N);\r\n    }\r\n}\r\n\r\n\r\nnamespace solve {\r\n    \r\n    pair<int, int> infinity_cell;\r\n\r\n    vector<int> vis;\r\n    \r\n    void flood(pair<int, int> n, int par) {\r\n        int id = cell[n];\r\n        if (vis[id]) return;\r\n        vis[id] = 1;\r\n        component.join(id, par);\r\n\r\n        for (int d = 1; d < 8; d += 2) { //4-direction\r\n            int tr = n.first + dr[d], tc = n.second + dc[d];\r\n            if (empty_cell.find({tr, tc}) == empty_cell.end()) continue;\r\n            flood({tr, tc}, par);\r\n        }\r\n    }\r\n\r\n    set<int> regions, small;\r\n    vector<DisjointSet> near;\r\n    \r\n    vector<int> infinity_reachable;\r\n    vector<array<int, 8>> empty_neighbour;\r\n    vector<bool> is_removable, in_queue;\r\n\r\n    inline bool is_valid(pair<int, int> p) {\r\n        int id = cell[p];\r\n        regions.clear();\r\n        small.clear();\r\n        // near.init(4);\r\n\r\n        for (int d = 1; d < 8; d += 2) {\r\n            int tr = p.first + dr[d], tc = p.second + dc[d];\r\n            if (!empty_neighbour[id][d]) continue;\r\n            small.insert(near[id].find(((d - 1) / 2)));\r\n            regions.insert(component.find(cell[{tr, tc}]));\r\n        }\r\n\r\n        if (!infinity_reachable[id]) infinity_reachable[id] = (regions.find(component.find(cell[{infinity_cell}])) != regions.end());\r\n        if (!infinity_reachable[id]) return false;\r\n        return (regions.size() == small.size()); //all regions must be different components\r\n    }\r\n\r\n    vector<int> get_solution() {\r\n        /*  We can check if a cell is 4-reachable from infinity in O(1) with\r\n            the help of dijoinst set. We can also determine if a cell is an\r\n            articulation the same way. Thus each time we are going to remove\r\n            a cell, we can just check all N possible skyscrapers.\r\n\r\n            However, each 4-reachable cell can change its status as an\r\n            articulation or non-articulation at most 2 times: a non-articulation\r\n            (as there are other connecting paths), an articulation (all other\r\n            connecting paths are already removed), a non-articulation (it becomes\r\n            a leaf).\r\n\r\n            Thus if we join two components, we can afford to recompute all 8-negihbours \r\n            of the one with less size and achieve N log N by the weighted-union heursitic.\r\n\r\n            When updating, different components will never increase, while regions will\r\n            never decrease. Regions will only increase for 8-neighbours of removed cell,\r\n            while components will decrease for all 4-reachable path from removed cell. \r\n            Also, once a cell is reachable from infinity, it will always be reachable\r\n            from infinity. Thus we can just maintain this information to speed up\r\n            when updating cells.\r\n        */\r\n\r\n        infinity_cell = cell.begin()->first;\r\n        for (auto i : cell) infinity_cell = min(infinity_cell, i.first);\r\n\r\n        infinity_reachable.resize(full_cell.size());\r\n        // regions.reserve(4);\r\n        // small.reserve(4);\r\n        empty_neighbour.resize(full_cell.size());\r\n        is_removable.resize(full_cell.size());\r\n        in_queue.resize(full_cell.size());\r\n        near.resize(full_cell.size());\r\n\r\n        vis.assign(cell.size(), 0);\r\n        flood(infinity_cell, cell[infinity_cell]);\r\n        \r\n        for (auto i : cell) {\r\n            if (empty_cell.find(i.first) == empty_cell.end()) continue;\r\n            flood(i.first, i.second);\r\n        }\r\n\r\n        for (auto i : full_cell) {\r\n            for (int d = 0; d < 8; d++) {\r\n                int tr = i.first.first + dr[d], tc = i.first.second + dc[d];\r\n                empty_neighbour[i.second][d] = (empty_cell.find({tr, tc}) != empty_cell.end());\r\n            }\r\n            near[i.second].init(4);\r\n            for (int d = 1; d < 8; d += 2) {\r\n                int c1 = empty_neighbour[i.second][d],\r\n                    c2 = empty_neighbour[i.second][(d + 1) % 8],\r\n                    c3 = empty_neighbour[i.second][(d + 2) % 8];\r\n                if (c1 == c2 && c2 == c3 && c3 == 1) near[i.second].join(((d - 1) / 2), (((d - 1) / 2) + 1) % 4);\r\n            }\r\n        }\r\n\r\n        // set<int> removable;\r\n        priority_queue<int> removable;\r\n        for (auto i : full_cell) if (is_valid(i.first)) removable.emplace(i.second), is_removable[i.second] = 1, in_queue[i.second] = 1;\r\n        \r\n        vector<int> res;\r\n        vector<int> change;\r\n        // unordered_set<pair<int, int>, Hash> update_list;\r\n        vector<pair<int, int>> update_list;\r\n        update_list.reserve(4 * N);\r\n        res.reserve(N);\r\n        change.reserve(N);\r\n\r\n        while (full_cell.size() > 0) {\r\n            // int candidate = *prev(removable.end());\r\n            while (!is_removable[removable.top()]) in_queue[removable.top()] = 0, removable.pop();\r\n            int candidate = removable.top();\r\n            pair<int, int> P = cell_id[candidate];\r\n            // removable.erase(prev(removable.end()));\r\n            removable.pop();\r\n            is_removable[candidate] = 0;\r\n            in_queue[candidate] = 0;\r\n\r\n            res.push_back(candidate + 1);\r\n            full_cell.erase(full_cell.find(P));\r\n            empty_cell.insert({P, candidate});\r\n\r\n            update_list.clear();\r\n\r\n            /* Update connected components of cells affected */\r\n            for (int d = 1; d < 8; d += 2) {\r\n                int tr = P.first + dr[d], tc = P.second + dc[d];\r\n                \r\n                int P_id = cell[P], neighbour_id = cell[{tr, tc}];\r\n                if (empty_cell.find({tr, tc}) == empty_cell.end()) continue;\r\n                if (component.find(P_id) == component.find(neighbour_id)) continue;\r\n\r\n                if (component.get_size(neighbour_id) > component.get_size(P_id)) {\r\n                    change = component.get_members(P_id);                    \r\n                } else {\r\n                    change = component.get_members(neighbour_id);\r\n                }\r\n\r\n                component.join(neighbour_id, P_id);\r\n                \r\n                for (auto i : change) {\r\n                    pair<int, int> cur = cell_id[i];\r\n\r\n                    for (int change_d = 0; change_d < 8; change_d++) {\r\n                        int change_tr = cur.first + dr[change_d], change_tc = cur.second + dc[change_d];\r\n                        if (full_cell.find({change_tr, change_tc}) == full_cell.end()) continue;\r\n                        // update_list.insert({change_tr, change_tc});\r\n                        update_list.push_back({change_tr, change_tc});\r\n                        \r\n                    }\r\n                }\r\n            }\r\n\r\n            for (int d = 0; d < 8; d++) {\r\n                int tr = P.first + dr[d], tc = P.second + dc[d];    \r\n                if (full_cell.find({tr, tc}) == full_cell.end()) continue;\r\n                int id = cell[{tr, tc}];\r\n                empty_neighbour[id][(d + 4) % 8] = 1;\r\n                for (int d2 = 1; d2 < 8; d2 += 2) {\r\n                    int c1 = empty_neighbour[id][d2],\r\n                        c2 = empty_neighbour[id][(d2 + 1) % 8],\r\n                        c3 = empty_neighbour[id][(d2 + 2) % 8];\r\n                    if (c1 == c2 && c2 == c3 && c3 == 1) near[id].join(((d2 - 1) / 2), (((d2 - 1) / 2) + 1) % 4);\r\n                }   \r\n            }\r\n\r\n            sort(update_list.begin(), update_list.end());\r\n            update_list.resize(unique(update_list.begin(), update_list.end()) - update_list.begin());\r\n            \r\n            for (auto i : update_list) {\r\n                int id = cell[i];\r\n                if (is_valid(i)) {\r\n                    is_removable[id] = 1;\r\n                    if (!in_queue[id]) removable.emplace(id);\r\n\r\n                    // if (!is_removable[id]) {\r\n                    //     removable.emplace(id);\r\n                    //     is_removable[id] = 1;\r\n                    // }\r\n                } else {\r\n                    is_removable[id] = 0;\r\n                    // if (is_removable[id]) {\r\n                    //     removable.erase(cell[i]);\r\n                    //     is_removable[id] = 0;\r\n                    // }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n\r\n}\r\n\r\n\r\nint main() {\r\n    // ios_base::sync_with_stdio(0);\r\n    // cin.tie(0), cout.tie(0);\r\n\r\n    // freopen(\"7.022.in\", \"r\", stdin);\r\n    // freopen(\"7.022.out\", \"w\", stdout);\r\n\r\n    int t;\r\n    // cin >> N >> t;\r\n    scanf(\"%d %d\", &N, &t);\r\n\r\n    // full_cell.reserve(2 * N);\r\n    // empty_cell.reserve(10 * N);\r\n    // cell.reserve(10 * N);\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        int r, c;\r\n        // cin >> r >> c;\r\n        scanf(\"%d %d\", &r, &c);\r\n        full_cell.insert({{r, c}, cell.size()});\r\n        cell.insert({{r, c}, cell.size()});\r\n    }\r\n\r\n    for (auto i : full_cell) {\r\n        for (int d = 0; d < 8; d++) {\r\n            int tr = i.first.first + dr[d], tc = i.first.second + dc[d];\r\n            if (cell.find({tr, tc}) != cell.end()) continue;\r\n            empty_cell.insert({{tr, tc}, cell.size()});\r\n            cell.insert({{tr, tc}, cell.size()});\r\n        }\r\n    }\r\n\r\n    component.init(cell.size());\r\n    cell_id.resize(cell.size());\r\n    for (auto i : cell) cell_id[i.second] = i.first;\r\n\r\n    if (!validity_check::solution_exists()) {\r\n        // cout << \"NO\\n\";\r\n        printf(\"NO\\n\");\r\n        return 0;\r\n    }\r\n\r\n    // cout << \"YES\\n\";\r\n    printf(\"YES\\n\");\r\n    vector<int> ans = solve::get_solution();\r\n    // for (auto i : ans) cout << i << \"\\n\";\r\n    for (auto i : ans) printf(\"%d\\n\", i);\r\n    return 0;\r\n}\r\n\r\n/*\r\nin:\r\n25\r\n1\r\n0 1\r\n1 0\r\n-1 1\r\n1 -1\r\n0 2\r\n0 3\r\n2 0\r\n3 0\r\n3 -1\r\n3 -2\r\n3 -3\r\n-1 3\r\n-2 3\r\n-3 3\r\n-3 -3\r\n-3 -2\r\n-3 -1\r\n-3 0\r\n-3 1\r\n-3 2\r\n-1 -3\r\n-2 -3\r\n0 -3\r\n1 -3\r\n2 -3\r\n\r\nout:\r\nYES\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n20\r\n19\r\n18\r\n17\r\n16\r\n15\r\n22\r\n21\r\n23\r\n24\r\n25\r\n\r\n*/\r\n"
}