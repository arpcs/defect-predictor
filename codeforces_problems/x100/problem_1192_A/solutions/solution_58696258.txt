{
    "id": 58696258,
    "contestId": 1192,
    "creationTimeSeconds": 1565676505,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Nakagawa.Kanon"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 2262,
    "memoryConsumedBytes": 72396800,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\ntemplate <typename T>\r\nvoid unique(vector<T> &u) {\r\n  sort(u.begin(), u.end());\r\n  u.resize(unique(u.begin(), u.end()) - u.begin());\r\n}\r\n\r\ntemplate <typename T>\r\nvoid debug_out(T t) {\r\n  cerr << t;\r\n}\r\n\r\ntemplate <typename A, typename B>\r\nvoid debug_out(pair<A, B> u) {\r\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\r\n}\r\n\r\ntemplate <typename T>\r\nvoid debug_out(vector<T> t) {\r\n  int sz = t.size();\r\n  for(int i = 0; i < sz; i++) {\r\n    debug_out(t[i]);\r\n    if(i != sz - 1) cerr << \", \";\r\n  }\r\n}\r\n\r\ntemplate <typename T>\r\nvoid debug_out(vector<vector<T>> t) {\r\n  int sz = t.size();\r\n  for(int i = 0; i < sz; i++) {\r\n    debug_out(t[i]);\r\n    if(i != sz - 1) cerr << endl;\r\n  }\r\n}\r\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\r\n\r\n#define range(i, m, n) for(int i = m; i < n; i++)\r\n#define husk(i, m, n) for(int i = m; i > n; i--)\r\n\r\nclass dsu {\r\n public:\r\n   int n;\r\n   vector<vector<int>> in;\r\n   vector<int> to;\r\n   dsu(int _n) {\r\n     n = _n;\r\n     range(i, 0, n) {\r\n       to.push_back(i);\r\n       in.push_back({i});\r\n     }\r\n   }\r\n   void unite(int a, int b) {\r\n     if(to[a] == to[b]) return;\r\n     a = to[a]; b = to[b];\r\n     if(in[a].size() > in[b].size()) swap(a, b);\r\n     for(auto i : in[a]) {\r\n      in[b].push_back(i);\r\n      to[i] = b;\r\n     }\r\n     in[a].clear();\r\n   }\r\n};\r\n\r\nstruct point {\r\n  int x, y, id = -1;\r\n  point(){};\r\n  point(int _x, int _y) : x(_x), y(_y) {};\r\n  bool operator < (const point &a) const {\r\n    return make_pair(id, make_pair(x, y)) > make_pair(a.id, make_pair(a.x, a.y));\r\n  }\r\n  bool operator == (const point &a) const {\r\n    return x == a.x && y == a.y;\r\n  }\r\n};\r\n\r\nvoid debug_out(point a) {\r\n  cerr << \"(\" << a.x << \" \" << a.y << \")\";\r\n}\r\n\r\ntemplate<typename T>\r\nvoid debug_out(set<T> a) {\r\n  vector<T> _a;\r\n  for(auto i : a) _a.push_back(i);\r\n  debug_out(_a);\r\n}\r\n\r\nconst long long inf = 1e15 + 7;\r\n\r\nstruct foo {\r\n  static uint64_t splitmix64(uint64_t x) {\r\n    // http://xorshift.di.unimi.it/splitmix64.c\r\n    x += 0x9e3779b97f4a7c15;\r\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n    return x ^ (x >> 31);\r\n  }\r\n\r\n  size_t operator()(point x) const {\r\n    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n    return splitmix64(1LL * x.x * inf + x.y + FIXED_RANDOM);\r\n  }\r\n\r\n};\r\n\r\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\r\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\r\n\r\npoint sp(point a, int id) {\r\n  return point(a.x + dx[id], a.y + dy[id]);\r\n}\r\n\r\nint n, t;\r\n\r\nint main() {\r\n  scanf(\"%d%d\", &n, &t);\r\n  vector<point> a(n);\r\n  unordered_set<point, foo> cur;\r\n  range(i, 0, n) {\r\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\r\n    a[i].id = i;\r\n    cur.insert(a[i]);\r\n  }\r\n  {\r\n    dsu ss(n);\r\n    for(auto u : a) {\r\n      range(i, 0, 8) {\r\n        point cc = point(u.x + dx[i], u.y + dy[i]);\r\n        if(cur.find(cc) != cur.end()) {\r\n          ss.unite(u.id, cur.find(cc) -> id);\r\n        }\r\n      }\r\n    }\r\n    int mx = 0;\r\n    for(auto i : ss.in) mx = max(mx, (int) i.size());\r\n    if(mx < n) {\r\n      printf(\"NO\");\r\n      return 0;\r\n    }\r\n  }\r\n  printf(\"YES\\n\");\r\n  dsu st(4 * n + 1);\r\n  auto it = max_element(a.begin(), a.end(), [&](point a, point b){return a.y < b.y;});\r\n  st.unite(4 * n, 4 * it -> id);\r\n  unordered_map<point, vector<int>, foo> dog;\r\n  for(auto u : a) {\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(!cur.count(sp(u, i))) dog[sp(u, i)].push_back(4 * u.id + i / 2);\r\n    }\r\n  }\r\n  for(auto u : a) {\r\n    for(int i = 1; i < 8; i += 2) {\r\n      if(!cur.count(sp(u, i)) && !cur.count(sp(u, i - 1)) && !cur.count(sp(u, (i + 1) % 8))) st.unite(dog[sp(u, i - 1)][0], dog[sp(u, (i + 1) % 8)][0]);\r\n    }\r\n  }\r\n  for(auto u : dog) {\r\n    point cc = u.first;\r\n    vector<int> id = u.second;\r\n    for(auto i : id) st.unite(i, id.front());\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(dog.count(sp(cc, i))) st.unite(id[0], dog[sp(cc, i)][0]);\r\n    }\r\n  }\r\n  auto valid = [&] (point v) {\r\n    map<int, vector<int>> cat;\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(cur.find(sp(v, i)) == cur.end()) cat[st.to[v.id * 4 + i / 2]].push_back(i);\r\n    }\r\n    bool ok = false;\r\n    for(auto i : cat) {\r\n      ok |= st.to[i.first] == st.to[4 * n];\r\n    }\r\n    if(!ok) return false;\r\n    vector<int> cc;\r\n    range(i, 0, 8) {\r\n      if(cur.find(sp(v, i)) != cur.end()) cc.push_back(i);\r\n    }\r\n    for(auto u : cat) {\r\n      vector<int> bar = u.second;\r\n      int sz = bar.size();\r\n      set<int> p;\r\n      for(auto i : cc) {\r\n        p.insert((lower_bound(bar.begin(), bar.end(), i) - bar.begin()) % sz);\r\n      }\r\n      if(p.size() > 1) return false;\r\n    }\r\n    return true;\r\n  };\r\n  set<point> pos;\r\n  range(i, 0, n) if(valid(a[i])) pos.insert(a[i]);\r\n  vector<int> res;\r\n  while(pos.size()) {\r\n    res.push_back(pos.begin() -> id);\r\n    point cc = *pos.begin();\r\n    pos.erase(cc);\r\n    cur.erase(cc);\r\n    vector<int> id, _id;\r\n    range(i, 0, 8) {\r\n      if(cur.count(sp(cc, i))) id.push_back(cur.find(sp(cc, i)) -> id);\r\n    }\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(!cur.count(sp(cc, i))) {\r\n        if(st.to[4 * n] != st.to[4 * cc.id + i / 2]) _id.push_back(st.to[4 * cc.id + i / 2]);\r\n      }\r\n    }\r\n    unique(_id);\r\n    for(auto i : _id) {\r\n      for(auto j : st.in[i]) id.push_back(j / 4);\r\n    }\r\n    unique(id);\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(!cur.count(sp(cc, i))) {\r\n        st.unite(4 * cc.id + i / 2, 4 * n);\r\n      }\r\n    }\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(cur.count(sp(cc, i))) {\r\n        point ss = *cur.find(sp(cc, i));\r\n        st.unite(4 * n, 4 * ss.id + ((i + 4) % 8) / 2);\r\n      }\r\n    }\r\n    for(auto i : id) {\r\n      if(cur.count(a[i]) && valid(a[i])) pos.insert(a[i]);\r\n      else pos.erase(a[i]);\r\n    }\r\n  }\r\n  reverse(res.begin(), res.end());\r\n  for(auto i : res) printf(\"%d\\n\", i + 1);\r\n  return 0;\r\n}\r\n"
}