{
    "id": 57762662,
    "contestId": 1192,
    "creationTimeSeconds": 1564080000,
    "relativeTimeSeconds": 16500,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Benq"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 3120,
    "memoryConsumedBytes": 101990400,
    "points": 100.0,
    "source": "#pragma GCC optimize (\"O3\")\r\n#pragma GCC target (\"sse4\")\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/rope>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\nusing namespace __gnu_cxx;\r\n \r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef complex<ld> cd;\r\n\r\ntypedef pair<int, int> pi;\r\ntypedef pair<ll,ll> pl;\r\ntypedef pair<ld,ld> pd;\r\n\r\ntypedef vector<int> vi;\r\ntypedef vector<ld> vd;\r\ntypedef vector<ll> vl;\r\ntypedef vector<pi> vpi;\r\ntypedef vector<pl> vpl;\r\ntypedef vector<cd> vcd;\r\n\r\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\r\n\r\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\r\n#define F0R(i, a) for (int i = 0; i < (a); i++)\r\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\r\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\r\n#define trav(a, x) for (auto& a : x)\r\n\r\n#define mp make_pair\r\n#define pb push_back\r\n#define f first\r\n#define s second\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n\r\n#define sz(x) (int)x.size()\r\n#define all(x) begin(x), end(x)\r\n#define rsz resize\r\n\r\nconst int MOD = 1000000007; // 998244353\r\nconst ll INF = 1e18;\r\nconst int MX = 150005;\r\nconst ld PI = 4*atan((ld)1);\r\n\r\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\r\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\r\n\r\nnamespace input {\r\n    template<class T> void re(complex<T>& x);\r\n    template<class T1, class T2> void re(pair<T1,T2>& p);\r\n    template<class T> void re(vector<T>& a);\r\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\r\n\r\n    template<class T> void re(T& x) { cin >> x; }\r\n    void re(double& x) { string t; re(t); x = stod(t); }\r\n    void re(ld& x) { string t; re(t); x = stold(t); }\r\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \r\n        re(first); re(rest...); \r\n    }\r\n\r\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\r\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\r\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\r\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\r\n}\r\n\r\nusing namespace input;\r\n\r\nnamespace output {\r\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\r\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\r\n    template<class T> void pr(const vector<T>& x);\r\n    template<class T> void pr(const set<T>& x);\r\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\r\n\r\n    template<class T> void pr(const T& x) { cout << x; }\r\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \r\n        pr(first); pr(rest...); \r\n    }\r\n\r\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \r\n        pr(\"{\",x.f,\", \",x.s,\"}\"); \r\n    }\r\n    template<class T> void prContain(const T& x) {\r\n        pr(\"{\");\r\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\r\n        pr(\"}\");\r\n    }\r\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\r\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\r\n    template<class T> void pr(const set<T>& x) { prContain(x); }\r\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\r\n    \r\n    void ps() { pr(\"\\n\"); }\r\n    template<class Arg> void ps(const Arg& first) { \r\n        pr(first); ps(); // no space at end of line\r\n    }\r\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \r\n        pr(first,\" \"); ps(rest...); // print w/ spaces\r\n    }\r\n}\r\n\r\nusing namespace output;\r\n\r\nnamespace io {\r\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\r\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\r\n    void setIO(string s = \"\") {\r\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\r\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\r\n    }\r\n}\r\n\r\nusing namespace io;\r\n\r\ntemplate<class T> T invGeneral(T a, T b) {\r\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\r\n    T x = invGeneral(b,a); \r\n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\r\n}\r\n\r\ntemplate<class T> struct modular {\r\n    T val; \r\n    explicit operator T() const { return val; }\r\n    modular() { val = 0; }\r\n    modular(const ll& v) { \r\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\r\n        if (val < 0) val += MOD;\r\n    }\r\n    \r\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\r\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\r\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\r\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\r\n\r\n    modular operator-() const { return modular(-val); }\r\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\r\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\r\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\r\n    friend modular pow(modular a, ll p) {\r\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\r\n        return ans;\r\n    }\r\n    friend modular inv(const modular& a) { \r\n        auto i = invGeneral(a.val,MOD); assert(i != -1);\r\n        return i;\r\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\r\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\r\n    \r\n    friend modular operator+(modular a, const modular& b) { return a += b; }\r\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\r\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\r\n    \r\n    friend modular operator/(modular a, const modular& b) { return a /= b; }\r\n};\r\n\r\ntypedef modular<int> mi;\r\ntypedef pair<mi,mi> pmi;\r\ntypedef vector<mi> vmi;\r\ntypedef vector<pmi> vpmi;\r\n\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nmap<pi,int> mm;\r\nmap<int,int> adjbc[MX];\r\n\r\ntemplate<int SZ> struct BCC {\r\n    int N;\r\n    vi adj[SZ];\r\n    vector<vpi> fin;\r\n\r\n    void addEdge(int u, int v) { adj[u].pb(v), adj[v].pb(u); }\r\n\r\n    int ti = 0, disc[SZ], low[SZ], comp[SZ], par[SZ];\r\n    vpi st;\r\n\r\n    void BCCutil(int u, bool root = 0) {\r\n        disc[u] = low[u] = ti++;\r\n        int child = 0;\r\n\r\n        trav(i,adj[u]) if (i != par[u])\r\n            if (disc[i] == -1) {\r\n                child ++; par[i] = u;\r\n                st.pb({u,i});\r\n                BCCutil(i);\r\n                low[u] = min(low[u],low[i]);\r\n\r\n                // disc[u] < low[i]: bridge\r\n                if ((root && child > 1) || (!root && disc[u] <= low[i])) { // articulation point!\r\n                    vpi tmp;\r\n                    while (st.back() != mp(u,i)) tmp.pb(st.back()), st.pop_back();\r\n                    tmp.pb(st.back()), st.pop_back();\r\n                    fin.pb(tmp);\r\n                }\r\n            } else if (disc[i] < disc[u]) {\r\n                low[u] = min(low[u],disc[i]);\r\n                st.pb({u,i});\r\n            }\r\n    }\r\n\r\n    void bcc(int _N) {\r\n        N = _N;\r\n        F0R(i,N) {\r\n        \tsort(all(adj[i]));\r\n        \tadj[i].erase(unique(all(adj[i])),adj[i].end());\r\n        }\r\n        F0R(i,N) par[i] = disc[i] = low[i] = -1;\r\n        F0R(i,N) if (disc[i] == -1) {\r\n            BCCutil(i,1);\r\n            if (sz(st)) fin.pb(st);\r\n            st.clear();\r\n        }\r\n        int co = 0;\r\n        trav(a,fin) {\r\n        \t// ps(a);\r\n        \ttrav(b,a) mm[b] = mm[{b.s,b.f}] = co;\r\n        \tco ++;\r\n        }\r\n        F0R(i,N) trav(t,adj[i]) adjbc[i][mm[{i,t}]] ++;\r\n        // exit(0);\r\n    }\r\n};\r\n\r\nBCC<MX> B;\r\nconst int xd[8] = {0,1,1,1,0,-1,-1,-1}, yd[8] = {1,1,0,-1,-1,-1,0,1};\r\n\r\nint n,t;\r\nmap<pi,int> m;\r\nvi sol;\r\nvpi v;\r\nset<pi> cur;\r\nset<int> OK;\r\nint cnt[MX];\r\nbool vis[MX];\r\n\r\npi nex(pi a, int b) {\r\n\treturn {a.f+xd[b],a.s+yd[b]};\r\n}\r\n\r\nbool ok(int ind, int b) {\r\n\tpi x = nex(v[ind],b);\r\n\treturn m.count(x);\r\n}\r\n\r\nvoid good(int x) {\r\n\t// return;\r\n\tif (OK.count(x)) OK.erase(x);\r\n\t//ps(\"HA\",x);\r\n\tif (sz(adjbc[x]) != 1) return;\r\n\tif (cnt[x] != 1) return;\r\n\tOK.insert(x);\r\n}\r\n\r\nvoid rem(int ind, int x) {\r\n\tcur.erase({ind,x}); \r\n\tcnt[ind] --;\r\n\tgood(ind);\r\n}\r\n\r\nvoid ins(int ind, int x) {\r\n\tcur.insert({ind,x}); \r\n\tcnt[ind] ++;\r\n\tgood(ind);\r\n}\r\n\r\nint zz = 0;\r\n\r\nvoid fin() {\r\n\tif (sz(sol) != n) {\r\n\t\tps(\"??\",zz,sz(sol),n);\r\n        ps(v);\r\n        ps(sol);\r\n        ps(sz(m));\r\n        ps(m);\r\n        ps(cur);\r\n\t\texit(0);\r\n\t}\r\n    ps(\"YES\");\r\n    reverse(all(sol));\r\n    trav(t,sol) ps(t+1);\r\n}\r\n\r\nvoid gen(int ind, int x) {\r\n\tint num = 0;\r\n\twhile (!ok(ind,x) && num < 8) {\r\n\t\tx = (x+1)%8;\r\n\t\tnum ++;\r\n\t}\r\n\tif (num == 8) fin();\r\n\tif (cur.count({ind,x})) return;\r\n\tins(ind,x);\r\n\tgen(m[nex(v[ind],x)],(x+5)%8);\r\n}\r\n\r\nbool testImpossible() {\r\n\tF0R(i,n) vis[i] = 0;\r\n\tqueue<int> q; q.push(0); vis[0] = 1;\r\n\twhile (sz(q)) {\r\n\t\tauto a = q.front(); q.pop();\r\n\t\tFOR(i,-1,2) FOR(j,-1,2) {\r\n\t\t\tpi b = {v[a].f+i,v[a].s+j};\r\n\t\t\tif (m.count(b) && !vis[m[b]]) {\r\n\t\t\t\tvis[m[b]] = 1;\r\n\t\t\t\tq.push(m[b]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tF0R(t,n)\r\n\t\tFOR(i,-1,2) FOR(j,-1,2) {\r\n\t\t\tif (mp(i,j) <= mp(0,0)) continue;\r\n\t\t\tpi z = {v[t].f+i,v[t].s+j};\r\n\t\t\tif (m.count(z)) B.addEdge(t,m[z]);\r\n\t\t}\r\n\tF0R(i,n) if (!vis[i]) {\r\n\t\tps(\"NO\");\r\n\t\treturn 1;\r\n\t}\r\n\tB.bcc(n);\r\n\t// exit(0);\r\n\treturn 0;\r\n} \r\n\r\nconst int DIM = 6;\r\n\r\nvoid solve() {\r\n\tzz ++; if (zz%1000 == 0) cerr << \"DOING \" << zz << \"\\n\";\r\n\t// n = rand()%(DIM*DIM)+1; t = 2;\r\n\tre(n,t);\r\n\tvpi V; F0R(i,DIM) F0R(j,DIM) V.pb({i,j});\r\n\trandom_shuffle(all(V));\r\n\tv = V; \r\n    // if (zz <= 74) return;\r\n\tv.rsz(n); re(v);\r\n\tm.clear(); sol.clear(); cur.clear();\r\n\tOK.clear();\r\n\tF0R(i,n) cnt[i] = 0;\r\n    F0R(i,n) m[v[i]] = i;\r\n    if (n == 1) {\r\n    \tsol.pb(0);\r\n    \tfin();\r\n        return;\r\n    }\r\n    if (testImpossible()) return;\r\n    /*if (zz == 75) {\r\n        ps(\"HA\",v,sz(v),n);\r\n        exit(0);\r\n    }*/\r\n    int ind = 0; FOR(i,1,sz(v)) if (v[i] < v[ind]) ind = i;\r\n    gen(ind,0);\r\n    // F0R(i,n) ps(\"??\",i,sz(adjbc[i]),cnt[i]);\r\n    //ps(OK);\r\n    //exit(0);\r\n    // exit(0);\r\n    F0R(i,n) {\r\n    \tif (i == n-2) {\r\n    \t\tif (sz(OK) != 2) fin();\r\n    \t\tsol.pb(*OK.rbegin());\r\n    \t\tsol.pb(*OK.begin());\r\n    \t\tfin();\r\n    \t\treturn;\r\n    \t} else {\r\n    \t\tif (!sz(OK)) fin();\r\n    \t\tint x = *OK.rbegin();\r\n    \t\t// ps(\"HA\",OK,x); exit(0);\r\n    \t\tint z = 0, Z = 0; while (!cur.count({x,z})) z ++;\r\n    \t\twhile (1) {\r\n    \t\t\tpi t = {v[x].f-xd[Z],v[x].s-yd[Z]};\r\n    \t\t\tif (m.count(t) && cur.count({m[t],Z})) break;\r\n    \t\t\tZ ++;\r\n    \t\t}\r\n    \t\tpi t = {v[x].f-xd[Z],v[x].s-yd[Z]};\r\n    \t\tpi pre = {m[t],Z};\r\n            // if (zz == 40404) ps(\"HUH\",x,v[x]);\r\n            m.erase(v[x]); \r\n    \t\trem(x,z); rem(pre.f,pre.s); sol.pb(x);\r\n    \t\tgen(pre.f,pre.s);\r\n    \t\tFOR(i,-1,2) FOR(j,-1,2) {\r\n    \t\t\tpi t = {v[x].f+i,v[x].s+j};\r\n    \t\t\tif (m.count(t)) {\r\n    \t\t\t\tint w = m[t];\r\n    \t\t\t\tint label = mm[{x,w}];\r\n    \t\t\t\tadjbc[w][label] --; if (adjbc[w][label] == 0) adjbc[w].erase(label);\r\n    \t\t\t\tadjbc[x][label] --; if (adjbc[x][label] == 0) adjbc[x].erase(label);\r\n    \t\t\t\tgood(w);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tif (OK.count(x)) OK.erase(x);\r\n    \t} \r\n        if (zz == 40404) {\r\n            ps(i);\r\n            ps(cur);\r\n            ps(m);\r\n            ps();\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    //setIO(\"AA\"); \r\n    F0R(i,1) solve();\r\n}\r\n\r\n/* stuff you should look for\r\n    * int overflow, array bounds\r\n    * special cases (n=1?), set tle\r\n    * do smth instead of nothing and stay organized\r\n*/"
}