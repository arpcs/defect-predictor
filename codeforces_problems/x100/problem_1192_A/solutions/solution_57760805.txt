{
    "id": 57760805,
    "contestId": 1192,
    "creationTimeSeconds": 1564077371,
    "relativeTimeSeconds": 13871,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "mnbvmar"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 1450,
    "memoryConsumedBytes": 48332800,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing ll = long long;\nusing vi = vector<int>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vll = vector<ll>;\nusing ld = long double;\n\nconst int kMaxN = 2e5;\nconst int kMaxVert = 5e5;\nconst int M = 1.02e9;\n\nconst int dr[] = {-1, -1, -1, 0, 1, 1,  1,  0};\nconst int dc[] = {-1,  0,  1, 1, 1, 0, -1, -1};\nmap<int, vector<tuple<int, int, int>>> intvs;\nconst int kNumDirs = 8;\n\nvector<pii> cells;\nmap<pii, int> cell_mapping;\nbool vis[kMaxN];\nvi adj[kMaxVert];\n\nint fu_parent[kMaxVert];\n//~ vi fu_elems[kMaxVert];\n\nint n;\nint outside_vert;\nset<int> avail_verts;\nset<int> quarantine_verts;\nvector<bool> is_free;\n\nint FuFind(int v) {\n  if (v == fu_parent[v]) { return v; }\n  return fu_parent[v] = FuFind(fu_parent[v]);\n}\n\nvoid FuUnion(int a, int b) {\n  a = FuFind(a); b = FuFind(b);\n  if (a == b) { return; }\n  fu_parent[a] = b;\n  //~ if (SZ(fu_elems[a]) > SZ(fu_elems[b])) { swap(a, b); }\n  \n  //~ for (int x : {a, b}) {\n    //~ if (x == FuFind(outside_vert)) {\n      //~ const int y = x ^ a ^ b;\n      //~ for (int s : fu_elems[y]) {\n        //~ avail_verts.insert(s);\n      //~ }\n    //~ }\n  //~ }\n  \n  //~ fu_parent[a] = b;\n  //~ for (int x : fu_elems[a]) {\n    //~ fu_elems[b].PB(x);\n  //~ }\n  //~ fu_elems[a].clear();\n}\n\nint GetByID(int r, int c) {\n  auto &I = intvs[c];\n  assert(!I.empty());\n  auto iter = prev(upper_bound(ALL(I),\n      tuple<int,int,int>(r, M + 100, -1)));\n  return get<2>(*iter);\n}\n\nbool MakesDisconnected(int v) {\n  assert(v < n);\n  bool is_adj[10];\n  memset(is_adj, 0, sizeof(is_adj));\n  \n  for (int i = 0; i < 8; ++i) {\n    const int nr = cells[v].st + dr[i];\n    const int nc = cells[v].nd + dc[i];\n    //~ debug(v, nr, nc);\n    const pii np{nr, nc};\n    auto iter = cell_mapping.find(np);\n    if (iter == cell_mapping.end()) { continue; }\n    const int s = iter->nd;\n    is_adj[i] = !is_free[s];\n  }\n  \n  set<int> comp_ids;\n  for (int i = 0; i < 8; ++i) {\n    const int j = (i + 1) % 8;\n    if (is_adj[i] && !is_adj[j]) {\n      if (j % 2 == 0 && is_adj[j + 1]) { continue; }\n      debug(v, i, j);\n      const int nr = cells[v].st + dr[j];\n      const int nc = cells[v].nd + dc[j];\n      const int cid = FuFind(GetByID(nr, nc));\n      if (comp_ids.count(cid)) { return true; }\n      comp_ids.insert(cid);\n    }\n  }\n  return false;\n}\n\n\ninline void AddEdge(int u, int v) {\n  debug(u, v);\n  adj[u].PB(v); adj[v].PB(u);\n}\n\nvoid Dfs(int v) {\n  vis[v] = true;\n  for (int i = 0; i < kNumDirs; ++i) {\n    const int nr = cells[v].st + dr[i];\n    const int nc = cells[v].nd + dc[i];\n    const pii np{nr, nc};\n    auto iter = cell_mapping.find(np);\n    if (iter != cell_mapping.end()) {\n      const int s = iter->nd;\n      if (!vis[s]) { Dfs(s); }\n    }\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  \n  int tidx;\n  cin >> n >> tidx;\n  cells.resize(n);\n  for (auto &[r, c] : cells) { cin >> r >> c; }\n  for (int i = 0; i < n; ++i) {\n    cell_mapping[cells[i]] = i;\n  }\n  \n  Dfs(0);\n  for (int i = 0; i < n; ++i) {\n    if (!vis[i]) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  \n  int min_c = M, max_c = -M;\n  map<int, vector<pii>> cell_cols;\n  for (int i = 0; i < n; ++i) {\n    mini(min_c, cells[i].nd);\n    maxi(max_c, cells[i].nd);\n    cell_cols[cells[i].nd].emplace_back(cells[i].st, i);\n  }\n  \n  assert(max_c - min_c <= n);\n  \n  int cur_id = n;\n  \n  for (int col = min_c; col <= max_c; ++col) {\n    vector<pii> rows = cell_cols[col];\n    assert(!rows.empty());\n    sort(ALL(rows));\n    \n    int last_r = -M;\n    \n    for (auto &&[r, idx] : rows) {\n      if (last_r < r - 1) {\n        intvs[col].emplace_back(last_r + 1, r, cur_id++);\n      }\n      intvs[col].emplace_back(r, r + 1, idx);\n      last_r = r;\n    }\n    intvs[col].emplace_back(last_r + 1, M, cur_id++);\n  }\n  \n  intvs[min_c - 1].emplace_back(-M, M, cur_id++);\n  intvs[max_c + 1].emplace_back(-M, M, cur_id++);\n  const int nverts = cur_id;\n  \n  for (int col = min_c; col <= max_c; ++col) {\n    const auto &I = intvs[col];\n    const int sz = SZ(I);\n    for (int i = 1; i < sz; ++i) {\n      AddEdge(get<2>(I[i - 1]), get<2>(I[i]));\n    }\n  }\n  \n  for (int col = min_c; col <= max_c + 1; ++col) {\n    int aptr = 0, bptr = 0;\n    const auto &A = intvs[col - 1];\n    const auto &B = intvs[col];\n    while (aptr < SZ(A) && bptr < SZ(B)) {\n      const auto [al, ar, aidx] = A[aptr];\n      const auto [bl, br, bidx] = B[bptr];\n      if (ar <= bl) { ++aptr; continue; }\n      if (br <= al) { ++bptr; continue; }\n      AddEdge(aidx, bidx);\n      if (ar < br) { ++aptr; } else { ++bptr; }\n    }\n  }\n  \n  debug(nverts);\n  outside_vert = nverts - 1;\n  iota(fu_parent, fu_parent + nverts, 0);\n  //~ for (int i = 0; i < nverts; ++i) {\n    //~ fu_elems[i].PB(i);\n  //~ }\n  for (int i = n; i < nverts; ++i) {\n    for (int j : adj[i]) {\n      if (j > i) {\n        FuUnion(i, j);\n      }\n    }\n  }\n  \n  vector<bool> is_deleted(nverts);\n  avail_verts.insert(outside_vert);\n  \n  is_free.resize(nverts);\n  for (int i = n; i < nverts; ++i) {\n    is_free[i] = true;\n  }\n  \n  vi answer;\n  while (SZ(answer) < n) {\n    if (avail_verts.empty()) {\n      debug(answer);\n      debug(vi(ALL(quarantine_verts)));\n    }\n    assert(!avail_verts.empty());\n    const int v = *avail_verts.rbegin();\n    avail_verts.erase(v);\n    debug(v);\n    \n    if (v < n && MakesDisconnected(v)) {\n      quarantine_verts.insert(v);\n      continue;\n    } else {\n      is_free[v] = is_deleted[v] = true;\n      if (v < n) { answer.PB(v); }\n      for (int s : adj[v]) {\n        if (!is_deleted[s]) { avail_verts.insert(s); }\n        quarantine_verts.erase(s);\n        if (is_free[s]) {\n          FuUnion(v, s);\n        }\n      }\n      \n      if (v < n) {\n        for (int ddr : {-1, 1}) {\n          for (int ddc : {-1, 1}) {\n            bool any_free = false;\n            const int nrow = GetByID(cells[v].st + ddr, cells[v].nd);\n            any_free |= is_free[nrow];\n            const int ncol = GetByID(cells[v].st, cells[v].nd + ddc);\n            any_free |= is_free[ncol];\n            if (!any_free) { continue; }\n            \n            pii np{cells[v].st + ddr, cells[v].nd + ddc};\n            auto iter = cell_mapping.find(np);\n            if (iter != cell_mapping.end()) {\n              const int s = iter->nd;\n              if (!is_deleted[s]) {\n                avail_verts.insert(s); quarantine_verts.erase(s);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  reverse(ALL(answer));\n  cout << \"YES\\n\";\n  for (int x : answer) { cout << x + 1 << \"\\n\"; }\n}\n"
}