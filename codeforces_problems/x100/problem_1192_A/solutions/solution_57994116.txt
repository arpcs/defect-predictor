{
    "id": 57994116,
    "contestId": 1192,
    "creationTimeSeconds": 1564496576,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Nishihara"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 3010,
    "memoryConsumedBytes": 50790400,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\ntemplate <typename T>\r\nvoid unique(vector<T> &u) {\r\n  sort(u.begin(), u.end());\r\n  u.resize(unique(u.begin(), u.end()) - u.begin());\r\n}\r\n\r\n#define range(i, m, n) for(int i = m; i < n; i++)\r\n#define husk(i, m, n) for(int i = m; i > n; i--)\r\n\r\ntemplate <typename T>\r\nvoid debug_out(T t) {\r\n  cerr << t;\r\n}\r\n\r\ntemplate <typename A, typename B>\r\nvoid debug_out(pair<A, B> u) {\r\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\r\n}\r\n\r\ntemplate <typename T>\r\nvoid debug_out(vector<T> t) {\r\n  int sz = t.size();\r\n  for(int i = 0; i < sz; i++) {\r\n    debug_out(t[i]);\r\n    if(i != sz - 1) cerr << \", \";\r\n  }\r\n}\r\n\r\ntemplate <typename T>\r\nvoid debug_out(vector<vector<T>> t) {\r\n  int sz = t.size();\r\n  for(int i = 0; i < sz; i++) {\r\n    debug_out(t[i]);\r\n    if(i != sz - 1) cerr << endl;\r\n  }\r\n}\r\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\r\n\r\n\r\nclass dsu {\r\n public:\r\n  vector<int> p;\r\n  int n;\r\n\r\n  dsu(int _n) : n(_n) {\r\n    p.resize(n);\r\n    iota(p.begin(), p.end(), 0);\r\n  }\r\n\r\n  inline int get(int x) {\r\n    return (x == p[x] ? x : (p[x] = get(p[x])));\r\n  }\r\n\r\n  inline bool unite(int x, int y) {\r\n    x = get(x);\r\n    y = get(y);\r\n    if (x != y) {\r\n      p[x] = y;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n};\r\n\r\nstruct point {\r\n  int x, y, id = -1;\r\n  point(){};\r\n  point(int _x, int _y) : x(_x), y(_y) {};\r\n  bool operator < (const point &a) const {\r\n    return id > a.id;\r\n  }\r\n  bool operator == (const point &a) const {\r\n    return x == a.x && y == a.y;\r\n  }\r\n};\r\n\r\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\r\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\r\n\r\npoint sp(point a, int id) {\r\n  return point(a.x + dx[id], a.y + dy[id]);\r\n}\r\n\r\nlong long dis(point a) {\r\n  return 1LL * a.x * INT_MAX + a.y;\r\n}\r\n\r\nint n, t;\r\n\r\nint main() {\r\n  scanf(\"%d%d\", &n, &t);\r\n  vector<point> a(n);\r\n  range(i, 0, n) {\r\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\r\n    a[i].id = i;\r\n  }\r\n  sort(a.begin(), a.end(), [&](point u, point v){return make_pair(u.x, u.y) < make_pair(v.x, v.y);});\r\n  vector<vector<int>> edges(n, vector<int>(8, -1));\r\n  dsu ss(n);\r\n  int l = 0, r = 0;\r\n  range(i, 0, n) {\r\n    if(i < n - 1 && a[i].x == a[i + 1].x && a[i].y == a[i + 1].y - 1) {\r\n      edges[a[i].id][0] = a[i + 1].id;\r\n      edges[a[i + 1].id][4] = a[i].id;\r\n      ss.unite(a[i].id, a[i + 1].id);\r\n    }\r\n    while(r < n && make_pair(a[r].x, a[r].y) <= make_pair(a[i].x + 1, a[i].y + 1)) r++;\r\n    while(l < n && make_pair(a[l].x, a[l].y) < make_pair(a[i].x + 1, a[i].y - 1)) l++;\r\n    range(j, l, r) {\r\n      int dif = a[j].y - a[i].y;\r\n      int id;\r\n      if(!dif) id = 2;\r\n      else id = (dif > 0 ? 1 : 3);\r\n      edges[a[i].id][id] = a[j].id;\r\n      edges[a[j].id][(id + 4) % 8] = a[i].id;\r\n      ss.unite(a[i].id, a[j].id);\r\n    }\r\n  }\r\n  range(i, 0, n) if(ss.get(i) != ss.get(0)) {\r\n    printf(\"NO\");\r\n    return 0;\r\n  }\r\n  sort(a.begin(), a.end());\r\n  reverse(a.begin(), a.end());\r\n  printf(\"YES\\n\");\r\n  dsu st(4 * n + 1);\r\n  auto it = max_element(a.begin(), a.end(), [&](point a, point b){return a.y < b.y;});\r\n  st.unite(4 * n, 4 * it -> id);\r\n  unordered_map<long long, vector<int>> dog;\r\n  for(auto u : a) {\r\n    for(int i = 0; i < 8; i += 2) {\r\n      int v = edges[u.id][i];\r\n      if(v == -1) dog[dis(sp(u, i))].push_back(4 * u.id + i / 2);\r\n    }\r\n  }\r\n  for(auto u : a) {\r\n    vector<int> xs(8);\r\n    range(i, 0, 8) xs[i] = edges[u.id][i] >= 0;\r\n    for(int i = 1; i < 8; i += 2) {\r\n      if(!xs[i] && !xs[i - 1] && !xs[(i + 1) % 8]) st.unite(4 * u.id + i / 2, 4 * u.id + ((i + 1) % 8) / 2);\r\n    }\r\n  }\r\n  for(auto u : dog) {\r\n    point cc = point(u.first / INT_MAX, u.first % INT_MAX);\r\n    vector<int> id = u.second;\r\n    for(auto i : id) st.unite(i, id.front());\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(dog.count(dis(sp(cc, i)))) st.unite(id[0], dog[dis(sp(cc, i))][0]);\r\n    }\r\n  }\r\n  vector<int> alive(n, 1);\r\n  int iter = 0;\r\n  vector<int> pp(4 * n + 1);\r\n  auto valid = [&] (point v) {\r\n    iter++;\r\n    bool ok = false;\r\n    range(i, 0, 8) {\r\n      if(~edges[v.id][i] && alive[edges[v.id][i]]) {\r\n        int xs = 8;\r\n        i++;\r\n        if(i == 8) i = 0;\r\n        vector<int> pc;\r\n        while(xs--) {\r\n          if(~edges[v.id][i] && alive[edges[v.id][i]]) {\r\n            for(auto j : pc) {\r\n              if(pp[j] == iter) return false;\r\n            }\r\n            for(auto j : pc) pp[j] = iter;\r\n            pc.clear();\r\n          } else if(i % 2 == 0) {\r\n            pc.push_back(st.get(4 * v.id + i / 2));\r\n            ok |= st.get(4 * v.id + i / 2) == st.get(4 * n);\r\n          }\r\n          i++;\r\n          if(i == 8) i = 0;\r\n        }\r\n        break;\r\n      }\r\n      ok |= i == 7;\r\n    }\r\n    return ok;\r\n  };\r\n  set<point> pos;\r\n  range(i, 0, n) if(valid(a[i])) pos.insert(a[i]);\r\n  vector<vector<int>> in(4 * n + 1);\r\n  range(i, 0, 4 * n + 1) in[st.get(i)].push_back(i);\r\n  vector<int> res;\r\n  int cnt = 0;\r\n  vector<int> ap(n);\r\n  while(pos.size()) {\r\n    cnt++;\r\n    res.push_back(pos.begin() -> id);\r\n    point cc = *pos.begin();\r\n    pos.erase(pos.begin());\r\n    alive[cc.id] = 0;\r\n    vector<int> id, _id;\r\n    range(i, 0, 8) {\r\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) id.push_back(edges[cc.id][i]);\r\n    }\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\r\n        if(st.get(4 * n) != st.get(4 * cc.id + i / 2)) _id.push_back(st.get(4 * cc.id + i / 2));\r\n      }\r\n    }\r\n    unique(_id);\r\n    for(auto i : _id) {\r\n      for(auto j : in[i]) id.push_back(j / 4);\r\n    }\r\n    unique(id);\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(edges[cc.id][i] == -1 || !alive[edges[cc.id][i]]) {\r\n        st.unite(4 * cc.id + i / 2, 4 * n);\r\n      }\r\n    }\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(~edges[cc.id][i] && alive[edges[cc.id][i]]) {\r\n        int v = edges[cc.id][i];\r\n        st.unite(4 * v + ((i + 4) % 8) / 2, 4 * n);\r\n      }\r\n    }\r\n    for(auto i : id) {\r\n      if(ap[i] == cnt) continue;\r\n      ap[i] = cnt;\r\n      if(alive[i] && valid(a[i])) pos.insert(a[i]);\r\n      else pos.erase(a[i]);\r\n    }\r\n  }\r\n  reverse(res.begin(), res.end());\r\n  for(auto i : res) printf(\"%d\\n\", i + 1);\r\n  return 0;\r\n}\r\n"
}