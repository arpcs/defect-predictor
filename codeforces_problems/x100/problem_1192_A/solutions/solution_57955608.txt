{
    "id": 57955608,
    "contestId": 1192,
    "creationTimeSeconds": 1564425189,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Nishihara"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "points": 0.0,
    "source": "#include <bits/stdc++.h>\r\n \r\nusing namespace std;\r\n \r\ntemplate <typename T>\r\nvoid unique(vector<T> &u) {\r\n  sort(u.begin(), u.end());\r\n  u.resize(unique(u.begin(), u.end()) - u.begin());\r\n}\r\n \r\ntemplate <typename T>\r\nvoid debug_out(T t) {\r\n  cerr << t;\r\n}\r\n \r\ntemplate <typename A, typename B>\r\nvoid debug_out(pair<A, B> u) {\r\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\r\n}\r\n \r\ntemplate <typename T>\r\nvoid debug_out(vector<T> t) {\r\n  int sz = t.size();\r\n  for(int i = 0; i < sz; i++) {\r\n    debug_out(t[i]);\r\n    if(i != sz - 1) cerr << \", \";\r\n  }\r\n}\r\n \r\ntemplate <typename T>\r\nvoid debug_out(vector<vector<T>> t) {\r\n  int sz = t.size();\r\n  for(int i = 0; i < sz; i++) {\r\n    debug_out(t[i]);\r\n    if(i != sz - 1) cerr << endl;\r\n  }\r\n}\r\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\r\n \r\n#define range(i, m, n) for(int i = m; i < n; i++)\r\n#define husk(i, m, n) for(int i = m; i > n; i--)\r\n \r\nclass dsu {\r\n public:\r\n  vector<int> p;\r\n  int n;\r\n \r\n  dsu(int _n) : n(_n) {\r\n    p.resize(n);\r\n    iota(p.begin(), p.end(), 0);\r\n  }\r\n \r\n  inline int get(int x) {\r\n    return (x == p[x] ? x : (p[x] = get(p[x])));\r\n  }\r\n \r\n  inline bool unite(int x, int y) {\r\n    x = get(x);\r\n    y = get(y);\r\n    if (x != y) {\r\n      p[x] = y;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n};\r\n \r\nstruct point {\r\n  int x, y, id = -1;\r\n  point(){};\r\n  point(int _x, int _y) : x(_x), y(_y) {};\r\n  bool operator < (const point &a) const {\r\n    return make_pair(id, make_pair(x, y)) > make_pair(a.id, make_pair(a.x, a.y));\r\n  }\r\n  bool operator == (const point &a) const {\r\n    return x == a.x && y == a.y;\r\n  }\r\n};\r\n \r\nvoid debug_out(point a) {\r\n  cerr << \"(\" << a.x << \" \" << a.y << \")\";\r\n}\r\n \r\ntemplate<typename T>\r\nvoid debug_out(set<T> a) {\r\n  vector<T> _a;\r\n  for(auto i : a) _a.push_back(i);\r\n  debug_out(_a);\r\n}\r\n \r\nclass foo {\r\n  public:;\r\n  long long operator()(const point &a) const {\r\n    return 1LL * a.x * INT_MAX + a.y;\r\n  }\r\n};\r\n \r\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\r\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\r\n \r\npoint sp(point a, int id) {\r\n  return point(a.x + dx[id], a.y + dy[id]);\r\n}\r\n \r\nint n, t;\r\n \r\nint main() {\r\n  scanf(\"%d%d\", &n, &t);\r\n  vector<point> a(n);\r\n  unordered_set<point, foo> cur;\r\n  range(i, 0, n) {\r\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\r\n    a[i].id = i;\r\n    cur.insert(a[i]);\r\n  }\r\n  {\r\n    dsu ss(n);\r\n    for(auto u : a) {\r\n      range(i, 0, 8) {\r\n        point cc = point(u.x + dx[i], u.y + dy[i]);\r\n        if(cur.find(cc) != cur.end()) {\r\n          ss.unite(u.id, cur.find(cc) -> id);\r\n        }\r\n      }\r\n    }\r\n    set<int> mx;\r\n    range(i, 0, n) mx.insert(ss.get(i));\r\n    if((int) mx.size() > 1) {\r\n      printf(\"NO\");\r\n      return 0;\r\n    }\r\n  }\r\n  printf(\"YES\\n\");\r\n  dsu st(4 * n + 1);\r\n  auto it = max_element(a.begin(), a.end(), [&](point a, point b){return a.y < b.y;});\r\n  st.unite(4 * n, 4 * it -> id);\r\n  unordered_map<point, vector<int>, foo> dog;\r\n  for(auto u : a) {\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(!cur.count(sp(u, i))) dog[sp(u, i)].push_back(4 * u.id + i / 2);\r\n    }\r\n  }\r\n  for(auto u : a) {\r\n    for(int i = 1; i < 8; i += 2) {\r\n      if(!cur.count(sp(u, i)) && !cur.count(sp(u, i - 1)) && !cur.count(sp(u, (i + 1) % 8))) st.unite(dog[sp(u, i - 1)][0], dog[sp(u, (i + 1) % 8)][0]);\r\n    }\r\n  }\r\n  for(auto u : dog) {\r\n    point cc = u.first;\r\n    vector<int> id = u.second;\r\n    for(auto i : id) st.unite(i, id.front());\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(dog.count(sp(cc, i))) st.unite(id[0], dog[sp(cc, i)][0]);\r\n    }\r\n  }\r\n  auto valid = [&] (point v) {\r\n    map<int, vector<int>> cat;\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(cur.find(sp(v, i)) == cur.end()) cat[st.get(v.id * 4 + i / 2)].push_back(i);\r\n    }\r\n    bool ok = false;\r\n    for(auto i : cat) {\r\n      ok |= i.first == st.get(4 * n);\r\n    }\r\n    if(!ok) return false;\r\n    vector<int> cc;\r\n    range(i, 0, 8) {\r\n      if(cur.find(sp(v, i)) != cur.end()) cc.push_back(i);\r\n    }\r\n    for(auto u : cat) {\r\n      vector<int> bar = u.second;\r\n      int sz = bar.size();\r\n      set<int> p;\r\n      for(auto i : cc) {\r\n        p.insert((lower_bound(bar.begin(), bar.end(), i) - bar.begin()) % sz);\r\n      }\r\n      if(p.size() > 1) return false;\r\n    }\r\n    return true;\r\n  };\r\n  unorderd_set<point> pos;\r\n  range(i, 0, n) if(valid(a[i])) pos.insert(a[i]);\r\n  vector<vector<int>> in(4 * n + 1);\r\n  range(i, 0, 4 * n + 1) in[st.get(i)].push_back(i);\r\n  vector<int> res;\r\n  while(pos.size()) {\r\n    res.push_back(pos.begin() -> id);\r\n    point cc = *pos.begin();\r\n    pos.erase(cc);\r\n    cur.erase(cc);\r\n    vector<int> id, _id;\r\n    range(i, 0, 8) {\r\n      if(cur.count(sp(cc, i))) id.push_back(cur.find(sp(cc, i)) -> id);\r\n    }\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(!cur.count(sp(cc, i))) {\r\n        if(st.get(4 * n) != st.get(4 * cc.id + i / 2)) _id.push_back(st.get(4 * cc.id + i / 2));\r\n      }\r\n    }\r\n    unique(_id);\r\n    for(auto i : _id) {\r\n      for(auto j : in[i]) id.push_back(j / 4);\r\n    }\r\n    unique(id);\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(!cur.count(sp(cc, i))) {\r\n        st.unite(4 * cc.id + i / 2, 4 * n);\r\n      }\r\n    }\r\n    for(int i = 0; i < 8; i += 2) {\r\n      if(cur.count(sp(cc, i))) {\r\n        point ss = *cur.find(sp(cc, i));\r\n        st.unite(4 * n, 4 * ss.id + ((i + 4) % 8) / 2);\r\n      }\r\n    }\r\n    for(auto i : id) {\r\n      if(cur.count(a[i]) && valid(a[i])) pos.insert(a[i]);\r\n      else pos.erase(a[i]);\r\n    }\r\n  }\r\n  reverse(res.begin(), res.end());\r\n  for(auto i : res) printf(\"%d\\n\", i + 1);\r\n  return 0;\r\n}\r\n"
}