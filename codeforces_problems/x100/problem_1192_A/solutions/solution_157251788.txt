{
    "id": 157251788,
    "contestId": 1192,
    "creationTimeSeconds": 1652578684,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "teapotd"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 483,
    "memoryConsumedBytes": 66252800,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\nusing Pii = pair<int,int>;\r\nusing Vi = vector<int>;\r\n#define mp make_pair\r\n#define pb push_back\r\n#define x first\r\n#define y second\r\n#define rep(i,b,e) for (int i = (b); i < (e); i++)\r\n#define each(a,x) for (auto& a : (x))\r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(x) int((x).size())\r\n#define tem template<class t, class u, class ...w> auto\r\n#define pri(x,y,z) tem operator<<(t& o, u a)->decltype(z,o) { o << *x; y; z; return o << x[1]; }\r\npri(\"{}\",, a.print())\r\npri(\"()\",, o << a.x << \", \" << a.y)\r\npri(\"[]\", auto d=\"\"; for (auto i : a) (o << d << i, d = \", \"), all(a))\r\nvoid DD(...) {}\r\ntem DD(t s, u a, w... k) {\r\n    for (int b = 1; cerr << *s++, *s && *s - b*44;) b += 2 / (*s*2 - 81);\r\n    cerr << \": \" << a; DD(s, k...);\r\n}\r\n#ifdef LOC\r\n#define deb(...) DD(\"[,\\b :] \"#__VA_ARGS__, __LINE__, __VA_ARGS__), cerr << endl\r\n#else\r\n#define deb(...)\r\n#endif\r\n#define DBP(...) void print() { DD(#__VA_ARGS__, __VA_ARGS__); }\r\n\r\n// 0 = outer face vertex\r\n// 1-n = cell vertices\r\n// >n = other faces\r\n\r\n// for cells:\r\n// 012\r\n// 7x3\r\n// 654\r\n\r\nstruct FAU {\r\n\tVi G;\r\n\tFAU(int n = 0) : G(n, -1) {}\r\n\tint find(int i) { return G[i] < 0 ? i : G[i] = find(G[i]); }\r\n\tbool join(int i, int j) {\r\n\t\ti = find(i); j = find(j);\r\n\t\tif (i == j) return 0;\r\n\t\tif (G[i] > G[j]) swap(i, j);\r\n\t\tG[i] += G[j]; G[j] = i;\r\n\t\treturn 1;\r\n\t}\r\n};\r\n\r\nvector<bool> cell, outer, seen;\r\nvector<Vi> edges;\r\nvector<array<int, 8>> neigh;\r\npriority_queue<int> que;\r\nFAU dsu;\r\n\r\nvoid dfsConnected(int v) {\r\n\tif (v == -1 || seen[v] || !cell[v]) return;\r\n\tseen[v] = 1;\r\n\teach(e, neigh[v]) dfsConnected(e);\r\n}\r\n\r\nvoid dfsOuter(int v) {\r\n\tif (cell[v]) return que.push(v);\r\n\tif (outer[v]) return;\r\n\touter[v] = 1;\r\n\teach(e, edges[v]) dfsOuter(e);\r\n}\r\n\r\nint main() {\r\n    cin.sync_with_stdio(0); cin.tie(0);\r\n    cout << fixed << setprecision(10);\r\n\r\n\tint n, t;\r\n\tcin >> n >> t;\r\n\r\n\tvector<Pii> elems(n);\r\n\tint minX = INT_MAX, minY = INT_MAX;\r\n\tint maxX = INT_MIN, maxY = INT_MIN;\r\n\r\n\teach(e, elems) {\r\n\t\tcin >> e.x >> e.y;\r\n\t\tminX = min(minX, e.x);\r\n\t\tminY = min(minY, e.y);\r\n\t\tmaxX = max(maxX, e.x);\r\n\t\tmaxY = max(maxY, e.y);\r\n\t}\r\n\r\n\tint C = maxX-minX+1;\r\n\tint R = maxY-minY+1;\r\n\r\n\tif (R > n+5 || C > n+5) {\r\n\t\tcout << \"NO\\n\";\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tvector<vector<Pii>> cols(C);\r\n\r\n\trep(i, 0, n) {\r\n\t\tauto& e = elems[i];\r\n\t\te.x -= minX;\r\n\t\te.y -= minY;\r\n\t\tcols[e.x].pb({e.y, i+1});\r\n\t}\r\n\r\n\tcell.resize(n+1, 1);\r\n\tcell[0] = 0;\r\n\r\n\teach(vec, cols) {\r\n\t\tsort(all(vec));\r\n\t\tint s = sz(vec);\r\n\t\trep(i, 0, s) {\r\n\t\t\tint prv = (i > 0 ? vec[i-1].x+1 : 0);\r\n\t\t\tif (prv != vec[i].x) {\r\n\t\t\t\tvec.pb({prv, sz(cell)});\r\n\t\t\t\tcell.pb(0);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint prv = (s > 0 ? vec[s-1].x+1 : 0);\r\n\t\tif (prv < R) {\r\n\t\t\tvec.pb({prv, sz(cell)});\r\n\t\t\tcell.pb(0);\r\n\t\t}\r\n\t\tsort(all(vec));\r\n\t}\r\n\r\n\tauto vertexAt = [&](int x, int y) {\r\n\t\tif (x < 0 || x >= C || y < 0 || y >= R) return 0;\r\n\t\tauto it = --upper_bound(all(cols[x]), y, [](int l, Pii r) { return l < r.x; });\r\n\t\treturn it->y;\r\n\t};\r\n\r\n\tdsu = {sz(cell)};\r\n\touter.resize(sz(cell));\r\n\tedges.resize(sz(cell));\r\n\tneigh.resize(sz(cell), {-1,-1,-1,-1,-1,-1,-1,-1});\r\n\r\n\trep(x, 0, C) {\r\n\t\trep(i, 0, sz(cols[x])) {\r\n\t\t\tauto& cur = cols[x][i];\r\n\t\t\tint nxtY = (i+1 < sz(cols[x]) ? cols[x][i+1].x : R);\r\n\r\n\t\t\tauto &N = neigh[cur.y];\r\n\t\t\tauto &E = edges[cur.y];\r\n\r\n\t\t\tif (cell[cur.y]) {\r\n\t\t\t\tN[0] = vertexAt(x-1, cur.x+1);\r\n\t\t\t\tN[1] = vertexAt(x, cur.x+1);\r\n\t\t\t\tN[2] = vertexAt(x+1, cur.x+1);\r\n\t\t\t\tN[3] = vertexAt(x+1, cur.x);\r\n\t\t\t\tN[4] = vertexAt(x+1, cur.x-1);\r\n\t\t\t\tN[5] = vertexAt(x, cur.x-1);\r\n\t\t\t\tN[6] = vertexAt(x-1, cur.x-1);\r\n\t\t\t\tN[7] = vertexAt(x-1, cur.x);\r\n\t\t\t\tE = {N[1], N[3], N[5], N[7]};\r\n\t\t\t} else {\r\n\t\t\t\tE.pb(vertexAt(x, cur.x-1));\r\n\t\t\t\tE.pb(vertexAt(x, nxtY));\r\n\t\t\t\tif (x > 0) {\r\n\t\t\t\t\tauto it = --upper_bound(all(cols[x-1]), cur.x, [](int l, Pii r) { return l < r.x; });\r\n\t\t\t\t\twhile (it != cols[x-1].end() && it->x < nxtY) {\r\n\t\t\t\t\t\tE.pb(it->y);\r\n\t\t\t\t\t\tit++;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tE.pb(0);\r\n\t\t\t\t}\r\n\t\t\t\tif (x+1 < C) {\r\n\t\t\t\t\tauto it = --upper_bound(all(cols[x+1]), cur.x, [](int l, Pii r) { return l < r.x; });\r\n\t\t\t\t\twhile (it != cols[x+1].end() && it->x < nxtY) {\r\n\t\t\t\t\t\tE.pb(it->y);\r\n\t\t\t\t\t\tit++;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tE.pb(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\teach(u, E) if (u == 0) {\r\n\t\t\t\tedges[0].pb(cur.y);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tseen.resize(sz(edges));\r\n\tdfsConnected(1);\r\n\r\n\trep(i, 0, n) {\r\n\t\tif (!seen[i+1]) {\r\n\t\t\tcout << \"NO\\n\";\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\trep(i, 0, sz(cell)) if (!cell[i]) {\r\n\t\teach(e, edges[i]) if (!cell[e]) {\r\n\t\t\tdsu.join(i, e);\r\n\t\t}\r\n\t}\r\n\r\n\tdfsOuter(0);\r\n\tVi ans;\r\n\r\n\twhile (!que.empty()) {\r\n\t\tint v = que.top();\r\n\t\tque.pop();\r\n\t\tif (!cell[v]) continue;\r\n\r\n\t\tauto &N = neigh[v];\r\n\t\tbool good = 0;\r\n\r\n\t\tfor (int i = 1; i < 8; i += 2) {\r\n\t\t\tif (outer[N[i]]) {\r\n\t\t\t\tgood = 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!good) continue;\r\n\r\n\t\tfor (int i = 1; i < 8; i += 2) {\r\n\t\t\tint a = N[i];\r\n\t\t\tif (cell[a]) continue;\r\n\t\t\ta = dsu.find(a);\r\n\t\t\tfor (int j = i+2; j < 8; j += 2) {\r\n\t\t\t\tint b = N[j];\r\n\t\t\t\tif (cell[b]) continue;\r\n\t\t\t\tb = dsu.find(b);\r\n\t\t\t\tif (a != b) continue;\r\n\t\t\t\tint cnt = 0;\r\n\t\t\t\tfor (int k = i; k != j; k = (k+1)%8) {\r\n\t\t\t\t\tif (cell[N[k]]) {\r\n\t\t\t\t\t\tcnt++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (int k = j; k != i; k = (k+1)%8) {\r\n\t\t\t\t\tif (cell[N[k]]) {\r\n\t\t\t\t\t\tcnt++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (cnt == 2) {\r\n\t\t\t\t\tgood = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!good) break;\r\n\t\t}\r\n\r\n\t\tif (good) {\r\n\t\t\tans.pb(v);\r\n\t\t\tcell[v] = 0;\r\n\t\t\tdfsOuter(v);\r\n\t\t\teach(e, edges[v]) if (!cell[e]) {\r\n\t\t\t\tdsu.join(v, e);\r\n\t\t\t}\r\n\r\n\t\t\tfor (int j = 0; j < 8; j += 2) {\r\n\t\t\t\tif (cell[N[j]]) {\r\n\t\t\t\t\tque.push(N[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcout << \"YES\\n\";\r\n\treverse(all(ans));\r\n\teach(a, ans) cout << a << '\\n';\r\n    return 0;\r\n}\r\n"
}