{
    "id": 57762510,
    "contestId": 1192,
    "creationTimeSeconds": 1564079779,
    "relativeTimeSeconds": 16279,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "Arturgo"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 3260,
    "memoryConsumedBytes": 141414400,
    "points": 100.0,
    "source": "#include <iostream>\r\n#include <vector>\r\n#include <unordered_map>\r\n#include <list>\r\n#include <set>\r\n#include <cstdio>\r\n#include <map>\r\n#include <cstdio>\r\n#pragma comment(linker, \"/stack:200000000\")\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\nusing namespace std;\r\n\r\nint deps[8][2] = {\r\n\t{1, 0},\r\n\t{1, 1},\r\n\t{0, 1},\r\n\t{-1, 1},\r\n\t{-1, 0},\r\n\t{-1, -1},\r\n\t{0, -1},\r\n\t{1, -1}\r\n};\r\n\r\nstruct Info {\r\n\tbool estPasse;\r\n\tint zone;\r\n\tint id;\r\n\r\n\tInfo(int _id = -1) {\r\n\t\tid = _id;\r\n\t\testPasse = false;\r\n\t\tzone = -1;\r\n\t}\r\n};\r\n\r\nvector<pair<int, int>> points;\r\n\r\nconst int MOD = 1000 * 1000 + 33;\r\nvector<pair<pair<int, int>, Info>> infos[MOD];\r\n\r\ninline Info& getInfo(pair<int, int> coord) {\r\n\tint h = (MOD + (coord.first + 31ll * coord.second) % MOD) % MOD;\r\n\r\n\tfor(pair<pair<int, int>, Info>& paire : infos[h]) {\r\n\t\tif(paire.first == coord)\r\n\t\t\treturn paire.second;\r\n\t}\r\n\r\n\tinfos[h].push_back({coord, Info()});\r\n\treturn infos[h].back().second;\r\n}\r\n\r\ninline bool existInfo(pair<int, int> coord) {\r\n\tint h = (MOD + (coord.first + 31ll * coord.second) % MOD) % MOD;\r\n\r\n\tfor(pair<pair<int, int>, Info>& paire : infos[h]) {\r\n\t\tif(paire.first == coord)\r\n\t\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nint arbre[(1 << 19)];\r\n\r\ninline void setVal(int pos, int val) {\r\n\tpos += (1 << 18);\r\n\tarbre[pos] = val;\r\n\r\n\twhile(pos != 1) {\r\n\t\tpos /= 2;\r\n\t\tarbre[pos] = max(arbre[2 * pos], arbre[2 * pos + 1]);\r\n\t}\r\n}\r\n\r\ninline int zone(int lig, int col) {\r\n\tif(getInfo({lig, col}).zone == -1)\r\n\t\treturn -1 - getInfo({lig, col}).id;\r\n\treturn getInfo({lig, col}).zone;\r\n}\r\n\r\ninline bool estPoint(int lig, int col) {\r\n\treturn getInfo({lig, col}).id != -1;\r\n}\r\n\r\ninline void update(pair<int, int> coord) {\r\n\tif(!existInfo(coord))\r\n\t\treturn;\r\n\tif(getInfo(coord).id == -1)\r\n\t\treturn;\r\n\r\n\tbool toucheInf = false;\r\n\tfor(int iDep = 0;iDep < 4;iDep++) {\r\n\t\tif(zone(coord.first + deps[2 * iDep][0], coord.second + deps[2 * iDep][1]) == 0)\r\n\t\t\ttoucheInf = true;\r\n\t}\r\n\r\n\tbool connecte = true;\r\n\r\n\tbool pointBas = estPoint(coord.first + 1, coord.second + 1) || estPoint(coord.first + 1, coord.second) || estPoint(coord.first + 1, coord.second - 1);\r\n\tbool pointHaut = estPoint(coord.first - 1, coord.second + 1) || estPoint(coord.first - 1, coord.second) || estPoint(coord.first - 1, coord.second - 1);\r\n\tbool pointDroite = estPoint(coord.first + 1, coord.second + 1) || estPoint(coord.first, coord.second + 1) || estPoint(coord.first - 1, coord.second + 1);\r\n\tbool pointGauche = estPoint(coord.first + 1, coord.second - 1) || estPoint(coord.first, coord.second - 1) || estPoint(coord.first - 1, coord.second - 1);\r\n\r\n\tif(zone(coord.first + 1, coord.second) == zone(coord.first - 1, coord.second) && pointDroite && pointGauche)\r\n\t\tconnecte = false;\r\n\tif(zone(coord.first, coord.second + 1) == zone(coord.first, coord.second - 1) && pointBas && pointHaut)\r\n\t\tconnecte = false;\r\n\tif(zone(coord.first + 1, coord.second) == zone(coord.first, coord.second + 1) && (pointHaut || pointGauche) && estPoint(coord.first + 1, coord.second + 1))\r\n\t\tconnecte = false;\r\n\tif(zone(coord.first + 1, coord.second) == zone(coord.first, coord.second - 1) && (pointHaut || pointDroite) && estPoint(coord.first + 1, coord.second - 1))\r\n\t\tconnecte = false;\r\n\tif(zone(coord.first - 1, coord.second) == zone(coord.first, coord.second + 1) && (pointBas || pointGauche) && estPoint(coord.first - 1, coord.second + 1))\r\n\t\tconnecte = false;\r\n\tif(zone(coord.first - 1, coord.second) == zone(coord.first, coord.second - 1) && (pointBas || pointDroite) && estPoint(coord.first - 1, coord.second - 1))\r\n\t\tconnecte = false;\r\n\r\n\tif(toucheInf && connecte) {\r\n\t\tsetVal(getInfo(coord).id, getInfo(coord).id);\r\n\t}\r\n\telse {\r\n\t\tsetVal(getInfo(coord).id, 0);\r\n\t}\r\n}\r\n\r\nvoid dfs(const pair<int, int> coord, int couleur) {\r\n\tif(!existInfo(coord))\r\n\t\treturn;\r\n\tif(getInfo(coord).zone == 0 || (couleur != 0 && getInfo(coord).zone != -1))\r\n\t\treturn;\r\n\tif(getInfo(coord).id != -1)\r\n\t\treturn;\r\n\r\n\tgetInfo(coord).zone = couleur;\r\n\r\n\tfor(int iDep = 0;iDep < 8;iDep++) {\r\n\t\tupdate({coord.first + deps[iDep][0], coord.second + deps[iDep][1]});\r\n\t}\r\n\r\n\tfor(int iDep = 0;iDep < 4;iDep++) {\r\n\t\tdfs({coord.first + deps[2 * iDep][0], coord.second + deps[2 * iDep][1]}, couleur);\r\n\t}\r\n}\r\n\r\nint taille(const pair<int, int> coord) {\r\n\tif(!existInfo(coord))\r\n\t\treturn 0;\r\n\tif(getInfo(coord).id == -1)\r\n\t\treturn 0;\r\n\r\n\tif(getInfo(coord).estPasse)\r\n\t\treturn 0;\r\n\tgetInfo(coord).estPasse = true;\r\n\r\n\tint t = 1;\r\n\tfor(int iDep = 0;iDep < 8;iDep++) {\r\n\t\tt += taille({coord.first + deps[iDep][0], coord.second + deps[iDep][1]});\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nint main() {\r\n\tint nbPoints, type;\r\n\tscanf(\"%d%d\", &nbPoints, &type);\r\n\r\n\tpair<int, int> mini = {1000000000, 1000000000};\r\n\tfor(int iPoint = 0;iPoint < nbPoints;iPoint++) {\r\n\t\tint lig, col;\r\n\t\tscanf(\"%d%d\", &lig, &col);\r\n\r\n\t\tpoints.push_back({lig, col});\r\n\r\n\t\tgetInfo({lig, col}) = Info();\r\n\t\tfor(int iDep = 0;iDep < 8;iDep++) {\r\n\t\t\tgetInfo({lig + deps[iDep][0], col + deps[iDep][1]}) = Info();\r\n\t\t\tmini = min(mini, {lig + deps[iDep][0], col + deps[iDep][1]});\r\n\t\t}\r\n\t}\r\n\r\n\tfor(int iPoint = 0;iPoint < nbPoints;iPoint++) {\r\n\t\tgetInfo(points[iPoint]) = Info(iPoint);\r\n\t}\r\n\r\n\t//check connexe ?\r\n\tif(taille(points[0]) != nbPoints) {\r\n\t\tprintf(\"NO\\n\");\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tint nbZones = 0;\r\n\tdfs(mini, nbZones++);\r\n\r\n\t//todo\r\n\tfor(int i = 0;i < MOD;i++) {\r\n\t\tfor(auto info : infos[i]) {\r\n\t\t\tif(info.second.zone == -1 && info.second.id == -1)\r\n\t\t\t\tdfs(info.first, nbZones++);\r\n\t\t}\r\n\t}\r\n\r\n\tprintf(\"YES\\n\");\r\n\r\n\tvector<int> ordre;\r\n\tfor(int iFois = 0;iFois < nbPoints;iFois++) {\r\n\t\tint melId = arbre[1];\r\n\t\tordre.push_back(melId);\r\n\t\tsetVal(melId, 0);\r\n\r\n\t\tgetInfo(points[melId]).id = -1;\r\n\t\tdfs(points[melId], 0);\t\r\n\t}\r\n\r\n\twhile(!ordre.empty()) {\r\n\t\tprintf(\"%d\\n\", ordre.back() + 1);\r\n\t\tordre.pop_back();\r\n\t}\r\n\treturn 0;\r\n}"
}