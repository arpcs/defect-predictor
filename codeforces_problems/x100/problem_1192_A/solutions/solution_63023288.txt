{
    "id": 63023288,
    "contestId": 1192,
    "creationTimeSeconds": 1571584838,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "rama_pang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 2979,
    "memoryConsumedBytes": 163328000,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int dr[] = {-1, -1, -1,  0, +1, +1, +1,  0};\r\nconst int dc[] = {-1,  0, +1, +1, +1,  0, -1, -1};\r\n\r\n/*  Solve the problem in reverse: find and remove a non-8-articulation 4-reachable from infinity \r\n    cell N times, and restore the order in reverse order (or report that it is impossible).\r\n \r\n    If cells are all 8-connected, then there is a non-8-articulation 4-reachable from infinity cell.\r\n    \r\n    Let the region of a c0 = 4-reachable empty cells surrounding this cell, and different cell c1\r\n    and c2 are in one region if there are 4-paths only using 8-negihbours of c0. (c1 and c2 are\r\n    4-reachable negihbours of c0)\r\n\r\n    For all 4-reachable from infinity full cells, if it is a non-articulation, then all regioin\r\n    must belong to different components. If two regions belong to the same component, then there\r\n    are no alternate paths connecting some 8-reachable cells through c0 in the graph.\r\n*/\r\n\r\nstruct DisjointSet {\r\n\r\n    vector<int> p, set_size;\r\n    vector<vector<int>> members;\r\n\r\n    int size;\r\n    bool need_members;\r\n\r\n    DisjointSet(bool yes = 0): need_members(yes) {}\r\n    \r\n    void init(int n) {\r\n        p.resize(n);\r\n        iota(p.begin(), p.end(), 0);\r\n        size = n;\r\n\r\n        if (need_members) {\r\n            members.resize(n);\r\n            for (int i = 0; i < n; i++) members[i].emplace_back(i);\r\n        } else {\r\n            set_size.assign(n, 1);\r\n        }\r\n    }\r\n\r\n    int find(int n) {\r\n        return (p[n] == n)? n : p[n] = find(p[n]);\r\n    }\r\n    \r\n    inline bool join(int a, int b) {\r\n        a = find(a), b = find(b);\r\n        if (a == b) return false;\r\n\r\n        if (need_members) {\r\n            if (members[a].size() < members[b].size()) swap(a, b);\r\n            for (auto i : members[b]) members[a].emplace_back(i);\r\n            members[b].clear();\r\n        } else {\r\n            if (set_size[a] < set_size[b]) swap(a, b);\r\n            set_size[a] += set_size[b];\r\n            set_size[b] = 0;\r\n        }\r\n\r\n        p[b] = a;\r\n        size--;\r\n        return true;\r\n    }\r\n\r\n    inline vector<int> get_members(int n) {\r\n        return members[find(n)];\r\n    }\r\n    \r\n    inline int get_size(int n) {\r\n        return (need_members)? members[find(n)].size() : set_size[find(n)];\r\n    }\r\n\r\n};\r\n\r\nint N;\r\nmap<pair<int, int>, int> full_cell, empty_cell, cell;\r\nvector<pair<int, int>> cell_id;\r\nDisjointSet component(1); //connected components of empty cells\r\n\r\nnamespace validity_check {\r\n\r\n    /*  Run DFS on 8-reachable graph of full cells. It can be proven that\r\n        if the given graph is 8-connected, then there is at least one cell\r\n        which is non-8-articulation 4-reachable from infinity. Thus a solution\r\n        exists if and only if the graph is 8-connected.\r\n    */\r\n\r\n    vector<vector<int>> G;\r\n    vector<int> vis;\r\n    \r\n    int flood(pair<int, int> n) {\r\n        int id = cell[n];\r\n        if (vis[id]) return 0;\r\n        vis[id] = 1;\r\n        int res = 1;\r\n\r\n        for (int d = 0; d < 8; d++) {\r\n            int tr = n.first + dr[d], tc = n.second + dc[d];\r\n            if (full_cell.find(make_pair(tr, tc)) == full_cell.end()) continue;\r\n            res += flood(make_pair(tr, tc));\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    bool solution_exists() {\r\n        G.resize(full_cell.size()), vis.resize(full_cell.size());\r\n        int connected_size = flood(cell_id[0]);\r\n        return (connected_size == N);\r\n    }\r\n}\r\n\r\nnamespace solve {\r\n    \r\n    pair<int, int> infinity_cell;\r\n\r\n    vector<int> vis;\r\n    \r\n    void flood(pair<int, int> n, int par) {\r\n        int id = cell[n];\r\n        if (vis[id]) return;\r\n        vis[id] = 1;\r\n        component.join(id, par);\r\n\r\n        for (int d = 1; d < 8; d += 2) { //4-direction\r\n            int tr = n.first + dr[d], tc = n.second + dc[d];\r\n            if (empty_cell.find(make_pair(tr, tc)) == empty_cell.end()) continue;\r\n            flood(make_pair(tr, tc), par);\r\n        }\r\n    }\r\n\r\n    vector<int> regions, small;\r\n    vector<DisjointSet> near;\r\n    \r\n    vector<int> infinity_reachable;\r\n    vector<array<int, 8>> empty_neighbour;\r\n    vector<bool> is_removable, in_queue;\r\n\r\n    inline bool is_valid(pair<int, int> p) {\r\n        int id = cell[p];\r\n        regions.clear();\r\n        small.clear();\r\n\r\n        for (int d = 1; d < 8; d += 2) {\r\n            int tr = p.first + dr[d], tc = p.second + dc[d];\r\n            if (!empty_neighbour[id][d]) continue;\r\n\r\n            small.emplace_back(near[id].find(((d - 1) / 2)));\r\n            regions.emplace_back(component.find(cell[make_pair(tr, tc)]));\r\n        }\r\n\r\n        sort(small.begin(), small.end());\r\n        sort(regions.begin(), regions.end());\r\n\r\n        small.resize(unique(small.begin(), small.end()) - small.begin());\r\n        regions.resize(unique(regions.begin(), regions.end()) - regions.begin());\r\n\r\n        if (!infinity_reachable[id]) infinity_reachable[id] = (count(regions.begin(), regions.end(), component.find(cell[infinity_cell])) > 0);\r\n        if (!infinity_reachable[id]) return false;\r\n        return (regions.size() == small.size()); //all regions must be different components\r\n    }\r\n\r\n    vector<int> get_solution() {\r\n\r\n        /*  We can check if a cell is 4-reachable from infinity in O(1) with\r\n            the help of dijoinst set. We can also determine if a cell is an\r\n            articulation the same way. Thus each time we are going to remove\r\n            a cell, we can just check all N possible skyscrapers.\r\n\r\n            However, each 4-reachable cell can change its status as an\r\n            articulation or non-articulation at most 2 times: a non-articulation\r\n            (as there are other connecting paths), an articulation (all other\r\n            connecting paths are already removed), a non-articulation (it becomes\r\n            a leaf).\r\n\r\n            Thus if we join two components, we can afford to recompute all 8-negihbours \r\n            of the one with less size and achieve N log N by the weighted-union heursitic.\r\n\r\n            Notice that the number of regions are only changed if and only if a cell is\r\n            an 8-neighbour of the removed cell. Thus we can save this data in an array\r\n            and update only when needed, to avoid recomputation.\r\n        */\r\n\r\n        infinity_cell = cell.begin()->first;\r\n        for (auto i : cell) infinity_cell = min(infinity_cell, i.first);\r\n\r\n        infinity_reachable.resize(full_cell.size());\r\n        empty_neighbour.resize(full_cell.size());\r\n        is_removable.resize(full_cell.size());\r\n        in_queue.resize(full_cell.size());\r\n        near.resize(full_cell.size());\r\n\r\n        /* Initial merging of empty cell components */\r\n        vis.assign(cell.size(), 0);\r\n        flood(infinity_cell, cell[infinity_cell]);\r\n        \r\n        for (auto i : cell) {\r\n            if (empty_cell.find(i.first) == empty_cell.end()) continue;\r\n            flood(i.first, i.second);\r\n        }\r\n\r\n        /* Compute data (regions and components) to determine whether cell is an articulation */\r\n        for (auto i : full_cell) {\r\n            for (int d = 0; d < 8; d++) {\r\n                int tr = i.first.first + dr[d], tc = i.first.second + dc[d];\r\n                empty_neighbour[i.second][d] = (empty_cell.find(make_pair(tr, tc)) != empty_cell.end());\r\n            }\r\n\r\n            near[i.second].init(4);\r\n            for (int d = 1; d < 8; d += 2) {\r\n                int c1 = empty_neighbour[i.second][d],\r\n                    c2 = empty_neighbour[i.second][(d + 1) % 8],\r\n                    c3 = empty_neighbour[i.second][(d + 2) % 8];\r\n                \r\n                if (c1 == c2 && c2 == c3 && c3 == 1) near[i.second].join(((d - 1) / 2), (((d - 1) / 2) + 1) % 4);\r\n            }\r\n        }\r\n\r\n        /* Initialize removable cells for first pass */\r\n        priority_queue<int> removable; //get highest cell index that is removable\r\n        for (auto i : full_cell) if (is_valid(i.first)) {\r\n            removable.emplace(i.second);\r\n            is_removable[i.second] = in_queue[i.second] = 1;\r\n        }\r\n        \r\n        vector<int> res;\r\n        vector<int> change;\r\n        vector<pair<int, int>> update_list;\r\n\r\n        update_list.reserve(4 * N);\r\n        res.reserve(N);\r\n        change.reserve(N);\r\n\r\n        while (full_cell.size() > 0) {\r\n            while (!is_removable[removable.top()]) in_queue[removable.top()] = 0, removable.pop();\r\n            int candidate = removable.top();\r\n            pair<int, int> P = cell_id[candidate];\r\n\r\n            removable.pop();\r\n            is_removable[candidate] = 0;\r\n            in_queue[candidate] = 0;\r\n\r\n            res.emplace_back(candidate + 1);\r\n            full_cell.erase(full_cell.find(P));\r\n            empty_cell.emplace(P, candidate);\r\n\r\n            update_list.clear();\r\n\r\n            /* Update connected components of cells affected */\r\n            for (int d = 1; d < 8; d += 2) {\r\n                int tr = P.first + dr[d], tc = P.second + dc[d];\r\n                int P_id = cell[P], neighbour_id = cell[make_pair(tr, tc)];\r\n\r\n                if (empty_cell.find(make_pair(tr, tc)) == empty_cell.end()) continue;\r\n                if (component.find(P_id) == component.find(neighbour_id)) continue;\r\n\r\n                if (component.get_size(neighbour_id) > component.get_size(P_id)) {\r\n                    change = component.get_members(P_id);                    \r\n                } else {\r\n                    change = component.get_members(neighbour_id);\r\n                }\r\n\r\n                component.join(neighbour_id, P_id);\r\n                \r\n                for (auto i : change) {\r\n                    pair<int, int> cur = cell_id[i];\r\n\r\n                    for (int change_d = 0; change_d < 8; change_d++) {\r\n                        int change_tr = cur.first + dr[change_d], change_tc = cur.second + dc[change_d];\r\n                        if (full_cell.find({change_tr, change_tc}) == full_cell.end()) continue;\r\n\r\n                        update_list.emplace_back(change_tr, change_tc);\r\n                    }\r\n                }\r\n            }\r\n\r\n            /* Update data needed to determine articulation cells */\r\n            for (int d = 0; d < 8; d++) {\r\n                int tr = P.first + dr[d], tc = P.second + dc[d];    \r\n                if (full_cell.find(make_pair(tr, tc)) == full_cell.end()) continue;\r\n\r\n                /* Update empty neighbours for 8-neighbours of removed cell */\r\n                int id = cell[make_pair(tr, tc)];\r\n                empty_neighbour[id][(d + 4) % 8] = 1;\r\n\r\n                /* Update number of regions for 8-neighbours of removed cell */\r\n                for (int d2 = 1; d2 < 8; d2 += 2) {\r\n                    int c1 = empty_neighbour[id][d2],\r\n                        c2 = empty_neighbour[id][(d2 + 1) % 8],\r\n                        c3 = empty_neighbour[id][(d2 + 2) % 8];\r\n                    \r\n                    if (c1 == c2 && c2 == c3 && c3 == 1) near[id].join(((d2 - 1) / 2), (((d2 - 1) / 2) + 1) % 4);\r\n                }   \r\n            }\r\n\r\n            sort(update_list.begin(), update_list.end());\r\n            update_list.resize(unique(update_list.begin(), update_list.end()) - update_list.begin());\r\n            \r\n            for (auto i : update_list) {\r\n                int id = cell[i];\r\n                is_removable[id] = is_valid(i);\r\n\r\n                if (is_removable[id] && !in_queue[id]) removable.emplace(id);\r\n            }\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n\r\n}\r\n\r\nint main() {\r\n    int t;\r\n    cin >> N >> t;\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        pair<int, int> p; cin >> p.first >> p.second;\r\n\r\n        full_cell.emplace(p, cell.size());\r\n        cell.emplace(p, cell.size());\r\n    }\r\n\r\n    for (auto i : full_cell) {\r\n        for (int d = 0; d < 8; d++) {\r\n            int tr = i.first.first + dr[d], tc = i.first.second + dc[d];\r\n            if (cell.find(make_pair(tr, tc)) != cell.end()) continue;\r\n\r\n            empty_cell.emplace(make_pair(tr, tc), cell.size());\r\n            cell.emplace(make_pair(tr, tc), cell.size());\r\n        }\r\n    }\r\n\r\n    component.init(cell.size());\r\n    cell_id.resize(cell.size());\r\n    for (auto i : cell) cell_id[i.second] = i.first;\r\n\r\n    if (!validity_check::solution_exists()) {\r\n        cout << \"NO\\n\";\r\n        return 0;\r\n    }\r\n\r\n    cout << \"YES\\n\";\r\n    vector<int> ans = solve::get_solution();\r\n    for (auto i : ans) cout << i << \"\\n\";\r\n\r\n    return 0;\r\n}\r\n"
}