{
    "id": 86642551,
    "contestId": 1192,
    "creationTimeSeconds": 1594551414,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "train_driver"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 185,
    "timeConsumedMillis": 3151,
    "memoryConsumedBytes": 235929600,
    "points": 100.0,
    "source": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ii = pair<int, int>;\n\n#define X first\n#define Y second\n\nint n, t, cnt;\nmap<ii, int> M;\nii cor[1500007];\nint skynum[150007], sky[1500007];\nint component[1500007];\nbool engaged[1500007];\nvector<int> incomp[1500007];\nvector<int> G4[1500007], G8[1500007];\nbool vis[1500007];\nint ecnt;\nint infty;\nset<int, greater<int> > to_use;\n\nvoid add_point(int x, int y) {\n\tii p = {x, y};\n\tif(!M.count(p)) {\n\t\tM[p] = ++cnt;\n\t\tcor[cnt] = p;\n\t\tcomponent[cnt] = cnt;\n\t\tincomp[cnt].push_back(cnt);\n\t}\n}\n\nbool check(int i) {\n\tbool eng[3][3];\n\tint comp[3][3];\n\tfor(int w : G8[i]) {\n\t\tint x = cor[w].X - cor[i].X + 1;\n\t\tint y = cor[w].Y - cor[i].Y + 1;\n\t\teng[x][y] = engaged[w];\n\t\tcomp[x][y] = component[w];\n\t}\n\t\n\tif(!eng[0][1] && !eng[1][2] && comp[0][1] == comp[1][2] && eng[0][2]\n\t\t&& (eng[0][0] || eng[1][0] || eng[2][0] || eng[2][1] || eng[2][2]))\n\t\t\treturn false;\n\tif(!eng[1][2] && !eng[2][1] && comp[1][2] == comp[2][1] && eng[2][2]\n\t\t&& (eng[2][0] || eng[1][0] || eng[0][0] || eng[0][1] || eng[0][2]))\n\t\t\treturn false;\n\tif(!eng[2][1] && !eng[1][0] && comp[2][1] == comp[1][0] && eng[2][0]\n\t\t&& (eng[0][0] || eng[0][1] || eng[0][2] || eng[1][2] || eng[2][2]))\n\t\t\treturn false;\n\tif(!eng[1][0] && !eng[0][1] && comp[1][0] == comp[0][1] && eng[0][0]\n\t\t&& (eng[0][2] || eng[1][2] || eng[2][2] || eng[2][1] || eng[2][0]))\n\t\t\treturn false;\n\tif(!eng[0][1] && !eng[2][1] && comp[0][1] == comp[2][1]\n\t\t&& (eng[0][0] || eng[1][0] || eng[2][0]) && (eng[0][2] || eng[1][2] || eng[2][2]))\n\t\t\treturn false;\n\tif(!eng[1][0] && !eng[1][2] && comp[1][0] == comp[1][2]\n\t\t&& (eng[0][0] || eng[0][1] || eng[0][2]) && (eng[2][0] || eng[2][1] || eng[2][2]))\n\t\t\treturn false;\n\t\t\t\n\tif(comp[1][0] == component[infty] || comp[0][1] == component[infty]\n\t\t|| comp[2][1] == component[infty] || comp[1][2] == component[infty])\t\n\t\t\treturn true;\n\n\treturn false;\n}\n\nvoid upd_check(int i) {\n\tif(check(skynum[i]))\n\t\tto_use.insert(i);\n\telse\n\t\tto_use.erase(i);\n}\n\nvoid merge(int a, int b, bool upd = false) {\n\tif(a == b)\n\t\treturn ;\n\t\t\n\tif(incomp[b].size() > incomp[a].size())\n\t\tswap(a, b);\n\t\t\n\tfor(int x : incomp[b]) {\n\t\tincomp[a].push_back(x);\n\t\tcomponent[x] = a;\n\t}\n\t\n\tfor(int x : incomp[b])\n\t\tfor(int y : G8[x])\n\t\t\tif(engaged[y])\n\t\t\t\tupd_check(sky[y]);\n\t\n\tincomp[b].clear();\n}\n\nvoid erase(int w) {\n\tengaged[w] = 0;\n\tfor(int u : G4[w])\n\t\tif(!engaged[u])\n\t\t\tmerge(component[w], component[u], true);\n}\n\nvoid dfs(int w) {\n\tif(vis[w])\n\t\treturn ;\n\tvis[w] = 1;\n\tecnt++;\n\t\t\n\tfor(int u : G8[w])\n\t\tif(engaged[u])\n\t\t\tdfs(u);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &t);\n\t\n\tii minp = {1e9 + 7, 1e9 + 7};\n\t\n\tfor(int i = 1 ; i <= n ; i++) {\n\t\tint r, c;\n\t\tscanf(\"%d%d\", &r, &c);\n\t\tfor(int x = -1 ; x <= 1 ; x++)\n\t\t\tfor(int y = -1 ; y <= 1 ; y++)\n\t\t\t\tadd_point(r + x, c + y);\n\t\tengaged[M[{r, c}]] = 1;\n\t\tskynum[i] = M[{r, c}];\n\t\tsky[M[{r, c}]] = i;\n\t\tminp = min(minp, {r, c});\n\t}\n\t\n\tinfty = M[{minp.X - 1, minp.Y}];\n\t\n\tfor(int i = 1 ; i <= cnt ; i++) {\n\t\tint x = cor[i].X;\n\t\tint y = cor[i].Y;\n\t\t\n\t\tfor(int xo = -1 ; xo <= 1 ; xo++) {\n\t\t\tfor(int yo = -1 ; yo <= 1 ; yo++) {\n\t\t\t\tii p2 = {x + xo, y + yo};\n\t\t\t\tif(M.count(p2) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tint num = M[p2];\n\t\t\t\t\n\t\t\t\tif(xo || yo)\n\t\t\t\t\tG8[i].push_back(num);\n\t\t\t\tif((xo || yo) && !(xo && yo)) {\n\t\t\t\t\tG4[i].push_back(num);\n\t\t\t\t\tif(!engaged[i] && !engaged[num])\n\t\t\t\t\t\tmerge(component[i], component[num]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(skynum[1]);\n\tif(ecnt != n) {\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tupd_check(i);\n\t\n\tprintf(\"YES\\n\");\n\tvector<int> res;\n\tfor(int i = 0 ; i < n ; i++) {\n\t\tint s = *to_use.begin();\n\t\tto_use.erase(to_use.begin());\n\t\tres.push_back(s);\n\t\terase(skynum[s]);\n\t}\n\t\n\treverse(res.begin(), res.end());\n\tfor(int x : res)\n\t\tprintf(\"%d\\n\", x);\n\t\n\treturn 0;\n}\n"
}