{
    "id": 62907763,
    "contestId": 1192,
    "creationTimeSeconds": 1571466156,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1192,
        "index": "A",
        "name": "Building Skyscrapers",
        "type": "PROGRAMMING",
        "tags": [
            "*special"
        ]
    },
    "author": {
        "contestId": 1192,
        "members": [
            {
                "handle": "rama_pang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1564063500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "PARTIAL",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 3500,
    "memoryConsumedBytes": 38092800,
    "points": 22.0,
    "source": "#pragma GCC optimize (\"Ofast\")\r\n#pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma,tune=native\")\r\n#pragma GCC optimize (\"unroll-loops\")\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int dr[] = {-1, -1, -1,  0, +1, +1, +1,  0};\r\nconst int dc[] = {-1,  0, +1, +1, +1,  0, -1, -1};\r\nint key;\r\n\r\n/*  Solve the problem in reverse: find and remove a non-8-articulation 4-reachable from infinity \r\n    cell N times, and restore the order in reverse order (or report that it is impossible).\r\n\r\n    If cells are all 8-connected, then there is a (non-8-articulation 4-reachable from infinity) cell.\r\n    Let all 4-reachable form a cycle C. Then for all cells in cycle C if it is a non-articulation, \r\n    all 4-reachable empty-cell-regions belong to different components.\r\n*/\r\n\r\nstruct PairHash {\r\n    inline size_t operator() (const pair<int, int> &o) const {\r\n        return hash<int>()(o.first ^ o.second ^ 99844531);\r\n    }\r\n};\r\n\r\nstruct DisjointSet {\r\n    vector<int> p;\r\n    int size;\r\n    DisjointSet() {}\r\n    void init(int n) {\r\n        p.resize(n);\r\n        size = n;\r\n        iota(p.begin(), p.end(), 0);\r\n    }\r\n    int find(int n) {\r\n        return (p[n] == n)? n : p[n] = find(p[n]);\r\n    }\r\n    bool join(int a, int b) {\r\n        a = find(a);\r\n        b = find(b);\r\n        if (a == b) return false;\r\n        p[a] = b;\r\n        size--;\r\n        return true;\r\n    }\r\n};\r\n\r\nint N;\r\nunordered_map<pair<int, int>, int, PairHash> full_cell, empty_cell, cell;\r\nDisjointSet component; //connected components for empty cells\r\n\r\nnamespace validity_check{\r\n\r\n    /*  Run DFS on 8-reachable graph of full cells. It can be proven that\r\n        if the given graph is 8-connected, then there is at least one cell\r\n        which is non-8-articulation 4-reachable from infinity. Thus a solution\r\n        exists if and only if the graph is 8-connected.\r\n    */\r\n\r\n    vector<vector<int>> G;\r\n    vector<int> vis;\r\n    \r\n    int dfs(int n) {\r\n        if (vis[n]) return 0;\r\n        vis[n] = 1;\r\n        int res = 1;\r\n        for (auto i : G[n]) res += dfs(i);\r\n        return res;\r\n    }\r\n\r\n    bool solution_exists() {\r\n        G.resize(full_cell.size()), vis.resize(full_cell.size());\r\n        for (auto i : full_cell) {\r\n            for (int d = 0; d < 8; d++) {\r\n                int tr = i.first.first + dr[d], tc = i.first.second + dc[d];\r\n                if (full_cell.find({tr, tc}) == full_cell.end()) continue;\r\n                G[i.second].push_back(full_cell[{tr, tc}]);\r\n            }\r\n        }\r\n        int a = dfs(0);\r\n        return (a == N);\r\n    }\r\n}\r\n\r\nnamespace O_NxN { //O(N^2) solution\r\n    \r\n    pair<int, int> infinity_cell;\r\n\r\n    vector<int> vis;\r\n    void flood(pair<int, int> n, pair<int, int> par) {\r\n        if (vis[cell[n]]) return;\r\n        vis[cell[n]] = 1;\r\n        component.join(cell[n], cell[par]);\r\n        for (int d = 1; d < 8; d += 2) { //4-direction\r\n            int tr = n.first + dr[d], tc = n.second + dc[d];\r\n            if (empty_cell.find({tr, tc}) == empty_cell.end()) continue;\r\n            flood({tr, tc}, par);\r\n        }\r\n    }\r\n\r\n    set<int> regions;\r\n    int cnt_regions;\r\n    DisjointSet near;\r\n    set<int> small;\r\n\r\n    inline bool is_valid(pair<int, int> p) {\r\n        regions.clear();\r\n        cnt_regions = 0;\r\n        near.init(8);\r\n        small.clear();\r\n\r\n        for (int d = 1; d < 8; d += 2) {\r\n            int tr = p.first + dr[d], tc = p.second + dc[d];\r\n            if (empty_cell.find({tr, tc}) == empty_cell.end()) continue;\r\n            regions.insert(component.find(cell[{tr, tc}]));\r\n        }\r\n\r\n        for (int d = 0; d < 8; d++) {\r\n            int tr1 = p.first + dr[d], tc1 = p.second + dc[d];\r\n            int c1 = (empty_cell.find({tr1, tc1}) == empty_cell.end());\r\n\r\n            int tr2 = p.first + dr[(d + 1) % 8], tc2 = p.second + dc[(d + 1) % 8];\r\n            int c2 = (empty_cell.find({tr2, tc2}) == empty_cell.end());\r\n            \r\n            if (c1 == c2) near.join(d, (d + 1) % 8);\r\n        }\r\n\r\n        for (int d = 1; d < 8; d += 2) {\r\n            int tr = p.first + dr[d], tc = p.second + dc[d];\r\n            if (empty_cell.find({tr, tc}) == empty_cell.end()) continue;\r\n            small.insert(near.find(d));\r\n        }\r\n\r\n        cnt_regions = small.size();\r\n        if (regions.find(component.find(cell[{infinity_cell}])) == regions.end()) return false;\r\n        return (regions.size() == cnt_regions); //all regions must be different components\r\n    }\r\n    \r\n    vector<int> solve_O_NxN() {\r\n        /*  We can check if a cell is 4-reachable from infinity in O(1) with\r\n            the help of dijoinst set. We can also determine if a cell is an\r\n            articulation the same way. Thus each time we are going to remove\r\n            a cell, we can just check all N possible skyscrapers.\r\n        */\r\n        infinity_cell = cell.begin()->first;\r\n        for (auto i : cell) infinity_cell = min(infinity_cell, i.first);\r\n\r\n        vector<int> res;\r\n        vis.assign(cell.size(), 0);\r\n        flood(infinity_cell, infinity_cell);\r\n        for (auto i : cell) {\r\n            if (empty_cell.find(i.first) == empty_cell.end()) continue;\r\n            flood(i.first, i.first);\r\n        }\r\n        while (full_cell.size() > 0) {\r\n            int candidate = -1;\r\n            pair<int, int> P;\r\n            for (auto &k : full_cell) {\r\n                if (is_valid(k.first) && k.second > candidate) {\r\n                    candidate = k.second;\r\n                    P = k.first;\r\n                }\r\n            }\r\n            res.push_back(candidate + 1);\r\n            full_cell.erase(full_cell.find(P));\r\n            empty_cell.insert({P, candidate});\r\n            component.join(cell[P], cell[infinity_cell]);\r\n            for (int d = 1; d < 8; d += 2) {\r\n                int tr = P.first + dr[d], tc = P.second + dc[d];\r\n                if (empty_cell.find({tr, tc}) == empty_cell.end()) continue;\r\n                component.join(cell[{tr, tc}], cell[P]);\r\n            }\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n\r\n}\r\n\r\n\r\nint main() {\r\n    int t;\r\n    cin >> N >> t;\r\n    \r\n    full_cell.reserve(2 * N);\r\n    empty_cell.reserve(10 * N);\r\n    cell.reserve(10 * N);\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        int r, c; cin >> r >> c;\r\n        full_cell.insert({{r, c}, cell.size()});\r\n        cell.insert({{r, c}, cell.size()});\r\n    }\r\n\r\n    for (auto i : full_cell) {\r\n        for (int d = 0; d < 8; d++) {\r\n            int tr = i.first.first + dr[d], tc = i.first.second + dc[d];\r\n            if (cell.find({tr, tc}) != cell.end()) continue;\r\n            empty_cell.insert({{tr, tc}, cell.size()});\r\n            cell.insert({{tr, tc}, cell.size()});\r\n        }\r\n    }\r\n\r\n    component.init(cell.size());\r\n\r\n    if (!validity_check::solution_exists()) {\r\n        cout << \"NO\\n\";\r\n        return 0;\r\n    }\r\n\r\n    cout << \"YES\\n\";\r\n    vector<int> ans = O_NxN::solve_O_NxN();\r\n    for (auto i : ans) cout << i << \"\\n\";\r\n\r\n}\r\n\r\n/*\r\n10\r\n1\r\n-1 -1\r\n-3 -1\r\n0 -1\r\n-3 -2\r\n0 0\r\n-2 -1\r\n-2 1\r\n-1 -2\r\n-2 -3\r\n-2 0\r\n\r\n*/"
}