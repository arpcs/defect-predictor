{
    "id": 196677488,
    "contestId": 1371,
    "creationTimeSeconds": 1678374282,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1371,
        "index": "E2",
        "name": "Asterism (Hard Version)",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1371,
        "members": [
            {
                "handle": "Pious"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1593610500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 10,
    "timeConsumedMillis": 61,
    "memoryConsumedBytes": 2867200,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long int\r\n#define fo(i, p, n) for (ll i = p; i < n; i++)\r\nconst ll MAXN = 1;\r\nconst ll M = 998244353;\r\n\r\n// long long binpow1(long long a, long long b, long long m) {\r\n//     a %= m;\r\n//     long long res = 1;\r\n//     while (b > 0) {\r\n//         if (b & 1)\r\n//             res = res * a % m;\r\n//         a = a * a % m;\r\n//         b >>= 1;\r\n//     }\r\n//     return res;\r\n// }\r\nlong long binpow(long long a, long long b)\r\n{\r\n\r\n\tlong long res = 1;\r\n\twhile (b > 0)\r\n\t{\r\n\t\tif (b & 1)\r\n\t\t\tres = res * a;\r\n\t\ta = a * a;\r\n\t\tb >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nunsigned long long power(unsigned long long x,\r\n\t\t\t\t\t\t ll y, ll p)\r\n{\r\n\tunsigned long long res = 1; // Initialize result\r\n\r\n\tx = x % p; // Update x if it is more than or\r\n\t// equal to p\r\n\r\n\twhile (y > 0)\r\n\t{\r\n\r\n\t\t// If y is odd, multiply x with result\r\n\t\tif (y & 1)\r\n\t\t\tres = (res * x) % p;\r\n\r\n\t\t// y must be even now\r\n\t\ty = y >> 1; // y = y/2\r\n\t\tx = (x * x) % p;\r\n\t}\r\n\treturn res % M;\r\n}\r\nunsigned long long modInverse(unsigned long long n,\r\n\t\t\t\t\t\t\t  ll p)\r\n{\r\n\treturn power(n, p - 2, p);\r\n}\r\n\r\nunsigned long long nCrModPFermat(unsigned long long n,\r\n\t\t\t\t\t\t\t\t ll r, ll p)\r\n{\r\n\t// If n<r, then nCr should return 0\r\n\tif (n < r)\r\n\t\treturn 0;\r\n\t// Base case\r\n\tif (r == 0)\r\n\t\treturn 1;\r\n\r\n\t// Fill factorial array so that we\r\n\t// can find all factorial of r, n\r\n\t// and n-r\r\n\tunsigned long long fac[n + 1];\r\n\tfac[0] = 1;\r\n\tfor (ll i = 1; i <= n; i++)\r\n\t\tfac[i] = (fac[i - 1] * i) % p;\r\n\r\n\treturn (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\r\n}\r\n\r\n// bool prime[1000100];\r\n// void isprime()\r\n// {\r\n//     memset(prime, true, sizeof(prime));\r\n\r\n//     for (ll p = 2; p * p < 1000100; p++)\r\n//     {\r\n//         if (prime[p] == true)\r\n//         {\r\n//             for (ll i = p * p; i < 1000100; i += p)\r\n//                 prime[i] = false;\r\n//         }\r\n//     }\r\n// }\r\n\r\nll fact(ll k)\r\n{\r\n\tif (k == 0)\r\n\t\treturn 1;\r\n\tif (k == 1)\r\n\t\treturn 1;\r\n\t// return k*fact(k-1);\r\n\treturn ((k % M) * (fact(k - 1) % M)) % M;\r\n}\r\n\r\n// void primefactor(ll n, vector<ll> &p)\r\n// {\r\n//     // Print the number of 2s that divide n\r\n//     while (n % 2 == 0)\r\n//     {\r\n//         p.push_back(2);\r\n//         n = n / 2;\r\n//     }\r\n\r\n//     // n must be odd at this point. So we can skip\r\n//     // one element (Note i = i +2)\r\n//     for (ll i = 3; i <= sqrt(n); i = i + 2)\r\n//     {\r\n//         // While i divides n, print i and divide n\r\n//         while (n % i == 0)\r\n//         {\r\n//             p.push_back(i);\r\n//             n = n / i;\r\n//         }\r\n//     }\r\n\r\n//     // This condition is to handle the case when n\r\n//     // is a prime number greater than 2\r\n//     if (n > 2)\r\n//         p.push_back(n);\r\n// }\r\n\r\n// ll smallestDivisor(ll n)\r\n// {\r\n//     // if divisible by 2\r\n//     if (n % 2 == 0)\r\n//         return 2;\r\n\r\n//     // iterate from 3 to sqrt(n)\r\n//     for (ll i = 3; i * i <= n; i += 2)\r\n//     {\r\n//         if (n % i == 0)\r\n//             return i;\r\n//     }\r\n\r\n//     return n;\r\n// }\r\n// vector< pair<ll, ll> > findSubArrays(ll arr[], ll n)\r\n// {\r\n//     // create an empty map\r\n//     unordered_map<ll, vector<ll> > map;\r\n\r\n//     // create an empty vector of pairs to store\r\n//     // subarray starting and ending index\r\n//     vector <pair<ll, ll>> out;\r\n\r\n//     // Maintains sum of elements so far\r\n//     ll sum = 0;\r\n\r\n//     for (ll i = 0; i < n; i++)\r\n//     {\r\n//         // add current element to sum\r\n//         sum += arr[i];\r\n\r\n//         // if sum is 0, we found a subarray starting\r\n//         // from index 0 and ending at index i\r\n//         if (sum == 0)\r\n//             out.push_back(make_pair(0, i));\r\n\r\n//         // If sum already exists in the map there exists\r\n//         // at-least one subarray ending at index i with\r\n//         // 0 sum\r\n//         if (map.find(sum) != map.end())\r\n//         {\r\n//             // map[sum] stores starting index of all subarrays\r\n//             vector<ll> vc = map[sum];\r\n//             for (auto it = vc.begin(); it != vc.end(); it++)\r\n//                 out.push_back(make_pair(*it + 1, i));\r\n//         }\r\n\r\n//         // Important - no else\r\n//         map[sum].push_back(i);\r\n//     }\r\n\r\n//     // return output vector\r\n//     return out;\r\n// }\r\n\r\n// // Utility function to print all subarrays with sum 0\r\n// // ll print(vector<pair<ll, ll>> out)\r\n// // {ll dp=1; ll pr=out.begin()->second;\r\n// //     for (auto it = out.begin()+1; it != out.end(); it++)\r\n// //         if(it->second>pr){dp++; pr=it->second;}\r\n// //         return dp;\r\n// // }\r\n// #define MAXN   (ll)1e7+1\r\n\r\n// // stores smallest prime factor for every number\r\nll spf[MAXN];\r\n\r\n// Calculating SPF (Smallest Prime Factor) for every\r\n// number till MAXN.\r\n// Time Complexity : O(nloglogn)\r\nvoid sieve()\r\n{\r\n\tspf[1] = 1;\r\n\tfor (ll i = 2; i < MAXN; i++)\r\n\r\n\t\t// marking smallest prime factor for every\r\n\t\t// number to be itself.\r\n\t\tspf[i] = i;\r\n\r\n\t// separately marking spf for every even\r\n\t// number as 2\r\n\tfor (ll i = 4; i < MAXN; i += 2)\r\n\t\tspf[i] = 2;\r\n\r\n\tfor (ll i = 3; i * i < MAXN; i++)\r\n\t{\r\n\t\t// checking if i is prime\r\n\t\tif (spf[i] == i)\r\n\t\t{\r\n\t\t\t// marking SPF for all numbers divisible by i\r\n\t\t\tfor (ll j = i * i; j < MAXN; j += i)\r\n\r\n\t\t\t\t// marking spf[j] if it is not\r\n\t\t\t\t// previously marked\r\n\t\t\t\tif (spf[j] == j)\r\n\t\t\t\t\tspf[j] = i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// A O(log n) function returning primefactorization\r\n// by dividing by smallest prime factor at every step\r\nvector<ll> getFactorization(ll x)\r\n{\r\n\tvector<ll> ret;\r\n\twhile (x != 1)\r\n\t{\r\n\t\tret.push_back(spf[x]);\r\n\t\tx = x / spf[x];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// C++ Program to count all subarrays having\r\n// XOR of elements as given value m with\r\n// O(n) time complexity.\r\n\r\n// Returns count of subarrays of arr with XOR\r\n// value equals to m\r\nlong long subarrayXor(ll arr[], ll n, ll m)\r\n{\r\n\tlong long ans = 0; // Initialize answer to be returned\r\n\r\n\t// Create a prefix xor-sum array such that\r\n\t// xorArr[i] has value equal to XOR\r\n\t// of all elements in arr[0 ..... i]\r\n\t// vector<ll>xorArr(n);\r\n\r\n\t// Create map that stores number of prefix array\r\n\t// elements corresponding to a XOR value\r\n\tunordered_map<ll, ll> mp;\r\n\r\n\t// Initialize first element of prefix array\r\n\t// xorArr[0] = arr[0];\r\n\tll cx = arr[0];\r\n\tll px = cx;\r\n\r\n\t// Computing the prefix array.\r\n\t// for (ll i = 1; i < n; i++)\r\n\t// \txorArr[i] = xorArr[i - 1] ^ arr[i];\r\n\r\n\t// Calculate the answer\r\n\tfor (ll i = 0; i < n; i++)\r\n\t{\r\n\t\tpx = cx;\r\n\t\tif (i != 0)\r\n\t\t\tcx = px ^ arr[i];\r\n\t\t// Find XOR of current prefix with m.\r\n\t\t// ll tmp = m ^ xorArr[i];\r\n\t\tll tmp = m ^ cx;\r\n\r\n\t\t// If above XOR exists in map, then there\r\n\t\t// is another previous prefix with same\r\n\t\t// XOR, i.e., there is a subarray ending\r\n\t\t// at i with XOR equal to m.\r\n\t\tans = ans + ((long long)mp[tmp]);\r\n\r\n\t\t// If this subarray has XOR equal to m itself.\r\n\t\tif (cx == m)\r\n\t\t\tans++;\r\n\r\n\t\t// Add the XOR of this subarray to the map\r\n\t\tmp[cx]++;\r\n\t}\r\n\r\n\t// Return total count of subarrays having XOR of\r\n\t// elements as given value m\r\n\treturn ans;\r\n}\r\n\r\n// Driver program to test above function\r\n\r\n// C++ Program to print prime factors and their\r\n// powers using Sieve Of Eratosthenes\r\n\r\n// Using SieveOfEratosthenes to find smallest prime\r\n// factor of all the numbers.\r\n// For example, if N is 10,\r\n// s[2] = s[4] = s[6] = s[10] = 2\r\n// s[3] = s[9] = 3\r\n// s[5] = 5\r\n// s[7] = 7\r\nvoid sieveOfEratosthenes(ll N, ll s[])\r\n{\r\n\t// Create a boolean array \"prime[0..n]\" and\r\n\t// initialize all entries in it as false.\r\n\tvector<bool> prime(N + 1, false);\r\n\r\n\t// Initializing smallest factor equal to 2\r\n\t// for all the even numbers\r\n\tfor (ll i = 2; i <= N; i += 2)\r\n\t\ts[i] = 2;\r\n\r\n\t// For odd numbers less than equal to n\r\n\tfor (ll i = 3; i <= N; i += 2)\r\n\t{\r\n\t\tif (prime[i] == false)\r\n\t\t{\r\n\t\t\t// s(i) for a prime is the number itself\r\n\t\t\ts[i] = i;\r\n\r\n\t\t\t// For all multiples of current prime number\r\n\t\t\tfor (ll j = i; j * i <= N; j += 2)\r\n\t\t\t{\r\n\t\t\t\tif (prime[i * j] == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tprime[i * j] = true;\r\n\r\n\t\t\t\t\t// i is the smallest prime factor for\r\n\t\t\t\t\t// number \"i*j\".\r\n\t\t\t\t\ts[i * j] = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Function to generate prime factors and its power\r\nmap<ll, ll> generatePrimeFactors(ll N)\r\n{\r\n\tmap<ll, ll> mp;\r\n\t// s[i] is going to store smallest prime factor\r\n\t// of i.\r\n\tll s[N + 1];\r\n\r\n\t// Filling values in s[] using sieve\r\n\tsieveOfEratosthenes(N, s);\r\n\r\n\t// printf(\"Factor Power\\n\");\r\n\r\n\tll curr = s[N]; // Current prime factor of N\r\n\tll dp = 1;\t\t// Power of current prime factor\r\n\r\n\t// Printing prime factors and their powers\r\n\twhile (N > 1)\r\n\t{\r\n\t\tN /= s[N];\r\n\r\n\t\t// N is now N/s[N]. If new N als has smallest\r\n\t\t// prime factor as curr, increment power\r\n\t\tif (curr == s[N])\r\n\t\t{\r\n\t\t\tdp++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// printf(\"%d\\t%d\\n\", curr, dp);\r\n\t\tmp[curr] = dp;\r\n\t\t// Update current prime factor as s[N] and\r\n\t\t// initializing count as 1.\r\n\t\tcurr = s[N];\r\n\t\tdp = 1;\r\n\t}\r\n\treturn mp;\r\n}\r\n\r\nbool isKthBitSet(int n, int k)\r\n{\r\n\tif (n & (1 << k))\r\n\t\treturn true;\r\n\telse\r\n\t\treturn false;\r\n}\r\n\r\nll getMid(ll s, ll e)\r\n{\r\n\treturn s + (e - s) / 2;\r\n}\r\n\r\n/*  A recursive function to get the sum of\r\n\tvalues in given range of the array.\r\n\tThe following are parameters for this\r\n\tfunction.\r\n\r\n\tst       -> Pointer to segment tree\r\n\tnode     -> Index of current node in\r\n\t\t\t\tthe segment tree .\r\n\tss & se  -> Starting and ending indexes\r\n\t\t\t\tof the segment represented\r\n\t\t\t\tby current node, i.e., st[node]\r\n\tl & r    -> Starting and ending indexes\r\n\t\t\t\tof range query */\r\nll MaxUtil(ll *st, ll ss, ll se, ll l,\r\n\t\t   ll r, ll node)\r\n{\r\n\t// If segment of this node is completely\r\n\t// part of given range, then return\r\n\t// the max of segment\r\n\tif (l <= ss && r >= se)\r\n\t\treturn st[node];\r\n\r\n\t// If segment of this node does not\r\n\t// belong to given range\r\n\tif (se < l || ss > r)\r\n\t\treturn -1;\r\n\r\n\t// If segment of this node is partially\r\n\t// the part of given range\r\n\tll mid = getMid(ss, se);\r\n\r\n\treturn max(MaxUtil(st, ss, mid, l, r,\r\n\t\t\t\t\t   2 * node + 1),\r\n\t\t\t   MaxUtil(st, mid + 1, se, l,\r\n\t\t\t\t\t   r, 2 * node + 2));\r\n}\r\n\r\n/* A recursive function to update the nodes\r\n   which have the given index in their range.\r\n   The following are parameters st, ss and\r\n   se are same as defined\r\n   above index -> index of the element\r\n   to be updated.*/\r\nvoid updateValue(ll arr[], ll *st, ll ss, ll se,\r\n\t\t\t\t ll index, ll value, ll node)\r\n{\r\n\tif (index < ss || index > se)\r\n\t{\r\n\t\tcout << \"Invalid Input\" << endl;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ss == se)\r\n\t{\r\n\t\t// update value in array and in segment tree\r\n\t\tarr[index] = value;\r\n\t\tst[node] = value;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tll mid = getMid(ss, se);\r\n\r\n\t\tif (index >= ss && index <= mid)\r\n\t\t\tupdateValue(arr, st,\r\n\t\t\t\t\t\tss, mid, index,\r\n\t\t\t\t\t\tvalue, 2 * node + 1);\r\n\t\telse\r\n\t\t\tupdateValue(arr,\r\n\t\t\t\t\t\tst, mid + 1, se,\r\n\t\t\t\t\t\tindex,\r\n\t\t\t\t\t\tvalue, 2 * node + 2);\r\n\r\n\t\tst[node] = max(st[2 * node + 1],\r\n\t\t\t\t\t   st[2 * node + 2]);\r\n\t}\r\n\treturn;\r\n}\r\n\r\n// Return max of elements in range from\r\n// index l (query start) to r (query end).\r\nll getMax(ll *st, ll n, ll l, ll r)\r\n{\r\n\t// Check for erroneous input values\r\n\tif (l < 0 || r > n - 1 || l > r)\r\n\t{\r\n\t\tprintf(\"Invalid Input\");\r\n\t\treturn -1;\r\n\t}\r\n\r\n\treturn MaxUtil(st, 0, n - 1, l, r, 0);\r\n}\r\n\r\n// A recursive function that constructs Segment\r\n// Tree for array[ss..se]. si is index of\r\n// current node in segment tree st\r\nll constructSTUtil(ll arr[], ll ss, ll se,\r\n\t\t\t\t   ll *st, ll si)\r\n{\r\n\t// If there is one element in array, store\r\n\t// it in current node of\r\n\t// segment tree and return\r\n\tif (ss == se)\r\n\t{\r\n\t\tst[si] = arr[ss];\r\n\t\treturn arr[ss];\r\n\t}\r\n\r\n\t// If there are more than one elements, then\r\n\t// recur for left and right subtrees and\r\n\t// store the max of values in this node\r\n\tll mid = getMid(ss, se);\r\n\r\n\tst[si] = max(constructSTUtil(arr, ss, mid, st,\r\n\t\t\t\t\t\t\t\t si * 2 + 1),\r\n\t\t\t\t constructSTUtil(arr, mid + 1, se,\r\n\t\t\t\t\t\t\t\t st, si * 2 + 2));\r\n\r\n\treturn st[si];\r\n}\r\n\r\n/* Function to construct segment tree\r\n   from given array.\r\n   This function allocates memory for\r\n   segment tree.*/\r\nll *constructST(ll arr[], ll n)\r\n{\r\n\t// Height of segment tree\r\n\tll x = (ll)(ceil(log2(n)));\r\n\r\n\t// Maximum size of segment tree\r\n\tll max_size = 2 * (ll)pow(2, x) - 1;\r\n\r\n\t// Allocate memory\r\n\tll *st = new ll[max_size];\r\n\r\n\t// Fill the allocated memory st\r\n\tconstructSTUtil(arr, 0, n - 1, st, 0);\r\n\r\n\t// Return the constructed segment tree\r\n\treturn st;\r\n}\r\n\r\nbool isPrime(ll n)\r\n{\r\n\t// Since 0 and 1 is not prime\r\n\t// return false.\r\n\tif (n == 1 || n == 0)\r\n\t\treturn false;\r\n\r\n\t// Run a loop from 2 to\r\n\t// square root of n.\r\n\tfor (ll i = 2; i * i <= n; i++)\r\n\t{\r\n\t\t// If the number is divisible by i,\r\n\t\t// then n is not a prime number.\r\n\t\tif (n % i == 0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\t// Otherwise n is a prime number.\r\n\treturn true;\r\n}\r\n\r\nll longest_increasing_subsequence(vector<ll> &arr)\r\n{\r\n\tvector<ll> ans;\r\n\tll n = arr.size();\r\n\tfor (ll i = 0; i < n; i++)\r\n\t{\r\n\t\tauto it = upper_bound(ans.begin(), ans.end(), arr[i]);\r\n\t\tif (it == ans.end())\r\n\t\t{\r\n\t\t\tans.push_back(arr[i]);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t*it = arr[i];\r\n\t\t}\r\n\t}\r\n\treturn ans.size();\r\n}\r\n\r\nll gcdExtended(ll a, ll b, ll *x, ll *y);\r\n\r\n// Function to find modulo inverse of b. It returns\r\n// -1 when inverse doesn't\r\nll modInverse(ll b, ll m)\r\n{\r\n\tll x, y; // used in extended GCD algorithm\r\n\tll g = gcdExtended(b, m, &x, &y);\r\n\r\n\t// Return -1 if b and m are not co-prime\r\n\tif (g != 1)\r\n\t\treturn -1;\r\n\r\n\t// m is added to handle negative x\r\n\treturn (x % m + m) % m;\r\n}\r\n\r\n// Function to compute a/b under modulo m\r\nll modDivide(ll a, ll b, ll m)\r\n{\r\n\ta = a % m;\r\n\tll inv = modInverse(b, m);\r\n\tif (inv == -1)\r\n\t\tprintf(\"Division not defined\");\r\n\telse\r\n\t{\r\n\t\tll c = (inv * a) % m;\r\n\t\t// printf (\"Result of division is %d\", c) ;\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n// C function for extended Euclidean Algorithm (used to\r\n// find modular inverse.\r\nll gcdExtended(ll a, ll b, ll *x, ll *y)\r\n{\r\n\t// Base Case\r\n\tif (a == 0)\r\n\t{\r\n\t\t*x = 0, *y = 1;\r\n\t\treturn b;\r\n\t}\r\n\r\n\tll x1, y1; // To store results of recursive call\r\n\tll gcd = gcdExtended(b % a, a, &x1, &y1);\r\n\r\n\t// Update x and y using results of recursive\r\n\t// call\r\n\t*x = y1 - (b / a) * x1;\r\n\t*y = x1;\r\n\r\n\treturn gcd;\r\n}\r\n\r\nvoid solve()\r\n{\r\n\tll n,p; cin>>n>>p;\r\n\tll a[n];\r\n\tfo(i,0,n){cin>>a[i];}\r\n\tsort(a,a+n);\r\n\tvector<ll>vp;\r\n\tll bas=0;\r\n\tll bk[262144]={0};\r\n\tfor(ll i=0;i<n;i++){\r\n    \r\n    bas=max(a[i],bas);\r\n  }\r\n  for(ll i=0;i<n;i++){bk[max(0ll,a[i]-bas+n)]++;}\r\n  for(ll i=1;i<262144;i++){bk[i]+=bk[i-1];}\r\n \r\n  ll st=1;\r\n  for(ll i=1;i<=n;i++){\r\n    while(bk[st+(i-1)]<i){st++;}\r\n  }\r\n  st+=(bas-n);\r\nll i=0;\r\nll t=a[n-1];\r\n\twhile(i<n){\r\n\t\tll d=upper_bound(a,a+n,t)-a;\r\n\t\t\r\n\t\td-=i;\r\n\t\tif(d>=p)t--;\r\n\t\telse i++;\r\n\r\n\t}\r\n\tif(st>t){cout<<\"0\\n\";return;}\r\ncout<<t-st+1<<\"\\n\";\r\nfo(i,st,t+1){cout<<i<<\" \";}\r\n}\r\n\r\nint main()\r\n{ // {freopen(\"input.txt\", \"r\", stdin);\r\n\t// \tfreopen(\"output.txt\", \"w\", stdout);\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\r\n\tll t = 1;\r\n\r\n\t//cin >> t;\r\n\r\n\twhile (t--)\r\n\t{\r\n\t\tsolve();\r\n\t}\r\n\r\n\t// return 0;\r\n}"
}