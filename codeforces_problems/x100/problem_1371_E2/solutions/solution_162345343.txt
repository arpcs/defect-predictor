{
    "id": 162345343,
    "contestId": 1371,
    "creationTimeSeconds": 1656596591,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1371,
        "index": "E2",
        "name": "Asterism (Hard Version)",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1371,
        "members": [
            {
                "handle": "NK_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1593610500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 100,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 5734400,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n/////////////////////// MACROS ////////////////////////////////////////////\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing db = double;\r\nusing str = string;\r\n\r\nusing pi = pair<int,int>;\r\nusing pl = pair<ll,ll>;\r\n\r\nusing vi = vector<int>;\r\nusing vl = vector<ll>;\r\nusing vs = vector<str>;\r\nusing vc = vector<char>;\r\nusing vpi = vector<pi>;\r\nusing vpl = vector<pl>;\r\n\r\n\r\n#define tcT template<class T\r\n#define tcTU tcT, class U\r\ntcT> using V = vector<T>;\r\ntcT, size_t SZ> using AR = array<T,SZ>;\r\ntcTU> using PR = pair<T,U>;\r\ntcTU> using umap = unordered_map<T, U>;\r\ntcT> using uset = unordered_set<T>;\r\ntcT> using mset = multiset<T>;\r\n\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n\r\n#define sz(x) int((x).size())\r\n#define all(x) begin(x), end(x)\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define rsz resize\r\n#define ins insert\r\n#define ft front()\r\n#define bk back()\r\n#define ppb pop_back()\r\n#define ppf pop_front()\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define pf push_front\r\n\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n\r\n// LOOPS\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define rep(a) F0R(_, a)\r\n#define each(a,x) for (auto& a: x)\r\n\r\n/////////////////////// IMPORANT VARS /////////////////////////////////////\r\n\r\nconst int MOD = 1e9+7; // 998244353;\r\nconst int MX = 2e5+5;\r\nconst ll INFL = ll(3e18)+10;\r\nconst int INF = int(1e9)+10;\r\nconst ld PI = acos((ld)-1);\r\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\r\ntcT> using pqg = priority_queue<T,vector<T>,greater<T>>;\r\ntcT> using pql = priority_queue<T,vector<T>,less<T>>;\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n#define nl '\\n'\r\n\r\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\r\nconstexpr int bits(int x) { \r\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); }\r\nconstexpr int p2(int x) { return 1<<x; }\r\nconstexpr int msk2(int x) { return p2(x)-1; }\r\n \r\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\r\n \r\ntcT> bool ckmin(T& a, const T& b) {\r\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\r\ntcT> bool ckmax(T& a, const T& b) {\r\n\treturn a < b ? a = b, 1 : 0; }\r\n \r\ntcTU> T fstTrue(T lo, T hi, U f) {\r\n\thi ++; assert(lo <= hi); // assuming f is increasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo)/2;\r\n\t\tf(mid) ? hi = mid : lo = mid+1; \r\n\t} \r\n\treturn lo;\r\n}\r\ntcTU> T lstTrue(T lo, T hi, U f) {\r\n\tlo --; assert(lo <= hi); // assuming f is decreasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo+1)/2;\r\n\t\tf(mid) ? lo = mid : hi = mid-1;\r\n\t} \r\n\treturn lo;\r\n}\r\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\r\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\r\ntcTU> void erase(T& t, const U& u) { // don't erase\r\n\tauto it = t.find(u); assert(it != end(t));\r\n\tt.erase(it); } // element that doesn't exist from (multi)set\r\n\r\n\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// using namespace __gnu_pbds;\r\n\r\n// tcT> using iset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; \r\n// #define ook order_of_key\r\n// #define fbo find_by_order\r\n\r\n// struct chash { \r\n// \tconst uint64_t C = ll(2e18*PI)+71;\r\n// \tconst int RANDOM = rng();\r\n// \tll operator()(ll x) const {\r\n// \t\treturn __builtin_bswap64((x^RANDOM)*C); }\r\n// };\r\n// template<class K,class V> using um = unordered_map<K,V,chash>;\r\n// template<class K,class V> using ht = gp_hash_table<K,V,chash>;\r\n// template<class K,class V> V get(ht<K,V>& u, K x) {\r\n// \tauto it = u.find(x); return it == end(u) ? 0 : it->s; }\r\n\r\n/////////////////////// OUPUT /////////////////////////////////////////////\r\n#define ts to_string\r\nstr ts(char c) { return str(1,c); }\r\nstr ts(const char* s) { return (str)s; }\r\nstr ts(str s) { return s; }\r\nstr ts(bool b) {\r\n\t#ifdef LOCAL\r\n\t\treturn b ? \"true\" : \"false\";\r\n\t#else\r\n\t\treturn ts((int)b);\r\n\t#endif\r\n}\r\ntcTU> str ts(pair<T,U> p) {\r\n\t#ifdef LOCAL\r\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\";\r\n\t#else\r\n\t\treturn ts(p.f)+\" \"+ts(p.s);\r\n\t#endif\r\n}\r\n\r\ntcTU> str ts(V<pair<T, U>> v) {\r\n\t#ifdef LOCAL\r\n\t\tbool fst = 1; str res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\t#endif\r\n}\r\n\r\ntcT> str ts(T v) {\r\n\t#ifdef LOCAL\r\n\t\tbool fst = 1; str res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\r\n\t#endif\r\n}\r\n\r\n///////////////////////// DEBUG ///////////////////////////////////////////\r\n#define tcTUU tcT, class ...U\r\nvoid DBG() { cerr << \"]\" << endl; }\r\ntcTUU> void DBG(const T& t, const U&... u) {\r\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\r\n\tDBG(u...); }\r\n#ifdef LOCAL\r\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\r\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\r\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\r\n#else\r\n\t#define dbg(...) 0\r\n\t#define chk(...) 0\r\n#endif\r\n\r\n///////////////////////// FILE I/O ////////////////////////////////////////\r\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\r\nvoid setPrec() { cout << fixed << setprecision(15); }\r\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\r\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\nvoid setIO(str s = \"\") {\r\n\tunsyncIO(); setPrec();\r\n\t#ifndef LOCAL\t\r\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for USACO\r\n\t#endif\r\n}\r\n\r\n///////////////////////// TEMPLATE ABOVE //////////////////////////////////\r\n\r\n// REMEMBER\r\n// - Don't Focus On Only One Approach\r\n// - Read And Understand Problem Fully\r\n// - Think Of Edges Cases\r\n// - Implement Carefully\r\n// - Always Check For Overflows\r\n// - Reset Global Variables\r\n// - Don't get discouraged, you can pull it back\r\n\r\nvoid solve() {\r\n\tint N, P; cin >> N >> P;\r\n\tvi A(N); each(x, A) cin >> x;\r\n\tsort(all(A));\r\n\tint L = 0; F0R(i, N) ckmax(L, A[i]-i);\r\n\tint R = A[P-1];\r\n\r\n\tif (L > R) {\r\n\t\tcout << 0 << nl;\r\n\t\tcout << nl;\r\n\t\treturn;\r\n\t}\r\n\r\n\tdbg(L, R);\r\n\tvi pos;\r\n\tvi vis(R-L+1);\r\n\tF0R(i, N) {\r\n\t\tint x = L;\r\n\t\tint v = (i-A[i]+x+1)%P;\r\n\t\tx += (P-v)%P;\r\n\r\n\t\tif (x <= min(A[i], R)) pos.pb(x);\r\n\t}\t\r\n\tdbg(pos);\r\n\r\n\teach(v, pos) {\r\n\t\tint x = v;\r\n\t\twhile(x <= R && !vis[x-L]) {\r\n\t\t\tdbg(x, x-L);\r\n\t\t\tvis[x-L] = 1;\r\n\t\t\tx += P;\r\n\t\t}\r\n\t}\t\r\n\r\n\tvi ans;\r\n\tF0R(x, sz(vis)) {\r\n\t\tdbg(x, x+L);\r\n\t\tif (!vis[x]) ans.pb(x+L);\r\n\t}\r\n\tcout << sz(ans) << nl;\r\n\tcout << ts(ans) << nl;\r\n}\r\n\r\nint main() {\r\n\tsetIO(); \r\n\r\n\tint TT = 1;\r\n\t// cin >> TT;\r\n\r\n\trep(TT) solve();\r\n\t\r\n\texit(0-0);\r\n}\r\n"
}