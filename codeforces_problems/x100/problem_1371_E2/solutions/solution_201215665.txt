{
    "id": 201215665,
    "contestId": 1371,
    "creationTimeSeconds": 1680932898,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1371,
        "index": "E2",
        "name": "Asterism (Hard Version)",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1371,
        "members": [
            {
                "handle": "Mc3X"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1593610500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 6,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 2457600,
    "source": "#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n \r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\nusing namespace std;\r\nusing i64 = uint64_t;\r\n//using i128 = __int128;\r\n#define MAXN 100005\r\n#define MAXM 2525\r\n#define MAXK 65\r\n#define MAXT 102\r\n#define OP 0\r\n#define CLO 1\r\n#define PLUS 0\r\n#define MINUS 1\r\n#define MUL 2\r\n#define HORZ 0\r\n#define VERT 1\r\n#define ITER 1000\r\n#define INF 1e18\r\n#define EPS 1e-9\r\n#define MOD 1000000007\r\n#define SRC 0\r\n#define PUSH 0\r\n#define POP 1\r\n#define PI acos(-1)\r\n#define UNVISITED INF\r\n#define FOR 0\r\n#define BACK 1\r\n#define OK 2\r\n#define H 18\r\n#define HSH 3\r\ntypedef long long ll;\r\ntypedef ll hash_t;\r\ntypedef __int128_t lint;\r\ntypedef long double ld;\r\ntypedef pair<int,int> ii;\r\ntypedef pair<int,ll> ilp;\r\ntypedef pair<ll,ii> pl;\r\ntypedef pair<ll, ll> pll;\r\ntypedef pair<ll,int> ppll;\r\ntypedef pair<ll,int> li;\r\ntypedef pair<ll,ll> iv;\r\ntypedef pair<double,int> ip;\r\ntypedef tuple<int,int,int> iii;\r\ntypedef tuple<ll, ll, ll> tll;\r\ntypedef tuple<ld, int, int> iit;\r\ntypedef tuple<int,int,ll> i3;\r\ntypedef vector<vector<ll>> vv;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\ntypedef vector<ii> vii;\r\ntypedef vector<vector<ll>> vll;\r\n//typedef complex<ld> cd;\r\ntypedef tuple<ll,int,int> tpl;\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ppb pop_back\r\n#define ppf pop_front\r\n#define pf push_front\r\n#define bk back()\r\n#define frnt front()\r\n#define ins insert\r\n#define er erase\r\n#define sc second\r\n#define fr first\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define repl(i,x,y) for (int i = (x); i <= (y); ++i)\r\n#define rep(i,x,y) for (int i = (x); i < (y); ++i)\r\n#define rev(i,x,y) for (int i = (x); i >= (y); --i)\r\n#define repd(i,x,y,d) for (int i = (x); i < (y); i += (d))\r\n#define LSOne(S) (S & (-S))\r\n#define trav(i,v) for (auto &i : v)\r\n#define foreach(it,v) for (auto it = begin(v); it != end(v); ++it)\r\n#define bend(v) begin(v), end(v)\r\n#define rbend(v) (v).rbegin(), (v).rend()\r\n#define sortarr(v) sort(bend(v))\r\n#define rsortarr(v) sort(rbend(v))\r\n#define rdup(v) v.er(unique(bend(v)), end(v))\r\n#define rstreak(v) v.resize(unique(bend(v)) - begin(v))\r\n#define extend(A,B) A.insert(end(A), bend(B))\r\n#define sz(A) (int)(A.size())\r\n#define fill(V) iota(bend(V), (0))\r\n#define vfill(V, st) iota(bend(V), st)\r\n#define sum(V) accumulate(bend(V), 0LL)\r\n#define vsum(V, st) accumulate(bend(V), (ll)(st))\r\n#define freq(V, amt) (int)(count(bend(V), amt))\r\ntemplate<class T> bool ckmin(T &a, T b) { return a > b ? a = b, 1 : 0; };\r\ntemplate<class T> bool ckmax(T &a, T b) { return a < b ? a = b, 1 : 0; };\r\ntemplate<class T> void amax(T &a, T b, T c) { a = max(b, c); };\r\ntemplate<class T> void amin(T &a, T b, T c) { a = min(b, c); };\r\ntemplate<class T> T getmax(vector<T> &v) { return *max_element(bend(v)); };\r\ntemplate<class T> T getmin(vector<T> &v) { return *min_element(bend(v)); };\r\ntemplate<class vi> void distinct(vi &a) { sortarr(a); rdup(a); };\r\ntemplate<class T> int compress(vector<T> &v, T val) { return (int)(lower_bound(bend(v), val) - begin(v)); };\r\ntemplate<class T> auto vfind(vector<T> &v, T val) {\r\n    return find(bend(v), val);\r\n}\r\ntemplate<class T> auto verase(vector<T> &v, T val) {\r\n    return v.er(vfind(v, val));\r\n}\r\ntemplate<class T> void revarr(vector<T> &v) { reverse(bend(v)); };\r\ntemplate<class T> void print(vector<T> &v, char end) { trav(i,v) cout << i << end;\r\n}\r\n \r\nmt19937 gen((int)(chrono::steady_clock::now().time_since_epoch().count()));\r\nll rng(ll l,ll r) {return uniform_int_distribution<ll>(l,r)(gen);}\r\n \r\nvoid fast_io() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL); cout.tie(NULL);\r\n}\r\n \r\nll gcd(ll a, ll b) {\r\n    if (!a) return b;\r\n    return gcd(b % a, a);\r\n}\r\n \r\nvector<ii> mv = {{-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}};\r\n\r\nint main() {\r\n    fast_io();\r\n    //int t; cin >> t;\r\n    //while (t--) solve();\r\n    int n,p; cin >> n >> p;\r\n    vi v(n);\r\n    trav(i,v) cin >> i;\r\n    rsortarr(v);\r\n    //find the starting amount such that the last element has a valid slot\r\n    int st = max(v.front() - (n - 1), 0);\r\n    //st = 4;\r\n    int shift = 0;\r\n    vi d;\r\n    bool has0 = false;\r\n    vector<bool> fixed(n);\r\n    rep(i,0,n) {\r\n        int num = (v[i] > st) ? n - (v[i] - st) - i : n - i;\r\n        if (num <= 0) {\r\n            ckmax(shift, min(v[i] - st, num + 1));\r\n        } else {\r\n            //if there is a slot factor that is divisible by p then it is impossible\r\n            //because it is a constant and cannot change\r\n            if (v[i] <= st && (n - i) % p == 0) has0 = true;\r\n            if (v[i] <= st) fixed[i] = true;\r\n            assert(num >= 0);\r\n            d.pb(num);\r\n        }\r\n    }\r\n    if (has0) {\r\n        cout << 0;\r\n        return 0;\r\n    }\r\n    //if the number of slots drops to 0 or below then we need to correct it\r\n    //to get a non-zero amount of valid permutations for any x\r\n    if (shift) {\r\n        d.clear();\r\n        st = max(v.front() - (n - 1) + shift, 0);\r\n        rep(i,0,n) {\r\n            fixed[i] = false;\r\n            int num = (v[i] > st) ? n - (v[i] - st) - i : n - i;\r\n            if (v[i] <= st && (n - i) % p == 0) has0 = true;\r\n            if (v[i] <= st) fixed[i] = true;\r\n            assert(num >= 0);\r\n            d.pb(num);\r\n        }\r\n    }\r\n    if (has0) {\r\n        cout << 0;\r\n        return 0;\r\n    }\r\n    vi cnt(p);\r\n    rep(i,0,n) {\r\n        if (!fixed[i]) cnt[(d[i] % p)]++;\r\n    }\r\n    vi ans;\r\n    int hi = v.front();\r\n    rep(i,st,hi) {\r\n        while (!v.empty() && v.back() <= i) {\r\n            //if originally this index is larger than the starting index\r\n            //then now its position is fixed because it can be placed anywhere in the permutation\r\n            if (!fixed[sz(v) - 1]) cnt[(d[sz(v) - 1] % p)]--;\r\n            if ((n - sz(v) + 1) % p == 0) {\r\n                has0 = true;\r\n            }\r\n            v.pop_back();\r\n        }\r\n        if (has0) break;\r\n        int diff = (i - st) % p;\r\n        if (!cnt[(2 * p - diff) % p]) ans.pb(i);\r\n    }\r\n    cout << sz(ans) << '\\n';\r\n    trav(i,ans) cout << i << ' ';\r\n}"
}