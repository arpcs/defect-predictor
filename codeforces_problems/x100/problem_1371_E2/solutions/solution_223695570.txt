{
    "id": 223695570,
    "contestId": 1371,
    "creationTimeSeconds": 1694936222,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1371,
        "index": "E2",
        "name": "Asterism (Hard Version)",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1371,
        "members": [
            {
                "handle": "Profect"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1593610500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 100,
    "timeConsumedMillis": 78,
    "memoryConsumedBytes": 40857600,
    "source": "//#pragma GCC optimize(\"Ofast\")\r\n//#pragma GCC optimize (\"unroll-loops\")\r\n//#pragma GCC target(\"avx,avx2\")\r\n\r\n#include \"bits/stdc++.h\"\r\n//#include <ext/pb_ds/assoc_container.hpp>\r\n\r\nusing namespace std;\r\n//using namespace __gnu_pbds;\r\n\r\n#define int long long\r\n#define ff first\r\n#define ss second\r\n#define sz(a) (int) (a).size()\r\n//template<class T, class C = null_type> using ordered_tree = tree<T, C, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntypedef long double ld;\r\n\r\nnamespace io {\r\n\r\n    template<typename F, typename S>\r\n    ostream &operator<<(ostream &os, const pair<F, S> &p) { return os << p.ff << \" \" << p.ss; }\r\n\r\n    template<typename F, typename S>\r\n    ostream &operator<<(ostream &os, const map<F, S> &mp) {\r\n        for (auto it: mp) { os << it << endl; }\r\n        return os;\r\n    }\r\n\r\n    template<typename F>\r\n    ostream &operator<<(ostream &os, const vector<F> &v) {\r\n        bool space = false;\r\n        for (F x: v) {\r\n            if (space) os << \" \";\r\n            space = true;\r\n            os << x;\r\n        }\r\n        return os;\r\n    }\r\n\r\n    template<typename F>\r\n    ostream &operator<<(ostream &os, const deque<F> &d) {\r\n        bool space = false;\r\n        for (F x: d) {\r\n            if (space) os << \" \";\r\n            space = true;\r\n            os << x;\r\n        }\r\n        return os;\r\n    }\r\n\r\n    template<typename F>\r\n    ostream &operator<<(ostream &os, const set<F> &st) {\r\n        bool space = false;\r\n        for (F x: st) {\r\n            if (space) os << \" \";\r\n            space = true;\r\n            os << x;\r\n        }\r\n        return os;\r\n    }\r\n\r\n    template<typename F>\r\n    ostream &operator<<(ostream &os, const multiset<F> &st) {\r\n        bool space = false;\r\n        for (F x: st) {\r\n            if (space) os << \" \";\r\n            space = true;\r\n            os << x << x;\r\n        }\r\n        return os;\r\n    }\r\n\r\n    template<typename F, typename S>\r\n    istream &operator>>(istream &is, pair<F, S> &p) { return is >> p.ff >> p.ss; }\r\n\r\n    template<typename F>\r\n    istream &operator>>(istream &is, vector<F> &v) {\r\n        for (F &x: v) { is >> x; }\r\n        return is;\r\n    }\r\n\r\n    long long fastread() {\r\n        char c;\r\n        long long d = 1, x = 0;\r\n        do c = getchar(); while (c == ' ' || c == '\\n');\r\n        if (c == '-') c = getchar(), d = -1;\r\n        while (isdigit(c)) {\r\n            x = x * 10 + c - '0';\r\n            c = getchar();\r\n        }\r\n        return d * x;\r\n    }\r\n\r\n    static bool sep = false;\r\n\r\n    using std::to_string;\r\n\r\n    string to_string(bool x) {\r\n        return (x ? \"true\" : \"false\");\r\n    }\r\n\r\n    string to_string(const string &s) { return \"\\\"\" + s + \"\\\"\"; }\r\n\r\n    string to_string(const char *s) { return \"\\\"\" + string(s) + \"\\\"\"; }\r\n\r\n    string to_string(const char &c) {\r\n        string s;\r\n        s += c;\r\n        return \"\\'\" + s + \"\\'\";\r\n    }\r\n\r\n    template<typename Type>\r\n    string to_string(vector<Type>);\r\n\r\n    template<typename F, typename S>\r\n    string to_string(pair<F, S>);\r\n\r\n    template<typename Collection>\r\n    string to_string(Collection);\r\n\r\n    template<typename F, typename S>\r\n    string to_string(pair<F, S> p) { return \"{\" + to_string(p.ff) + \", \" + to_string(p.ss) + \"}\"; }\r\n\r\n    template<typename Type>\r\n    string to_string(vector<Type> v) {\r\n        bool sep = false;\r\n        string s = \"[\";\r\n        for (Type x: v) {\r\n            if (sep) s += \", \";\r\n            sep = true;\r\n            s += to_string(x);\r\n        }\r\n        s += \"]\";\r\n        return s;\r\n    }\r\n\r\n    template<typename Collection>\r\n    string to_string(Collection collection) {\r\n        bool sep = false;\r\n        string s = \"{\";\r\n        for (auto x: collection) {\r\n            if (sep) s += \", \";\r\n            sep = true;\r\n            s += to_string(x);\r\n        }\r\n        s += \"}\";\r\n        return s;\r\n    }\r\n\r\n    void print() {\r\n        cout << endl;\r\n        sep = false;\r\n    }\r\n\r\n    template<typename F, typename... Other>\r\n    void print(F ff, Other... other) {\r\n        if (sep) cout << \" | \";\r\n        sep = true;\r\n        cout << to_string(ff);\r\n        print(other...);\r\n    }\r\n\r\n}\r\nusing namespace io;\r\n\r\nnamespace utils {\r\n\r\n    template<typename F, typename S>\r\n    inline void maxs(F &a, S b) { a = a > b ? a : b; }\r\n\r\n    template<typename F, typename S>\r\n    inline void mins(F &a, S b) { a = a < b ? a : b; }\r\n\r\n    template<typename F, typename S>\r\n    long long max(F a, S b) { return a > b ? a : b; }\r\n\r\n    template<typename F, typename S>\r\n    long long min(F a, S b) { return a < b ? a : b; }\r\n\r\n    constexpr long long operator \"\" _E(unsigned long long n) {\r\n        long long p = 1, a = 10;\r\n        for (int i = 0; i < n; i++) p *= a;\r\n        return p;\r\n    }\r\n\r\n    random_device rd;\r\n    mt19937 mt(rd());\r\n\r\n    template<typename T>\r\n    T rand(T l, T r) {\r\n        uniform_int_distribution<T> dist(l, r);\r\n        return dist(mt);\r\n    };\r\n\r\n}\r\nusing namespace utils;\r\n\r\n\r\n#ifdef sunnatov\r\n#define print(...) cout << \"[\" << #__VA_ARGS__ << \"]: \"; io::print( __VA_ARGS__ );\r\n#else\r\n#define print( ... ) 42\r\n#endif\r\n\r\nconst int mod = 9_E + 7;\r\nconst double EPS = 1e-7;\r\nlong long LLINF = 18_E + 10;\r\nint INF = 9_E;\r\nconst char nl = '\\n';\r\n\r\nint month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\r\n\r\n/*\r\n\r\n*/\r\n\r\ntemplate<typename T> struct sparse_table {\r\n    vector<vector<T>> rmq;\r\n    T calc(T a, T b) {\r\n        return std::min(a, b);\r\n    }\r\n    void build(vector<T> &a) {\r\n        int n = a.size();\r\n        int ln = 31 - __builtin_clz(n);\r\n        if ((1 << ln) < n) {\r\n            ln++;\r\n        }\r\n        rmq.assign(ln + 1, vector<T>(n));\r\n        for (int j = 0; j <= ln; j++) {\r\n            for (int i = 0; i <= n - (1 << j); i++) {\r\n                if (j > 0) {\r\n                    rmq[j][i] = calc(rmq[j - 1][i], rmq[j - 1][i + (1 << (j - 1))]);\r\n                } else {\r\n                    rmq[j][i] = a[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    T get(int l, int r) {\r\n        assert(l <= r);\r\n        int x = 31 - __builtin_clz(r - l + 1);\r\n        return calc(rmq[x][l], rmq[x][r - (1 << x) + 1]);\r\n    }\r\n};\r\n\r\nint get_mod(int x, int p) {return (x % p + p) % p; }\r\n\r\nvoid solution(istream &cin, ostream &cout, const int &test_case) {\r\n    int n, p;\r\n    cin >> n >> p;\r\n    vector<int> a(n), ans;\r\n    cin >> a;\r\n    sort(a.begin(), a.end());\r\n    int right = *max_element(a.begin(), a.end());\r\n    int left = right - n + 1;\r\n    vector<int> cnt(2 * n + 1);\r\n    vector<vector<int>> pos(p);\r\n    for (int i = left; i < left + sz(cnt); i++) {\r\n        cnt[i - left] = upper_bound(a.begin(), a.end(), i) - a.begin();\r\n        cnt[i - left] -= i;\r\n        pos[get_mod(cnt[i - left], p)].emplace_back(i);\r\n    }\r\n    print(left, cnt);\r\n    sparse_table<int> sp; sp.build(cnt);\r\n    for (int i = left; i <= right; i++) {\r\n        if (sp.get(i - left, i + n - 1 - left) + i < 0) continue;\r\n        int md = get_mod(-i, p);\r\n//        print(i, md);\r\n        int j = lower_bound(pos[md].begin(), pos[md].end(), i) - pos[md].begin();\r\n//        print(j, pos[md]);\r\n        if (j == pos[md].size() or pos[md][j] > i + n - 1) ans.emplace_back(i);\r\n    }\r\n    cout << sz(ans) << nl << ans;\r\n}\r\n\r\nint32_t main() {\r\n    clock_t startTime = clock();\r\n    cin.tie(0)->sync_with_stdio(false);\r\n    srand(time(0));\r\n\r\n    std::istream &in(std::cin);\r\n    std::ostream &out(std::cout);\r\n\r\n    int32_t queries = 1;\r\n\r\n#ifdef test_cases\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n    cin >> queries;\r\n#else\r\n//    cin >> queries;\r\n#endif\r\n\r\n    for (int32_t test_case = 1; test_case <= queries; test_case++) {\r\n        print(test_case);\r\n        solution(cin, cout, test_case);\r\n        cout << nl;\r\n    }\r\n\r\n#ifdef sunnatov\r\n    cout << \"Time: \" << (int) ((double) (clock() - startTime) / CLOCKS_PER_SEC * 1000) << \" ms\" << endl;\r\n#endif\r\n\r\n    return EXIT_SUCCESS;\r\n}\r\n"
}