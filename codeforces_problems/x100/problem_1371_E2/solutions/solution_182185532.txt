{
    "id": 182185532,
    "contestId": 1371,
    "creationTimeSeconds": 1669157037,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1371,
        "index": "E2",
        "name": "Asterism (Hard Version)",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 2300,
        "tags": [
            "binary search",
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1371,
        "members": [
            {
                "handle": "aufannn"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1593610500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 100,
    "timeConsumedMillis": 312,
    "memoryConsumedBytes": 23449600,
    "source": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#define int                                                             long long\r\n#define ll                                                              long long\r\n#define ld                                                              long double\r\n#define ull                                                             unsigned long long\r\n#define itn                                                             int\r\n#define sqrt                                                            sqrtl\r\n#define cbrt                                                            cbrtl\r\n#define pow                                                             powl\r\n#define floor                                                           floorl\r\n#define ceil                                                            ceill\r\n#define fi                                                              first\r\n#define se                                                              second\r\n#define range(a, b, c)                                                  a <= b && b <= c\r\n#define ckmin(a, b)                                                     a = min(a, b)\r\n#define ckmax(a, b)                                                     a = max(a, b)\r\n#define all(x)                                                          (x).begin(), (x).end()\r\n#define allr(x)                                                         (x).rbegin(), (x).rend()\r\n#define mp(a, b)                                                        make_pair(a, b)\r\n#define N                                                               1000005\r\n#define xyz                                                             1000005\r\n#define debug(x)                                                        cout << #x << \" => \" << x << \"\\n\";\r\n#define tc                                                              int t; cin >> t; while(t--) {solve();}\r\n#define slv                                                             solve();\r\n#define ordered_multiset                                                tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>\r\n#define ordered_set                                                     tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\r\n#define Aufan                                                           ios_base::sync_with_stdio(false);cin.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\nbitset<1000007> isPrime;\r\nconst int MOD=1e9+7;\r\nconst int mod=998244353;\r\nconst int INF=2e9;\r\nconst int INFF=4e18;\r\null fac[xyz];\r\null modin[xyz];\r\nstruct Point                                                            {int x;int y;};\r\ntemplate <typename T>T modx(T a,T b)                                    {return (a-1)%b+1;}\r\ntemplate <typename T>T modp(T a,T b)                                    {return (a%b+b)%b;}\r\ntemplate <typename T> void print(T v)                                   {for(auto x:v)cout<<x<<' ';cout<<'\\n';}\r\ntemplate <typename A, typename B> void print(map<A,B> m)                {for(auto x:m)cout<<x.fi<<' '<<x.se<<'\\n';}\r\ntemplate <typename A, typename B> void print(vector<pair<A,B>> v)       {for(auto x:v)cout<<x.fi<<' '<<x.se<<'\\n';}\r\ntemplate <typename T> map<T,int> freq_count(vector<T> v)                {int n=v.size();map<T,int> m;for(T x:v)m[x]++;return m;}\r\ntemplate <typename T> vector<pair<T,int>> group_count(vector<T> v)      {int n=v.size();vector<pair<T,int>> r;if(!n)return r;int c=1;for(int i=1;i<n;i++){if(v[i]==v[i-1])c++;else{r.push_back(make_pair(v[i-1],c));c=1;}}r.push_back(make_pair(v[n-1],c));return r;}\r\ntemplate <typename T> vector<T> prefix_sum(vector<T> v)                 {int n=v.size();vector<T> r(n+1,0);for(int i=0;i<n;i++) {r[i+1]=r[i]+v[i];}return r;}\r\ntemplate <typename A, typename B> vector<A> keys(map<A,B> m)            {vector<A> v;for(auto x:m) v.push_back(x.fi);return v;}\r\ntemplate <typename A, typename B> vector<B> values(map<A,B> m)          {vector<B> v;for(auto x:m) v.push_back(x.se);return v;}\r\nvector<pair<char,int>> group_count(string s)                            {return group_count(vector(all(s)));}\r\nmap<char,int> freq_count(string s)                                      {return freq_count(vector(all(s)));}\r\nint orientation(Point p,Point q,Point r)                                {int val=(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);if(val==0)return 0;return (val>0)?1:2;}\r\nbool onSegment(Point p,Point q,Point r)                                 {if(q.x<=max(p.x,r.x)&&q.x>=min(p.x,r.x)&&q.y<=max(p.y,r.y)&&q.y>=min(p.y,r.y))return true;return false;}\r\nbool doIntersect(Point p1,Point q1,Point p2,Point q2)                   {int o1=orientation(p1,q1,p2);int o2=orientation(p1,q1,q2);int o3=orientation(p2,q2,p1);int o4=orientation(p2,q2,q1);if(o1!=o2&&o3!=o4)return true;if(o1==0&&onSegment(p1,p2,q1))return true;if(o2==0&&onSegment(p1,q2,q1))return true;if(o3==0&&onSegment(p2,p1,q2))return true;if(o4==0&&onSegment(p2,q1,q2))return true;return false;}\r\nbool difdigit(int a)                                                    {int b=floor(log10(a)+1);int arr[10];memset(arr,0,sizeof(arr));while(a>0){arr[a%10]++;a/=10;}if(count(arr,arr+10,1)==b)return true;return false;}\r\nbool isPerfectSquare(int x)                                             {if(x>=0){int sr=sqrt(x);return (sr*sr==x);}return false;}\r\nbool isPal(int x)                                                       {string s=\"\";while(x){s+=x%10;x/=10;}string t=s;reverse(all(s));return s==t;}\r\nbool checkPrime(int x)                                                  {for(int i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\r\nchar letter(int n)                                                      {string alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";return alphabet[n];}\r\nchar number(int n)                                                      {string bruh=\"0123456789\"; return bruh[n];}\r\nstring balik(string s)                                                  {reverse(s.begin(),s.end());return s;}\r\nstring base10_2(int x)                                                  {if(x == 1)return \"1\";if(x%2)return base10_2(x/2)+\"1\";return base10_2(x/2)+\"0\";}\r\nstring to_upper(string s)                                               {string ret=\"\";for(auto c:s){ret.push_back(toupper(c));}return ret;}\r\nstring to_lower(string s)                                               {string ret=\"\";for(auto c:s){ret.push_back(tolower(c));}return ret;}\r\nint xorNih(int n)                                                       {if(n%4==0)return n;if(n%4==1)return 1;if(n%4==2)return n+1;return 0;}\r\nint base2_10(int x)                                                     {int output;for(int i=0;x>0;i++){if(x%10==1)output+=pow(2,i);x/=10;}return output;}\r\nint digitsum(int a)                                                     {int b=0;while(a>0){b+=a%10;a/=10;}return b;}\r\nint digitmul(int a)                                                     {int b=1;while(a>0){if(a%10)b*=a%10;a/=10;}return b;}\r\nint factorial(int a)                                                    {int b=1;while(a>0){b*=a;a--;}return b;}\r\nint ceildiv(int a, int b)                                               {int q;q=a/b+(a%b!=0);return q;}\r\nint binpow(int a, int b, int c)                                         {if(b==0)return 1;int d=binpow(a,b/2,c);return ((b%2?a%c:1)*((d*d)%c))%c;}\r\null power(ull x,int y)                                                  {ull res=1;x=x%MOD;while(y>0){if(y&1)res=(res*x)%MOD;y=y>>1;x=(x*x)%MOD;}return res;}\r\null modInverse(ull n)                                                   {return power(n,MOD-2);}\r\null nCrModPFermat(ull n,int r)                                          {if(n<r)return 0;if(r==0)return 1;return (fac[n]*modin[r]%MOD*modin[n-r]%MOD)%MOD;}\r\nvoid generatefac()                                                      {fac[0]=1;modin[0]=modInverse(1);for(int i=1;i<=xyz;i++){fac[i]=(fac[i-1]*i)%MOD;modin[i]=modInverse(fac[i]);}}\r\nvoid callprime()                                                        {for(int i=2;i<=1000000;i++){if(!isPrime[i]){int j=i*i;while(j<=1000000){isPrime[j]=true;j+=i;}}}isPrime.flip();isPrime[1]=false;}\r\n\r\nvoid solve() {\r\n        int n, p;\r\n        cin >> n >> p;\r\n        vector<int> v(n+5);\r\n        map<int, int> cnt;\r\n        for (int i = 1; i <= n; i++) {\r\n                cin >> v[i];\r\n                cnt[v[i]]++;\r\n        }\r\n        sort(v.begin() + 1, v.begin() + n + 1);\r\n        /*\r\n        ending gaboleh >= p -> n - move < p\r\n        move > n - p\r\n        */\r\n        int mv = n - p + 1;\r\n        int lf = max(v[1], v[n] - n + 1);\r\n        int rg = min(v[n] - mv, v[p] - 1);\r\n        int posrg = lf - 1;\r\n        if (rg < lf) {\r\n                cout << \"0\\n\";\r\n                return;\r\n        }\r\n        while (lf <= rg) {\r\n                int md = (lf + rg)/2;\r\n                int left = 1;\r\n                int right = n;\r\n                int possible = 1;\r\n                while (left <= right) {\r\n                        int mid = (left + right)/2;\r\n                        if (v[mid] <= md) {\r\n                                possible = mid;\r\n                                left = mid + 1;\r\n                        } else {\r\n                                right = mid - 1;\r\n                        }\r\n                }\r\n                int zz = md;\r\n                int cur = possible;\r\n                int done = 0;\r\n                int mx = 0;\r\n                while (cur > 0) {\r\n                        ckmax(mx, cur);\r\n                        cur--;\r\n                        done++;\r\n                        zz++;\r\n                        if (cnt.count(zz)) cur += cnt[zz];\r\n                }\r\n                // cout << md << \" \" << mx << '\\n';\r\n                if (mx < p && done == n) {\r\n                        posrg = md;\r\n                        lf = md + 1;\r\n                } else {\r\n                        rg = md - 1;\r\n                }\r\n        }\r\n        lf = max(v[1], v[n] - n + 1);\r\n        rg = min(v[n] - mv, v[p] - 1);\r\n        int poslf = rg + 1;\r\n        while (lf <= rg) {\r\n                int md = (lf + rg)/2;\r\n                int left = 1;\r\n                int right = n;\r\n                int possible = 1;\r\n                while (left <= right) {\r\n                        int mid = (left + right)/2;\r\n                        if (v[mid] <= md) {\r\n                                possible = mid;\r\n                                left = mid + 1;\r\n                        } else {\r\n                                right = mid - 1;\r\n                        }\r\n                }\r\n                int zz = md;\r\n                int cur = possible;\r\n                int done = 0;\r\n                int mx = 0;\r\n                while (cur > 0) {\r\n                        ckmax(mx, cur);\r\n                        cur--;\r\n                        done++;\r\n                        zz++;\r\n                        if (cnt.count(zz)) cur += cnt[zz];\r\n                }\r\n                // cout << md << \" \" << mx << '\\n';\r\n                if (mx < p && done == n) {\r\n                        poslf = md;\r\n                        rg = md - 1;\r\n                } else {\r\n                        lf = md + 1;\r\n                }\r\n        }\r\n        if (posrg < poslf) {\r\n                cout << \"0\\n\";\r\n                return;\r\n        }\r\n        cout << posrg - poslf + 1 << '\\n';\r\n        for (int i = poslf; i <= posrg; i++) {\r\n                cout << i << \" \";\r\n        }\r\n        cout << '\\n';\r\n\r\n        return;\r\n}\r\n\r\nint32_t main()\r\n{\r\n        Aufan\r\n        slv\r\n        return 0;\r\n}"
}