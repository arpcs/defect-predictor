{
    "id": 141579007,
    "contestId": 1236,
    "creationTimeSeconds": 1641234989,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "ivan100sic"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 122,
    "timeConsumedMillis": 390,
    "memoryConsumedBytes": 62976000,
    "source": "// Retired?\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nnamespace R = ranges;\r\nauto ra(auto x, auto y) { return R::iota_view(x, y); }\r\n\r\nusing ll = long long;\r\nusing ull = long unsigned long;\r\nusing ld = double long;\r\n\r\ntemplate<int m>\r\nstruct modint {\r\n    unsigned x;\r\n\r\n    modint() : x(0) {}\r\n    modint(long long arg) : x((arg %= m) < 0 ? arg + m : arg) {}\r\n\r\n    modint operator+ (const modint& b) const {\r\n        auto t = *this; t.x = (t.x += b.x) >= m ? t.x-m : t.x; return t;\r\n    }\r\n\r\n    modint operator- (const modint& b) const {\r\n        auto t = *this; t.x = (t.x += m-b.x) >= m ? t.x-m : t.x; return t;\r\n    }\r\n\r\n    modint operator* (const modint& b) const {\r\n        auto t = *this; t.x = ll(t.x) * b.x % m; return t;\r\n    }\r\n\r\n    modint operator/ (const modint& b) const {\r\n        return *this * b.inv();\r\n    }\r\n\r\n    template<class T> modint operator^ (T n) const {\r\n        modint t;\r\n        if (n == 0) return t.x = 1, t;\r\n        if (n == 1) return t.x = x, t;\r\n        t = *this ^ (n >> 1); t *= t;\r\n        return n & 1 ? *this * t : t;\r\n    }\r\n\r\n    modint& operator+= (const modint& b) { return *this = *this + b; }\r\n    modint& operator-= (const modint& b) { return *this = *this - b; }\r\n    modint& operator*= (const modint& b) { return *this = *this * b; }\r\n    modint& operator/= (const modint& b) { return *this = *this / b; }\r\n    modint& operator++ () { if (++x == m) x = 0; return *this; }\r\n    modint& operator-- () { if (x-- == 0) x = m-1; return *this; }\r\n    modint operator++ (int) { modint tmp = *this; ++*this; return tmp; }\r\n    modint operator-- (int) { modint tmp = *this; --*this; return tmp; }\r\n    bool operator== (const modint& other) const { return x == other.x; }\r\n    bool operator!= (const modint& other) const { return x != other.x; }\r\n    int operator() () const { return x; }\r\n    template<class T> modint operator^= (T n) { return *this = *this ^ n; }\r\n    modint inv() const { return *this ^ (m-2); }\r\n};\r\n\r\nconst int mod = 1000 * 1000 * 1000 + 7;\r\ntypedef modint<mod> mint;\r\n\r\nconst mint half = mint(1) / 2;\r\nmint pw2[1000005], pwh[1000005];\r\nint n, m;\r\nvector<int> e[500005];\r\n\r\nvector<vector<int>> bp;\r\nvector<int> paths_rooted[500005];\r\nint bpath[500005], bord[500005], par[500005];\r\n\r\nchar vis[500005];\r\nvoid dfs(int x, int p) {\r\n    par[x] = p;\r\n    vis[x] = 1;\r\n    for (int y : e[x]) {\r\n        if (y == p) continue;\r\n        if (!vis[y]) {\r\n            dfs(y, x);\r\n        } else if (vis[y] == 1) {\r\n            // b-e\r\n            int bid = ssize(bp);\r\n            bp.emplace_back();\r\n            for (int t=x, i=0; t!=y; t=par[t], i++) {\r\n                bpath[t] = bid;\r\n                bord[t] = i;\r\n                bp.back().push_back(t);\r\n            }\r\n            bp.back().push_back(y);\r\n            for (int t : bp.back()) {\r\n                paths_rooted[t].push_back(bid);\r\n            }\r\n        }\r\n    }\r\n    vis[x] = 2;\r\n}\r\n\r\nmint e_self[500005];\r\n\r\nint main() {\r\n    ios::sync_with_stdio(!cin.tie(0));\r\n\r\n    cin >> n >> m;\r\n    for (int i : ra(0, m)) {\r\n        int x, y;\r\n        cin >> x >> y;\r\n        e[x].push_back(y);\r\n        e[y].push_back(x);\r\n    }\r\n\r\n    pwh[0] = pw2[0] = 1;\r\n    pwh[1] = mint(1) / 2;\r\n    pw2[1] = 2;\r\n\r\n    for (int x : ra(2, 2*n+1)) pw2[x] = pw2[x-1] * 2;\r\n    for (int x : ra(2, 2*n+1)) pwh[x] = pwh[x-1] * half;\r\n\r\n    fill(bpath+1, bpath+n+1, -1);\r\n    dfs(1, -1);\r\n\r\n    mint ev = half * n;\r\n    mint ee = pwh[2] * m; // m / 4\r\n    mint ec = 0;\r\n    for (auto& path : bp) {\r\n        ec += pwh[size(path)];\r\n    }\r\n    mint ex = ev - ee + ec;\r\n\r\n    // V x V\r\n    mint evv = pwh[2] * n * (n+1);\r\n\r\n    // E x E\r\n    mint eee = 0;\r\n    {\r\n        // same edge\r\n        eee += pwh[2] * m;\r\n\r\n        // adjacent but different edges\r\n        mint cnt = 0;\r\n        for (int x : ra(1, n+1)) {\r\n            cnt += mint(ssize(e[x])) * (ssize(e[x]) - 1);\r\n        }\r\n        eee += cnt * pwh[3]; // 1/8\r\n\r\n        // unrelated edges\r\n        cnt = mint(m)*m - m - cnt;\r\n\r\n        eee += cnt * pwh[4]; // 1/16\r\n    }\r\n\r\n    // C x C\r\n    mint ecc = 0;\r\n    {\r\n        mint sum = 0;\r\n        // same cycles\r\n        for (auto& path : bp) {\r\n            mint term = pwh[size(path)];\r\n            ecc += term;\r\n            sum += term;\r\n        }\r\n\r\n        // adjacent but different cycles\r\n        // these can only be found at cycle roots\r\n        for (int x : ra(1, n+1)) {\r\n            mint sum = 0; // sum of 2^-len\r\n\r\n            for (int id : paths_rooted[x]) {\r\n                int len = ssize(bp[id]);\r\n                ecc += sum * pwh[len] * 4; // x2 root node, x2 counting twice\r\n                sum += pwh[len];\r\n            }\r\n        }\r\n\r\n        // unrelated cycles, first add all pairs\r\n        mint unrel = sum * sum;\r\n\r\n        // remove same-pairs\r\n        for (auto& path : bp) {\r\n            unrel -= pwh[2 * size(path)];\r\n        }\r\n\r\n        // remove adj but different pairs\r\n        for (int x : ra(1, n+1)) {\r\n            mint sum = 0; // sum of 2^-len\r\n            for (int id : paths_rooted[x]) {\r\n                int len = ssize(bp[id]);\r\n                unrel -= sum * pwh[len] * 2; // x2 counting twice\r\n                sum += pwh[len];\r\n            }\r\n        }\r\n\r\n        // finally add unrelated to sol\r\n        ecc += unrel;\r\n    }\r\n\r\n    // V x E\r\n    mint eve = 0;\r\n    {\r\n        // unrelated vertex-edge\r\n        eve += pwh[3] * m * (n-2);\r\n\r\n        // related vertex-edge\r\n        eve += pwh[2] * m * 2;\r\n    }\r\n\r\n    // E x C\r\n    mint eec = 0;\r\n    for (auto& path : bp) {\r\n        int len = size(path);\r\n        // let's classify edges\r\n        int inside = len;\r\n\r\n        int touching = 0;\r\n        for (int x : path) {\r\n            touching += ssize(e[x]);\r\n        }\r\n        touching -= 2 * len;\r\n\r\n        int unrelated = m - inside - touching;\r\n\r\n        eec += pwh[len] * inside;\r\n        eec += pwh[len+1] * touching;\r\n        eec += pwh[len+2] * unrelated;\r\n    }\r\n\r\n    // V x C\r\n    mint evc = 0;\r\n    for (auto& path : bp) {\r\n        int len = size(path);\r\n        // let's classify vertices\r\n        int inside = len;\r\n        int unrelated = n - inside;\r\n\r\n        evc += pwh[len] * inside;\r\n        evc += pwh[len+1] * unrelated;\r\n    }\r\n\r\n    mint exx = evv + eee + ecc - eve*2 - eec*2 + evc*2;\r\n\r\n    cerr << \"E(X) = \" << (ex * pw2[n])() << \"/ \" << (1<<n) << '\\n';\r\n    int quot = 1 << (n+n);\r\n    cerr << \"E(V^2)   = \" << (evv  * pw2[n+n])()   << \"/ \" << quot << '\\n';\r\n    cerr << \"E(E^2)   = \" << (eee  * pw2[n+n])()   << \"/ \" << quot << '\\n';\r\n    cerr << \"E(C^2)   = \" << (ecc  * pw2[n+n])()   << \"/ \" << quot << '\\n';\r\n    cerr << \"E(VE)   = \" << (eve  * pw2[n+n])()   << \"/ \" << quot << '\\n';\r\n    cerr << \"E(EC)   = \" << (eec  * pw2[n+n])()   << \"/ \" << quot << '\\n';\r\n    cerr << \"E(VC)   = \" << (evc  * pw2[n+n])()   << \"/ \" << quot << '\\n';\r\n    cerr << \"E(X^2) = \" << (exx * pw2[n+n])() << \"/ \" << quot << '\\n';\r\n\r\n    cout << (exx - ex*ex)() << '\\n';    \r\n}\r\n"
}