{
    "id": 162022221,
    "contestId": 1236,
    "creationTimeSeconds": 1656403250,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "Mc3X"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 1700,
    "memoryConsumedBytes": 50790400,
    "source": "#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n//#include <cstdalign>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n \r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\nusing namespace std;\r\nusing i64 = long long;\r\nusing i128 = __int128;\r\n#define MAXN 1000005\r\n#define MAXM 1000005\r\n#define M 1000000\r\n#define K 17\r\n#define MAXP 25\r\n#define MAXK 55\r\n#define MAXC 255\r\n#define MAXERR 105\r\n#define MAXLEN 105\r\n#define MDIR 10\r\n#define MAXR 705\r\n#define BASE 102240\r\n#define MAXA 28\r\n#define MAXT 100005\r\n#define LIMIT 86400\r\n#define MAXV 305\r\n#define LEQ 1\r\n#define EQ 0\r\n#define OP 0\r\n#define CLO 1\r\n#define DIG 1\r\n#define C1 0\r\n#define C2 1\r\n#define PLUS 0\r\n#define MINUS 1\r\n#define MUL 2\r\n#define CLO 1\r\n#define VERT 1\r\n#define B 31\r\n#define B2 1007\r\n#define W 1\r\n#define H 18\r\n#define SPEC 1\r\n#define MUL 2\r\n#define CNT 3\r\n#define ITER 1000\r\n#define INF 1e9\r\n#define EPS 1e-9\r\n#define MOD 1000000007\r\n#define CONST 1000000007\r\n#define FACT 100000000000000\r\n#define PI 3.14159265358979\r\n#define SRC 0\r\n#define pb push_back\r\n#define eb emplace_back\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef pair<int,int> ii;\r\ntypedef pair<ll,ii> pl;\r\ntypedef pair<ll,ll> pll;\r\ntypedef pair<int,ll> li;\r\ntypedef pair<ll,ll> iv;\r\ntypedef tuple<int,int,int> iii;\r\ntypedef vector<vector<int>> vv;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\n//typedef pair<ld,int> iv;\r\ntypedef vector<ii> vii;\r\ntypedef vector<vector<ll>> vll;\r\n//typedef complex<double> cd;\r\n#define sc second\r\n#define fr first\r\n#define rep(i,x,y) for (int i = (x); i < (y); ++i)\r\n#define rev(i,x,y) for (int i = (x); i >= (y); --i)\r\n#define LSOne(S) (S & (-S))\r\n#define trav(i,v) for (auto &i : v)\r\n#define foreach(it,v) for (auto it = begin(v); it != end(v); ++it)\r\n#define sortarr(v) sort(begin(v), end(v))\r\n\r\nvv cyc, adj, rev;\r\nll p2[MAXN];\r\nint fa[MAXN], dep[MAXN];\r\nll n,m;\r\nll raise(int b, int p) {\r\n    ll ans = 1, k = b;\r\n    while (p) {\r\n        if (p & 1) ans = (ans * k) % MOD;\r\n        k = (k * k) % MOD;\r\n        p >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nll inv(int b) {\r\n    return raise(b, MOD - 2);\r\n}\r\n\r\nvoid dfs(int u) {\r\n    trav(i,adj[u]) {\r\n        if (!dep[i]) {\r\n            dep[i] = dep[fa[i] = u] + 1;\r\n            dfs(i);\r\n        } else if (dep[i] < dep[u] - 1) {\r\n            vector<int> v;\r\n            for (int j = u; ;j = fa[j]) {\r\n                v.eb(j);\r\n                if (j == i) break;\r\n            }\r\n            trav(j,v) rev[j].eb((int)(v.size()));\r\n            cyc.eb(v);\r\n        }\r\n    }\r\n}\r\n\r\nll adjust(ll a) {\r\n    if (a < 0) {\r\n        ll incr = -a / MOD + 1;\r\n        return (a + incr * MOD) % MOD;\r\n    }\r\n    return a % MOD;\r\n}\r\n\r\nint main() {\r\n    p2[0] = 1LL;\r\n    rep(i,1,MAXN) p2[i] = (p2[i - 1] * inv(2)) % MOD;\r\n    cin >> n >> m;\r\n    adj.resize(n);\r\n    rev.resize(n);\r\n    rep(i,0,m) {\r\n        int a,b; cin >> a >> b;\r\n        a--, b--;\r\n        adj[a].eb(b);\r\n        adj[b].eb(a);\r\n    }\r\n    dep[0] = 1;\r\n    dfs(0);\r\n    //E[x] = node - edg + ring\r\n    ll node = (p2[1] * n) % MOD, edg = (p2[2] * m) % MOD, ring = 0;\r\n    trav(i,cyc) {\r\n        int sz = (int)(i.size());\r\n        ring = (ring + p2[sz]) % MOD;\r\n    }\r\n    ll ans = adjust(node - edg + ring);\r\n    ll ans1 = (ans * ans) % MOD;\r\n    //cout << ans << ' ' << ans1 << '\\n';\r\n    //E[x^2] = nodes^2 + edges^2 + rings^2 + 2 * nodes * rings - 2 * nodes * edges  - 2 * edges * rings\r\n    \r\n    //compute nodes^2\r\n    ll n2 = (p2[2] * n) % MOD;\r\n    n2 = (n2 * (ll)(n - 1)) % MOD;\r\n    n2 = (n2 + (p2[1] * n) % MOD) % MOD;\r\n    \r\n    //compute edges^2\r\n    ll curr = m * (m - 1);\r\n    ll e2 = 0;\r\n    rep(i,0,n) {\r\n        ll rm = (ll)(adj[i].size()) * (ll)(adj[i].size() - 1);\r\n        curr -= rm;\r\n        ll add = (rm * p2[3]) % MOD;\r\n        e2 = (e2 + add) % MOD;\r\n    }\r\n    e2 = (e2 + (curr * p2[4]) % MOD) % MOD;\r\n    e2 = (e2 + ((ll)(m) * p2[2]) % MOD) % MOD;\r\n    \r\n    //compute ring^2\r\n    ll c2 = (ring * ring) % MOD;\r\n    //subtract out the double contribution for a single pair\r\n    trav(i,cyc) {\r\n        int sz = (int)(i.size());\r\n        ll sub = (p2[sz] * p2[sz]) % MOD;\r\n        c2 = adjust(c2 - sub);\r\n        c2 = (c2 + p2[sz]) % MOD;\r\n    }\r\n    //remove the case on non-independent rings\r\n    //rings can only intersect at one point\r\n    rep(i,0,n) {\r\n        ll pref = 0;\r\n        trav(j,rev[i]) {\r\n            ll sub = (pref * p2[j]) % MOD;\r\n            sub = (2LL * sub) % MOD;\r\n            c2 = adjust(c2 - sub);\r\n            ll add = (pref * p2[j - 1]) % MOD;\r\n            add = (2LL * add) % MOD;\r\n            c2 = (c2 + add) % MOD;\r\n            pref = (pref + p2[j]) % MOD;\r\n        }\r\n    }\r\n    ll ans2 = (n2 + e2 + c2) % MOD;\r\n    \r\n    //compute pairs of nodes and rings\r\n    ll nr = 0;\r\n    trav(i,cyc) {\r\n        ll add = (int)(n) - (int)(i.size());\r\n        ll temp = (add * p2[1]) % MOD;\r\n        temp = (temp * p2[(int)(i.size())]) % MOD;\r\n        nr = (nr + temp) % MOD;\r\n        ll incr2 = (p2[(int)(i.size())] * (ll)(i.size())) % MOD;\r\n        nr = (nr + incr2) % MOD;\r\n    }\r\n   \r\n    nr = (2LL * nr) % MOD;\r\n    ans2 = (ans2 + nr) % MOD;\r\n    \r\n    //compute pairs of nodes and edges\r\n    ll ne = 0;\r\n    rep(i,0,n) {\r\n        ll lft = m - (ll)(adj[i].size());\r\n        ll temp = (lft * p2[3]) % MOD;\r\n        ne = (ne + temp) % MOD;\r\n        ll incr = ((ll)(adj[i].size()) * p2[2]) % MOD;\r\n        ne = (ne + incr) % MOD;\r\n    }\r\n    \r\n    ne = (2LL * ne) % MOD;\r\n    ans2 = adjust(ans2 - ne);\r\n    \r\n    //compute pairs of edges and rings\r\n    ll er = 0;\r\n    trav(i,cyc) {\r\n        //copmute for edges inside the cycle first\r\n        int sz = (int)(i.size());\r\n        ll lft = m - sz;\r\n        ll incr = ((ll)(sz) * p2[sz]) % MOD;\r\n        er = (er + incr) % MOD;\r\n        \r\n        //compute for all edges outgoing from a vertex and not inside any cycle\r\n        trav(j,i) {\r\n            ll temp = (ll)(adj[j].size()) - 2;\r\n            //cout << temp << '\\n';\r\n            ll add = (p2[sz + 1] * temp) % MOD;\r\n            er = (er + add) % MOD;\r\n            lft -= temp;\r\n        }\r\n        ll last = (lft * p2[sz + 2]) % MOD;\r\n        er = (er + last) % MOD;\r\n    }\r\n   \r\n    er = (2LL * er) % MOD;\r\n    ans2 = adjust(ans2 - er);\r\n    cout << adjust(ans2 - ans1);\r\n}"
}