{
    "id": 97152660,
    "contestId": 1236,
    "creationTimeSeconds": 1604048063,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "Lusterdawn"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 15,
    "timeConsumedMillis": 468,
    "memoryConsumedBytes": 57241600,
    "source": "/*\r\n \r\nAuthor: https://codeforces.com/profile/Asriel_Dreemurr\r\n \r\nThis template is still under development\r\n \r\n*/\r\n//\r\n//#pragma comment(linker, \"/stack:200000000\")\r\n//#pragma GCC optimize(\"Ofast\")\r\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\n //pragma is magic\r\n\r\n#include <bits/stdc++.h>\r\n#define ll long long\r\n#define lll __int128\r\n#define mp std::make_pair\r\n#define pii std::pair<int,int>\r\n#define pll std::pair<ll,ll>\r\n#define pli std::pair<ll,int>\r\n#define pil std::pair<int,ll>\r\n#define mtp std::make_tuple\r\n#define _clear(x) std::memset(x,0,sizeof(x))\r\n#define _move(x,y) std::memcpy(y,x,sizeof(x))\r\n#define _len(s) std::strlen(s)\r\n#define writeln(a,n) {for (int i = 1; i <= (n); ++ i) { write(a[i]); } puts(\"\") ;}\r\n#define readln(a,n) for (int i = 1; i <= (n); ++ i) read(a[i]);\r\n#define re(x) for (int _i = 1; _i <= (x); ++ _i)\r\n#define rep(i,l,r) for (int i = (l); i <= (r); ++ i)\r\n#define _debug puts(\"!\")\r\n#define _tell(x) std::cerr << #x << \" is \" << x << std::endl;\r\n\r\n//#define int ll \r\n//#define int lll\r\n\r\ntemplate <class T> class _Fenwick {\r\n\tprivate:\r\n       \tstd::vector<T>sum;\r\n        int _size;\r\n    public:\r\n        _Fenwick() { _size = 0; }\r\n        void reset(int n) { _size = n; sum.clear(); sum.resize(n+1); }\r\n        void add(int x,T y) { while (x <= _size) { sum[x] += y; x += x & -x ; } }\r\n        T query(int x, T y) { T ans = y; while (x) { ans += sum[x]; x -= x & -x; }; return ans; }\r\n        void build(T *a, int n) { reset(n); for (int i = 1; i <= n; ++ i) add(i,a[i]); }\r\n};\r\n\r\ntemplate<typename T> void read(T &x);\r\ntemplate<typename T> void read(T &x,T &y);\r\ntemplate<typename T> void read(T &x,T &y, T &z);\r\ntemplate<typename T> void write(T x);\r\ntemplate<typename T> void writeC(T x);\r\ntemplate<typename T> void writeN(T x);\r\ntemplate<typename T> void _binary(T x,int len);\r\n\r\nvoid init_factorial(int *fac,int *ifac,int n,int mod) ;\r\n\r\nll _qpow(ll a,ll b,ll M);\r\nll _inv(ll x,ll M);\r\n\r\n#define maxn 500005\r\nconst int mod = 1e9+7;\r\n\r\nint qpow(int a,int b) { return _qpow(a,b,mod); }\r\nint inv2 = (mod + 1) / 2;\r\nint inv4 = (ll) inv2 * inv2 % mod;\r\nint inv8 = (ll) inv4 * inv2 % mod;\r\nint inv16 = (ll) inv4 * inv4 % mod;\r\nint vis[maxn],instk[maxn],fa[maxn],u[maxn],v[maxn],d[maxn],a[maxn],b[maxn],sumD[maxn],n,m,tl,s;\r\nstd::vector<int>ch[maxn],in[maxn];\r\n\r\n// Nothing can be more stupid than a cactus problem\r\n\r\nvoid dfs(int u,int f) {\r\n\tvis[u] = 1; instk[u] = 1; fa[u] = f;\r\n\tfor (int v:ch[u]) {\r\n\t\tif (v == f) continue;\r\n\t\tif (!vis[v]) dfs(v,u);\r\n\t\telse {\r\n\t\t\tif (!instk[v]) continue;\r\n\t\t//\tprintf(\"%d -> %d\\n\",u,v);\r\n\t\t\t++tl;\r\n\t\t\tint p = u; sumD[tl] += d[u]; a[tl] ++; in[u].push_back(tl);\r\n\t\t\twhile (1) {\r\n\t\t\t\tp = fa[p];\r\n\t\t\t\tsumD[tl] += d[p]; a[tl] ++; in[p].push_back(tl);\r\n\t\t\t\tif (p == v) break;\r\n\t\t\t}\r\n\t\t}\r\n\t} instk[u] = 0;\r\n}\r\n\r\nsigned main() {\r\n\tread(n,m); rep(i,1,m) { read(u[i],v[i]); ch[u[i]].push_back(v[i]); ch[v[i]].push_back(u[i]); d[u[i]] ++; d[v[i]] ++; }\r\n\tdfs(1,0);\r\n\tfor (int i = 1; i <= n; ++ i) {\r\n\t\tint sum = 0;\r\n\t\tfor (int p:in[i]) sum = (sum + qpow(inv2,a[p])) % mod;\r\n\t\tfor (int p:in[i]) \r\n\t\t\tb[p] = ((b[p] + sum) % mod - qpow(inv2,a[p]) + mod) % mod;\r\n\t}\r\n\t\r\n//\tfor (int i = 1; i <= tl; ++ i) printf(\"%d %d %d\\n\",a[i],b[i],sumD[i]);\r\n\tint E = ((ll) n * inv2 % mod - (ll) m * inv4 % mod + mod) % mod; // 3/2 - 3/4 + 1/8\r\n\tfor (int i = 1; i <= tl; ++ i) { s = (s + qpow(inv2,a[i])) % mod; }\r\n\tE = (E + s) % mod;\r\n\t\r\n\tint A = 0;\r\n\t\r\n\t\r\n\r\n\t// N*N + E*E + R*R - 2NE - 2ER + 2NR\r\n\t\r\n\t//N*N\r\n\tA = (A + (ll) n * (n-1) % mod * inv4 % mod) % mod; //3 / 2 + 3 / 2\r\n\tA = (A + (ll) n * inv2 % mod) % mod;  //0+1+1+1+4+4+4+9 = 24 -> 3 \r\n\t\r\n\t//E*E // = 3/2\r\n\tfor (int i = 1; i <= m; ++ i) {\r\n\t\tint self = 1;\r\n\t\tint related = d[u[i]] - 1 + d[v[i]] - 1;\r\n\t\tint non_related = m - self - related;\r\n\t//\tprintf(\"EE <%d> %d %d %d\\n\",i,self,related,non_related);\r\n\t\tA = (A + (ll) self * inv4 % mod) % mod;\r\n\t\tA = (A + (ll) related * inv8 % mod) % mod;\r\n\t\tA = (A + (ll) non_related * inv16 % mod) % mod;\r\n\t}\r\n\t\r\n\t//R*R = 1/8\r\n\tfor (int i = 1; i <= tl; ++ i) {\r\n\t\tint self = (ll) qpow(inv2,a[i]);\r\n\t\tint related = b[i];\r\n\t\tint non_related = ( (s - self + mod) % mod - related + mod) % mod;\r\n\t\tA = ( (A + self) % mod + (ll) qpow(inv2,a[i]-1) * related % mod ) % mod;\r\n\t\tA = (A + (ll) self * non_related % mod) % mod;\r\n\t}\r\n\t\r\n\t//N*E = 2+2+2+9 15/8\r\n\tint P = 0;\r\n\tfor (int i = 1; i <= m; ++ i) {\r\n\t\tint related = 2;\r\n\t\tint non_related = n - related;\r\n\t\tP = (P + (ll) inv8 * non_related % mod) % mod;\r\n\t\tP = (P + (ll) inv4 * related % mod) % mod;\r\n\t}// printf(\"[%d %d]\\n\",P,(ll)15*inv8%mod); \r\n\tA = (A - (ll) P * 2 % mod + mod) % mod;\r\n\t\r\n\t//N*R = 3/8\r\n\tP = 0;\r\n\tfor (int i = 1; i <= tl; ++ i) {\r\n\t\tint related = a[i];\r\n\t\tint non_related = n - a[i];\r\n\t\tP = (P + (ll) related * qpow(inv2,a[i]) % mod) % mod;\r\n\t\tP = (P + (ll) non_related * qpow(inv2,a[i]+1) % mod) % mod;\r\n\t} A = (A + (ll) 2 * P % mod) % mod;\r\n\t//printf(\"[%d %d]\\n\",P,(ll)3*inv8%mod)%mod;\r\n\t\r\n\t//E * R = 3/8\r\n\tP = 0;\r\n\tfor (int i = 1; i <= tl; ++ i) {\r\n\t\tint full_related = a[i];\r\n\t\tint partial_related = sumD[i] - 2 * (a[i]);\r\n\t\t\r\n\t\tint non_related = m - full_related - partial_related;\r\n\t//\tprintf(\"<%d> %d %d %d\\n\",i,full_related,partial_related,non_related);\r\n\t\tP = (P + (ll) full_related * qpow(inv2,a[i]) % mod) % mod;\r\n\t\tP = (P + (ll) partial_related * qpow(inv2,a[i]+1) % mod) % mod;\r\n\t\tP = (P + (ll) non_related * qpow(inv2,a[i] + 2) % mod) % mod;\r\n\t}\r\n\tA = (A - (ll) 2 * P + mod) % mod;\r\n\t\r\n\tA = (A + (ll)  (mod - 1) * E % mod * E % mod) % mod;\r\n\t\r\n\twrite(A);\r\n\treturn 0;\r\n}\r\n    \r\ntemplate<typename T> void read(T &x) {\r\n\tx = 0;\r\n\tchar c = getchar(); T flag = 1; \r\n\twhile (c < '0' || c > '9') {\r\n\t\tif (c == '-') flag = -flag;\r\n\t\tc = getchar();\r\n\t} while ('0' <= c && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\r\n\tx *= flag;\r\n}\r\n\r\ntemplate<typename T> void read(T &x, T &y) {\r\n\tread(x); read(y);\r\n}\r\ntemplate<typename T> void read(T &x, T &y, T &z) {\r\n\tread(x); read(y); read(z);\r\n}\r\n\r\ntemplate<typename T> void writeC(T x) {\r\n\tif (x < 0) x = ~x + 1, putchar('-');\r\n\tif (x > 9) writeC(x / 10);\r\n\tputchar(x % 10 + '0');\r\n}\r\n\r\ntemplate<typename T> void write(T x) {\r\n\twriteC(x); putchar(' ');\r\n}\r\n\r\ntemplate<typename T> void writeN(T x) {\r\n\twriteC(x); puts(\"\");\r\n}\r\n\r\ntemplate<typename T> void _binary(T x,int len) { for (int i = len-1; i >= 0; -- i) writeC((x>>i)&1); }\r\n\r\nll _inv(ll x,ll M) { assert(x != 0); return x == 1 ? 1 : (M - M / x) * _inv(M % x,M) % M; }\r\n\r\nll _qpow(ll a, ll b, ll M) {\r\n\tll res = 1;\r\n  \twhile (b > 0) {\r\n\t\tif (b & 1) res = res * a % M;\r\n\t\ta = a * a % M;\r\n\t\tb >>= 1;\r\n\t}\r\n  \treturn res;\r\n} \r\n\r\nvoid init_factorial(int *fac,int *ifac,int n,int mod) {\r\n\tfac[0] = ifac[0] = ifac[1] = 1;\r\n\tfor (int i = 1; i <= n; ++ i) fac[i] = (ll) fac[i-1] * i % mod;\r\n\tfor (int i = 2; i <= n; ++ i) ifac[i] = (ll) (mod -mod / i) * ifac[mod % i] % mod;\r\n\tfor (int i = 2; i <= n; ++ i) ifac[i] = (ll) ifac[i-1] * ifac[i] % mod;\r\n}\r\n"
}