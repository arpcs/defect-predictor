{
    "id": 63092527,
    "contestId": 1236,
    "creationTimeSeconds": 1571684647,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "Maksim1744"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 122,
    "timeConsumedMillis": 1653,
    "memoryConsumedBytes": 31436800,
    "source": "/*\r\n    author:  Maksim1744\r\n    created: 21.10.2019 20:53:51\r\n*/\r\n\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define ll   long long\r\n#define ld   long double\r\n\r\n#define mp   make_pair\r\n#define pb   push_back\r\n#define eb   emplace_back\r\n\r\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\r\n#define mine(a)    (*min_element((a).begin(), (a).end()))\r\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\r\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\r\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\r\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\r\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\r\n\r\ntemplate<typename T>             vector<T>& operator--            (vector<T>& v){for (auto& i : v) --i;            return  v;}\r\ntemplate<typename T>             vector<T>& operator++            (vector<T>& v){for (auto& i : v) ++i;            return  v;}\r\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T>& v){for (auto& i : v) is >> i;        return is;}\r\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>& v){for (auto& i : v) os << i << ' '; return os;}\r\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U>& p){is >> p.first >> p.second;        return is;}\r\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>& p){os << p.first << ' ' << p.second; return os;}\r\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\r\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\r\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\r\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\r\n\r\n#ifdef HOME\r\n#define TAG_LENGTH       25\r\n#define LR_LEFT          left\r\n#define LR_RIGHT         right\r\n#define LR_VALUE         value\r\n#define LR_SECOND_VALUE  mn\r\n#include \"C:/C++ libs/print.cpp\"\r\n#else\r\n#define showl            42;\r\n#define shows            42;\r\n#define show(...)        42;\r\n#define showm(...)       42;\r\n#define showt(...)       42;\r\n#define printTree(...)   42;\r\n#define printGraph(...)  42;\r\n#define printLRTree(...) 42;\r\n#define printMatrix(...) 42;\r\n#define printWGraph(...) 42;\r\n#endif\r\n\r\nconst ll mod = 1e9 + 7;\r\n\r\nlong long mpow(long long a, long long p, long long mod = mod) {\r\n    long long res = 1;\r\n    while (p) {\r\n        if (p & 1) res = res * a % mod;\r\n        p >>= 1;\r\n        a = a * a % mod;\r\n    }\r\n    return res;\r\n}\r\n\r\nll inv(ll k) {\r\n    return mpow(k, mod - 2, mod);\r\n}\r\n\r\nint main() {\r\n    ll n, m;\r\n    cin >> n >> m;\r\n    vector<vector<int>> g(n);\r\n    for (int i = 0; i < m; ++i) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        --u; --v;\r\n        g[u].push_back(v);\r\n        g[v].push_back(u);\r\n    }\r\n    vector<vector<int>> cycles;\r\n    vector<bool> u(n, false);\r\n    vector<int> pr(n, -1);\r\n    vector<bool> out(n, false);\r\n    function<void(int, int)> dfs = [&](int v, int p) {\r\n        u[v] = true;\r\n        pr[v] = p;\r\n        for (auto k : g[v]) {\r\n            if (!u[k]) {\r\n                dfs(k, v);\r\n            } else if (k != p && !out[k]) {\r\n                int v0 = v;\r\n                cycles.pb({v0});\r\n                while (v0 != k) {\r\n                    v0 = pr[v0];\r\n                    // shows;\r\n                    // show(v0, k, pr, cycles);\r\n                    cycles.back().pb(v0);\r\n                }\r\n            }\r\n        }\r\n        out[v] = true;\r\n    };\r\n    dfs(0, -1);\r\n    show(cycles);\r\n\r\n    vector<vector<int>> in_cycle(n);\r\n    for (int i = 0; i < cycles.size(); ++i) {\r\n        for (auto v : cycles[i]) {\r\n            in_cycle[v].pb(i);\r\n        }\r\n    }\r\n    show(in_cycle);\r\n\r\n    ll exp = n * inv(2) % mod - m * inv(4) % mod + mod;\r\n    exp %= mod;\r\n    for (int i = 0; i < cycles.size(); ++i) {\r\n        exp += inv(mpow(2, cycles[i].size()));\r\n    }\r\n    exp %= mod;\r\n    // show(exp, inv(4)*5%mod);\r\n\r\n    ll expsq = 0;\r\n    expsq += n * (n + 1) % mod * inv(4) % mod;\r\n    // show(expsq%mod, inv(2)*15%mod);\r\n\r\n    ll adj_edg = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        adj_edg += (ll)(g[i].size()) * (g[i].size() - 1);\r\n    }\r\n    expsq += adj_edg % mod * inv(8) % mod;\r\n    expsq += m * inv(4) % mod;\r\n    expsq += (m * m - adj_edg - m) % mod * inv(16) % mod;\r\n    expsq %= mod;\r\n\r\n    ll sth = 0;\r\n    for (int i = 0; i < cycles.size(); ++i) {\r\n        ll c = cycles[i].size();\r\n        sth += inv(mpow(2, c));\r\n    }\r\n    sth %= mod;\r\n    show(sth,inv(4));\r\n    sth = sth * sth % mod;\r\n    for (int i = 0; i < cycles.size(); ++i) {\r\n        ll c = cycles[i].size();\r\n        sth = (sth - inv(mpow(2, c * 2)) + inv(mpow(2, c)) + mod) % mod;\r\n    }\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        if (in_cycle[i].size() > 1) {\r\n            ll sth2 = 0;\r\n            for (auto ind : in_cycle[i]) {\r\n                sth2 += inv(mpow(2, cycles[ind].size()));\r\n            }\r\n            sth2 %= mod;\r\n            sth2 = sth2 * sth2 * 2 % mod;\r\n            for (auto ind : in_cycle[i]) {\r\n                sth2 -= inv(mpow(2, cycles[ind].size() * 2 - 1));\r\n            }\r\n            sth2 = (sth2 % mod + mod) % mod;\r\n            sth = (sth + sth2 * inv(2) % mod + mod) % mod;\r\n        }\r\n    }\r\n\r\n    show(sth, inv(16)*5%mod);\r\n\r\n    expsq += sth % mod;\r\n    expsq %= mod;\r\n\r\n    show(expsq, inv(16)*199%mod)\r\n\r\n    expsq -= m * 2 * inv(4) * 2 % mod;\r\n    expsq -= m * (n - 2) % mod * inv(8) * 2 % mod;\r\n\r\n    sth = 0;\r\n    for (int i = 0; i < cycles.size(); ++i) {\r\n        ll c = cycles[i].size();\r\n        sth -= c * inv(mpow(2, c)) % mod;\r\n        ll adj = 0;\r\n        for (auto v : cycles[i]) {\r\n            ll now = g[v].size() - 2;\r\n            adj += now;\r\n        }\r\n        sth -= adj * inv(mpow(2, c + 1)) % mod;\r\n        sth -= (m - adj - c) * inv(mpow(2, c + 2)) % mod;\r\n\r\n        sth += c * inv(mpow(2, c)) % mod;\r\n        sth += (n - c) * inv(mpow(2, c + 1)) % mod;\r\n    }\r\n    expsq += sth * 2 % mod;\r\n    // expsq %= mod;\r\n    expsq = (expsq % mod + mod) % mod;\r\n    // show(expsq, inv(4)*29%mod);\r\n    ll d = expsq - exp * exp % mod;\r\n    d = (d % mod + mod) % mod;\r\n    cout << d << '\\n';\r\n    return 0;\r\n}\r\n"
}