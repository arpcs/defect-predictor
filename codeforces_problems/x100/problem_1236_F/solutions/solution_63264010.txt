{
    "id": 63264010,
    "contestId": 1236,
    "creationTimeSeconds": 1571868845,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "PavelChadnov"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 18534400,
    "source": "#ifdef _MSC_VER\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include <thread>\r\n#include <unordered_set>\r\n#include <vector>\r\n#include <memory.h>\r\n#include <list>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <set>\r\n#include <queue>\r\n#include <deque>\r\n#include <stack>\r\n#include <string>\r\n#include <bitset>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <numeric>\r\n#include <stdio.h>\r\n#include <utility>\r\n#include <sstream>\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <random>\r\n#include <string>\r\n#include <cassert>\r\n\r\n\r\n#define getcx _getchar_nolock\r\n\r\nusing namespace std;\r\n\r\nnamespace std\r\n{\r\n\tstring to_string(string const& s) { return '\"' + s + '\"'; }\r\n\tstring to_string(char c) { return string(1, c); }\r\n\tstring to_string(const char* s) { return to_string((string)s); }\r\n\tstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\r\n\r\n\ttemplate <class T1, class T2>\r\n\tstring to_string(pair<T1, T2> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\r\n\r\n\ttemplate <class T>\r\n\tstring to_string(T c)\r\n\t{\r\n\t\tstring s = \"[\";\r\n\t\tfor (auto vvv : c) { s += to_string(vvv) + \",\"; }\r\n\t\ts += \"]\";\r\n\t\treturn s;\r\n\t}\r\n\r\n\tvoid debug_impl() { cerr << endl; };\r\n\r\n\ttemplate <typename T1, typename... T2>\r\n\tvoid debug_impl(T1 a, T2 ... b)\r\n\t{\r\n\t\tcerr << \" \" << to_string(a);\r\n\t\tdebug_impl(b...);\r\n\t}\r\n}\r\n\r\ntemplate <typename T>\r\nstruct reversion_wrapper\r\n{\r\n\tT& iterable;\r\n};\r\n\r\ntemplate <typename T>\r\nauto begin(reversion_wrapper<T> w) { return std::rbegin(w.iterable); }\r\n\r\ntemplate <typename T>\r\nauto end(reversion_wrapper<T> w) { return std::rend(w.iterable); }\r\n\r\ntemplate <typename T>\r\nreversion_wrapper<T> reverse(T&& iterable) { return { iterable }; }\r\n\r\ntemplate<class T>T gcd(T a, T b) { while (a && b)if (a > b)a %= b; else b %= a; return a + b; }\r\n\r\n#ifdef __ASD__\r\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_impl(__VA_ARGS__)\r\n#define endl \"\\n\"\r\n#else\r\n#define dbg(...) ;\r\n//#define endl \"\\n\"\r\n#endif\r\n\r\n#define lng long long\r\n\r\nint const MOD = 1'000'000'007;\r\n\r\n\r\nint powmod(int n, int k) {\r\n\tif (k==0)return 1;\r\n\tint res = powmod(n, k/2);\r\n\tres=(lng)res*res%MOD;\r\n\tif (k%2) {\r\n\t\t\tres=(lng)res*n%MOD;\r\n\t}\r\n\r\n\treturn res;\r\n}\r\n\r\nint inverse(int n) {\r\n\treturn powmod(n, MOD-2);\r\n}\r\n\r\n\r\nstruct modular {\r\n\r\n\r\n\tint value;\r\n\r\n\tmodular() : value(0){}\r\n\r\n\tmodular(int x):value(x){}\r\n\r\n\tmodular& operator +=(const modular &o) {\r\n\t\tthis->value += o.value;\r\n\t\tif (this->value > MOD) {\r\n\t\t\tthis->value -= MOD;\r\n\t\t}\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tmodular& operator -=(const modular &o) {\r\n\t\tthis->value -= o.value;\r\n\t\tif (this->value<0)this->value+=MOD;\r\n\t\telse\r\n\t\tif (this->value > MOD) {\r\n\t\t\tthis->value -= MOD;\r\n\t\t}\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tmodular& operator *=(const modular &o) {\r\n\t\tthis->value = (lng)this->value*o.value%MOD;\r\n\t\tthis->value%=MOD;\r\n\t\tif (this->value > MOD) {\r\n\t\t\tthis->value -= MOD;\r\n\t\t}\r\n\t\treturn *this;\r\n\t}\r\n\t\r\n\tmodular& operator ^=(int k) {\r\n\t\tvalue = powmod(value, k);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tmodular& operator ^=(modular k) {\r\n\t\tvalue = powmod(value, k.value);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tmodular operator~() const {\r\n\t\treturn modular(inverse(this->value));\r\n\t}\r\n\r\n\tmodular& operator /=(const modular &o) {\r\n\t\tauto i = ~o;\r\n\t\t*this *= i;\r\n\t\treturn *this;\r\n\t}\r\n};\r\n\r\nmodular operator+ (modular a, modular const &b) {\r\n\ta+=b;\r\n\treturn a;\r\n}\r\n\r\n\r\nmodular operator- (modular a, modular const &b) {\r\n\ta-=b;\r\n\treturn a;\r\n}\r\n\r\nmodular operator^ (modular a, modular b) {\r\n\ta^=b;\r\n\treturn a;\r\n}\r\n\r\nmodular operator/ (modular a, modular const &b) {\r\n\ta/=b;\r\n\treturn a;\r\n}\r\n\r\n\r\nmodular operator* (modular a, modular const &b) {\r\n\ta*=b;\r\n\treturn a;\r\n}\r\n\r\nint const MAXN = 500000+10;\r\n\r\nstruct edge {\r\n\tint u, v;\r\n\tbool on_cycle;\r\n\tint cycle_id;\r\n};\r\nint n, m;\r\nvector<edge*> grav[MAXN];\r\nint parent[MAXN];\r\nbool was[MAXN];\r\nedge *to_parent[MAXN];\r\nvector<vector<int>>cycles;\r\nvector<int> cycles_by_vertex[MAXN];\r\n\r\nmodular inv2_p[MAXN];\r\n\r\nvoid dfs(int u, edge *pe) {\r\n\twas[u]=true;\r\n\tto_parent[u] = pe;\r\n\tfor(auto e:grav[u]) {\r\n\t\tif (e==pe)continue;\r\n\t\tint v = e->u^e->v^u;\r\n\t\tif (!was[v])dfs(v, e);\r\n\t\telse {\r\n\t\t\tif (pe && ((pe->u)^(pe->v)^v)!=u && !e->on_cycle) {\r\n\t\t\t\te->on_cycle = true;\r\n\t\t\t\te->cycle_id = cycles.size();\r\n\t\t\t\tcycles.emplace_back();\r\n\t\t\t\tint x = u;\r\n\t\t\t\twhile (x!=v) {\r\n\t\t\t\t\tcycles.back().push_back(x);\r\n\t\t\t\t\tto_parent[x]->on_cycle = true;\r\n\t\t\t\t\tx = to_parent[x]->u^to_parent[x]->v^x;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcycles.back().push_back(x);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\r\n#ifdef __ASD__\r\n\tauto start_t = chrono::steady_clock::now();\r\n\tfreopen(\"input.txt\", \"r\", stdin);\r\n\t//freopen(\"1nul\", \"w\", stderr);\r\n\t//freopen(\"output.txt\", \"w\",  stdout);\r\n#else\r\n\t//ios_base::sync_with_stdio(false);\r\n#endif\r\n\r\n\t\r\n\tcin >> n >> m;\r\n\tfor(int i=0;i<m;i++) {\r\n\t\tint u, v;\r\n\t\tcin >> u >> v;\r\n\t\tu--;\r\n\t\tv--;\r\n\t\tedge* e = new edge();\r\n\t\te->u=u;\r\n\t\te->v=v;\r\n\t\tgrav[u].push_back(e);\r\n\t\tgrav[v].push_back(e);\r\n\t}\r\n\r\n\r\n\tfor(int i=0;i<n;i++) {\r\n\t\tif (!was[i])dfs(i,0);\r\n\t}\r\n\r\n\tmodular v;\r\n\tmodular e;\r\n\tmodular c;\r\n\t\r\n\tmodular vv;\r\n\tmodular ee;\r\n\tmodular cc;\r\n\r\n\tmodular ve;\r\n\tmodular vc;\r\n\tmodular ec;\r\n\r\n\tmodular inv2 = modular(inverse(2));\r\n\tinv2_p[0] = 1;\r\n\tfor(int i=1;i<=n;i++) {\r\n\t\tinv2_p[i] = inv2_p[i-1]*inv2;\r\n\t}\r\n\r\n\r\n\tv = modular(n)*inv2;\r\n\te = modular(m)*inv2_p[2];\r\n\tfor(auto &_c:cycles) {\r\n\t\tc +=  inv2_p[_c.size()];\r\n\t}\r\n\tvv = modular(n) * n + n;\r\n\tvv*=inv2_p[2];\r\n\r\n\t{\r\n\t\tfor(int i=0;i<n;i++) {\r\n\t\t\tmodular cnt = (int)grav[i].size();\r\n\t\t\r\n\t\t\tee += cnt*(cnt-1)*inv2_p[3];\r\n\t\t}\r\n\t\tfor(int i=0;i<n;i++) {\r\n\t\t\tfor(auto e:grav[i]) {\r\n\t\t\t\tint u = e->u;\r\n\t\t\t\tint v = e->v;\r\n\r\n\t\t\t\tmodular c;\r\n\t\t\t\tc = (int)(grav[u].size()+grav[v].size()) - 1;\r\n\r\n\t\t\t\tee += (m-c)*inv2_p[5];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tee += modular(m)*inv2_p[2];\r\n\t}\r\n\r\n\tfor(int i=0;i<cycles.size();i++) {\r\n\t\tauto &c = cycles[i];\r\n\t\tfor(int v:c) {\r\n\t\t\tcycles_by_vertex[v].push_back(i);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t{\r\n\t\tmodular overlap=0;\r\n\t\tint cnt=0;\r\n\t\tmodular self=0;\r\n\t\tfor(int i=0;i<n;i++) {\r\n\t\t\tcnt+=cycles_by_vertex[i].size();\r\n\t\t\tmodular sum;\r\n\t\t\tmodular sum_sq;\r\n\t\t\tfor(int c:cycles_by_vertex[i]) {\r\n\t\t\t\tmodular t = inv2_p[cycles[c].size()];\r\n\t\t\t\tsum += t;\r\n\t\t\t\tsum_sq += t*t;\r\n\t\t\t}\r\n\t\t\toverlap+=sum*sum;\r\n\t\t\toverlap-=sum_sq;\r\n\t\t}\r\n\r\n\t\tfor(auto &c:cycles) {\r\n\t\t\tself += inv2_p[c.size()];\r\n\t\t\tcnt++;\r\n\t\t}\r\n\r\n\t\tmodular sum;\r\n\t\tmodular sum_sq;\r\n\t\tfor(auto &c:cycles) {\r\n\t\t\tmodular t = inv2_p[c.size()];\r\n\t\t\tsum += t;\r\n\t\t\tsum_sq += t*t;\r\n\t\t}\r\n\r\n\t\tmodular rest = sum*sum - sum_sq;\r\n\r\n\t\tcc += overlap;\r\n\t\tcc += self;\r\n\t\tcc += rest;\r\n\t}\r\n\r\n\t{\r\n\t\tfor(int i=0;i<n;i++) {\r\n\t\t\tve += modular((int)grav[i].size())*inv2_p[2];\r\n\t\t\tve += modular(m-(int)grav[i].size())*inv2_p[3];\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tfor(auto &_c:cycles) {\r\n\t\t\tmodular c = (int)_c.size();\r\n\t\t\tvc += c*inv2_p[c.value];\r\n\t\t\tvc += (n-c)*inv2_p[c.value+1];\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tfor(auto &_c:cycles) {\r\n\t\t\tmodular c = (int)_c.size();\r\n\t\t\tec += c*inv2_p[c.value];\r\n\t\t\t\r\n\t\t\tmodular cnt;\r\n\t\t\tfor(int v:_c) cnt += (int)grav[v].size()-2;\r\n\t\t\tec += cnt/(2^(c+1));\r\n\r\n\t\t\tec += (m-c-cnt)*inv2_p[c.value+2];\r\n\t\t}\r\n\t}\r\n\r\n\tmodular res;\r\n\r\n\tauto t = v-e+c;\r\n\r\n\tres+=vv;\r\n\tres+=ee;\r\n\tres+=cc;\r\n\tres+=vc*2;\r\n\tres-=ve*2;\r\n\tres-=ec*2;\r\n\tres-=t*t;\r\n\tcout<<(res).value<<endl;\r\n\t\r\n#ifdef __ASD__\r\n\tauto finish_t = chrono::steady_clock::now();\r\n\tcerr << \"Elapsed \" << chrono::duration_cast<chrono::milliseconds>(finish_t - start_t).count() << \" ms\" << endl;\r\n#endif\r\n\treturn 0;\r\n}"
}