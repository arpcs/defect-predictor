{
    "id": 63219273,
    "contestId": 1236,
    "creationTimeSeconds": 1571815426,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "sajibreadd"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 122,
    "timeConsumedMillis": 499,
    "memoryConsumedBytes": 43417600,
    "source": "#include<bits/stdc++.h>\r\n#include <cstring>\r\n#include <iostream>\r\n#define pie acos(-1)\r\n#define si(a) scanf(\"%d\",&a)\r\n#define sii(a,b) scanf(\"%d %d\",&a,&b)\r\n#define siii(a,b,c) scanf(\"%d %d %d\",&a,&b,&c)\r\n#define sl(a) scanf(\"%lld\",&a)\r\n#define sll(a,b) scanf(\"%lld %lld\",&a,&b)\r\n#define slll(a,b,c) scanf(\"%lld %lld %lld\",&a,&b,&c)\r\n#define ss(st) scanf(\"%s\",st)\r\n#define sch(ch) scanf(\"%ch\",&ch)\r\n#define ps(a) printf(\"%s\",a)\r\n#define newLine() printf(\"\\n\")\r\n#define pi(a) printf(\"%d\",a)\r\n#define pii(a,b) printf(\"%d %d\",a,b)\r\n#define piii(a,b,c) printf(\"%d %d %d\",a,b,c)\r\n#define pl(a) printf(\"%lld\",a)\r\n#define pll(a,b) printf(\"%lld %lld\",a,b)\r\n#define plll(a,b,c) printf(\"%lld %lld %lld\",a,b,c)\r\n#define pd(a) printf(\"%lf\",a)\r\n#define pdd(a,b) printf(\"%lf %lf\",a,b)\r\n#define pddd(a,b,c) printf(\"%lf %lf %lf\",a,b,c)\r\n#define pch(c) printf(\"%ch\",c)\r\n#define debug1(str,a) printf(\"%s=%d\\n\",str,a)\r\n#define debug2(str1,str2,a,b) printf(\"%s=%d %s=%d\\n\",str1,a,str2,b)\r\n#define debug3(str1,str2,str3,a,b,c) printf(\"%s=%d %s=%d %s=%d\\n\",str1,a,str2,b,str3,c)\r\n#define debug4(str1,str2,str3,str4,a,b,c,d) printf(\"%s=%d %s=%d %s=%d %s=%d\\n\",str1,a,str2,b,str3,c,str4,d)\r\n#define for0(i,n) for(i=0;i<n;i++)\r\n#define for1(i,n) for(i=1;i<=n;i++)\r\n#define forab(i,a,b) for(i=a;i<=b;i++)\r\n#define forstl(i, s) for (__typeof ((s).end ()) i = (s).begin (); i != (s).end (); ++i)\r\n#define nl puts(\"\")\r\n#define sd(a) scanf(\"%lf\",&a)\r\n#define sdd(a,b) scanf(\"%lf %lf\",&a,&b)\r\n#define sddd(a,b,c) scanf(\"%lf %lf %lf\",&a,&b,&c)\r\n#define sp printf(\" \")\r\n#define ll long long int\r\n#define ull unsigned long long int\r\n#define MOD 1000000007\r\n#define mpr make_pair\r\n#define pub(x) push_back(x)\r\n#define pob(x) pop_back(x)\r\n#define mem(ara,value) memset(ara,value,sizeof(ara))\r\n#define INF INT_MAX\r\n#define eps 1e-9\r\n#define checkbit(n, pos) (n & (1<<pos))\r\n#define setbit(n, pos) (n  (1<<pos))\r\n#define para(i,a,b,ara)\\\r\nfor(i=a;i<=b;i++){\\\r\n    if(i!=0){printf(\" \");}\\\r\n    cout<<ara[i];\\\r\n}\\\r\nprintf(\"\\n\");\r\n#define pvec(i,vec)\\\r\nfor(i=0;i<vec.size();i++){\\\r\n    if(i!=0){printf(\" \");}\\\r\n    cout<<vec[i];\\\r\n}\\\r\nprintf(\"\\n\");\r\n#define ppara(i,j,n,m,ara)\\\r\nfor(i=0;i<n;i++){\\\r\n    for(j=0;j<m;j++){\\\r\n        if(j!=0){printf(\" \");}\\\r\n        cout<<ara[i][j];\\\r\n    }\\\r\n    printf(\"\\n\");\\\r\n}\r\n#define ppstructara(i,j,n,m,ara)\\\r\nfor(i=0;i<n;i++){\\\r\n    printf(\"%d:\\n\",i);\\\r\n    for(j=0;j<m;j++){\\\r\n        cout<<ara[i][j];printf(\"\\n\");\\\r\n    }\\\r\n}\r\n#define ppvec(i,j,n,vec)\\\r\nfor(i=0;i<n;i++){\\\r\n    printf(\"%d:\",i);\\\r\n    for(j=0;j<vec[i].size();j++){\\\r\n        if(j!=0){printf(\" \");}\\\r\n        cout<<vec[i][j];\\\r\n    }\\\r\n    printf(\"\\n\");\\\r\n}\r\n#define ppstructvec(i,j,n,vec)\\\r\nfor(i=0;i<n;i++){\\\r\n    printf(\"%d:\",i);\\\r\n    for(j=0;j<vec[i].size();j++){\\\r\n        cout<<vec[i][j];printf(\"\\n\");\\\r\n    }\\\r\n}\r\n#define sara(i,a,b,ara)\\\r\nfor(i=a;i<=b;i++){\\\r\n    scanf(\"%d\",&ara[i]);\\\r\n}\r\n#define pstructara(i,a,b,ara)\\\r\nfor(i=a;i<=b;i++){\\\r\n    cout<<ara[i];nl;\\\r\n}\r\n#define pstructvec(i,vec)\\\r\nfor(i=0;i<vec.size();i++){\\\r\n    cout<<vec[i];nl;\\\r\n}\r\n#define pstructstl(stl,x)\\\r\nfor(__typeof(stl.begin()) it=stl.begin();it!=stl.end();++it){\\\r\n    x=*it;\\\r\n    cout<<x;nl;\\\r\n}\\\r\nnl;\r\n#define pstl(stl)\\\r\nfor(__typeof(stl.begin()) it=stl.begin();it!=stl.end();++it){\\\r\n    if(it!=stl.begin()){sp;}\\\r\n    pi(*it);\\\r\n}\\\r\nnl;\r\n#define ppairvec(i,vec)\\\r\nfor(i=0;i<vec.size();i++){\\\r\n    cout<<vec[i].first;sp;cout<<vec[i].second;printf(\"\\n\");\\\r\n}\r\n#define ppairara(i,a,b,ara)\\\r\nfor(i=a;i<=b;i++){\\\r\n    cout<<ara[i].first;sp;cout<<ara[i].second;printf(\"\\n\");\\\r\n}\r\n#define pppairvec(i,j,n,vec)\\\r\nfor(i=0;i<n;i++){\\\r\n    printf(\"%d:\\n\",i);\\\r\n    for(j=0;j<vec[i].size();j++){\\\r\n        cout<<vec[i][j].first;sp;cout<<vec[i][j].second;nl;\\\r\n    }\\\r\n}\r\n#define pppairara(i,j,n,m,ara)\\\r\nfor(i=0;i<n;i++){\\\r\n    printf(\"%d:\\n\",i);\\\r\n    for(j=0;j<m;j++){\\\r\n        cout<<ara[i][j].first;printf(\" \");cout<<ara[i][j].second;nl;\\\r\n    }\\\r\n}\r\n#define SZ 5 * 100010\r\nusing namespace std;\r\n//bool status[100010];\r\n//vector <int> prime;\r\n//void siv(){\r\n//    int N = 100005, i, j; prime.clear();\r\n//    int sq = sqrt(N);\r\n//    for(i = 4; i <= N; i += 2){ status[i] = true; }\r\n//    for(i = 3; i <= sq; i+= 2){\r\n//        if(status[i] == false){\r\n//            for(j = i * i; j <= N; j += i){ status[j] = true; }\r\n//        }\r\n//    }\r\n//    status[1] = true;\r\n//    for1(i, N){ if(!status[i]){ prime.pub(i); } }\r\n//}\r\nint add(int _a, int _b){\r\n   _a = (_a + MOD) % MOD;\r\n   _b = (_b + MOD) % MOD;\r\n   return (_a + _b) % MOD;\r\n}\r\nint mul(int _a, int _b){\r\n   _a = (_a + MOD) % MOD;\r\n   _b = (_b + MOD) % MOD;\r\n   return ((ll)((ll)_a * (ll)_b)) % MOD;\r\n}\r\nint big_mod(int v, int p){\r\n    if(p == 0){ return 1; }\r\n    int ret = big_mod(v, p / 2);\r\n    if(p % 2 == 0){ return mul(ret, ret); }\r\n    return mul(ret, mul(ret, v));\r\n}\r\nint n, m, pwr[2 * SZ], inv_pwr[2 * SZ];\r\nvector <int> adj[SZ];\r\nbool vis[SZ], is_art[SZ];\r\nint Time, low[SZ], dis[SZ], bcc_cnt;\r\nvector <int> bcc[SZ], art_vec[SZ];\r\nstack <int> S;\r\nvoid pop_bcc(int s, int u){\r\n    is_art[s] = true;\r\n    bcc[bcc_cnt].push_back(s);\r\n    while(true){\r\n        bcc[bcc_cnt].push_back(S.top());\r\n        if(S.top() == u){ S.pop(); break; }\r\n        S.pop();\r\n    }\r\n    bcc_cnt++;\r\n    if(bcc[bcc_cnt - 1].size() <= 2){\r\n        bcc[bcc_cnt - 1].clear();\r\n        bcc_cnt--;\r\n    }\r\n}\r\nvoid find_bcc(int src, int par){\r\n    S.push(src);\r\n    int i, u, child = 0; vis[src] = true, Time++, dis[src] = low[src] = Time;\r\n    for0(i, adj[src].size()){\r\n        u = adj[src][i];\r\n        if(!vis[u]){\r\n            child++, find_bcc(u, src);\r\n            low[src] = min(low[src], low[u]);\r\n            if(par != -1 && low[u] >= dis[src]){ pop_bcc(src, u); }\r\n            else if(par == -1){\r\n                if(child > 1){ pop_bcc(src, u); }\r\n            }\r\n        } else if(par != u){ low[src] = min(low[src], dis[u]); }\r\n    } if(par == -1 && child > 1){ is_art[src] = true; }\r\n}\r\nvoid process_bcc(){\r\n    int i, j;\r\n    bool f;\r\n    bcc_cnt = 0;\r\n    for0(i, n){\r\n        if(!vis[i]){\r\n            Time = 0;\r\n            find_bcc(i, -1);\r\n            f = false;\r\n            while(!S.empty()){\r\n                f = true;\r\n                bcc[bcc_cnt].push_back(S.top());\r\n                S.pop();\r\n            } if(f){\r\n                bcc_cnt++;\r\n                if(bcc[bcc_cnt - 1].size() <= 2){\r\n                    bcc[bcc_cnt - 1].clear();\r\n                    bcc_cnt--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid input(){\r\n    int i, j;\r\n    sii(n, m);\r\n    for0(i, m){\r\n        int u, v;\r\n        sii(u, v), u--, v--;\r\n        adj[u].push_back(v), adj[v].push_back(u);\r\n    }\r\n}\r\ninline int comb(int a){\r\n    return mul(a, a - 1);\r\n}\r\nvoid solve(){\r\n    int i, j, sol = 0, sz, baki = 0, sum = 0, sz1;\r\n    process_bcc();\r\n    //a\r\n    int a = mul(n, inv_pwr[1]);\r\n    //b\r\n    int b = mul(m, inv_pwr[2]);\r\n    //c\r\n    int c = 0;\r\n    for0(i, bcc_cnt){\r\n        sz = bcc[i].size();\r\n        c = add(c, inv_pwr[sz]);\r\n    }\r\n    //a^2;\r\n    int a_2 = mul(comb(n), inv_pwr[2]);\r\n    a_2 = add(a_2, mul(n, inv_pwr[1]));\r\n    //b^2\r\n    int b_2 = 0;\r\n    for0(i, n){\r\n        sz = adj[i].size();\r\n        b_2 = add(b_2, mul(comb(sz), inv_pwr[3]));\r\n        b_2 = add(b_2, -mul(comb(sz), inv_pwr[4]));\r\n    }\r\n    b_2 = add(b_2, mul(comb(m), inv_pwr[4]));\r\n    b_2 = add(b_2, mul(m, inv_pwr[2]));\r\n    //c^2\r\n    int c_2 = 0;\r\n    for0(i, bcc_cnt){\r\n        for0(j, bcc[i].size()){\r\n            if(is_art[bcc[i][j]]){\r\n                art_vec[bcc[i][j]].push_back(i);\r\n            }\r\n        }\r\n    }\r\n    for(i = 0; i < n; i++){\r\n        for(j = 0, sum = 0; j < art_vec[i].size(); j++){\r\n            sz = bcc[art_vec[i][j]].size();\r\n            sum = add(sum, inv_pwr[sz]);\r\n        }\r\n        for0(j, art_vec[i].size()){\r\n            sz = bcc[art_vec[i][j]].size();\r\n            c_2 = add(c_2, mul(add(sum, -inv_pwr[sz]), inv_pwr[sz - 1]));\r\n            c_2 = add(c_2, -mul(add(sum, -inv_pwr[sz]), inv_pwr[sz]));\r\n        }\r\n    }\r\n    for(i = 0, sum = 0; i < bcc_cnt; i++){\r\n        sz = bcc[i].size();\r\n        sum = add(sum, inv_pwr[sz]);\r\n    }\r\n    for0(i, bcc_cnt){\r\n        sz = bcc[i].size();\r\n        c_2 = add(c_2, mul(add(sum, -inv_pwr[sz]), inv_pwr[sz]));\r\n        c_2 = add(c_2, inv_pwr[sz]);\r\n    }\r\n    //ab\r\n    int ab = 0;\r\n    ab = add(ab, mul(mul(2, m), inv_pwr[2]));\r\n    ab = add(ab, mul(mul(m, n - 2), inv_pwr[3]));\r\n    //bc\r\n    int bc = 0;\r\n    for0(i, bcc_cnt){\r\n        sz = bcc[i].size();\r\n        bc = add(bc, mul(sz, inv_pwr[sz]));\r\n        bc = add(bc, -mul(sz, inv_pwr[sz + 2]));\r\n        bc = add(bc, mul(m, inv_pwr[sz + 2]));\r\n        for0(j, bcc[i].size()){\r\n            sz1 = adj[bcc[i][j]].size();\r\n            sz1 = add(sz1, -2);\r\n            bc = add(bc, mul(sz1, inv_pwr[sz + 1]));\r\n            bc = add(bc, -mul(sz1, inv_pwr[sz + 2]));\r\n        }\r\n    }\r\n    //ac\r\n    int ca = 0;\r\n    for0(i, bcc_cnt){\r\n        sz = bcc[i].size();\r\n        ca = add(ca, mul(sz, inv_pwr[sz]));\r\n        ca = add(ca, -mul(sz, inv_pwr[sz + 1]));\r\n        ca = add(ca, mul(n, inv_pwr[sz + 1]));\r\n    }\r\n    int e_x = add(a, add(-b, c));\r\n    sol = 0;\r\n    sol = add(sol, -mul(e_x, e_x));\r\n    sol = add(sol, add(a_2, add(b_2, c_2)));\r\n    sol = add(sol, -mul(2, ab));\r\n    sol = add(sol, -mul(2, bc));\r\n    sol = add(sol, mul(2, ca));\r\n    pi(sol); nl;\r\n}\r\nvoid pre_process(){\r\n    int i, j, inv_2 = big_mod(2, MOD - 2);\r\n    for(i = 1, pwr[0] = 1, inv_pwr[0] = 1; i < 2 * SZ - 2; i++){\r\n        pwr[i] = mul(pwr[i - 1], 2);\r\n        inv_pwr[i] = mul(inv_pwr[i - 1], inv_2);\r\n    }\r\n}\r\nint main(){\r\n//    freopen(\"input.txt\",\"r\",stdin);\r\n//    freopen(\"output.txt\", \"w\", stdout);\r\n    pre_process();\r\n    input();\r\n    solve();\r\n}\r\n"
}