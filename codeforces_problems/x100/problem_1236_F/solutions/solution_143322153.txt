{
    "id": 143322153,
    "contestId": 1236,
    "creationTimeSeconds": 1642593788,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "Xylofo"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 122,
    "timeConsumedMillis": 639,
    "memoryConsumedBytes": 71475200,
    "source": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define debug(...) //ignore\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\n\n\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\n  private:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\n  public:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v -= MOD-o.v;\n    v = (v < 0) ? v + MOD : v;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    v = (v < 0) ? v + MOD : v;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pw(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\n\nconst ll mod = 1'000'000'007;\nusing M = modnum<mod>;\n//using M = ld;\n\n\nvi num, st;\nvector<vector<pii>> ed;\nint Time;\ntemplate<class F>\nint dfs(int at, int par, F& f) {\n  int me = num[at] = ++Time, e, y, top = me;\n  for (auto pa : ed[at]) if (pa.second != par) {\n    tie(y, e) = pa;\n    if (num[y]) {\n      top = min(top, num[y]);\n      if (num[y] < me)\n        st.push_back(e);\n    } else {\n      int si = sz(st);\n      int up = dfs(y, e, f);\n      top = min(top, up);\n      if (up == me) {\n        st.push_back(e);\n        f(vi(st.begin() + si, st.end()));\n        st.resize(si);\n      }\n      else if (up < me) st.push_back(e);\n      else { } // bridge\n    }\n  }\n  return top;\n}\n\ntemplate<class F>\nvoid bicomps(F f) {\n  num.assign(sz(ed), 0);\n  rep(i,0,sz(ed)) if (!num[i]) dfs(i, -1, f);\n}\n\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int n, m;\n  cin >> n >> m;\n\n  ed.resize(n);\n  vector<pii> edges(m);\n  vector<vi> g(n);\n  rep(i,0,m) {\n    int x,y;\n    cin>>x>>y;\n    --x,--y;\n    ed[x].emplace_back(y,i);\n    ed[y].emplace_back(x,i);\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n    edges[i] = pii(x,y);\n  }\n\n  vector<vi> in_cyc(n);\n  vector<vi> cyc;\n\n  auto bcc = [&](vi c) {\n    vi verts;\n    int us = sz(cyc);\n    for(int e : c) {\n      auto [x,y] = edges[e];\n      if(!sz(in_cyc[x]) || in_cyc[x].back() != us) {\n        in_cyc[x].emplace_back(us);\n        verts.emplace_back(x);\n      }\n      if(!sz(in_cyc[y]) || in_cyc[y].back() != us) {\n        in_cyc[y].emplace_back(us);\n        verts.emplace_back(y);\n      }\n    }\n    cyc.emplace_back(verts);\n  };\n  bicomps(bcc);\n  debug(in_cyc);\n  debug(cyc);\n\n  M Var_V = n * (1/M(2)) * (1/M(2));\n\n  M Var_E = [&](){\n    M res = m * (1/M(4) - 1/M(16));\n    rep(i,0,n) res += M(sz(g[i])) * M(sz(g[i])-1) * (1/M(8) - (1/M(16)));\n    return res;\n  }();\n\n  M Var_F = [&](){\n    M res = 0;\n    rep(i,0,sz(cyc)) {\n      M p = 1/pw(M(2),sz(cyc[i]));\n      res += p*(1-p);\n    }\n    rep(i,0,n) {\n      M term = 0;\n      M surplus = 0;\n      for(int c : in_cyc[i]) {\n        M q = pw(M(2), sz(cyc[c]));\n        term += 1/q;\n        surplus += 1/(q*q);\n      }\n      res += term*term - surplus;\n    }\n    return res;\n  }();\n\n  M Cov_VE = m/M(4);\n\n  M Cov_VF = [&](){\n    M res = 0;\n    rep(c,0,sz(cyc)) res += sz(cyc[c]) / pw(M(2), sz(cyc[c])+1);\n    return res;\n  }();\n\n  M Cov_EF = [&](){\n    M res = 0;\n    rep(c,0,sz(cyc)) res += sz(cyc[c]) * 3 / (pw(M(2), sz(cyc[c])+2));\n    rep(c,0,sz(cyc)) {\n      int extra = 0;\n      for(int x : cyc[c]) extra += sz(g[x])-2;\n      res += extra / pw(M(2), sz(cyc[c])+2);\n    }\n    return res;\n  }();\n\n\n  /*\n  auto est_var = [&](auto &f) {\n    ld xy=0, x=0, y=0;\n    const int Q = 1000;\n    rep(i,0,Q) {\n      auto [X,Y] = f();\n      x += X;\n      y += Y;\n      xy += X*Y;\n    }\n    return xy/Q-x/Q*y/Q;\n  };\n  auto vef = [&](){\n    vi alive(n);\n    rep(i,0,n) alive[i] = 1-(rand()%2);\n    int v = count(all(alive),1);\n    int e = 0;\n    int f = 0;\n    rep(i,0,n) for(int j : g[i]) if(i < j && alive[i] && alive[j]) ++e;\n    rep(c,0,sz(cyc)) {\n      bool ok = true;\n      for(int x : cyc[c]) if(!alive[x]) ok = false;\n      if(ok) ++f;\n    }\n    return make_tuple(v,e,f);\n  };\n  auto _vv = [&](){ auto t = vef(); return make_pair(get<0>(t), get<0>(t)); };\n  auto _ee = [&](){ auto t = vef(); return make_pair(get<1>(t), get<1>(t)); };\n  auto _ff = [&](){ auto t = vef(); return make_pair(get<2>(t), get<2>(t)); };\n  auto _ve = [&](){ auto t = vef(); return make_pair(get<0>(t), get<1>(t)); };\n  auto _vf = [&](){ auto t = vef(); return make_pair(get<0>(t), get<2>(t)); };\n  auto _ef = [&](){ auto t = vef(); return make_pair(get<1>(t), get<2>(t)); };\n  auto _ans = [&](){\n    auto t = vef();\n    int r = get<0>(t)-get<1>(t)+get<2>(t);\n    return make_pair(r,r);\n  };\n  debug(est_var(_vv));\n  debug(est_var(_ee));\n  debug(est_var(_ff));\n  debug(est_var(_ve));\n  debug(est_var(_vf));\n  debug(est_var(_ef));\n\n  debug(Var_V);\n  debug(Var_E);\n  debug(Var_F);\n  debug(Cov_VE);\n  debug(Cov_VF);\n  debug(Cov_EF);\n\n  debug();\n  debug(est_var(_ans));\n  */\n\n  // ans = Var(V-E+F)\n  M ans = Var_V + Var_E + Var_F + 2*Cov_VF - 2*Cov_VE - 2*Cov_EF;\n  cout << ans << endl;\n}\n"
}