{
    "id": 63349902,
    "contestId": 1236,
    "creationTimeSeconds": 1571951379,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "arthurpd"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 7,
    "timeConsumedMillis": 529,
    "memoryConsumedBytes": 30105600,
    "source": "#pragma once\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntemplate <class TH>\r\nvoid _dbg(const char *sdbg, TH h) { cerr << sdbg << '=' << h << endl; }\r\n\r\ntemplate <class TH, class... TA>\r\nvoid _dbg(const char *sdbg, TH h, TA... a)\r\n{\r\n\twhile (*sdbg != ',')\r\n\t\tcerr << *sdbg++;\r\n\tcerr << '=' << h << ',';\r\n\t_dbg(sdbg + 1, a...);\r\n}\r\n\r\ntemplate <class L, class R>\r\nostream &operator<<(ostream &os, pair<L, R> p)\r\n{\r\n\treturn os << \"(\" << p.first << \", \" << p.second << \")\";\r\n}\r\n\r\ntemplate <class Iterable, class = typename enable_if<!is_same<string, Iterable>::value>::type>\r\nauto operator<<(ostream &os, Iterable v) -> decltype(os << *begin(v))\r\n{\r\n\tos << \"[\";\r\n\tfor (auto vv : v)\r\n\t\tos << vv << \", \";\r\n\treturn os << \"]\";\r\n}\r\n\r\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\r\n\r\ntypedef pair<int, int> pii;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double ld;\r\n\r\nconst int inf = 0x3f3f3f3f;\r\nconst long long infll = 0x3f3f3f3f3f3f3f3fll;\r\n\r\n#define sz(x) ((int)(x).size())\r\n\r\n// Return 1 if x > 0, 0 if x == 0 and -1 if x < 0.\r\ntemplate <class T>\r\nint sign(T x) { return (x > 0) - (x < 0); }\r\n\r\ntemplate <class T>\r\nT abs(const T &x) { return (x < T(0)) ? -x : x; }\r\n\r\n// Pretty good compilation command:\r\n// g++ -g a.cpp --std=c++14 -Wall -Wextra -Wno-unused-result -Wconversion -Wfatal-errors -fsanitize=undefined,address -o a.out\r\n\r\n// int main()\r\n// {\r\n// \tcin.sync_with_stdio(0);\r\n// \tcin.tie(0);\r\n// }\r\n\r\n/*\r\n\tExtended Euclidean Algorithm:\r\n\t\tReturns the gcd of a and b.\r\n\t\tAlso finds numbers x and y for which a * x + b * y = gcd(a, b) (not unique).\r\n\t\tAll pairs can be represented in the form (x + k * b / gcd, y - k * a / gcd) for k an arbitrary integer.\r\n\t\tIf there are several such x and y, the function returns the pair for which |x| + |y| is minimal.\r\n\t\tIf there are several x and y satisfying the minimal criteria, it outputs the pair for which X <= Y.\r\n\r\n\tSource: modified from https://cp-algorithms.com/algebra/extended-euclid-algorithm.html\r\n\r\n\tUsage:\r\n\t\tFor non-extendend version, c++ has __gcd and __lcm.\r\n\r\n\tConstraints:\r\n\t\tProduces correct results for negative integers as well.\r\n*/\r\n\r\ntemplate<class T>\r\nT gcd(T a, T b, T &x, T &y)\r\n{\r\n\tif (b == 0)\r\n\t{\r\n\t\tx = 1;\r\n\t\ty = 0;\r\n\t\treturn a;\r\n\t}\r\n\r\n\tT x1, y1;\r\n\tT d = gcd(b, a % b, x1, y1);\r\n\tx = y1;\r\n\ty = x1 - y1 * (a / b);\r\n\treturn d;\r\n}\r\n\r\n/*\r\n\tModular Inverse:\r\n\t\tReturns an integer x such that (a * x) % m == 1.\r\n\t\tThe modular inverse exists if and only if a and m are relatively prime.\r\n\t\tModular inverse is also equal to a^(phi(m) - 1) % m.\r\n\t\tIn particular, if m is prime a^(-1) == a^(m-2), which might be faster to code.\r\n\r\n\tSource: modified from https://cp-algorithms.com/algebra/module-inverse.html\r\n*/\r\n\r\ntemplate<class T>\r\nT mod_inverse(T a, T m)\r\n{\r\n\tT x, y;\r\n\tassert(gcd(a, m, x, y) == 1); // Or return something, if gcd is not 1 the inverse doesn't exist.\r\n\treturn (x % m + m) % m;\r\n}\r\n\r\n/*\r\n\tModular Arithmetic:\r\n\t\tStruct wrapper on to of modular arithmetics.\r\n\r\n\tSource: modified from https://github.com/kth-competitive-programming/kactl/blob/master/content/number-theory/ModularArithmetic.h\r\n*/\r\n\r\ntemplate <ll mod>\r\nstruct mod_num\r\n{\r\n\tll x;\r\n\texplicit mod_num(ll x = 0) : x(x % mod) {}\r\n\tmod_num operator+(mod_num b) { return mod_num(x + b.x); }\r\n\tmod_num operator-(mod_num b) { return mod_num(x - b.x + mod); }\r\n\tmod_num operator*(mod_num b) { return mod_num(x * b.x); }\r\n\tmod_num operator/(mod_num b) { return mod_num(x * mod_inverse(b.x, mod)); }\r\n\tmod_num operator^(ll e)\r\n\t{\r\n\t\tmod_num ans(1);\r\n\t\tmod_num b = *this;\r\n\t\tfor (; e; b = b * b % mod, e /= 2)\r\n\t\t\tif (e & 1)\r\n\t\t\t\tans = ans * b % mod;\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tvoid operator+=(mod_num b) { x = (x + b.x) % mod; }\r\n};\r\n\r\ntemplate <ll mod>\r\nostream &operator<<(ostream &os, mod_num<mod> x)\r\n{\r\n\treturn os << x.x;\r\n}\r\n\r\n#define MAXN 512345\r\n#define mod_num mod_num<1000000007>\r\n\r\nvector<int> graph[MAXN];\r\nint been[MAXN];\r\nvector<int> st;\r\n\r\nvector<vector<int>> rings;\r\nvector<pii> edges;\r\n\r\nmod_num vertex_rings_factor[MAXN];\r\n\r\nvoid dfs(int a, int p)\r\n{\r\n\tbeen[a] = 1;\r\n\tst.push_back(a);\r\n\tfor (int i = 0; i < graph[a].size(); i++)\r\n\t{\r\n\t\tif (graph[a][i] != p)\r\n\t\t{\r\n\t\t\tif (been[graph[a][i]] == 0)\r\n\t\t\t\tdfs(graph[a][i], a);\r\n\t\t\telse if (been[graph[a][i]] == 1)\r\n\t\t\t{\r\n\t\t\t\tvector<int> tmp;\r\n\t\t\t\tfor (int j = sz(st) - 1; st[j] != graph[a][i]; j--)\r\n\t\t\t\t\ttmp.push_back(st[j]);\r\n\t\t\t\ttmp.push_back(graph[a][i]);\r\n\r\n\t\t\t\trings.push_back(tmp);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tst.pop_back();\r\n\tbeen[a] = 2;\r\n}\r\n\r\nbool intersect(const vector<int> &v1, const vector<int> &v2)\r\n{\r\n\tfor (int i = 0; i < sz(v1); i++)\r\n\t\tif (find(v2.begin(), v2.end(), v1[i]) != v2.end())\r\n\t\t\treturn true;\r\n\treturn false;\r\n}\r\n\r\nint main()\r\n{\r\n\tcin.sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\r\n\tint n, m, a, b;\r\n\tcin >> n >> m;\r\n\tfor (int i = 0; i < m; i++)\r\n\t{\r\n\t\tcin >> a >> b;\r\n\t\tedges.push_back({min(a, b), max(a, b)});\r\n\t\tgraph[a].push_back(b);\r\n\t\tgraph[b].push_back(a);\r\n\t}\r\n\r\n\tdfs(1, 1);\r\n\t// debug(rings);\r\n\r\n\tvector<mod_num> pot2div(max(11, n + 1));\r\n\tpot2div[0] = mod_num(1);\r\n\tfor (int i = 1; i <= max(10, n + 1); i++)\r\n\t\tpot2div[i] = pot2div[i-1] / mod_num(2);\r\n\r\n\tmod_num sum_rings_factors(0);\r\n\r\n\tfor (int i = 0; i < sz(rings); i++)\r\n\t{\r\n\t\tsum_rings_factors += pot2div[sz(rings[i])];\r\n\t\tfor (int x : rings[i])\r\n\t\t{\r\n\t\t\tvertex_rings_factor[x] += pot2div[sz(rings[i])];\r\n\t\t}\r\n\t}\r\n\r\n\tvector<mod_num> intersecting_rings_factors(sz(rings));\r\n\tfor (int i = 0; i < sz(rings); i++)\r\n\t\tfor (int x : rings[i])\r\n\t\t\tintersecting_rings_factors[i] += vertex_rings_factor[x] - pot2div[sz(rings[i])];\r\n\r\n\tmod_num ex = mod_num(n) / mod_num(2) - mod_num(m) / mod_num(4);\r\n\tfor (int i = 0; i < rings.size(); i++)\r\n\t\tex += pot2div[sz(rings[i])];\r\n\r\n\tmod_num ex2(0);\r\n\r\n\tmod_num ev2 = mod_num(n) * mod_num(n - 1) / mod_num(4) + mod_num(n) / mod_num(2);\r\n\r\n\tmod_num ee2(0);\r\n\tfor (int i = 0; i < m; i++)\r\n\t{\r\n\t\tee2 += pot2div[2];\r\n\t\tee2 += mod_num(sz(graph[edges[i].first]) + sz(graph[edges[i].second]) - 2) * pot2div[3];\r\n\t\tee2 += mod_num(m - (sz(graph[edges[i].first]) + sz(graph[edges[i].second]) - 1)) * pot2div[4];\r\n\t}\r\n\r\n\tmod_num er2(0);\r\n\tfor (int i = 0; i < sz(rings); i++)\r\n\t{\r\n\t\ter2 += pot2div[sz(rings[i])];\r\n\t\ter2 += pot2div[sz(rings[i]) - 1] * intersecting_rings_factors[i];\r\n\t\ter2 += pot2div[sz(rings[i])] * (sum_rings_factors - intersecting_rings_factors[i] - pot2div[sz(rings[i])]);\r\n\t}\r\n\r\n\tmod_num eve;\r\n\tfor (int i = 1; i <= n; i++)\r\n\t{\r\n\t\teve += mod_num(sz(graph[i])) * pot2div[2];\r\n\t\teve += mod_num(m - sz(graph[i])) * pot2div[3];\r\n\t}\r\n\r\n\tmod_num eer;\r\n\tfor (int j = 0; j < sz(rings); j++)\r\n\t{\r\n\t\tint k = sz(rings[j]);\r\n\r\n\t\teer += mod_num(sz(rings[j])) * pot2div[sz(rings[j])];\r\n\t\tfor (int x : rings[j])\r\n\t\t{\r\n\t\t\teer += mod_num(sz(graph[x]) - 2) * pot2div[sz(rings[j]) + 1];\r\n\t\t\tk += sz(graph[x]) - 2;\r\n\t\t}\r\n\r\n\t\teer += mod_num(m - k) * pot2div[sz(rings[j]) + 2];\r\n\t}\r\n\r\n\tmod_num evr;\r\n\tfor (int i = 1; i <= n; i++)\r\n\t{\r\n\t\tevr += vertex_rings_factor[i];\r\n\t\tevr += (sum_rings_factors - vertex_rings_factor[i]) * pot2div[1];\r\n\t}\r\n\r\n\tex2 = ev2 + ee2 + er2 - mod_num(2) * eve - mod_num(2) * eer + mod_num(2) * evr;\r\n\r\n\t// debug(ex);\r\n\r\n\t// debug(ev2, ee2, er2, eve, eer, evr);\r\n\r\n\t// debug(ex2);\r\n\r\n\t// debug(ex2 - ex * ex);\r\n\r\n\tcout << (ex2 - ex * ex) << endl;\r\n}\r\n"
}