{
    "id": 66085496,
    "contestId": 1236,
    "creationTimeSeconds": 1575173841,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1236,
        "index": "F",
        "name": "Alice and the Cactus",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "dfs and similar",
            "graphs",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1236,
        "members": [
            {
                "handle": "UoA_ZQC"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1571319300
    },
    "programmingLanguage": "Clang++17 Diagnostics",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T>\ninline int sign(const T &a) {\n    if(a < 0)return -1;\n    if(a > 0)return 1;\n    return 0;\n}\n\nstring to_string(string s) { return '\"' + s + '\"'; }\n\nstring to_string(const char *s) { return to_string((string) s); }\n\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) { res += \", \"; }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin(T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax(T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\ntemplate<typename T>\ninline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    }\n    while(isdigit(ch)) {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\null twop(ll x) { return 1ULL << x; }\n\ntemplate<typename T>\nT MOD(T a, T m) {\n    a %= m;\n    if(a < 0)a += m;\n    return a;\n}\n\ntemplate<typename T>\nT inverse(T a, T m) {\n    a = MOD(a, m);\n    if(a <= 1)return a;\n    return MOD((1 - inverse(m, a) * m) / a, m);\n}\n\ntemplate<typename A, typename B>\ninline void in(A &x, B &y) {\n    in(x);\n    in(y);\n}\n\ntemplate<typename A, typename B, typename C>\ninline void in(A &x, B &y, C &z) {\n    in(x);\n    in(y);\n    in(z);\n}\n\ntemplate<typename A, typename B, typename C, typename D>\ninline void in(A &x, B &y, C &z, D &d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\ntemplate<typename T>\nT sqr(T x) { return x * x; }\n\nll gcd(ll a, ll b) {\n    while(b != 0) {\n        a %= b;\n        swap(a, b);\n    }\n    return abs(a);\n}\n\nll fast(ll a, ll b, ll mod) {\n    ll ans = 1;\n    while(b) {\n        if(b & 1) {\n            b--;\n            ans = ans * a % mod;\n        } else {\n            a = a * a % mod;\n            b /= 2;\n        }\n    }\n    return ans % mod;\n}\n\n\nll ans = 0;\n\n\nclass Articulation {\npublic:\n    static const int N = 1000005; // \u6700\u5927\u7ed3\u70b9\u4e2a\u6570\n    std::vector<PII > keyE;               // keyE\u4e3a\u5272\u8fb9\u96c6\uff0ckeyV\u4e3a\u5272\u70b9\u96c6\n    std::vector<int> keyV, cc[N];      // cc[p]\u8868\u793a\u7ed3\u70b9p\u5728\u54ea\u4e9b\u53cc\u8fde\u901a\u5206\u91cf\u4e2d\n    int cnt;  // \u5bf9\u4e8e\u65e7\u7248\u7f16\u8bd1\u5668\uff0c\u5c06\u4e0a\u9762cc[N]\u6539\u6210vector\u7684\u5f62\u5f0f\n    // \u4f20\u5165\u7ed3\u70b9\u4e2a\u6570n\u53ca\u5404\u7ed3\u70b9\u7684\u51fa\u8fb9e[]\uff0c\u8fd4\u56de\u53cc\u8fde\u901a\u5206\u91cf\u7684\u4e2a\u6570cnt\n    VI BCC[N];\n    \n    int run(int n, const std::vector<int> G[]) {\n        memset(dfn, use = 0, sizeof(dfn[0]) * n);\n        memset(low, cnt = 0, sizeof(low[0]) * n);\n        keyE.clear();\n        fill_n(cc, n, keyV = std::vector<int>());\n        for(int i = 0; i < n; ++i) {\n            if(!dfn[i]) dfs(i, 1, G);\n        }\n        REP(i, 0, n) {\n            for(auto j:cc[i]) {\n                BCC[j].PB(i);\n            }\n        }\n        REP(i, 0, N) {\n            if(BCC[i].size() <= 2)BCC[i].clear();\n            if(sz(BCC[i]))dbg(BCC[i]);\n        }\n        return cnt;\n    }\n\nprivate:\n    int dfn[N], low[N], dot[N], use;\n    \n    void dfs(int x, int dep, const std::vector<int> G[]) {\n        int src = 0, out = 1 < dep;\n        dot[use++] = x;\n        dfn[x] = low[x] = dep;\n        for(auto &y: G[x]) {\n            if(!dfn[y]) {\n                dfs(y, dep + 1, G);\n                low[x] = std::min(low[x], low[y]);\n                if(low[y] > dfn[x]) keyE.push_back(PII(x, y));\n                if(low[y] >= dfn[x]) {\n                    if(++out == 2) keyV.push_back(x);\n                    while(dot[--use] != y) cc[dot[use]].push_back(cnt);\n                    cc[x].push_back(cnt);\n                    cc[y].push_back(cnt++);\n                }\n            } else if(dfn[y] != dfn[x] - 1 || src++) {\n                low[x] = std::min(low[x], dfn[y]);\n            }\n        }\n    }\n} biconnected;\n\nVI G[500010];\nll n, m;\nvoid get_frac(ll c){\n    return;\n    REP(i,0,100){\n        REP(j,1,100){\n            if(MOD(i-j*c,mod) == 0){\n                cerr<<i<<\"/\"<<j<<endl;\n                return;\n            }\n        }\n    }\n    RREP(i,0,-100){\n        REP(j,1,100){\n            if(MOD(i-j*c,mod) == 0){\n                cerr<<i<<\"/\"<<j<<endl;\n                return;\n            }\n        }\n    }\n}\n\nvoid calcEX() {\n    ll tmp = 0;\n    tmp += n * inverse(2ll, mod);\n    tmp %= mod;\n    tmp -= m * inverse(4ll, mod);\n    tmp %= mod;\n    REP(i, 0, biconnected.N) {\n        if(biconnected.BCC[i].size()) {\n            tmp += inverse(fast(2, biconnected.BCC[i].size(), mod), mod);\n            tmp %= mod;\n        }\n    }\n    \n    \n    get_frac(tmp);\n    \n    ans -= tmp * tmp % mod;\n    \n    dbg(\"n^2\");\n    ans += (n * n + n) % mod * inverse(4ll, mod) % mod;//n^2\n    get_frac((n * n + n) % mod * inverse(4ll, mod) % mod);\n    get_frac(ans);\n    \n    dbg(\"-2nm\");\n    ans += -(2 * m + n * m) % mod * inverse(4ll, mod) % mod;//E[-2nm] = -(2m+nm)/4\n    get_frac(-(2 * m + n * m) % mod * inverse(4ll, mod) % mod);\n    get_frac(ans);\n    ans = MOD(ans, mod);\n}\n\n\nvoid calcNC() {\n    ll tmp = 0;\n    REP(i, 0, biconnected.N) {\n        if(biconnected.BCC[i].size()) {\n            tmp += biconnected.BCC[i].size() * inverse(fast(2, biconnected.BCC[i].size(), mod), mod);\n            tmp %= mod;\n            tmp += (n - biconnected.BCC[i].size()) * inverse(fast(2, biconnected.BCC[i].size() + 1, mod), mod);\n            tmp %= mod;\n        }\n    }\n    tmp *= 2;\n    dbg(\"2nc\");\n    get_frac(tmp);\n    ans += tmp;\n    ans %= mod;\n}\n\nvoid calcm2() {\n    ll tot = m * m - m;\n    ll tmp = 0;\n    tmp += m * inverse(4ll, mod) % mod;\n    get_frac(tmp);\n    \n    REP(i, 0, n) {\n        ll siz = sz(G[i]);\n        ll cnt = siz * (siz - 1) ;\n        tot -= cnt;\n        tmp += cnt * inverse(8ll, mod) % mod;\n    }\n    tmp += tot * inverse(16ll, mod) % mod;\n    get_frac(tmp);\n    ans += tmp % mod;\n}\n\nvoid calccm() {\n    ll tmp = 0;\n    REP(i, 0, biconnected.N) {\n        if(biconnected.BCC[i].size()) {\n            ll tot = m;\n            ll siz = biconnected.BCC[i].size();\n            tot -= siz;\n            tmp += fast(inverse(2ll, mod), siz, mod) * siz % mod;\n            for(auto v:biconnected.BCC[i]) {\n                ll cnt = sz(G[v]) - 2;\n                tot -= cnt;\n                tmp += fast(inverse(2ll, mod), siz + 1, mod) * cnt % mod;\n            }\n            tmp += fast(inverse(2ll, mod), siz + 2, mod) * tot % mod;\n        }\n    }\n    dbg(\"cm\");\n    get_frac(tmp);\n    ans += -2 * tmp;\n    ans %= mod;\n}\n\n\nvoid calccc() {\n    ll tmpans = 0;\n    ll tot = 0;\n    REP(i, 0, biconnected.N) {\n        if(biconnected.BCC[i].size()) {\n            tot += fast(inverse(2ll, mod), biconnected.BCC[i].size(), mod);\n        }\n    }\n    tot %= mod;\n    get_frac(tot);\n    tmpans += tot * tot % mod;\n    REP(i, 0, n) {\n        VLL sizs;\n        ll tmp = 0;\n        for(auto c:biconnected.cc[i]) {\n            sizs.PB(sz(biconnected.BCC[c]));\n            if(sizs.back() != 0) {\n                tmp += fast(inverse(2ll, mod), sizs.back(), mod);\n            }\n        }\n        dbg(111);\n        get_frac(tmp);\n    \n        tmpans += tmp*tmp%mod;\n    }\n    REP(i, 0, biconnected.N) {\n        if(biconnected.BCC[i].size()) {\n            ll siz = biconnected.BCC[i].size();\n            tmpans += fast(inverse(2ll, mod), siz, mod) -  (siz+1)*fast(inverse(2ll, mod), 2*siz, mod);\n        }\n    }\n    dbg(\"c^2\");\n    \n    get_frac(tmpans);\n    ans += tmpans;\n}\n\n\nnamespace SOLVE {\n    void main() {\n        in(n, m);\n        REP(i, 0, m) {\n            int u, v;\n            in(u, v);\n            G[u - 1].PB(v - 1);\n            G[v - 1].PB(u - 1);\n        }\n        biconnected.run(n, G);\n        calcEX();\n        calcNC();\n        calcm2();\n        calccm();\n        calccc();\n        get_frac(ans);\n        cout << MOD(ans,mod) << endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    int t = 1;\n//    in(t);\n    for(int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\":\";\n        SOLVE::main();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
}