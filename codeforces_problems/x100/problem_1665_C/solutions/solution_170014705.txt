{
    "id": 170014705,
    "contestId": 1665,
    "creationTimeSeconds": 1661724485,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1665,
        "index": "C",
        "name": "Tree Infection",
        "type": "PROGRAMMING",
        "points": 1250.0,
        "rating": 1600,
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "trees"
        ]
    },
    "author": {
        "contestId": 1665,
        "members": [
            {
                "handle": "Ragnexas"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1649428500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 8499200,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nvoid __print(int x) {cerr << x;}\r\nvoid __print(long x) {cerr << x;}\r\nvoid __print(long long x) {cerr << x;}\r\nvoid __print(unsigned x) {cerr << x;}\r\nvoid __print(unsigned long x) {cerr << x;}\r\nvoid __print(unsigned long long x) {cerr << x;}\r\nvoid __print(float x) {cerr << x;}\r\nvoid __print(double x) {cerr << x;}\r\nvoid __print(long double x) {cerr << x;}\r\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\r\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\r\n\r\ntemplate<typename T, typename V>\r\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\r\ntemplate<typename T>\r\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\r\nvoid _print() {cerr << \"]\\n\";}\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\r\n#else\r\n#define debug(x...)\r\n#endif\r\n#define all(x) x.begin(),x.end()\r\n \r\ntypedef long long ll;\r\nusing vi = vector<int>;\r\nusing vll = vector<ll>;\r\nusing pi = pair<int,int>;\r\nusing vpi = vector<pi>;\r\nusing vb = vector<bool>;\r\n\r\n#include <ext/pb_ds/assoc_container.hpp> //required\r\n#include <ext/pb_ds/tree_policy.hpp> //required\r\nusing namespace __gnu_pbds; //required \r\nusing namespace std;\r\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n \r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\n\r\n\r\nstruct ordered_multiset{\r\n    ordered_multiset() {}\r\n    ordered_set<pair<int,size_t>> os;\r\n    size_t size = 0;\r\n\r\n    void insert(int x) {\r\n        os.insert({x,size++});\r\n    }\r\n\r\n    void erase(int x) {\r\n        os.erase(os.lower_bound({x,0}));\r\n    }\r\n    int order_of_key(int x) {\r\n        return os.order_of_key({x,0});\r\n    }\r\n\r\n    int find_by_order(int k) {\r\n        return (*os.find_by_order(k)).first;\r\n    }\r\n\r\n};\r\n\r\n\r\n\r\nconst ll MOD = 1e9+7;\r\nconst int N = 200001;\r\n \r\n\r\ntemplate <class T> \r\nstruct seg_tree {\r\n    vector<T> tree;\r\n    int arr_size;\r\n\r\n    seg_tree(int size, T def) {\r\n        int new_size = size;\r\n        while( __builtin_popcount(new_size) != 1) {\r\n            new_size++;\r\n        }\r\n        tree.resize(2*new_size);\r\n        arr_size = new_size;\r\n\r\n        for(int i = new_size;i < 2*new_size;i++) tree[i] = def;\r\n\r\n        for(int i = new_size - 1;i >= 1;i--) {\r\n            tree[i] = tree[2*i] + tree[2*i + 1];\r\n        }\r\n    }\r\n\r\n    seg_tree() {\r\n\r\n    }\r\n\r\n    seg_tree(vector<T> arr) {\r\n        int size = arr.size();\r\n        int new_size = size;\r\n        while( __builtin_popcount(new_size) != 1) {\r\n            new_size++;\r\n        }\r\n        tree.resize(2*new_size);\r\n        arr_size = new_size;\r\n        for(int i = 0;i < size;i++) {\r\n            tree[i+new_size] = arr[i];\r\n        }\r\n        for(int i = new_size - 1;i >= 1;i--) {\r\n            tree[i] = tree[2*i] + tree[2*i + 1];\r\n        }\r\n    }\r\n\r\n\r\n    seg_tree(T arr[], int size) {\r\n        int new_size = size;\r\n        while( __builtin_popcount(new_size) != 1) {\r\n            new_size++;\r\n        }\r\n        tree.resize(2*new_size);\r\n        arr_size = new_size;\r\n        for(int i = 0;i < size;i++) {\r\n            tree[i+new_size] = arr[i];\r\n        }\r\n        for(int i = new_size - 1;i >= 1;i--) {\r\n            tree[i] = tree[2*i] + tree[2*i + 1];\r\n        }\r\n    }\r\n    private:\r\n    void update_helper(int node) {\r\n        if(node == 0) return;\r\n        tree[node] = tree[2*node] + tree[2*node + 1];\r\n        update_helper(node/2);\r\n    }\r\n\r\n    public:\r\n    void update(int index, T value) {\r\n        tree[index + arr_size] = value;\r\n        update_helper((index + arr_size)/2);\r\n    }\r\n\r\n    T query(int q_left, int q_right, int node = 1, int node_left = 0, int node_right = -1) {\r\n        if(node_right == -1) {\r\n            node_right = arr_size - 1;\r\n        }\r\n\r\n        if(q_left <= node_left && q_right >= node_right) {\r\n            return tree[node]; \r\n        }\r\n        if(q_right < node_left || q_left > node_right) {\r\n            return (T)0;\r\n        } \r\n        int mid = (node_left + node_right) / 2;\r\n        return query(q_left, q_right, 2*node, node_left, mid)\r\n        + query(q_left, q_right, 2*node + 1, mid + 1, node_right);\r\n    }\r\n\r\n    T get(int i) {\r\n        return tree[arr_size + i];\r\n    }\r\n}; \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid solve() {\r\n    int n; cin >> n;\r\n    vi count(n,0);\r\n    set<int> st;\r\n    for(int i = 2;i <= n;i++) {\r\n        int x; cin >> x;\r\n        count[x]++, st.insert(x);\r\n    }\r\n    int g = st.size(), nw = g;\r\n    int ans = g + 1;\r\n    sort(all(count), greater<>());\r\n    //debug(count, g);\r\n    for(int i = 0;i < g;i++) {\r\n        count[i] -= min(count[i], g - i + 1);\r\n        if(count[i] == 0)nw--;\r\n    }\r\n    if(nw == 0) {\r\n        cout << ans << \"\\n\";\r\n        return;\r\n    }\r\n    int s = 0;\r\n    sort(all(count), greater<>());\r\n    vi pre(nw);for(int i = 0;i < nw;i++)pre[i] += s, s += count[i];\r\n    //debug(count, nw, pre);\r\n    int best = INT_MAX;\r\n    for(int i = 0;i < nw;i++) {\r\n        int left = count[i] - (pre[i] - i*count[i]);\r\n        if(left > 0)best = min(best, left/2 + left%2);\r\n    }\r\n    if(best != INT_MAX)ans+=best;\r\n    cout << ans << '\\n';\r\n} \r\n\r\nint main() { \r\n    ios_base::sync_with_stdio(false); cin.tie(0);\r\n    int t;cin >> t;\r\n    for(int i = 1;i <= t;i++) {\r\n        solve();\r\n    }\r\n    return 0;\r\n}"
}