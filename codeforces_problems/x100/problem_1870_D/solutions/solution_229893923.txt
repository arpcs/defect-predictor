{
    "id": 229893923,
    "contestId": 1870,
    "creationTimeSeconds": 1698334623,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1870,
        "index": "D",
        "name": "Prefix Purchase",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1800,
        "tags": [
            "greedy",
            "implementation",
            "sortings"
        ]
    },
    "author": {
        "contestId": 1870,
        "members": [
            {
                "handle": "ND_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1695047700
    },
    "programmingLanguage": "Java 8",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 0,
    "source": "\nimport java.io.*;\nimport java.util.*;\npublic class Codeforces {\n    /*-------------------------------------------EDITING CODE STARTS HERE-------------------------------------------*/\n    public static void solve(int tCase) throws IOException {\n        int n = sc.nextInt();\n        int [] arr = new int[n];\n        for(int i=0;i<n;i++)arr[i] = sc.nextInt();\n        int k = sc.nextInt();\n        int mn = arr[0];\n        int ok = k;\n        int ind = 0;\n        for(int i=0;i<n;i++){\n            if(arr[i] <=mn){\n                mn  = arr[i];\n                ind = i;\n            }\n        }\n        int[] ans = new int[n];\n        int cnt = k / mn;\n        k %= mn;\n        for(int i = n-1;i>ind && cnt > 0;i--){\n            while((k + mn) >= arr[i]){\n                ans[i]++;\n                cnt--;\n                k = k + mn - arr[i];\n            }\n        }\n        ans[ind]+=cnt;\n        for(int i=n-2;i>=0;i--)ans[i] += ans[i+1];\n        for(int x : ans){\n            out.print(x+\" \");\n            count++;\n//            if(tt==7380 && count==93)throw new IOException(Arrays.toString(arr)+\" \"+ok);\n        }\n\n        out.println();\n    }\n    static int count = 0;\n    static int tt = 0;\n    public static void main(String[] args) throws IOException {\n        openIO();\n        int testCase = 1;\n        testCase = sc.nextInt();\n        tt = testCase;\n        for (int i = 1; i <= testCase; i++) solve(i);\n        closeIO();\n    }\n\n\n    /*-------------------------------------------EDITING CODE ENDS HERE-------------------------------------------*/\n    /*--------------------------------------HELPER FUNCTIONS STARTS HERE-----------------------------------------*/\n\n    public static long mod = (int) 1e9+17;\n    //    public static long mod =  998244353;\n    public static int inf_int = (int)2e9+10;\n    public static long inf_long = (long)2e14 + 10;\n\n    public static void _sort(int[] arr, boolean isAscending) {\n        int n = arr.length;\n        List<Integer> list = new ArrayList<>();\n        for (int ele : arr) list.add(ele);\n        Collections.sort(list);\n        if (!isAscending) Collections.reverse(list);\n        for (int i = 0; i < n; i++) arr[i] = list.get(i);\n    }\n\n    public static void _sort(long[] arr, boolean isAscending) {\n        int n = arr.length;\n        List<Long> list = new ArrayList<>();\n        for (long ele : arr) list.add(ele);\n        Collections.sort(list);\n        if (!isAscending) Collections.reverse(list);\n        for (int i = 0; i < n; i++) arr[i] = list.get(i);\n    }\n\n    // time : O(1), space : O(1)\n    public static int _digitCount(long num,int base){\n        // this will give the # of digits needed for a number num in format : base\n        return (int)(1 + Math.log(num)/Math.log(base));\n    }\n\n    // time for pre-computation of factorial and inverse-factorial table : O(nlog(mod))\n    public static long[] factorial , inverseFact;\n    public static void _ncr_precompute(int n){\n        factorial = new long[n+1];\n        inverseFact = new long[n+1];\n        factorial[0] = inverseFact[0] = 1;\n        for (int i = 1; i <=n; i++) {\n            factorial[i] = (factorial[i - 1] * i) % mod;\n            inverseFact[i] = _modExpo(factorial[i], mod - 2);\n        }\n    }\n    // time of factorial calculation after pre-computation is O(1)\n    public static int _ncr(int n,int r){\n        if(r > n)return 0;\n        return (int)(factorial[n] * inverseFact[r] % mod * inverseFact[n - r] % mod);\n    }\n    public static int _npr(int n,int r){\n        if(r > n)return 0;\n        return (int)(factorial[n] * inverseFact[n - r] % mod);\n    }\n\n    // euclidean algorithm time O(max (loga ,logb))\n    public static long _gcd(long a, long b) {\n        while (a>0){\n            long x = a;\n            a = b % a;\n            b = x;\n        }\n        return b;\n    }\n\n    // lcm(a,b) * gcd(a,b) = a * b\n    public static long _lcm(long a, long b) {\n        return (a / _gcd(a, b)) * b;\n    }\n\n    // binary exponentiation time O(logn)\n    public static long _modExpo(long x, long n) {\n        if(x==1)return 1;\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans *= x;\n                ans %= mod;\n                n--;\n            } else {\n                x *= x;\n                x %= mod;\n                n >>= 1;\n            }\n        }\n        return ans;\n    }\n    // function to find a/b under modulo mod. time : O(logn)\n    public static long _modInv(long a,long b){\n        return (a * _modExpo(b,mod-2)) % mod;\n    }\n\n    //sieve or first divisor time : O(mx * log ( log (mx) ) )\n    public static int[]  _seive(int mx){\n        int[] firstDivisor = new int[mx+1];\n        firstDivisor[0] = firstDivisor[1] = 1;\n        for(int i=2;i<=mx;i++)firstDivisor[i] = i;\n        for(int i=2;i*i<=mx;i++)\n            if(firstDivisor[i] == i)\n                for(int j = i*i;j<=mx;j+=i)\n                    if(firstDivisor[j]==j)firstDivisor[j] = i;\n        return firstDivisor;\n    }\n\n    static class Pair<K, V>{\n        K ff;\n        V ss;\n\n        public Pair(K ff, V ss) {\n            this.ff = ff;\n            this.ss = ss;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || this.getClass() != o.getClass()) return false;\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n            return ff.equals(pair.ff) && ss.equals(pair.ss);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(ff, ss);\n        }\n        @Override\n        public String toString(){\n            return ff.toString()+\" \"+ss.toString();\n        }\n    }\n    // takes O(sqrt(n))\n    private static boolean _isPrime(long n){\n        if(n<2)return false;\n        for(long i=2;i*i<=n;i++)\n            if(n%i == 0)return false;\n        return true;\n    }\n\n    /*--------------------------------------HELPER FUNCTIONS ENDS HERE-----------------------------------------*/\n    /*-------------------------------------------FAST INPUT STARTS HERE---------------------------------------------*/\n    static FastestReader sc;\n    static PrintWriter out;\n\n    private static void openIO() throws IOException {\n        sc = new FastestReader();\n        out = new PrintWriter(System.out);\n    }\n\n    public static void closeIO() throws IOException {\n        out.flush();\n        out.close();\n        sc.close();\n    }\n\n    private static final class FastestReader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastestReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastestReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private int skip() throws IOException {\n            int b;\n            //noinspection StatementWithEmptyBody\n            while ((b = read()) != -1 && isSpaceChar(b)) {}\n            return b;\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n\n            final boolean neg = c == '-';\n            if (neg) c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            return neg?-ret:ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n\n            final boolean neg = c == '-';\n            if (neg) c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            return neg?-ret:ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n\n            final boolean neg = c == '-';\n            if (neg) c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n                while ((c = read()) >= '0' && c <= '9')\n                    ret += (c - '0') / (div *= 10);\n\n            return neg?-ret:ret;\n        }\n        public String nextLine() throws IOException {\n            final byte[] buf = new byte[(1<<10)]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    break;\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n        public void close() throws IOException {\n            din.close();\n        }\n    }\n    /*---------------------------------------------FAST INPUT ENDS HERE ---------------------------------------------*/\n}\n/** Some points to keep in mind :\n * 1. don't use Arrays.sort(primitive data type array)\n * 2. try to make the parameters of a recursive function as less as possible,more use static variables.\n * 3. If n = 5000, then O(n^2 logn) need atleast 4 sec to work\n * 4. dp[2][n] works faster than dp[n][2]\n * 5. if split wrt 1 char use '\\\\' before char: .split(\"\\\\.\");\n * 6. while using dp, do not change the state variable for next recursive call apart from the function call itself.\n * 7. (int + int + long) can give integer overflow while (long + int + int) will not\n * 8. when you divide while doing modulo, better to use modular inverse for division\n * 9. If you are subtracting under modulo, always add mod and then take mod after subtraction\n *\n *\n **/"
}