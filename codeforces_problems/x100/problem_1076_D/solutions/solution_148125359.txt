{
    "id": 148125359,
    "contestId": 1076,
    "creationTimeSeconds": 1646231872,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1076,
        "index": "D",
        "name": "Edge Deletion",
        "type": "PROGRAMMING",
        "rating": 1800,
        "tags": [
            "graphs",
            "greedy",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1076,
        "members": [
            {
                "handle": "kelvin_0179"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1542033300
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\n\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n// using namespace __gnu_pbds;\r\n#define MODS 100005\r\n#define MOD 1000000007\r\n#define all(x) (x).begin(), (x).end()\r\n#define ll long long\r\n#define ld long double\r\n#define bigint int64_t\r\n#define vll vector<ll>\r\n#define vpll vector<pair<ll,ll>>\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define pb push_back\r\n#define test ll t;read(t);while(t--)\r\n#define pll pair<ll,ll>\r\n#define vvll vector<vector<ll>>\r\n#define fst first\r\n#define scd second\r\n#define ins insert\r\n#define line \"\\n\"\r\n#define yes \"YES\"\r\n#define no \"NO\"\r\n#define tup tuple<ll,ll,ll>\r\n\r\n#define debug2(x,y)  cerr << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<line;\r\n#define debug3(x,y,z)cerr << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<line;\r\n#define forn(i,n) for(ll (i) = 0 ; (i) < (n) ; ++(i))\r\n#define for1(i,n) for(ll (i) = 1 ; (i) <= (n) ; ++(i))\r\n#define forr(i,n) for(ll (i) = (n)-1 ; (i)>=0 ; --(i))\r\n#define forab(i,a,b,c) for(ll (i) = a ; (i) <= (b) ; (i)+=(c))\r\n\r\n// #define pbds tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x)    cerr << #x <<\"=\"; _print(x); cerr << line;\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\ntemplate <typename T>                                           void read(T &x){cin >> x;}\r\ntemplate <typename T , typename T0>                             void read(T &x,T0 &y){cin >> x >> y;}\r\ntemplate <typename T , typename T0 , typename T1>               void read(T &x,T0 &y,T1 &z){cin >> x >> y >> z;}\r\ntemplate <typename T , typename T0 , typename T1 , typename T2> void read(T &x,T0 &y,T1 &z,T2 &w){cin >> x >> y >> z >> w;}\r\ntemplate <typename T , typename T0>                             void read(pair< T , T0 > &p){cin >> p.fst >>p.scd;}\r\ntemplate <typename T>                                           void read(vector< T > &oneD,ll n){forn(i,n){T x;read(x);oneD.push_back(x);}}\r\ntemplate <typename T>                                           void read(T oneD[] , ll n){for(ll i=0;i<n;i++){read(oneD[i]);}}\r\ntemplate <typename T>                                           void write(T &x){cout << x << \" \";}\r\ntemplate <typename T>                                           void wrtline(T &x){cout << x << line;}\r\ntemplate <typename T , typename T0>                             void write(T &x,T0 &y){cout << x << \" \" << y << \"\\n\";}\r\ntemplate <typename T , typename T0 , typename T1>               void write(T &x,T0 &y,T1 &z){cout << x << \" \" << y << \" \" << z << \"\\n\";}\r\ntemplate <typename T , typename T0 , typename T1 , typename T2> void write(T &x,T0 &y,T1 &z,T2 &w){cout << x << \" \" << y << \" \" << z << \" \" << w << \"\\n\";}\r\ntemplate <typename T , typename T0>                             void write(pair< T , T0 > &p){write(p.fst);write(p.scd);cout << line;}\r\ntemplate <typename T>                                           void write(vector< T > &oneD,ll n){for(ll i=0;i<n;i++){cout<<oneD[i]<<\" \";}cout << line;}\r\ntemplate <typename T>                                           void write(T oneD[] ,int &n){for(ll i=0;i<n;i++){write(oneD[i]);}cout <<line;}\r\ntemplate <typename T , typename T0>                             void write(map< T , T0 > &mpp){for(auto it : mpp){write(it.fst);cout << \": \";write(it.scd);cout << \"\\n\";}cout<<line;}\r\ntemplate <typename T>                                           void write(vector<vector<T>> &rc,T &n,T &m){forn(i,n){forn(j,m){cout<<rc[i][j]<<\" \";}cout<<line;}}\r\ntemplate <typename T>                                           void _print(T &t) {cerr << t;}\r\ntemplate <class T, class V>                                     void _print(pair <T, V> &p);\r\ntemplate <class T>                                              void _print(vector <T> &v);\r\ntemplate <class T>                                              void _print(set <T> &v);\r\ntemplate <class T, class V>                                     void _print(map <T, V> &v);\r\ntemplate <class T>                                              void _print(multiset <T> &v);\r\ntemplate <class T, class V>                                     void _print(pair <T, V> &p) {cerr << \"{\"; _print(p.fst); cerr << \",\"; _print(p.scd); cerr << \"}\";}\r\ntemplate <class T>                                              void _print(vector <T> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(set <T> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(multiset <T> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V>                                     void _print(map <T, V> &v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\n\r\n\r\nclass UnionFind {\r\n    public :\r\n   ll size2;\r\n   vector<ll> sz,id;\r\n   ll numComponents;\r\n\r\n  UnionFind(ll size1) {\r\n\r\n    if (size1 <= 0)\r\n    {\r\n        cout<<\"Not Allowed\";\r\n        return;\r\n    }\r\n\r\n    size2 = size1;\r\n    numComponents=size1;\r\n\r\n    for (ll i = 0; i <=size1; i++) {\r\n      id.push_back(i);// Link to itself (self root)\r\n      sz.push_back(1); // Each component is originally of size one\r\n    }\r\n  }\r\n\r\n   ll find1(ll p) {\r\n\r\n    // Find the root of the component/set\r\n    ll root = p;\r\n    while (root != id[root]) root = id[root];\r\n\r\n    // Compress the path leading back to the root.\r\n    // Doing this operation is called \"path compression\"\r\n    // and is what gives us amortized time complexity.\r\n    while (p != root) {\r\n      ll next = id[p];\r\n      id[p] = root;\r\n      p = next;\r\n    }\r\n\r\n    return root;\r\n  }\r\n\r\n \r\n   bool connected(ll p,ll q) {\r\n    return find1(p) == find1(q);\r\n  }\r\n\r\n   ll componentSize(ll p) {\r\n    return sz[find1(p)];\r\n  }\r\n\r\n   ll sizecom() {\r\n    return size2;\r\n  }\r\n\r\n  // Returns the number of remaining components/sets\r\n   ll components() {\r\n    return numComponents;\r\n  }\r\n\r\n   bool unify(ll p, ll q) {\r\n    ll root1 = find1(p);\r\n    ll root2 = find1(q);\r\n    // These elements are already in the same group!\r\n    if (root1 == root2) return 0;\r\n\r\n    // Merge smaller component/set into the larger one.\r\n    if (sz[root1] < sz[root2]) {\r\n      sz[root2] += sz[root1];\r\n      id[root1] = root2;\r\n      sz[root1]=1;\r\n    } else {\r\n      sz[root1] += sz[root2];\r\n      id[root2] = root1;\r\n      sz[root2]=1;\r\n    }\r\n\r\n    // Since the roots found are different we know that the\r\n    // number of components/sets has decreased by one\r\n    numComponents--;\r\n    return 1;\r\n  }\r\n};\r\nll n,m,k;\r\nvector<vector<pll>> graph;\r\nvll ans;\r\nvoid dfs(ll par,ll curr)\r\n{\r\n    if((ll)ans.size()>=k)\r\n        return;\r\n    for(auto it: graph[curr])\r\n    {\r\n        if(it.fst!=par)\r\n        {\r\n            ans.pb(it.scd);\r\n            dfs(curr,it.fst);\r\n        }\r\n    }\r\n}\r\nvoid solve()\r\n{\r\n    read(n,m,k);\r\n    graph=vector<vector<pll>>(n+1);\r\n    priority_queue<vll,vvll,greater<vll>> pq;\r\n    forn(i,m)\r\n    {\r\n        ll x,y,w;\r\n        read(x,y,w);\r\n        pq.push({w,x,y,i+1});\r\n    }\r\n    UnionFind ob(n);\r\n    while(!pq.empty())\r\n    {\r\n        vll temp=pq.top();\r\n        pq.pop();\r\n        if(ob.unify(temp[1],temp[2]))\r\n        {\r\n            graph[temp[1]].pb({temp[2],temp[3]});\r\n            graph[temp[2]].pb({temp[1],temp[3]});\r\n        }\r\n    }\r\n    dfs(0,1);\r\n    cout<<min(k,(ll)ans.size())<<line;\r\n    write(ans,min(k,(ll)ans.size()));\r\n}\r\nint main() {\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stderr);\r\n#endif\r\nios_base::sync_with_stdio(false);\r\ncin.tie(NULL);\r\n//*******************************************************//\r\n// test\r\nsolve();\r\n\r\nreturn 0;\r\n}"
}