{
    "id": 232972397,
    "contestId": 1076,
    "creationTimeSeconds": 1700140720,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1076,
        "index": "D",
        "name": "Edge Deletion",
        "type": "PROGRAMMING",
        "rating": 1800,
        "tags": [
            "graphs",
            "greedy",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1076,
        "members": [
            {
                "handle": "Mc3X"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1542033300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 73,
    "timeConsumedMillis": 499,
    "memoryConsumedBytes": 53964800,
    "source": "#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n \r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\nusing namespace std;\r\nusing i64 = uint64_t;\r\n//using i128 = __int128;\r\n#define MAXN 100005\r\n#define MAXM 305\r\n#define MAXK 65\r\n#define MAXT 102\r\n#define OP 0\r\n#define CLO 1\r\n#define PLUS 0\r\n#define MINUS 1\r\n#define MUL 2\r\n#define HORZ 0\r\n#define VERT 1\r\n#define ITER 65\r\n#define INF 1e18\r\n#define EPS 1e-9\r\n#define MOD 1000000007\r\n#define SRC 0\r\n#define PUSH 0\r\n#define POP 1\r\n#define PI acos(-1)\r\n#define UNVISITED INF\r\n#define FOR 0\r\n#define BACK 1\r\n#define OK 2\r\n#define H 17\r\n#define HSH 3\r\ntypedef long long ll;\r\ntypedef __int128_t lint;\r\ntypedef long double ld;\r\ntypedef pair<int,int> ii;\r\ntypedef pair<int,ll> ilp;\r\ntypedef pair<ll,ii> pl;\r\ntypedef pair<ll, ll> pll;\r\ntypedef pair<ll,int> ppll;\r\ntypedef pair<ll,int> li;\r\ntypedef pair<ll,ll> iv;\r\ntypedef pair<double,int> ip;\r\ntypedef tuple<int,int,int> iii;\r\ntypedef tuple<ll, ll, ll> tll;\r\ntypedef tuple<ld, int, int> iit;\r\ntypedef tuple<int,int,ll> i3;\r\ntypedef vector<vector<int>> vv;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\ntypedef vector<ii> vii;\r\ntypedef vector<vector<ll>> vll;\r\n//typedef complex<ld> cd;\r\ntypedef tuple<ll,int,int> tpl;\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ppb pop_back\r\n#define ppf pop_front\r\n#define pf push_front\r\n#define bk back()\r\n#define frnt front()\r\n#define ins insert\r\n#define er erase\r\n#define sc second\r\n#define fr first\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define repl(i,x,y) for (int i = (x); i <= (y); ++i)\r\n#define rep(i,x,y) for (int i = (x); i < (y); ++i)\r\n#define rev(i,x,y) for (int i = (x); i >= (y); --i)\r\n#define repd(i,x,y,d) for (int i = (x); i < (y); i += (d))\r\n#define LSOne(S) (S & (-S))\r\n#define trav(i,v) for (auto &i : v)\r\n#define foreach(it,v) for (auto it = begin(v); it != end(v); ++it)\r\n#define bend(v) begin(v), end(v)\r\n#define rbend(v) (v).rbegin(), (v).rend()\r\n#define sortarr(v) sort(bend(v))\r\n#define rsortarr(v) sort(rbend(v))\r\n#define rdup(v) v.er(unique(bend(v)), end(v))\r\n#define rstreak(v) v.resize(unique(bend(v)) - begin(v))\r\n#define extend(A,B) A.insert(end(A), bend(B))\r\n#define sz(A) (int)(A.size())\r\n#define fill(V) iota(bend(V), (0))\r\n#define vfill(V, st) iota(bend(V), st)\r\n#define sum(V) accumulate(bend(V), 0LL)\r\n#define vsum(V, st) accumulate(bend(V), (ll)(st))\r\n#define freq(V, amt) (int)(count(bend(V), amt))\r\ntemplate<class T> bool ckmin(T &a, T b) { return a > b ? a = b, 1 : 0; };\r\ntemplate<class T> bool ckmax(T &a, T b) { return a < b ? a = b, 1 : 0; };\r\ntemplate<class T> void amax(T &a, T b, T c) { a = max(b, c); };\r\ntemplate<class T> void amin(T &a, T b, T c) { a = min(b, c); };\r\ntemplate<class T> T getmax(vector<T> &v) { return *max_element(bend(v)); };\r\ntemplate<class T> T getmin(vector<T> &v) { return *min_element(bend(v)); };\r\ntemplate<class vi> void distinct(vi &a) { sortarr(a); rdup(a); };\r\ntemplate<class T> int compress(vector<T> &v, T val) { return (int)(lower_bound(bend(v), val) - begin(v)); };\r\ntemplate<class T> int ucompress(vector<T> &v, T val) { return (int)(upper_bound(bend(v), val) - begin(v)); };\r\ntemplate<class T> auto vfind(vector<T> &v, T val) {\r\n    return find(bend(v), val);\r\n}\r\ntemplate<class T> auto verase(vector<T> &v, T val) {\r\n    return v.er(vfind(v, val));\r\n}\r\ntemplate<class T> void revarr(vector<T> &v) { reverse(bend(v)); };\r\ntemplate<class T> void print(vector<T> &v, char end) { trav(i,v) cout << i << end;\r\n}\r\n \r\nmt19937 gen((int)(chrono::steady_clock::now().time_since_epoch().count()));\r\nll rng(ll l,ll r) {return uniform_int_distribution<ll>(l,r)(gen);}\r\n \r\nvoid fast_io() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL); cout.tie(NULL);\r\n}\r\n \r\nint gcd(int a, int b) {\r\n    if (!a) return b;\r\n    return gcd(b % a, a);\r\n}\r\n \r\nvector<ii> mv = {{-1,0}, {0,1}, {1,0}, {0,-1}};\r\nvector<ii> mv2 = {{-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}};\r\n//first try to remove all edges not part of the shortest path DAG\r\n//then remove cross edges in the DAG that is not part of the spanning tree\r\n//finally remove all edges in the spanning tree with the minimum subtree size\r\nint n,m,k;\r\nint main() {\r\n    fast_io();\r\n    //int t; cin >> t;\r\n    //while (t--) solve();\r\n    cin >> n >> m >> k;\r\n    vector<vector<iii>> adj(n), nadj(n);\r\n    vector<iii> el;\r\n    rep(i,0,m) {\r\n        int x,y,w; cin >> x >> y >> w;\r\n        x--, y--;\r\n        adj[x].eb(y,w,i);\r\n        adj[y].eb(x,w,i);\r\n        el.eb(x,y,w);\r\n    }\r\n    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;\r\n    vector<ll> d(n, INF);\r\n    d[0] = 0;\r\n    pq.push({d[0], 0});\r\n    while (!pq.empty()) {\r\n        auto [dist, u] = pq.top();\r\n        pq.pop();\r\n        if (dist != d[u]) continue;\r\n        for (auto &[v,w,id] : adj[u]) {\r\n            if (d[v] > d[u] + w) {\r\n                d[v] = d[u] + w;\r\n                pq.push({d[v], v});\r\n            }\r\n        }\r\n    }\r\n    vi remove;\r\n    rep(i,0,m) {\r\n        auto &[x,y,w] = el[i];\r\n        if (d[x] + w == d[y]) {\r\n            nadj[x].eb(y,w,i);\r\n        } else if (d[y] + w == d[x]) nadj[y].eb(x,w,i);\r\n        else remove.eb(i);\r\n    }\r\n    vector<bool> removed(m);\r\n    if (sz(remove) >= m - k) {\r\n        trav(i,remove) removed[i] = true;\r\n    } else {\r\n        swap(adj,nadj);\r\n        vi sub(n), par(n);\r\n        vector<bool> vis(n);\r\n        vector<ii> cand;\r\n        function<int(int, int)> dfs = [&](int u, int p) {\r\n            vis[u] = true;\r\n            sub[u] = 1;\r\n            par[u] = p;\r\n            for (auto &[v,w,id] : adj[u]) {\r\n                if (!vis[v]) sub[u] += dfs(v, id);\r\n                else remove.eb(id);\r\n            }\r\n            if (p != -1) cand.eb(sub[u], par[u]);\r\n            return sub[u];\r\n        };\r\n        dfs(0,-1);\r\n        trav(i,remove) removed[i] = true;\r\n        if (sz(remove) < m - k) {\r\n            sortarr(cand);\r\n            rep(i,0,m-k-sz(remove)) removed[cand[i].sc] = true;\r\n        }\r\n    }\r\n    vi left;\r\n    rep(i,0,m) {\r\n        if (!removed[i]) left.eb(i);\r\n    }\r\n    cout << sz(left) << '\\n';\r\n    trav(i,left) cout << i + 1 << ' ';\r\n}"
}