{
    "id": 103658595,
    "contestId": 1076,
    "creationTimeSeconds": 1610041168,
    "relativeTimeSeconds": 3868,
    "problem": {
        "contestId": 1076,
        "index": "D",
        "name": "Edge Deletion",
        "type": "PROGRAMMING",
        "rating": 1800,
        "tags": [
            "graphs",
            "greedy",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1076,
        "members": [
            {
                "handle": "suyash_jain_"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1610037300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 48230400,
    "source": "#include<bits/stdc++.h>\r\n#include <ext/pb_ds/tree_policy.hpp> \r\n#include <ext/pb_ds/assoc_container.hpp> \r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define mem(a, b) memset(a, (b), sizeof(a))\r\n#define all(cont) cont.begin(), cont.end()\r\n#define ll long long int\r\n#define ld long double \r\n#define inf LLONG_MAX\r\n#define endl \"\\n\"\r\n#define inp(a) int a;cin>>a;\r\n#define inpv(a,n)vector<int> a(n);for(int i = 0; i<n; i++)cin>>a[i];\r\nconst double pi=acos(-1.0);\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; //greater<int> can also be used\r\n#define printclock cerr<<\"Running Time is: \"<<1000*(ld)clock()/(ld)CLOCKS_PER_SEC<<\"ms\\n\";\r\n#define sz(c) (int)c.size()\r\n#define d1(x)            cout<<#x<<\"=\"<<x<<endl;\r\n#define d2(x,y)          cout<<#x<<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<endl;\r\n#define d3(x,y,z)        cout<<#x<<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<endl;\r\n#define d4(x,y,z,w)      cout<<#x<<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<\" \"<<#w <<\"=\"<<w<<endl;\r\n#define da(arr,j,n)  for(int i=j;i<n;i++) {cout<<\"i=\"<<i<<\" arr[i]=\"<<arr[i]<<\"\\n\";} \r\n#define debug(x)         cout<<\"debug\"<<x<<\" \"<<endl;\r\nconst  ll MODA =                         1000000007;\r\n// const  int MODA =                     998244353 ;\r\nvector<ll> primefactors    ;            // used by generatePrimeFactors()                                                                                   // ARRAYS/VECTORS\r\nvector<ll> factors         ;            // used by generateFactors()\r\nll   fact[1000005]={}         ;            // used by generateFactorial() & ncr()\r\nbool isPowerTwo(ll x)                   { return (x && !(x & (x - 1))); }                                                                                    // FUNCTIONS\r\nll   modmul(ll a,ll b)                  { return((a%MODA)*(b%MODA))%MODA;     }\r\nll   modadd(ll a,ll b)                  { return((a%MODA)+(b%MODA)+MODA)%MODA;}\r\nll   modsub(ll a,ll b)                  { return((a%MODA)-(b%MODA)+MODA)%MODA;}\r\nbool isSubstring(string s1, string s2)  { if (s1.find(s2) != string::npos) return true; else return false; }\r\nvoid generateFactorial(ll n)            { fact[0] = 1; for(ll i = 1; i <= n; i++)   fact[i] = (i* 1ll * fact[i - 1]) ; }\r\nvoid generateFactorialMOD(ll n)         { fact[0] = 1; for(ll i = 1; i <= n; i++)   fact[i] = (i* 1ll * fact[i - 1]) % MODA; }\r\nbool isPrime(ll n)                      { if(n<2) return false; for(ll i=2;i*i<=n;i++) if(n%i==0) return false; return true; } //O(sqrt(n))\r\nll   power(ll a, ll b)                  {   ll res=1; while(b) {    if(b&1) res=(res*a); a=(a*a);   b>>=1;  }   return res; }\r\nll   powermod(ll a, ll b)               {   ll res=1; while(b) {    if(b&1) res=(res*a)%MODA; a=(a*a)%MODA;     b>>=1;  }   return res; }\r\nll   modi (ll a)                        { ll m=MODA,s=1,p=0;  while(a>1)  {  ll q=a/m,t=m;  m=a%m; a=t; t=p; p=s-q*p; s=t;  } return s>=0 ? s :s+MODA; }\r\nvoid generatePrimeFactors(ll n)         { primefactors.clear(); for(ll i=2;i*i<=n;i++) { if(n%i==0) { primefactors.push_back(i); while(n%i==0)  n=n/i; } } if(n!=1)   primefactors.push_back(n); }\r\nll   ncr(ll n, ll r)                    { if(r==0)return 1;  fact[0]=1; for(int i=1 ; i<=n; i++) fact[i] = fact[i-1]*i%MODA;   return (fact[n]* modi(fact[r]) % MODA *  modi(fact[n-r]) % MODA) % MODA; }\r\nvoid generateFactors(ll n)              { factors.clear(); for(ll i=2;i*i<=n;i++){ if(n%i==0) { factors.push_back(i); if(n/i!=i)factors.push_back(n/i); }} factors.push_back(1); factors.push_back(n); sort(factors.begin(),factors.end()); }\r\nld   Logn(ld n, ld r)                   { return log(n) / log(r); }  \r\n\r\n///////////////////////////////////\r\nconst int Nmax = 1000005;\r\nint gcnt = 1; int goo = 0; //Kickstart    \r\n\r\nvector<vector<pair<ll,ll>>> graph(Nmax);\r\nvector<vector<ll>> treee(Nmax);\r\nvector<ll> parent(Nmax);\r\nvector<ll> dist(Nmax, inf);\r\n////////////////////////////////////\r\n\r\n\r\n//bas ek choti si galti\r\nvoid solve(){\r\n  ll n,m,k;\r\n  cin >> n >> m >> k;\r\n  map<pair<ll,ll>,ll> mp;\r\n  for(ll i = 0; i< m; i++){\r\n    ll x, y, w;\r\n    cin >> x >> y >>w;\r\n\r\n    graph[x].push_back({y,w});\r\n    graph[y].push_back({x, w});\r\n    if(x > y){\r\n        swap(x, y);\r\n\r\n    }\r\n\r\n    mp[{x,y}] = i + 1;\r\n  }\r\n\r\n  set<ll> que;\r\n  que.insert(1);\r\n  dist[1] = 0;\r\n  while(sz(que) != 0){\r\n    ll cv = *que.begin();\r\n   // d1(cv);\r\n    for(auto child : graph[cv]){\r\n\r\n        ll node = child.first;\r\n       // d1(node);\r\n        if(node == parent[cv]){\r\n            continue;\r\n        }\r\n    //    d2(cv,node);\r\n        ll tdist = child.second;\r\n        if(dist[cv] + tdist < dist[node]){\r\n           // d2(cv, node);\r\n            dist[node] = dist[cv] + tdist;\r\n            parent[node] = cv;\r\n            que.insert(node);\r\n        }\r\n    }\r\n    que.erase(cv);\r\n  }  \r\n\r\n /* for(ll i = 1; i<=n; i++){\r\n    cout << i << \" \" << parent[i] << endl;\r\n  }*/\r\n  for(ll i = 2; i<=n; i++){\r\n    treee[i].push_back(parent[i]);\r\n    treee[parent[i]].push_back(i);\r\n  }\r\n\r\n  ll cnt = 0;\r\n\r\n  queue<ll> q;\r\n  q.push(1);\r\n  vector<ll> ans;\r\n  while(cnt<k){\r\n    ll cn = q.front();\r\n    ll pn = parent[cn];\r\n    q.pop();\r\n    ll x = cn, y = pn;\r\n    if(x > y){\r\n        swap(x, y);\r\n    } \r\n    if(mp.find({x,y}) != mp.end()){\r\n        ans.push_back(mp[{x,y}]);\r\n    cnt++;\r\n    }\r\n\r\n    \r\n    for(ll child : treee[cn]){\r\n        if(child != pn){\r\n            q.push(child);\r\n        }\r\n    }\r\n\r\n  }\r\ncout << k << endl;\r\n  for(ll i = 0; i< sz(ans); i++){\r\n    cout << ans[i] << \" \";\r\n  }\r\n  cout << endl;\r\n  \r\n\r\n\r\n\r\n      \r\n      \r\n\r\n\r\n     \r\n        \r\n     if(goo){\r\n        int ans;\r\n        cout << \"Case #\" << gcnt << \": \" << ans << endl;\r\n        gcnt++;\r\n     }\r\n\r\n    \r\n    }\r\n\r\nsigned main(){\r\n    #ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n    #endif\r\n        ios_base::sync_with_stdio(false); cin.tie(0);\r\n          int t= 1;\r\n       //cin >> t;\r\n        while(t--){\r\n            solve();\r\n        }\r\n        printclock;\r\n }\r\n\r\n/////////////////////////////\r\n//Don't assume graph to be connected if it is not explicitly mentioned. \r\n//check for double, triple.. counting in answer \r\n//try to bring as much symmetry as possible\r\n//just check for integer overflow\r\n//add MOD value when you substract two numbers\r\n//clear globally declared vectors after each test case \r\n// don't return or break while taking input of particular test case \r\n// using brackets when using (XOR, AND, OR) when calculating boolean value \r\n/////////////////////////////"
}