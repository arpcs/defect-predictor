{
    "id": 211697235,
    "contestId": 1076,
    "creationTimeSeconds": 1688201921,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1076,
        "index": "D",
        "name": "Edge Deletion",
        "type": "PROGRAMMING",
        "rating": 1800,
        "tags": [
            "graphs",
            "greedy",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1076,
        "members": [
            {
                "handle": "jain47040"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1542033300
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include \"bits/stdc++.h\"\r\n#define ll long long\r\n#define ll1 unsigned long long int \r\n#define vec vector<ll>\r\n#define f_a(arr,it) for(auto it:arr)\r\n#define vec_pair vector<pair<ll,ll>>\r\n#define us  unordered_set<ll>\r\n#define us_pair unordered_set<pair<ll,ll>>\r\n#define mapi map<ll,ll>\r\n#define fr(i,a,b) for(ll i = a; i < b; i++)\r\n#define input(v,a,b) for(ll i = a; i < b; i++){ cin>>v[i] ;}\r\n#define print(v,a,b) for(ll i =0;i<n;i++){ cout<<(v[i])<<\" \";}\r\n#define printp(v,a,b) for(ll i =0;i<n;i++){ cout<<(v[i].first)<<\" \"<<(v[i].second)<<endl;}\r\n#define printm(m) for(auto it : m){cout<<(it.first)<<\" \"<<(it.second)<<endl;} \r\n#define modi 1000000007\r\n#define mod 998244353\r\n#define nline cout<<'\\n';\r\n#define prDouble(x) cout << fixed << setprecision(10) << x;\r\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\r\nusing namespace std;\r\n\r\n\r\n// #include \"ext/pb_ds/assoc_container.hpp\"\r\n// #include \"ext/pb_ds/tree_policy.hpp\"\r\n// using namespace __gnu_pbds;\r\n// template<class T>\r\n// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n// ordered_set<pair<ll,ll>> front;\r\n// ordered_set<ll> pp;\r\n// order_of_key\r\n// find_by_order\r\n\r\n// pp.insert(3);\r\n// pp.insert(2);\r\n// pp.insert(1);\r\n// char input[1000];\r\n// cin.getline(input,1000,'$');\r\n\r\nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\r\nll expo(ll a, ll b, ll mod1) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod1; a = (a * a) % mod1; b = b >> 1;} return res;}\r\nvoid extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3\r\nll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b\r\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\r\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\r\n\r\n\r\n\r\n// #define MAXN 1007\r\n// // #define MAXN 10000007\r\n// // arre isko last m change kardio\r\n// // 1e7 se\r\n\r\n// // stores smallest prime factor for every number\r\n// int spf[MAXN];\r\n// // Calculating SPF (Smallest Prime Factor) for every\r\n// // number till MAXN.\r\n// // Time Complexity : O(nloglogn)\r\n// // sieve struct ka dekhlio eek baar\r\n\r\n// void sieve()\r\n// {\r\n//     spf[1] = 1;\r\n//     for (int i=2; i<MAXN; i++)\r\n \r\n//         // marking smallest prime factor for every\r\n//         // number to be itself.\r\n//         spf[i] = i;\r\n \r\n//     // separately marking spf for every even\r\n//     // number as 2\r\n//     for (int i=4; i<MAXN; i+=2)\r\n//         spf[i] = 2;\r\n \r\n//     for (int i=3; i*i<MAXN; i++)\r\n//     {\r\n//         // checking if i is prime\r\n//         if (spf[i] == i)\r\n//         {\r\n//             // marking SPF for all numbers divisible by i\r\n//             for (int j=i*i; j<MAXN; j+=i)\r\n \r\n//                 // marking spf[j] if it is not\r\n//                 // previously marked\r\n//                 if (spf[j]==j)\r\n//                     spf[j] = i;\r\n//         }\r\n//     }\r\n// }\r\n\r\n// void google(ll t) {cout << \"Case #\" << t << \": \";}\r\n\r\n// // A O(log n) function returning primefactorization\r\n// // by dividing by smallest prime factor at every step\r\n// int getFactorization(int x,map<int,int> &m)\r\n// {\r\n//     while (x != 1)\r\n//     {\r\n//         m[spf[x]]++;\r\n//         x = x / spf[x];\r\n//     }\r\n\r\n//     int ans=1;\r\n//     for(auto i:m){\r\n//         if(i.second%2)ans*=i.first;\r\n//     }\r\n//     return ans;\r\n// }\r\n\r\n// auto cmp = [](pair<ll,ll> const &x,pair<ll,ll> const &y) {\r\n//     return x > y;\r\n// };\r\n// set<pair<ll,ll>,decltype(cmp)> a(cmp);\r\n// Star and bars problem cf\r\n\r\n// #define ll long long\r\n// #define vec vector<ll>\r\n// #define f_a(arr,it) for(auto it:arr)\r\n// #define fr(i,a,b) for(ll i = a; i < b; i++)\r\n\r\n\r\nstd::vector<ll> fact(1e1+1);\r\n\r\nvoid preCalc(ll m) {\r\n    fact[0]=1;\r\n    for(int i=1;i<=(1e1);i++){   \r\n        fact[i] = mod_mul(fact[i-1ll],i,m);\r\n    }\r\n}\r\n\r\n\r\nll binExp(ll a, ll b, ll m) {\r\n    ll res=1, mul=a;\r\n    while(b) {\r\n        if(b&1) {   \r\n            res=(res*mul)%m;\r\n        }\r\n        mul=(mul*mul)%m;\r\n        b>>=1;\r\n    }\r\n    return res;\r\n}\r\n\r\nll modInv(ll n, ll m) {  \r\n   return binExp(n, m-2, m);\r\n}\r\n\r\nll nCr(ll n, ll r, ll m) {\r\n    ll res=(fact[n]*modInv(fact[r], m))%m;\r\n    res=(res*modInv(fact[n-r], m))%m;   \r\n    return res%m;\r\n}\r\n\r\nll nPr(ll n, ll r,ll m){\r\n    ll res=(fact[n]*modInv(fact[n-r], m))%m;\r\n    return res;\r\n}\r\n\r\nbool is_prime(ll n){\r\n    if (n <= 1ll)\r\n        return false;\r\n    if (n <= 3ll)\r\n        return true;\r\n    if (n % 2 == 0 || n % 3 == 0)\r\n        return false;\r\n    for (ll i = 5; i * i <= n; i = i + 6ll)\r\n        if (n % i == 0 || n % (i + 2ll) == 0)\r\n            return false;\r\n    return true;\r\n}\r\n\r\nll floor_find_ll(vec& arr,ll target){\r\n        int start = 0;\r\n        int end = arr.size() - 1;\r\n        if(arr[0]>target){\r\n            return -1;\r\n        }\r\n        while(start <= end) {\r\n            int mid = start + (end - start) / 2;\r\n            if(target < arr[mid]) {\r\n                end = mid - 1;\r\n            } \r\n            else if (target > arr[mid]) {\r\n                start = mid + 1;\r\n            } \r\n            else {\r\n                return mid;\r\n            }\r\n        }\r\n        return end;\r\n}\r\n\r\n\r\nll ceil_find_ll(vec& arr,ll target){\r\n        if (target > arr[arr.size() - 1]) {\r\n            return -1;\r\n        }\r\n        int start = 0;\r\n        int end = arr.size() - 1;\r\n        while(start <= end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (target < arr[mid]) {\r\n                end = mid - 1;\r\n            } else if (target > arr[mid]) {\r\n                start = mid + 1;\r\n            } else {\r\n                return mid;\r\n            }\r\n        }\r\n        return start;\r\n}\r\n\r\nll lcm(ll a,ll b){\r\n    return (a*b)/gcd(a,b);\r\n}\r\n\r\n\r\nbool isperfectsqaure(ll x){\r\n    if(x==0){\r\n        return true;\r\n    }\r\n    ll low = 1, high = x, ans = 1;\r\n    while(low<=high){\r\n        double mid = (low+high)/2;\r\n        if(mid*mid<=x){\r\n            ans = mid;\r\n            low = mid+1;\r\n        }\r\n        else\r\n            high = mid-1;\r\n    }\r\n    return ((ans*ans)==x)?1:0;\r\n}\r\n\r\nll get_pp(ll n,ll k){\r\n    ll i = 0;\r\n    ll base = 1;\r\n    while(base<=n){\r\n        base = base * k;\r\n        i=i+1;\r\n    }\r\n    return (i-1);\r\n}\r\n\r\nll count_digits(ll n,ll k){\r\n    ll count = 0;\r\n    while(n%k==0){\r\n        n = n / k;\r\n        count++;\r\n    }\r\n    return count;\r\n}\r\nbool perf_2(ll n){\r\n\r\n    ll count = 0;\r\n    fr(i,0,32){\r\n        if(n & (1<<i)){\r\n            count++;\r\n        }\r\n    }\r\n    return (count==1);\r\n}\r\n\r\nbool is_asc(vec& v){\r\n    ll n = v.size();\r\n    fr(i,0,n-1){\r\n        if(v[i]>v[i+1]){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nbool is_desc(vec& v){\r\n\r\n    ll n = v.size();\r\n    fr(i,0,n-1){\r\n        if(v[i]<v[i+1]){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n\r\n}\r\nclass Segtree{\r\n\r\n    public : \r\n\r\n      vector<ll> v1;\r\n      vector<ll> tree;\r\n\r\n      Segtree(ll n){  // initialization of Seg tree\r\n        v1.resize(n+1,0); // iinitialization depends on how\r\n        ll size = 2*n - 1;\r\n        tree.resize(size+1,0); // initializtion changes in cases\r\n      }\r\n\r\n      ll operation(ll val1,ll val2){\r\n        ll ans = val1+val2;\r\n        return ans;\r\n      }\r\n\r\n      ll Filling(ll node,ll l,ll r){\r\n        if(l==r){\r\n            tree[node] = v1[l];\r\n            return tree[node];\r\n            // return 0;\r\n        }\r\n\r\n        ll mid = l + (r-l)/2 ;\r\n        ll val1 = Filling(2*node,l,mid);\r\n        ll val2 = Filling(2*node+1ll,mid+1,r);\r\n        tree[node] = operation(val2,val1);\r\n        return tree[node];\r\n        // return 0;\r\n      }\r\n\r\n      ll update(ll node,ll l,ll r,ll val,ll ind){\r\n        if(l==r && l==ind){\r\n            v1[l] = val;\r\n            tree[node] = v1[ind];\r\n            return tree[node];\r\n        }\r\n        ll mid = l + (r-l)/2 ;\r\n        ll val1 = tree[2*node];\r\n        ll val2 = tree[2*node+1];\r\n        if( ind <= mid ){\r\n            val1 = update(2*node,l,mid,val,ind);\r\n        }\r\n        else{\r\n            val2 = update(2*node+1ll,mid+1ll,r,val,ind);\r\n        }\r\n        tree[node] = operation(val2,val1);\r\n        return tree[node];\r\n      }\r\n\r\n      ll ansforrange(ll node,ll tl,ll tr,ll l,ll r){\r\n\r\n        if(l==tl && tr==r){\r\n            return tree[node];\r\n        }\r\n\r\n        ll mid = r/2;\r\n\r\n        if( mid > tr  ){\r\n            return ansforrange(2*node,tl,tr,l,mid);\r\n        }\r\n        else if( mid < tl ){\r\n            return ansforrange(2*node+1ll,tl,tr,mid+1ll,r);\r\n        }\r\n        else{\r\n            ll val1 = ansforrange(2*node,tl,tr,l,mid);\r\n            ll val2 = ansforrange(2*node+1ll,tl,tr,mid+1ll,r);\r\n            return operation(val2,val1);\r\n        }\r\n\r\n      }\r\n\r\n};\r\n\r\nll update(ll n){\r\n    ll bit = 0;\r\n    ll count = 0;\r\n    fr(i,0,30){\r\n       if( n & (1<<i) ){\r\n         count++;\r\n         bit = i;\r\n       }\r\n    }\r\n    if(count!=1){\r\n       bit++;\r\n       n = (1<<bit);\r\n    }\r\n    return n;\r\n}\r\n\r\n// ll bit = 0;\r\n// ll count = 0;\r\n// fr(i,0,30){\r\n//     if( n & (1<<i) ){\r\n//         count++;\r\n//         bit = i;\r\n//     }\r\n// }\r\n// if(count!=1){\r\n//     bit++;\r\n//     n = (1<<bit);\r\n// }\r\n\r\n// Segtree* S1 = new Segtree(n);\r\n// fr(i,1,n+1){\r\n//     S1->v1[i] = i;\r\n// }\r\n// (*S1).Filling(1,1,8);\r\n// cout<<(*S1).tree[1];\r\n// (*S1).update(1,1,8,0,8);\r\n// cout<<(*S1).tree[1];\r\n\r\n\r\n#define MAXN 101\r\n\r\nint spf[MAXN];\r\n\r\nvoid sieve()\r\n{\r\n    spf[1] = 1;\r\n    for (int i=2; i<MAXN; i++)\r\n        spf[i] = i;\r\n \r\n    for (int i=4; i<MAXN; i+=2)\r\n        spf[i] = 2;\r\n \r\n    for (int i=3; i*i<MAXN; i++)\r\n    {\r\n        if (spf[i] == i)\r\n        {\r\n            for (int j=i*i; j<MAXN; j+=i){\r\n                if (spf[j]==j){\r\n                    spf[j] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst int N = 101;\r\n// fr(i,0,78498){ : maximum prime ispar \r\n// N = 1000001\r\nint primes[N], cnt;\r\nbool st[N]; \r\n\r\nvoid get_primes(int n)\r\n{\r\n    for (int i = 2; i <= n; i ++ )\r\n    {\r\n        if (!st[i]) primes[cnt ++ ] = i;\r\n        for (int j = 0; primes[j] <= n / i; j ++ )\r\n        {\r\n            st[primes[j] * i] = true;\r\n            if (i % primes[j] == 0) break;\r\n        }\r\n    }\r\n}\r\n\r\nint cnt_f(int x)\r\n{\r\n    int i = 0, res = 1;\r\n    if (x < 2) return 0;\r\n    while (x > 1)\r\n    {\r\n        if (x <= primes[i] || i >= cnt) break;\r\n        if (x % primes[i] == 0) x /= primes[i], res ++;\r\n        else i ++;\r\n    }\r\n    return res;\r\n    \r\n}\r\n\r\npair<ll,ll> com(ll l1,ll r1,ll l2,ll r2){\r\n    pair<ll,ll> p1;\r\n    p1.first = max(l1,l2);\r\n    p1.second = min(r1,r2);\r\n    return p1;\r\n}\r\n\r\nll get(ll l,ll r,ll v){\r\n\r\n    if(l > r){\r\n        return 0;\r\n    }\r\n\r\n    l--;\r\n    ll a1 = l/v;\r\n    ll b1 = r/v;\r\n\r\n    b1 = b1 - a1;\r\n\r\n    return b1;\r\n}\r\n\r\n\r\n\r\n// ll min = *(sizes.begin());\r\n// ll max = *(--sizes.end());\r\n\r\n// Mission EXPERT Launched...\r\n// Fasten ur seats belt and be ready to launch ...........\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS  \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS\r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS \r\n// FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS FOCUS..........................\r\n// I m back again ..........................................................................\r\n\r\n// function<int(int&,int&)> f = [&](int& a,int b){\r\n//     a = a + 1;\r\n//     return a;\r\n// };\r\n\r\nvoid solve(){\r\n\r\n    ll n,m,k;\r\n    cin>>n>>m>>k;\r\n\r\n    unordered_map<ll,ll> m1;\r\n    vector<vec_pair> v1(n+1);\r\n    fr(i,1,m+1){\r\n        ll x,y,w;\r\n        cin>>x>>y>>w;\r\n        m1[i] = w;\r\n        v1[x].push_back({y,i});\r\n        v1[y].push_back({x,i});\r\n    }\r\n\r\n    vec_pair ans(n+1,{-1,-1});\r\n    ans[1].first = 0;\r\n    ans[1].second = 0;\r\n\r\n    vector<ll> parent(m+1,-1);\r\n    parent[0] = -1;\r\n\r\n    set<pair<ll,ll>> sp;\r\n    sp.insert({0,1});\r\n\r\n    vector<pair<ll,ll>> occur(m+1);\r\n\r\n    while(sp.size() > 0){\r\n        \r\n        ll ind = (*sp.begin()).second;\r\n        ll val = (*sp.begin()).first;\r\n\r\n        ll nodecurr = ans[ind].second;\r\n        sp.erase(*sp.begin());\r\n\r\n        f_a(v1[ind],it){\r\n\r\n            ll curr = m1[it.second]+val;\r\n            ll node = it.first;\r\n            if(ans[node].first==-1 || ans[node].first >= curr){\r\n                ans[node].first  = curr;\r\n                ans[node].second = it.second;\r\n                parent[it.second] = nodecurr; \r\n                sp.insert({curr,node});\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    fr(i,2,n+1){\r\n        occur[ans[i].second].first++;\r\n    }\r\n\r\n    unordered_map<ll,ll> m2;\r\n    fr(i,1,n+1){\r\n        ll ind = i;\r\n        ll p = parent[i];\r\n        m2[p]++;\r\n    }\r\n\r\n    set<pair<ll,ll>> s2;\r\n    f_a(m2,it){\r\n        s2.insert({it.second,it.first});\r\n    }\r\n\r\n    while(s2.size() > 0){\r\n        ll ind = (*s2.begin()).second;\r\n        if(parent[ind]!=-1){\r\n            occur[parent[ind]].first += occur[ind].first;\r\n        }\r\n        s2.erase(*s2.begin());\r\n    }\r\n\r\n    \r\n    occur[0].first = 0;\r\n\r\n    fr(i,1,m+1){\r\n        occur[i].second = i;\r\n    }\r\n\r\n    sort(occur.begin(),occur.end());\r\n\r\n    cout<<min(m,k);\r\n    nline\r\n    for(int i=m;i>=max(1ll,m-k+1);i--){\r\n        cout<<occur[i].second<<\" \";\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\nint main(){\r\n    \r\n\r\n    ios_base::sync_with_stdio(false);  \r\n    cin.tie(NULL); \r\n    cout.tie(0);\r\n    fast_io;\r\n    #ifndef ONLINE_JUDGE\r\n    freopen(\"inputf.in\",\"r\",stdin);\r\n    freopen(\"outputf.in\",\"w\",stdout);\r\n    #endif\r\n\r\n\r\n    ll t;\r\n    t = 1;\r\n    // cin>>t;\r\n\r\n    // sieve();\r\n    // get_primes();  \r\n\r\n    while(t--){\r\n        \r\n        \r\n        solve();\r\n        nline\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n// Absolute diff codechef\r\n// Zero Array cc\r\n// Special Operation\r\n// Rank Queries\r\n// Rescue Nibel!\r\n// Letter Picking\r\n\r\n// nums[i] % nums[i+1] == 0 or\r\n// nums[i+1] % nums[i] == 0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}