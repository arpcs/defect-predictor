{
    "id": 73293536,
    "contestId": 917,
    "creationTimeSeconds": 1584229673,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "vjudge5"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 2199,
    "memoryConsumedBytes": 313344000,
    "source": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#define il inline\n#define ri register\n#define ll long long\n#define Size 400050\n#define Size1 524288\nusing namespace std;\ntemplate<class free>\nil void Max(free&,free);\nstruct graph{\n\tstruct pointy{\n\t\tint next,to,w;\n\t}ar[Size1];\n\tint head[Size],art;\n\til void link(int u,int v,int w){\n\t\tar[++art]={head[u],v,w},head[u]=art;\n\t\tar[++art]={head[v],u,w},head[v]=art;\n\t}\n\til void link1(int u,int v,int w){\n\t\tar[++art]={head[u],v,w},head[u]=art;\n\t}\n\til void clear(int n){\n\t\tmemset(head,art=0,n+1<<2);\n\t}\n}G,G1[2];\ntemplate<class free>\nstruct Vector{\n\tfree*a;int n,n1;\n\til Vector(){n=n1=0,a=0;}\n\til void push_back(const free&x){\n\t\tif(n<n1)a[n++]=x;\n\t\telse{\n\t\t\tfree*a1(new free[n1=n1?n1<<1:1]);\n\t\t\tmemcpy(a1,a,n*sizeof(free));\n\t\t\tif(a)delete[]a;a1[n++]=x,a=a1;\n\t\t}\n\t}il free&operator[](const int&x)const{\n\t\treturn a[x];\n\t}il void clear(){n=0;}\n\til void pop_back(){--n;}\n\til void clear1(){if(a)delete[]a;n=n1=0,a=0;}\n};\nstruct query{\n\tint x,y,z,id;\n}q1[Size];\nstruct pi{int x,y;};\nstruct AC{\n\tgraph G;\n\tint tran[Size][26],fail[Size],\n\t\ttot=1,a[Size],a1[Size],tim,\n\t\tsz[Size];\n\til void insert(char*s,int id){\n\t\tint p(1);\n\t\tfor(int i(1);s[i];++i){\n\t\t\tif(!tran[p][s[i]-97])\n\t\t\t\ttran[p][s[i]-97]=++tot;\n\t\t\tp=tran[p][s[i]-97];\n\t\t}a[id]=p;\n\t}\n\til void Iinsert(char*s,int id){\n\t\tint p(1),n(strlen(s+1));\n\t\tfor(int i(n);i;--i){\n\t\t\tif(!tran[p][s[i]-97])\n\t\t\t\ttran[p][s[i]-97]=++tot;\n\t\t\tp=tran[p][s[i]-97];\n\t\t}a[id]=p;\n\t}\n\til void bfs(){\n\t\tstatic int T[Size];int L(0),R(0);\n\t\tfor(int i(0);i<26;++i)\n\t\t\ttran[1][i]?fail[T[++R]=tran[1][i]]=1:tran[1][i]=1;\n\t\twhile(L++^R)\n\t\t\tfor(int i(0);i<26;++i)\n\t\t\t\ttran[T[L]][i]?fail[T[++R]=tran[T[L]][i]]=tran[fail[T[L]]][i]:\n\t\t\t\t\ttran[T[L]][i]=tran[fail[T[L]]][i];\n\t\tfor(int i(2);i<=tot;++i)G.link1(fail[i],i,0);dfs(1);\n\t}\n\til void dfs(int x){\n\t\ta1[x]=++tim,sz[x]=1;\n\t\tfor(int i(G.head[x]),i1;i;i=G.ar[i].next)\n\t\t\tdfs(i1=G.ar[i].to),sz[x]+=sz[i1];\n\t}\n}A[2];\nstruct GSAM{\n\tgraph G;\n\tstruct state{\n\t\tint tran[26],link,len;\n\t}s[Size];\n\tint tot=1,a[Size],tim,a1[Size],sz[Size];\n\til void dfs(int x){\n\t\ta[x]=++tim,sz[x]=1;\n\t\tfor(int i(G.head[x]),i1;i;i=G.ar[i].next)\n\t\t\tdfs(i1=G.ar[i].to),sz[x]+=sz[i1];\n\t}\n\til void extend(int&last,int c){\n\t\tint cur,p(last);\n\t\tif(s[p].tran[c])\n\t\t\tlast=s[s[p].tran[c]].len^\n\t\t\t\ts[p].len+1?tot+1:s[p].tran[c],\n\t\t\t\tcur=tot+2;\n\t\telse s[last=cur=++tot].len=s[p].len+1;\n\t\twhile(p&&!s[p].tran[c])\n\t\t\ts[p].tran[c]=cur,p=s[p].link;\n\t\tif(p){\n\t\t\tint q(s[p].tran[c]);\n\t\t\tif(s[q].len==s[p].len+1)s[cur].link=q;\n\t\t\telse{\n\t\t\t\tint clone(++tot);\n\t\t\t\ts[clone]=s[q],s[clone].len=s[p].len+1;\n\t\t\t\ts[q].link=s[cur].link=clone;\n\t\t\t\twhile(s[p].tran[c]==q)\n\t\t\t\t\ts[p].tran[c]=clone,p=s[p].link;\n\t\t\t}\n\t\t}else s[cur].link=1;\n\t}il void init(){\n\t\tfor(int i(2);i<=tot;++i)\n\t\t\tG.link1(s[i].link,i,0);\n\t\tdfs(1);\n\t}\n}S[2];\nstruct segmentree{\n\tVector<int>t[Size<<1];int n1;\n\til void clear(){\n\t\tfor(int i(1);i<n1<<1;++i)t[i].clear1();\n\t}il void build(int n){\n\t\tfor(n1=1;n1<=n;n1<<=1);\n\t}il void push(int l,int r,int dep){\n\t\tfor(l+=n1-1,r+=n1+1;l^r^1;l>>=1,r>>=1){\n\t\t\tif(~l&1)t[l^1].push_back(dep);\n\t\t\tif(r&1)t[r^1].push_back(dep);\n\t\t}\n\t}il void pop(int l,int r){\n\t\tfor(l+=n1-1,r+=n1+1;l^r^1;l>>=1,r>>=1){\n\t\t\tif(~l&1)t[l^1].pop_back();\n\t\t\tif(r&1)t[r^1].pop_back();\n\t\t}\n\t}il int ask(int p){\n\t\tint ans(0);\n\t\tfor(p+=n1;p;p>>=1)\n\t\t\tif(t[p].n)Max(ans,t[p][t[p].n-1]);\n\t\treturn ans;\n\t}\n}T[2];\nll ans[Size];\nbool is[Size];\nVector<pi>q2[Size];\nchar*s[Size],s1[Size];\nint len[Size],gh,sz[Size],be[Size],\n\ta[Size],n,m,q,ans1[Size][2],\n\tNext[Size],a1[Size],tim;\nil int ask(int);\nil void read(int&),get(char&),\n\tdfs(int,int,int,int),change(int,int),\n\tdfs1(int,int,int),dfs2(int,int),\n\tdfs3(int,int,int,int,int,bool),kmp(char*),\n\tdfs4(int),dfs5(int,int);\nil bool comp(const query&,const query&);\nil bool comp1(const query&,const query&);\nint main(){\n\t//freopen(\"in\",\"r\",stdin);\n\t//freopen(\"out\",\"w\",stdout);\n\tread(n),read(m),read(q);\n\tfor(int i(1),u,v;i<n;++i){\n\t\tread(u),read(v);char c;\n\t\tget(c),G.link(u,v,c-97);\n\t}for(int i(1);i<=m;++i){\n\t\tscanf(\"%s\",s1+1),len[i]=strlen(s1+1);\n\t\ts[i]=new char[len[i]+50],strcpy(s[i]+1,s1+1);\n\t}for(int i(1);i<=q;++i)\n\t\t read(q1[i].x),read(q1[i].y),\n\t\t\t read(q1[i].z),q1[i].id=i;\n\tfor(int i(1),j,p;i<=m;++i){\n\t\tA[0].insert(s[i],i),A[1].Iinsert(s[i],i);\n\t\tfor(j=p=1;j<=len[i];++j)S[0].extend(p,s[i][j]-97);S[0].a1[i]=p;\n\t\tfor(j=len[i],p=1;j;--j)S[1].extend(p,s[i][j]-97);S[1].a1[i]=p;\n\t}A[0].bfs(),A[1].bfs();\n\tT[0].build(S[0].tot),T[1].build(S[1].tot);\n\tS[0].init(),S[1].init();\n\tdfs(1,n,1,q),sort(q1+1,q1+q+1,comp1);\n\tfor(int i(1),j(1),k,l;i<=m;++i,j=k){\n\t\tfor(k=j;q1[k].z==i;++k);\n\t\tif(j==k)continue;kmp(s[i]),tim=0;\n\t\tfor(l=1;l<=len[i];++l)G1[0].link1(Next[l],l,0);\n\t\treverse(s[i]+1,s[i]+len[i]+1),kmp(s[i]);\n\t\tfor(l=1;l<=len[i];++l)G1[1].link1(Next[l],l,0);\n\t\tfor(l=j;l<k;++l){\n\t\t\tq2[ans1[q1[l].id][0]].\n\t\t\t\tpush_back({ans1[q1[l].id][1],q1[l].id});\n\t\t\tans[q1[l].id]-=(ans1[q1[l].id][0]==len[i])+\n\t\t\t\t(ans1[q1[l].id][1]==len[i]);\n\t\t}dfs4(0),dfs5(0,len[i]);\n\t\tG1[0].clear(len[i]),G1[1].clear(len[i]);\n\t}for(int i(1);i<=q;++i)printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\nil void dfs4(int x){a1[x]=++tim,sz[x]=1;\n\tfor(int i(G1[0].head[x]),i1;i;i=G1[0].ar[i].next)\n\t\tdfs4(i1=G1[0].ar[i].to),sz[x]+=sz[i1];\n}\nil void dfs5(int x,int n){\n\tchange(a1[n-x],1),change(a1[n-x]+sz[n-x],-1);\n\tfor(int i(0);i<q2[x].n;++i)\n\t\tans[q2[x][i].y]+=ask(a1[q2[x][i].x]);\n\tq2[x].clear();\n\tfor(int i(G1[1].head[x]),i1;i;i=G1[1].ar[i].next)\n\t\tdfs5(i1=G1[1].ar[i].to,n);\n\tchange(a1[n-x],-1),change(a1[n-x]+sz[n-x],1);\n}\nil void kmp(char*s){\n\tfor(int i(2),j(0);s[i];++i){\n\t\twhile(j&&s[i]^s[j+1])j=Next[j];\n\t\tif(s[i]==s[j+1])++j;Next[i]=j;\n\t}\n}\nil bool comp1(const query&A,const query&B){\n\treturn A.z<B.z;\n}\nil void dfs3(int x,int fa,int p,int q,int dep,bool type){\n\tchange(A[type].a1[p],1);\n\tif(q)T[type].push(S[type].a[q],S[type].a[q]+S[type].sz[q]-1,dep);\n\tfor(int i(0),i1;i<q2[x].n;++i){\n\t\ti1=A[type].a[q2[x][i].x];\n\t\tans[q2[x][i].y]+=ask(A[type].a1[i1]+A[type].sz[i1]-1)-ask(A[type].a1[i1]-1);\n\t\ti1=S[type].a1[q2[x][i].x];\n\t\tans1[q2[x][i].y][type]=T[type].ask(S[type].a[i1]);\n\t}q2[x].clear();\n\tfor(int i(G.head[x]),i1;i;i=G.ar[i].next){\n\t\tif(is[i1=G.ar[i].to]||i1==fa)continue;\n\t\tdfs3(i1,x,A[type].tran[p][G.ar[i].w],\n\t\t\t S[type].s[q].tran[G.ar[i].w],dep+1,type);\n\t}change(A[type].a1[p],-1);\n\tT[type].pop(S[type].a[q],S[type].a[q]+S[type].sz[q]-1);\n}\nil int ask(int p){\n\tint ans(0);\n\twhile(p)ans+=a[p],p^=p&-p;\n\treturn ans;\n}\nil void change(int p,int v){\n\twhile(p<Size)a[p]+=v,p+=p&-p;\n}\nil void dfs2(int x,int fa){\n\tfor(int i(G.head[x]),i1;i;i=G.ar[i].next){\n\t\tif(is[i1=G.ar[i].to]||i1==fa)continue;\n\t\tbe[i1]=be[x],dfs2(i1,x);\n\t}\n}\nil bool comp(const query&a,const query&b){\n\tif(be[b.x]^be[b.y])return 0;\n\tif(be[a.x]^be[a.y])return 1;\n\treturn be[a.x]<be[b.x];\n}\ntemplate<class free>\nil void Max(free&x,free y){x=x>y?x:y;}\nil void dfs1(int x,int fa,int n){\n\tsz[x]=1;int mp(0);\n\tfor(int i(G.head[x]),i1;i;i=G.ar[i].next)\n\t\tif(!is[i1=G.ar[i].to]&&i1^fa)\n\t\t\tdfs1(i1,x,n),sz[x]+=sz[i1],Max(mp,sz[i1]);\n\tMax(mp,n-sz[x]);if(mp<<1<=n)gh=x;\n}\nil void dfs(int x,int n,int l,int r){\n\tif(l>r)return;\n\tdfs1(x,0,n);int gh(::gh),tot(0);\n\tis[gh]=1,be[gh]=0;\n\tfor(int i(G.head[gh]),i1;i;i=G.ar[i].next){\n\t\tif(is[i1=G.ar[i].to])continue;\n\t\tbe[i1]=++tot,dfs2(i1,0);\n\t}sort(q1+l,q1+r+1,comp);int l1(l);\n\twhile(l1<=r&&be[q1[l1].x]^be[q1[l1].y])++l1;\n\tfor(int i(l);i<l1;++i)\n\t\tq2[q1[i].x].push_back({q1[i].z,q1[i].id});\n\tdfs3(gh,0,1,1,0,1);\n\tT[1].clear();\n\tfor(int i(l);i<l1;++i)\n\t\tq2[q1[i].y].push_back({q1[i].z,q1[i].id});\n\tdfs3(gh,0,1,1,0,0),T[0].clear();\n\tint temp(sz[gh]);while(l1<=r&&!be[q1[l1].x])++l1;\n\tfor(int i(G.head[gh]),i1,j;i;i=G.ar[i].next){\n\t\tif(is[i1=G.ar[i].to])continue;\n\t\tfor(j=l1;j<=r&&be[i1]==be[q1[j].x];++j);\n\t\tdfs(i1,temp>sz[i1]?sz[i1]:n-sz[gh],l1,j-1),l1=j;\n\t}\n}\nil void read(int&x){\n\tx^=x;ri char c;while(c=getchar(),c<'0'||c>'9');\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();\n}\nil void get(char&c){\n\twhile(c=getchar(),c==' '||c=='\\n'||c=='\\r');\n}\n\n\t \t\t \t \t \t \t\t\t\t\t\t  \t\t  \t  \t\t \t"
}