{
    "id": 171245548,
    "contestId": 917,
    "creationTimeSeconds": 1662560611,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "atcoderfan"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 77,
    "memoryConsumedBytes": 415334400,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define forg(i,x) for(int i=fir[x];i;i=nxt[i])\r\n#define fre(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\r\n#define uu unsigned\r\n#define scanf(x...) assert(~scanf(x))\r\ntypedef long long ll;\r\ntypedef uu long long ull;\r\ntypedef pair<int,int>pii;\r\ntypedef vector<int>VI;\r\nmt19937 rnd((ull)(new char));\r\nint rd(int l,int r){return uniform_int_distribution<>(l,r)(rnd);}\r\nvoid NC(ull k){cerr<<(k>>20)<<endl;}\r\n\r\nconst int mxn=4e5+3;\r\nint n,m,qn,N=1,P,T,L[mxn],L0[mxn];\r\nint to[mxn],nxt[mxn],fir[mxn],gn=1,ed[mxn];\r\nvoid gad(int x,int y,int c){to[++gn]=y,nxt[gn]=fir[x],fir[x]=gn,ed[gn]=c,to[++gn]=x,nxt[gn]=fir[y],fir[y]=gn,ed[gn]=c;}\r\nvector<pii>dd[mxn];char s[mxn],S1[mxn],S2[mxn];\r\nint d1[mxn],d2[mxn],dn,dx[mxn];\r\nvoid dfsd(int x){d1[x]=++dn;forg(i,x)dfsd(to[i]);d2[x]=dn;}\r\nstruct SM{\r\n    VI E[mxn];int m=1,P,fa[mxn],ts[mxn][26],le[mxn],id[mxn],ez[mxn][26];char*s[mxn];\r\n    int ext(int c){\r\n        int p=P,np,q,nq;if(ts[p][c]){\r\n            q=ts[p][c];if(le[q]==le[p]+1)return q;else{\r\n                nq=++m,fa[nq]=fa[q],fa[q]=nq,le[nq]=le[p]+1,memcpy(ts[nq],ts[q],sizeof(ts[q]));\r\n                for(;ts[p][c]==q;p=fa[p])ts[p][c]=nq;\r\n                return nq;\r\n            }\r\n        }\r\n        np=++m;for(;p&&!ts[p][c];p=fa[p])ts[p][c]=np;\r\n        if(!p)fa[np]=1;else{\r\n            q=ts[p][c];if(le[q]==le[p]+1)fa[np]=q;else{\r\n                nq=++m;fa[nq]=fa[q],fa[q]=fa[np]=nq,le[nq]=le[p]+1,memcpy(ts[nq],ts[q],sizeof(ts[q]));\r\n                for(;ts[p][c]==q;p=fa[p])ts[p][c]=nq;\r\n            }\r\n        }\r\n        return np;\r\n    }\r\n    void ins(int c){\r\n        P=ext(c);E[P].push_back(T);id[P]=T;\r\n    }\r\n    void EE(char*s0){\r\n        static int px[mxn];for(int i=1;i<=m;++i)px[i]=i;sort(px+1,px+m+1,[&](int x,int y){return le[x]<le[y];});\r\n        for(int T=m;T>1;--T){\r\n            int x=px[T],y=fa[x];if(!s[x])s[x]=s0+L0[id[x]-1]+L[id[x]]-le[x];\r\n            s[y]=s[x];ez[y][s[x][le[y]+1]]=x;\r\n        }\r\n    }\r\n    void ju(pii&k,int c){\r\n        if(k.first<0)return;int&x=k.first,&l=k.second;\r\n        if(l==le[x]){if(ez[x][c])k={ez[x][c],l+1};else x=-x;}else if(s[x][l+1]!=c)x=-x;else ++l;\r\n    }\r\n    void gd(){\r\n        auto gad=[&](int x,int y){to[++gn]=y,nxt[gn]=fir[x],fir[x]=gn;};\r\n        memset(fir,0,sizeof(fir));gn=0;for(int i=2;i<=m;++i)gad(fa[i],i);\r\n    }\r\n}b1,b2;\r\nstruct thr{int x,y,k,t;};\r\nvector<thr>ve0,cz[mxn],xw[mxn];\r\nint sz[mxn],vs[mxn],be[mxn],da[mxn],fa[mxn];\r\nstruct AC{\r\n    int ac[mxn][26],fail[mxn],m,po[mxn][2],qu[mxn],d1[mxn],d2[mxn],dn;\r\n    int to[mxn],nxt[mxn],fir[mxn],gn;void gad(int x,int y){to[++gn]=y,nxt[gn]=fir[x],fir[x]=gn;}\r\n    int a[mxn];void add(int x,int v){if(x)for(x=d1[x];x<=m;x+=x&-x)a[x]+=v;}\r\n    int ask(int x){x=x>0?po[x][1]:po[-x][0];return qry(d2[x])-qry(d1[x]-1);}\r\n    int qry(int x){int r=0;for(;x;x&=x-1)r+=a[x];return r;}\r\n    void ins(int k){\r\n        int n=strlen(s+1);int x=0;for(int i=1;i<=n;++i){int c=(s[i]-='a');if(!ac[x][c])ac[x][c]=++m;x=ac[x][c];}\r\n        po[k][0]=x;x=0;for(int i=n;i;--i){int c=s[i];if(!ac[x][c])ac[x][c]=++m;x=ac[x][c];}po[k][1]=x;\r\n    }\r\n    void dfsd(int x){d1[x]=++dn;forg(i,x)dfsd(to[i]);d2[x]=dn;}\r\n    void bud(){\r\n        int qh=1,qt=0;for(int c=0;c<26;++c)if(ac[0][c])qu[++qt]=ac[0][c];while(qh<=qt){\r\n            int x=qu[qh++];for(int c=0;c<26;++c)if(!ac[x][c])ac[x][c]=ac[fail[x]][c];else\r\n                fail[ac[x][c]]=ac[fail[x]][c],qu[++qt]=ac[x][c];\r\n        }\r\n        assert(qt==m);\r\n        for(int i=1;i<=m;++i)gad(fail[i],i);\r\n        assert(gn==m);\r\n        dfsd(0);for(int i=1;i<=m;++i)--d1[i],--d2[i];\r\n    }\r\n}ac;\r\nvector<pii>ah[mxn];\r\nint zx(int x,int e,int S){forg(i,x)if(i!=e&&!vs[to[i]]&&sz[to[i]]*2>S)return zx(to[i],i^1,S);return x;}\r\nvoid dfs0(int x,int e=0){\r\n//    ac.add(p,1);for(pii k:ah[x])da[k.first]+=ac.ask(k.second);ah[x].clear();\r\n    sz[x]=1,fa[x]=e,dx[++dn]=x;forg(i,x)if(i!=e&&!vs[to[i]]){\r\n        int y=to[i];be[y]=be[x]?be[x]:y;dfs0(y,i^1),sz[x]+=sz[y];\r\n    }\r\n//    ac.add(p,-1);\r\n}\r\nvoid dfs2(int x,int e=0,int p=0){\r\n    ac.add(p,1);for(pii k:ah[x])da[k.first]+=ac.ask(k.second);ah[x].clear();\r\n    forg(i,x)if(i!=e&&!vs[to[i]])dfs2(to[i],i^1,ac.ac[p][ed[i]]);\r\n    ac.add(p,-1);\r\n}\r\nvoid dfs(int x=0,vector<thr>ve=ve0){\r\n    cz[x].clear();x=x?zx(x,0,sz[x]):rd(1,n);\r\n    be[x]=dn=0,dfs0(x);assert(dn==sz[x]);\r\n    static vector<thr>v0;\r\n    for(auto k:ve){\r\n        int x=k.x,y=k.y,v=k.k;if(be[x]!=be[y]||!be[x])\r\n            cz[k.x].push_back(k),ah[k.x].emplace_back(k.t,v),ah[k.y].emplace_back(k.t,-v);else v0.push_back(k);\r\n    }\r\n    auto ge=[&](pii k){\r\n        int t=abs(k.first);if(b2.le[t]!=k.second)t=b2.fa[t];return t;\r\n    };\r\n    dfs2(x);\r\n    static pii e1[mxn],e2[mxn];e1[x]=e2[x]={1,0};for(int t=2;t<=dn;++t){\r\n        int x=dx[t],y=to[fa[x]];e1[x]=e1[y],e2[x]=e2[y],b1.ju(e1[x],ed[fa[x]]),b2.ju(e2[x],ed[fa[x]]);\r\n    }\r\n    for(int t=1;t<=dn;++t){\r\n        int x=dx[t];if(cz[x].size()){\r\n            int t=abs(e1[x].first);if(b1.le[t]!=e1[x].second)t=b1.fa[t];\r\n            if(t>1)for(auto k:cz[x])xw[t].push_back({k.k,ge(e2[k.y]),k.t});\r\n            cz[x].clear();\r\n        }\r\n    }\r\n    for(auto k:v0)cz[be[k.x]].push_back(k);v0.clear();\r\n    vs[x]=1;forg(i,x)if(!vs[to[i]])dfs(to[i],cz[to[i]]);\r\n}\r\n#define mid ((l+r)>>1)\r\nint rt[mxn];\r\nstruct seeee{\r\n    static const int mxm=mxn*20;\r\n    int vl[mxm],dc,ls[mxm],rs[mxm];\r\n    void add(int&x,int lc,int rc,int v,int l=1,int r=m){\r\n        if(!x)x=++dc;if(lc<=l&&r<=rc)return vl[x]+=v,void();\r\n        if(lc<=mid)add(ls[x],lc,rc,v,l,mid);if(rc>mid)add(rs[x],lc,rc,v,mid+1,r);\r\n    }\r\n    int ask(int x,int k){\r\n        int l=1,r=m,re=0;while(1){re+=vl[x];if(l==r||!x)return re;if(k<=mid)x=ls[x],r=mid;else x=rs[x],l=mid+1;}\r\n    }\r\n}se;\r\n#undef mid\r\nvoid dfs1(int x){\r\n    for(auto k:dd[x])se.add(rt[k.second],d1[k.first],d2[k.first],1);\r\n    for(auto k:xw[x])da[k.k]+=se.ask(rt[k.x],d1[k.y]);\r\n    forg(i,x)dfs1(to[i]);\r\n    for(auto k:dd[x])se.add(rt[k.second],d1[k.first],d2[k.first],-1);\r\n}\r\nint main(){\r\n    cin>>n>>m>>qn;for(int i=1,x,y;i<n;++i){static char o[3];scanf(\"%d%d%s\",&x,&y,o);gad(x,y,o[0]-'a');}\r\n    int sn=0;\r\n    for(T=1;T<=m;++T){\r\n        b1.P=b2.P=1;scanf(\"%s\",s+1);int l=strlen(s+1);L[T]=l;ac.ins(T);\r\n        static int e[mxn];\r\n        for(int i=1;i<=l;++i)b1.ins(s[i]),S1[sn+i]=s[i],e[i]=b1.P;\r\n        reverse(s+1,s+l+1);\r\n        for(int i=1;i<=l;++i)b2.ins(s[i]),S2[sn+i]=s[i],dd[e[l-i]].emplace_back(b2.P,T);\r\n        sn+=l;L0[T]=sn;\r\n    }\r\n    b1.EE(S2),b2.EE(S1);ac.bud();\r\n    for(int i=1;i<=qn;++i){thr t;scanf(\"%d%d%d\",&t.x,&t.y,&t.k);t.t=i;ve0.push_back(t);}\r\n    dfs();b2.gd(),dn=0,dfsd(1),m=b2.m,assert(dn==m);b1.gd();\r\n    if(qn<=5e4)dfs1(1);\r\n    for(int i=1;i<=qn;++i)printf(\"%d\\n\",da[i]);\r\n    return 0;\r\n}\r\n"
}