{
    "id": 155003302,
    "contestId": 917,
    "creationTimeSeconds": 1650954497,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "legendgoddes"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 16,
    "timeConsumedMillis": 498,
    "memoryConsumedBytes": 164761600,
    "source": "#include <bits/stdc++.h>\r\n#include <bits/extc++.h>\r\nusing namespace std;\r\nusing namespace __gnu_cxx;\r\nusing namespace __gnu_pbds;\r\nnamespace Legendgod {\r\n\tnamespace Read {\r\n//\t\t#define Fread\r\n\t\t#ifdef Fread\r\n\t\tconst int Siz = (1 << 21) + 5;\r\n\t\tchar *iS, *iT, buf[Siz];\r\n\t\t#define gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )\r\n\t\t#define getchar gc\r\n\t\t#endif\r\n\t\ttemplate <typename T>\r\n\t\tvoid r1(T &x) {\r\n\t\t    x = 0;\r\n\t\t\tchar c(getchar());\r\n\t\t\tint f(1);\r\n\t\t\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\r\n\t\t\tfor(; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\r\n\t\t\tx *= f;\r\n\t\t}\r\n\t\ttemplate <typename T, typename...Args>\r\n\t\tvoid r1(T &x, Args&...arg) {\r\n\t\t\tr1(x), r1(arg...);\r\n\t\t}\r\n\t\t#undef getchar\r\n\t}\r\n\r\nusing namespace Read;\r\n\r\nconst int maxn = 2e5 + 5;\r\nint n, m, Q, head[maxn], cnt(1);\r\nstruct Edge {\r\n    int to, next, w;\r\n}edg[maxn << 1];\r\nvoid add(int u,int v,int w) {\r\n    edg[++ cnt] = (Edge) {v, head[u], w}, head[u] = cnt;\r\n}\r\nchar _s[maxn];\r\n//constexpr int mod1 = 1e9 + 7, mod2 = 1e9 + 9;\r\nstruct Hash {\r\n    unsigned long long a, b;\r\n    Hash(int x = 0,int y = 0) : a(x), b(y) {}\r\n    Hash operator + (const Hash& z) { return (Hash){(a + z.a), (b + z.b)}; }\r\n    Hash operator - (const Hash& z) { return (Hash){(a - z.a), (b - z.b)}; }\r\n    Hash operator * (const Hash& z) { return (Hash){a * z.a, b * z.b}; }\r\n    bool operator == (const Hash& z) { return (a == z.a) && (b == z.b); }\r\n    bool operator != (const Hash& z) { return !((*this) == z); }\r\n}pw[maxn], th[maxn];\r\nconst Hash base = (Hash){31, 79};\r\nint fa[maxn][21], cl[maxn], dep[maxn];\r\nHash Thas(int u,int lc) {\r\n    return th[u] - th[lc] * pw[dep[u] - dep[lc]];\r\n}\r\n\r\nvoid dfs(int p,int pre) {\r\n    fa[p][0] = pre, dep[p] = dep[pre] + 1;\r\n    for(int i = 1; i < 19; ++ i) fa[p][i] = fa[fa[p][i - 1]][i - 1];\r\n    for(int i = head[p];i;i = edg[i].next) {\r\n        int to = edg[i].to; if(to == pre) continue;\r\n        cl[to] = edg[i].w, th[to] = th[p] * base + (Hash){cl[to], cl[to]};\r\n        dfs(to, p);\r\n    }\r\n}\r\n\r\nint Lca(int u,int v) {\r\n    if(dep[u] < dep[v]) swap(u, v);\r\n    int d = dep[u] - dep[v];\r\n    for(int i = 18; i >= 0; -- i) if((d >> i) & 1) u = fa[u][i];\r\n    if(u == v) return u;\r\n    for(int i = 18; i >= 0; -- i) {\r\n        if(fa[u][i] != fa[v][i]) {\r\n            u = fa[u][i], v = fa[v][i];\r\n        }\r\n    }\r\n    return fa[u][0];\r\n}\r\n\r\nint Jump(int u,int k) {\r\n    for(int i = 18; i >= 0; -- i) if((k >> i) & 1) u = fa[u][i];\r\n    return u;\r\n}\r\n\r\nstruct ACAM {\r\n    int tr[maxn][27], fl[maxn], tot, pos[maxn];\r\n    vector<int> vc[maxn];\r\n    ACAM(void) : tot(1) {}\r\n    void Insert(char* str,int m,int id) {\r\n        int p = 1;\r\n        for(int i = 1; i <= m; ++ i) {\r\n            int x = str[i] - 'a' + 1;\r\n            if(!tr[p][x]) tr[p][x] = ++ tot;\r\n            p = tr[p][x];\r\n        }\r\n        pos[id] = p;\r\n    }\r\n    int dfn[maxn], edfn[maxn], dfntot;\r\n    void dfs(int p) {\r\n        dfn[p] = ++ dfntot;\r\n        for(const int& v : vc[p]) dfs(v);\r\n        edfn[p] = dfntot;\r\n    }\r\n    void build() {\r\n        static queue<int> q; while(!q.empty()) q.pop();\r\n        for(int i = 1; i <= 26; ++ i) if(tr[1][i]) q.push(tr[1][i]), fl[tr[1][i]] = 1;\r\n        else tr[1][i] = 1;\r\n        while(!q.empty()) {\r\n            int u = q.front(); q.pop();\r\n            for(int v, i = 1; i <= 26; ++ i) {\r\n                v = tr[u][i];\r\n                if(v) {\r\n                    q.push(v), fl[v] = tr[fl[u]][i];\r\n                }\r\n                else tr[u][i] = tr[fl[u]][i];\r\n            }\r\n        }\r\n        for(int i = 2; i <= tot; ++ i) vc[fl[i]].emplace_back(i);\r\n        dfntot = 0;\r\n        dfs(1);\r\n    }\r\n    int t[maxn];\r\n    int lowbit(int x) { return x & -x; }\r\n    void add(int p,int c) { p = dfn[p]; for(; p <= tot; p += lowbit(p)) t[p] += c;}\r\n    int ask(int p) { int res(0); for(; p > 0; p -= lowbit(p)) res += t[p]; return res; }\r\n    int query(int x) { x = pos[x]; return ask(edfn[x]) - ask(dfn[x] - 1); }\r\n}Ta[2];\r\n// Arithmetic sequence\r\nstruct Arith {\r\n    int s, t, d;\r\n};\r\n\r\nstruct KMP {\r\n    int *bel, *nxt, *del, n;\r\n    void Insert(char* str,int m) {\r\n        bel = new int[m + 2] ();\r\n        nxt = new int[m + 2] ();\r\n        del = new int[m + 2] ();\r\n        n = m;\r\n        del[1] = 1, bel[1] = 1;\r\n        for(int i = 2, j = 0; i <= n; ++ i) {\r\n            while(j && str[j + 1] != str[i]) j = nxt[j];\r\n//            printf(\"j = %d\\n\", j);\r\n            if(str[j + 1] == str[i]) ++ j;\r\n            del[i] = i - j, nxt[i] = j;\r\n            bel[i] = (del[i] == del[j] ? bel[j] : i);\r\n        }\r\n    }\r\n\r\n    void Get(int p,int len,Arith* ret, int& tot) const {\r\n        for(; p > len; p = nxt[p]) ;\r\n        tot = 0;\r\n        while(p > 0) {\r\n            int s = bel[p], t = p, d = del[p];\r\n            ret[++ tot] = {s, t, d};\r\n            p = nxt[p];\r\n        }\r\n    }\r\n\r\n}p[2][maxn];\r\n\r\nint buc[maxn];\r\n\r\nstruct SA {\r\n    int *a, *sa, *sa2, *rk, n, m;\r\n    Hash *h;\r\n\r\n    void Sort() {\r\n        for(int i = 1; i <= m; ++ i) buc[i] = 0;\r\n        for(int i = 1; i <= n; ++ i) buc[rk[i]] ++;\r\n        for(int i = 1; i <= m; ++ i) buc[i] += buc[i - 1];\r\n        for(int i = n; i >= 1; -- i) sa[buc[rk[sa2[i]]] --] = sa2[i];\r\n    }\r\n\r\n    void Insert(char *str, int ln) {\r\n        n = ln, m = 26;\r\n        a = new int[n + 2] ();\r\n        sa = new int[n + 2] ();\r\n        sa2 = new int[n + 2] ();\r\n        rk = new int[n + 2] ();\r\n        h = new Hash[n + 2] ();\r\n        for(int i = 1; i <= n; ++ i) a[i] = str[i] - 'a' + 1, h[i] = h[i - 1] * base + (Hash){a[i], a[i]};\r\n        for(int i = 1; i <= n; ++ i) rk[i] = a[i], sa2[i] = i;\r\n        Sort();\r\n\r\n        for(int i = 1; i <= n; i <<= 1) {\r\n            int num(0);\r\n            for(int j = n - i + 1; j <= n; ++ j) sa2[++ num] = j;\r\n            for(int j = 1; j <= n; ++ j) if(sa[j] > i)\r\n                sa2[++ num] = sa[j] - i;\r\n            Sort();\r\n            swap(rk, sa2);\r\n            num = 1;\r\n            rk[sa[1]] = 1;\r\n            for(int j = 2; j <= n; ++ j)\r\n                rk[sa[j]] = (sa2[sa[j]] == sa2[sa[j - 1]] && sa2[sa[j] + i] == sa2[sa[j - 1] + i]) ? num : ++ num;\r\n            if(num >= n) break;\r\n            m = num;\r\n        }\r\n    }\r\n\r\n    Hash Has(int l,int r) {\r\n        return h[r] - h[l - 1] * pw[r - l + 1];\r\n    }\r\n\r\n    int lcp(int id, int u,int lc) {\r\n        int x = sa[id], ln = n - x + 1;\r\n        if(u == lc) return 0;\r\n        if(ln >= dep[u] - dep[lc] && Thas(u, lc) == Has(x, x + dep[u] - dep[lc] - 1)) return dep[u] - dep[lc];\r\n        for(int i = 18; i >= 0; -- i) if(dep[u] - dep[lc] > (1 << i))\r\n            if( (ln < dep[fa[u][i]] - dep[lc]) || (Thas(fa[u][i], lc) != Has(x, x + dep[fa[u][i]] - dep[lc] - 1)) ) {\r\n                u = fa[u][i];\r\n            }\r\n        u = fa[u][0];\r\n        return dep[u] - dep[lc];\r\n    }\r\n\r\n    bool check(int mid, int u,int lc) {\r\n        int L = lcp(mid, u, lc);\r\n        if(L == n - sa[mid] + 1) return 1;\r\n        if(L == dep[u] - dep[lc]) return 0;\r\n        return a[sa[mid] + L] < cl[Jump(u, dep[u] - dep[lc] - L - 1)];\r\n    }\r\n\r\n    void Solve(int u,int lc,KMP& kp, Arith* ret, int& num) {\r\n        int l = 1, r = n, mid, ans(0);\r\n        while(l <= r) {\r\n            mid = (l + r) >> 1;\r\n            if(check(mid, u, lc)) ans = mid, l = mid + 1;\r\n            else r = mid - 1;\r\n        }\r\n        num = 0;\r\n        if(!ans) return ;\r\n        int p = n - sa[ans] + 1, ln = lcp(ans, u, lc);\r\n        kp.Get(p, ln, ret, num);\r\n    }\r\n\r\n}s[2][maxn];\r\n\r\nlong long ans[maxn];\r\n\r\nstruct Quer {\r\n    int id, opt, C, str;\r\n};\r\nvector<Quer> q[maxn];\r\nint sstr[maxn];\r\n\r\nvoid dfs2(int p,int pre,int num0, int num1) {\r\n    Ta[0].add(num0, 1), Ta[1].add(num1, 1);\r\n    for(const Quer& v : q[p]) {\r\n        ans[v.id] += v.C * Ta[v.opt].query(v.str);\r\n    }\r\n    for(int i = head[p];i;i = edg[i].next) {\r\n        int to = edg[i].to; if(to == pre) continue;\r\n        int c = edg[i].w;\r\n        dfs2(to, p, Ta[0].tr[num0][c], Ta[1].tr[num1][c]);\r\n    }\r\n    Ta[0].add(num0, - 1), Ta[1].add(num1, - 1);\r\n}\r\n\r\nvoid qadd(int u,int lc,int c,int id,int op) {\r\n    if(dep[u] - dep[lc] < sstr[c]) return ;\r\n    q[u].push_back({id, op, 1, c});\r\n    int x = Jump(u, dep[u] - dep[lc] - sstr[c] + 1);\r\n    q[x].push_back({id, op, - 1, c});\r\n}\r\n\r\nnamespace Chain {\r\n    Arith a1[65], a2[65];\r\n    int n1, n2;\r\n    int exgcd(int a,int b,long long& x,long long& y) {\r\n        if(b == 0) return x = 1, y = 0, a;\r\n        int gc = exgcd(b, a % b, x, y); long long z = x;\r\n        x = y, y = (z - a / b * y);\r\n        return gc;\r\n    }\r\n\r\n    int Calc(int a,int b,int ua,int ub,int c) {\r\n        long long x, y, x1, y1, dx, dy, mx;\r\n        int gd = exgcd(a, b, x, y);\r\n        if(c % gd != 0) return 0;\r\n        x1 = c * x / gd, y1 = c * y / gd;\r\n        dx = b / gd, dy = a / gd, mx = x1 % dx;\r\n        if(mx < 0) mx += dx;\r\n        y1 += ((x - mx) / dx) * dy, x1 = mx;\r\n        if(y1 < 0) return 0;\r\n        if(y1 > ub) {\r\n            int tmp = (y1 - ub - 1) / dy + 1;\r\n            y1 -= tmp * dy, x1 += tmp * dx;\r\n        }\r\n        if(x1 < 0 || y1 < 0 || x1 > ua || y1 > ub) return 0;\r\n        return min((ua - x1) / dx + 1, (ub - y1) / dy + 1);\r\n    }\r\n\r\n    int calc(Arith& x, Arith& y,int ln) {\r\n        return Calc(x.d, y.d, (x.t - x.s) / x.d, (y.t - y.s) / y.d, ln - x.s - y.s);\r\n    }\r\n\r\n    void Solve(int u, int v,int lc, int id,int qi) {\r\n        s[1][id].Solve(u, lc, p[0][id], a1, n1);\r\n        s[0][id].Solve(v, lc, p[1][id], a2, n2);\r\n//        assert(n1 < 60 && n2 < 60);\r\n        int ln = sstr[id]; long long res(0);\r\n        for(int a = 1; a <= n1; ++ a) for(int b = 1; b <= n2; ++ b)\r\n        if(a1[a].s + a2[b].s <= ln && a1[a].t + a2[b].t >= ln) {\r\n            res += calc(a1[a], a2[b], ln);\r\n        }\r\n        ans[qi] += res;\r\n    }\r\n}\r\n\r\nsigned main() {\r\n\tint i, j;\r\n    r1(n, m, Q);\r\n    pw[0] = {1, 1};\r\n    for(i = 1; i < maxn; ++ i) pw[i] = pw[i - 1] * base;\r\n    for(i = 1; i < n; ++ i) {\r\n        int u, v; r1(u, v), scanf(\"%s\", _s + 1);\r\n        add(u, v, _s[1] - 'a' + 1), add(v, u, _s[1] - 'a' + 1);\r\n    }\r\n    dfs(1, 0);\r\n    for(i = 1; i <= m; ++ i) {\r\n        scanf(\"%s\", _s + 1);\r\n        int ln = strlen(_s + 1);\r\n        sstr[i] = ln;\r\n        Ta[0].Insert(_s, ln, i);\r\n        p[0][i].Insert(_s, ln);\r\n        s[0][i].Insert(_s, ln);\r\n        reverse(_s + 1, _s + ln + 1);\r\n        Ta[1].Insert(_s, ln, i);\r\n        p[1][i].Insert(_s, ln);\r\n        s[1][i].Insert(_s, ln);\r\n    }\r\n    Ta[0].build(), Ta[1].build();\r\n    /*\r\nstruct Quer {\r\n    int id, opt, C, str;\r\n};\r\n    */\r\n    for(i = 1; i <= Q; ++ i) {\r\n        int u, v, c;\r\n        r1(u, v, c);\r\n        int lc = Lca(u, v);\r\n        qadd(u, lc, c, i, 1), qadd(v, lc, c, i, 0);\r\n        Chain::Solve(u, v, lc, c, i);\r\n    }\r\n//    for(i = 1; i <= Q; ++ i) printf(\"%d : %lld\\n\", i, ans[i]);\r\n    dfs2(1, 0, 1, 1);\r\n    for(i = 1; i <= Q; ++ i) printf(\"%lld\\n\", ans[i]);\r\n\treturn 0;\r\n}\r\n\r\n}\r\n\r\n\r\nsigned main() { return Legendgod::main(), 0; }//\r\n\r\n"
}