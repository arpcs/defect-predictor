{
    "id": 193621788,
    "contestId": 917,
    "creationTimeSeconds": 1676389915,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "cyh_toby"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1466,
    "memoryConsumedBytes": 191385600,
    "source": "// LUOGU_RID: 102166228\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 1e5 + 5, M = 2e5 + 5;\r\ntypedef vector<int> vi;\r\n#define pb push_back\r\n\r\nint n, m, q;\r\nint g[N], v[N<<1], w[N<<1], nxt[N<<1], tot;\r\nstring s[N][2];\r\nstruct Qs { int u, v, k; } qs[N];\r\nint len[N][2], ans[N];\r\nvi pos[N][2];\r\nint sz[N], mxs[N], vis[N], col[N], dep[N];\r\n\r\ninline void add(int x, int y, int z) {\r\n\tv[++tot] = y, w[tot] = z, nxt[tot] = g[x], g[x] = tot;\r\n}\r\n\r\nstruct SAM {\r\n\tint ch[M][26], len[M], pa[M], tot, lst;\r\n\tvi e[M];\r\n\tint dfn[M], sec, sz[M], son[M], tp[M];\r\n\tint to[M][26], w[M][26];//\u76f4\u63a5\u628a sam \u6539\u88c5\u6210 acam \r\n\tvi v[M];\r\n\tinline int extend(int c) {\r\n\t\tint p = lst;\r\n\t\tif (ch[p][c]) {\r\n\t\t\tint q = ch[p][c];\r\n\t\t\tif (len[p] + 1 == len[q]) return lst = q;\r\n\t\t\tint k = ++tot;\r\n\t\t\tpa[k] = pa[q], memcpy(ch[k], ch[q], sizeof(ch[k]));\r\n\t\t\tlen[k] = len[p] + 1, pa[q] = k;\r\n\t\t\twhile (~p && ch[p][c] == q) ch[p][c] = k, p = pa[p];\r\n\t\t\treturn lst = k;\r\n\t\t}\r\n\t\tint x = ++tot;\r\n\t\tlen[x] = len[p] + 1;\r\n\t\twhile (~p && !ch[p][c]) ch[p][c] = x, p = pa[p];\r\n\t\tif (!~p) return pa[x] = 0, lst = x;\r\n\t\tint q = ch[p][c];\r\n\t\tif (len[p] + 1 == len[q]) return pa[x] = q, lst = x;\r\n\t\tint k = ++tot;\r\n\t\tpa[k] = pa[q], memcpy(ch[k], ch[q], sizeof(ch[k]));\r\n\t\tlen[k] = len[p] + 1, pa[x] = pa[q] = k;\r\n\t\twhile (~p && ch[p][c] == q) ch[p][c] = k, p = pa[p];\r\n\t\treturn lst = x;\r\n\t}\r\n\tinline void ins(int id, int o) {\r\n\t\tpa[0] = -1, lst = 0;\r\n\t\tint len = s[id][o].size();\r\n\t\tpos[id][o].resize(len);\r\n\t\tfor (int i = 0; i < len; i++) pos[id][o][i] = extend(s[id][o][i] - 'a');\r\n\t}\r\n\tvoid dfs1(int x) {\r\n\t\tsz[x] = 1;\r\n\t\tfor (int i = 0; i < 26; i++) {\r\n\t\t\tif (ch[x][i]) to[x][i] = ch[x][i], w[x][i] = len[x];\r\n\t\t\telse if (!x) to[x][i] = 0, w[x][i] = -1;\r\n\t\t\telse to[x][i] = to[pa[x]][i], w[x][i] = w[pa[x]][i];\r\n\t\t}\r\n\t\tfor (auto y : e[x]) {\r\n\t\t\tdfs1(y), sz[x] += sz[y];\r\n\t\t\tif (!son[x] || sz[y] > sz[son[x]]) son[x] = y;\r\n\t\t}\r\n\t}\r\n\tvoid dfs2(int x, int p) {\r\n\t\ttp[x] = p, dfn[x] = ++sec;\r\n\t\tif (son[x]) dfs2(son[x], p);\r\n\t\tfor (auto y : e[x]) if (y != son[x]) dfs2(y, y);\r\n\t}\r\n\tinline void build() {\r\n\t\tfor (int i = 1; i <= tot; i++) e[pa[i]].pb(i);\r\n\t\tdfs1(0), dfs2(0, 0);\r\n\t}\r\n\tinline void push(int p, int k) { v[tp[p]].pb(k); }\r\n\tinline void pop(int p, int k) { v[tp[p]].pop_back(); }\r\n\tinline int calc(int p) {\r\n\t\twhile (~p) {\r\n\t\t\tint q = tp[p];\r\n\t\t\tif (!v[q].empty() && v[q].front() <= len[p]) \r\n\t\t\t\treturn *--upper_bound(v[q].begin(), v[q].end(), len[p]);\r\n\t\t\tp = pa[q];\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n} sam[2];\r\n\r\nstruct BIT {\r\n\tint c[M];\r\n\tinline void upd(int x, int v) {\r\n\t\tfor (; x < M; x += x & -x) c[x] += v;\r\n\t}\r\n\tinline int qry(int x) {\r\n\t\tint res = 0;\r\n\t\tfor (; x; x -= x & -x) res += c[x];\r\n\t\treturn res;\r\n\t}\r\n\tinline int qry(int l, int r) {\r\n\t\treturn qry(r) - qry(l - 1);\r\n\t}\r\n} bit[2];\r\n\r\nint getrt(int x, int fa, int sum) {\r\n\tsz[x] = 1, mxs[x] = 0;\r\n\tint rt = 0;\r\n\tfor (int i = g[x]; i; i = nxt[i]) {\r\n\t\tint y = v[i];\r\n\t\tif (vis[y] || y == fa) continue;\r\n\t\tint k = getrt(y, x, sum);\r\n\t\tsz[x] += sz[y], mxs[x] = max(mxs[x], sz[y]);\r\n\t\tif (!rt || mxs[k] < mxs[rt]) rt = k;\r\n\t}\r\n\tmxs[x] = max(mxs[x], sum - sz[x]);\r\n\tif (!rt || mxs[x] < mxs[rt]) rt = x;\r\n\treturn rt;\r\n}\r\n\r\nvoid getdis(int x, int fa, int dpt, int c) {\r\n\tcol[x] = c, sz[x] = 1, dep[x] = dpt;\r\n\tfor (int i = g[x]; i; i = nxt[i]) {\r\n\t\tint y = v[i];\r\n\t\tif (vis[y] || y == fa) continue;\r\n\t\tgetdis(y, x, dep[x] + 1, c), sz[x] += sz[y];\r\n\t}\r\n}\r\n\r\nvi que[N];\r\n\r\nvoid dfs(int x, int fa, int p0, int l0, int p1, int l1) {\r\n\tl0 = min(l0, sam[0].len[p0]), l1 = min(l1, sam[1].len[p1]);\r\n\tif (fa) {\r\n\t\tif (sam[0].len[p0] == l0) bit[0].upd(sam[0].dfn[p0], 1);\r\n\t\telse bit[0].upd(sam[0].dfn[sam[0].pa[p0]], 1);\r\n\t\tif (sam[1].len[p1] == l1) bit[1].upd(sam[1].dfn[p1], 1);\r\n\t\telse bit[1].upd(sam[1].dfn[sam[1].pa[p1]], 1);\r\n\t\tif (l0 == dep[x]) sam[0].push(p0, l0);\r\n\t\tif (l1 == dep[x]) sam[1].push(p1, l1);\r\n\t}\r\n\tfor (auto i : que[x]) {\r\n\t\tint o = 0;\r\n\t\tif (i < 0) i = -i, o = 1;\r\n\t\tint k = qs[i].k;\r\n\t\tauto calc = [&](int pos) { \r\n\t\t\treturn bit[o].qry(sam[o].dfn[pos], sam[o].dfn[pos] + sam[o].sz[pos] - 1); \r\n\t\t};\r\n\t\tans[i] += calc(pos[k][o].back());\r\n\t\tlen[i][o] = sam[o].calc(pos[k][o].back());\r\n\t}\r\n\tvi().swap(que[x]);\r\n\tfor (int i = g[x]; i; i = nxt[i]) {\r\n\t\tint y = v[i], z = w[i];\r\n\t\tif (vis[y] || y == fa) continue;\r\n\t\tdfs(y, x, sam[0].to[p0][z], min(l0, sam[0].w[p0][z]) + 1, sam[1].to[p1][z], min(l1, sam[1].w[p1][z]) + 1);\r\n\t}\r\n\tif (fa) {\r\n\t\tif (sam[0].len[p0] == l0) bit[0].upd(sam[0].dfn[p0], -1);\r\n\t\telse bit[0].upd(sam[0].dfn[sam[0].pa[p0]], -1);\r\n\t\tif (sam[1].len[p1] == l1) bit[1].upd(sam[1].dfn[p1], -1);\r\n\t\telse bit[1].upd(sam[1].dfn[sam[1].pa[p1]], -1);\r\n\t\tif (l0 == dep[x]) sam[0].pop(p0, l0);\r\n\t\tif (l1 == dep[x]) sam[1].pop(p1, l1);\r\n\t}\r\n}\r\n\r\n\r\n\r\nvoid solve(int x, vi Q) {\r\n\tif (Q.empty()) return;\r\n\tvis[x] = 1, dep[x] = 0;\r\n\tvi P;\r\n\tcol[x] = P.size(), P.pb(x);\r\n\tfor (int i = g[x]; i; i = nxt[i]) {\r\n\t\tint y = v[i];\r\n\t\tif (vis[y]) continue;\r\n\t\tgetdis(y, x, 1, P.size()), P.pb(y);\r\n\t}\r\n\tvector<vi > sonq(P.size());\r\n\tfor (auto o : Q) {\r\n\t\tif (col[qs[o].u] == col[qs[o].v]) sonq[col[qs[o].u]].pb(o);\r\n\t\telse {\r\n\t\t\tif (qs[o].u != x) que[qs[o].u].pb(o);\r\n\t\t\tif (qs[o].v != x) que[qs[o].v].pb(-o);\r\n\t\t}\r\n\t}\r\n\tdfs(x, 0, 0, 0, 0, 0);\r\n\tvi().swap(Q);\r\n\tfor (int i = 1; i < (int)P.size(); i++) {\r\n\t\tint rt = getrt(P[i], 0, sz[P[i]]);\r\n\t\tsolve(rt, sonq[i]);\r\n\t\tvi().swap(sonq[i]);\r\n\t}\r\n}\r\n\r\nvi evt[N];\r\nstruct KMP {\r\n\tint fail[N], dfn[N], sec, sz[N];\r\n\tvi e[N];\r\n\tvoid dfs(int x) {\r\n\t\tdfn[x] = ++sec, sz[x] = 1; \r\n\t\tfor (auto y : e[x]) {\r\n\t\t\tdfs(y), sz[x] += sz[y];\r\n\t\t}\r\n\t}\r\n\tinline void build(const string &s) {\r\n\t\tint len = s.size();\r\n\t\tfor (int i = 0; i <= len; i++) e[i].clear();\r\n\t\tfail[1] = 0, e[0].pb(1);\r\n\t\tfor (int i = 2, j = 0; i <= len; i++) {\r\n\t\t\twhile (j && s[j] != s[i-1]) j = fail[j];\r\n\t\t\tif (s[j] == s[i-1]) j++;\r\n\t\t\tfail[i] = j, e[j].pb(i);\r\n\t\t}\r\n\t\tsec = 0, dfs(0);\r\n\t}\r\n} b[2];\r\n\r\nvoid dfs(int x, int k) {\r\n\tif (x && x < k) bit[0].upd(b[1].dfn[k - x], 1), bit[0].upd(b[1].dfn[k - x] + b[1].sz[k - x], -1);\r\n\tfor (auto o : evt[x]) ans[o] += bit[0].qry(b[1].dfn[len[o][1]]);\t\r\n\tfor (auto y : b[0].e[x]) dfs(y, k);\r\n\tif (x && x < k) bit[0].upd(b[1].dfn[k - x], -1), bit[0].upd(b[1].dfn[k - x] + b[1].sz[k - x], 1);\r\n}\r\n\r\nint main()\r\n{\r\n\tcin >> n >> m >> q;\r\n\tfor (int i = 1; i < n; i++) {\r\n\t\tint x, y; char z;\r\n\t\tcin >> x >> y >> z;\r\n\t\tadd(x, y, z - 'a'), add(y, x, z - 'a');\r\n\t}\r\n\tfor (int i = 1; i <= m; i++) {\r\n\t\tcin >> s[i][0]; \r\n\t\ts[i][1] = s[i][0], reverse(s[i][0].begin(), s[i][0].end());\r\n\t\tsam[0].ins(i, 0), sam[1].ins(i, 1);\r\n\t}\r\n\tsam[0].build(), sam[1].build();\r\n\tvi Q;\r\n\tfor (int i = 1; i <= q; i++) {\r\n\t\tcin >> qs[i].u >> qs[i].v >> qs[i].k;\r\n\t\tQ.pb(i);\r\n\t}\r\n\tint rt = getrt(1, 0, n);\r\n\tsolve(rt, Q);\r\n\tfor (int i = 1; i <= q; i++) que[qs[i].k].pb(i);\r\n\tfor (int i = 1; i <= m; i++) if (!que[i].empty()) {\r\n\t\tb[0].build(s[i][1]), b[1].build(s[i][0]);\r\n\t\tfor (auto o : que[i]) if (len[o][0]) evt[len[o][0]].pb(o);\r\n\t\tdfs(0, s[i][0].size());\r\n\t\tfor (int j = 0; j <= (int)s[i][0].size(); j++) evt[j].clear();\r\n\t}\r\n\tfor (int i = 1; i <= q; i++) printf(\"%d\\n\", ans[i]);\r\n\treturn 0;\r\n}"
}