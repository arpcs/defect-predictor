{
    "id": 227532082,
    "contestId": 917,
    "creationTimeSeconds": 1696940234,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "vjudge3"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1700,
    "memoryConsumedBytes": 126156800,
    "source": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n#define fir first\n#define sec second\ntypedef vector <int> vi;\ntypedef vector <ll> vl;\n\n#ifdef LCX\n#define msg(args...) fprintf(stderr, args)\n#else\n#define msg(...) void()\n#endif\n\n#define Memset(a, b) (memset((a), (b), sizeof (a)))\nint sgn(int x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\nstring rev(string s) { reverse(begin(s), end(s)); return s; }\n\nconst int maxn = 2e5 + 10, SIGMA = 26;\nint n, m, q, ans[maxn];\nstring s[maxn];\nstruct Query {\n    int x, y, z, p;\n} a[maxn];\n\nstruct BIT {\n    int c[maxn], n;\n    void init(int _n) { n = _n, fill(c, c + n + 1, 0); }\n    void add(int x, int y) { for (; x <= n; x += x & -x) c[x] += y; }\n    void add(int l, int r, int x) { add(l, x), add(r + 1, -x); }\n    int ask(int x) {\n        int res = 0;\n        for (; x > 0; x &= x - 1) res += c[x];\n        return res;\n    }\n    int ask(int l, int r) { return ask(r) - ask(l - 1); }\n} tr;\n\nnamespace Tree {\nvoid add(int u, int v, int c);\nint lca(int x, int y);\nint jump(int u, int k);\nvoid build();\n\nvector <pii> e[maxn];\nvoid add(int u, int v, int c) {\n    e[u].push_back({v, c});\n    e[v].push_back({u, c});\n}\n\nconst int B = 20;\nint fa[B][maxn], dep[maxn], w[maxn];\nvoid dfs(int u, int pre) {\n    fa[0][u] = pre, dep[u] = dep[pre] + 1;\n    for (int i = 1; i < B; ++i)\n        fa[i][u] = fa[i - 1][fa[i - 1][u]];\n    for (pii p : e[u]) {\n        int v = p.fir;\n        if (v == pre) continue;\n        w[v] = p.sec, dfs(v, u);\n    }\n}\nint lca(int x, int y) {\n    if (dep[x] < dep[y]) swap(x, y);\n    for (int i = B - 1; i >= 0; --i)\n        if (dep[x] - dep[y] >= (1 << i)) x = fa[i][x];\n    if (x == y) return x;\n    for (int i = B - 1; i >= 0; --i)\n        if (fa[i][x] != fa[i][y]) x = fa[i][x], y = fa[i][y];\n    return fa[0][x];\n}\nint jump(int u, int k) {\n    for (int i = B - 1; i >= 0; --i)\n        if ((k >> i) & 1) u = fa[i][u];\n    return u;\n}\n\nvoid build() { dfs(1, 0); }\n}\n\nnamespace Solve1 {\nvoid work();\n\nnamespace ACAM {\nvoid init();\nint ins(string s);\nvoid build();\n\nint trie[maxn][SIGMA], tot;\nvoid init() { Memset(trie, 0), tot = 1; }\n\nint ins(string s) {\n    int u = 1;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (!trie[u][c]) trie[u][c] = ++tot;\n        u = trie[u][c];\n    }\n    return u;\n}\n\nint fail[maxn];\nvi e[maxn];\nint st[maxn], ed[maxn], idx;\nvoid dfs(int u) {\n    st[u] = ++idx;\n    for (int v : e[u]) dfs(v);\n    ed[u] = idx;\n}\nvoid build() {\n    queue <int> q;\n    for (int i = 0; i < SIGMA; ++i)\n        if (trie[1][i]) q.push(trie[1][i]), fail[trie[1][i]] = 1;\n        else trie[1][i] = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int c = 0; c < SIGMA; ++c)\n            if (!trie[u][c]) trie[u][c] = trie[fail[u]][c];\n            else q.push(trie[u][c]), fail[trie[u][c]] = trie[fail[u]][c];\n    }\n\n    for (int i = 1; i <= tot; ++i) e[i].clear();\n    for (int i = 2; i <= tot; ++i) e[fail[i]].push_back(i);\n    idx = 0, dfs(1);\n}\n}\n\nint pos[maxn];\nvi vec[maxn];\nvoid dfs(int u, int pre, int x) {\n    for (int i : vec[u]) {\n        int c = sgn(i); i = abs(i);\n        ans[i] += c * tr.ask(ACAM::st[pos[a[i].p]], ACAM::ed[pos[a[i].p]]);\n    }\n    for (pii p : Tree::e[u]) {\n        int v = p.fir, c = p.sec;\n        if (v == pre) continue;\n        int y = ACAM::trie[x][c];\n        tr.add(ACAM::st[y], 1);\n        dfs(v, u, y);\n        tr.add(ACAM::st[y], -1);\n    }\n}\nvoid work() {\n    ACAM::init();\n    for (int i = 1; i <= m; ++i) pos[i] = ACAM::ins(rev(s[i]));\n    ACAM::build();\n    for (int i = 1; i <= q; ++i) {\n        int x = a[i].x, z = a[i].z, len = s[a[i].p].size();\n        int d = Tree::dep[x] - Tree::dep[z];\n        if (d < len) continue;\n        vec[x].push_back(i);\n        vec[Tree::jump(x, d - len + 1)].push_back(-i);\n    }\n    tr.init(ACAM::tot);\n    dfs(1, 0, 1);\n\n    ACAM::init();\n    for (int i = 1; i <= m; ++i) pos[i] = ACAM::ins(s[i]);\n    ACAM::build();\n    for (int i = 0; i <= n; ++i) vec[i].clear();\n    for (int i = 1; i <= q; ++i) {\n        int y = a[i].y, z = a[i].z, len = s[a[i].p].size();\n        int d = Tree::dep[y] - Tree::dep[z];\n        if (d < len) continue;\n        vec[y].push_back(i);\n        vec[Tree::jump(y, d - len + 1)].push_back(-i);\n    }\n    tr.init(ACAM::tot);\n    dfs(1, 0, 1);\n}\n}\n\nnamespace Solve2 {\nusing Tree::dep;\nvoid work();\n\ntypedef unsigned long long ull;\nconst int B = 131;\null pw[maxn], htr[maxn];\nvoid dfs(int u, int pre) {\n    for (pii p : Tree::e[u]) {\n        int v = p.fir, c = p.sec;\n        if (v == pre) continue;\n        htr[v] = htr[u] * B + c + 1;\n        dfs(v, u);\n    }\n}\null get_hash(int u, int v) { return htr[v] - htr[u] * pw[dep[v] - dep[u]]; }\nvoid prework() {\n    pw[0] = 1;\n    for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * B;\n    dfs(1, 0);\n}\n\npii b[maxn];\n\nnamespace SA {\nvoid work(string Str, vi &Vec);\n\nint n, m;\nchar s[maxn];\nint sa[maxn], rk[maxn], tmp[maxn], cnt[maxn];\nvoid radix_sort() {\n    for (int i = 0; i <= m; ++i) cnt[i] = 0;\n    for (int i = 1; i <= n; ++i) cnt[rk[tmp[i]]]++;\n    for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];\n    for (int i = n; i >= 1; --i) sa[cnt[rk[tmp[i]]]--] = tmp[i];\n}\n\nint ht[maxn];\nvoid buildSA() {\n    fill(tmp, tmp + 2 * n + 3, 0);\n    m = SIGMA;\n    for (int i = 1; i <= n; ++i) rk[i] = s[i] - 'a' + 1, tmp[i] = i;\n    radix_sort();\n\n    for (int p = 0, w = 1; p < n; m = p, w <<= 1) {\n        p = 0;\n        for (int i = n; i > n - w; --i) tmp[++p] = i;\n        for (int i = 1; i <= n; ++i) if (sa[i] > w) tmp[++p] = sa[i] - w;\n        radix_sort();\n        for (int i = 1; i <= n; ++i) tmp[i] = rk[i];\n        p = 1, rk[sa[1]] = 1;\n        for (int i = 2; i <= n; ++i) {\n            int u = sa[i], v = sa[i - 1];\n            if (tmp[u] != tmp[v] || tmp[u + w] != tmp[v + w]) ++p;\n            rk[u] = p;\n        }\n    }\n    for (int i = 1, j = 0; i <= n; ++i) {\n        if (rk[i] == n) continue;\n        if (j) --j;\n        while (s[i + j] == s[sa[rk[i] + 1] + j]) ++j;\n        ht[rk[i]] = j;\n    }\n}\n\null hs[maxn];\null get(int l, int r) { return hs[r] - hs[l - 1] * pw[r - l + 1]; }\nint lcp(int p, int u, int v) {\n    if (u == v) return 0;\n    auto check = [&] (int x) -> int {\n        if (x == u) return 1;\n        int d = dep[x] - dep[u];\n        if (p + d - 1 > n) return 0;\n        return get_hash(u, x) == get(p, p + d - 1);\n    };\n    if (check(v)) return dep[v] - dep[u];\n    for (int i = Tree::B - 1; i >= 0; --i)\n        if (dep[v] - dep[u] >= (1 << i)) {\n            int x = Tree::fa[i][v];\n            if (!check(x)) v = x;\n        }\n    return dep[v] - dep[u] - 1;\n}\n\nint cmp(int p, int u, int v) {\n    int len = lcp(p, u, v);\n    if (len == n - p + 1) return 1;\n    if (len == dep[v] - dep[u]) return 0;\n    return s[p + len] < Tree::w[Tree::jump(v, dep[v] - dep[u] - len - 1)] + 'a';\n}\n\nint getrk(int u, int v) {\n    int l = 1, r = n, mid, res = 0;\n    while (l <= r) {\n        mid = (l + r) >> 1;\n        if (cmp(sa[mid], u, v)) res = mid, l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}\n\nvi vec[maxn];\nint stk[maxn], tp;\nvoid work(string Str, vi &Vec) {\n    if (Vec.empty()) return;\n    n = Str.size();\n    fill(s, s + n * 2 + 1, 0);\n    for (int i = 1; i <= n; ++i) s[i] = Str[i - 1];\n    buildSA();\n    hs[0] = 0;\n    for (int i = 1; i <= n; ++i)\n        hs[i] = hs[i - 1] * B + s[i] - 'a' + 1;\n    for (int i = 0; i <= n; ++i) vec[i].clear();\n    for (int i : Vec)\n        vec[getrk(a[i].z, a[i].x)].push_back(i);\n    tp = 0;\n    for (int o = 1; o <= n; ++o) {\n        int i = sa[o];\n        stk[++tp] = i;\n        for (int x : vec[o]) {\n            int len = lcp(i, a[x].z, a[x].x);\n            int l = 1, r = tp, mid, res = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (n - stk[mid] + 1 <= len) res = mid, l = mid + 1;\n                else r = mid - 1;\n            }\n            if (res) b[x].fir = max(b[x].fir, n - stk[res] + 1);\n        }\n        while (tp && n - stk[tp] + 1 > ht[o]) --tp;\n    }\n    tp = 0;\n    for (int o = n; o >= 1; --o) {\n        int i = sa[o];\n        stk[++tp] = i;\n        for (int x : vec[o - 1]) {\n            int len = lcp(i, a[x].z, a[x].x);\n            int l = 1, r = tp, mid, res = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (n - stk[mid] + 1 <= len) res = mid, l = mid + 1;\n                else r = mid - 1;\n            }\n            if (res) b[x].fir = max(b[x].fir, n - stk[res] + 1);\n        }\n        while (tp && n - stk[tp] + 1 > ht[o - 1]) --tp;\n    }\n}\n}\n\nnamespace KMP {\nvoid work(string &Str, vi &Vec);\n\nint n, nxt[maxn], nxtR[maxn];\nchar s[maxn];\nvi e[maxn], eR[maxn], vec[maxn];\nint st[maxn], ed[maxn], idx;\nvoid dfs(int u) {\n    st[u] = ++idx;\n    for (int v : eR[u]) dfs(v);\n    ed[u] = idx;\n}\nvoid dfs2(int u) {\n    if (u && u <= n - 1) tr.add(st[u + 1], ed[u + 1], 1);\n    for (int i : vec[u])\n        ans[i] += tr.ask(st[n - b[i].sec + 1]);\n    for (int v : e[u]) dfs2(v);\n    if (u && u <= n - 1) tr.add(st[u + 1], ed[u + 1], -1);\n}\nvoid work(string &Str, vi &Vec) {\n    n = Str.size();\n    fill(s, s + n * 2 + 1, 0);\n    for (int i = 1; i <= n; ++i) s[i] = Str[i - 1];\n\n    nxt[1] = 0;\n    for (int i = 2, j = 0; i <= n; ++i) {\n        while (j && s[j + 1] != s[i]) j = nxt[j];\n        if (s[j + 1] == s[i]) ++j;\n        nxt[i] = j;\n    }\n    nxtR[n] = n + 1;\n    for (int i = n - 1, j = n + 1; i >= 1; --i) {\n        while (j <= n && s[j - 1] != s[i]) j = nxtR[j];\n        if (s[j - 1] == s[i]) --j;\n        nxtR[i] = j;\n    }\n\n    for (int i = 0; i <= n + 1; ++i) e[i].clear(), eR[i].clear(), vec[i].clear();\n    for (int i = 1; i <= n; ++i) e[nxt[i]].push_back(i), eR[nxtR[i]].push_back(i);\n    for (int i : Vec) if (b[i].fir && b[i].sec) vec[b[i].fir].push_back(i);\n    idx = 0, dfs(n + 1);\n    tr.init(idx), dfs2(0);\n}\n}\n\nvi vec[maxn];\nvoid work() {\n    prework();\n    for (int i = 1; i <= q; ++i) vec[a[i].p].push_back(i);\n    for (int i = 1; i <= m; ++i) SA::work(rev(s[i]), vec[i]);\n    for (int i = 1; i <= q; ++i) swap(b[i].fir, b[i].sec), swap(a[i].x, a[i].y);\n    for (int i = 1; i <= m; ++i) SA::work(s[i], vec[i]);\n    for (int i = 1; i <= q; ++i) swap(b[i].fir, b[i].sec), swap(a[i].x, a[i].y);\n    for (int i = 1; i <= m; ++i) KMP::work(s[i], vec[i]);\n}\n}\n\nint main() {\n    cin >> n >> m >> q;\n    for (int i = 1; i < n; ++i) {\n        int u, v; char ch;\n        cin >> u >> v >> ch;\n        Tree::add(u, v, ch - 'a');\n    }\n    Tree::build();\n    for (int i = 1; i <= m; ++i) cin >> s[i];\n    for (int i = 1; i <= q; ++i) {\n        cin >> a[i].x >> a[i].y >> a[i].p;\n        a[i].z = Tree::lca(a[i].x, a[i].y);\n    }\n\n    Solve1::work();\n    Solve2::work();\n\n    for (int i = 1; i <= q; ++i) cout << ans[i] << endl;\n    return 0;\n}\n \t\t \t  \t\t\t\t\t\t \t\t     \t \t \t\t\t  \t"
}