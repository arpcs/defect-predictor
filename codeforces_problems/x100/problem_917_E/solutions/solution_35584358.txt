{
    "id": 35584358,
    "contestId": 917,
    "creationTimeSeconds": 1519336588,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "sehun01"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1403,
    "memoryConsumedBytes": 347955200,
    "source": "//This problem was solved by Salem Fradi\r\n//at 22:56 22/02/2018\r\n#include<bits/stdc++.h>\r\n#define N 200005\r\nusing namespace std;\r\nint n,m,q,len[N];char s[N];\r\nint Nxt[N],Fst[N],Ans[N];//query\r\nint used[N*2],to[N*2],nxt[N*2],str[N*2],fst[N],l=1;//edge\r\nstruct T\r\n{\r\n\tint x,y,p;\r\n}Q[N],Q0[N];//query\r\nint sz[N],Mx[N],blg[N];\r\nstruct ACatm\r\n{\r\n\tint c[N][26],fail[N],cnt,id[N];\r\n\tint s[N][26],st[N],ed[N],ly;\r\n\tint q[N];\r\n\tvector<int>v[N];\r\n\tvoid clr()\r\n\t{\r\n\t\tcnt=1;\r\n\t}\r\n\tvoid add(char s[],int len,int k)\r\n\t{\r\n\t\tint now=1;\r\n\t\tfor (int i=0;i<len;i++)\r\n\t\t{\r\n\t\t\tif (!c[now][s[i]-'a']) c[now][s[i]-'a']=++cnt;\r\n\t\t\tnow=c[now][s[i]-'a'];\r\n\t\t}\r\n\t\tid[k]=now;\r\n\t\t/**/\r\n\t}\r\n\tvoid dfs(int x)\r\n\t{\r\n\t\tst[x]=++ly;\r\n\t\tfor (int i=0;i<v[x].size();i++)\r\n\t\t\tdfs(v[x][i]);\r\n\t\ted[x]=ly;\r\n\t}\r\n\tvoid build()\r\n\t{\r\n\t\tfor (int i=0;i<26;i++)\r\n\t\t\tc[0][i]=1;\r\n\t\tint l=0,r=1;\r\n\t\tq[1]=1;//fail[1]=0;\r\n\t\twhile(l<r)\r\n\t\t{\r\n\t\t\tint x=q[++l];\r\n\t\t\tfor (int i=0;i<26;i++)\r\n\t\t\t\tif (c[x][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tq[++r]=c[x][i];\r\n\t\t\t\t\tfail[c[x][i]]=c[fail[x]][i];\r\n\t\t\t\t}\r\n\t\t\t\telse c[x][i]=c[fail[x]][i];\r\n\t\t}\r\n\t\tfor (int i=2;i<=cnt;i++)\r\n\t\t\tv[fail[i]].push_back(i);\r\n\t\tdfs(1);\r\n/*\r\n\t\tputs(\"=====\");\r\n\t\tfor (int i=1;i<=cnt;i++)\r\n\t\t{\r\n\r\n\t\t\tprintf(\"%d----%d  %d-%d\\n\",i,fail[i],st[i],ed[i]);\r\n\t\t}\r\n*/\r\n\t}\r\n\r\n\tint val[N*4];\r\n\tvoid add(int k,int l,int r,int x,int y)\r\n\t{\r\n\t\tval[k]+=y;\r\n\t\tif (l==r) return;\r\n\t\tint mid=l+r>>1;\r\n\t\tif (x<=mid) add(k<<1,l,mid,x,y);\r\n\t\telse add(k<<1|1,mid+1,r,x,y);\r\n\t}\r\n\tint qry(int k,int l,int r,int x,int y)\r\n\t{\r\n\t\tif (x<=l&&r<=y) return val[k];\r\n\t\tint mid=l+r>>1,ans=0;\r\n\t\tif (x<=mid) ans+=qry(k<<1,l,mid,x,y);\r\n\t\tif (y>mid) ans+=qry(k<<1|1,mid+1,r,x,y);\r\n\t\treturn ans;\r\n\t}\r\n\tvoid add(int x,int y)\r\n\t{\r\n\t\t//x+=y\r\n\t\t//cerr<<st[x]<<\"***\"<<y<<endl;\r\n\t\tadd(1,1,cnt,st[x],y);\r\n\t}\r\n\tint qry(int x)\r\n\t{\r\n\t\tx=id[x];\r\n\t\t//cerr<<x<<endl;\r\n\t\t//cerr<<st[x]<<' '<<ed[x]<<endl;\r\n\t\treturn qry(1,1,cnt,st[x],ed[x]);\r\n\t}\r\n}A1,A2;\r\nstruct S\r\n{\r\n\tint x,y,flag;\r\n}newS=(S){1,0,0};\r\nstruct SAM\r\n{\r\n\tint F[N*2],st[N*2],c[N*2][26],cnt;\r\n\tint pos[N*2],str[N],ly,s[N*2][26];\r\n\tvector<int>v[N];\r\n\tint stt[N*2],ed[N*2],hz;\r\n\tvoid clr()\r\n\t{\r\n\t\tcnt=1;\r\n\t}\r\n\tint add(int p,int x,int y)\r\n\t{\r\n\t\tint q,np,nq;\r\n\t\tif (c[p][x]&&st[c[p][x]]==st[p]+1)\r\n\t\t\treturn c[p][x];\r\n\t\tst[np=++cnt]=st[p]+1;pos[np]=y;\r\n\t\twhile(p&&!c[p][x]) c[p][x]=np,p=F[p];\r\n\t\tif (!p) F[np]=1;\r\n\t\telse if (st[p]+1==st[q=c[p][x]]) F[np]=q;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (st[np]==st[p]+1)\r\n\t\t\t{\r\n\t\t\t\tnq=np;st[nq]=st[p]+1;\r\n\t\t\t\tfor (int i=0;i<26;i++) c[nq][i]=c[q][i];\r\n\t\t\t\tF[nq]=F[q];F[q]=nq;\r\n\t\t\t\twhile(p&&c[p][x]==q) c[p][x]=nq,p=F[p];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tst[nq=++cnt]=st[p]+1;pos[nq]=pos[q];\r\n\t\t\t\tfor (int i=0;i<26;i++) c[nq][i]=c[q][i];\r\n\t\t\t\tF[nq]=F[q];F[q]=F[np]=nq;\r\n\t\t\t\twhile(p&&c[p][x]==q) c[p][x]=nq,p=F[p];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn np;\r\n\t}\r\n\tvoid add(char s[],int len,int k)\r\n\t{\r\n\t\tint now=1;\r\n\t\tfor (int i=0;i<len;i++)\r\n\t\t{\r\n\t\t\tstr[++ly]=s[i]-'a';\r\n\t\t\tnow=add(now,s[i]-'a',ly);\r\n\t\t}/*\r\n\t\tputs(\"-------\");\r\n\t\tfor (int i=1;i<=cnt;i++)\r\n\t\t\tprintf(\"%d  %d %d %d %d\\n\",i,F[i],st[i],c[i][0],c[i][1]);*/\r\n\t}\r\n\tvoid dfs(int x)\r\n\t{\r\n\t\t//cerr<<x<<endl;\r\n\t\tstt[x]=++hz;\r\n\t\tfor (int i=0;i<v[x].size();i++)\r\n\t\t\tdfs(v[x][i]);\r\n\t\ted[x]=hz;\r\n\t}\r\n\tvoid build()\r\n\t{\r\n\t\t/*suffix tree*/\r\n\t\tfor (int i=2;i<=cnt;i++)\r\n\t\t{\r\n\t\t\t//cerr<<i<<' '<<F[i]<<' '<<str[pos[i]-st[i]+1]<<endl;\r\n\t\t\tpos[i]=pos[i]-st[F[i]];\r\n\t\t\ts[F[i]][str[pos[i]]]=i;\r\n\t\t\tv[F[i]].push_back(i);\r\n\t\t}\r\n\t\tdfs(1);\r\n/*\r\n\t\tputs(\"=============\");\r\n\t\tfor (int i=1;i<=ly;i++)\r\n\t\t\tputchar(str[i]+'a');\r\n\t\tputs(\"\");\r\n\t\tfor (int i=1;i<=cnt;i++)\r\n\t\t{\r\n\t\t\tprintf(\"%d    %d %d %c\\n\",i,F[i],st[i],str[pos[i]]+'a');\r\n\t\t}\r\n*/\r\n\t}\r\n\tS Get(S x,int y)\r\n\t{\r\n\t\tif (x.flag==1) return x;\r\n\t\tif (x.y==0)\r\n\t\t{\r\n\t\t\t//cerr<<s[x.x][y]<<endl;\r\n\t\t\tif (!s[x.x][y]) x.flag=1;\r\n\t\t\telse x.x=s[x.x][y],x.y=st[x.x]-st[F[x.x]]-1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (str[pos[x.x]-(st[x.x]-st[F[x.x]])+x.y]!=y) x.flag=1;\r\n\t\t\telse x.y--;\r\n\t\t}\r\n\t\treturn x;\r\n\t}\r\n}S1,S2;\r\nvoid link(int x,int y,int z)\r\n{\r\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;str[l]=z;\r\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;str[l]=z;\r\n}\r\nvoid Dfs(int x,int f)\r\n{\r\n\tsz[x]=1;Mx[x]=0;\r\n\tfor (int i=fst[x];i;i=nxt[i])\r\n\tif (!used[i]&&to[i]!=f)\r\n\t{\r\n\t\tDfs(to[i],x);\r\n\t\tsz[x]+=sz[to[i]];\r\n\t\tMx[x]=max(Mx[x],sz[to[i]]);\r\n\t}\r\n}\r\nvoid GetG(int x,int f,int &G,int size)\r\n{\r\n\tif (max(Mx[x],size-sz[x])<max(Mx[G],size-sz[G])) G=x;\r\n\tfor (int i=fst[x];i;i=nxt[i])\r\n\t\tif (!used[i]&&to[i]!=f) GetG(to[i],x,G,size);\r\n}\r\nvoid dfs(int x,int f,int y)\r\n{\r\n\tblg[x]=y;\r\n\tfor (int i=fst[x];i;i=nxt[i])\r\n\t\tif (!used[i]&&to[i]!=f)\r\n\t\t\tdfs(to[i],x,y);\r\n}\r\nint FST[N],NXT[N*2];//qry on ACatm\r\nvoid work(int x,int n1,int n2,S m1,S m2,int f)\r\n{\r\n\t//cerr<<x<<endl;\r\n\t//cerr<<x<<' '<<n1<<' '<<n2<<endl;\r\n\tA1.add(n1,1);\r\n\tA2.add(n2,1);\r\n\r\n\tfor (int i=FST[x];i;i=NXT[i])\r\n\t{\r\n\t\t//cerr<<i<<endl;\r\n\t\tif (i&1)\r\n\t\t{\r\n\t\t\tAns[i/2]+=A1.qry(Q[i/2].p);\r\n\t\t\tQ0[i/2].y=m2.y?S2.F[m2.x]:m2.x;\r\n\t\t\t//cout<<\"x: \"<<Q0[i/2].x<<' '<<m1.x<<' '<<m1.y<<endl;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tAns[i/2]+=A2.qry(Q[i/2].p);\r\n\t\t\tQ0[i/2].x=m1.y?S1.F[m1.x]:m1.x;\r\n\t\t\t//cout<<\"y: \"<<Q0[i/2].y<<endl;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i=fst[x];i;i=nxt[i])\r\n\tif (!used[i]&&to[i]!=f)\r\n\t{\r\n\t\t//cerr<<(char)(str[i]+'a')<<endl;\r\n\t\twork(to[i],A1.c[n1][str[i]],A2.c[n2][str[i]],S1.Get(m1,str[i]),S2.Get(m2,str[i]),x);\r\n\t}\r\n\r\n\tA1.add(n1,-1);\r\n\tA2.add(n2,-1);\r\n}\r\nvoid clrFST(int x,int f)\r\n{\r\n\tFST[x]=0;\r\n\tfor (int i=fst[x];i;i=nxt[i])\r\n\t\tif (!used[i]&&to[i]!=f)\r\n\t\t\tclrFST(to[i],x);\r\n}\r\nvoid solve(int x)\r\n{\r\n\tint G=x;\r\n\tDfs(x,0);\r\n\tGetG(x,0,G,sz[x]);\r\n\t//cerr<<x<<\"   \"<<G<<endl;\r\n\r\n\tfor (int i=fst[G];i;i=nxt[i])\r\n\tif (!used[i])\r\n\t\tdfs(to[i],G,to[i]);\r\n\tswap(Fst[G],Fst[x]);\r\n\tfor (int i=Fst[G],tmp;i;i=tmp)\r\n\t{\r\n\t\t//cerr<<\"ok \"<<i<<endl;\r\n\t\ttmp=Nxt[i];\r\n\t\tif (Q[i].x==G||Q[i].y==G)\r\n\t\t{\r\n\t\t\t//cerr<<\"Skipped: \"<<i<<endl;\r\n\t\t\tif (Q[i].x!=G) NXT[i*2]=FST[Q[i].x],FST[Q[i].x]=i*2;//A2\r\n\t\t\tif (Q[i].y!=G) NXT[i*2+1]=FST[Q[i].y],FST[Q[i].y]=i*2+1;//A1\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t//cerr<<blg[Q[i].x]<<' '<<blg[Q[i].y]<<endl;\r\n\t\tif (blg[Q[i].x]==blg[Q[i].y])\r\n\t\t{\r\n\t\t\t//cerr<<blg[Q[i].x]<<endl;\r\n\t\t\tNxt[i]=Fst[blg[Q[i].x]];\r\n\t\t\tFst[blg[Q[i].x]]=i;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t/*calc*/\r\n\t\t\t//cerr<<G<<\"--\"<<i<<endl;\r\n\t\t\tNXT[i*2]=FST[Q[i].x];FST[Q[i].x]=i*2;//A2\r\n\t\t\tNXT[i*2+1]=FST[Q[i].y];FST[Q[i].y]=i*2+1;//A1\r\n\r\n\t\t\t/**/\r\n\t\t}\r\n\t}\r\n\t/*dfs*/\r\n\twork(G,1,1,newS,newS,0);\r\n\t/*clear FST*/\r\n\tclrFST(G,0);\r\n\t//return;\r\n\r\n\tfor (int i=fst[G];i;i=nxt[i])\r\n\tif (!used[i])\r\n\t{\r\n\t\tused[i]=used[i^1]=1;\r\n\t\tsolve(to[i]);\r\n\t}\r\n}\r\nstruct Md\r\n{\r\n\tint x,l,r,p;\r\n}md[N*2];\r\nbool operator<(T a,T b){return a.x<b.x;}\r\nbool operator<(Md a,Md b){return a.x<b.x;}\r\nvector<T>v[N];\r\nint val[N*8];\r\nvoid mdy(int k,int l,int r,int x,int y,int p)\r\n{\r\n\tif (x<=l&&r<=y)\r\n\t{\r\n\t\tval[k]+=p;\r\n\t\treturn;\r\n\t}\r\n\tint mid=l+r>>1;\r\n\tif (x<=mid) mdy(k<<1,l,mid,x,y,p);\r\n\tif (y>mid) mdy(k<<1|1,mid+1,r,x,y,p);\r\n}\r\nint qry(int k,int l,int r,int x)\r\n{\r\n\tif (l==r) return val[k];\r\n\tint mid=l+r>>1;\r\n\tif (x<=mid) return val[k]+qry(k<<1,l,mid,x);\r\n\treturn val[k]+qry(k<<1|1,mid+1,r,x);\r\n}\r\nint main()\r\n{\r\n\tscanf(\"%d%d%d\",&n,&m,&q);\r\n\tfor (int i=1;i<n;i++)\r\n\t{\r\n\t\tint x,y;\r\n\t\tscanf(\"%d%d%s\",&x,&y,s);\r\n\t\tlink(x,y,s[0]-'a');\r\n\t}\r\n\r\n\tint sta[N],ly=0,strr[N];\r\n\t/**/\r\n\tA1.clr();S1.clr();\r\n\tA2.clr();S2.clr();\r\n\r\n\tfor (int i=1;i<=m;i++)\r\n\t{\r\n\t\tscanf(\"%s\",s);\r\n\r\n\t\tlen[i]=strlen(s);\r\n\r\n\t\tsta[i]=ly+1;\r\n\t\tfor (int j=0;j<len[i];j++)\r\n\t\tstrr[++ly]=s[j]-'a';\r\n\r\n\t\t/*add to SAM*/\r\n\t\tS1.add(s,len[i],i);\r\n\t\t/*add to ACatm*/\r\n\t\tA1.add(s,len[i],i);\r\n\r\n\t\treverse(s,s+len[i]);\r\n\t\t/*add to SAM*/\r\n\t\tS2.add(s,len[i],i);\r\n\t\t/*add to ACatm*/\r\n\t\tA2.add(s,len[i],i);\r\n\r\n\r\n\t}\r\n\r\n\tA1.build();S1.build();\r\n\t//return 0;\r\n\tA2.build();S2.build();\r\n\r\n\tfor (int i=1;i<=q;i++)\r\n\t{\r\n\t\tscanf(\"%d%d%d\",&Q[i].x,&Q[i].y,&Q[i].p);\r\n\t\tNxt[i]=i-1;\r\n\t}\r\n\tFst[1]=q;\r\n\r\n\tsolve(1);\r\n/*\r\n\tfor (int i=1;i<=q;i++)\r\n\t\tprintf(\"%d    %d %d\\n\",Ans[i],S1.stt[Q0[i].x],S2.stt[Q0[i].y]);\r\n*/\r\n\t//puts(\"------------------\");\r\n\t/*calc on suffix tree*/\r\n\tfor (int i=1;i<=q;i++)\r\n\t{\r\n\t\t//swap(Q0[i].x,Q0[i].y);\r\n\t\tif (S1.stt[Q0[i].x]&&S2.stt[Q0[i].y])\r\n\t\t\tv[Q[i].p].push_back((T){S1.stt[Q0[i].x],S2.stt[Q0[i].y],i});\r\n\t}\r\n\tint tmpx[N],tmpy[N];\r\n\tfor (int i=1;i<=m;i++)\r\n\t{\r\n\t\tint m1=1,m2=1;\r\n\t\tfor (int j=0;j<len[i];j++)\r\n\t\t{\r\n\t\t\tm1=S1.c[m1][strr[sta[i]+j]];\r\n\t\t\ttmpx[j+1]=m1;\r\n\t\t}\r\n\t\tfor (int j=len[i]-1;j>=0;j--)\r\n\t\t{\r\n\t\t\tm2=S2.c[m2][strr[sta[i]+j]];\r\n\t\t\ttmpy[j]=m2;\r\n\t\t}\r\n\t\tint ly=0;\r\n\t\t//puts(\"ok\");\r\n\t\tmd[++ly]=(Md){0,1,S2.cnt,0};\r\n\t\tmd[++ly]=(Md){S1.cnt+1,1,S2.cnt,0};\r\n\t\t//cerr<<i<<endl;\r\n\t\tfor (int j=1;j<len[i];j++)\r\n\t\t{\r\n\t\t\tmd[++ly]=(Md){S1.stt[tmpx[j]],S2.stt[tmpy[j]],S2.ed[tmpy[j]],1};\r\n\t\t\tmd[++ly]=(Md){S1.ed[tmpx[j]]+1,S2.stt[tmpy[j]],S2.ed[tmpy[j]],-1};\r\n//\t\tcerr<<i<<\"  ---  \"<<S1.stt[tmpx[j]]<<' '<<S1.ed[tmpx[j]]<<' '<<S2.stt[tmpy[j]]<<' '<<S2.ed[tmpy[j]]<<endl;\r\n\t\t}\r\n\t\tsort(md+1,md+ly+1);\r\n\t\tsort(v[i].begin(),v[i].end());\r\n\t\tfor (int j=1,k=0;j<=ly;)\r\n\t\t{\r\n\t\t\tint tmp=md[j].x;\r\n\t\t\twhile(k<v[i].size()&&v[i][k].x<tmp)\r\n\t\t\t\tAns[v[i][k].p]+=qry(1,1,S2.cnt,v[i][k].y),k++;\r\n\t\t\twhile(j<=ly&&md[j].x==tmp)\r\n\t\t\t\tmdy(1,1,S2.cnt,md[j].l,md[j].r,md[j].p),j++;\r\n\t\t}\r\n\t}\r\n\tfor (int i=1;i<=q;i++)\r\n\t{\r\n\t\tprintf(\"%d\\n\",Ans[i]);\r\n\t\t//printf(\"%d    %d %d\\n\",Ans[i],S1.stt[Q0[i].x],S2.stt[Q0[i].y]);\r\n\r\n\t}\r\n\t//cerr<<\"QAQ: \"<<newS.x<<' '<<newS.y<<' '<<newS.flag<<endl;\r\n\t//cerr<<S1.Get(newS,0).x;\r\n}"
}