{
    "id": 43671544,
    "contestId": 917,
    "creationTimeSeconds": 1538456318,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "ohweonfire"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 116,
    "timeConsumedMillis": 1730,
    "memoryConsumedBytes": 373760000,
    "source": "// This amazing code is by Eric Sunli Chen.\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\ntemplate<typename T> bool get_int(T &x)\r\n{\r\n\tchar t=getchar();\r\n\tbool neg=false;\r\n\tx=0;\r\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\r\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\r\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\r\n\tif(neg)x=-x;return true;\r\n}\r\ntemplate<typename T> void print_int(T x)\r\n{\r\n\tif(x<0)putchar('-'),x=-x;\r\n\tshort a[20]= {},sz=0;\r\n\twhile(x>0)a[sz++]=x%10,x/=10;\r\n\tif(sz==0)putchar('0');\r\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\r\n}\r\n#define ff first\r\n#define ss second\r\n#define pb push_back\r\n#define mp make_pair\r\n#define get1(a) get_int(a)\r\n#define get2(a,b) (get1(a)&&get1(b))\r\n#define get3(a,b,c) (get1(a)&&get2(b,c))\r\n#define printendl(a) print_int(a),puts(\"\")\r\ntypedef long long LL;\r\ntypedef unsigned long long uLL;\r\ntypedef pair<int,int> pii;\r\nconst int inf=0x3f3f3f3f;\r\nconst LL Linf=1ll<<61;\r\nconst double pi=acos(-1.0);\r\n\r\nconst int maxn=100111;\r\nconst int maxv=2000111;\r\nconst int base=443;\r\nconst int mod=1e9+7;\r\n\r\nint power[maxn];\r\n\r\nint ans[maxn];\r\nnamespace kmp\r\n{\r\n\tvector<int>qs[maxn];\r\n\tint t1[maxn],t2[maxn];\r\n\tint addq(int id,int k,int l1,int l2){t1[id]=l1;t2[id]=l2;qs[k].pb(id);}\r\n\t\r\n\tint nxt[maxn],link[maxn],rnxt[maxn],rlink[maxn],s[maxn],n;\r\n\t\r\n\tvoid construct(int*nxt,int*link)\r\n\t{\r\n\t\tnxt[1]=0;\r\n\t\tfor(int i=2;i<=n;i++)\r\n\t\t{\r\n\t\t\tnxt[i]=nxt[i-1];\r\n\t\t\twhile(nxt[i]&&s[nxt[i]+1]!=s[i])nxt[i]=nxt[nxt[i]];\r\n\t\t\tif(s[nxt[i]+1]==s[i])nxt[i]++;\r\n\t\t\tif(i-nxt[i]==nxt[i]-nxt[nxt[i]])link[i]=link[nxt[i]];\r\n\t\t\telse link[i]=nxt[i];\r\n\t\t}\r\n\t}\r\n\t\r\n\tint inter(const pair<int,pii>&a,const pair<int,pii>&b)\r\n\t{\r\n\t\tif(a.ff==b.ff)\r\n\t\t{\r\n\t\t\tif((a.ss.ff-b.ss.ff)%a.ff!=0)return 0;\r\n\t\t\tint st=max(a.ss.ff,b.ss.ff),ed=min(a.ss.ss,b.ss.ss);\r\n\t\t\tif(st>ed)return 0;\r\n\t\t\treturn (ed-st)/a.ff+1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint sz1=(a.ss.ss-a.ss.ff)/a.ff+1,sz2=(b.ss.ss-b.ss.ff)/b.ff+1,ret=0;\r\n\t\t\tif(sz1<sz2)\r\n\t\t\t{\r\n\t\t\t\tfor(int t=a.ss.ff;t<=a.ss.ss;t+=a.ff)\r\n\t\t\t\t\tret+=(t>=b.ss.ff&&t<=b.ss.ss&&(t-b.ss.ff)%b.ff==0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor(int t=b.ss.ff;t<=b.ss.ss;t+=b.ff)\r\n\t\t\t\t\tret+=(t>=a.ss.ff&&t<=a.ss.ss&&(t-a.ss.ff)%a.ff==0);\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid solve(int k,const vector<int>&ch)\r\n\t{\r\n\t\tn=(int)ch.size();\r\n\t\tfor(int i=0;i<n;i++)s[i+1]=ch[i];\r\n\t\tconstruct(nxt,link);reverse(s+1,s+n+1);construct(rnxt,rlink);\r\n\t\tfor(auto&i:qs[k])\r\n\t\t{\r\n\t\t\tvector<pair<int,pii> >v1,v2;\r\n\t\t\tint t,st,ed,d;\r\n\t\t\t\r\n\t\t\tt=t1[i];\r\n\t\t\twhile(t)\r\n\t\t\t{\r\n\t\t\t\td=t-nxt[t];ed=t;st=link[t]+d;\r\n\t\t\t\tv1.pb(mp(d,mp(st,ed)));\r\n\t\t\t\tt=link[t];\r\n\t\t\t}\r\n\t\t\treverse(v1.begin(),v1.end());\r\n\t\t\t\r\n\t\t\tt=t2[i];\r\n\t\t\twhile(t)\r\n\t\t\t{\r\n\t\t\t\td=t-rnxt[t];ed=t;st=rlink[t]+d;\r\n\t\t\t\tv2.pb(mp(d,mp(n-ed,n-st)));\r\n\t\t\t\tt=rlink[t];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tint it1=0,it2=0;\r\n\t\t\twhile(it1<(int)v1.size()&&it2<(int)v2.size())\r\n\t\t\t{\r\n\t\t\t\tans[i]+=inter(v1[it1],v2[it2]);\r\n\t\t\t\tif(v1[it1].ss.ss<v2[it2].ss.ss)it1++;\r\n\t\t\t\telse it2++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nint bit[maxv],vpos[maxn<<1],ltot;\r\npii lpos[maxn<<1];\r\nvoid add(int x,const int&v){for(;x<maxv;x+=x&-x)bit[x]+=v;}\r\nint query(int x){int ret=0;for(;x;x-=x&-x)ret+=bit[x];return ret;}\r\n\r\nnamespace ac\r\n{\r\n\tint go[maxv][26],tot=1,rt=1;\r\n\t\r\n\tint q[maxv],fail[maxv],dfn[maxv],edfn[maxv],timer;\r\n\tvector<int> g[maxv];\r\n\t\r\n\tvector<pii> qs1[maxv],qs2[maxv];\r\n\t\r\n\tint ans2[maxn<<1];\r\n\tvoid addq(int id,int p1,int p2,int k1,int k2)\r\n\t{\r\n\t\tqs1[p1].pb(mp(id,k2));qs1[p2].pb(mp(id,k1));\r\n\t\tqs2[p1].pb(mp(id<<1,k1));qs2[p2].pb(mp(id<<1|1,k2));\r\n\t}\r\n\t\r\n\tint len[maxn<<1];\r\n\tvoid dfs(int x,int dep,int hs)\r\n\t{\r\n\t\tadd(dfn[x],1);\r\n\t\tvector<pii> mem;\r\n\t\tint id=lower_bound(lpos+1,lpos+ltot+1,mp(hs,0))-lpos;\r\n\t\tfor(;id<=ltot&&lpos[id].ff==hs;id++)\r\n\t\t{\r\n\t\t\tmem.pb(mp(lpos[id].ss,len[lpos[id].ss]));\r\n\t\t\tlen[lpos[id].ss]=dep;\r\n\t\t}\r\n\t\t\r\n\t\tfor(auto&q:qs1[x])ans[q.ff]+=query(edfn[vpos[q.ss]])-query(dfn[vpos[q.ss]]-1);\r\n\t\tfor(auto&q:qs2[x])ans2[q.ff]=len[q.ss];\r\n\t\t\r\n\t\tfor(int i=0;i<26;i++)if(go[x][i])\r\n\t\t\tdfs(go[x][i],dep+1,(hs+(LL)power[dep]*(i+1))%mod);\r\n\t\t\t\r\n\t\tadd(dfn[x],-1);\r\n\t\tfor(auto&v:mem)len[v.ff]=v.ss;\r\n\t}\r\n\t\r\n\tvoid rdfs(int x)\r\n\t{\r\n\t\tdfn[x]=++timer;\r\n\t\tfor(auto&v:g[x])rdfs(v);\r\n\t\tedfn[x]=timer;\r\n\t}\r\n\t\r\n\tvoid construct()\r\n\t{\r\n\t\tint fr=0,rr=0,x;q[rr++]=rt;\r\n\t\tfail[rt]=rt;\r\n\t\tfor(;fr<rr;fr++)\r\n\t\t{\r\n\t\t\tx=q[fr];\r\n\t\t\tfor(int i=0;i<26;i++)if(go[x][i])\r\n\t\t\t{\r\n\t\t\t\tif(x==rt)fail[go[x][i]]=x;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tint&f=fail[go[x][i]];\r\n\t\t\t\t\tf=fail[x];while(f!=rt&&!go[f][i])f=fail[f];\r\n\t\t\t\t\tif(go[f][i])f=go[f][i];\r\n\t\t\t\t}\r\n\t\t\t\tq[rr++]=go[x][i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvoid solve()\r\n\t{\r\n\t\tfor(int i=2;i<=tot;i++)g[fail[i]].pb(i);\r\n\t\trdfs(rt);\r\n\t\tdfs(rt,0,0);\r\n\t}\r\n};\r\n\r\nint head[maxn],nxt[maxn<<1],to[maxn<<1],sv[maxn<<1],etot=1;\r\nvoid addedge(int u,int v,int w)\r\n{\r\n\tnxt[++etot]=head[u];head[u]=etot;\r\n\tto[etot]=v;sv[etot]=w;\r\n}\r\n\r\nbool useR[maxn];\r\nint sz[maxn],sub[maxn],pos[maxn],tot,seq[maxn],mark[maxn],timer;\r\n\r\nvoid rdfs(int x,int fa)\r\n{\r\n\tseq[++tot]=x;sz[x]=1;mark[x]=timer;\r\n\tfor(int i=head[x];i;i=nxt[i])if(!useR[to[i]]&&to[i]!=fa)\r\n\t{\r\n\t\trdfs(to[i],x);\r\n\t\tsz[x]+=sz[to[i]];\r\n\t}\r\n}\r\nint getroot(int x)\r\n{\r\n\ttimer++;\r\n\ttot=0;rdfs(x,0);\r\n\tint ret=0;\r\n\tfor(int i=1;i<=tot;i++)if((sz[seq[i]]<<1)>=tot&&(ret==0||sz[ret]>sz[seq[i]]))\r\n\t\tret=seq[i];\r\n\treturn ret;\r\n}\r\n\r\nvoid dfs(int x,int fa,int insub,int cur)\r\n{\r\n\tsub[x]=insub;pos[x]=cur;\r\n\tfor(int i=head[x];i;i=nxt[i])if(!useR[to[i]]&&to[i]!=fa)\r\n\t{\r\n\t\tif(!ac::go[cur][sv[i]])ac::go[cur][sv[i]]=++ac::tot;\r\n\t\tdfs(to[i],x,fa==0?to[i]:insub,ac::go[cur][sv[i]]);\r\n\t}\r\n}\r\n\r\nvector<int> qs[maxn];\r\nint n,m,q,q1[maxn],q2[maxn],qk[maxn];\r\n\r\nvoid solve(int x)\r\n{\r\n\tx=getroot(x);\r\n\t\r\n\tdfs(x,0,x,ac::rt);\r\n\t\r\n\tfor(int _=1;_<=tot;_++)\r\n\t{\r\n\t\tint v=seq[_];\r\n\t\tfor(auto&i:qs[v])if(mark[q1[i]]==timer&&mark[q2[i]]==timer&&sub[q1[i]]!=sub[q2[i]])\r\n\t\t\tac::addq(i,pos[q1[i]],pos[q2[i]],qk[i],qk[i]+m);\r\n\t}\r\n\t\r\n\tuseR[x]=1;\r\n\tfor(int i=head[x];i;i=nxt[i])if(!useR[to[i]])solve(to[i]);\r\n}\r\n\r\nvector<int> ch[maxn];\r\nchar s[maxn];\r\n\r\nint main()\r\n{\r\n\tpower[0]=1;for(int i=1;i<maxn;i++)power[i]=(LL)power[i-1]*base%mod;\r\n\t\r\n\tget3(n,m,q);\r\n\tfor(int i=1,u,v;i<n;i++)\r\n\t{\r\n\t\tget2(u,v);scanf(\"%s\",s);\r\n\t\taddedge(u,v,s[0]-'a');\r\n\t\taddedge(v,u,s[0]-'a');\r\n\t}\r\n\tfor(int i=1;i<=m;i++)\r\n\t{\r\n\t\tscanf(\"%s\",s);\r\n\t\tfor(int j=0;s[j];j++)ch[i].pb(s[j]-'a');\r\n\t}\r\n\t\r\n\tfor(int i=1;i<=q;i++)\r\n\t{\r\n\t\tget3(q1[i],q2[i],qk[i]);\r\n\t\tqs[q1[i]].pb(i);\r\n\t}\r\n\t\r\n\tsolve(1);\r\n\t\r\n\tfor(int i=1;i<=m;i++)\r\n\t{\r\n\t\tint sz=(int)ch[i].size(),cur,hs;\r\n\t\t\r\n\t\tcur=ac::rt;hs=0;\r\n\t\tfor(int j=0;j<sz;j++)\r\n\t\t{\r\n\t\t\tif(ac::go[cur][ch[i][j]]==0)ac::go[cur][ch[i][j]]=++ac::tot;\r\n\t\t\tcur=ac::go[cur][ch[i][j]];\r\n\t\t\ths=((LL)hs*base+ch[i][j]+1)%mod;\r\n\t\t\tif(j<sz-1)lpos[++ltot]=mp(hs,i);\r\n\t\t}\r\n\t\tvpos[i]=cur;\r\n\t\t\r\n\t\tcur=ac::rt;hs=0;\r\n\t\tfor(int j=sz-1;j>=0;j--)\r\n\t\t{\r\n\t\t\tif(ac::go[cur][ch[i][j]]==0)ac::go[cur][ch[i][j]]=++ac::tot;\r\n\t\t\tcur=ac::go[cur][ch[i][j]];\r\n\t\t\ths=((LL)hs*base+ch[i][j]+1)%mod;\r\n\t\t\tif(j>0)lpos[++ltot]=mp(hs,i+m);\r\n\t\t}\r\n\t\tvpos[i+m]=cur;\r\n\t}\r\n\t\r\n\tac::construct();\r\n\tsort(lpos+1,lpos+ltot+1);\r\n\tac::solve();\r\n\t\r\n\tfor(int i=1;i<=q;i++)if(ac::ans2[i<<1]&&ac::ans2[i<<1|1])kmp::addq(i,qk[i],ac::ans2[i<<1],ac::ans2[i<<1|1]);\r\n\tfor(int i=1;i<=m;i++)kmp::solve(i,ch[i]);\r\n\t\r\n\tfor(int i=1;i<=q;i++)printf(\"%d\\n\",ans[i]);\r\n\t\r\n\treturn 0;\r\n}"
}