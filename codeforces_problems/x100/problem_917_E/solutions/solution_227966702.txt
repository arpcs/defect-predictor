{
    "id": 227966702,
    "contestId": 917,
    "creationTimeSeconds": 1697163497,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "luogu_bot4"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 2932,
    "memoryConsumedBytes": 349798400,
    "source": "// LUOGU_RID: 129048002\n#include <bits/stdc++.h>\r\n#define INF 1000000000\r\n#define LINF 1000000000000000000\r\n#define MOD 1000000007\r\n#define mod 998244353\r\n#define F first\r\n#define S second\r\n#define ll int\r\n#define N 100010\r\n#define M 400010\r\nusing namespace std;\r\nstruct SegT{\r\n\tll lo[M<<2],hi[M<<2];\r\n\tvector<ll> stk[M<<2];\r\n\tvoid build(ll x,ll l,ll r)\r\n\t{\r\n\t\tlo[x]=l,hi[x]=r;\r\n\t\tstk[x].clear();\r\n\t\tif(l==r)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tll mid=(l+r)>>1,a=x<<1;\r\n\t\tbuild(a,l,mid);\r\n\t\tbuild(a|1,mid+1,r);\r\n\t\treturn;\r\n\t}\r\n\tvoid update(ll x,ll l,ll r,ll v)\r\n\t{\r\n\t\tll tl=lo[x],tr=hi[x];\r\n\t\tif(l<=tl&&tr<=r)\r\n\t\t{\r\n\t\t\tstk[x].push_back(v);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tll mid=(tl+tr)>>1,a=x<<1;\r\n\t\tif(mid>=l)\r\n\t\t{\r\n\t\t\tupdate(a,l,r,v);\r\n\t\t}\r\n\t\tif(mid<r)\r\n\t\t{\r\n\t\t\tupdate(a|1,l,r,v);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tvoid recall(ll x,ll l,ll r)\r\n\t{\r\n\t\tll tl=lo[x],tr=hi[x];\r\n\t\tif(l<=tl&&tr<=r)\r\n\t\t{\r\n\t\t\tstk[x].pop_back();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tll mid=(tl+tr)>>1,a=x<<1;\r\n\t\tif(mid>=l)\r\n\t\t{\r\n\t\t\trecall(a,l,r);\r\n\t\t}\r\n\t\tif(mid<r)\r\n\t\t{\r\n\t\t\trecall(a|1,l,r);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tll query(ll x,ll l)\r\n\t{\r\n\t\tll tl=lo[x],tr=hi[x];\r\n\t\tll ret=(stk[x].empty()?0:stk[x].back());\r\n\t\tif(tl==tr)\r\n\t\t{\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\tll mid=(tl+tr)>>1,a=x<<1;\r\n\t\tif(mid>=l)\r\n\t\t{\r\n\t\t\tret=max(ret,query(a,l));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tret=max(ret,query(a|1,l));\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n}segt;\r\nstruct BIT{\r\n\tll val[M];\r\n\tvoid upd(ll x,ll v)\r\n\t{\r\n\t\t++x;\r\n\t\twhile(x<M)\r\n\t\t{\r\n\t\t\tval[x]+=v;\r\n\t\t\tx+=x&(-x);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tll qry(ll x)\r\n\t{\r\n\t\t++x;\r\n\t\tll ret=0;\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tret+=val[x];\r\n\t\t\tx-=x&(-x);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n}bit1,bit2;\r\nstruct AC_Automaton{\r\n\tll fail[N],trs[N][26],din[N],dout[N],dcnt,idx[N],tot;\r\n\tvector<ll> vt[N];\r\n\tvoid init()\r\n\t{\r\n\t\tmemset(fail,0,sizeof(fail));\r\n\t\tmemset(trs,0,sizeof(trs));\r\n\t\ttot=1;\r\n\t\treturn;\r\n\t}\r\n\tvoid ins(string s,ll id)\r\n\t{\r\n\t\tll cur=1,i;\r\n\t\tfor(i=0;i<s.size();i++)\r\n\t\t{\r\n\t\t\tif(trs[cur][s[i]-'a']==0)\r\n\t\t\t{\r\n\t\t\t\ttrs[cur][s[i]-'a']=++tot;\r\n\t\t\t}\r\n\t\t\tcur=trs[cur][s[i]-'a'];\r\n\t\t}\r\n\t\tidx[id]=cur;\r\n\t\treturn;\r\n\t}\r\n\tvoid dfs(ll x)\r\n\t{\r\n\t\tll i;\r\n\t\tdin[x]=++dcnt;\r\n\t\tfor(i=0;i<vt[x].size();i++)\r\n\t\t{\r\n\t\t\tdfs(vt[x][i]);\r\n\t\t}\r\n\t\tdout[x]=dcnt;\r\n\t\treturn;\r\n\t}\r\n\tvoid build()\r\n\t{\r\n\t\tll i,x;\r\n\t\tqueue<ll> q;\r\n\t\tfor(i=0;i<26;i++)\r\n\t\t{\r\n\t\t\tif(trs[1][i]>0)\r\n\t\t\t{\r\n\t\t\t\tfail[trs[1][i]]=1;\r\n\t\t\t\tq.push(trs[1][i]);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttrs[1][i]=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(!q.empty())\r\n\t\t{\r\n\t\t\tx=q.front();\r\n\t\t\tvt[fail[x]].push_back(x);\r\n\t\t\tq.pop();\r\n\t\t\tfor(i=0;i<26;i++)\r\n\t\t\t{\r\n\t\t\t\tif(trs[x][i]!=0)\r\n\t\t\t\t{\r\n\t\t\t\t\tfail[trs[x][i]]=trs[fail[x]][i];\r\n\t\t\t\t\tq.push(trs[x][i]);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttrs[x][i]=trs[fail[x]][i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tdcnt=0;\r\n\t\tdfs(1);\r\n\t\treturn;\r\n\t}\r\n}acam1,acam2;\r\nstruct SAM{\r\n\tll par[M],mx[M],lst,cnt,dcnt,din[M],dout[M];\r\n\tmap<ll,ll> trs[M];\r\n\tvector<ll> vt[M];\r\n\tvoid init()\r\n\t{\r\n\t\tlst=cnt=0;\r\n\t\tmemset(par,-1,sizeof(par));\r\n\t\tmemset(mx,0,sizeof(mx));\r\n\t\treturn;\r\n\t}\r\n\tll ins(ll i,ll c)\r\n\t{\r\n\t\tll j,ret;\r\n\t\tmx[++cnt]=mx[lst]+1;\r\n\t\tret=cnt;\r\n\t\tll p=lst,q,nq;\r\n\t\twhile(p!=-1)\r\n\t\t{\r\n\t\t\tif(trs[p].count(c))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\ttrs[p][c]=cnt;\r\n\t\t\tp=par[p];\r\n\t\t}\r\n\t\tlst=cnt;\r\n\t\tif(p==-1)\r\n\t\t{\r\n\t\t\tpar[cnt]=0;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\tq=trs[p][c];\r\n\t\tif(mx[q]==mx[p]+1)\r\n\t\t{\r\n\t\t\tpar[cnt]=q;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnq=cnt+1;\r\n\t\t\ttrs[nq]=trs[q];\r\n\t\t\tmx[nq]=mx[p]+1,par[nq]=par[q];\r\n\t\t\tpar[q]=par[cnt]=nq;\r\n\t\t\twhile(p!=-1)\r\n\t\t\t{\r\n\t\t\t\tif(trs[p][c]!=q)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\ttrs[p][c]=nq;\r\n\t\t\t\tp=par[p];\r\n\t\t\t}\r\n\t\t\t++cnt;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\tvoid dfs(ll x)\r\n\t{\r\n\t\tll i;\r\n\t\tdin[x]=++dcnt;\r\n\t\tfor(i=0;i<vt[x].size();i++)\r\n\t\t{\r\n\t\t\tdfs(vt[x][i]);\r\n\t\t}\r\n\t\tdout[x]=dcnt;\r\n\t\treturn;\r\n\t}\r\n\tvoid build()\r\n\t{\r\n\t\tll i;\r\n\t\tfor(i=0;i<=cnt;i++)\r\n\t\t{\r\n\t\t\tif(par[i]!=-1)\r\n\t\t\t{\r\n\t\t\t\tvt[par[i]].push_back(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdcnt=0;\r\n\t\tdfs(0);\r\n\t\treturn;\r\n\t}\r\n}sam1,sam2;\r\nll n,m,q,ans[N],sz[N],mxsz[N],bel[N],dcnt,din[N],dout[N];\r\nll lstid[N][2],acamid[N][2],samid[N][2],mxlen[N][2];\r\nbool iscent[N];\r\nstring s[N];\r\nvector<pair<pair<ll,ll>,ll> > qry[N],finq[N];\r\nvector<pair<ll,char> > vt[N];\r\nvector<pair<ll,ll> > ask1[N],ask2[N],qrys[N],upds[N],erzs[N];\r\nvector<ll> pth;\r\nvoid solveqry(vector<pair<pair<ll,ll>,pair<ll,ll> > > uu,vector<pair<pair<ll,ll>,ll> > qq)\r\n{\r\n\tll i,j;\r\n\tvector<ll> allv;\r\n\tfor(i=0;i<uu.size();i++)\r\n\t{\r\n\t\tallv.push_back(uu[i].F.F);\r\n\t\tallv.push_back(uu[i].F.S+1);\r\n\t}\r\n\tfor(i=0;i<qq.size();i++)\r\n\t{\r\n\t\tallv.push_back(qq[i].F.F);\r\n\t}\r\n\tsort(allv.begin(),allv.end());\r\n\tallv.erase(unique(allv.begin(),allv.end()),allv.end());\r\n\tfor(i=0;i<allv.size();i++)\r\n\t{\r\n\t\tupds[i].clear();\r\n\t\terzs[i].clear();\r\n\t\tqrys[i].clear();\r\n\t}\r\n\tfor(i=0;i<uu.size();i++)\r\n\t{\r\n\t\tupds[lower_bound(allv.begin(),allv.end(),uu[i].F.F)-allv.begin()].push_back(uu[i].S);\r\n\t\terzs[lower_bound(allv.begin(),allv.end(),uu[i].F.S+1)-allv.begin()].push_back(uu[i].S);\r\n\t}\r\n\tfor(i=0;i<qq.size();i++)\r\n\t{\r\n\t\tqrys[lower_bound(allv.begin(),allv.end(),qq[i].F.F)-allv.begin()].push_back(make_pair(qq[i].F.S,qq[i].S));\r\n\t}\r\n\tfor(i=0;i<allv.size();i++)\r\n\t{\r\n\t\tfor(j=0;j<upds[i].size();j++)\r\n\t\t{\r\n\t\t\tbit1.upd(upds[i][j].F,1);\r\n\t\t\tbit1.upd(upds[i][j].S+1,-1);\r\n\t\t}\r\n\t\tfor(j=0;j<erzs[i].size();j++)\r\n\t\t{\r\n\t\t\tbit1.upd(erzs[i][j].F,-1);\r\n\t\t\tbit1.upd(erzs[i][j].S+1,1);\r\n\t\t}\r\n\t\tfor(j=0;j<qrys[i].size();j++)\r\n\t\t{\r\n\t\t\tans[qrys[i][j].S]+=bit1.qry(qrys[i][j].F);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\nvoid dfssz(ll x,ll lst)\r\n{\r\n\tll i;\r\n\tsz[x]=1;\r\n\tmxsz[x]=0;\r\n\tpth.push_back(x);\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(vt[x][i].F!=lst&&(!iscent[vt[x][i].F]))\r\n\t\t{\r\n\t\t\tdfssz(vt[x][i].F,x);\r\n\t\t\tsz[x]+=sz[vt[x][i].F];\r\n\t\t\tmxsz[x]=max(mxsz[x],sz[vt[x][i].F]);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\nll getcent(ll x)\r\n{\r\n\tll i;\r\n\tpth.clear();\r\n\tdfssz(x,-1);\r\n\tfor(i=0;i<pth.size();i++)\r\n\t{\r\n\t\tif(max(mxsz[pth[i]],(ll)pth.size()-sz[pth[i]])*2<=pth.size())\r\n\t\t{\r\n\t\t\treturn pth[i];\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\nvoid dfscol(ll x,ll lst,ll c)\r\n{\r\n\tll i;\r\n\tbel[x]=c;\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(vt[x][i].F!=lst&&(!iscent[vt[x][i].F]))\r\n\t\t{\r\n\t\t\tdfscol(vt[x][i].F,x,c);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\nvoid dfs0(ll x,ll lst)\r\n{\r\n\tll i;\r\n\task1[x].clear();\r\n\task2[x].clear();\r\n\tdin[x]=++dcnt;\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(vt[x][i].F!=lst&&(!iscent[vt[x][i].F]))\r\n\t\t{\r\n\t\t\tacamid[vt[x][i].F][0]=acam1.trs[acamid[x][0]][vt[x][i].S-'a'];\r\n\t\t\tacamid[vt[x][i].F][1]=acam2.trs[acamid[x][1]][vt[x][i].S-'a'];\r\n\t\t\tsamid[vt[x][i].F][0]=((samid[x][0]>=0&&sam1.trs[samid[x][0]].count(vt[x][i].S-'a'))?sam1.trs[samid[x][0]][vt[x][i].S-'a']:-1);\r\n\t\t\tsamid[vt[x][i].F][1]=((samid[x][1]>=0&&sam2.trs[samid[x][1]].count(vt[x][i].S-'a'))?sam2.trs[samid[x][1]][vt[x][i].S-'a']:-1);\r\n\t\t\tdfs0(vt[x][i].F,x);\r\n\t\t}\r\n\t}\r\n\tdout[x]=dcnt;\r\n\treturn;\r\n}\r\nvoid dfsqry(ll x,ll lst)\r\n{\r\n\tll i;\r\n\tfor(i=0;i<qry[x].size();i++)\r\n\t{\r\n\t\tif(bel[qry[x][i].F.F]!=-1&&bel[qry[x][i].F.F]!=bel[x])\r\n\t\t{\r\n\t\t\task1[x].push_back(make_pair(qry[x][i].F.S,qry[x][i].S));\r\n\t\t\task2[qry[x][i].F.F].push_back(make_pair(qry[x][i].F.S,qry[x][i].S));\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(vt[x][i].F!=lst&&(!iscent[vt[x][i].F]))\r\n\t\t{\r\n\t\t\tdfsqry(vt[x][i].F,x);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\nvoid calc0(ll x,ll lst,ll d=0)\r\n{\r\n\tll i;\r\n\tbit1.upd(acam1.din[acamid[x][0]],1);\r\n\tbit2.upd(acam2.din[acamid[x][1]],1);\r\n\tif(samid[x][0]>=0)\r\n\t{\r\n\t\tsegt.update(1,sam1.din[samid[x][0]],sam1.dout[samid[x][0]],d);\r\n\t}\r\n\tfor(i=0;i<ask1[x].size();i++)\r\n\t{\r\n\t\tans[ask1[x][i].S]+=bit2.qry(acam2.dout[acam2.idx[ask1[x][i].F]])-bit2.qry(acam2.din[acam2.idx[ask1[x][i].F]]-1);\r\n\t}\r\n\tfor(i=0;i<ask2[x].size();i++)\r\n\t{\r\n\t\tmxlen[ask2[x][i].S][1]=segt.query(1,sam1.din[lstid[ask2[x][i].F][0]]);\r\n\t\tans[ask2[x][i].S]+=bit1.qry(acam1.dout[acam1.idx[ask2[x][i].F]])-bit1.qry(acam1.din[acam1.idx[ask2[x][i].F]]-1);\r\n\t}\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(vt[x][i].F!=lst&&(!iscent[vt[x][i].F]))\r\n\t\t{\r\n\t\t\tcalc0(vt[x][i].F,x,d+1);\r\n\t\t}\r\n\t}\r\n\tbit1.upd(acam1.din[acamid[x][0]],-1);\r\n\tbit2.upd(acam2.din[acamid[x][1]],-1);\r\n\tif(samid[x][0]>=0)\r\n\t{\r\n\t\tsegt.recall(1,sam1.din[samid[x][0]],sam1.dout[samid[x][0]]);\r\n\t}\r\n\treturn;\r\n}\r\nvoid calc1(ll x,ll lst,ll d=0)\r\n{\r\n\tll i;\r\n\tif(samid[x][1]>=0)\r\n\t{\r\n\t\tsegt.update(1,sam2.din[samid[x][1]],sam2.dout[samid[x][1]],d);\r\n\t}\r\n\tfor(i=0;i<ask1[x].size();i++)\r\n\t{\r\n\t\tmxlen[ask1[x][i].S][0]=segt.query(1,sam2.din[lstid[ask1[x][i].F][1]]);\r\n\t}\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(vt[x][i].F!=lst&&(!iscent[vt[x][i].F]))\r\n\t\t{\r\n\t\t\tcalc1(vt[x][i].F,x,d+1);\r\n\t\t}\r\n\t}\r\n\tif(samid[x][1]>=0)\r\n\t{\r\n\t\tsegt.recall(1,sam2.din[samid[x][1]],sam2.dout[samid[x][1]]);\r\n\t}\r\n\treturn;\r\n}\r\nvoid solve(ll x)\r\n{\r\n\tll i;\r\n\tx=getcent(x);\r\n\tiscent[x]=true;\r\n\tbel[x]=x;\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(!iscent[vt[x][i].F])\r\n\t\t{\r\n\t\t\tdfscol(vt[x][i].F,x,vt[x][i].F);\r\n\t\t}\r\n\t}\r\n\tdcnt=0;\r\n\tacamid[x][0]=acamid[x][1]=1;\r\n\tsamid[x][0]=samid[x][1]=0;\r\n\tdfs0(x,-1);\r\n\tdfsqry(x,-1);\r\n\tcalc0(x,-1);\r\n\tcalc1(x,-1);\r\n\tbel[x]=-1;\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(!iscent[vt[x][i].F])\r\n\t\t{\r\n\t\t\tdfscol(vt[x][i].F,x,-1);\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i<vt[x].size();i++)\r\n\t{\r\n\t\tif(!iscent[vt[x][i].F])\r\n\t\t{\r\n\t\t\tsolve(vt[x][i].F);\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\nint main(){\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0),cout.tie(0);\r\n\tll i,j,x,y;\r\n\tchar c;\r\n\tcin>>n>>m>>q;\r\n\tfor(i=1;i<n;i++)\r\n\t{\r\n\t\tcin>>x>>y>>c;\r\n\t\tx--,y--;\r\n\t\tvt[x].push_back(make_pair(y,c));\r\n\t\tvt[y].push_back(make_pair(x,c));\r\n\t}\r\n\tacam1.init();\r\n\tacam2.init();\r\n\tsam1.init();\r\n\tsam2.init();\r\n\tll len=0;\r\n\tfor(i=0;i<m;i++)\r\n\t{\r\n\t\tcin>>s[i];\r\n\t\tacam1.ins(s[i],i);\r\n\t\tfor(j=0;j<s[i].size();j++)\r\n\t\t{\r\n\t\t\tlstid[i][0]=sam1.ins(len+j,s[i][j]-'a');\r\n\t\t}\r\n\t\tsam1.ins(len+s[i].size(),i+26);\r\n\t\treverse(s[i].begin(),s[i].end());\r\n\t\tacam2.ins(s[i],i);\r\n\t\tfor(j=0;j<s[i].size();j++)\r\n\t\t{\r\n\t\t\tlstid[i][1]=sam2.ins(len+j,s[i][j]-'a');\r\n\t\t}\r\n\t\tsam2.ins(len+s[i].size(),i+26);\r\n\t\tlen+=s[i].size()+1;\r\n\t\treverse(s[i].begin(),s[i].end());\r\n\t}\r\n\tacam1.build();acam2.build();\r\n\tsam1.build();sam2.build();\r\n\tsegt.build(1,0,max(sam1.dcnt,sam2.dcnt));\r\n\tvector<ll> qwq(q);\r\n\tfor(i=0;i<q;i++)\r\n\t{\r\n\t\tcin>>x>>y>>j;\r\n\t\tx--,y--,j--;\r\n\t\tqwq[i]=j;\r\n\t\tqry[x].push_back(make_pair(make_pair(y,j),i));\r\n\t}\r\n\tmemset(bel,-1,sizeof(bel));\r\n\tsolve(0);\r\n\tfor(i=0;i<q;i++)\r\n\t{\r\n\t\tif(mxlen[i][0]&&mxlen[i][1])\r\n\t\t{\r\n\t\t\tfinq[qwq[i]].push_back(make_pair(make_pair(mxlen[i][0],mxlen[i][1]),i));\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i<m;i++)\r\n\t{\r\n\t\tvector<ll> preid(s[i].size()),sufid(s[i].size());\r\n\t\tx=1;\r\n\t\tfor(j=0;j<s[i].size();j++)\r\n\t\t{\r\n\t\t\tx=acam1.trs[x][s[i][j]-'a'];\r\n\t\t\tpreid[j]=x;\r\n\t\t}\r\n\t\tx=1;\r\n\t\tfor(j=s[i].size()-1;j>=0;j--)\r\n\t\t{\r\n\t\t\tx=acam2.trs[x][s[i][j]-'a'];\r\n\t\t\tsufid[j]=x;\r\n\t\t}\r\n\t\tvector<pair<pair<ll,ll>,pair<ll,ll> > > curupd;\r\n\t\tvector<pair<pair<ll,ll>,ll> > curqry;\r\n\t\tfor(j=0;j+1<s[i].size();j++)\r\n\t\t{\r\n\t\t\tcurupd.push_back(make_pair(make_pair(acam1.din[preid[j]],acam1.dout[preid[j]]),make_pair(acam2.din[sufid[j+1]],acam2.dout[sufid[j+1]])));\r\n\t\t}\r\n\t\tfor(j=0;j<finq[i].size();j++)\r\n\t\t{\r\n\t\t\tcurqry.push_back(make_pair(make_pair(acam1.din[preid[finq[i][j].F.F-1]],acam2.din[sufid[s[i].size()-finq[i][j].F.S]]),finq[i][j].S));\r\n\t\t}\r\n\t\tif((!curupd.empty())&&(!curqry.empty()))\r\n\t\t{\r\n\t\t\tsolveqry(curupd,curqry);\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i<q;i++)\r\n\t{\r\n\t\tcout<<ans[i]<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}"
}