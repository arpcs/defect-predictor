{
    "id": 34838013,
    "contestId": 917,
    "creationTimeSeconds": 1517575019,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "Georgia_001"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1060,
    "memoryConsumedBytes": 138035200,
    "source": "#include <algorithm>  \r\n#include <iostream>  \r\n#include <sstream>  \r\n#include <string>  \r\n#include <cstring>\r\n#include <vector>  \r\n#include <queue>  \r\n#include <set>  \r\n#include <map>  \r\n#include <cstdio>  \r\n#include <cstdlib>  \r\n#include <cctype>  \r\n#include <cmath>  \r\n#include <list>  \r\n#include <cassert>\r\n#include <ctime>\r\n#include <climits>\r\nusing namespace std;\r\n\r\n#define PB push_back  \r\n#define MP make_pair  \r\n#define SZ(v) ((int)(v).size())  \r\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \r\n#define REP(i,n) FOR(i,0,n)  \r\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \r\n#define REPE(i,n) FORE(i,0,n)  \r\n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \r\n#define REPSZ(i,v) REP(i,SZ(v))  \r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\r\n\r\nconst int MAXN = 100000;\r\nconst int MAXALPH = 26;\r\nconst int MAXWORD = 100000;\r\nconst int MAXSUMWORDLEN = 100000;\r\nconst int MAXAHONODES = MAXSUMWORDLEN + 1;\r\nconst int MAXQ = 100000;\r\nconst int MAXSTNODES = 2 * MAXSUMWORDLEN + 1;\r\nconst int MAXBITNODES = MAXAHONODES >= MAXSUMWORDLEN ? MAXAHONODES : MAXSUMWORDLEN;\r\n\r\nstruct BIT {\r\n\tint bit[MAXBITNODES+1], n;\r\n\tvoid init(int _n) { n = _n; memset(bit, 0, sizeof(bit)); }\r\n\tvoid mod(int idx, int by) { ++idx; while (idx <= n) { bit[idx] += by; idx += idx&-idx; } }\r\n\tvoid modrange(int lidx, int ridx, int by) { mod(lidx, by); mod(ridx + 1, -by); }\r\n\tint get(int idx) { ++idx; int ret = 0; while (idx > 0) { ret += bit[idx]; idx -= idx&-idx; } return ret; }\r\n\tint getrange(int lidx, int ridx) { return get(ridx) - get(lidx - 1); }\r\n};\r\n\r\nstruct AHO {\r\n\tint root, n;\r\n\tint dep[MAXAHONODES];\r\n\tint nxt[MAXAHONODES][MAXALPH];\r\n\tint suff[MAXAHONODES];\r\n\tint chead[MAXAHONODES], cnxt[MAXAHONODES];\r\n\tint lid[MAXAHONODES], rid[MAXAHONODES], nid;\r\n\tint leaf[MAXWORD];\r\n\tvoid init() { n = 0; memset(nxt, -1, sizeof(nxt)); root = n++; dep[root] = 0; }\r\n\tvoid add(char *s,int len, int id) {\r\n\t\tint at = root; REP(i, len) { int x = s[i] - 'a'; if (nxt[at][x] == -1) nxt[at][x] = n++, dep[nxt[at][x]] = dep[at] + 1; at = nxt[at][x]; }\r\n\t\tleaf[id] = at;\r\n\t}\r\n\tint q[MAXAHONODES], qhead, qtail;\r\n\tvoid dfsid(int at) { lid[at] = nid++; for (int to = chead[at]; to != -1; to = cnxt[to]) dfsid(to); rid[at] = nid - 1; }\r\n\tvoid calc() {\r\n\t\tsuff[root] = root; REP(x, MAXALPH) if (nxt[root][x] == -1) nxt[root][x] = root;\r\n\t\tqhead = qtail = 0; q[qhead++] = root;\r\n\t\twhile (qtail < qhead) {\r\n\t\t\tint at = q[qtail++];\r\n\t\t\tREP(x, MAXALPH) {\r\n\t\t\t\tif (nxt[at][x] != -1 && nxt[at][x] != root) {\r\n\t\t\t\t\tsuff[nxt[at][x]] = at == root ? root : nxt[suff[at]][x];\r\n\t\t\t\t\tq[qhead++] = nxt[at][x];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnxt[at][x] = nxt[suff[at]][x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tREP(i, n) chead[i] = -1; REP(i, n) if (i != root) cnxt[i] = chead[suff[i]], chead[suff[i]] = i;\r\n\t\tnid = 0; dfsid(root);\r\n\t}\r\n\tvoid print(int at) {\r\n\t\tREP(x, MAXALPH) if (nxt[at][x]!=-1 && dep[nxt[at][x]] > dep[at]) {\r\n\t\t\tREP(i, dep[at]) printf(\" \"); printf(\"%c (%d suff=%d, id=%d..%d)\\n\", 'a' + x, nxt[at][x], suff[nxt[at][x]], lid[nxt[at][x]], rid[nxt[at][x]]);\r\n\t\t\tprint(nxt[at][x]);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nstruct STNode {\r\n\tchar *s; int len;\r\n\tint childs[MAXALPH];\r\n\tint suffix;\r\n\tvector<int> ids;\r\n\tSTNode(char *s, int len, int id) :s(s), len(len) { memset(childs, -1, sizeof(childs)); suffix = -1; if (id != -1) ids.PB(id); }\r\n};\r\nstruct STState { int at, x, len; STState(int at, int x, int len) :at(at), x(x), len(len) {} STState() {} };\r\nstruct ST {\r\n\tint root;\r\n\tvector<STNode> nodes;\r\n\r\n\tvoid init() { nodes.clear(); root = addnode(NULL, 0, -1); }\r\n\tint addnode(char *s, int len, int id) { nodes.PB(STNode(s, len, id)); return SZ(nodes) - 1; }\r\n\tint add(char *s, int n, int id) {\r\n\t\t//printf(\"adding %.*s\\n\", n, s);\r\n\t\tint atnode = root, atedge = 0, atlen = 0, pint = -1, pleaf = -1; // atedge+atlen==i\r\n\t\tREPE(i, n) {\r\n\t\t\t//printf(\"i=%d\\n\", i); print(root);\r\n\t\t\twhile (true) {\r\n\t\t\t\t//printf(\"atnode=%d atedge=%d atlen=%d\\n\", atnode, atedge, atlen);\r\n\t\t\t\tint tonode = atedge == n ? -1 : nodes[atnode].childs[s[atedge] - 'a'];\r\n\t\t\t\tif (tonode != -1 && atlen >= nodes[tonode].len) {\r\n\t\t\t\t\tatedge += nodes[tonode].len;\r\n\t\t\t\t\tatlen -= nodes[tonode].len;\r\n\t\t\t\t\tatnode = tonode;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (tonode == -1) { // atlen should be 0, atedge should be i\r\n\t\t\t\t\tif (i != n) {\r\n\t\t\t\t\t\tint leaf = addnode(s + i, n - i, id);\r\n\t\t\t\t\t\tnodes[atnode].childs[nodes[leaf].s[0] - 'a'] = leaf;\r\n\t\t\t\t\t\tif (pleaf != -1) nodes[pleaf].suffix = leaf; pleaf = leaf;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnodes[atnode].ids.PB(id);\r\n\t\t\t\t\t\tif (pleaf != -1) nodes[pleaf].suffix = atnode; pleaf = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (pint != -1) nodes[pint].suffix = atnode; pint = -1;\r\n\t\t\t\t} else if (i == n || nodes[tonode].s[atlen] != s[i]) {\r\n\t\t\t\t\tint branch = addnode(nodes[tonode].s, atlen, -1);\r\n\t\t\t\t\tnodes[tonode].s += atlen, nodes[tonode].len -= atlen;\r\n\t\t\t\t\tnodes[atnode].childs[nodes[branch].s[0] - 'a'] = branch;\r\n\t\t\t\t\tnodes[branch].childs[nodes[tonode].s[0] - 'a'] = tonode;\r\n\t\t\t\t\tif (i != n) {\r\n\t\t\t\t\t\tint leaf = addnode(s + i, n - i, id);\r\n\t\t\t\t\t\tnodes[branch].childs[nodes[leaf].s[0] - 'a'] = leaf;\r\n\t\t\t\t\t\tif (pleaf != -1) nodes[pleaf].suffix = leaf; pleaf = leaf;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnodes[branch].ids.PB(id);\r\n\t\t\t\t\t\tif (pleaf != -1) nodes[pleaf].suffix = branch; pleaf = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (pint != -1) nodes[pint].suffix = branch; pint = branch;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (pint != -1) assert(atlen == 0), nodes[pint].suffix = atnode; pint = -1;\r\n\t\t\t\t\t++atlen;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (atnode == root) {\r\n\t\t\t\t\tatedge++;\r\n\t\t\t\t\tif (atlen == 0) { assert(pint == -1); break; } else --atlen;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tatnode = nodes[atnode].suffix;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn root;\r\n\t}\r\n\r\n\tSTState nxt(STState cur, int x) {\r\n\t\tif (cur.len == -1) return cur;\r\n\t\tSTState ret;\r\n\t\tif (cur.len == 0) {\r\n\t\t\tif (nodes[cur.at].childs[x] == -1) return STState(cur.at, -1, -1); else ret = STState(cur.at, x, 1);\r\n\t\t} else {\r\n\t\t\tif (nodes[nodes[cur.at].childs[cur.x]].s[cur.len] != 'a' + x) return STState(cur.at, -1, -1); else ret = STState(cur.at, cur.x, cur.len + 1);\r\n\t\t}\r\n\t\treturn nodes[nodes[ret.at].childs[ret.x]].len == ret.len ? STState(nodes[ret.at].childs[ret.x], -1, 0) : ret;\r\n\t}\r\n\r\n\tvoid print(int at, int depth = 0) {\r\n\t\tREP(i, depth) printf(\"  \"); if (nodes[at].s != NULL) printf(\"'%.*s'\", nodes[at].len, nodes[at].s);\r\n\t\tprintf(\" = %d\", at); if (nodes[at].suffix != -1) printf(\" [%d]\", nodes[at].suffix);\r\n\t\tif (SZ(nodes[at].ids) != 0) { printf(\" <\"); REPSZ(i, nodes[at].ids) { if (i != 0) printf(\",\"); printf(\"%d\", nodes[at].ids[i]); } printf(\">\"); } puts(\"\");\r\n\t\tREP(i, MAXALPH) if (nodes[at].childs[i] != -1) print(nodes[at].childs[i], depth + 1);\r\n\t}\r\n};\r\n\r\nBIT FWBIT, BWBIT;\r\nAHO AHOFW, AHOBW;\r\nST STFW, STBW;\r\n\r\nint n, nword, nq;\r\nvector<pair<int, char> > adj[MAXN];\r\nint woff[MAXWORD + 1], wlen[MAXWORD]; char wsfw[MAXSUMWORDLEN + 1], wsbw[MAXSUMWORDLEN + 1];\r\n\r\nint qkind[MAXQ], qa[MAXQ], qb[MAXQ], qans[MAXQ], qstfw[MAXQ], qstbw[MAXQ], qstidx[MAXQ];\r\nvector<int> rqa[MAXN], rqb[MAXN], rstfw[MAXSTNODES], rstbw[MAXSTNODES];\r\n\r\nint sz[MAXN];\r\nbool alive[MAXN];\r\nint mark[MAXN];\r\n\r\nvoid dfssz(int at, int par) {\r\n\tsz[at] = 1;\r\n\tREPSZ(i, adj[at]) {\r\n\t\tint to = adj[at][i].first; if (!alive[to] || to == par) continue;\r\n\t\tdfssz(to, at); sz[at] += sz[to];\r\n\t}\r\n}\r\n\r\nint centroid(int at) {\r\n\tdfssz(at, -1); int rootsz = sz[at], par = -1;\r\n\twhile (true) {\r\n\t\tbool found = false;\r\n\t\tREPSZ(i, adj[at]) {\r\n\t\t\tint to = adj[at][i].first; if (!alive[to] || to == par) continue;\r\n\t\t\tif (2 * sz[to] > rootsz) { par = at; at = to; found = true; break; }\r\n\t\t}\r\n\t\tif (!found) return at;\r\n\t}\r\n}\r\n\r\nvoid dfsmark(int at, int par, int tok) {\r\n\tmark[at] = tok;\r\n\tREPSZ(i, adj[at]) {\r\n\t\tint to = adj[at][i].first; if (!alive[to] || to == par) continue;\r\n\t\tdfsmark(to, at, tok);\r\n\t}\r\n}\r\n\r\nbool debug = false;\r\nvoid dfssolve(int at, int par, int ahofw, int ahobw, STState stfw, STState stbw) {\r\n\tif (debug) printf(\"dfspath(%d,%d,%d=%d,%d=%d|%d,%d,%d|%d,%d,%d)\\n\", at + 1, par + 1, ahofw, AHOFW.lid[ahofw], ahobw, AHOBW.lid[ahobw], stfw.at, stfw.x, stfw.len, stbw.at, stbw.x, stbw.len);\r\n\tFWBIT.mod(AHOFW.lid[ahofw], +1);\r\n\tBWBIT.mod(AHOBW.lid[ahobw], +1);\r\n\tREPSZ(i, rqa[at]) {\r\n\t\tint qi = rqa[at][i], node = AHOBW.leaf[qkind[qi]]; if (mark[qb[qi]] == -1 || mark[qb[qi]] == mark[qa[qi]]) continue;\r\n\t\tif (debug) printf(\"qa%d: %d->%d [ahobw%d=%d..%d]\\n\", qi, qa[qi] + 1, qb[qi] + 1, node, AHOBW.lid[node], AHOBW.rid[node]);\r\n\t\tqans[qi] += BWBIT.getrange(AHOBW.lid[node], AHOBW.rid[node]);\r\n\t\tqstbw[qi] = stbw.at;\r\n\t}\r\n\tREPSZ(i, rqb[at]) {\r\n\t\tint qi = rqb[at][i], node = AHOFW.leaf[qkind[qi]]; if (mark[qa[qi]] == -1 || mark[qa[qi]] == mark[qb[qi]]) continue;\r\n\t\tif (debug) printf(\"qb%d: %d->%d [ahofw%d=%d..%d]\\n\", qi, qa[qi] + 1, qb[qi] + 1, node, AHOFW.lid[node], AHOFW.rid[node]);\r\n\t\tqans[qi] += FWBIT.getrange(AHOFW.lid[node], AHOFW.rid[node]);\r\n\t\tqstfw[qi] = stfw.at;\r\n\t}\r\n\tREPSZ(i, adj[at]) {\r\n\t\tint to = adj[at][i].first, x = adj[at][i].second - 'a'; if (!alive[to] || to == par) continue;\r\n\t\tdfssolve(to, at, AHOFW.nxt[ahofw][x], AHOBW.nxt[ahobw][x], STFW.nxt(stfw, x), STBW.nxt(stbw, x));\r\n\t}\r\n\tFWBIT.mod(AHOFW.lid[ahofw], -1);\r\n\tBWBIT.mod(AHOBW.lid[ahobw], -1);\r\n}\r\n\r\nvoid decompose(int at) {\r\n\tat = centroid(at);\r\n\t//printf(\"centroid=%d\\n\", at + 1); debug = at + 1 == 2;\r\n\r\n\tmark[at] = at;\r\n\tREPSZ(i, adj[at]) {\r\n\t\tint to = adj[at][i].first; if (!alive[to]) continue;\r\n\t\tdfsmark(to, at, to);\r\n\t}\r\n\tdfssolve(at, -1, AHOFW.root, AHOBW.root, STState(STFW.root, -1, 0), STState(STBW.root, -1, 0));\r\n\tmark[at] = -1;\r\n\tREPSZ(i, adj[at]) {\r\n\t\tint to = adj[at][i].first; if (!alive[to]) continue;\r\n\t\tdfsmark(to, at, -1);\r\n\t}\r\n\r\n\talive[at] = false;\r\n\tREPSZ(i, adj[at]) {\r\n\t\tint to = adj[at][i].first; if (!alive[to]) continue;\r\n\t\tdecompose(to);\r\n\t}\r\n}\r\n\r\nBIT STBIT;\r\nint wlast[MAXWORD], oldwlast[MAXSUMWORDLEN];\r\nint bwlid[MAXSUMWORDLEN], bwrid[MAXSUMWORDLEN], bwnid[MAXWORD];\r\n\r\nvoid preprocst(int at, int len) {\r\n\tREPSZ(i, STBW.nodes[at].ids) {\r\n\t\tint wi = STBW.nodes[at].ids[i]; if (len >= wlen[wi]) continue; int idx = woff[wi] + len;\r\n\t\toldwlast[idx] = wlast[wi], wlast[wi] = idx;\r\n\t\tbwlid[idx] = woff[wi] + bwnid[wi]++;\r\n\t\t//printf(\"%d: (%d,%d)=%d\\n\", at, wi, len, idx);\r\n\t}\r\n\tREPSZ(i, rstbw[at]) {\r\n\t\tint qi = rstbw[at][i], wi = qkind[qi];\r\n\t\tqstidx[qi] = wlast[wi];\r\n\t\t//printf(\"qstidx%d=%d\\n\", qi, qstidx[qi]);\r\n\t}\r\n\tREP(x, MAXALPH) if (STBW.nodes[at].childs[x] != -1) preprocst(STBW.nodes[at].childs[x], len + STBW.nodes[STBW.nodes[at].childs[x]].len);\r\n\tREPSZ(i, STBW.nodes[at].ids) {\r\n\t\tint wi = STBW.nodes[at].ids[i]; if (len >= wlen[wi]) continue; int idx = woff[wi] + len;\r\n\t\twlast[wi] = oldwlast[idx];\r\n\t\tbwrid[idx] = woff[wi] + bwnid[wi] - 1;\r\n\t}\r\n}\r\n\r\nvoid solvest(int at,int len) {\r\n\tREPSZ(i, STFW.nodes[at].ids) {\r\n\t\tint wi = STFW.nodes[at].ids[i]; if (len <= 0 || len >= wlen[wi]) continue; int idx = woff[wi] + wlen[wi] - len;\r\n\t\t//printf(\"%d: suffix of word %d of length %d\\n\", at, wi, len);\r\n\t\tSTBIT.modrange(bwlid[idx], bwrid[idx], +1);\r\n\t}\r\n\tREPSZ(i, rstfw[at]) {\r\n\t\tint qi = rstfw[at][i], idx = qstidx[qi];\r\n\t\tqans[qi] += STBIT.get(bwlid[idx]);\r\n\t}\r\n\tREP(x, MAXALPH) if (STFW.nodes[at].childs[x] != -1) solvest(STFW.nodes[at].childs[x], len + STFW.nodes[STFW.nodes[at].childs[x]].len);\r\n\tREPSZ(i, STFW.nodes[at].ids) {\r\n\t\tint wi = STFW.nodes[at].ids[i]; if (len <= 0 || len >= wlen[wi]) continue; int idx = woff[wi] + wlen[wi] - len;\r\n\t\tSTBIT.modrange(bwlid[idx], bwrid[idx], -1);\r\n\t}\r\n}\r\n\r\nvoid solve() {\r\n\tREP(i, nword) REP(j, wlen[i]) wsbw[woff[i] + wlen[i] - j - 1] = wsfw[woff[i] + j]; wsbw[woff[nword]] = '\\0';\r\n\tREP(i, n) rqa[i].clear(), rqb[i].clear();\r\n\tREP(i, nq) rqa[qa[i]].PB(i), rqb[qb[i]].PB(i);\r\n\r\n\tAHOFW.init(); REP(i, nword) AHOFW.add(wsfw + woff[i], wlen[i], i); AHOFW.calc(); FWBIT.init(AHOFW.n);\r\n\tAHOBW.init(); REP(i, nword) AHOBW.add(wsbw + woff[i], wlen[i], i); AHOBW.calc(); BWBIT.init(AHOBW.n);\r\n\t//printf(\"wsfw: %s\\nwsbw: %s\\n\", wsfw, wsbw); AHOFW.print(AHOFW.root); AHOBW.print(AHOBW.root);\r\n\r\n\tSTFW.init(); REP(i, nword) STFW.add(wsfw + woff[i], wlen[i], i);\r\n\tSTBW.init(); REP(i, nword) STBW.add(wsbw + woff[i], wlen[i], i);\r\n\t//printf(\"st\\n\"); STFW.print(STFW.root); STBW.print(STBW.root);\r\n\r\n\tREP(i, n) mark[i] = -1, alive[i] = true; REP(i, nq) qans[i] = 0, qstfw[i] = -1, qstbw[i] = -1, qstidx[i] = -1;\r\n\tdecompose(0);\r\n\r\n\t//REP(i, nq) printf(\"q%d: fw=%d bw=%d\\n\", i, qstfw[i], qstbw[i]);\r\n\tREPSZ(i, STFW.nodes) rstfw[i].clear(); REPSZ(i, STBW.nodes) rstbw[i].clear();\r\n\tREP(i, nq) { if (qstfw[i] != -1) rstfw[qstfw[i]].PB(i); if (qstbw[i] != -1) rstbw[qstbw[i]].PB(i); }\r\n\tSTBIT.init(woff[nword]);\r\n\tREP(i, nword) wlast[i] = -1, bwnid[i] = 0; REP(i, woff[nword]) oldwlast[i] = -1, bwlid[i] = bwrid[i] = -1;\r\n\tpreprocst(STBW.root, 0);\r\n\tsolvest(STFW.root, 0);\r\n}\r\n\r\nvoid input() {\r\n\tscanf(\"%d%d%d\", &n, &nword, &nq);\r\n\tREP(i, n) adj[i].clear();\r\n\tREP(i, n - 1) { int a, b; char c; scanf(\"%d%d %c\", &a, &b, &c); --a, --b; adj[a].PB(MP(b, c)); adj[b].PB(MP(a, c)); }\r\n\twoff[0] = 0; REP(i, nword) { scanf(\"%s\", wsfw + woff[i]); wlen[i] = strlen(wsfw + woff[i]); woff[i + 1] = woff[i] + wlen[i]; }\r\n\tREP(i, nq) scanf(\"%d%d%d\", &qa[i], &qb[i], &qkind[i]), --qa[i], --qb[i], --qkind[i];\r\n}\r\n\r\nvoid run() {\r\n\tinput();\r\n\tsolve();\r\n\tREP(i, nq) printf(\"%d\\n\", qans[i]);\r\n}\r\n\r\nint myrand() { return rand() % 1000 * 1000000 + rand() % 1000 * 1000 + rand() % 1000; }\r\nvoid stresslarge() {\r\n\tn = MAXN, nword = min(MAXWORD, max(1, (int)sqrt(1.0*MAXSUMWORDLEN))), nq = MAXQ;\r\n\tREP(i, n) adj[i].clear();\r\n\tREP(i, n - 1) { int a = myrand() % (i + 1), b = i, x = rand() % 26; adj[a].PB(MP(b, 'a' + x)), adj[b].PB(MP(a, 'a' + x)); }\r\n\twoff[nword] = MAXSUMWORDLEN; REP(i, nword) woff[i] = myrand() % (woff[nword] - nword + 1); sort(woff, woff + nword); REP(i, nword) woff[i] += i; REP(i, nword) wlen[i] = woff[i + 1] - woff[i];\r\n\tREP(i, woff[nword]) wsfw[i] = 'a' + rand() % 26;\r\n\tREP(i, nq) qa[i] = myrand() % n, qb[i] = myrand() % n, qkind[i] = myrand() % nword;\r\n\tclock_t start = clock();\r\n\tsolve();\r\n\tprintf(\"Took %.9lf\\n\", double(clock() - start) / CLOCKS_PER_SEC);\r\n}\r\n\r\nint main() {\r\n\trun();\r\n\t//stresslarge();\r\n\treturn 0;\r\n}"
}