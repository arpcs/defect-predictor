{
    "id": 70409840,
    "contestId": 917,
    "creationTimeSeconds": 1580963867,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "gongsuidashen"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<cstring>\r\n#include<cstdlib>\r\n#include<cstdio>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdlib.h>\r\nusing namespace std;\r\n\r\nint n,m,lq;\r\n#define maxn 200011\r\nstruct Edge{int to,next; char v;}edge[maxn<<1]; int first[maxn],le=2;\r\nvoid in(int x,int y,char v) {Edge &e=edge[le]; e.to=y; e.v=v; e.next=first[x]; first[x]=le++;}\r\nvoid insert(int x,int y,char v) {in(x,y,v); in(y,x,v);}\r\n\r\nstruct Ques{int x,y,z,id,col,ps1,ps2;}q[maxn];\r\nbool cmp(const Ques &a,const Ques &b) {return a.col<b.col;}\r\nint ans[maxn];\r\n\r\nstruct AC\r\n{\r\n\tint ch[maxn][26],size,pos[maxn];\r\n\tAC() {size=0; le=2; Time=0;}\r\n\tint idx(char c) {return c-'a';}\r\n\tvoid insert(int who,char *s)\r\n\t{\r\n\t\tint len=strlen(s),now=0;\r\n\t\tfor (int i=0;i<len;i++)\r\n\t\t{\r\n\t\t\tint id=idx(s[i]);\r\n\t\t\tif (!ch[now][id])\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t\tch[now][id]=size;\r\n\t\t\t}\r\n\t\t\tnow=ch[now][id];\r\n\t\t}\r\n\t\tpos[who]=now;\r\n\t}\r\n\tint fail[maxn];\r\n\tint que[maxn],head,tail;\r\n\tvoid makefail()\r\n\t{\r\n\t\thead=tail=0;\r\n\t\tfor (int i=0;i<26;i++) if (ch[0][i])\r\n\t\t{\r\n\t\t\tfail[ch[0][i]]=0;\r\n\t\t\tque[tail++]=ch[0][i];\r\n\t\t}\r\n\t\twhile (head!=tail)\r\n\t\t{\r\n\t\t\tint now=que[head++];\r\n\t\t\tfor (int i=0;i<26;i++)\r\n\t\t\t{\r\n\t\t\t\tif (!ch[now][i]) {ch[now][i]=ch[fail[now]][i]; continue;}\r\n\t\t\t\tque[tail++]=ch[now][i];\r\n\t\t\t\tfail[ch[now][i]]=ch[fail[now]][i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tEdge edge[maxn<<1]; int first[maxn],le;\r\n\tvoid in(int x,int y) {Edge &e=edge[le]; e.to=y; e.next=first[x]; first[x]=le++;}\r\n\tint ll[maxn],rr[maxn],Time;\r\n\tvoid predfs(int x)\r\n\t{\r\n\t\tll[x]=++Time;\r\n\t\tfor (int i=first[x];i;i=edge[i].next)\r\n\t\t{\r\n\t\t\tEdge &e=edge[i];\r\n\t\t\tpredfs(e.to);\r\n\t\t}\r\n\t\trr[x]=Time;\r\n\t}\r\n\tvoid predfs()\r\n\t{\r\n\t\tfor (int i=1;i<=size;i++) in(fail[i],i);\r\n\t\tpredfs(0);\r\n\t}\r\n}a1,a2;\r\nvector<char> ss[maxn],fs[maxn];\r\nstruct SAM\r\n{\r\n\tstruct Node{int ch[26],pos,pre,who,Max;}a[maxn<<1];\r\n\tint size,last;\r\n\tSAM() {a[0].pre=-1; size=last=0; le=2; Time=0;}\r\n\tint idx(char c) {return c-'a';}\r\n\tvoid insert(int who,char c,int pos)\r\n\t{\r\n\t\tint id=idx(c);\r\n\t\tif (a[last].ch[id])\r\n\t\t{\r\n\t\t\tif (a[a[last].ch[id]].Max==a[last].Max+1) last=a[last].ch[id];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint z=a[last].ch[id],w=++size; a[w]=a[z]; a[w].Max=a[last].Max+1; a[w].pos=pos; a[w].who=who;\r\n\t\t\t\ta[z].pre=w;\r\n\t\t\t\tfor (int y=last;~y && a[y].ch[id]==z;y=a[y].pre) a[y].ch[id]=w;\r\n\t\t\t\tlast=w;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint x=++size; a[x].pos=pos; a[x].who=who; a[x].Max=a[last].Max+1;\r\n\t\t\tint y=last; last=x;\r\n\t\t\tfor (;~y && !a[y].ch[id];y=a[y].pre) a[y].ch[id]=x;\r\n\t\t\tif (!~y) a[x].pre=0;\r\n\t\t\telse if (a[a[y].ch[id]].Max==a[y].Max+1) a[x].pre=a[y].ch[id];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint z=a[y].ch[id],w=++size; a[w]=a[z]; a[w].pos=pos; a[w].Max=a[y].Max+1; a[w].who=who;\r\n\t\t\t\ta[z].pre=a[x].pre=w;\r\n\t\t\t\tfor (;~y && a[y].ch[id]==z;y=a[y].pre) a[y].ch[id]=w;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tEdge edge[maxn<<2]; int first[maxn<<1],le;\r\n\tvoid in(int x,int y) {Edge &e=edge[le]; e.to=y; e.next=first[x]; first[x]=le++;}\r\n\tint ll[maxn],rr[maxn],Time;\r\n\tvoid predfs(int x)\r\n\t{\r\n\t\tll[x]=++Time;\r\n\t\tfor (int i=first[x];i;i=edge[i].next)\r\n\t\t{\r\n\t\t\tEdge &e=edge[i];\r\n\t\t\tpredfs(e.to);\r\n\t\t}\r\n\t\trr[x]=Time;\r\n\t}\r\n\tvoid predfs() {for (int i=1;i<=size;i++) in(a[i].pre,i); predfs(0);}\r\n\tbool go(int &x,int &son,int &pos,char c,vector<char> *s)\r\n\t{\r\n\t\tif (!son)\r\n\t\t{\r\n\t\t\tfor (int i=first[x];i;i=edge[i].next)\r\n\t\t\t{\r\n\t\t\t\tEdge &e=edge[i]; Node &now=a[e.to];\r\n\t\t\t\tif (s[now.who][now.pos+a[x].Max]==c)\r\n\t\t\t\t{\r\n\t\t\t\t\tson=e.to;\r\n\t\t\t\t\tpos=now.pos+a[x].Max+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!son) return 0;\r\n\t\t}\r\n\t\telse if (s[a[son].who][pos]==c) pos++; else return 0;\r\n\t\tif (pos==a[son].pos+a[son].Max) {x=son; son=pos=0;}\r\n\t\treturn 1;\r\n\t}\r\n}s1,s2;\r\nstruct BIT\r\n{\r\n\tint a[maxn<<1],n;\r\n\tvoid clear(int m) {n=m;}\r\n\tvoid add(int x,int v) {for (;x<=n;x+=x&-x) a[x]+=v;}\r\n\tint query(int x) {int ans=0; for (;x;x-=x&-x) ans+=a[x]; return ans;}\r\n}ta1,ta2,ts;\r\n\r\nint size[maxn];\r\nint col[maxn]; bool vis[maxn];\r\nvoid getsize(int x,int fa)\r\n{\r\n\tsize[x]=1;\r\n\tfor (int i=first[x];i;i=edge[i].next)\r\n\t{\r\n\t\tEdge &e=edge[i]; if (e.to==fa || vis[e.to]) continue;\r\n\t\tgetsize(e.to,x); size[x]+=size[e.to];\r\n\t}\r\n}\r\nint getroot(int x,int fa,int tot)\r\n{\r\n\tfor (int i=first[x];i;i=edge[i].next)\r\n\t{\r\n\t\tEdge &e=edge[i]; if (e.to==fa || vis[e.to]) continue;\r\n\t\tif (size[e.to]*2>tot) return getroot(e.to,x,tot);\r\n\t}\r\n\treturn x;\r\n}\r\n\r\nvoid paint(int x,int fa,int c)\r\n{\r\n\tcol[x]=c;\r\n\tfor (int i=first[x];i;i=edge[i].next)\r\n\t{\r\n\t\tEdge &e=edge[i]; if (e.to==fa || vis[e.to]) continue;\r\n\t\tpaint(e.to,x,c);\r\n\t}\r\n}\r\nstruct Eve{int to,type,next;}eve[maxn<<1]; int feve[maxn],leve=2;\r\nvoid ineve(int x,int y,int type) {Eve &e=eve[leve]; e.to=y; e.type=type; e.next=feve[x]; feve[x]=leve++;}\r\nvoid Dfs(int x,int fa,int pa1,int pa2,int ps1,bool die1,int son1,int pos1,int ps2,bool die2,int son2,int pos2)\r\n{\r\n\tta1.add(a1.ll[pa1],1); ta2.add(a2.ll[pa2],1);\r\n\tfor (int i=feve[x];i;i=eve[i].next)\r\n\t{\r\n\t\tEve &e=eve[i];\r\n\t\tif (e.type==1)\r\n\t\t{\r\n\t\t\tans[q[e.to].id]+=ta2.query(a2.rr[a2.pos[q[e.to].z]])-ta2.query(a2.ll[a2.pos[q[e.to].z]]-1);\r\n\t\t\tq[e.to].ps1=ps1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tans[q[e.to].id]+=ta1.query(a1.rr[a1.pos[q[e.to].z]])-ta1.query(a1.ll[a1.pos[q[e.to].z]]-1);\r\n\t\t\tq[e.to].ps2=ps2;\r\n\t\t}\r\n\t}\r\n\tfor (int i=first[x];i;i=edge[i].next)\r\n\t{\r\n\t\tEdge &e=edge[i]; if (e.to==fa || vis[e.to]) continue;\r\n\t\tint id=e.v-'a';\r\n\t\tint nps1=ps1,npos1=pos1,nson1=son1,nps2=ps2,npos2=pos2,nson2=son2; bool nd1=die1,nd2=die2;\r\n\t\tif (die1) nps1=ps1,nson1=0,npos1=0,nd1=1;\r\n\t\telse nd1=!s1.go(nps1,nson1,npos1,e.v,fs);\r\n\t\tif (die2) nps2=ps2,nson2=0,npos2=0,nd2=1;\r\n\t\telse nd2=!s2.go(nps2,nson2,npos2,e.v,ss);\r\n\t\tDfs(e.to,x,a1.ch[pa1][id],a2.ch[pa2][id],nps1,nd1,nson1,npos1,nps2,nd2,nson2,npos2);\r\n\t}\r\n\tta1.add(a1.ll[pa1],-1); ta2.add(a2.ll[pa2],-1);\r\n}\r\n\t\t\r\nvoid cd(int x,int ql,int qr)\r\n{\r\n\tvis[x]=1; col[x]=0;\r\n\tif (ql>qr) return;\r\n\tbool flag=0; int tot=0;\r\n\tfor (int i=first[x];i;i=edge[i].next)\r\n\t{\r\n\t\tEdge &e=edge[i]; if (vis[e.to]) continue;\r\n\t\tpaint(e.to,0,++tot);\r\n\t}\r\n\tfor (int i=ql;i<=qr;i++)\r\n\t{\r\n\t\tif (col[q[i].x]==col[q[i].y]) q[i].col=col[q[i].x];\r\n\t\telse flag=1,q[i].col=0;\r\n\t}\r\n\tsort(q+ql,q+qr+1,cmp);\r\n\tint j;\r\n\tfor (j=ql;j<=qr && q[j].col==0;j++)\r\n\t{\r\n\t\tineve(q[j].x,j,1);\r\n\t\tineve(q[j].y,j,0);\r\n\t}\r\n\tif (flag) Dfs(x,0,0,0,0,0,0,0,0,0,0,0);\r\n\tfor (int k=ql;k<j;k++) feve[q[k].x]=feve[q[k].y]=0; leve=2;\r\n\tfor (int i=first[x];i;i=edge[i].next)\r\n\t{\r\n\t\tEdge &e=edge[i]; if (vis[e.to]) continue;\r\n\t\tint tj=j; while (j<=qr && q[j].col==col[e.to]) j++;\r\n\t\tgetsize(e.to,0); cd(getroot(e.to,0,size[e.to]),tj,j-1);\r\n\t}\r\n}\r\n\r\nstruct Bre{int tx,ty,tz,type,isq;}bre[maxn],ff[maxn<<2]; int lbre=0,lff=0;\r\nvoid inbre(int x,int y,int t) {bre[++lbre]=(Bre){x,y,0,t};}\r\n\r\nchar s[maxn]; int br[maxn];\r\nbool cmpff(const Bre &a,const Bre &b) {return a.type<b.type || (a.type==b.type && a.tx<b.tx)\r\n|| (a.type==b.type && a.tx==b.tx && a.isq<b.isq);}\r\nint main()\r\n{\r\n\tscanf(\"%d%d%d\",&n,&m,&lq);\r\n\tchar c;\r\n\tfor (int i=1,x,y;i<n;i++)\r\n\t{\r\n\t\tscanf(\"%d%d\",&x,&y); while ((c=getchar())<'a' || c>'z');\r\n\t\tinsert(x,y,c);\r\n\t}\r\n\tfor (int i=1;i<=m;i++)\r\n\t{\r\n\t\ts1.last=s2.last=0;\r\n\t\tscanf(\"%s\",s); int len=strlen(s);\r\n\t\tss[i].push_back('$'); for (int j=0;j<len;j++) ss[i].push_back(s[j]);\r\n\t\ta1.insert(i,s); for (int j=0;j<len;j++) s1.insert(i,s[j],len-j),br[j]=s1.last;\r\n\t\tfor (int j=0,to=len>>1;j<to;j++) s[j]^=s[len-j-1]^=s[j]^=s[len-j-1];\r\n\t\tfs[i].push_back('$'); for (int j=0;j<len;j++) fs[i].push_back(s[j]);\r\n\t\ta2.insert(i,s); for (int j=0;j<len-1;j++) s2.insert(i,s[j],len-j),inbre(br[len-j-2],s2.last,i); s2.insert(i,s[len-1],1);\r\n\t}\r\n\tfor (int i=1;i<=lq;i++) scanf(\"%d%d%d\",&q[i].x,&q[i].y,&q[q[i].id=i].z);\r\n\t\r\n\tta1.clear(a1.size+3); ta2.clear(a2.size+3);\r\n\ta1.makefail(); a2.makefail();\r\n\ta1.predfs(); a2.predfs(); s1.predfs(); s2.predfs();\r\n\tgetsize(1,0); cd(getroot(1,0,size[1]),1,lq);\r\n\t\r\n\tfor (int i=1;i<=lbre;i++)\r\n\t{\r\n\t\tff[++lff]=(Bre){s1.ll[bre[i].tx],bre[i].ty,1,bre[i].type,0};\r\n\t\tff[++lff]=(Bre){s1.rr[bre[i].tx]+1,bre[i].ty,-1,bre[i].type,0};\r\n\t}\r\n\tfor (int i=1;i<=lq;i++) ff[++lff]=(Bre){s1.ll[q[i].ps1],s2.ll[q[i].ps2],q[i].id,q[i].z,1};\r\n\tsort(ff+1,ff+1+lff,cmpff);\r\n\tts.clear(s2.size+3);\r\n\tfor (int k=1;k<=lff;k++)\r\n\t{\r\n\t\tif (ff[k].isq==0) ts.add(s2.ll[ff[k].ty],ff[k].tz),ts.add(s2.rr[ff[k].ty]+1,-ff[k].tz);\r\n\t\telse ans[ff[k].tz]+=ts.query(ff[k].ty);\r\n\t}\r\n\t\r\n\tfor (int i=1;i<=lq;i++) printf(\"%d\\n\",ans[i]);\r\n\treturn 0;\r\n}"
}