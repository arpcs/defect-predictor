{
    "id": 42155191,
    "contestId": 917,
    "creationTimeSeconds": 1535379372,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "Durant_Lee"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 2464,
    "memoryConsumedBytes": 377958400,
    "source": "#include<bits/stdc++.h>\r\n#define pb push_back\r\n#define mkp make_pair\r\n#define fi first\r\n#define se second\r\nusing namespace std;\r\n\r\ntypedef long long LL;\r\ntypedef pair<char,int> pci;\r\ntypedef pair<int,char> pic;\r\ntypedef pair<LL,int> pli;\r\ntypedef pair<int,int> pii;\r\ntypedef pair<int,pii> piii;\r\nconst LL INF=(LL)2e18;\r\nconst int inf=2e9,mod=1e9+7;\r\nconst int N=2e5+10,M=1800010;\r\nconst LL bas=233,hsmod=(LL)100000000000031;\r\nconst int hsmsk=(1<<22)-1;\r\n\r\nLL qpow(LL x,LL y) {LL ret=1; for(;y;y>>=1,x=x*x%mod) if(y&1) ret=ret*x%mod; return ret;}\r\n\r\n/*namespace KMP\r\n{\r\n\tLL rdown(LL x,LL y) {return y<0?rdown(-x,-y):(x>0?x/y:-(-x+y-1)/y);}\r\n\tLL rup(LL x,LL y) {return -rdown(-x,y);}\r\n\t\r\n\tstruct sub\r\n\t{\r\n\t\tint s,d,cnt;\r\n\t\tsub(int S=0,int D=0,int CNT=0) {s=S;d=D;cnt=CNT;}\r\n\t\tint end()const{return s+(cnt-1)*d;}\r\n\t\tbool have(int x)const{return x>=s && x<=end() && !((x-s)%d);}\r\n\t\tint calc(const sub &t)\r\n\t\t{\r\n\t\t\tif(d==t.d) \r\n\t\t\t{\r\n\t\t\t\tif((s-t.s)%d) return 0;\r\n\t\t\t\treturn max(0,(min(end(),t.end())-max(s,t.s))/d+1);\r\n\t\t\t}\r\n\t\t\telse if(cnt==1) return t.have(s);\r\n\t\t\telse return have(t.s);\r\n\t\t}\r\n\t\tsub flip(int x) {return sub(x-(s+(cnt-1)*d),d,cnt);}\r\n\t};\r\n\t\r\n\tvector<int> fail[N],slink[N];\r\n\tvoid construct(char s[],int n,int id)\r\n\t{\r\n\t\tvector<int> &f=fail[id],&g=slink[id];\r\n\t\tf.resize(n+1);g.resize(n+1);f[0]=f[1]=0;\r\n\t\tfor(int i=2;i<=n;++i)\r\n\t\t{\r\n\t\t\tint &p=f[i];p=f[i-1];\r\n\t\t\twhile(p && s[p+1]^s[i]) p=f[p];\r\n\t\t\tif(s[p+1]==s[i]) ++p;\r\n\t\t}\r\n\t\tfor(int i=1;i<=n;++i) g[i]=(f[i]==0?0:(i-(f[i]==f[i]-f[f[i]]?g[f[i]]:f[i]) ) );\r\n\t}\r\n\t\r\n\tvector<sub> extract(int id,int x)\r\n\t{\r\n\t\tvector<int> &f=fail[id],&g=slink[id];\r\n\t\tassert(x<f.size() && x<g.size());\r\n\t\tvector<sub>ret;\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tint d=x-f[x];\r\n\t\t\tret.pb(sub(g[x]+d,d,(x-g[x])/d)); x=g[x];\r\n\t\t}\r\n\t\treverse(ret.begin(),ret.end());\r\n\t\tif(ret.back().cnt>1) ret.back().cnt--,ret.pb(sub(ret.back().end()+ret.back().d,1,1));\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tint query(int x,int xl,int y,int yl,int tot)\r\n\t{\r\n\t\tif(!xl || !yl || xl+yl<tot) return 0;\r\n\t\tvector<sub> vx=extract(x,xl),vy=extract(y,yl);\r\n\t\tfor(int i=0;i<vy.size();++i) vy[i]=vy[i].flip(tot);\r\n\t\treverse(vy.begin(),vy.end());\r\n\t\tint itx=0,ity=0,ret=0;\r\n\t\twhile(itx<vx.size() && ity<vy.size())\r\n\t\t{\r\n\t\t\tret+=vx[itx].calc(vy[ity]);\r\n\t\t\tif(vx[itx].end()<=vy[ity].end()) ++itx;\r\n\t\t\telse ++ity;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n};\r\n*/\r\n\r\nnamespace KMP\r\n{\r\n\tLL rdown(LL p,LL q){return q<0?rdown(-p,-q):(p>0?p/q:-(-p+q-1)/q);}\r\n\tLL rup(LL p,LL q){return -rdown(-p,q);}\r\n\tstruct sub\r\n\t{\r\n\t\tint s,d,cnt;//d>0\r\n\t\tsub(int S=0,int D=0,int CNT=0){s=S;d=D;cnt=CNT;}\r\n\t\tint end()const{return s+(cnt-1)*d;}\r\n\t\tbool has(int x)const{return x>=s&&x<=end()&&(x-s)%d==0;}\r\n\t\tint calc(const sub &t)\r\n\t\t{\r\n\t\t\tif(d==t.d)\r\n\t\t\t{\r\n\t\t\t\tif((s-t.s)%d!=0)return 0;\r\n\t\t\t\telse return max(0,(min(end(),t.end())-max(s,t.s))/d+1);\r\n\t\t\t}\r\n\t\t\telse if(cnt==1)return t.has(s);\r\n\t\t\telse return has(t.s);\r\n\t\t}\r\n\t\tsub flip(int x){return sub(x-(s+(cnt-1)*d),d,cnt);}\r\n\t};\r\n\tvector<int> Fail[N],Slink[N];\r\n\tvoid construct(char s[],int n,int id)\r\n\t{\r\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\r\n\t\tfail.resize(n+1);\r\n\t\tslink.resize(n+1);\r\n\t\tfail[0]=0;fail[1]=0;\r\n\t\tfor(int i=2;i<=n;i++)\r\n\t\t{\r\n\t\t\tint &p=fail[i];\r\n\t\t\tp=fail[i-1];\r\n\t\t\twhile(p&&s[p+1]!=s[i])p=fail[p];\r\n\t\t\tif(s[p+1]==s[i])p++;\r\n\t\t}\r\n\t\tfor(int i=1;i<=n;i++)slink[i]=fail[i]==0?0:(i-fail[i]==fail[i]-fail[fail[i]]?slink[fail[i]]:fail[i]);\r\n\t}\r\n\tvector<sub> extract(int id,int x)\r\n\t{\r\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\r\n\t\tassert(x<fail.size()&&x<slink.size());\r\n\t\tvector<sub> ret;\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tint d=x-fail[x];\r\n\t\t\tret.pb(sub(slink[x]+d,d,(x-slink[x])/d));\r\n\t\t\tx=slink[x];\r\n\t\t}\r\n\t\treverse(ret.begin(),ret.end());\r\n\t\tif(ret.back().cnt>1)ret.back().cnt--,ret.pb(sub(ret.back().end()+ret.back().d,1,1));\r\n\t\treturn ret;\r\n\t}\r\n\tint query(int x,int xl,int y,int yl,int tot)\r\n\t{\r\n\t\tif(xl==0||yl==0||xl+yl<tot)return 0;\r\n\t\tvector<sub> vx=extract(x,xl);\r\n\t\tvector<sub> vy=extract(y,yl);\r\n\t\tfor(int i=0;i<vy.size();i++)vy[i]=vy[i].flip(tot);\r\n\t\treverse(vy.begin(),vy.end());\r\n\t\tint itx=0,ity=0,ret=0;\r\n\t\twhile(itx<vx.size()&&ity<vy.size())\r\n\t\t{\r\n\t\t\tret+=vx[itx].calc(vy[ity]);\r\n\t\t\tif(vx[itx].end()<=vy[ity].end())itx++;\r\n\t\t\telse ity++;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n};\r\n\r\nstruct BIT\r\n{\r\n\tint bit_table[M];\r\n\tint lowbit(int x) {return x&(-x);}\r\n\tvoid add(int x,int v) {for(;x<M;x+=lowbit(x)) bit_table[x]+=v;}\r\n\tint query(int x) {int ret=0;for(;x;x-=lowbit(x)) ret+=bit_table[x];return ret;}\r\n}bit;\r\n\r\nstruct HashTable\r\n{\r\n\tint hs[hsmsk],val[hsmsk];\r\n\tHashTable(){memset(hs,-1,sizeof(hs));memset(val,-1,sizeof(val));}\r\n\tint getpos(int p){return ((p<<5)^(p>>3))&hsmsk;}\r\n\tint find(int chs)\r\n\t{\r\n\t\tint p=getpos(chs);\r\n\t\twhile(hs[p]!=-1&&hs[p]!=chs)p=(p+1)&hsmsk;\r\n\t\treturn val[p];\r\n\t}\r\n\tint& get(int chs)\r\n\t{\r\n\t\tint p=getpos(chs);\r\n\t\twhile(hs[p]!=-1&&hs[p]!=chs)p=(p+1)&hsmsk;\r\n\t\tif(hs[p]==-1)hs[p]=chs,val[p]=-1;\r\n\t\treturn val[p];\r\n\t}\r\n};\r\n\r\n/*struct HashTable\r\n{\r\n\tint hs[hsmsk],val[hsmsk];\r\n\tHashTable() {memset(hs,-1,sizeof(hs));memset(val,-1,sizeof(val));}\r\n\tint getpos(int p) {return ((p<<5)^(p>>3))&hsmsk;}\r\n\tint find(int c) {int p=getpos(c);while(~hs[p] && hs[p]^c) p=(p+1)&hsmsk; return val[p];}\r\n\tint& get(int c) \r\n\t{\r\n\t\tint p=getpos(c); while(~hs[p] && hs[p]^c) p=(p+1)&hsmsk;\r\n\t\tif(!~hs[p]) hs[p]=c,val[p]=-1; return val[p];\r\n\t} \r\n};\r\n*/\r\n\r\n/*namespace ACM\r\n{\r\n\tint tot=1,fa[M],pc[M]; LL hs[M];\r\n\tpli hsarr[M]; vector<pci> go[M];\r\n\tHashTable mp;\r\n\t\r\n\tint insert(int p,int c)\r\n\t{\r\n\t\tint &q=mp.get(p<<8|c);\r\n\t\tif(q==-1)\r\n\t\t{\r\n\t\t\tq=++tot;fa[q]=p;pc[q]=c;hs[q]=(hs[p]*bas+c+1)%hsmod;\r\n\t\t\tgo[p].pb(mkp(c,q));\r\n\t\t\tassert(tot<M);\r\n\t\t}\r\n\t\treturn q;\r\n\t}\t\r\n\t\r\n\tint ind,fail[M],idfn[M],idfnr[M];\r\n\tvector<int> con[M];\r\n\t\r\n\tvoid idfs(int x)\r\n\t{\r\n\t\tidfn[x]=++ind;\r\n\t\tfor(int i=0;i<con[x].size();++i) idfs(con[x][i]);\r\n\t\tidfnr[x]=ind;\r\n\t}\r\n\t\r\n\tint son[M],top[M],dep[M];\r\n\tset<int> st[M];\r\n\tint dfs1(int x)\r\n\t{\r\n\t\tint sz=1,mx=0;\r\n\t\tfor(int i=0;i<go[x].size();++i)\r\n\t\t{\r\n\t\t\tint v=go[x][i].se;dep[v]=dep[x]+1;\r\n\t\t\tint szv=dfs1(v);sz+=szv;\r\n\t\t\tif(szv>mx) son[x]=v,mx=szv;\r\n\t\t}\r\n\t\treturn sz;\r\n\t}\r\n\t\r\n\tvoid dfs2(int x,int tp)\r\n\t{\r\n\t\ttop[x]=tp; if(!son[x]) return;\r\n\t\tdfs2(son[x],tp);\r\n\t\tfor(int i=0;i<go[x].size();++i)\r\n\t\t{\r\n\t\t\tint v=go[x][i].se;\r\n\t\t\tif(v==son[x]) continue;\r\n\t\t\tdfs2(v,v);\t\r\n\t\t}\t\r\n\t} \r\n\t\r\n\tvoid construct() {dep[1]=0;dfs1(1);dfs2(1,1);}\r\n\tvoid flip(int x)\r\n\t{\r\n\t\tint g=top[x];\r\n\t\tif(st[g].find(dep[x])==st[g].end()) st[g].insert(dep[x]);\r\n\t\telse st[g].erase(dep[x]);\r\n\t}\r\n\t\r\n\tint query(int x)\r\n\t{\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tif(st[top[x]].size()>0 && *st[top[x]].begin()<=dep[x]) return *(--st[top[x]].lower_bound(dep[x]+1));\r\n\t\t\tx=fa[top[x]];\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tint q[M],qn;\r\n\tvoid build()\r\n\t{\r\n\t\tconstruct();\r\n\t\tfor(int i=1;i<=tot;++i) hsarr[i]=mkp(hs[i],i);\r\n\t\tsort(hsarr+1,hsarr+tot+1);qn=0;q[qn++]=1;\r\n\t\tfor(int i=0;i<qn;++i)\r\n\t\t{\r\n\t\t\tint x=q[i];\r\n\t\t\tfor(int j=0;j<go[x].size();++j)\tq[qn++]=go[x][j].se;\r\n\t\t}\r\n\t\tfail[1]=1;\r\n\t\tfor(int i=1;i<qn;++i)\r\n\t\t{\r\n\t\t\tint x=q[i],&p=fail[x];\r\n\t\t\tif(fa[x]==1) p=1;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tp=fail[fa[x]];\r\n\t\t\t\twhile(p^1 && !~mp.find(p<<8|pc[x])) p=fail[p];\r\n\t\t\t\tif(~mp.find(p<<8|pc[x])) p=mp.find(p<<8|pc[x]);\r\n\t\t\t}\r\n\t\t\tcon[fail[x]].pb(x);\r\n\t\t}\r\n\t\tidfs(1);\r\n\t}\r\n\t\r\n\tint qans[M],qans2[M];\r\n\tvector<pii> qr[M],qr2[M];\r\n\t\r\n\tvoid dfs_solve1(int x)\r\n\t{\r\n\t\tbit.add(idfn[x],1);\r\n\t\tfor(int i=0;i<qr[x].size();++i)\r\n\t\t{\r\n\t\t\tint pos=qr[x][i].fi;\r\n\t\t\tqans[qr[x][i].se]+=bit.query(idfnr[pos])-bit.query(idfn[pos]-1);\r\n\t\t}\r\n\t\tfor(int i=0;i<go[x].size();++i) dfs_solve1(go[x][i].se);\r\n\t\tbit.add(idfn[x],-1);\r\n\t}\r\n\t\r\n\tvoid dfs_solve2(int x,LL hs=0,LL hsbs=1)\r\n\t{\r\n\t\tint p=lower_bound(hsarr+1,hsarr+tot+1,mkp(hs,0))-hsarr;\r\n\t\tif(hsarr[p].fi==hs) flip(hsarr[p].se);\r\n\t\tfor(int i=0;i<qr2[x].size();++i) qans2[qr2[x][i].se]=query(qr2[x][i].fi);\r\n\t\tfor(int i=0;i<go[x].size();++i) dfs_solve2(go[x][i].se,(hs+hsbs*(go[x][i].fi+1))%hsmod,hsbs*bas%hsmod);\r\n\t\tif(hsarr[p].fi==hs) flip(hsarr[p].se);\r\n\t}\r\n\t\r\n\tvoid add_query(int ui,int vi,int si,int ti,int id)\r\n\t{\r\n\t\tqr[ui].pb(mkp(ti,id));qr[vi].pb(mkp(si,id));\r\n\t\tqr2[si].pb(mkp(ui,id<<1));qr2[ti].pb(mkp(vi,id<<1|1));\r\n\t}\r\n\t\r\n\tpiii get_query(int id) {return mkp(qans[id],mkp(qans2[id<<1],qans2[id<<1|1]));}\r\n\t\r\n\tvoid solve()\r\n\t{\r\n\t\tmemset(qans,0,sizeof(qans));\r\n\t\tdfs_solve1(1);dfs_solve2(1);\r\n\t}\r\n};\r\n*/\r\n\r\nnamespace ACM\r\n{\r\n\t//TRIE\r\n\tint tot=1;\r\n\tvector<pair<char,int> > go[M];\r\n\tHashTable gomp;\r\n\tLL hs[M];\r\n\tint fa[M],pc[M];\r\n\tpair<LL,int> hs_arr[M];\r\n\t\r\n\tint insert(int p,int c)\r\n\t{\r\n\t\tint &q=gomp.get(p<<8|c);\r\n\t\tif(q==-1)\r\n\t\t{\r\n\t\t\tq=++tot,fa[q]=p,pc[q]=c,hs[q]=(hs[p]*bas+c+1)%hsmod;\r\n\t\t\tgo[p].pb(mkp(c,q));\r\n\t\t\tassert(tot<M);\r\n\t\t}\r\n\t\treturn q;\r\n\t}\r\n\tint fail[M];\r\n\tvector<int> con[M];//store fail tree\r\n\tint fdfn[M],fdfnr[M],dfntot;\r\n\tvoid fdfs(int x)\r\n\t{\r\n\t\tfdfn[x]=++dfntot;\r\n\t\tfor(int i=0;i<con[x].size();i++)\r\n\t\t{\r\n\t\t\tint u=con[x][i];\r\n\t\t\tfdfs(u);\r\n\t\t}\r\n\t\tfdfnr[x]=dfntot;\r\n\t}\r\n\t\r\n\t//HLD\r\n\tint son[M],top[M],lv[M];\r\n\tset<int> st[M];\r\n\tint dfs(int x)\r\n\t{\r\n\t\tint sz=1,mx=0;\r\n\t\tson[x]=0;\r\n\t\tfor(int t=0;t<go[x].size();t++)\r\n\t\t{\r\n\t\t\tint u=go[x][t].se;\r\n\t\t\tlv[u]=lv[x]+1;\r\n\t\t\tint szu=dfs(u);\r\n\t\t\tsz+=szu;\r\n\t\t\tif(szu>mx)son[x]=u,mx=szu;\r\n\t\t}\r\n\t\treturn sz;\r\n\t}\r\n\tvoid dfs2(int x,int tp)\r\n\t{\r\n\t\ttop[x]=tp;\r\n\t\tif(son[x])dfs2(son[x],tp);\r\n\t\tfor(int t=0;t<go[x].size();t++)\r\n\t\t{\r\n\t\t\tint u=go[x][t].se;\r\n\t\t\tif(u==son[x])continue;\r\n\t\t\tdfs2(u,u);\r\n\t\t}\r\n\t}\r\n\tvoid construct_HLD()\r\n\t{\r\n\t\tlv[1]=0;\r\n\t\tdfs(1);\r\n\t\tdfs2(1,1);\r\n\t}\r\n\tvoid HLDflip(int x)\r\n\t{\r\n\t\tint g=top[x];\r\n\t\tif(st[g].find(lv[x])==st[g].end())st[g].insert(lv[x]);\r\n\t\telse st[g].erase(lv[x]);\r\n\t}\r\n\tint HLDquery(int x)\r\n\t{\r\n\t\twhile(x)\r\n\t\t{\r\n\t\t\tif(st[top[x]].size()>0&&*st[top[x]].begin()<=lv[x])return *(--st[top[x]].lower_bound(lv[x]+1));\r\n\t\t\tx=fa[top[x]];\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tint q[M],qn;\r\n\tvoid construct()\r\n\t{\r\n\t\tconstruct_HLD();\r\n\t\tfor(int i=1;i<=tot;i++)hs_arr[i]=mkp(hs[i],i);\r\n\t\tsort(hs_arr+1,hs_arr+tot+1);\r\n\t\tqn=0;q[qn++]=1;\r\n\t\tfor(int i=0;i<qn;i++)\r\n\t\t{\r\n\t\t\tint x=q[i];\r\n\t\t\tfor(int j=0;j<go[x].size();j++)\r\n\t\t\t{\r\n\t\t\t\tq[qn++]=go[x][j].se;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfail[1]=1;\r\n\t\tfor(int i=1;i<qn;i++)\r\n\t\t{\r\n\t\t\tint x=q[i];\r\n\t\t\tint &p=fail[x];\r\n\t\t\tif(fa[x]==1)p=1;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tp=fail[fa[x]];\r\n\t\t\t\twhile(p!=1&&gomp.find(p<<8|pc[x])==-1)p=fail[p];\r\n\t\t\t\tif(gomp.find(p<<8|pc[x])!=-1)p=gomp.find(p<<8|pc[x]);\r\n\t\t\t}\r\n\t\t\tcon[fail[x]].pb(x);\r\n\t\t}\r\n\t\tfdfs(1);\r\n\t}\r\n\tint qans[M],qans2[M];\r\n\tvector<pair<int,int> > qr[M],qr2[M];\r\n\tvoid dfs_solve_p1(int x)\r\n\t{\r\n\t\tbit.add(fdfn[x],1);\r\n\t\tfor(int i=0;i<qr[x].size();i++)\r\n\t\t{\r\n\t\t\tint pos=qr[x][i].fi;\r\n\t\t\tqans[qr[x][i].se]+=bit.query(fdfnr[pos])-bit.query(fdfn[pos]-1);\r\n\t\t}\r\n\t\tfor(int i=0;i<go[x].size();i++)dfs_solve_p1(go[x][i].se);\r\n\t\tbit.add(fdfn[x],-1);\r\n\t}\r\n\tvoid dfs_solve_p2(int x,LL hs=0,LL hs_bs=1)\r\n\t{\r\n\t\tint p=lower_bound(hs_arr+1,hs_arr+tot+1,mkp(hs,0))-hs_arr;\r\n\t\tif(hs_arr[p].fi==hs)HLDflip(hs_arr[p].se);\r\n\t\tfor(int i=0;i<qr2[x].size();i++)\r\n\t\t{\r\n\t\t\tqans2[qr2[x][i].se]=HLDquery(qr2[x][i].fi);\r\n\t\t}\r\n\t\tfor(int i=0;i<go[x].size();i++)dfs_solve_p2(go[x][i].se,(hs+hs_bs*(go[x][i].fi+1))%hsmod,hs_bs*bas%hsmod);\r\n\t\tif(hs_arr[p].fi==hs)HLDflip(hs_arr[p].se);\r\n\t}\r\n\tvoid add_query(int ui,int vi,int si,int ti,int id)\r\n\t{\r\n\t\tqr[ui].pb(mkp(ti,id));\r\n\t\tqr[vi].pb(mkp(si,id));\r\n\t\tqr2[si].pb(mkp(ui,id*2));\r\n\t\tqr2[ti].pb(mkp(vi,id*2+1));\r\n\t}\r\n\tpair<int,pair<int,int> > get_query(int id)\r\n\t{\r\n\t\treturn mkp(qans[id],mkp(qans2[id*2],qans2[id*2+1]));\r\n\t}\r\n\tvoid solve()\r\n\t{\r\n\t\tmemset(qans,0,sizeof(qans));\r\n\t\tdfs_solve_p1(1);\r\n\t\tdfs_solve_p2(1);\r\n\t}\r\n};\r\n\r\nnamespace solution\r\n{\r\n\tint n,m,q,cur_rt,cur_dp,an;\r\n\tint qu[N],qv[N],qx[N],uid[N],vid[N];\r\n\tint dp[N],siz[N],arr[N],gr[N],id[N];\r\n\tchar s[N];\r\n\tvector<pic>con[N]; vector<pii>qr[N]; vector<int> sid[N];\r\n\t\r\n\tvoid pdfs(int x,int f=-1)\r\n\t{\r\n\t\tsiz[x]=1;arr[an++]=x;dp[x]=cur_dp+1;\r\n\t\tfor(int i=0;i<con[x].size();++i)\r\n\t\t{\r\n\t\t\tint v=con[x][i].fi;\r\n\t\t\tif(v==f || dp[v]<cur_dp) continue;\r\n\t\t\tpdfs(v,x);siz[x]+=siz[v];\r\n\t\t}\r\n\t}\r\n\t\r\n\tint findroot(int x)\r\n\t{\r\n\t\tan=0;pdfs(x); int ret=x;\r\n\t\tfor(int i=0;i<an;++i) if(siz[arr[i]]*2>=siz[x] && siz[arr[i]]<siz[ret]) ret=arr[i];\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tvoid dfs(int x,int f,int g)\r\n\t{\r\n\t\tgr[x]=g;\r\n\t\tfor(int i=0;i<con[x].size();++i)\r\n\t\t{\r\n\t\t\tint v=con[x][i].fi;\r\n\t\t\tif(v==f || dp[v]<cur_dp) continue;\r\n\t\t\tid[v]=ACM::insert(id[x],con[x][i].se-'a');\r\n\t\t\tdfs(v,x,f==-1?v:g);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid solve(int X,int d)\r\n\t{\r\n\t\tcur_dp=d;int rt=findroot(X);cur_rt=rt;\r\n\t\tdp[rt]=d;id[rt]=1;dfs(rt,-1,rt);\r\n\t\tstatic bool vis[N];\r\n\t\tfor(int i=0;i<an;++i) vis[arr[i]]=1;\r\n\t\tfor(int i=0;i<an;++i)\r\n\t\t{\r\n\t\t\tint x=arr[i];\r\n\t\t\tfor(int j=0;j<qr[x].size();++j)\r\n\t\t\t{\r\n\t\t\t\tint y=qr[x][j].fi;\r\n\t\t\t\tif(vis[y] && gr[y]^gr[x]) uid[qr[x][j].se]=id[x],vid[qr[x][j].se]=id[y];\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i=0;i<an;++i) vis[arr[i]]=0;\r\n\t\tfor(int i=0;i<con[rt].size();++i)\r\n\t\t{\r\n\t\t\tint v=con[rt][i].fi;\r\n\t\t\tif(dp[v]<d) continue;\r\n\t\t\tsolve(v,d+1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid end_of_the_world()\r\n\t{\r\n\t\tscanf(\"%d%d%d\",&n,&m,&q);\r\n\t\tfor(int i=1;i<n;++i)\r\n\t\t{\r\n\t\t\tint u,v;char c[2]; scanf(\"%d%d%s\",&u,&v,c);\r\n\t\t\tcon[u].pb(mkp(v,c[0]));con[v].pb(mkp(u,c[0]));\r\n\t\t}\r\n\t\tfor(int i=1;i<=m;++i)\r\n\t\t{\r\n\t\t\tscanf(\"%s\",s+1);int l=strlen(s+1),p=1; sid[i].pb(1);\r\n\t\t\tfor(int j=1;j<=l;++j) p=ACM::insert(p,s[j]-'a'),sid[i].pb(p);\r\n\t\t\tKMP::construct(s,l,i); \r\n\t\t\treverse(s+1,s+l+1);p=1;sid[i+m].pb(1);\r\n\t\t\tfor(int j=1;j<=l;++j) p=ACM::insert(p,s[j]-'a'),sid[i+m].pb(p);\r\n\t\t\tKMP::construct(s,l,i+m);\r\n\t\t}\r\n\t\tfor(int i=1;i<=q;++i)\r\n\t\t{\r\n\t\t\tint u,v,x;scanf(\"%d%d%d\",&u,&v,&x);\r\n\t\t\tqr[u].pb(mkp(v,i));qu[i]=u;qv[i]=v;qx[i]=x;\r\n\t\t}\r\n\t\tsolve(1,0);\r\n\t\tACM::construct();\r\n\t\tfor(int i=1;i<=q;++i) ACM::add_query(uid[i],vid[i],sid[qx[i]].back(),sid[qx[i]+m].back(),i);\r\n\t\tACM::solve();\r\n\t\tfor(int i=1;i<=q;++i) piii pp=ACM::get_query(i);\r\n\t\tfor(int i=1;i<=q;++i)\r\n\t\t{\r\n\t\t\tpiii pp=ACM::get_query(i);int ans=pp.fi;\r\n\t\t\tans+=KMP::query(qx[i],pp.se.fi,qx[i]+m,pp.se.se,sid[qx[i]].size()-1);\r\n\t\t\tprintf(\"%d\\n\",ans);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n#ifndef ONLINE_JUDGE\r\n\tfreopen(\"CF917E.in\",\"r\",stdin);\r\n\tfreopen(\"CF917E.out\",\"w\",stdout);\r\n#endif\r\n\tsolution::end_of_the_world();\r\n\r\n\treturn 0;\r\n}"
}