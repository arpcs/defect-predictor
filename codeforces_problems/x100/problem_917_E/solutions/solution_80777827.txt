{
    "id": 80777827,
    "contestId": 917,
    "creationTimeSeconds": 1589982441,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "Warriors_fsy"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 17,
    "timeConsumedMillis": 670,
    "memoryConsumedBytes": 392704000,
    "source": "#include<bits/stdc++.h>\r\n#define cs const\r\n#define pb push_back\r\n#define fi first\r\n#define se second\r\n#define mp make_pair\r\nusing namespace std;\r\ntypedef long long ll;\r\nnamespace IO{\r\n\tcs int Rlen=1<<22|1;\r\n\tinline char gc(){\r\n\t\tstatic char buf[Rlen],*p1,*p2;\r\n\t\t(p1==p2)&&(p2=(p1=buf)+fread(buf,1,Rlen,stdin));\r\n\t\treturn p1==p2?EOF:*p1++;\r\n\t} int read(){\r\n\t\tint x=0; char c=gc(); bool f=false;\r\n\t\twhile(!isdigit(c)) f=c=='-', c=gc();\r\n\t\twhile(isdigit(c)) x=(((x<<2)+x)<<1)+(c^48), c=gc();\r\n\t\treturn f?-x:x;\r\n\t} int str(){\r\n\t\tchar c=gc(); while(isspace(c)) c=gc();\r\n\t\treturn c-'a';\r\n\t} int Str(char *S){\r\n\t\tchar c=gc(); while(isspace(c)) c=gc();\r\n\t\tint len=0; while('a'<=c&&c<='z') S[++len]=c, c=gc(); \r\n\t\treturn len;\r\n\t}\r\n} using namespace IO;\r\n// Hash work \r\ntypedef pair<int, int> pi;\r\ncs int N = 2e5 + 50;\r\ncs int M1 = 1e9 + 7, M2 = 998244353;\r\ncs int B1 = 19260817, B2 = 17680321;\r\nint add(int a, int b, int mod){ return a + b >= mod ? a + b - mod : a + b; }\r\nint dec(int a, int b, int mod){ return a - b < 0 ? a - b + mod : a - b; }\r\nint mul(int a, int b, int mod){ return 1ll * a * b % mod; }\r\npi operator + (pi a, pi b){ return mp(add(a.fi,b.fi,M1), add(a.se,b.se,M2)); }\r\npi operator - (pi a, pi b){ return mp(dec(a.fi,b.fi,M1), dec(a.se,b.se,M2)); }\r\npi operator * (pi a, pi b){ return mp(mul(a.fi,b.fi,M1), mul(a.se,b.se,M2)); }\r\nbool operator == (pi a, pi b){ return a.fi == b.fi && a.se == b.se; }\r\npi pw[N]; void init_pw(int n){\r\n\tpw[0]=mp(1,1); pw[1]=mp(B1,B2);\r\n\tfor(int i=2; i<=n; i++) pw[i] = pw[i-1] * pw[1];\r\n}\r\nint n, m, q, len[N], ps[N][2]; char tmp[N];\r\nstruct dat{ int l, r, dt; };\r\nstruct AC_Automaton{\r\n\tint ch[N][26], nd, fail[N];\r\n\tint ins(char *S, int len){\r\n\t\tint u=0; for(int i=1,c; i<=len; i++){ c=S[i]-'a'; \r\n\t\tif(!ch[u][c]) ch[u][c]=++nd; u=ch[u][c]; } return u;\r\n\t} int in[N], out[N], sgn; vector<int> G[N];\r\n\tvoid dfs(int u){\r\n\t\tin[u]=++sgn; for(int e=0,v; e<(int)G[u].size(); e++)\r\n\t\t{ v=G[u][e]; dfs(v); } out[u]=sgn;\r\n\t} void build(){\r\n\t\tqueue<int> q; for(int i=0; i<26; i++) if(ch[0][i]) q.push(ch[0][i]);\r\n\t\twhile(!q.empty()){\r\n\t\t\tint x=q.front(); q.pop(); for(int i=0; i<26; i++)\r\n\t\t\tif(ch[x][i]) fail[ch[x][i]]=ch[fail[x]][i],q.push(ch[x][i]);\r\n\t\t\telse ch[x][i]=ch[fail[x]][i];\r\n\t\t} for(int i=1; i<=nd; i++) G[fail[i]].pb(i); dfs(0);\r\n\t}\r\n} AC[2];\r\nstruct BIT{\r\n\tint c[N], n;\r\n\tvoid add(int x, int v){ for(;x<=n;x+=x&-x) c[x]+=v; }\r\n\tint ask(int x){ int as=0; for(;x;x-=x&-x) as+=c[x]; return as; }\r\n\tint ask(int l, int r){ return ask(r)-ask(l-1); }\r\n} bit[2];\r\n// Part tree \r\nvector<pi> G[N];\r\nint an[N][22], o[N], dep[N], lg[N], Ans[N];\r\npi h[N]; // up to down \r\npi Has(int u, int v){ return h[u] - h[v] * pw[dep[u]-dep[v]]; }\r\nvoid dfs(int u, int fa){\r\n\tdep[u]=dep[fa]+1; an[u][0]=fa;\r\n\tfor(int i=1; i<=lg[dep[u]]; i++)\r\n\tan[u][i]=an[an[u][i-1]][i-1];\r\n\tfor(int e=0,v,c; e<(int)G[u].size(); e++)\r\n\tif((v=G[u][e].fi)!=fa){\r\n\t\tc=G[u][e].se; o[v]=c;\r\n\t\th[v]=h[u]*pw[1]+mp(c,c); dfs(v,u);\r\n\t}\r\n} int LCA(int x, int y){\r\n\tif(dep[x]<dep[y]) swap(x,y);\r\n\tfor(int i=lg[dep[x]];~i;i--) \r\n\tif(dep[an[x][i]]>=dep[y]) x=an[x][i]; if(x==y) return x;\r\n\tfor(int i=lg[dep[x]];~i;i--) \r\n\tif(an[x][i]!=an[y][i]) x=an[x][i], y=an[y][i];\r\n\treturn an[x][0];\r\n} int jmp(int x, int d){\r\n\tif(!d) return x; for(int i=lg[d];~i;i--)\r\n\tif(d>=(1<<i)) x=an[x][i], d-=1<<i; return x;\r\n}\r\nstruct qry{ int op, p, c; };\r\nvector<qry> ql[N], qr[N];\r\nvoid cope(int u, int fa, int nx, int ny){\r\n\tbit[0].add(AC[0].in[nx],1);\r\n\tbit[1].add(AC[1].in[ny],1);\r\n\tfor(int i=0; i<(int)qr[u].size(); i++){\r\n\t\tqry x = qr[u][i]; int pt = ps[x.p][0];\r\n\t\tAns[x.c] += x.op * bit[0].ask(AC[0].in[pt], AC[0].out[pt]);\r\n\t}\r\n\tfor(int i=0; i<(int)ql[u].size(); i++){\r\n\t\tqry x = ql[u][i]; int pt = ps[x.p][1];\r\n\t\tAns[x.c] += x.op * bit[1].ask(AC[1].in[pt], AC[1].out[pt]);\r\n\t} \r\n\tfor(int e=0,v; e<(int)G[u].size(); e++) if((v=G[u][e].fi)!=fa) \r\n\tcope(v,u,AC[0].ch[nx][G[u][e].se],AC[1].ch[ny][G[u][e].se]);\r\n\tbit[0].add(AC[0].in[nx],-1);\r\n\tbit[1].add(AC[1].in[ny],-1);\r\n}\r\nstruct Suffix_Array{\r\n\tint n, m; string S;\r\n\tint *SA, *rk, *y, *tmp, *bin; // suffix array \r\n\tpi *h; // hash\r\n\tint *nxt[22], *trs; // border \r\n\tvoid copy(char *t, int len){\r\n\t\tn = len; S = ' ';\r\n\t\tfor(int i=1; i<=n; i++) S += t[i];\r\n\t}\r\n\tvoid Kmp_work(){\r\n\t\tfor(int i=1; i+i<=n; i++) if(i<n-i+1) swap(S[i],S[n-i+1]);\r\n\t\tfor(int i=0; i<=lg[n]; i++) nxt[i] = new int[n+1](); \r\n\t\tfor(int i=2,j=0; i<=n; i++){\r\n\t\t\twhile(j && S[j+1]!=S[i]) j = nxt[0][j];\r\n\t\t\tif(S[j+1] == S[i]) ++j; nxt[0][i] = j;\r\n\t\t} for(int j=1; j<=lg[n]; j++)\r\n\t\tfor(int i=1; i<=n; i++) nxt[j][i]=nxt[j-1][nxt[j-1][i]];\r\n\t\ttrs = new int[n+1]();\r\n\t\tfor(int i=1; i<=n; i++){\r\n\t\t\tif(nxt[0][i] && i-nxt[0][i] == nxt[0][i]-nxt[0][nxt[0][i]]) \r\n\t\t\ttrs[i] = trs[nxt[0][i]]; else trs[i] = i;\r\n\t\t} for(int i=1; i+i<=n; i++) if(i<n-i+1) swap(S[i],S[n-i+1]);\r\n\t}\r\n\tvoid Hash_work(){\r\n\t\th = new pi[n+1](); for(int i=1; i<=n; i++) \r\n\t\th[i] = h[i-1] * pw[1] + mp(S[i]-'a',S[i]-'a');\r\n\t}\r\n\tvoid radix_sort(){\r\n\t\tfor(int i=0; i<=m; i++) bin[i]=0;\r\n\t\tfor(int i=1; i<=n; i++) ++bin[rk[i]];\r\n\t\tfor(int i=1; i<=m; i++) bin[i]+=bin[i-1];\r\n\t\tfor(int i=n; i; i--) SA[bin[rk[y[i]]]--]=y[i];\r\n\t}\r\n\tvoid build(){\r\n\t\tm = 128; SA = new int[n+1](); rk = new int[n+1]();\r\n\t\ttmp = new int[n+1](); y = new int[n+1](); \r\n\t\tbin = new int[max(n+1,1<<8)]();\r\n\t\tfor(int i=1; i<=n; i++) rk[i]=S[i], y[i]=i; \r\n\t\tradix_sort(); for(int k=1; k<=n; k<<=1){\r\n\t\t\tint ct=0; for(int i=n-k+1; i<=n; i++) y[++ct]=i;\r\n\t\t\tfor(int i=1; i<=n; i++) if(SA[i]>k) y[++ct]=SA[i]-k;\r\n\t\t\tradix_sort(); swap(rk,tmp); rk[SA[1]]=1; int num=1;\r\n\t\t\tfor(int i=2; i<=n; i++){\r\n\t\t\t\tif(tmp[SA[i]]==tmp[SA[i-1]] && tmp[SA[i]+k]==tmp[SA[i-1]+k])\r\n\t\t\t\trk[SA[i]] = num; else rk[SA[i]] = ++num;\r\n\t\t\t} m = num;\r\n\t\t}\r\n\t}\r\n\tpi Get(int l, int r){ return h[r] - h[l-1] * pw[r-l+1]; }\r\n\tint lcp(int u, int v, int p){\r\n\t\tint as=0, l=1, r=min(n-p+1,dep[u]-dep[v]);\r\n\t\twhile(l<=r){\r\n\t\t\tint mid=(l+r)>>1;\r\n\t\t\tif(Has(jmp(u,dep[u]-dep[v]-mid),v)==Get(p,p+mid-1))\r\n\t\t\tl=mid+1, as=mid; else r=mid-1;\r\n\t\t} return as;\r\n\t}\r\n\tbool chk(int u, int v, int p){\r\n\t\tint len=lcp(u,v,SA[p]); \r\n\t\tif(len==dep[u]-dep[v]) return false;\r\n\t\tint nx=jmp(u,dep[u]-dep[v]-len-1); \r\n\t\treturn o[nx]>=S[SA[p]+len]-'a';\r\n\t}\r\n\tint fnd(int u, int v){\r\n\t\tint l=1, r=n; while(l<r){\r\n\t\t\tint mid=(l+r+1)>>1; \r\n\t\t\tif(chk(u,v,mid)) l=mid; else r=mid-1;\r\n\t\t} int pt = SA[l], mx = lcp(u,v,pt);\r\n\t\tif(l<n && lcp(u,v,SA[l+1])>mx) \r\n\t\tpt=SA[l+1], mx=lcp(u,v,pt); \r\n\t\tif(mx==0) return 0; \r\n\t\tif(mx==n-pt+1) return n-pt+1; \r\n\t\tfor(int i=lg[n];~i;i--){\r\n\t\t\tint np=n-nxt[i][n-pt+1]+1; \r\n\t\t\tif(!np) continue;\r\n\t\t\tif(lcp(u,v,np)!=n-np+1) pt=np;\r\n\t\t} return nxt[0][n-pt+1];\r\n\t} \r\n\tvoid fnd_border(int pt, vector<dat>&S){\r\n\t\twhile(pt){\r\n\t\t\tint np = trs[pt]; \r\n\t\t\tif(pt==np) S.pb((dat){np,pt,0});\r\n\t\t\telse S.pb((dat){np,pt,pt-nxt[0][pt]}); \r\n\t\t\tpt = nxt[0][np];\r\n\t\t} \r\n\t}\r\n} My[N][2];\r\nnamespace Yolanda{\r\nll x, y;\r\nint exgcd(int a, int b){\r\n\tif(!b) return x=1,y=0,a;\r\n\tint gc=exgcd(b,a%b); ll tx=y, ty=x-(ll)a/b*y;\r\n\tx=tx; y=ty; return gc;\r\n}\r\nint ex_work(dat a, dat b, int len){\r\n\tint c = b.l + a.r - len;\r\n\tint u1 = (a.r - a.l) / a.dt, u2 = (b.r - b.l) / b.dt;\r\n\tint gc = exgcd(a.dt, b.dt);\r\n\tif(abs(c) % gc) return 0;\r\n\tx = x * c / gc;\r\n\ty = y * c / gc; y = -y;\r\n\tint t1 = b.dt / gc, t2 = a.dt / gc;\r\n\tll dl = max((-x) / t1, (-y) / t2), dr = min((u1 - x) / t1, (u2 - y) / t2);\r\n\tif(x > u1) dr = min(dr, (u1 - x + 1) / t1 - 1);\r\n\tif(y > u2) dr = min(dr, (u2 - x + 1) / t2 - 1);\r\n \tif(x < 0) dl = max(dl, (-x - 1) / t1 + 1);\r\n\tif(y < 0) dl = max(dl, (-y - 1) / t2 + 1);\r\n\treturn max(0ll, dr - dl + 1);\r\n}\r\nint work(int u, int v, int l, int p){\r\n\tint len = My[p][0].n;\r\n\tint up = My[p][1].fnd(u,l);\r\n\tint vp = My[p][0].fnd(v,l);\r\n\tif(!up||!vp) return 0;\r\n\tvector<dat> S, T; int as = 0;\r\n\tMy[p][0].fnd_border(up,S);\r\n\tMy[p][1].fnd_border(vp,T);\r\n\tfor(int i=0; i<S.size(); i++)\r\n\tfor(int j=0; j<T.size(); j++){\r\n\t\tdat a = S[i], b = T[j];\r\n\t\tif(a.r + b.r < len) break;\r\n\t\tif(a.dt == 0 && b.dt == 0){ if(a.l + b.l == len) ++as; continue; } \r\n\t\tif(a.dt == 0){ int c=len-a.l; if(b.l<=c&&c<=b.r&&(c-b.l)%b.dt==0) ++as; continue; } \r\n\t\tif(b.dt == 0){ int c=len-b.r; if(a.l<=c&&c<=a.r&&(c-a.l)%a.dt==0) ++as; continue; }\r\n\t\tif(a.dt == b.dt){\r\n\t\t\tint c=len-a.r;\r\n\t\t\tif(abs(b.l-c) % a.dt == 0){\r\n\t\t\t\tint tl = max(c,b.l), tr = min(len-a.l, b.r);\r\n\t\t\t\tif(tl<=tr) as += (tr-tl)/a.dt+1;\r\n\t\t\t}\r\n\t\t} else as += ex_work(a,b,len);\r\n\t} return as;\r\n}\r\n}\r\nint main(){\r\n\t#ifdef FSYolanda\r\n\tfreopen(\"tree.in\",\"r\",stdin);\r\n\tfreopen(\"tree.out\",\"w\",stdout);\r\n\t#endif\r\n\tn=read(), m=read(), q=read(); init_pw(n);\r\n\tfor(int i=2; i<N; i++) lg[i]=lg[i>>1]+1;\r\n\tfor(int i=1,u,v,c; i<n; i++)\r\n\tu=read(), v=read(), c=str(), \r\n\tG[u].pb(mp(v,c)), G[v].pb(mp(u,c)); dfs(1,0); \r\n\tfor(int i=1; i<=m; i++){\r\n\t\tlen[i]=Str(tmp); My[i][0].copy(tmp,len[i]);\r\n\t\tps[i][0]=AC[0].ins(tmp,len[i]);\r\n\t\treverse(tmp+1,tmp+len[i]+1); My[i][1].copy(tmp,len[i]);\r\n\t\tps[i][1]=AC[1].ins(tmp,len[i]);\r\n\t}\t\r\n\tAC[0].build();\r\n\tAC[1].build();\r\n\tbit[0].n = AC[0].sgn;\r\n\tbit[1].n = AC[1].sgn;\r\n\tfor(int i=1; i<=m; i++)\r\n\tMy[i][0].build(), My[i][1].build(),\r\n\tMy[i][0].Hash_work(), My[i][1].Hash_work(),\r\n\tMy[i][0].Kmp_work(), My[i][1].Kmp_work();\r\n\tfor(int i=1,u,v,p,x; i<=q; i++){\r\n\t\tu=read(), v=read(), p=read();\r\n\t\tint l = LCA(u,v); \r\n\t\tif(dep[u] - dep[l] >= len[p]){\r\n\t\t\tx = jmp(u, dep[u] - dep[l] - len[p] + 1);\r\n\t\t\tql[u].pb((qry){1,p,i});\r\n\t\t\tql[x].pb((qry){-1,p,i});\r\n\t\t} if(dep[v] - dep[l] >= len[p]){\r\n\t\t\tx = jmp(v, dep[v] - dep[l] - len[p] + 1);\r\n\t\t\tqr[v].pb((qry){1,p,i});\r\n\t\t\tqr[x].pb((qry){-1,p,i});\r\n\t\t} if(u!=l && v!=l) Ans[i] += Yolanda :: work(u,v,l,p);\r\n\t\tassert(Ans[i]>=0);\r\n\t} cope(1,0,0,0);\r\n\tfor(int i=1; i<=q; i++) cout<<Ans[i]<<'\\n', assert(Ans[i]>=0);\r\n\treturn 0;\r\n}\r\n"
}