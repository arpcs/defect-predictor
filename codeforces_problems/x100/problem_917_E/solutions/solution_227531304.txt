{
    "id": 227531304,
    "contestId": 917,
    "creationTimeSeconds": 1696939920,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "L7-56"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1902,
    "memoryConsumedBytes": 101683200,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef double db;\r\ntypedef pair <int, int> pii;\r\ntypedef pair <ll, ll> pll;\r\n#define fir first\r\n#define sec second\r\ntypedef vector <int> vi;\r\ntypedef vector <ll> vl;\r\n\r\n#ifdef LCX\r\n#define msg(args...) fprintf(stderr, args)\r\n#else\r\n#define msg(...) void()\r\n#endif\r\n\r\n#define Memset(a, b) (memset((a), (b), sizeof (a)))\r\nint sgn(int x) {\r\n    if (x > 0) return 1;\r\n    if (x < 0) return -1;\r\n    return 0;\r\n}\r\nstring rev(string s) { reverse(begin(s), end(s)); return s; }\r\n\r\nll TIM, CNT;\r\n\r\nconst int maxn = 2e5 + 10, SIGMA = 26;\r\nint n, m, q, ans[maxn];\r\nstring s[maxn];\r\nstruct Query {\r\n    int x, y, z, p;\r\n} a[maxn];\r\n\r\nstruct BIT {\r\n    int c[maxn], n;\r\n    void init(int _n) { n = _n, fill(c, c + n + 1, 0); }\r\n    void add(int x, int y) {\r\n        // msg(\"add %d %d\\n\", x, y);\r\n        for (; x <= n; x += x & -x) c[x] += y;\r\n    }\r\n    void add(int l, int r, int x) { add(l, x), add(r + 1, -x); }\r\n    int ask(int x) {\r\n        int res = 0;\r\n        for (; x > 0; x &= x - 1) res += c[x];\r\n        return res;\r\n    }\r\n    int ask(int l, int r) {\r\n        // msg(\"ask [%d, %d] %d\\n\", l, r, ask(r) - ask(l - 1));\r\n        return ask(r) - ask(l - 1);\r\n    }\r\n} tr;\r\n\r\nnamespace Tree {\r\nvoid add(int u, int v, int c);\r\nint lca(int x, int y);\r\nint jump(int u, int k);\r\nvoid build();\r\n\r\nvector <pii> e[maxn];\r\nvoid add(int u, int v, int c) {\r\n    e[u].push_back({v, c});\r\n    e[v].push_back({u, c});\r\n}\r\n\r\nconst int B = 20;\r\nint fa[B][maxn], dep[maxn], w[maxn];\r\nvoid dfs(int u, int pre) {\r\n    fa[0][u] = pre, dep[u] = dep[pre] + 1;\r\n    for (int i = 1; i < B; ++i)\r\n        fa[i][u] = fa[i - 1][fa[i - 1][u]];\r\n    for (pii p : e[u]) {\r\n        int v = p.fir;\r\n        if (v == pre) continue;\r\n        w[v] = p.sec, dfs(v, u);\r\n    }\r\n}\r\nint lca(int x, int y) {\r\n    if (dep[x] < dep[y]) swap(x, y);\r\n    for (int i = B - 1; i >= 0; --i)\r\n        if (dep[x] - dep[y] >= (1 << i)) x = fa[i][x];\r\n    if (x == y) return x;\r\n    for (int i = B - 1; i >= 0; --i)\r\n        if (fa[i][x] != fa[i][y]) x = fa[i][x], y = fa[i][y];\r\n    return fa[0][x];\r\n}\r\nint jump(int u, int k) {\r\n    for (int i = B - 1; i >= 0; --i)\r\n        if ((k >> i) & 1) u = fa[i][u];\r\n    return u;\r\n}\r\n\r\nvoid build() {\r\n    dfs(1, 0);\r\n}\r\n}\r\n\r\nnamespace Solve1 {\r\nvoid work();\r\n\r\nnamespace ACAM {\r\nvoid init();\r\nint ins(string s);\r\nvoid build();\r\n\r\nint trie[maxn][SIGMA], tot;\r\nvoid init() { Memset(trie, 0), tot = 1; }\r\n\r\nint ins(string s) {\r\n    int u = 1;\r\n    for (char ch : s) {\r\n        int c = ch - 'a';\r\n        if (!trie[u][c]) trie[u][c] = ++tot;\r\n        u = trie[u][c];\r\n    }\r\n    return u;\r\n}\r\n\r\nvoid print() {\r\n    msg(\"Trie:\\n\");\r\n    for (int i = 1; i <= tot; ++i) {\r\n        msg(\"%d:\\n\", i);\r\n        for (int c = 0; c < SIGMA; ++c)\r\n            if (trie[i][c]) msg(\"-%c>%d\\n\", c + 'a', trie[i][c]);\r\n    }\r\n    msg(\"--------\\n\");\r\n}\r\n\r\nint fail[maxn];\r\nvi e[maxn];\r\nint st[maxn], ed[maxn], idx;\r\nvoid dfs(int u) {\r\n    st[u] = ++idx;\r\n    for (int v : e[u]) dfs(v);\r\n    ed[u] = idx;\r\n}\r\nvoid build() {\r\n    // print();\r\n    queue <int> q;\r\n    for (int i = 0; i < SIGMA; ++i)\r\n        if (trie[1][i]) q.push(trie[1][i]), fail[trie[1][i]] = 1;\r\n        else trie[1][i] = 1;\r\n    while (!q.empty()) {\r\n        int u = q.front(); q.pop();\r\n        for (int c = 0; c < SIGMA; ++c)\r\n            if (!trie[u][c]) trie[u][c] = trie[fail[u]][c];\r\n            else q.push(trie[u][c]), fail[trie[u][c]] = trie[fail[u]][c];\r\n    }\r\n    // msg(\"ACAM built.\\n\");\r\n\r\n    for (int i = 1; i <= tot; ++i) e[i].clear();\r\n    for (int i = 2; i <= tot; ++i) e[fail[i]].push_back(i);\r\n    idx = 0, dfs(1);\r\n    // msg(\"idx %d\\ntot %d\\n\", idx, tot);\r\n}\r\n}\r\n\r\nint pos[maxn];\r\nvi vec[maxn];\r\nvoid dfs(int u, int pre, int x) {\r\n    for (int i : vec[u]) {\r\n        int c = sgn(i); i = abs(i);\r\n        ans[i] += c * tr.ask(ACAM::st[pos[a[i].p]], ACAM::ed[pos[a[i].p]]);\r\n    }\r\n    for (pii p : Tree::e[u]) {\r\n        int v = p.fir, c = p.sec;\r\n        if (v == pre) continue;\r\n        int y = ACAM::trie[x][c];\r\n        // msg(\"(%d, %d) %d -%c> %d\\n\", u, v, x, c + 'a', y);\r\n        tr.add(ACAM::st[y], 1);\r\n        dfs(v, u, y);\r\n        tr.add(ACAM::st[y], -1);\r\n    }\r\n}\r\nvoid work() {\r\n    ACAM::init();\r\n    for (int i = 1; i <= m; ++i) pos[i] = ACAM::ins(rev(s[i]));\r\n    ACAM::build();\r\n    for (int i = 1; i <= q; ++i) {\r\n        int x = a[i].x, z = a[i].z, len = s[a[i].p].size();\r\n        int d = Tree::dep[x] - Tree::dep[z];\r\n        // msg(\"#%d: %d %d\\n\", i, d, len);\r\n        if (d < len) continue;\r\n        vec[x].push_back(i);\r\n        vec[Tree::jump(x, d - len + 1)].push_back(-i);\r\n        // msg(\"#%d : %d - %d\\n\", i, x, Tree::jump(x, d - len + 1));\r\n    }\r\n    tr.init(ACAM::tot);\r\n    dfs(1, 0, 1);\r\n    msg(\"@1.1\\n\");\r\n\r\n    ACAM::init();\r\n    for (int i = 1; i <= m; ++i) pos[i] = ACAM::ins(s[i]);\r\n    ACAM::build();\r\n    for (int i = 0; i <= n; ++i) vec[i].clear();\r\n    for (int i = 1; i <= q; ++i) {\r\n        int y = a[i].y, z = a[i].z, len = s[a[i].p].size();\r\n        int d = Tree::dep[y] - Tree::dep[z];\r\n        // msg(\"#%d: %d %d\\n\", i, d, len);\r\n        if (d < len) continue;\r\n        vec[y].push_back(i);\r\n        vec[Tree::jump(y, d - len + 1)].push_back(-i);\r\n        // msg(\"#%d : %d - %d\\n\", i, y, Tree::jump(y, d - len + 1));\r\n    }\r\n    tr.init(ACAM::tot);\r\n    dfs(1, 0, 1);\r\n    msg(\"@1.2\\n\");\r\n}\r\n}\r\n\r\nnamespace Solve2 {\r\nusing Tree::dep;\r\nvoid work();\r\n\r\ntypedef unsigned long long ull;\r\nconst int B = 131;\r\null pw[maxn], htr[maxn];\r\nvoid dfs(int u, int pre) {\r\n    for (pii p : Tree::e[u]) {\r\n        int v = p.fir, c = p.sec;\r\n        if (v == pre) continue;\r\n        htr[v] = htr[u] * B + c + 1;\r\n        dfs(v, u);\r\n    }\r\n}\r\null get_hash(int u, int v) { return htr[v] - htr[u] * pw[dep[v] - dep[u]]; }\r\nvoid prework() {\r\n    pw[0] = 1;\r\n    for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * B;\r\n    dfs(1, 0);\r\n}\r\n\r\npii b[maxn];\r\n\r\nnamespace SA {\r\nvoid work(string Str, vi &Vec);\r\n\r\nint n, m;\r\nchar s[maxn];\r\nint sa[maxn], rk[maxn], tmp[maxn], cnt[maxn];\r\nvoid radix_sort() {\r\n    for (int i = 0; i <= m; ++i) cnt[i] = 0;\r\n    for (int i = 1; i <= n; ++i) cnt[rk[tmp[i]]]++;\r\n    for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];\r\n    for (int i = n; i >= 1; --i) sa[cnt[rk[tmp[i]]]--] = tmp[i];\r\n}\r\n\r\nint ht[maxn];\r\nvoid buildSA() {\r\n    fill(tmp, tmp + 2 * n + 3, 0);\r\n    m = SIGMA;\r\n    for (int i = 1; i <= n; ++i) rk[i] = s[i] - 'a' + 1, tmp[i] = i;\r\n    radix_sort();\r\n\r\n    for (int p = 0, w = 1; p < n; m = p, w <<= 1) {\r\n        p = 0;\r\n        for (int i = n; i > n - w; --i) tmp[++p] = i;\r\n        for (int i = 1; i <= n; ++i) if (sa[i] > w) tmp[++p] = sa[i] - w;\r\n        radix_sort();\r\n        for (int i = 1; i <= n; ++i) tmp[i] = rk[i];\r\n        p = 1, rk[sa[1]] = 1;\r\n        for (int i = 2; i <= n; ++i) {\r\n            int u = sa[i], v = sa[i - 1];\r\n            if (tmp[u] != tmp[v] || tmp[u + w] != tmp[v + w]) ++p;\r\n            rk[u] = p;\r\n        }\r\n    }\r\n    for (int i = 1, j = 0; i <= n; ++i) {\r\n        if (rk[i] == n) continue;\r\n        if (j) --j;\r\n        while (s[i + j] == s[sa[rk[i] + 1] + j]) ++j;\r\n        ht[rk[i]] = j;\r\n    }\r\n    // for (int i = 1; i <= n; ++i) msg(\"%d%c\", sa[i], \" \\n\"[i == n]);\r\n    // for (int i = 1; i <= n; ++i) msg(\"%d%c\", rk[i], \" \\n\"[i == n]);\r\n    // for (int i = 1; i <= n; ++i) msg(\"%d%c\", ht[i], \" \\n\"[i == n]);\r\n}\r\n\r\null hs[maxn];\r\null get(int l, int r) { return hs[r] - hs[l - 1] * pw[r - l + 1]; }\r\nint lcp(int p, int u, int v) {\r\n    if (u == v) return 0;\r\n    auto check = [&] (int x) -> int {\r\n        if (x == u) return 1;\r\n        int d = dep[x] - dep[u];\r\n        if (p + d - 1 > n) return 0;\r\n        return get_hash(u, x) == get(p, p + d - 1);\r\n    }; // u --> x --> v\r\n    if (check(v)) return dep[v] - dep[u];\r\n    // msg(\"(%d, %d) :\\n\", u, v);\r\n    for (int i = Tree::B - 1; i >= 0; --i)\r\n        if (dep[v] - dep[u] >= (1 << i)) {\r\n            int x = Tree::fa[i][v];\r\n            if (!check(x)) v = x;\r\n        }\r\n    // msg(\"(%d, %d)\\n\", u, v);\r\n    return dep[v] - dep[u] - 1;\r\n}\r\n\r\nint cmp(int p, int u, int v) {\r\n    int len = lcp(p, u, v);\r\n    // msg(\"lcp (%d, %d->%d) %d\\n\", p, u, v, len);\r\n    if (len == n - p + 1) return 1;\r\n    if (len == dep[v] - dep[u]) return 0;\r\n    return s[p + len] < Tree::w[Tree::jump(v, dep[v] - dep[u] - len - 1)] + 'a';\r\n} // s[p...n] \\le u->v\r\n\r\nint getrk(int u, int v) {\r\n    int l = 1, r = n, mid, res = 0;\r\n    while (l <= r) {\r\n        mid = (l + r) >> 1;\r\n        if (cmp(sa[mid], u, v)) res = mid, l = mid + 1;\r\n        else r = mid - 1;\r\n    }\r\n    // printf(\"rk %d->%d: %d\\n\", u, v, res);\r\n    return res;\r\n}\r\n\r\nvi vec[maxn];\r\nint stk[maxn], tp;\r\nvoid work(string Str, vi &Vec) {\r\n    // msg(\"work %s %d\\n\", Str.c_str(), (int) Vec.size());\r\n    if (Vec.empty()) return;\r\n    n = Str.size();\r\n    fill(s, s + n * 2 + 1, 0);\r\n    for (int i = 1; i <= n; ++i) s[i] = Str[i - 1];\r\n    buildSA();\r\n    hs[0] = 0;\r\n    for (int i = 1; i <= n; ++i)\r\n        hs[i] = hs[i - 1] * B + s[i] - 'a' + 1;\r\n    for (int i = 0; i <= n; ++i) vec[i].clear();\r\n    for (int i : Vec)\r\n        vec[getrk(a[i].z, a[i].x)].push_back(i);\r\n    tp = 0;\r\n    for (int o = 1; o <= n; ++o) {\r\n        int i = sa[o];\r\n        stk[++tp] = i;\r\n        for (int x : vec[o]) {\r\n            int len = lcp(i, a[x].z, a[x].x);\r\n            // msg(\"lcp %d (%d, %d) : %d\\n\", i, a[x].z, a[x].x, len);\r\n            int l = 1, r = tp, mid, res = 0;\r\n            while (l <= r) {\r\n                mid = (l + r) >> 1;\r\n                if (n - stk[mid] + 1 <= len) res = mid, l = mid + 1;\r\n                else r = mid - 1;\r\n            }\r\n            // for (int i = 1; i <= tp; ++i) msg(\"%d%c\", stk[i], \" \\n\"[i == tp]);\r\n            // msg(\"res %d\\n\", res);\r\n            if (res) b[x].fir = max(b[x].fir, n - stk[res] + 1);\r\n        }\r\n        while (tp && n - stk[tp] + 1 > ht[o]) --tp;\r\n    }\r\n    tp = 0;\r\n    for (int o = n; o >= 1; --o) {\r\n        int i = sa[o];\r\n        stk[++tp] = i;\r\n        for (int x : vec[o - 1]) {\r\n            int len = lcp(i, a[x].z, a[x].x);\r\n            // msg(\"lcp %d (%d, %d) : %d\\n\", i, a[x].z, a[x].x, len);\r\n            int l = 1, r = tp, mid, res = 0;\r\n            while (l <= r) {\r\n                mid = (l + r) >> 1;\r\n                if (n - stk[mid] + 1 <= len) res = mid, l = mid + 1;\r\n                else r = mid - 1;\r\n            }\r\n            if (res) b[x].fir = max(b[x].fir, n - stk[res] + 1);\r\n        }\r\n        while (tp && n - stk[tp] + 1 > ht[o - 1]) --tp;\r\n    }\r\n}\r\n}\r\n\r\nnamespace KMP {\r\nvoid work(string &Str, vi &Vec);\r\n\r\nint n, nxt[maxn], nxtR[maxn];\r\nchar s[maxn];\r\nvi e[maxn], eR[maxn], vec[maxn];\r\nint st[maxn], ed[maxn], idx;\r\nvoid dfs(int u) {\r\n    st[u] = ++idx;\r\n    for (int v : eR[u]) dfs(v);\r\n    ed[u] = idx;\r\n}\r\nvoid dfs2(int u) {\r\n    if (u && u <= n - 1) tr.add(st[u + 1], ed[u + 1], 1);\r\n    for (int i : vec[u])\r\n        ans[i] += tr.ask(st[n - b[i].sec + 1]);\r\n    for (int v : e[u]) dfs2(v);\r\n    if (u && u <= n - 1) tr.add(st[u + 1], ed[u + 1], -1);\r\n}\r\nvoid work(string &Str, vi &Vec) {\r\n    n = Str.size();\r\n    fill(s, s + n * 2 + 1, 0);\r\n    for (int i = 1; i <= n; ++i) s[i] = Str[i - 1];\r\n\r\n    nxt[1] = 0;\r\n    for (int i = 2, j = 0; i <= n; ++i) {\r\n        while (j && s[j + 1] != s[i]) j = nxt[j];\r\n        if (s[j + 1] == s[i]) ++j;\r\n        nxt[i] = j;\r\n    }\r\n    for (int i = 1; i <= n; ++i) msg(\"%d%c\", nxt[i], \" \\n\"[i == n]);\r\n    nxtR[n] = n + 1;\r\n    for (int i = n - 1, j = n + 1; i >= 1; --i) {\r\n        while (j <= n && s[j - 1] != s[i]) j = nxtR[j];\r\n        if (s[j - 1] == s[i]) --j;\r\n        nxtR[i] = j;\r\n    }\r\n    for (int i = 1; i <= n; ++i) msg(\"%d%c\", nxtR[i], \" \\n\"[i == n]);\r\n\r\n    for (int i = 0; i <= n + 1; ++i) e[i].clear(), eR[i].clear(), vec[i].clear();\r\n    for (int i = 1; i <= n; ++i) e[nxt[i]].push_back(i), eR[nxtR[i]].push_back(i);\r\n    for (int i : Vec) if (b[i].fir && b[i].sec) vec[b[i].fir].push_back(i);\r\n    idx = 0, dfs(n + 1);\r\n    ll t1 = clock();\r\n    tr.init(idx), dfs2(0);\r\n    ll t2 = clock();\r\n    TIM += t2 - t1;\r\n}\r\n}\r\n\r\nvi vec[maxn];\r\nvoid work() {\r\n    prework();\r\n    for (int i = 1; i <= q; ++i) vec[a[i].p].push_back(i);\r\n    for (int i = 1; i <= m; ++i) SA::work(rev(s[i]), vec[i]);\r\n    for (int i = 1; i <= q; ++i) swap(b[i].fir, b[i].sec), swap(a[i].x, a[i].y);\r\n    for (int i = 1; i <= m; ++i) SA::work(s[i], vec[i]);\r\n    for (int i = 1; i <= q; ++i) swap(b[i].fir, b[i].sec), swap(a[i].x, a[i].y);\r\n    for (int i = 1; i <= q; ++i) msg(\"#%d : %d %d\\n\", i, b[i].fir, b[i].sec);\r\n    msg(\"@2.1\\n\");\r\n    for (int i = 1; i <= m; ++i) KMP::work(s[i], vec[i]);\r\n    msg(\"@2.2\\n\");\r\n}\r\n}\r\n\r\nint main() {\r\n    ll t1 = clock();\r\n    cin >> n >> m >> q;\r\n    for (int i = 1; i < n; ++i) {\r\n        int u, v; char ch;\r\n        cin >> u >> v >> ch;\r\n        Tree::add(u, v, ch - 'a');\r\n    }\r\n    Tree::build();\r\n    for (int i = 1; i <= m; ++i) cin >> s[i];\r\n    for (int i = 1; i <= q; ++i) {\r\n        cin >> a[i].x >> a[i].y >> a[i].p;\r\n        a[i].z = Tree::lca(a[i].x, a[i].y);\r\n    }\r\n    msg(\"@0\\n\");\r\n\r\n    Solve1::work();\r\n    ll t2 = clock();\r\n    msg(\"@1 %lldms\\n\", t2 - t1);\r\n    for (int i = 1; i <= q; ++i) msg(\"%d\\n\", ans[i]);\r\n    t1 = t2;\r\n    Solve2::work();\r\n    t2 = clock();\r\n    msg(\"@2 %lldms\\n\\n\", t2 - t1);\r\n\r\n    for (int i = 1; i <= q; ++i)\r\n        cout << ans[i] << endl;\r\n\r\n    msg(\"TIM %lld\\n\", TIM);\r\n    msg(\"CNT %lld\\n\", CNT);\r\n    return 0;\r\n}"
}