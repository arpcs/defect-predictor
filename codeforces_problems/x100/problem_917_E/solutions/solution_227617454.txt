{
    "id": 227617454,
    "contestId": 917,
    "creationTimeSeconds": 1696996832,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "vjudge4"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 358,
    "memoryConsumedBytes": 74547200,
    "source": "/* \u967d\u708e\u306f\u9ec4\u6cc9\u306b\u5f85\u305f\u3080\u3068\u3002*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define inl inline\nconstexpr int BUF = 1<<17;\nchar ibuf[BUF], obuf[BUF], *__st, *__ed, *__pt;\ninl void buffer () { __st = ibuf,\n\t__ed = ibuf + fread (ibuf, 1, BUF, stdin); }\ninl void flush () {\n\tfwrite (obuf, 1, __pt - obuf, stdout);\n\t__pt = obuf; }\ninl char getc () {\n\treturn __st == __ed && (buffer (),\n\t\t__st == __ed) ? EOF : *__st++; }\ninl void putc (char c) {\n\tif (__pt == obuf + BUF) flush ();\n\t*__pt++ = c; }\ntemplate <typename T> inl bool read (T &x) {\n\tint f = 1; static char c = getc (); x = 0; \n\tfor (; ~c && !isdigit (c); c = getc ())\n\t\tif (c == '-') f = -1;\n\tif (c == EOF) return 0;\n\tfor (; ~c && isdigit (c); c = getc ())\n\t\tx = (x<<1) + (x<<3) + (c^48);\n\tx *= f; return 1;\n}\ninl int read (char *s) {\n\tstatic char c = getc ();\n\tfor (; ~c && isspace (c); c = getc ());\n\tif (c == EOF) return 0; int len = 0;\n\tfor (; ~c && !isspace (c); c = getc ())\n\t\t*s++ = c, ++len; return *s = 0, len;\n}\ntemplate <typename T, typename...Targs>\ninl bool read (T &x, Targs&... args) {\n\treturn read (x) && read (args...); }\ntemplate <typename T> inl void print (T x) {\n\tif (x < 0) x = -x, putc ('-');\n\tstatic int st[36], top = 0;\n\tdo { st[top++] = x % 10, x /= 10; } while (x);\n\twhile (top) putc (st[--top] ^ '0');\n}\nstruct IO {\n\tIO () { __pt = obuf, __ed = __st = ibuf; }\n\t~IO () { flush (); }\n} __io;\n#define putchar putc\n#define puts(s) (print (s, '\\n'))\n#define scanf(...) fprintf (stderr, \"fread loaded.\")\n#define printf scanf\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n// typedef __int128 lll;\n// typedef long double llf;\ntypedef pair <int, int> pint;\n#define fst first\n#define scd second\n#define all(p) begin (p), end (p)\n#define empb emplace_back\n\n#ifdef SHIKEN\n#define msg(args...) fprintf (stderr, args)\n#else\n#define msg(...) void ()\n#endif\n\nconstexpr int N = 1e5 + 10;\nint n, m, q, fa[N], siz[N], hson[N], top[N], dep[N], dfn[N], seq[N], dtot;\nchar __s[N<<1], *s[N], __t[N<<1], *t[N], faec[N];\nint slen[N], ans[N], mxp[N], mxs[N];\nstruct query { int x, y, z, sid; } qu[N];\nvector <pint> e[N], upqu[N], dnqu[N];\nvector <int> mdqu[N];\n\nstruct hash_t {\n\tstatic constexpr int h[26] {\n\t\t15, 17, 25, 27, 31, 35, 45, 53, 57, 59, 63, 65, 73, 79,\n\t\t83, 89, 91, 93, 97, 101, 103, 107, 115, 119, 123, 131\n\t}, P = 137;\n\tstatic constexpr ull invP = 16292379802327414201ull;\n\tstruct spow {\n\t\tull g[N];\n\t\tspow (const ull x) {\n\t\t\tg[0] = 1;\n\t\t\tfor (int i = 1; i < N; ++i)\n\t\t\t\tg[i] = g[i - 1] * x;\n\t\t}\n\t\tinl ull operator [] (int i) const { return g[i]; }\n\t};\n\tstatic const spow g; ull x, l;\n\thash_t (const char *s) : x (0), l (0) {\n\t\twhile (*s) x = x * P + h[*s++ - 'a'], ++l;\n\t}\n\thash_t (const char &c) : x (h[c - 'a']), l (1) {}\n\thash_t () : x (0), l (0) {}\n\tinl auto& operator += (const hash_t &b) {\n\t\tx = x * g[b.l] + b.x, l += b.l;\n\t\treturn *this;\n\t}\n\tinl friend auto operator + (hash_t a, const hash_t &b) {\n\t\treturn a += b;\n\t}\n\tinl auto& operator -= (const hash_t &b) {\n\t\tx -= b.x * g[l -= b.l];\n\t\treturn *this;\n\t}\n\tinl friend auto operator - (hash_t a, const hash_t &b) {\n\t\treturn a -= b;\n\t}\n\tinl bool operator == (const hash_t &b) const {\n\t\treturn x == b.x && l == b.l;\n\t}\n\tinl bool operator != (const hash_t &b) const { return !(*this == b); }\n} hpre[N];\nconst hash_t::spow hash_t::g (P);\nconstexpr int hash_t::h[26];\n\nvoid dfs (int x, int fr, int c) {\n\tfa[x] = fr; siz[x] = 1;\n\tdep[x] = dep[fr] + 1; faec[x] = c;\n\tif (fr) e[x].erase (find (all (e[x]), pint { fr, c }));\n\tfor (const auto &[y, c] : e[x]) {\n\t\tdfs (y, x, c), siz[x] += siz[y];\n\t\tif (siz[y] > siz[hson[x]])\n\t\t\thson[x] = y;\n\t}\n}\nvoid decomp (int x, int tp) {\n\tdfn[x] = ++dtot; top[x] = tp;\n\tseq[dtot] = x;\n\thpre[dtot] = hpre[dtot - 1] + hash_t (faec[x] + 'a');\n\tif (hson[x]) decomp (hson[x], tp);\n\tfor (const auto &[y, c] : e[x])\n\t\tif (y != hson[x]) decomp (y, y);\n}\ninl int lca (int x, int y) {\n\tint u, v;\n\twhile (u = top[x], v = top[y], u != v)\n\t\tif (dep[u] < dep[v]) y = fa[v];\n\t\telse x = fa[u];\n\treturn dep[x] < dep[y] ? x : y;\n}\ninl int ances (int x, int k) {\n\tif (k >= dep[x]) return 0;\n\tint dt;\n\twhile (dt = dep[x] - dep[top[x]] + 1, k >= dt)\n\t\tk -= dt, x = fa[top[x]];\n\treturn seq[dfn[x] - k];\n}\n\nint antot, tr[N][26], fail[N], edp[N], adfn[N], aowa[N], adtot;\nvector <int> ae[N];\nstruct BIT {\n\tint c[N], n;\n\tinl void init (const int len) {\n\t\tmemset (c, 0, (n = len) + 1<<2);\n\t}\n\tinl void add (int x, int y) {\n\t\tfor (; x <= n; x += x & -x)\n\t\t\tc[x] += y;\n\t}\n\tinl void add (int l, int r, int y) {\n\t\tadd (l, y), add (r + 1, -y);\n\t}\n\tinl int ask (int x) const {\n\t\tint res = 0;\n\t\tfor (; x > 0; x -= x & -x)\n\t\t\tres += c[x];\n\t\treturn res;\n\t}\n\tinl int ask (int l, int r) const {\n\t\treturn ask (r) - ask (l - 1);\n\t}\n} bit;\n\ninl int insert (const char *s) {\n\tint x = 0, c;\n\twhile (c = *s++) {\n\t\tif (!tr[x][c -= 'a'])\n\t\t\ttr[x][c] = ++antot;\n\t\tx = tr[x][c];\n\t}\n\treturn x;\n}\ninl void build_AC () {\n\tstatic int qu[N], st, ed;\n\tst = ed = 0;\n\tfor (int c = 0, x; c < 26; ++c)\n\t\tif (x = tr[0][c])\n\t\t\tqu[ed++] = tr[0][c], fail[x] = 0;\n\twhile (ed - st) {\n\t\tconst int x = qu[st++];\n\t\tae[fail[x]].empb (x);\n\t\tfor (int c = 0; c < 26; ++c)\n\t\t\tif (int &y = tr[x][c])\n\t\t\t\tqu[ed++] = y, fail[y] = tr[fail[x]][c];\n\t\t\telse y = tr[fail[x]][c];\n\t}\n}\nvoid adfs (int x) {\n\tadfn[x] = ++adtot;\n\tfor (const int y : ae[x]) adfs (y);\n\taowa[x] = adtot;\n}\n\nint rk[N], sa[N], ht[N], tt[N], ta[N]; pint tp[N];\ninl void radix_sort (const int n, const int p) {\n\tmemset (ta, 0, p + 1<<2);\n\tfor (int i = 0; i < n; ++i) ta[rk[i]]++;\n\tfor (int i = 1; i <= p; ++i)\n\t\tta[i] += ta[i - 1];\n\tfor (int i = n - 1; ~i; --i)\n\t\tsa[ta[rk[tt[i]]]--] = tt[i];\n}\ninl void build_SA (const char *s, const int n) {\n\tint p = 26;\n\tfor (int i = 0; i < n; ++i)\n\t\trk[i] = s[i] - 'a' + 1, tt[i] = i;\n\trk[n] = 0; sa[0] = n;\n\ttp[n] = { -1, -1 };\n\tradix_sort (n, p);\n\tfor (int w = 1, ini = w;; ini = w <<= 1) {\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\ttp[i] = { rk[i], i + w < n ? rk[i + w] : 0 };\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (sa[i] >= w)\n\t\t\t\ttt[ini++] = sa[i] - w;\n\t\t\telse tt[sa[i]] = n - sa[i] - 1;\n\t\tradix_sort (n, p); p = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\trk[sa[i]] = p += tp[sa[i]] != tp[sa[i - 1]];\n\t\tif (p == n) break;\n\t}\n\tfor (int i = 0, k = 0, p; i < n; ++i) {\n\t\tif (k) --k;\n\t\tif (rk[i] == 1) { ht[1] = 0; continue; }\n\t\tp = sa[rk[i] - 1];\n\t\twhile (s[p + k] == s[i + k]) ++k;\n\t\tht[rk[i]] = k;\n\t}\n}\n\nint nxt[N], ndfn[N], nowa[N], ndtot;\nvector <int> ne[N], nqu[N];\ninl void build_nxt (const char *s, const int n) {\n\tnxt[1] = 0;\n\tint x = 1, now = 0;\n\twhile (x < n)\n\t\tif (s[x] == s[now])\n\t\t\tnxt[++x] = ++now;\n\t\telse if (now) now = nxt[now];\n\t\telse nxt[++x] = 0;\n}\nvoid ndfs (int x) {\n\tndfn[x] = ++ndtot;\n\tfor (const int y : ne[x]) ndfs (y);\n\tnowa[x] = ndtot;\n}\nvoid nkotae (int x, const int &n) {\n\tif (x && x != n)\n\t\tbit.add (ndfn[n - x], nowa[n - x], 1);\n\tfor (const int id : nqu[x])\n\t\tans[id] += bit.ask (ndfn[mxp[id]]);\n\tfor (const int y : ne[x]) nkotae (y, n);\n\tif (x && x != n)\n\t\tbit.add (ndfn[n - x], nowa[n - x], -1);\n}\n\ninl int sgn (int x) { return 1 + (x>>31) * 2; }\ntemplate <vector <pint> qu[]>\ninl void whole (int x, int u) {\n\tbit.add (adfn[u], 1);\n\tfor (const auto &[sid, qid] : qu[x]) {\n\t\tconst int v = edp[sid];\n\t\tans[abs (qid)] += sgn (qid) * bit.ask (adfn[v], aowa[v]);\n\t}\n\tfor (const auto &[y, c] : e[x])\n\t\twhole <qu> (y, tr[u][c]);\n\tbit.add (adfn[u], -1);\n}\n\nstruct squery { int x, y, id; } squ[N]; int sqc;\nstruct lpquery { int p, t, id; } lpqu[N];\ntemplate <int mxm[]>\ninl void proce (const char *s, const int n) {\n\tstatic hash_t gpre[N];\n\tstatic pint seg[20], sta[N];\n\tint sc, ed = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tgpre[i + 1] = gpre[i] + hash_t (s[i]);\n\tauto calc_h = [&] (int l, int r) {\n\t\treturn hpre[r] - hpre[l - 1];\n\t};\n\tauto calc_g = [&] (int l, int r) {\n\t\treturn gpre[r + 1] - gpre[l];\n\t};\n\tauto comp = [&] (const int k) -> pair <bool, int> {\n\t\thash_t h, g, _h, _g;\n\t\tfor (int i = 0, hl, gl; i < sc; ++i) {\n\t\t\tconst auto &[p, q] = seg[i];\n\t\t\thl = q - p + 1;\n\t\t\tgl = n - k - g.l;\n\t\t\tif (gl > hl && (\n\t\t\t\t_g = calc_g (k + h.l, k + h.l + hl - 1),\n\t\t\t\t_h = calc_h (p, q), _g == _h)) {\n\t\t\t\tg += _g; h += _h; continue;\n\t\t\t}\n\t\t\tint l = 1, r = min (hl, gl) + 1, mid;\n\t\t\twhile (l < r) {\n\t\t\t\tmid = l + r >> 1;\n\t\t\t\tif (calc_h (p, p + mid - 1) == calc_g (k + h.l, k + h.l + mid - 1))\n\t\t\t\t\tl = mid + 1;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tif (l == min (hl, gl) + 1)\n\t\t\t\treturn { hl >= gl, h.l + l - 1 };\n\t\t\telse {\n\t\t\t\treturn { faec[seq[p + l - 1]] + 'a' >= s[l + k + h.l - 1], h.l + l - 1 };\n\t\t\t}\n\t\t}\n\t\treturn { 0, h.l };\n\t};\n\n\tbuild_SA (s, n);\n\tfor (int i = 0; i < sqc; ++i) {\n\t\tconst auto &[x, y, id] = squ[i]; // x as y's ancestor.\n\t\tsc = 0; int v = y;\n\t\twhile (top[v] != top[x])\n\t\t\tseg[sc++] = { dfn[top[v]], dfn[v] },\n\t\t\tv = fa[top[v]];\n\t\tif (v != x) seg[sc++] = { dfn[x] + 1, dfn[v] };\n\t\treverse (seg, seg + sc);\n\t\tint l = 1, r = n, mid;\n\t\twhile (l < r) {\n\t\t\tmid = l + r + 1 >> 1;\n\t\t\tconst auto &[ok, t] = comp (sa[mid]);\n\t\t\tif (ok) l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tlpqu[i] = { l, comp (sa[l]).scd, id };\n\t}\n\n\tsort (lpqu, lpqu + sqc, [] (auto &p, auto &q) {\n\t\treturn p.p < q.p;\n\t});\n\tfor (int i = 1, j = 0; i <= n && j < sqc; ++i) {\n\t\twhile (ed && sta[ed-1].fst > ht[i]) --ed;\n\t\tsta[ed] = { ht[i], ht[i] == n - sa[i - 1] ? ht[i] : sta[ed-1].scd }; ++ed;\n\t\twhile (j < sqc && lpqu[j].p == i) {\n\t\t\tconst auto &[p, t, id] = lpqu[j++];\n\t\t\tif (t == n - sa[p]) {\n\t\t\t\tmxm[id] = t; continue;\n\t\t\t}\n\t\t\tint l = 0, r = ed - 1, mid;\n\t\t\twhile (l < r) {\n\t\t\t\tmid = l + r + 1 >> 1;\n\t\t\t\tif (sta[mid].fst <= t) l = mid;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t\tmxm[id] = sta[l].scd;\n\t\t}\n\t}\n}\n\nint main () {\n\t/*  */\n\t#ifdef CHARLES_WU\n\tfreopen (\"CF917E.in\", \"r\", stdin);\n\tfreopen (\"CF917E.out\", \"w\", stdout);\n\t#endif\n\n\tread (n, m, q);\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tchar c[4];\n\t\tread (x, y), read (c);\n\t\te[x].empb (y, *c - 'a');\n\t\te[y].empb (x, *c - 'a');\n\t}\n\ts[0] = __s, t[0] = __t;\n\tfor (int i = 1, dt = 0; i <= m; ++i) {\n\t\tread (s[i] = s[i - 1] + dt);\n\t\tslen[i] = strlen (s[i]);\n\t\tt[i] = t[i - 1] + dt;\n\t\tstrcpy (t[i], s[i]);\n\t\treverse (t[i], t[i] + slen[i]);\n\t\tdt = slen[i] + 1;\n\t}\n\tdfs (1, 0, 0);\n\tdecomp (1, 1);\n\n\tfor (int x, y, k, i = 1; i <= q; ++i) {\n\t\tread (x, y, k);\n\t\tconst int z = lca (x, y), &l = slen[k];\n\t\tqu[i] = { x, y, z, k };\n\t\tmdqu[k].empb (i); int dt;\n\t\tif (dt = dep[x] - dep[z], dt >= l) {\n\t\t\tupqu[ances (x, dt - l + 1)].empb (k, -i);\n\t\t\tupqu[x].empb (k, i);\n\t\t}\n\t\tif (dt = dep[y] - dep[z], dt >= l) {\n\t\t\tdnqu[ances (y, dt - l + 1)].empb (k, -i);\n\t\t\tdnqu[y].empb (k, i);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; ++i)\n\t\tedp[i] = insert (s[i]);\n\tbuild_AC (); adfs (0);\n\tbit.init (adtot);\n\twhole <dnqu> (1, 0);\n\tmemset (tr, 0, 26 * (antot + 1)<<2);\n\tmemset (fail, 0, antot + 1<<2);\n\tfor (int x = 0; x <= antot; ++x)\n\t\tae[x].clear ();\n\tadtot = antot = 0;\n\tfor (int i = 1; i <= m; ++i)\n\t\tedp[i] = insert (t[i]);\n\tbuild_AC (); adfs (0);\n\tbit.init (adtot);\n\twhole <upqu> (1, 0);\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tconst int &sl = slen[i];\n\t\tsqc = 0;\n\t\tfor (const int id : mdqu[i])\n\t\t\tsqu[sqc++] = { qu[id].z, qu[id].y, id };\n\t\tproce <mxs> (s[i], sl);\n\t\tsqc = 0;\n\t\tfor (const int id : mdqu[i])\n\t\t\tsqu[sqc++] = { qu[id].z, qu[id].x, id };\n\t\tproce <mxp> (t[i], sl);\n\n\t\tbuild_nxt (s[i], sl);\n\t\tfor (int x = 0; x <= sl; ++x)\n\t\t\tne[x].clear ();\n\t\tfor (int x = 1; x <= sl; ++x)\n\t\t\tne[nxt[x]].empb (x);\n\t\tndtot = 0; ndfs (0);\n\t\tbuild_nxt (t[i], sl);\n\t\tfor (int x = 0; x <= sl; ++x)\n\t\t\tne[x].clear (), nqu[x].clear ();\n\t\tfor (int x = 1; x <= sl; ++x)\n\t\t\tne[nxt[x]].empb (x);\n\t\tfor (const int id : mdqu[i])\n\t\t\tif (mxp[id] && mxs[id])\n\t\t\t\tnqu[mxs[id]].empb (id);\n\t\tbit.init (ndtot);\n\t\tnkotae (0, sl);\n\t}\n\n\tfor (int i = 1; i <= q; ++i)\n\t\tprint (ans[i]), putc ('\\n');\n\n\treturn 0;\n}\n\n\t   \t\t       \t \t\t\t\t\t\t \t \t\t\t\t\t\t"
}