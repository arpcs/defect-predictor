{
    "id": 42154422,
    "contestId": 917,
    "creationTimeSeconds": 1535377990,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "vjudge3"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 2417,
    "memoryConsumedBytes": 377958400,
    "source": "#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=200111;\nconst int maxTRIEn=1800111;\nnamespace KMP\n{\n\tll rdown(ll p,ll q){return q<0?rdown(-p,-q):(p>0?p/q:-(-p+q-1)/q);}\n\tll rup(ll p,ll q){return -rdown(-p,q);}\n\tstruct sub\n\t{\n\t\tint s,d,cnt;//d>0\n\t\tsub(int S=0,int D=0,int CNT=0){s=S;d=D;cnt=CNT;}\n\t\tint end()const{return s+(cnt-1)*d;}\n\t\tbool has(int x)const{return x>=s&&x<=end()&&(x-s)%d==0;}\n\t\tint calc(const sub &t)\n\t\t{\n\t\t\tif(d==t.d)\n\t\t\t{\n\t\t\t\tif((s-t.s)%d!=0)return 0;\n\t\t\t\telse return max(0,(min(end(),t.end())-max(s,t.s))/d+1);\n\t\t\t}\n\t\t\telse if(cnt==1)return t.has(s);\n\t\t\telse return has(t.s);\n\t\t}\n\t\tsub flip(int x){return sub(x-(s+(cnt-1)*d),d,cnt);}\n\t};\n\tvector<int> Fail[maxn],Slink[maxn];\n\tvoid construct(char s[],int n,int id)\n\t{\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\n\t\tfail.resize(n+1);\n\t\tslink.resize(n+1);\n\t\tfail[0]=0;fail[1]=0;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tint &p=fail[i];\n\t\t\tp=fail[i-1];\n\t\t\twhile(p&&s[p+1]!=s[i])p=fail[p];\n\t\t\tif(s[p+1]==s[i])p++;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)slink[i]=fail[i]==0?0:(i-fail[i]==fail[i]-fail[fail[i]]?slink[fail[i]]:fail[i]);\n\t}\n\tvector<sub> extract(int id,int x)\n\t{\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\n\t\tassert(x<fail.size()&&x<slink.size());\n\t\tvector<sub> ret;\n\t\twhile(x)\n\t\t{\n\t\t\tint d=x-fail[x];\n\t\t\tret.PB(sub(slink[x]+d,d,(x-slink[x])/d));\n\t\t\tx=slink[x];\n\t\t}\n\t\treverse(ret.begin(),ret.end());\n\t\tif(ret.back().cnt>1)ret.back().cnt--,ret.PB(sub(ret.back().end()+ret.back().d,1,1));\n\t\treturn ret;\n\t}\n\tint query(int x,int xl,int y,int yl,int tot)\n\t{\n\t\tif(xl==0||yl==0||xl+yl<tot)return 0;\n\t\tvector<sub> vx=extract(x,xl);\n\t\tvector<sub> vy=extract(y,yl);\n\t\tfor(int i=0;i<vy.size();i++)vy[i]=vy[i].flip(tot);\n\t\treverse(vy.begin(),vy.end());\n\t\tint itx=0,ity=0,ret=0;\n\t\twhile(itx<vx.size()&&ity<vy.size())\n\t\t{\n\t\t\tret+=vx[itx].calc(vy[ity]);\n\t\t\tif(vx[itx].end()<=vy[ity].end())itx++;\n\t\t\telse ity++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst ll hs_B=233;\nconst ll hs_mod=100000000000031ll;\nint bit_tab[maxTRIEn];\nvoid bit_add(int x,int coef)\n{\n\tfor(int i=x;i<maxTRIEn;i+=i&(-i))bit_tab[i]+=coef;\n}\nint bit_query(int x)\n{\n\tint ret=0;\n\tfor(int i=x;i;i-=i&(-i))ret+=bit_tab[i];\n\treturn ret;\n}\nconst int HashMsk=(1<<22)-1;\nstruct HashTable\n{\n\tint hs[HashMsk],val[HashMsk];\n\tHashTable(){memset(hs,-1,sizeof(hs));memset(val,-1,sizeof(val));}\n\tint getpos(int p){return ((p<<5)^(p>>3))&HashMsk;}\n\tint find(int chs)\n\t{\n\t\tint p=getpos(chs);\n\t\twhile(hs[p]!=-1&&hs[p]!=chs)p=(p+1)&HashMsk;\n\t\treturn val[p];\n\t}\n\tint& get(int chs)\n\t{\n\t\tint p=getpos(chs);\n\t\twhile(hs[p]!=-1&&hs[p]!=chs)p=(p+1)&HashMsk;\n\t\tif(hs[p]==-1)hs[p]=chs,val[p]=-1;\n\t\treturn val[p];\n\t}\n};\nnamespace AC\n{\n\t//TRIE\n\tint tot=1;\n\tvector<pair<char,int> > go[maxTRIEn];\n\tHashTable gomp;\n\tll hs[maxTRIEn];\n\tint fa[maxTRIEn],pc[maxTRIEn];\n\tpair<ll,int> hs_arr[maxTRIEn];\n\t\n\tint insert(int p,int c)\n\t{\n\t\tint &q=gomp.get(p<<8|c);\n\t\tif(q==-1)\n\t\t{\n\t\t\tq=++tot,fa[q]=p,pc[q]=c,hs[q]=(hs[p]*hs_B+c+1)%hs_mod;\n\t\t\tgo[p].PB(MP(c,q));\n\t\t\tassert(tot<maxTRIEn);\n\t\t}\n\t\treturn q;\n\t}\n\tint fail[maxTRIEn];\n\tvector<int> con[maxTRIEn];//store fail tree\n\tint fdfn[maxTRIEn],fdfnr[maxTRIEn],dfntot;\n\tvoid fdfs(int x)\n\t{\n\t\tfdfn[x]=++dfntot;\n\t\tfor(int i=0;i<con[x].size();i++)\n\t\t{\n\t\t\tint u=con[x][i];\n\t\t\tfdfs(u);\n\t\t}\n\t\tfdfnr[x]=dfntot;\n\t}\n\t\n\t//HLD\n\tint son[maxTRIEn],top[maxTRIEn],lv[maxTRIEn];\n\tset<int> st[maxTRIEn];\n\tint dfs(int x)\n\t{\n\t\tint sz=1,mx=0;\n\t\tson[x]=0;\n\t\tfor(int t=0;t<go[x].size();t++)\n\t\t{\n\t\t\tint u=go[x][t].SS;\n\t\t\tlv[u]=lv[x]+1;\n\t\t\tint szu=dfs(u);\n\t\t\tsz+=szu;\n\t\t\tif(szu>mx)son[x]=u,mx=szu;\n\t\t}\n\t\treturn sz;\n\t}\n\tvoid dfs2(int x,int tp)\n\t{\n\t\ttop[x]=tp;\n\t\tif(son[x])dfs2(son[x],tp);\n\t\tfor(int t=0;t<go[x].size();t++)\n\t\t{\n\t\t\tint u=go[x][t].SS;\n\t\t\tif(u==son[x])continue;\n\t\t\tdfs2(u,u);\n\t\t}\n\t}\n\tvoid construct_HLD()\n\t{\n\t\tlv[1]=0;\n\t\tdfs(1);\n\t\tdfs2(1,1);\n\t}\n\tvoid HLDflip(int x)\n\t{\n\t\tint g=top[x];\n\t\tif(st[g].find(lv[x])==st[g].end())st[g].insert(lv[x]);\n\t\telse st[g].erase(lv[x]);\n\t}\n\tint HLDquery(int x)\n\t{\n\t\twhile(x)\n\t\t{\n\t\t\tif(st[top[x]].size()>0&&*st[top[x]].begin()<=lv[x])return *(--st[top[x]].lower_bound(lv[x]+1));\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint q[maxTRIEn],qn;\n\tvoid construct()\n\t{\n\t\tconstruct_HLD();\n\t\tfor(int i=1;i<=tot;i++)hs_arr[i]=MP(hs[i],i);\n\t\tsort(hs_arr+1,hs_arr+tot+1);\n\t\tqn=0;q[qn++]=1;\n\t\tfor(int i=0;i<qn;i++)\n\t\t{\n\t\t\tint x=q[i];\n\t\t\tfor(int j=0;j<go[x].size();j++)\n\t\t\t{\n\t\t\t\tq[qn++]=go[x][j].SS;\n\t\t\t}\n\t\t}\n\t\tfail[1]=1;\n\t\tfor(int i=1;i<qn;i++)\n\t\t{\n\t\t\tint x=q[i];\n\t\t\tint &p=fail[x];\n\t\t\tif(fa[x]==1)p=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp=fail[fa[x]];\n\t\t\t\twhile(p!=1&&gomp.find(p<<8|pc[x])==-1)p=fail[p];\n\t\t\t\tif(gomp.find(p<<8|pc[x])!=-1)p=gomp.find(p<<8|pc[x]);\n\t\t\t}\n\t\t\tcon[fail[x]].PB(x);\n\t\t}\n\t\tfdfs(1);\n\t}\n\tint qans[maxTRIEn],qans2[maxTRIEn];\n\tvector<pair<int,int> > qr[maxTRIEn],qr2[maxTRIEn];\n\tvoid dfs_solve_p1(int x)\n\t{\n\t\tbit_add(fdfn[x],1);\n\t\tfor(int i=0;i<qr[x].size();i++)\n\t\t{\n\t\t\tint pos=qr[x][i].FF;\n\t\t\tqans[qr[x][i].SS]+=bit_query(fdfnr[pos])-bit_query(fdfn[pos]-1);\n\t\t}\n\t\tfor(int i=0;i<go[x].size();i++)dfs_solve_p1(go[x][i].SS);\n\t\tbit_add(fdfn[x],-1);\n\t}\n\tvoid dfs_solve_p2(int x,ll hs=0,ll hs_bs=1)\n\t{\n\t\tint p=lower_bound(hs_arr+1,hs_arr+tot+1,MP(hs,0))-hs_arr;\n\t\tif(hs_arr[p].FF==hs)HLDflip(hs_arr[p].SS);\n\t\tfor(int i=0;i<qr2[x].size();i++)\n\t\t{\n\t\t\tqans2[qr2[x][i].SS]=HLDquery(qr2[x][i].FF);\n\t\t}\n\t\tfor(int i=0;i<go[x].size();i++)dfs_solve_p2(go[x][i].SS,(hs+hs_bs*(go[x][i].FF+1))%hs_mod,hs_bs*hs_B%hs_mod);\n\t\tif(hs_arr[p].FF==hs)HLDflip(hs_arr[p].SS);\n\t}\n\tvoid add_query(int ui,int vi,int si,int ti,int id)\n\t{\n\t\tqr[ui].PB(MP(ti,id));\n\t\tqr[vi].PB(MP(si,id));\n\t\tqr2[si].PB(MP(ui,id*2));\n\t\tqr2[ti].PB(MP(vi,id*2+1));\n\t}\n\tpair<int,pair<int,int> > get_query(int id)\n\t{\n\t\treturn MP(qans[id],MP(qans2[id*2],qans2[id*2+1]));\n\t}\n\tvoid solve()\n\t{\n\t\tmemset(qans,0,sizeof(qans));\n\t\tdfs_solve_p1(1);\n\t\tdfs_solve_p2(1);\n\t}\n};\nint n,m,q;\nvector<pair<int,char> > con[maxn];\nvector<pair<int,int> > qr[maxn];\nint qu[maxn],qv[maxn],qx[maxn],uid[maxn],vid[maxn];\nvector<int> sid[maxn];\nint cur_rt,cur_lv;\nint dlv[maxn],sz[maxn],arr[maxn],an,gr[maxn],id[maxn];\nvoid pdfs(int x,int pre=-1)\n{\n\tsz[x]=1;arr[an++]=x;dlv[x]=cur_lv+1;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i].FF;\n\t\tif(u==pre||dlv[u]<cur_lv)continue;\n\t\tpdfs(u,x);\n\t\tsz[x]+=sz[u];\n\t}\n}\nint findrt(int x)\n{\n\tan=0;\n\tpdfs(x);\n\tint ret=x;\n\tfor(int i=0;i<an;i++)if(sz[arr[i]]*2>=sz[x]&&sz[arr[i]]<sz[ret])ret=arr[i];\n\treturn ret;\n}\nvoid dfs(int x,int pre,int g)\n{\n\tgr[x]=g;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i].FF;\n\t\tif(u==pre||dlv[u]<cur_lv)continue;\n\t\tid[u]=AC::insert(id[x],con[x][i].SS-'a');\n\t\tdfs(u,x,pre==-1?u:g);\n\t}\n}\nvoid solve(int X,int lv)\n{\n\tcur_lv=lv;\n\tint rt=findrt(X);\n\tcur_rt=rt;\n\tdlv[rt]=lv;\n\tid[rt]=1;\n\tdfs(rt,-1,rt);\n\tstatic bool vis[maxn];\n\tfor(int i=0;i<an;i++)vis[arr[i]]=1;\n\tfor(int i=0;i<an;i++)\n\t{\n\t\tint x=arr[i];\n\t\tfor(int j=0;j<qr[x].size();j++)\n\t\t{\n\t\t\tint y=qr[x][j].FF;\n\t\t\tif(vis[y]&&gr[y]!=gr[x])\n\t\t\t{\n\t\t\t\tuid[qr[x][j].SS]=id[x];\n\t\t\t\tvid[qr[x][j].SS]=id[y];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<an;i++)vis[arr[i]]=0;\n\tfor(int i=0;i<con[rt].size();i++)\n\t{\n\t\tint u=con[rt][i].FF;\n\t\tif(dlv[u]<lv)continue;\n\t\tsolve(u,lv+1);\n\t}\n}\nchar s[maxn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d %d %c\",&x,&y,&c);\n\t\tcon[x].PB(MP(y,c));\n\t\tcon[y].PB(MP(x,c));\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",s+1);\n\t\tint l=strlen(s+1);\n\t\tint p;\n\t\tp=1;sid[i].PB(1);\n\t\tfor(int j=1;j<=l;j++)p=AC::insert(p,s[j]-'a'),sid[i].PB(p);\n\t\tKMP::construct(s,l,i);\n\t\treverse(s+1,s+l+1);\n\t\tp=1;sid[i+m].PB(1);\n\t\tfor(int j=1;j<=l;j++)p=AC::insert(p,s[j]-'a'),sid[i+m].PB(p);\n\t\tKMP::construct(s,l,i+m);\n\t\treverse(s+1,s+l+1);\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint u,v,x;\n\t\tscanf(\"%d%d%d\",&u,&v,&x);\n\t\tqr[u].PB(MP(v,i));\n\t\tqu[i]=u;qv[i]=v;qx[i]=x;\n\t}\n\tsolve(1,0);\n\tAC::construct();\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tAC::add_query(uid[i],vid[i],sid[qx[i]].back(),sid[qx[i]+m].back(),i);\n\t}\n\tAC::solve();\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tpair<int,pair<int,int> > pp=AC::get_query(i);\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tpair<int,pair<int,int> > pp=AC::get_query(i);\n\t\tint ans=pp.FF;\n\t\tans+=KMP::query(qx[i],pp.SS.FF,qx[i]+m,pp.SS.SS,sid[qx[i]].size()-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
}