{
    "id": 69547326,
    "contestId": 917,
    "creationTimeSeconds": 1580011396,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "vjudge2"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 5,
    "timeConsumedMillis": 93,
    "memoryConsumedBytes": 150937600,
    "source": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 205366\n#define lg 20\n#define mn nn\nstruct bit{\n\tint tree[nn];vector<int> inv;\n\tvoid add(int x,int y) {for(;x<nn;x+=x&-x) tree[x]+=y,inv.push_back(x);}\n\tint ask(int x) {int y=0;for(;x;x-=x&-x) y+=tree[x];return y;}\n\tint ask(int l,int r) {return ask(r)-ask(l-1);}\n\tvoid cls() {for(int i=0;i<inv.size();i++) tree[inv[i]]=0;inv.clear();}\n};\nstruct bbit{\n\tint tree[mn];vector<int> inv;\n\tvoid add(int x,int y) {for(;x<mn;x+=x&-x) tree[x]+=y,inv.push_back(x);}\n\tint ask(int x) {int y=0;for(;x;x-=x&-x) y+=tree[x];return y;}\n\tint ask(int l,int r) {return ask(r)-ask(l-1);}\n\tvoid cls() {for(int i=0;i<inv.size();i++) tree[inv[i]]=0;inv.clear();}\n}flame;\n\n\nint ans[nn];\nnamespace ptilopsis{\n\tstruct pts{\n\t\tint x,y,id;\n\t\tpts(int a=0,int b=0,int c=0){\n\t\t\tx=a,y=b,id=c;\n\t\t}\n\t};\n\tbool operator<(pts a,pts b){\n\t\treturn a.x<b.x;\n\t}\n\t\n\tvector<pts> vp[nn];\n\tvoid ins(int a,int b,int c,int d){\n\t\tvp[d].push_back(pts(a,b,c));\n\t}\n\tvoid solve(){\n\t\t\n\t\tfor(int i=0;i<nn;i++) if(vp[i].size()){\n\t\t\tvector<pts> vip=vp[i];flame.cls();\n\t\t\tsort(vip.begin(),vip.end());\n\t\t\tfor(int i=0;i<vip.size();i++){\n\t\t\t\tint j=i;for(;j<vip.size();j++) if(vip[j].x!=vip[i].x) break;j--;\n\t\t\t\tfor(int k=i;k<=j;k++) if(vip[k].id==0) flame.add(vip[k].y,1);\n\t\t\t\tfor(int k=i;k<=j;k++) if(vip[k].id==-1) flame.add(vip[k].y,-1);\n\t\t\t\tfor(int k=i;k<=j;k++) if(vip[k].id>0) ans[vip[k].id]+=flame.ask(vip[k].y);\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nnamespace easypartofstring{\n\tstruct acam{\n\t\tint ch[nn][26];int tot;int fail[nn];\n\t\tint uid;bit canon;int ep[nn];\n\t\tvoid ins(string s){\n\t\t\tint now=0;\n\t\t\tfor(int i=0;i<s.size();i++){\n\t\t\t\tint c=s[i]-'a';\n\t\t\t\tif(!ch[now][c]) ch[now][c]=++tot;\n\t\t\t\tnow=ch[now][c];\n\t\t\t}\n\t\t\t\n\t\t\tep[++uid]=now;\n\t\t}\n\t\tvector<int> v[nn];int dfn[nn],rdfn[nn],DFN;\n\t\tvoid dfs(int x){\n\t\t\tdfn[x]=++DFN;\n\t\t\tfor(int i=0;i<v[x].size();i++) dfs(v[x][i]);\n\t\t\trdfn[x]=DFN;\n\t\t}\n\t\tvoid build(){\n\t\t\tqueue<int> q;\n\t\t\tfor(int i=0;i<26;i++) if(ch[0][i]) q.push(ch[0][i]);\n\t\t\twhile(q.size()){\n\t\t\t\tint x=q.front();q.pop();\n\t\t\t\tfor(int i=0;i<26;i++) if(ch[x][i])\n\t\t\t\t\tq.push(ch[x][i]),fail[ch[x][i]]=ch[fail[x]][i];\n\t\t\t\telse ch[x][i]=ch[fail[x]][i];\n\t\t\t}\n\t\t\tfor(int i=1;i<=tot;i++) v[fail[i]].push_back(i);dfs(0);\n\t\t}\n\t\t\n\t\tint now=0;\n\t\tvector<int> ops;\n\t\tvoid walk(int x){\n\t\t\tops.push_back(now);\n\t\t\tnow=ch[now][x];\n\t\t\tcanon.add(dfn[now],1);\n\t\t}\n\t\tvoid back(){\n\t\t\tcanon.add(dfn[now],-1);\n\t\t\tnow=ops[ops.size()-1];\n\t\t\tops.pop_back();\n\t\t}\n\t\tint devote(int x){\n\t\t\treturn canon.ask(dfn[ep[x]],rdfn[ep[x]]);\n\t\t}\n\t}nor,rev;\n\t\n\n}\nusing namespace easypartofstring;\n\nnamespace hardpartforstring{\n\tstruct sam{\n\t\tint ch[mn][26];int pa[mn],len[mn];int rig[mn];\n\t\tint tot=1,lst=1;int all[nn],zzz;\n\t\tvoid news(){\n\t\t\tall[++zzz]=-1;\n\t\t\tlst=1;\n\t\t}\n\t\tint extend(int c){\n\t\t\tall[++zzz]=c;\n\t\t\tint p=lst,q=++tot;len[q]=len[p]+1,lst=q;rig[q]=zzz;\n\t\t\twhile(p and !ch[p][c]) ch[p][c]=q,p=pa[p];\n\t\t\t\n\t\t\tif(!p){\n\t\t\t\tpa[q]=1;return q;\n\t\t\t}\n\t\t\t\n\t\t\tint x=ch[p][c];\n\t\t\tif(len[x]==len[p]+1){\n\t\t\t\tpa[q]=x;return q;\n\t\t\t}\n\t\t\t\n\t\t\tint y=++tot;pa[y]=pa[x],pa[x]=pa[q]=y;len[y]=len[p]+1;\n\t\t\tfor(int i=0;i<26;i++) ch[y][i]=ch[x][i];\n\t\t\twhile(p and ch[p][c]==x) ch[p][c]=y,p=pa[p];\n\t\t\treturn q;\n\t\t}\n\t\tvector<int> v[nn];int dfn[nn],rdfn[nn],DFN;\n\t\tvoid dfs(int x){\n\t\t\tdfn[x]=++DFN;\n\t\t\tfor(int i=0;i<v[x].size();i++) dfs(v[x][i]),rig[x]=rig[v[x][i]];\n\t\t\trdfn[x]=DFN;\n\t\t}\n\t\tvoid build(){\n\t\t\tfor(int i=2;i<=tot;i++) v[pa[i]].push_back(i);\n\t\t\tdfs(1);\n\t\t}\n\t\t\n\t\tint cl=0;int now=1;vector<int> ops;vector<int> zero;\n\t\tvoid walk(int x){\n\t\t\tif(zero.size()==0) zero.push_back(1);\n\t\t\tops.push_back(now);cl++;\n\t\t\tif(now){\n\t\t\t\tif(cl<=len[now]) now=now*(x==all[rig[now]-cl+1]);\n\t\t\t\telse{\n\t\t\t\t\tint ui=0;\n\t\t\t\t\tfor(int i=0;i<v[now].size();i++) {\n\t\t\t\t\t\tint y=v[now][i];\n\t\t\t\t\t\tif(x==all[rig[y]-cl+1]) {\n\t\t\t\t\t\t//\tif(ui) assert(0);\n\t\t\t\t\t\t\tui=1;now=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow=now*ui;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!now)zero.push_back(zero[zero.size()-1]);\n\t\t\telse zero.push_back(now);\n\t\t}\t\n\t\tvoid back(){\n\t\t\tnow=ops[ops.size()-1];cl--;ops.pop_back();zero.pop_back();\n\t\t}\n\t\tint ask(){\n\t\t\tif(zero.size()==0) zero.push_back(1);\n\t\t\treturn zero[zero.size()-1];\n\t\t}\n\t}rnor,rrev;\n\t\n\t\n\tint uid;\n\tint st[nn],rst[nn];\n\tvector<int> sst[nn],rsst[nn];\n\tvoid bark(string s){vector<int> _,r_;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\t_.push_back(rnor.extend(s[i]-'a'));r_.push_back(rrev.extend(s[s.size()-i-1]-'a'));\n\t\t}\n\t\tst[++uid]=_[0],rst[uid]=r_[0];\n\t\tswap(sst[uid],_);swap(rsst[uid],r_);\n\t\trnor.news();rrev.news();\n\t}\n};\nusing namespace hardpartforstring;\n\nint used[nn];\nint xi[nn],yi[nn],zi[nn];\nvector<int> v[nn],g[nn];\nstring str[nn];\n\nchar ch[nn];\nstring ins(){\n\tscanf(\"%s\",ch);int n=strlen(ch);\n\tstring s;for(int i=0;i<n;i++) s+=ch[i];\n\treturn s;\n}\n\n\nint n,m,q;\nint all;int size[nn],dep[nn];\nint era[nn];\nint bst,bstid;\nvector<int> query[nn];\nvoid cc(int x,int p){\n\tint cp=0;size[x]=1+query[x].size();\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p and !era[v[x][i]]) cc(v[x][i],x),size[x]+=size[v[x][i]],cp=max(cp,size[v[x][i]]);\n\tcp=max(cp,all-size[x]);\n\tif(cp<bst) bst=cp,bstid=x;\n}\nvoid dc(int x,int p){\n\tvector<int> kl;for(int i=0;i<query[x].size();i++) if(!used[query[x][i]]) kl.push_back(query[x][i]);swap(kl,query[x]);\n\t\n\tsize[x]=1+query[x].size();\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p and !era[v[x][i]]) dc(v[x][i],x),size[x]+=size[v[x][i]];\n}\nvector<int> inv;int bap[nn],cap[nn];\nint fst[nn],sec[nn];\nvoid dfs(int x,int p){\n\tif(p) bap[x]=bap[p];else bap[x]=x;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p and !era[v[x][i]])\n\t\tdfs(v[x][i],x);\n\tfor(int i=0;i<query[x].size();i++){\n\t\tint y=query[x][i];inv.push_back(y);\n\t\tif(cap[y] and cap[y]!=bap[x]) used[y]=1;\n\t\telse cap[y]=bap[x];\n\t}\n}\n\n\nvoid efs(int x,int p){\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p and !era[v[x][i]]){\n\t\tnor.walk(g[x][i]),rev.walk(g[x][i]);\n\t\trnor.walk(g[x][i]),rrev.walk(g[x][i]);\n\t\tefs(v[x][i],x);\n\t\tnor.back(),rev.back();\n\t\trnor.back(),rrev.back();\n\t}\n\t\n\tfor(int i=0;i<query[x].size();i++)if(used[query[x][i]]){\n\t\tint z=query[x][i];\n\t\tif(xi[z]==x){\n\t\t\tans[z]+=rev.devote(zi[z]);\n\t\t\tfst[z]=rnor.ask();\n\t\t}\n\t\telse {\n\t\t\tans[z]+=nor.devote(zi[z]);\n\t\t\tsec[z]=rrev.ask();\n\t\t}\n\t}\n\t\n}\nvoid solve(int x,int _all){\n\tall=bst=_all;cc(x,0);x=bstid;\n\tera[x]=1;inv.clear();\n\tfor(int i=0;i<query[x].size();i++) used[query[x][i]]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!era[v[x][i]])\n\t\tdfs(v[x][i],0);\n\tfor(int i=0;i<v[x].size();i++) if(!era[v[x][i]]){\n\t\tnor.walk(g[x][i]),rev.walk(g[x][i]);\n\t\trnor.walk(g[x][i]),rrev.walk(g[x][i]);\n\t\tefs(v[x][i],0);\n\t\tnor.back(),rev.back();\n\t\trnor.back(),rrev.back();\n\t}\n\t\n\tdc(x,0);for(int i=0;i<inv.size();i++) cap[inv[i]]=0;\n\tfor(int i=0;i<v[x].size();i++) if(!era[v[x][i]]) solve(v[x][i],size[v[x][i]]);\n}\nvoid addedge(int x,int y,int z){\n\tv[x].push_back(y);v[y].push_back(x);\n\tg[x].push_back(z);g[y].push_back(z);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;char c[2];scanf(\"%d%d%s\",&x,&y,c);\n\t\taddedge(x,y,c[0]-'a');\n\t}\n\tfor(int i=1;i<=m;i++) str[i]=ins(),nor.ins(str[i]),reverse(str[i].begin(),\n\t\tstr[i].end()),rev.ins(str[i]),reverse(str[i].begin(),str[i].end()),bark(str[i]);\n\tnor.build(),rev.build();\n\t\n\trnor.build(),rrev.build();\n\tfor(int i=1;i<=q;i++){\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\tquery[x].push_back(i);query[y].push_back(i);\n\t\txi[i]=x,yi[i]=y,zi[i]=z;\n\t}\n\tsolve(1,n+q+q);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=0;j<sst[i].size()-1;j++) {\n\t\t\tint k=sst[i].size()-j-2;\n\t\t\tptilopsis::ins(rnor.dfn[sst[i][j]],rrev.dfn[rsst[i][k]],0,i);\n\t\t\tptilopsis::ins(1+rnor.rdfn[sst[i][j]],rrev.dfn[rsst[i][k]],-1,i);\n\t\t\tptilopsis::ins(rnor.dfn[sst[i][j]],1+rrev.rdfn[rsst[i][k]],-1,i);\n\t\t\tptilopsis::ins(1+rnor.rdfn[sst[i][j]],1+rrev.rdfn[rsst[i][k]],0,i);\n\t\t}\n\tfor(int i=1;i<=q;i++) if(fst[i] and sec[i]) ptilopsis::ins(rnor.dfn[fst[i]],rrev.dfn[sec[i]],i,zi[i]);\t\n\n\tptilopsis::solve();\n\t\n\tfor(int i=1;i<=q;i++) assert(used[i]),printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n/*\n6 1 1\n1 6 b\n2 3 a\n1 2 b\n5 3 b\n4 5 b\nab\n2 5 1\n\n*/\n   \t\t  \t \t\t     \t\t\t\t \t\t\t \t \t\t\t"
}