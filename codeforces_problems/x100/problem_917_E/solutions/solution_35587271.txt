{
    "id": 35587271,
    "contestId": 917,
    "creationTimeSeconds": 1519354967,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "laofudasuan"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 436,
    "memoryConsumedBytes": 142233600,
    "source": "#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#include<queue>\r\n#include<set>\r\n#include<map>\r\n#include<stack>\r\n#include<bitset>\r\n\r\n#define pb push_back\r\n#define mp make_pair\r\n\r\nusing namespace std;\r\n\r\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\r\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\r\n\r\ntypedef unsigned int u32;\r\ntypedef long long LL;\r\ntypedef unsigned long long ULL;\r\ntypedef long double lod;\r\ntypedef pair<int,int> PR;\r\ntypedef vector<int> VI;\r\n\r\nconst lod pi=acos(-1);\r\nconst int oo=1<<30;\r\nconst LL OO=1e18;\r\n\r\nconst int N=1e5+100;\r\n\r\nint gi() {\r\n\tint w=0;bool q=1;char c=getchar();\r\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\r\n\tif (c=='-') q=0,c=getchar();\r\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\r\n\treturn q? w:-w;\r\n}\r\n\r\nint n,m,Q;\r\nint len[N*2],*s[N*2],S[N*2],ans[N],now[N],last[N*2];\r\nstruct Query{ int u,v,id,k; }q[N];\r\n\r\nnamespace AC_automatic{\r\n\tint son[N*2][26],tot=1,cnt,q[N*2],fr[N*2];\r\n\tint L[N*2],R[N*2],fail[N*2],dep[N*2];\r\n\tint head[N*2],nxt[N*2],c[N*2];\r\n\tint IN[N*2],*in[N*2];\r\n\tinline void add(int k,int t) { for (k=L[k];k<=tot;k+=k&-k) c[k]+=t; }\r\n\tinline int sum(int k) { int ans=0; for (int x=R[k];x;x^=x&-x) ans+=c[x]; for (k=L[k]-1;k;k^=k&-k) ans-=c[k]; return ans; }\r\n\tinline void dfs(int k) {\r\n\t\tL[k]=++cnt;\r\n\t\tfor (int i=head[k];i;i=nxt[i]) dfs(i);\r\n\t\tR[k]=cnt;\r\n\t}\r\n\tinline void build() {\r\n\t\tfr[1]=1;in[1]=IN;\r\n\t\tfor (int i=1,*j,*p=IN,k;i<=m;in[++i]=p)\r\n\t\t\tfor (k=1,j=s[i];j++!=s[i+1];*++p=k=son[k][*j])\r\n\t\t\t\tif (!son[k][*j])\r\n\t\t\t\t\tson[k][*j]=++tot,dep[tot]=dep[k]+1,fr[tot]=i;\r\n\t\tint l=1,r=1;q[1]=fail[1]=1;\r\n\t\tfor (int i=0;i<26;i++)\r\n\t\t\tif (son[1][i])\r\n\t\t\t\tfail[q[++r]=son[1][i]]=1;\r\n\t\t\telse\r\n\t\t\t\tson[1][i]=1;\r\n\t\twhile (l!=r)\r\n\t\t\tfor (int k=q[++l],i=0;i<26;i++)\r\n\t\t\t\tif (son[k][i])\r\n\t\t\t\t\tfail[q[++r]=son[k][i]]=son[fail[k]][i];\r\n\t\t\t\telse\r\n\t\t\t\t\tson[k][i]=son[fail[k]][i];\r\n\t\tfor (int i=2;i<=tot;i++) nxt[i]=head[fail[i]],head[fail[i]]=i;\r\n\t\tdfs(1);\r\n\t}\r\n}\r\n\r\nnamespace Suffix_Tree{\r\n\tint son[N*4][26],to[N*4][26],fa[N*4],len[N*4],tot=1;\r\n\tint fr[N*4],rig[N*4];\r\n\tint L[N*4],R[N*4],cnt;\r\n\tinline int add(int p,int c,int _fr,int _rig) {\r\n\t\tint np=++tot,q,nq;\r\n\t\tlen[np]=len[p]+1;\r\n\t\tfr[np]=_fr;rig[np]=_rig;\r\n\t\tfor (;p&&!son[p][c];p=fa[p])\r\n\t\t\tson[p][c]=np;\r\n\t\tif (!p) fa[np]=1;\r\n\t\telse if (len[q=son[p][c]]==len[p]+1) fa[np]=q;\r\n\t\telse {\r\n\t\t\tnq=++tot;\r\n\t\t\tlen[nq]=len[p]+1;\r\n\t\t\tfr[nq]=fr[q];rig[nq]=rig[q];\r\n\t\t\tmemcpy(son[nq],son[q],sizeof(son[q]));\r\n\t\t\tfa[nq]=fa[q],fa[q]=fa[np]=nq;\r\n\t\t\tfor (;son[p][c]==q;p=fa[p])\r\n\t\t\t\tson[p][c]=nq;\r\n\t\t}\r\n\t\treturn np;\r\n\t}\r\n\tinline int go(int k,int l,int c) {\r\n\t\tif (k<0) return k;\r\n\t\tif (len[k]==l)\r\n\t\t\treturn to[k][c]?to[k][c]:-k;\r\n\t\treturn c==s[fr[k]][rig[k]-l]?k:-k;\r\n\t}\r\n\tinline void dfs(int k) {\r\n\t\tL[k]=++cnt;\r\n\t\tfor (int i=0;i<26;i++)\r\n\t\t\tif (to[k][i])\r\n\t\t\t\tdfs(to[k][i]);\r\n\t\tR[k]=cnt;\r\n\t}\r\n\tint c[N*4];PR eve[N],st[N];\r\n\tinline void modify(int k,int t) { while (k<=cnt) c[k]+=t,k+=k&-k; }\r\n\tinline int sum(int k) { int ans=0; while (k) ans+=c[k],k^=k&-k; return ans; }\r\n\tinline void build() {\r\n\t\tfor (int k=2;k<=tot;k++)\r\n\t\t\tto[fa[k]][s[fr[k]][rig[k]-len[fa[k]]]]=k;\r\n\t}\r\n\tinline void solve() {\r\n\t\tdfs(1);\r\n\t\tsort(q,q+Q,[&](Query a,Query b){return a.k==b.k?L[a.u]<L[b.u]:a.k<b.k;});\r\n\t\tQuery *cur=q;\r\n\t\tfor (int i=1,t,j,k,top;i<=m/2;i++) {\r\n\t\t\tfor (j=k=1;j<::len[i];j++) now[j]=k=son[k][s[i][j]];\r\n\t\t\tfor (j=k=1;j<::len[i];j++) {\r\n\t\t\t\tk=son[k][s[i+m/2][j]];\r\n\t\t\t\teve[j]=mp(now[::len[i]-j],k);\r\n\t\t\t}\r\n\t\t\tsort(eve+1,eve+::len[i],[&](PR a,PR b){return L[a.first]<L[b.first];});top=0;\r\n\t\t\tfor (t=1;cur->k==i;cur++) {\r\n\t\t\t\tfor (;t<::len[i]&&L[eve[t].first]<=L[cur->u];t++) {\r\n\t\t\t\t\tmodify(L[eve[t].second],1);\r\n\t\t\t\t\tmodify(R[eve[t].second]+1,-1);\r\n\t\t\t\t\tfor (;top&&R[st[top].first]<L[eve[t].first];top--) {\r\n\t\t\t\t\t\tmodify(L[st[top].second],-1);\r\n\t\t\t\t\t\tmodify(R[st[top].second]+1,1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tst[++top]=eve[t];\r\n\t\t\t\t}\r\n\t\t\t\tfor (;top&&R[st[top].first]<L[cur->u];top--) {\r\n\t\t\t\t\tmodify(L[st[top].second],-1);\r\n\t\t\t\t\tmodify(R[st[top].second]+1,1);\r\n\t\t\t\t}\r\n\t\t\t\tans[cur->id]+=sum(L[cur->v]);\r\n\t\t\t}\r\n\t\t\twhile (top) {\r\n\t\t\t\tmodify(L[st[top].second],-1);\r\n\t\t\t\tmodify(R[st[top--].second]+1,1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\ninline void build() {\r\n\tusing namespace AC_automatic;\r\n\tlast[1]=1;\r\n\tfor (int *k=AC_automatic::q+1,t;*k;k++)\r\n\t\tfor (int c=0;c<26;c++)\r\n\t\t\tif (dep[t=son[*k][c]]>dep[*k])\r\n\t\t\t\tlast[t]=Suffix_Tree::add(last[*k],c,fr[t],dep[t]);\r\n}\r\n\r\nint head[N],nxt[N*2],to[N*2],c[N*2];\r\nint siz[N],mi,rt,all,col[N],pos[N];bool vis[N];\r\nvector<PR>eve[N];\r\n\r\ninline void dfs1(int k,int fa) {\r\n\tsiz[k]=1;\r\n\tfor (int i=head[k];i;i=nxt[i])\r\n\t\tif (to[i]!=fa&&!vis[to[i]])\r\n\t\t\tdfs1(to[i],k),siz[k]+=siz[to[i]];\r\n}\r\ninline void dfs2(int k,int fa) {\r\n\tint mx=all-siz[k];\r\n\tfor (int i=head[k];i;i=nxt[i])\r\n\t\tif (to[i]!=fa&&!vis[to[i]])\r\n\t\t\tdfs2(to[i],k),upmax(mx,siz[to[i]]);\r\n\tif (mx<mi)\r\n\t\tmi=mx,rt=k;\r\n}\r\ninline void tick(int k,int fa) {\r\n\teve[k].clear();\r\n\tfor (int i=head[k];i;i=nxt[i])\r\n\t\tif (to[i]!=fa&&!vis[to[i]])\r\n\t\t\tcol[to[i]]=col[k],tick(to[i],k);\r\n}\r\ninline void solve(int k,int fa,int d,int t) {\r\n\tusing namespace AC_automatic;\r\n\tadd(t,1);\r\n\tfor (PR &p:eve[k])\r\n\t\tans[p.second]+=sum(p.first);\r\n\tfor (int i=::head[k];i;i=::nxt[i])\r\n\t\tif (to[i]!=fa&&!vis[to[i]]) {\r\n\t\t\tpos[to[i]]=Suffix_Tree::go(pos[k],d,::c[i]);\r\n\t\t\tsolve(to[i],k,d+1,son[t][::c[i]]);\r\n\t\t}\r\n\tpos[k]=abs(pos[k]);\r\n\t//if (Suffix_Tree::len[pos[k]]>d) pos[k]=Suffix_Tree::fa[pos[k]];\r\n\tadd(t,-1);\r\n}\r\ninline void devide(int k,int l,int r) {\r\n\tdfs1(k,0);\r\n\tmi=all=siz[k];\r\n\tdfs2(k,0);\r\n\tvis[k=rt]=true;\r\n\tcol[k]=k;pos[k]=1;\r\n\tfor (int i=head[k];i;i=nxt[i])\r\n\t\tif (!vis[to[i]])\r\n\t\t\tcol[to[i]]=to[i],tick(to[i],k);\r\n\tint R=l;\r\n\tfor (int i=l;i<r;i++)\r\n\t\tif (col[q[i].u]==col[q[i].v])\r\n\t\t\tswap(q[R++],q[i]);\r\n\t\telse {\r\n\t\t\tif (q[i].u!=k)\r\n\t\t\t\teve[q[i].u].pb(mp(*AC_automatic::in[q[i].k+1+m/2],q[i].id));\r\n\t\t\tif (q[i].v!=k)\r\n\t\t\t\teve[q[i].v].pb(mp(*AC_automatic::in[q[i].k+1],q[i].id));\r\n\t\t}\r\n\tsolve(k,0,0,1);\r\n\tfor (int i=R;i<r;i++)\r\n\t\tq[i].u=pos[q[i].u],q[i].v=pos[q[i].v];\r\n\tsort(q+l,q+R,[&](Query a,Query b){return col[a.u]<col[b.u];});\r\n\tfor (int i=l,j;i<R;i=j) {\r\n\t\tfor (j=i;j<R&&col[q[i].u]==col[q[j].u];j++);\r\n\t\tdevide(col[q[i].u],i,j);\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n#ifndef ONLINE_JUDGE\r\n\tfreopen(\"E.in\",\"r\",stdin);\r\n\tfreopen(\"E.out\",\"w\",stdout);\r\n#endif\r\n\tint i,a,b,tot=1,*cur;\r\n\tn=gi(),m=gi(),Q=gi();\r\n\tfor (i=1;i<n;i++) {\r\n\t\ta=gi(),b=gi();\r\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\r\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\r\n\t\tc[tot]=c[tot-1]=getchar()-'a';\r\n\t\tgetchar();\r\n\t}\r\n\ts[1]=S;\r\n\tfor (i=1;i<=m;i++) {\r\n\t\tfor (char ch;'a'<=(ch=getchar())&&ch<='z';s[i][++len[i]]=ch-'a');\r\n\t\ts[i+1]=s[i]+len[i];\r\n\t}\r\n\tfor (i=m+1,m<<=1;i<=m;i++) {\r\n\t\tfor (cur=s[i-m/2+1];cur!=s[i-m/2];s[i][++len[i]]=*cur--);\r\n\t\ts[i+1]=s[i]+len[i];\r\n\t}\r\n\tfor (i=0;i<Q;i++) q[i].u=gi(),q[i].v=gi(),q[i].k=gi(),q[i].id=i;\r\n\tAC_automatic::build();\r\n\tbuild();\r\n\tSuffix_Tree::build();\r\n\tdevide(1,0,Q);\r\n\tSuffix_Tree::solve();\r\n\tfor (i=0;i<Q;i++)\r\n\t\tprintf(\"%d\\n\",ans[i]);\r\n\treturn 0;\r\n}\r\n"
}