{
    "id": 36340500,
    "contestId": 917,
    "creationTimeSeconds": 1521255798,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "zxyhh"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 951,
    "memoryConsumedBytes": 303206400,
    "source": "#include <bits/stdc++.h>\r\n#define N 200001\r\nusing namespace std;\r\nint n,m,Q,E,cnt,cntpoi,tree[N],ret[N];\r\nint to[N],nex[N],fir[N],w[N],pa[N];\r\nint st[N],ed[N],size[N],co[N],dep[N];\r\nint acori[N],acrev[N];\r\nvector<int> vec[N];\r\nbool vis[N];\r\nint posori[N],posrev[N];\r\nstruct point\r\n{\r\n\tint x,y,t;\r\n\tpoint(int p,int q,int o){x=p;y=q;t=o;}\r\n\tpoint(){}\r\n} po[5*N];\r\nstruct query\r\n{\r\n\tint x,y,z,wei,id;\r\n} que[N];\r\nbool operator<(query a,query b)\r\n{\r\n\treturn a.wei<b.wei; \r\n}\r\nbool comz(query a,query b)\r\n{\r\n\treturn a.z<b.z;\r\n}\r\nstruct mzc\r\n{\r\n\tint NODE,SAMNODE,TIME,acTIME;\r\n\tint c[N][26],lis[N],tr[N][26],fir[N],nex[N];\r\n\tint mx[N],poi[N],lp[N],rp[N],str[N],from[N];\r\n\tint fail[N],fa[N],ch[N][26],aclp[N],acrp[N];\r\n\tint insert(int l,int r,int* a,bool rev) \r\n\t{\r\n\t\tint now=0;\r\n\t\tif(!rev)\r\n\t\tfor(int i=l;i<=r;i++)\r\n\t\t{\r\n\t\t\tnow=c[now][pa[i]]?c[now][pa[i]]:(c[now][pa[i]]=++NODE);\r\n\t\t\ta[i]=now;str[now]=i;\r\n\t\t}\r\n\t\telse\r\n\t\tfor(int i=r;i>=l;i--)\r\n\t\t{\r\n\t\t\tnow=c[now][pa[i]]?c[now][pa[i]]:(c[now][pa[i]]=++NODE);\r\n\t\t\ta[i]=now;str[now]=i;\r\n\t\t}\r\n\t\treturn now;\r\n\t}\r\n\tint extend(int p,int c,int pos)\r\n\t{\r\n\t\tint np=++SAMNODE,q,nq;\r\n\t\tmx[np]=mx[p]+1;from[np]=pos;\r\n\t\tfor(;p && !tr[p][c];p=fa[p]) tr[p][c]=np;\r\n\t\tif(!p)\r\n\t\t\tfa[np]=1;\r\n\t\telse\r\n\t\tif(mx[q=tr[p][c]]==mx[p]+1)\r\n\t\t\tfa[np]=q;\r\n\t\telse\r\n\t\t{\r\n\t\t\tmx[nq=++SAMNODE]=mx[p]+1;from[nq]=pos;\r\n\t\t\tmemcpy(tr[nq],tr[q],sizeof tr[q]);\r\n\t\t\tfa[nq]=fa[q];fa[q]=fa[np]=nq;\r\n\t\t\tfor(;p && tr[p][c]==q;p=fa[p])\r\n\t\t\t\ttr[p][c]=nq;\r\n\t\t}\r\n\t\treturn np;\r\n\t}\r\n\tvoid dfs(int now)\r\n\t{\r\n\t\tlp[now]=++TIME;\r\n\t\tfor(int i=0;i<26;i++)\r\n\t\tif(ch[now][i])\r\n\t\t\tdfs(ch[now][i]);\r\n\t\trp[now]=TIME;\r\n\t}\r\n\tvoid acdfs(int now)\r\n\t{\r\n\t\taclp[now]=++acTIME;\r\n\t\tfor(int i=fir[now];i;i=nex[i])\r\n\t\t\tacdfs(i);\r\n\t\tacrp[now]=acTIME;\r\n\t}\r\n\tvoid build(bool rev)\r\n\t{\r\n\t\tfor(int h=1,t=1;h<=t;h++)\r\n\t\t\tfor(int i=0;i<26;i++)\r\n\t\t\tif(c[lis[h]][i])\r\n\t\t\t{\r\n\t\t\t\tint tem=fail[lis[h]];\r\n\t\t\t\twhile(tem && !c[tem][i]) tem=fail[tem];\r\n\t\t\t\tfail[lis[++t]=c[lis[h]][i]]=c[tem][i];\r\n\t\t\t\tif(fail[lis[t]]==lis[t]) fail[lis[t]]=0;\r\n\t\t\t\tpoi[lis[t]]=extend(poi[lis[h]],i,str[lis[t]]);\r\n\t\t\t}\r\n\t\tfor(int i=2;i<=SAMNODE;i++)\r\n\t\t\tch[fa[i]][pa[rev?from[i]+mx[fa[i]]:(from[i]-mx[fa[i]])]]=i;\r\n\t\tfor(int i=1;i<=NODE;i++)\r\n\t\t\tnex[i]=fir[fail[i]],fir[fail[i]]=i;\r\n\t\tdfs(1);acdfs(0);\r\n\t}\r\n\tmzc()\r\n\t{\r\n\t\tmemset(c,0,sizeof c);\r\n\t\tmemset(lis,0,sizeof lis);\r\n\t\tmemset(fail,0,sizeof fail);\r\n\t\tmemset(tr,0,sizeof tr);\r\n\t\tmemset(fa,0,sizeof fa);\r\n\t\tmemset(ch,0,sizeof ch);\r\n\t\tmemset(fir,0,sizeof fir);\r\n\t\tNODE=0;SAMNODE=1;acTIME=0;poi[0]=1;TIME=0; \r\n\t}\r\n} ori,rev;\r\nstruct state\r\n{\r\n\tint p1,p2,le1,le2,p3,p4;\r\n\tbool d1,d2;\r\n\tstate(){ p1=p2=1;le1=le2=d1=d2=p3=p4=0;}\r\n} sta[N][20];\r\nstate trans(state x,int y)\r\n{\r\n\tif(!x.d1)\r\n\t\tif(x.le1==ori.mx[x.p1])\r\n\t\t\tif(ori.ch[x.p1][y]) x.p1=ori.ch[x.p1][y],x.le1++;\r\n\t\t\telse x.d1=1;\r\n\t\telse\r\n\t\t\tif(pa[ori.from[x.p1]-x.le1]==y) x.le1++;\r\n\t\t\telse x.d1=1;\r\n\tif(!x.d2)\r\n\t\tif(x.le2==rev.mx[x.p2])\r\n\t\t\tif(rev.ch[x.p2][y]) x.p2=rev.ch[x.p2][y],x.le2++;\r\n\t\t\telse x.d2=1;\r\n\t\telse\r\n\t\t\tif(pa[rev.from[x.p2]+x.le2]==y) x.le2++;\r\n\t\t\telse x.d2=1;\r\n\t//ac\r\n\twhile(x.p3 && !ori.c[x.p3][y])\r\n\t\tx.p3=ori.fail[x.p3];\r\n\tif(ori.c[x.p3][y]) x.p3=ori.c[x.p3][y];\r\n\twhile(x.p4 && !rev.c[x.p4][y])\r\n\t\tx.p4=rev.fail[x.p4];\r\n\tif(rev.c[x.p4][y]) x.p4=rev.c[x.p4][y];\r\n\treturn x;\r\n}\r\nvoid add(int p,int q,int o)\r\n{\r\n\tto[++E]=q;nex[E]=fir[p];fir[p]=E;w[E]=o;\r\n}\r\nint getsize(int now,int fat)\r\n{\r\n\tsize[now]=1;\r\n\tfor(int i=fir[now];i;i=nex[i])\r\n\tif(to[i]!=fat && !vis[to[i]])\r\n\t\tsize[now]+=getsize(to[i],now);\r\n\treturn size[now];\r\n}\r\nvoid paint(int now,int fat,int color,int alpha,int depth)\r\n{\r\n\tco[now]=color;\r\n\tsta[now][depth]=trans(sta[fat][depth],alpha);\r\n\tfor(int i=fir[now];i;i=nex[i])\r\n\tif(!vis[to[i]] && to[i]!=fat)\r\n\t\tpaint(to[i],now,color,w[i],depth);\r\n}\r\nint oritr[N],revtr[N];\r\nvoid acaddori(int x,int y)\r\n{\r\n\twhile(x<N)\r\n\t{\r\n\t\toritr[x]+=y;\r\n\t\tx+=x&-x;\r\n\t}\r\n}\r\nvoid acaddrev(int x,int y)\r\n{\r\n\twhile(x<N)\r\n\t{\r\n\t\trevtr[x]+=y;\r\n\t\tx+=x&-x;\r\n\t}\r\n}\r\nint acqueori(int x,int y)\r\n{\r\n\tint ret=0;\r\n\tx--;\r\n\twhile(x)\r\n\t{\r\n\t\tret-=oritr[x];\r\n\t\tx-=x&-x;\r\n\t}\r\n\twhile(y)\r\n\t{\r\n\t\tret+=oritr[y];\r\n\t\ty-=y&-y;\r\n\t}\r\n\treturn ret;\r\n}\r\nint acquerev(int x,int y)\r\n{\r\n\tint ret=0;\r\n\tx--;\r\n\twhile(x)\r\n\t{\r\n\t\tret-=revtr[x];\r\n\t\tx-=x&-x;\r\n\t}\r\n\twhile(y)\r\n\t{\r\n\t\tret+=revtr[y];\r\n\t\ty-=y&-y;\r\n\t}\r\n\treturn ret;\r\n}\r\nvoid acdfs(int now,int fat,int depth)\r\n{\r\n\tacaddori(ori.aclp[sta[now][depth].p3],1);\r\n\tacaddrev(rev.aclp[sta[now][depth].p4],1);\r\n\tfor(int i=0;i<vec[now].size();i++)\r\n\tif(vec[now][i]>0)\r\n\t\tret[que[vec[now][i]].id]+=acquerev(rev.aclp[acrev[que[vec[now][i]].z]],rev.acrp[acrev[que[vec[now][i]].z]]);\r\n\telse\r\n\t\tret[que[-vec[now][i]].id]+=acqueori(ori.aclp[acori[que[-vec[now][i]].z]],ori.acrp[acori[que[-vec[now][i]].z]]);\r\n\tvec[now].clear();\r\n\tfor(int i=fir[now];i;i=nex[i])\r\n\tif(!vis[to[i]] && to[i]!=fat)\r\n\t\tacdfs(to[i],now,depth);\r\n\tacaddori(ori.aclp[sta[now][depth].p3],-1);\r\n\tacaddrev(rev.aclp[sta[now][depth].p4],-1);\r\n}\r\nvoid solve(int now,int l,int r,int depth)\r\n{\r\n\tint allsize=getsize(now,0)/2,fat=0;\r\n\tfor(bool flag=1;flag;)\r\n\t{\r\n\t\tflag=0;\r\n\t\tfor(int i=fir[now];i;i=nex[i])\r\n\t\tif(to[i]!=fat && !vis[to[i]] && size[to[i]]>allsize)\r\n\t\t{\r\n\t\t\tfat=now;now=to[i];flag=1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tvis[now]=1;co[now]=0;dep[now]=depth;\r\n\tint color=0;\r\n\tfor(int i=fir[now];i;i=nex[i])\r\n\tif(!vis[to[i]])\r\n\t\tpaint(to[i],now,++color,w[i],depth);\r\n\tfor(int i=l;i<=r;i++)\r\n\t\tque[i].wei=co[que[i].x]==co[que[i].y]?co[que[i].x]:0;\r\n\tsort(que+l,que+r+1);\r\n\tint j=l;\r\n\tfor(;j<=r && que[j].wei==0;j++)\r\n\t{\r\n\t\tque[j].wei=now;\r\n\t\tvec[que[j].x].push_back(j);\r\n\t\tvec[que[j].y].push_back(-j);\r\n\t}\r\n\tfor(int i=fir[now];i;i=nex[i])\r\n\tif(!vis[to[i]])\r\n\t\tacdfs(to[i],now,depth);\r\n\tif(j>r) return;\r\n\tfor(int i=fir[now];i;i=nex[i])\r\n\tif(!vis[to[i]] && que[j].wei==co[to[i]])\r\n\t{\r\n\t\tint st=j;\r\n\t\twhile(j<=r && que[j].wei==que[st].wei) j++;\r\n\t\tsolve(to[i],st,j-1,depth+1);\r\n\t\tif(j>r) return;\r\n\t}\r\n}\r\nvoid Plus(int l1,int r1,int l2,int r2)\r\n{\r\n\tpo[++cntpoi]=point(l1,l2,1);\r\n\tpo[++cntpoi]=point(l1,r2+1,-1);\r\n\tpo[++cntpoi]=point(r1+1,l2,-1);\r\n\tpo[++cntpoi]=point(r1+1,r2+1,1);\r\n//\tprintf(\"+%d %d %d %d\\n\",l1,r1,l2,r2);\r\n}\r\nbool operator<(point a,point b)\r\n{\r\n\treturn a.x==b.x?a.y==b.y?a.t<b.t:a.y<b.y:a.x<b.x;\r\n}\r\nvoid add(int x,int y)\r\n{\r\n\twhile(x<N)\r\n\t{\r\n\t\ttree[x]+=y;\r\n\t\tx+=x&-x;\r\n\t}\r\n}\r\nint sum(int x)\r\n{\r\n\tint ret=0;\r\n\twhile(x)\r\n\t{\r\n\t\tret+=tree[x];\r\n\t\tx-=x&-x;\r\n\t}\r\n\treturn ret;\r\n}\r\nint main()\r\n{\r\n\tscanf(\"%d%d%d\",&n,&m,&Q);\r\n\tfor(int i=1;i<n;i++)\r\n\t{\r\n\t\tint p,q;\r\n\t\tscanf(\"%d%d\",&p,&q);\r\n\t\tchar ch=getchar();\r\n\t\tfor(;!isalpha(ch);ch=getchar());\r\n\t\tch-='a';add(p,q,ch);add(q,p,ch);\r\n\t}\r\n\tfor(int i=1;i<=m;i++)\r\n\t{\r\n\t\tchar ch=getchar();\r\n\t\tfor(;!isalpha(ch);ch=getchar());\r\n\t\tst[i]=cnt+1;\r\n\t\tfor(;isalpha(ch);ch=getchar())\r\n\t\t\tpa[++cnt]=ch-'a';\r\n\t\tacori[i]=ori.insert(st[i],ed[i]=cnt,posori,0);\r\n\t\tacrev[i]=rev.insert(st[i],ed[i],posrev,1);\r\n\t}\r\n\tori.build(0);rev.build(1);\r\n\tfor(int i=1;i<=cnt;i++)\r\n\t{\r\n\t\tposori[i]=ori.poi[posori[i]];\r\n\t\tposrev[i]=rev.poi[posrev[i]];\r\n\t} \r\n\tfor(int i=1;i<=Q;i++)\r\n\t\tscanf(\"%d%d%d\",&que[i].x,&que[i].y,&que[i].z),que[i].id=i;\r\n\tsolve(1,1,Q,0);\r\n\tsort(que+1,que+Q+1,comz);\r\n\tfor(int i=1,j=1;i<=m && j<=Q;i++)\r\n\tif(que[j].z==i)\r\n\t{\r\n\t\tcntpoi=0;\r\n//\t\tprintf(\"%d:\\n\",i);\r\n\t\tfor(int k=st[i];k<ed[i];k++)\r\n\t\t\tPlus(ori.lp[posori[k]],ori.rp[posori[k]],rev.lp[posrev[k+1]],rev.rp[posrev[k+1]]);\r\n\t\tfor(;j<=Q && que[j].z==i;j++)\r\n\t\t{\r\n\t\t\tstate x=sta[que[j].x][dep[que[j].wei]],y=sta[que[j].y][dep[que[j].wei]];\r\n\t\t\tif(x.le1<ori.mx[x.p1])\r\n\t\t\t\tx.p1=ori.fa[x.p1];\r\n\t\t\tif(y.le2<rev.mx[y.p2])\r\n\t\t\t\ty.p2=rev.fa[y.p2];\r\n\t\t\tpo[++cntpoi]=point(ori.lp[x.p1],rev.lp[y.p2],j+1);\r\n//\t\t\tprintf(\"Q%d %d\\n\",ori.lp[x.p1],rev.lp[y.p2]);\r\n\t\t}\r\n\t\tsort(po+1,po+cntpoi+1);\r\n\t\tfor(int i=1;i<=cntpoi;i++)\r\n\t\tif(po[i].t<2) add(po[i].y,po[i].t);\r\n\t\telse ret[que[po[i].t-1].id]+=sum(po[i].y);\r\n\t\tfor(int i=1;i<=cntpoi;i++)\r\n\t\tif(po[i].t<2) add(po[i].y,-po[i].t);\r\n\t}\r\n\tfor(int i=1;i<=Q;i++)\r\n\t\tprintf(\"%d\\n\",ret[i]);\r\n\treturn 0;\r\n} "
}