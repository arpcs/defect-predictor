{
    "id": 193940135,
    "contestId": 917,
    "creationTimeSeconds": 1676591098,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "Scintilla06"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 29,
    "timeConsumedMillis": 873,
    "memoryConsumedBytes": 260915200,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define mp make_pair\r\n#define pb emplace_back\r\n#define rep(i, s, e) for (int i = s; i <= e; ++i)\r\n#define drep(i, s, e) for (int i = s; i >= e; --i)\r\n#define file(a) freopen(#a\".in\", \"r\", stdin), freopen(#a\".out\", \"w\", stdout)\r\n#define pv(a) cout << #a << \" = \" << a << endl\r\n#define pa(a, l, r) cout << #a \" : \"; rep(_, l, r) cout << a[_] << ' '; cout << endl\r\n\r\nusing pii = pair <int, int>;\r\n\r\nconst int P = 998244353;\r\nconst int base = 131;\r\n\r\nconst int N = 4e5 + 10;\r\nconst int M = N * 20;\r\n\r\nint read() {\r\n  int x = 0, f = 1; char c = getchar();\r\n  for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -1;\r\n  for (; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - 48;\r\n  return x * f;\r\n}\r\n\r\nint inc(int a, int b) { return (a += b) >= P ? a - P : a; }\r\nint dec(int a, int b) { return (a -= b) < 0 ? a + P : a; }\r\nint mul(int a, int b) { return 1ll * a * b % P; }\r\nint qpow(int a, int b) { int res = 1; for(; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a); return res; }\r\n\r\nint n, m, qcnt, len, ans[N], pw[N];\r\nstruct Q {\r\n  int u, v, id;\r\n  Q(int _u = 0, int _v = 0, int _id = 0) {\r\n    u = _u, v = _v, id = _id;\r\n  }\r\n} ;\r\nvector <Q> qry[N];\r\nstring str[N];\r\nstruct info {\r\n  int l, r, d;\r\n  info(int _l = 0, int _r = 0, int _d = 0) {\r\n    l = _l, r = _r, d = _d;\r\n  }\r\n} ;\r\n\r\nstruct str {\r\n\r\n  int s[N], fail[N], val[N], pos;\r\n  \r\n  void kmp() {\r\n    for (int i = 2, j = 0; i <= len; ++ i) {\r\n      while (j && s[j + 1] != s[i]) j = fail[j];\r\n      fail[i] = j += s[j + 1] == s[i];\r\n    }\r\n  }\r\n\r\n  int sa[N], oldsa[N], rk[N], oldrk[N], cnt[N];\r\n\r\n  void build() {\r\n    rep(i, 1, 26) cnt[i] = 0;\r\n    rep(i, 1, len) ++ cnt[rk[i] = s[i] + 1];\r\n    rep(i, 1, 26) cnt[i] += cnt[i - 1];\r\n    drep(i, len, 1) sa[cnt[rk[i]] --] = i;\r\n    for (int w = 1, p, q; p = 0, q = 0, w < len; w <<= 1) {\r\n      rep(i, len - w + 1, len) oldsa[++ p] = i;\r\n      rep(i, 1, len) if (sa[i] > w) oldsa[++ p] = sa[i] - w;\r\n      rep(i, 1, max(len, 26)) cnt[i] = 0;\r\n      rep(i, 1, len) ++ cnt[rk[i]];\r\n      rep(i, 1, max(len, 26)) cnt[i] += cnt[i - 1];\r\n      drep(i, len, 1) sa[cnt[rk[oldsa[i]]] --] = oldsa[i];\r\n      rep(i, 1, len) oldrk[i] = rk[i];\r\n      rep(i, 1, len) {\r\n        if (oldrk[sa[i]] != oldrk[sa[i - 1]] || oldrk[sa[i] + w] != oldrk[sa[i - 1] + w]) ++ q;\r\n        rk[sa[i]] = q;\r\n      }\r\n      if (q == len) break;\r\n    }\r\n  }\r\n  \r\nvector <info> work(int p) {\r\n  // pv(p);\r\n  // pa(s, 1, n);\r\n  vector <info> res;\r\n  if (p < len) res.pb(info(p, p, 1));\r\n  for (; fail[p]; p = (p - 1) % (p - fail[p]) + 1) {\r\n    // pv(p - fail[p]);\r\n    res.pb(info((p - 1) % (p - fail[p]) + 1, fail[p], p - fail[p]));\r\n  }\r\n  return res;\r\n}\r\n\r\n  int calc(int l, int r) {\r\n    -- l;\r\n    return dec(val[r], mul(val[l], pw[r - l]));\r\n  }\r\n\r\n  int calcb(int p, int lim) {\r\n    // cout << \"p, lim = \" << p << ' ' << lim << endl;\r\n    // pa(s, 1, len);\r\n    if (p <= lim) return p;\r\n    for (int q, d; fail[p]; p = q) {\r\n      q = (p - 1) % (p - fail[p]) + 1, d = p - fail[p];\r\n      // cout << \"q, p, d = \" << q << ' ' << p << ' ' << d << endl;\r\n      if (q <= lim) return min(fail[p], q + (lim - q) / d * d);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  void init(string t) {\r\n    rep(i, 1, len) {\r\n      s[i] = t[i - 1] - 'a', fail[i] = oldrk[i] = oldrk[len + i] = 0;\r\n      val[i] = inc(mul(val[i - 1], base), s[i]);\r\n    }\r\n    s[len + 1] = -1, kmp(), build();\r\n    // pa(sa, 1, len);\r\n  }\r\n\r\n} fw, rv;\r\n\r\nnamespace smt {\r\n\r\n  #define ls lson[u]\r\n  #define rs rson[u]\r\n  #define mid (l + r >> 1)\r\n\r\n  int tot, rt[N], dat[M], lson[M], rson[M];\r\n\r\n  int clone(int u) {\r\n    ++ tot;\r\n    dat[tot] = dat[u], lson[tot] = ls, rson[tot] = rs;\r\n    return tot;\r\n  }\r\n\r\n  void maintain(int u) {\r\n    dat[u] = dat[ls] + dat[rs];\r\n  }\r\n\r\n  int modify(int p, int k, int u, int l, int r) {\r\n    u = clone(u);\r\n    // cout << \"p, k, u, l, r = \" << p << ' ' << k << ' ' << u << ' ' << l << ' ' << r << endl;\r\n    if (l == r) {\r\n      // cout << \"l, r, dat[u] = \" << l << ' ' << r << ' ' << dat[u] << endl;\r\n      return dat[u] += k, u;\r\n    }\r\n    if (p <= mid) ls = modify(p, k, ls, l, mid);\r\n    else rs = modify(p, k, rs, mid + 1, r);\r\n    return maintain(u), u;\r\n  }\r\n\r\n  int query(int ql, int qr, int u, int l, int r) {\r\n    if (!u) return 0;\r\n    if (ql <= l && r <= qr) return dat[u];\r\n    int res = 0;\r\n    if (ql <= mid) res += query(ql, qr, ls, l, mid);\r\n    if (qr > mid) res += query(ql, qr, rs, mid + 1, r);\r\n    return res;\r\n  }\r\n\r\n  #undef ls\r\n  #undef rs\r\n  #undef mid\r\n\r\n}\r\n\r\nusing smt :: rt;\r\nusing smt :: modify;\r\nusing smt :: query;\r\n\r\nnamespace acam {\r\n\r\n  vector <int> e[N];\r\n  int tot, fail[N], to[N][26], dfn[N], dn, sz[N];\r\n\r\n  int ins(int u, int c) {\r\n    if (!to[u][c]) to[u][c] = ++ tot;\r\n    return to[u][c];\r\n  }\r\n\r\n  void build() {\r\n    queue <int> q;\r\n    rep(i, 0, 25) if (to[0][i]) q.push(to[0][i]);\r\n    while (q.size()) {\r\n      int u = q.front(); q.pop();\r\n      rep(i, 0, 25) {\r\n        if (to[u][i]) fail[to[u][i]] = to[fail[u]][i], q.push(to[u][i]);\r\n        else to[u][i] = to[fail[u]][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  void dfs0(int u) {\r\n    // cout << \"u, fa = \" << u << ' ' << fa << endl;\r\n    dfn[u] = ++ dn, sz[u] = 1;\r\n    for (int v : e[u]) dfs0(v), sz[u] += sz[v];\r\n  }\r\n\r\n  int walk(int *s, int k) {\r\n    int u = 0;\r\n    rep(i, 1, k) u = to[u][s[i]];\r\n    return u;\r\n  }\r\n\r\n  void init() {\r\n    build();\r\n    rep(i, 1, tot) e[fail[i]].pb(i);\r\n    dfs0(0);\r\n  }\r\n\r\n  void print() {\r\n    cout << \"automaton : \\n\";\r\n    rep(u, 0, tot) rep(i, 0, 25) if (to[u][i]) {\r\n      cout << u << ' ' << to[u][i] << ' ' << (char) ('a' + i) << endl;\r\n    }\r\n    cout << \"fail : \\n\";\r\n    rep(u, 1, tot) cout << fail[u] << ' ' << u << endl;\r\n  }\r\n\r\n}\r\n\r\nusing acam :: ins;\r\nusing acam :: dfn;\r\nusing acam :: sz;\r\n\r\nnamespace tree {\r\n\r\n  vector <pii> e[N];\r\n  int dep[N], val[N], id[N], fp[N][20];\r\n  char ch[N];\r\n\r\n  void dfs0(int u, int fa) {\r\n    for (auto [v, w] : e[u]) if (v != fa) {\r\n      // cout << \"u, v, w = \" << u << ' ' << v << ' ' << w << endl;\r\n      fp[v][0] = u, dep[v] = dep[u] + 1;\r\n      id[v] = ins(id[u], w), ch[v] = w;\r\n      // pv(id[v]);\r\n      val[v] = inc(mul(val[u], base), w);\r\n      dfs0(v, u);\r\n    }\r\n  }\r\n\r\n  int LCA(int u, int v) {\r\n    if (dep[u] < dep[v]) swap(u, v);\r\n    drep(i, 19, 0) if (dep[u] - dep[v] >> i & 1) u = fp[u][i];\r\n    if (u == v) return u;\r\n    drep(i, 19, 0) if (fp[u][i] != fp[v][i]) u = fp[u][i], v = fp[v][i];\r\n    return fp[u][0];\r\n  }\r\n\r\n  int anc(int u, int k) {\r\n    drep(i, 19, 0) if (k >> i & 1) u = fp[u][i];\r\n    return u;\r\n  }\r\n\r\n  int calc(int u, int v) {\r\n    return dec(val[u], mul(val[v], pw[dep[u] - dep[v]]));\r\n  }\r\n\r\n  void dfs1(int u, int fa) {\r\n    // cout << \"u, id[u], dfn[id[u]] = \" << u << ' ' << id[u] << ' ' << dfn[id[u]] << endl;\r\n    rt[u] = modify(dfn[id[u]], 1, rt[fa], 1, acam :: tot + 1);\r\n    for (auto [v, w] : e[u]) if (v != fa) dfs1(v, u);\r\n  }\r\n\r\n  void init() {\r\n    ch[1] = -1;\r\n    dfs0(1, 0);\r\n    // pa(id, 1, n);\r\n    rep(i, 1, 19) rep(u, 1, n) fp[u][i] = fp[fp[u][i - 1]][i - 1];\r\n  }\r\n\r\n}\r\n\r\nusing tree :: dep;\r\nusing tree :: fp;\r\nusing tree :: id;\r\nusing tree :: ch;\r\nusing tree :: LCA;\r\nusing tree :: anc;\r\n\r\nint fwp, rvp;\r\nint solve(int u, int v) {\r\n  // cout << \"-------- solve u, v = \" << u << ' ' << v << endl;\r\n  // cout << \"fwp, rvp = \" << fwp << ' ' << rvp << endl;\r\n  int res = 0, lca = LCA(u, v);\r\n  // cout << \"u, v, lca = \" << u << ' ' << v << ' ' << lca << endl;\r\n  auto chain = [&](int x, int y, int z) {\r\n    // cout << \"---- x, y, z = \" << x << ' ' << y << ' ' << z << endl;\r\n    int o = 0;\r\n    o += query(dfn[x], dfn[x] + sz[x] - 1, rt[y], 1, acam :: tot + 1);\r\n    z = fp[z][0];\r\n    o -= query(dfn[x], dfn[x] + sz[x] - 1, rt[z], 1, acam :: tot + 1);\r\n    return o;\r\n  } ;\r\n  if (dep[u] - dep[lca] >= len) {\r\n    res += chain(rvp, u, anc(u, dep[u] - dep[lca] - len));\r\n  }\r\n  if (dep[v] - dep[lca] >= len) {\r\n    res += chain(fwp, v, anc(v, dep[v] - dep[lca] - len));\r\n  }\r\n  // pv(res);\r\n  int l = 1, r = len + 1, limu = 0, limv = 0;\r\n  while (l < r) {\r\n    int mid = (l + r) >> 1;\r\n    auto lcp = [&](int k) {\r\n      // cout << \"u lcp k = \" << k << endl;\r\n      int x = u, y = rv.sa[k], p = dep[x] - dep[lca];\r\n      // pv(p);\r\n      // pv(dep[x] - dep[lca]);\r\n      if (p + y - 1 <= len && tree :: calc(x, lca) == rv.calc(y, y + p - 1)) return p;\r\n      drep(i, 19, 0) if (p >> i) {\r\n        int rpos = (y + p - 1 - (1 << i));\r\n        if (rpos > len || tree :: calc(fp[x][i], lca) != rv.calc(y, rpos)) {\r\n          x = fp[x][i], p -= (1 << i);\r\n        }\r\n      }\r\n      // pv(p);\r\n      return p - 1;\r\n    } ;\r\n    auto chk = [&](int k) {\r\n      int p = lcp(k);\r\n      // cout << \"k, p = \" << k << ' ' << p << endl;\r\n      // pv(dep[u] - dep[lca]);\r\n      if (p == dep[u] - dep[lca]) return rv.sa[k] + p <= len;\r\n      return ch[anc(u, dep[u] - dep[lca] - p - 1)] < rv.s[rv.sa[k] + p];\r\n    } ;\r\n    if (chk(mid)) r = mid;\r\n    else l = mid + 1;\r\n    if (l == r) {\r\n      // pv(l);\r\n      // pv(rv.sa[l - 1]);\r\n      limu = l == 1 ? 0 : fw.calcb(len - rv.sa[l - 1] + 1, lcp(l - 1));\r\n    }\r\n  }\r\n  l = 1, r = len + 1;\r\n  while (l < r) {\r\n    int mid = (l + r) >> 1;\r\n    auto lcp = [&](int k) {\r\n      // cout << \"v lcp k = \" << k << endl;\r\n      // pv(fw.sa[k]);\r\n      int x = v, y = fw.sa[k], p = dep[x] - dep[lca];\r\n      if (p + y - 1 <= len && tree :: calc(x, lca) == fw.calc(y, y + p - 1)) return p;\r\n      drep(i, 19, 0) if (p >> i) {\r\n        int rpos = (y + p - 1 - (1 << i));\r\n        // cout << \"i, rpos = \" << i << ' ' << rpos << endl;\r\n        if (rpos > len || tree :: calc(fp[x][i], lca) != fw.calc(y, rpos)) {\r\n          x = fp[x][i], p -= (1 << i);\r\n        }\r\n      }\r\n      // pv(p);\r\n      return p - 1;\r\n    } ;\r\n    auto chk = [&](int k) {\r\n      int p = lcp(k);\r\n      if (p == dep[v] - dep[lca]) return fw.sa[k] + p <= len;\r\n      return ch[anc(v, dep[v] - dep[lca] - p - 1)] <= fw.s[fw.sa[k] + p];\r\n    } ;\r\n    if (chk(mid)) r = mid;\r\n    else l = mid + 1;\r\n    if (l == r) {\r\n      // pv(l);\r\n      // pv(fw.sa[l - 1]);\r\n      // pv(fw.sa[l]);\r\n      limv = l == 1 ? 0 : rv.calcb(len - fw.sa[l - 1] + 1, lcp(l - 1));\r\n    }\r\n  }\r\n  // cout << \"limu, limv = \"  << limu << ' ' << limv << endl;\r\n  auto su = fw.work(limu), sv = rv.work(limv);\r\n  for (auto p : su) for (auto q : sv) {\r\n    // cout << \"p : \" << p.l << ' ' << p.r << ' ' << p.d << endl;\r\n    // cout << \"q : \" << q.l << ' ' << q.r << ' ' << q.d << endl;\r\n    if (p.l + q.l > len || p.r + q.r < len) continue;\r\n    function <void(int, int, int, int&, int&)> exgcd = [&](int a, int b, int c, int &x, int &y) {\r\n      if (!b) return x = c / a, y = 0, void();\r\n      exgcd(b, a % b, c, y, x), y -= a / b * x;\r\n    } ;\r\n    int g = __gcd(p.d, q.d), x, y, c = len - p.l - q.l;\r\n    if (c % g) continue;\r\n    exgcd(p.d, q.d, c, x, y);\r\n    // cout << \"x, y = \" << x << ' ' << y << endl;\r\n    x -= q.d * (x / q.d), y += p.d * (x / q.d);\r\n    // cout << \"x, y = \" << x << ' ' << y << endl;\r\n    if (x < 0) x += q.d, y -= p.d;\r\n    if (x > p.r - p.l || y < 0) continue;\r\n    int L = max(0, (y - q.r + q.l + p.d - 1) / p.d), R = min(y / p.d, (p.r - p.l - x) / p.d);\r\n    // cout << \"L, R = \" << L << ' ' << R << endl;\r\n    res += max(0, R - L + 1);\r\n  }\r\n  return res;\r\n}\r\n\r\nint main() {\r\n  ios :: sync_with_stdio(false);\r\n  cin.tie(0), cout.tie(0);\r\n  pw[0] = 1;\r\n  rep(i, 1, N - 5) pw[i] = mul(pw[i - 1], base);\r\n  cin >> n >> m >> qcnt;\r\n  rep(i, 1, n - 1) {\r\n    int u, v; char c;\r\n    cin >> u >> v >> c;\r\n    tree :: e[u].pb(mp(v, c - 'a'));\r\n    tree :: e[v].pb(mp(u, c - 'a'));\r\n  }\r\n  for (int i = 1, u; i <= m; ++ i) {\r\n    cin >> str[i], u = 0;\r\n    for (auto c : str[i]) u = ins(u, c - 'a');\r\n    reverse(str[i].begin(), str[i].end()), u = 0;\r\n    for (auto c : str[i]) u = ins(u, c - 'a');\r\n  }\r\n  tree :: init();\r\n  acam :: init();\r\n  // acam :: print();\r\n  tree :: dfs1(1, 0);\r\n  rep(i, 1, qcnt) {\r\n    int u, v, k;\r\n    cin >> u >> v >> k;\r\n    // if (i == 5919) {\r\n    //   cout << \"u, v, k = \" << u << ' ' << v << ' ' << k << endl;\r\n    //   cout << str[k] << endl;\r\n    // }\r\n    qry[k].pb(Q(u, v, i));\r\n  }\r\n  rep(i, 1, m) {\r\n    // cout << \"------------ i = \" << i << endl;\r\n    len = str[i].size();\r\n    rv.init(str[i]);\r\n    reverse(str[i].begin(), str[i].end());\r\n    fw.init(str[i]);\r\n    // pv(len);\r\n    fwp = acam :: walk(fw.s, len);\r\n    rvp = acam :: walk(rv.s, len);\r\n    // cout << \"fwp, rvp = \" << fwp << ' ' << rvp << endl;\r\n    for (auto it : qry[i]) {\r\n      ans[it.id] = solve(it.u, it.v);\r\n    }\r\n  }\r\n  rep(i, 1, qcnt) cout << ans[i] << endl;\r\n  return 0;\r\n}"
}