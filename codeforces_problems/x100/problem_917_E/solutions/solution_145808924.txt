{
    "id": 145808924,
    "contestId": 917,
    "creationTimeSeconds": 1644466230,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "tutuneed"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 33,
    "timeConsumedMillis": 826,
    "memoryConsumedBytes": 94822400,
    "source": "#include<bits/stdc++.h>\r\n#define For(i,x,y) for (int i=(x);i<=(y);i++)\r\n#define FOR(i,x,y) for (int i=(x);i<(y);i++)\r\n#define Dow(i,x,y) for (int i=(x);i>=(y);i--)\r\n#define mp make_pair\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n#define ep emplace_back\r\n#define siz(x) ((int)(x).size())\r\n#define all(x) (x).begin(),(x).end()\r\n#define fil(a,b) memset((a),(b),sizeof(a))\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int,int> pa;\r\ntypedef pair<ll,ll> PA;\r\ntypedef vector<int> poly;\r\ninline ll read(){\r\n\tll x=0,f=1;char c=getchar();\r\n\twhile ((c<'0'||c>'9')&&(c!='-')) c=getchar();\r\n\tif (c=='-') f=-1,c=getchar();\r\n\twhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\r\n\treturn x*f;\r\n}\r\n\r\nconst int N = 1e5+10;\r\nconst int base = 233, mod = 998244853;\r\nint n,m,q,B,Ans[N],pos[N][2],posb[N];\r\nvector<pair<int,char>>e[N];\r\nstring s[N];\r\npoly big,fail[N][2],h[N][2];\r\n\r\nstruct AcAutoMaton{\r\n\tpoly e[N];\r\n\tint Tim,l[N],r[N];\r\n\tinline void dfs(int u){\r\n\t\tl[u]=++Tim;\r\n\t\tfor (auto v:e[u]) dfs(v);\r\n\t\tr[u]=Tim;\r\n\t}\r\n\r\n\tint cnt,son[N][26],dep[N];\r\n\tinline int insert(string s){\r\n\t\tint u=0;\r\n\t\tFOR(i,0,siz(s)){\r\n\t\t\tchar c=s[i];\r\n\t\t\tif (son[u][c-'a']) u=son[u][c-'a'];\r\n\t\t\t\telse u=son[u][c-'a']=++cnt;\r\n\t\t\tdep[u]=i+1;\r\n\t\t}\r\n\t\treturn u;\r\n\t}\r\n\tint fail[N];\r\n\tinline void Build(){\r\n\t\tqueue<int>q;\r\n\t\tFor(i,0,25) if (son[0][i]) q.push(son[0][i]);\r\n\t\twhile (!q.empty()){\r\n\t\t\tint u=q.front();q.pop(),e[fail[u]].pb(u);\r\n\t\t\tFor(i,0,25) if (son[u][i]){\r\n\t\t\t\tint v=son[u][i],p=fail[u];\r\n\t\t\t\tfail[v]=son[p][i],q.push(v);\r\n\t\t\t} else son[u][i]=son[fail[u]][i];\r\n\t\t}\r\n\t\tdfs(0);\r\n\t}\r\n}AC[2];\r\n\r\nstruct BIT{\r\n\tint n,c[N];\r\n\tinline void init(int _n){\r\n\t\tn=_n;\r\n\t\tFor(i,1,n) c[i]=0;\r\n\t}\r\n\tinline void Add(int x,int y){\r\n\t\tfor (;x<=n;x+=x&-x) c[x]+=y;\r\n\t}\r\n\tinline void Add(int l,int r,int x){\r\n\t\tAdd(l,x),Add(r+1,-x);\r\n\t}\r\n\tinline int Query(int x){\r\n\t\tint ret=0;\r\n\t\tfor (;x;x-=x&-x) ret+=c[x];\r\n\t\treturn ret;\r\n\t}\r\n\tinline int Query(int l,int r){\r\n\t\treturn Query(r)-(l==0?0:Query(l-1));\r\n\t}\r\n}t[2];\r\n\r\nint rt,Siz,siz[N],mx[N];\r\nbool vis[N];\r\ninline void FindRoot(int u,int fa){\r\n\tsiz[u]=1,mx[u]=0;\r\n\tfor (auto [v,w]:e[u]) if (v!=fa&&!vis[v]){\r\n\t\tFindRoot(v,u),siz[u]+=siz[v];\r\n\t\tmx[u]=max(mx[u],siz[v]);\r\n\t}\r\n\tmx[u]=max(mx[u],Siz-siz[u]);\r\n\tif (!rt||mx[u]<mx[rt]) rt=u;\r\n}\r\nint bel[N];\r\ninline void dfs1(int u,int fa,int bl){\r\n\tbel[u]=bl,siz[u]=1;\r\n\tfor (auto [v,w]:e[u]) if (v!=fa&&!vis[v]){\r\n\t\tdfs1(v,u,bl),siz[u]+=siz[v];\r\n\t}\r\n}\r\nint top,now[N][2],ret[N][2],ans[N][2],stkh[N],pw[N];\r\nchar stk[N];\r\nvector<pa>Q2[N][2];\r\ninline void dfs2(int u,int fa,int p0,int p1){\r\n\tt[0].Add(AC[0].l[p0],1),t[1].Add(AC[1].l[p1],1);\r\n\tvector<pa>las(siz(big));\r\n\tFOR(i,0,siz(big)){\r\n\t\tlas[i]=mp(now[i][0],now[i][1]);\r\n\t\tif (h[big[i]][0][top]==stkh[top]) now[i][0]=top;\r\n\t\tif (h[big[i]][1][top]==stkh[top]) now[i][1]=top;\r\n\t}\r\n\tif (fa){\r\n\t\tFor(i,0,1){\r\n\t\t\tfor (auto [x,y]:Q2[u][i]){\r\n\t\t\t\tif (siz(s[x])<=B){\r\n\t\t\t\t\tDow(j,min(siz(s[x])-1,top),1) if (h[x][i][j]==stkh[j]){\r\n\t\t\t\t\t\tret[y][i]=j;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tret[y][i]=now[posb[x]][i];\r\n\t\t\t\t}\r\n\t\t\t\tans[y][i]=t[i].Query(AC[i].l[pos[x][i]],AC[i].r[pos[x][i]]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (auto [v,w]:e[u]) if (v!=fa&&!vis[v]){\r\n\t\tstk[++top]=w;\r\n\t\tstkh[top]=(stkh[top-1]+1ll*(w-'a'+1)*pw[top-1])%mod;\r\n\t\tdfs2(v,u,AC[0].son[p0][w-'a'],AC[1].son[p1][w-'a']);\r\n\t\t--top;\r\n\t}\r\n\tt[0].Add(AC[0].l[p0],-1),t[1].Add(AC[1].l[p1],-1);\r\n\tFOR(i,0,siz(big)) now[i][0]=las[i].fi,now[i][1]=las[i].se;\r\n}\r\ninline void Clear(int u,int fa){\r\n\tFor(i,0,1) Q2[u][i].clear();\r\n\tfor (auto [v,w]:e[u]) if (v!=fa&&!vis[v]) Clear(v,u);\r\n}\r\nvector<pair<pa,pa>>tmp[N],Q[N];\r\nvector<pair<pa,int>>Q3[N];\r\nbool flag[N];\r\ninline void solve(int u){\r\n//\tprintf(\"solve %d:\\n\",u);\r\n//\tfor (auto i:Q[u]) printf(\" %d %d\\n\",i.fi.fi,i.fi.se);\r\n\tvis[u]=1,bel[u]=u;\r\n\tfor (auto [v,w]:e[u]) if (!vis[v]) dfs1(v,u,v);\r\n\tvector<pa> get;\r\n\tfor (auto [x,y]:Q[u]){\r\n\t\tif (bel[x.fi]==bel[x.se]) tmp[bel[x.fi]].pb(mp(x,y));\r\n\t\telse {\r\n\t\t\tans[y.se][0]=ans[y.se][1]=-1;\r\n\t\t\tQ2[x.fi][0].pb(y),Q2[x.se][1].pb(y);\r\n\t\t\tget.pb(y);\r\n\t\t}\r\n\t}\r\n\tdfs2(u,0,0,0);\r\n\tfor (auto [k,i]:get){\r\n\t\tif (~ans[i][0]&&~ans[i][1]){\r\n\t\t\tif (siz(s[k])<=B){\r\n\t\t\t\tfor (int u=ret[i][0];u;u=fail[k][0][u]) flag[u]=1;\r\n\t\t\t\tfor (int u=ret[i][1];u;u=fail[k][1][u]) Ans[i]+=flag[siz(s[k])-u];\r\n\t\t\t\tfor (int u=ret[i][0];u;u=fail[k][0][u]) flag[u]=0;\r\n\t\t\t} else {\r\n\t\t\t\tQ3[k].ep(mp(ret[i][0],ret[i][1]),i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tAns[i]+=max(0,ans[i][0])+max(0,ans[i][1]);\r\n\t}\r\n\tClear(u,0);\r\n\tfor (auto [v,w]:e[u]) if (!vis[v]){\r\n\t\tSiz=siz[v],rt=0,FindRoot(v,u);\r\n\t\tQ[rt]=tmp[v],tmp[v].clear(),solve(rt);\r\n\t}\r\n}\r\n\r\nint pre[N],cntQ4;\r\nstruct node{\r\n\tint op,x,y,z,w;\r\n}Q4[3*N];\r\nstruct FailTree{\r\n\tpoly e[N];\r\n\tint Tim;\r\n\tinline void init(int n){\r\n\t\tTim=0;\r\n\t\tFor(i,0,n) e[i].clear();\r\n\t}\r\n\tinline void Add(int x,int y){\r\n\t\te[x].pb(y);\r\n\t}\r\n\tint l[N],r[N];\r\n\tinline void dfs(int u){\r\n\t\tif (u) l[u]=++Tim;\r\n\t\tfor (auto v:e[u]) dfs(v);\r\n\t\tr[u]=Tim;\r\n\t}\r\n}T[2];\r\ninline void solve2(){\r\n\tfor (auto i:big){\r\n\t\tFor(j,0,1){\r\n\t\t\tT[j].init(siz(s[i]));\r\n\t\t\tFor(k,1,siz(s[i])) T[j].Add(fail[i][j][k],k);\r\n\t\t\tT[j].dfs(0);\r\n\t\t}\r\n\t\tcntQ4=0;\r\n\t\tFOR(j,1,siz(s[i])){\r\n\t\t\tint l1=T[0].l[j],r1=T[0].r[j];\r\n\t\t\tint l2=T[1].l[siz(s[i])-j],r2=T[1].r[siz(s[i])-j];\r\n\t\t\tQ4[++cntQ4]=(node){0,l1,l2,r2,1};\r\n\t\t\tQ4[++cntQ4]=(node){0,r1+1,l2,r2,-1};\r\n\t\t}\r\n\t\tfor (auto j:Q3[i]) Q4[++cntQ4]=(node){1,T[0].l[j.fi.fi],T[1].l[j.fi.se],j.se,0};\r\n\t\tsort(Q4+1,Q4+1+cntQ4,[](node a,node b){\r\n\t\t\treturn a.x<b.x||(a.x==b.x&&a.op<b.op);\r\n\t\t});\r\n\t\tt[0].init(siz(s[i]));\r\n\t\tFor(i,1,cntQ4){\r\n\t\t\tif (Q4[i].op==0) t[0].Add(Q4[i].y,Q4[i].z,Q4[i].w);\r\n\t\t\t\telse Ans[Q4[i].z]+=t[0].Query(Q4[i].y);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tn=read(),m=read(),q=read(),B=700;\r\n\tFOR(i,1,n){\r\n\t\tint x=read(),y=read();\r\n\t\tchar c=getchar();\r\n\t\te[x].ep(y,c),e[y].ep(x,c);\r\n\t}\r\n\tFor(i,1,m){\r\n\t\tcin>>s[i];\r\n\t\tDow(j,1,0){\r\n\t\t\tpos[i][j]=AC[j].insert(s[i]);\r\n\t\t\tfail[i][j].resize(siz(s[i])+1);\r\n\t\t\tint now=0;\r\n\t\t\tFor(k,2,siz(s[i])){\r\n\t\t\t\twhile (now&&s[i][k-1]!=s[i][now]) now=fail[i][j][now];\r\n\t\t\t\tif (s[i][k-1]==s[i][now]) ++now;\r\n\t\t\t\tfail[i][j][k]=now;\r\n\t\t\t}\r\n\t\t\th[i][j].resize(siz(s[i])+1);\r\n\t\t\tFor(k,1,siz(s[i])) h[i][j][k]=(1ll*h[i][j][k-1]*base+s[i][siz(s[i])-k]-'a'+1)%mod;\r\n\t\t\treverse(all(s[i]));\r\n\t\t}\r\n\t\tswap(fail[i][0],fail[i][1]);\r\n\t\tif (siz(s[i])>B) big.pb(i),posb[i]=siz(big)-1;\r\n\t}\r\n\tpw[0]=1;\r\n\tFor(i,1,n) pw[i]=1ll*pw[i-1]*base%mod;\r\n\tAC[0].Build(),AC[1].Build();\r\n\trt=0,Siz=n,FindRoot(1,0);\r\n\tFor(i,1,q){\r\n\t\tint x=read(),y=read(),z=read();\r\n\t\tQ[rt].ep(mp(x,y),mp(z,i));\r\n\t}\r\n\tt[0].init(AC[0].Tim),t[1].init(AC[1].Tim);\r\n\tsolve(rt);\r\n\tsolve2();\r\n\tFor(i,1,q) printf(\"%d\\n\",Ans[i]);\r\n}"
}