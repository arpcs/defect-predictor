{
    "id": 194436215,
    "contestId": 917,
    "creationTimeSeconds": 1676971753,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "schrodingerstom"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 1559,
    "memoryConsumedBytes": 97792000,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\nbool memBeg;\r\nconst int maxlet=28;\r\nconst int maxsz=1e5+5;\r\nconst int maxlg=25;//17\r\nint n,m,q,head[maxsz],to[maxsz<<1],nxt[maxsz<<1],tot;\r\nchar c[maxsz<<1],up[maxsz];\r\nvoid add_edge(int u,int v,char w) {\r\n    to[tot]=v; c[tot]=w; nxt[tot]=head[u]; head[u]=tot++;\r\n    to[tot]=u; c[tot]=w; nxt[tot]=head[v]; head[v]=tot++;\r\n}\r\nstring tpl[maxsz];\r\nint s[maxsz],t[maxsz],sr[maxsz],lca[maxsz];\r\nint fa[maxlg][maxsz],dep[maxsz],ret[maxsz];\r\nstruct hash_t {\r\n    static const int hash_num=2;\r\n    static const int base[hash_num];\r\n    static const int mod[hash_num];\r\n    int hsh[hash_num];\r\n    hash_t operator+(const hash_t &o) const {\r\n        hash_t ret;\r\n        for(int i=0;i<hash_num;i++) {\r\n            ret.hsh[i]=hsh[i]+o.hsh[i];\r\n            ret.hsh[i]-=(ret.hsh[i]>=mod[i])*mod[i];\r\n        }\r\n        return ret;\r\n    }\r\n    hash_t operator-(const hash_t &o) const {\r\n        hash_t ret;\r\n        for(int i=0;i<hash_num;i++) {\r\n            ret.hsh[i]=hsh[i]-o.hsh[i];\r\n            ret.hsh[i]+=(ret.hsh[i]<0)*mod[i];\r\n        }\r\n        return ret;\r\n    }\r\n    hash_t operator*(const hash_t &o) const {\r\n        hash_t ret;\r\n        for(int i=0;i<hash_num;i++)\r\n            ret.hsh[i]=1ll*hsh[i]*o.hsh[i]%mod[i];\r\n        return ret;\r\n    }\r\n    bool operator!=(const hash_t &o) const {\r\n        for(int i=0;i<hash_num;i++)\r\n            if(hsh[i]^o.hsh[i]) return true;\r\n        return false;\r\n    }\r\n}pw[maxsz],dn[maxsz];\r\nconst int hash_t::base[hash_t::hash_num]={800006833,800063291};\r\nconst int hash_t::mod[hash_t::hash_num]={1000061453,1000163837};\r\nvoid dfs0(int root) {\r\n    for(int i=head[root];~i;i=nxt[i]) {\r\n        if(to[i]==fa[0][root]) continue;\r\n        dep[to[i]]=dep[root]+1;\r\n        fa[0][to[i]]=root;\r\n        dn[to[i]]=dn[root]*pw[1]+(hash_t){c[i],c[i]};\r\n        up[to[i]]=c[i]; dfs0(to[i]);\r\n    }\r\n}\r\nint LCA(int u,int v) {\r\n    if(dep[u]>dep[v]) swap(u,v);\r\n    int delta=dep[v]-dep[u];\r\n    for(int lg=0;(1<<lg)<=delta;lg++)\r\n        if(delta&(1<<lg)) v=fa[lg][v];\r\n    if(u==v) return u;\r\n    for(int lg=17;lg>=0;lg--)\r\n        if(fa[lg][u]!=fa[lg][v]) {\r\n            u=fa[lg][u]; v=fa[lg][v];\r\n        }\r\n    return fa[0][u];\r\n}\r\nint jump(int st,int step) {\r\n    for(int lg=0;(1<<lg)<=step;lg++)\r\n        if(step&(1<<lg)) st=fa[lg][st];\r\n    return st;\r\n}\r\nvector<int> qry[maxsz];\r\nint P[maxsz],Q[maxsz];\r\nstruct aho_corasick_automaton {\r\n    int fail[maxsz],ch[maxsz][maxlet],nodes,tim,ed[maxsz];\r\n    int dfn[maxsz],en[maxsz],que[maxsz],sum[maxsz];\r\n    vector<int> son[maxsz],hng[maxsz];\r\n    void dfs1(int root) {\r\n        dfn[root]=++tim;\r\n        for(int i=0;i<(int)son[root].size();i++)\r\n            dfs1(son[root][i]);\r\n        en[root]=tim;\r\n    }\r\n    void add(int pos,int vl) {\r\n        for(;pos<=tim;pos+=pos&(-pos)) sum[pos]+=vl;\r\n    }\r\n    int query(int pos) {\r\n        int res=0;\r\n        for(;pos;pos-=pos&(-pos)) res+=sum[pos];\r\n        return res;\r\n    }\r\n    void dfs2(int root,int _st) {\r\n        add(dfn[_st],1);\r\n        for(int i=0;i<(int)hng[root].size();i++) {\r\n            int id=abs(hng[root][i]),sgn=hng[root][i]/id;\r\n            ret[id]+=sgn*(query(en[ed[sr[id]]])-query(dfn[ed[sr[id]]]-1));\r\n        }\r\n        for(int i=head[root];~i;i=nxt[i])\r\n            if(to[i]!=fa[0][root])\r\n                dfs2(to[i],ch[_st][c[i]-'a']);\r\n        add(dfn[_st],-1);\r\n    }\r\n    void build() {\r\n        memset(ch,-1,sizeof(ch));\r\n        fail[0]=-1;\r\n        for(int i=1;i<=m;i++) {\r\n            int cur=0;\r\n            for(int j=0;j<(int)tpl[i].length();j++) {\r\n                if(ch[cur][tpl[i][j]-'a']==-1)\r\n                    ch[cur][tpl[i][j]-'a']=++nodes;\r\n                cur=ch[cur][tpl[i][j]-'a'];\r\n            }\r\n            ed[i]=cur;\r\n        }\r\n        int tead=0,rail=0; que[rail++]=0;\r\n        while(tead<rail) {\r\n            int cur=que[tead++];\r\n            for(int i=0;i<26;i++) {\r\n                int mv=fail[cur]==-1?0:ch[fail[cur]][i];\r\n                if(ch[cur][i]==-1) ch[cur][i]=mv;\r\n                else {\r\n                    fail[ch[cur][i]]=mv;\r\n                    que[rail++]=ch[cur][i];\r\n                }\r\n            }\r\n        }\r\n        for(int i=1;i<=nodes;i++) son[fail[i]].push_back(i);\r\n        dfs1(0);\r\n    }\r\n}gon,rev;\r\nnamespace solver {\r\nint shd,n,LG;\r\nstring str;\r\nstruct suffix_array {\r\n    int sa[maxsz],rnk[maxsz],x[maxsz],y[maxsz],tmp[maxsz],sum[maxsz];\r\n    hash_t vl[maxsz];\r\n    void build() {\r\n        for(int i=1;i<=n;i++) rnk[i]=str[i]-'a'+1;\r\n        for(int lg=0;;lg++) {\r\n            for(int i=1;i<=n;i++) {\r\n                x[i]=rnk[i];\r\n                y[i]=(i+(1<<lg))<=n?rnk[i+(1<<lg)]:0;\r\n            }\r\n            for(int i=0;i<=max(26,n);i++) sum[i]=0;\r\n            for(int i=1;i<=n;i++) sum[y[i]]++;\r\n            for(int i=1;i<=max(26,n);i++) sum[i]+=sum[i-1];\r\n            for(int i=1;i<=n;i++) tmp[sum[y[i]]--]=i;\r\n            for(int i=0;i<=max(26,n);i++) sum[i]=0;\r\n            for(int i=1;i<=n;i++) sum[x[i]]++;\r\n            for(int i=1;i<=max(26,n);i++) sum[i]+=sum[i-1];\r\n            for(int i=n;i>=1;i--) sa[sum[x[tmp[i]]]--]=tmp[i];\r\n            for(int i=1;i<=n;i++)\r\n                rnk[sa[i]]=rnk[sa[i-1]]+(x[sa[i]]!=x[sa[i-1]]||y[sa[i]]!=y[sa[i-1]]);\r\n            if(rnk[sa[n]]==n) break;\r\n        }\r\n        vl[0]=(hash_t){1,1};\r\n        for(int i=1;i<=n;i++)\r\n            vl[i]=vl[i-1]*pw[1]+(hash_t){str[i],str[i]};\r\n        vl[n+1]=vl[n]*pw[1];\r\n    }\r\n}pre,suf;\r\nstruct knuth_morris_pratt_automaton {\r\n    vector<int> son[maxsz];\r\n    int jp[maxlg][maxsz],nxt[maxsz];\r\n    void build() {\r\n        for(int i=0;i<=n;i++) son[i].clear();\r\n        son[0].push_back(1); jp[0][1]=0;\r\n        for(int i=2;i<=n;i++) {\r\n            int check=nxt[i-1];\r\n            while(check&&str[check+1]!=str[i])\r\n                check=nxt[check];\r\n            if(str[check+1]==str[i])\r\n                nxt[i]=check+1;\r\n            else nxt[i]=0;\r\n            son[nxt[i]].push_back(i);\r\n            jp[0][i]=nxt[i];\r\n        }\r\n        LG=0;\r\n        for(int lg=1;(1<<lg)<=n;LG=lg,lg++)\r\n            for(int i=1;i<=n;i++)\r\n                jp[lg][i]=jp[lg-1][jp[lg-1][i]];\r\n    }\r\n}aln,ant;\r\nint get_lcp(int s,int t,int beg,const suffix_array &sa) {\r\n    beg=sa.sa[beg]; int cur=t;\r\n    if(dep[cur]-dep[s]>n-beg+1) {\r\n        for(int lg=17;lg>=0;lg--)\r\n            if(dep[fa[lg][cur]]-dep[s]>n-beg+1)\r\n                cur=fa[lg][cur];\r\n    }\r\n    for(int lg=17;lg>=0;lg--) {\r\n        if(dep[cur]-(1<<lg)<dep[s]) continue;\r\n        int len=dep[fa[lg][cur]]-dep[s];\r\n        if(sa.vl[beg+len-1]-sa.vl[beg-1]*pw[len]!=\r\n           dn[fa[lg][cur]]-dn[s]*pw[len])\r\n            cur=fa[lg][cur];\r\n    }\r\n    int len=dep[cur]-dep[s];\r\n    if(sa.vl[beg+len-1]-sa.vl[beg-1]*pw[len]\r\n       !=dn[cur]-dn[s]*pw[len]) return dep[fa[0][cur]]-dep[s];\r\n    return dep[cur]-dep[s];\r\n}\r\nint get_border(int s,int t,const suffix_array &sa,\r\n               const knuth_morris_pratt_automaton &kmp) {\r\n    int lo=0,hi=n;\r\n    while(lo<hi) {\r\n        int mid=(lo+hi+1)>>1,pos=sa.sa[mid];\r\n        int lcp=get_lcp(s,t,mid,sa);\r\n        bool check=((pos+lcp<=n)?str[pos+lcp]:0)<\r\n                    (lcp<dep[t]-dep[s]?up[jump(t,dep[t]-dep[s]-lcp-1)]:0);\r\n        if(check) lo=mid;\r\n        else hi=mid-1;\r\n    }\r\n    int lcp=-1,best=-1;\r\n    if(lo) {\r\n        int upd=get_lcp(s,t,lo,sa);\r\n        if(upd>lcp) {\r\n            lcp=upd; best=n-sa.sa[lo]+1;\r\n        }\r\n    }\r\n    if(lo<n) {\r\n        int upd=get_lcp(s,t,lo+1,sa);\r\n        if(upd>lcp) {\r\n            lcp=upd; best=n-sa.sa[lo+1]+1;\r\n        }\r\n    }\r\n    lcp=min(lcp,n-1);\r\n    if(best<=lcp) return best;\r\n    for(int lg=LG;lg>=0;lg--)\r\n        if(kmp.jp[lg][best]>lcp)\r\n            best=kmp.jp[lg][best];\r\n    return kmp.jp[0][best];\r\n}\r\nint dfn[maxsz],en[maxsz],tim,sum[maxsz];\r\nvoid dfs1(int root) {\r\n    dfn[root]=++tim;\r\n    for(int i=0;i<(int)ant.son[root].size();i++)\r\n        dfs1(ant.son[root][i]);\r\n    en[root]=tim;\r\n}\r\nvoid add(int pos,int vl) {\r\n    for(;pos<=tim;pos+=pos&(-pos)) sum[pos]+=vl;\r\n}\r\nint query(int pos) {\r\n    int res=0;\r\n    for(;pos;pos-=pos&(-pos)) res+=sum[pos];\r\n    return res;\r\n}\r\nvector<int> hng[maxsz];\r\nvoid dfs2(int root) {\r\n    if(root&&root<n) {add(dfn[n-root],1); add(en[n-root]+1,-1);}\r\n    for(int i=0;i<(int)hng[root].size();i++)\r\n        ret[hng[root][i]]+=query(dfn[Q[hng[root][i]]]);\r\n    for(int i=0;i<(int)aln.son[root].size();i++)\r\n        dfs2(aln.son[root][i]);\r\n    if(root&&root<n) {add(dfn[n-root],-1); add(en[n-root]+1,1);}\r\n}\r\nvoid work(int _shd) {\r\n    shd=_shd;\r\n    n=(int)tpl[shd].length();\r\n    str=\"_\"+tpl[shd]; pre.build(); aln.build();\r\n    str=tpl[shd]; reverse(str.begin(),str.end());\r\n    str=\"_\"+str; suf.build(); ant.build();\r\n    for(int i=0;i<=n;i++) hng[i].clear();\r\n    for(int i=0;i<(int)qry[shd].size();i++) {\r\n        int id=qry[shd][i],u=s[id],v=t[id],w=lca[id];\r\n        if(u==w||v==w) continue;\r\n        P[id]=get_border(w,u,suf,aln);\r\n        hng[P[id]].push_back(id);\r\n    }\r\n    str=\"_\"+tpl[shd];\r\n    for(int i=0;i<(int)qry[shd].size();i++) {\r\n        int id=qry[shd][i],u=s[id],v=t[id],w=lca[id];\r\n        if(dep[u]-dep[w]>=n) {\r\n            int o=jump(u,dep[u]-dep[w]-n+1);\r\n            rev.hng[u].push_back(id);\r\n            rev.hng[o].push_back(-id);\r\n        }\r\n        if(dep[v]-dep[w]>=n) {\r\n            int o=jump(v,dep[v]-dep[w]-n+1);\r\n            gon.hng[v].push_back(id);\r\n            gon.hng[o].push_back(-id);\r\n        }\r\n        if(u==w||v==w) continue;\r\n        Q[id]=get_border(w,v,pre,ant);\r\n    }\r\n    tim=0; dfs1(0); dfs2(0);\r\n}\r\n}\r\nbool memEn;\r\nint main() {\r\n    fprintf(stderr,\"%.24lf\\n\",fabs(&memEn-&memBeg)/1024.0/1024.0);\r\n    ios::sync_with_stdio(0); cin.tie(0);\r\n    cin>>n>>m>>q;\r\n    for(int i=1;i<=n;i++) head[i]=-1;\r\n    for(int i=1;i<n;i++) {\r\n        int u,v; char c;\r\n        cin>>u>>v>>c;\r\n        while(c<'a'||c>'z') cin>>c;\r\n        add_edge(u,v,c);\r\n    }\r\n    for(int i=1;i<=m;i++) cin>>tpl[i];\r\n    pw[0]=(hash_t){1,1};\r\n    pw[1]=(hash_t){800006833,800063291};\r\n    for(int i=2;i<maxsz;i++)\r\n        pw[i]=pw[i-1]*pw[1];\r\n    dfs0(1);\r\n    for(int lg=1;(1<<lg)<=n;lg++)\r\n        for(int i=1;i<=n;i++)\r\n            fa[lg][i]=fa[lg-1][fa[lg-1][i]];\r\n    for(int i=1;i<=q;i++) {\r\n        cin>>s[i]>>t[i]>>sr[i];\r\n        lca[i]=LCA(s[i],t[i]);\r\n        qry[sr[i]].push_back(i);\r\n    }\r\n    gon.build();\r\n    for(int i=1;i<=m;i++)\r\n        reverse(tpl[i].begin(),tpl[i].end());\r\n    rev.build();\r\n    for(int i=1;i<=m;i++)\r\n        reverse(tpl[i].begin(),tpl[i].end());\r\n    for(int i=1;i<=m;i++) solver::work(i);\r\n    gon.dfs2(1,0); rev.dfs2(1,0);\r\n    for(int i=1;i<=q;i++) cout<<ret[i]<<'\\n';\r\n\treturn 0;\r\n}\r\n"
}