{
    "id": 85839296,
    "contestId": 917,
    "creationTimeSeconds": 1593768335,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "Qiuly.qwq"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 904,
    "memoryConsumedBytes": 116838400,
    "source": "/*CYJian txdy!!*/\r\n#include <map>\r\n#include <set>\r\n#include <queue>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <vector>\r\n#include <string>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\ntypedef long long ll;\r\ntypedef unsigned int uint;\r\ntypedef unsigned long long ull;\r\ntypedef std::vector <int> poly;\r\n\r\n#define rez resize\r\n#define pp pop_back\r\n#define pb push_back\r\n#define mkp make_pair\r\n#define fi first\r\n#define se second\r\n#define CLEAR(x) memset((x),0,sizeof((x)))\r\n\r\n#define _int(n) new int[(n)]()\r\n#define _Node(n) new Node[(n)]()\r\n\r\nnamespace _ {\r\n    const int inf=1e9+7;\r\n    namespace _in {\r\n        template <class T> inline T read() {\r\n        \tchar ch;bool flag=0;T x=0;\r\n        \twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\r\n        \twhile(isdigit(ch)) x=x*10+ch-48,ch=getchar();\r\n        \treturn flag?-x:x;\r\n\t\t}\r\n\t\tstruct {\r\n\t\t\tinline operator ll() {return read<ll>();}\r\n\t\t\tinline operator int() {return read<int>();}\r\n\t\t\tinline operator bool() {return read<bool>();}\r\n\t\t\ttemplate <class T> inline void operator() (T&x) {x=*this;}\r\n\t\t\ttemplate <class T,class ...A> inline void operator() (T&x,A&...a)\r\n\t\t\t{x=*this,this->operator()(a...);}\r\n\t\t} IN;\r\n    } using namespace _in;\r\n    namespace _std {\r\n\t\ttemplate <class T> inline void swap(T&x,T&y) {x^=y^=x^=y;}\r\n\t\ttemplate <class T> inline T max(T x,T y) {if(x<y) x=y;return x;}\r\n\t\ttemplate <class T> inline T min(T x,T y) {if(x>y) x=y;return x;}\r\n\t\ttemplate <class T> inline void chkmax(T&x,T y) {if(x<y) x=y;}\r\n\t\ttemplate <class T> inline void chkmin(T&x,T y) {if(x>y) x=y;}\r\n    } using namespace _std;\r\n} using namespace _;\r\n\r\nconst int N=1e5+2;\r\nconst int LogN=18;\r\n \r\nstruct Edge_Node {int to,val;};\r\nstruct Query {int id1,id2,typ,val;};\r\n\r\nchar tmp_str[N];\r\nint n,m,q,ans[N],fa_ch[N],len_str[N];\r\n\r\nint *str[N];\r\n\r\nstd::vector <Edge_Node> son[N];\r\nstd::vector <Query> que_nod[N];\r\n\r\nnamespace Hash {\r\n\ttypedef std::pair <uint,uint> Node;\r\n\tconst Node base=Node(7,23);\r\n\t\r\n\tinline Node operator + (const Node &a,const Node &b) {return Node(a.fi+b.fi,a.se+b.se);}\r\n\tinline Node operator - (const Node &a,const Node &b) {return Node(a.fi-b.fi,a.se-b.se);}\r\n\tinline Node operator * (const Node &a,const Node &b) {return Node(a.fi*b.fi,a.se*b.se);}\r\n\tinline bool operator == (const Node &a,const Node &b) {return (a.fi==b.fi)&&(a.se==b.se);}\r\n} using namespace Hash;\r\n\r\nstruct BIT {\r\n\tint lim,res,c[N];\r\n\tinline int lowbit(int x) {return x&(-x);}\r\n\tinline void update(int x,int y) {for(;x<=lim;x+=lowbit(x)) c[x]+=y;}\r\n\tinline int _sum(int x) {res=0;for(;x;x-=lowbit(x)) res+=c[x];return res;}\r\n\tinline int query(int l,int r) {return _sum(r)-_sum(l-1);}\r\n} bit[2];\r\n\r\nstruct AC_AutoMaton {\r\n    std::queue <int> que;\r\n\tstd::vector <int> son[N];\r\n\r\n    int tot,tim,ch[N][26],fail[N],pos[N],dfn[N],siz[N];\r\n\r\n\tinline void build() {\r\n\t    for(int i=0;i<26;++i) if(ch[0][i])\r\n            fail[ch[0][i]]=0,que.push(ch[0][i]);\r\n\t    while(!que.empty()) {\r\n\t        int u=que.front();que.pop();\r\n\t        for(int c=0;c<26;++c)\r\n\t\t\t\tif(ch[u][c]) fail[ch[u][c]]=ch[fail[u]][c],que.push(ch[u][c]);\r\n\t\t\t\telse ch[u][c]=ch[fail[u]][c];\r\n        }\r\n\t}\r\n\tinline void insert(int id) {\r\n\t\tint now=0,len=len_str[id];\r\n\t\tfor(int i=1;i<=len;++i) {\r\n\t\t\tif(!ch[now][str[id][i]]) ch[now][str[id][i]]=++tot;\r\n\t\t\tnow=ch[now][str[id][i]];\r\n\t\t}\r\n\t\tpos[id]=now;\r\n\t}\r\n\tvoid get_son() {\r\n\t\tfor(int i=1;i<=tot;++i) son[fail[i]].pb(i);\r\n\t}\r\n\tvoid pre_dfn(int u) {\r\n\t\tdfn[u]=++tim,siz[u]=1;\r\n\t\tfor(int v:son[u]) pre_dfn(v),siz[u]+=siz[v];\r\n\t}\r\n} acm[2];\r\n\r\nnamespace LCA {\r\n\tint dep[N],fa[N][LogN];\r\n\tvoid get_fa(int u,int f) {\r\n\t\tfa[u][0]=f,dep[u]=dep[f]+1;\r\n\t\tfor(int i=1;i<18;++i) fa[u][i]=fa[fa[u][i-1]][i-1];\r\n\t\tfor(Edge_Node now:son[u]) if(now.to!=f)\r\n\t\t\tget_fa(now.to,u),fa_ch[now.to]=now.val;\r\n\t}\r\n\tinline int Lca(int x,int y) {\r\n\t\tif(x==y) return x;\r\n\t\tif(dep[x]<dep[y]) swap(x,y);\r\n\t\tfor(int i=17;~i;--i) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];\r\n\t\tif(x==y) return x;\r\n\t\tfor(int i=17;~i;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\r\n\t\treturn fa[x][0];\r\n\t}\r\n\tinline int kth(int x,int d) {\r\n\t\tif(dep[x]<d) return -1;\r\n\t\tfor(int i=17;~i;--i) if(dep[fa[x][i]]>=d) x=fa[x][i];\r\n\t\treturn x;\r\n\t}\r\n} using namespace LCA;\r\n\r\nNode sum[N],has_pow[N]; /*1->...->u hash*/\r\ninline Node tree_calc(int x,int y) {return sum[x]-sum[y]*has_pow[dep[x]-dep[y]];}\r\n\r\nint tot_bor[2];\r\nstruct Border {int s,t,d;} border[N][2];\r\n\r\nstruct KMP {\r\n\tint n,*las,*nxt,*del;\r\n\r\n\tinline void build(int id) {\r\n\t\tn=len_str[id],nxt=_int(n+2),las=_int(n+2),del=_int(n+2);\r\n\t\tdel[1]=las[1]=1;\r\n\t\tfor(int i=2,t=0;i<=n;++i) {\r\n\t\t\twhile(t&&str[id][i]!=str[id][t+1]) t=nxt[t];\r\n\t\t\tif(str[id][i]==str[id][t+1]) ++t;\r\n\t\t\tnxt[i]=t,del[i]=i-t,las[i]=(del[i]==del[t])?las[t]:i;\r\n\t\t}\r\n\t}\r\n\tinline void get_border(int pos,int len,int typ) {\r\n\t\twhile(pos>len) pos=nxt[pos];\r\n\r\n\t\twhile(pos>0) {\r\n\t\t\tborder[++tot_bor[typ]][typ]=(Border){las[pos],pos,del[pos]};\r\n\t\t\tpos=nxt[las[pos]];\r\n\t\t}\r\n\t}\r\n} kmp[N][2];\r\n\r\nint hep[N];\r\nstruct Suffix_Array {\r\n\tNode *has;\r\n\tint n,m,*x,*y,*sa,*ch;\r\n\r\n\tinline Node sa_calc(int l,int r) {return has[r]-has[l-1]*has_pow[r-l+1];}\r\n\tinline void sort() {\r\n\t\tfor(int i=0;i<=m;++i) hep[i]=0;\r\n\t\tfor(int i=1;i<=n;++i) ++hep[x[i]];\r\n\t\tfor(int i=1;i<=m;++i) hep[i]+=hep[i-1];\r\n\t\tfor(int i=n;i>=1;--i) sa[hep[x[y[i]]]--]=y[i];\r\n\t}\r\n\tinline void build(int id) {\r\n\t\tn=len_str[id],m=27;\r\n\t\tx=_int(n+2),y=_int(n+2),sa=_int(n+2),ch=_int(n+2);\r\n\t\thas=_Node(n+2);\r\n\r\n\t\thas[0]=Node(1,1);\r\n\t\tfor(int i=1;i<=n;++i) has[i]=has[i-1]*base+Node(str[id][i],str[id][i]);\r\n\r\n\t\tfor(int i=1;i<=n;++i) x[y[i]=i]=str[id][i]+1,ch[i]=str[id][i];\r\n\t\tsort();\r\n\t\tfor(int w=1,p=0;m=p,p<n;w<<=1) {\r\n\t\t\tfor(int i=1;i<=w;++i) y[p=i]=n-w+i;\r\n\t\t\tfor(int i=1;i<=n;++i) if(sa[i]>w) y[++p]=sa[i]-w;\r\n\t\t\tsort(),std::swap(x,y),x[sa[1]]=p=1;\r\n\t\t\tfor(int i=2;i<=n;++i)\r\n\t\t\t\tx[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+w]==y[sa[i-1]+w])?p:++p;\r\n\t\t}\r\n\t}\r\n\tinline int lcp(int p,int u,int lca,int len=0) {\r\n\t\tif(u==lca) return 0;\r\n\t\tp=sa[p],len=n-p+1;\r\n\t\t#define all dep[u]-dep[lca]\r\n\r\n\t\tif(len>=all&&tree_calc(u,lca)==sa_calc(p,p+all-1)) return all;\r\n\t\telse {\r\n\t\t\tint las;\r\n\t\t\tfor(int i=17;~i;--i) if(all>(1<<i)) {\r\n\t\t\t\tlas=u,u=fa[u][i];\r\n\t\t\t\tif(len>=all&&tree_calc(u,lca)==sa_calc(p,p+all-1)) u=las;\r\n\t\t\t}\r\n\t\t\tu=fa[u][0];\r\n\t\t\treturn all;\r\n\t\t}\r\n\t}\r\n\tinline bool check(int mid,int u,int lca) {\r\n\t\tint now=lcp(mid,u,lca);\r\n\t\tif(now==n-sa[mid]+1) return true;\r\n\t\tif(now==dep[u]-dep[lca]) return false;\r\n\t\treturn ch[sa[mid]+now]<fa_ch[kth(u,dep[lca]+now+1)];\r\n\t}\r\n\tinline void get_maxlen(int u,int lca,int id,int typ) {\r\n\t\tint l=1,r=n,mid,ans=0;\r\n\t\twhile(l<=r) check(mid=(l+r)>>1,u,lca)?ans=mid,l=mid+1:r=mid-1;\r\n\t\tif(!ans) return ;\r\n\t\tint len=lcp(ans,u,lca),pos=n-sa[ans]+1;\r\n\t\tkmp[id][typ].get_border(pos,len,typ);\r\n\t}\r\n} sa[N][2];\r\n\r\ninline void addedge(int u=0,int v=0) {\r\n\tIN(u,v),scanf(\"%s\",tmp_str);\r\n\tson[u].pb((Edge_Node){v,tmp_str[0]-'a'}),\r\n\tson[v].pb((Edge_Node){u,tmp_str[0]-'a'});\r\n}\r\n\r\nvoid get_ac_ans(int u,int t1,int t2) {\r\n\tbit[0].update(acm[0].dfn[t1],1);\r\n\tbit[1].update(acm[1].dfn[t2],1);\r\n\r\n\tfor(Query now:que_nod[u]) {\r\n\t\tint id=now.id2,p=now.typ,v=now.val,k=acm[p].pos[now.id1];\r\n\t\tans[id]+=v*bit[p].query(acm[p].dfn[k],acm[p].dfn[k]+acm[p].siz[k]-1);\r\n\t}\r\n\tfor(Edge_Node now:son[u]) {\r\n\t\tint v=now.to,c=now.val;\r\n\t\tif(v==fa[u][0]) continue;\r\n\t\tget_ac_ans(v,acm[0].ch[t1][c],acm[1].ch[t2][c]);\r\n\t}\r\n\r\n\tbit[0].update(acm[0].dfn[t1],-1);\r\n\tbit[1].update(acm[1].dfn[t2],-1);\r\n}\r\n\r\nvoid get_hash(int u) {\r\n\tfor(Edge_Node now:son[u]) {\r\n\t\tint v=now.to,c=now.val;\r\n\t\tif(v==fa[u][0]) continue;\r\n\t\tsum[v]=sum[u]*base+Node(c,c),get_hash(v);\r\n\t}\r\n}\r\n\r\nint exgcd(int a,int b,int &x,int &y) {\r\n\tif(!b) return x=1,y=0,a;\r\n\tint t=exgcd(b,a%b,y,x);\r\n\treturn y-=a/b*x,t;\r\n}\r\ninline int get_ans(int a,int b,int la,int lb,int c) {\r\n\tint x,y,gcd=exgcd(a,b,x,y);\r\n\tif(c%gcd) return 0;\r\n\tx*=c/gcd,y*=c/gcd;\r\n\r\n\tint _a=a/gcd,_b=b/gcd,_x=(x%_b+_b)%_b;\r\n\ty+=((x-_x)/_b)*_a,x=_x;\r\n\r\n\tif(y<0) return 0;\r\n\tif(y>lb) {\r\n\t\tint t=(y-lb-1)/_a+1;\r\n\t\ty-=t*_a,x+=t*_b;\r\n\t}\r\n\tif(x<0||y<0||x>la||y>lb) return 0;\r\n\treturn min((la-x)/_b+1,y/_a+1);\r\n}\r\n\r\ninline int kmp_solve(int u,int v,int lca,int id) {\r\n\ttot_bor[0]=tot_bor[1]=0;\r\n\tsa[id][1].get_maxlen(u,lca,id,0);\r\n\tsa[id][0].get_maxlen(v,lca,id,1);\r\n\r\n\tint res=0;\r\n\t#define a border[i][0]\r\n\t#define b border[j][1]\r\n\r\n\tfor(int i=1;i<=tot_bor[0];++i)\r\n\t\tfor(int j=1;j<=tot_bor[1];++j)\r\n\t\t\tif(a.s+b.s<=len_str[id]&&a.t+b.t>=len_str[id]) {\r\n\t\t\t\tint la=(a.t-a.s)/a.d;\r\n\t\t\t\tint lb=(b.t-b.s)/b.d;\r\n\t\t\t\tres+=get_ans(a.d,b.d,la,lb,len_str[id]-a.s-b.s);\r\n\t\t\t}\r\n\r\n\t#undef a\r\n\t#undef b\r\n\treturn res;\r\n}\r\n\r\nint u,v,id;\r\nint main() {\r\n    #ifndef ONLINE_JUDGE\r\n        freopen(\"code.in\",\"r\",stdin);\r\n        // freopen(\"code.out\",\"w\",stdout);\r\n    #endif\r\n\tIN(n,m,q);\r\n\tfor(int i=2;i<=n;++i) addedge();\r\n\tget_fa(1,0),get_hash(1);\r\n\r\n\thas_pow[0]=Node(1,1);\r\n\tfor(int i=1;i<N;++i) has_pow[i]=has_pow[i-1]*base;\r\n\r\n\tfor(int i=1;i<=m;++i) {\r\n\t\tscanf(\"%s\",tmp_str),\r\n\t\tlen_str[i]=strlen(tmp_str);\r\n\t\tstr[i]=new int[len_str[i]+2]();\r\n\t\tfor(int j=1;j<=len_str[i];++j) str[i][j]=tmp_str[j-1]-'a';\r\n\t\tstr[i][0]=str[i][len_str[i]+1]=-1;\r\n\r\n\t\tacm[0].insert(i);\r\n\t\tsa[i][0].build(i);\r\n\t\tkmp[i][0].build(i);\r\n\t\tstd::reverse(str[i]+1,str[i]+1+len_str[i]);\r\n\r\n\t\tacm[1].insert(i);\r\n\t\tsa[i][1].build(i);\r\n\t\tkmp[i][1].build(i);\r\n\t\tstd::reverse(str[i]+1,str[i]+1+len_str[i]);\r\n\t}\r\n\r\n\tacm[0].build(),acm[0].get_son(),acm[0].pre_dfn(0);\r\n\tacm[1].build(),acm[1].get_son(),acm[1].pre_dfn(0);\r\n\tbit[0].lim=acm[0].tim,bit[1].lim=acm[1].tim;\r\n\r\n\tfor(int t=1;t<=q;++t) {\r\n\t\tIN(u,v,id);\r\n\r\n\t\tint lca=Lca(u,v);\r\n\t\tans[t]=kmp_solve(u,v,lca,id);\r\n\t\t\r\n\t\tint t1=kth(u,min(dep[u],dep[lca]+len_str[id]-1));\r\n\t\tint t2=kth(v,min(dep[v],dep[lca]+len_str[id]-1));\r\n\r\n\t\tif(t1!=u) que_nod[u].pb((Query){id,t,1,1}),que_nod[t1].pb((Query){id,t,1,-1});\r\n\t\tif(t2!=v) que_nod[v].pb((Query){id,t,0,1}),que_nod[t2].pb((Query){id,t,0,-1});\r\n\t}\r\n\t\r\n\tget_ac_ans(1,0,0);\r\n\tfor(int i=1;i<=q;++i) printf(\"%d\\n\",ans[i]);\r\n    return 0;\r\n}"
}