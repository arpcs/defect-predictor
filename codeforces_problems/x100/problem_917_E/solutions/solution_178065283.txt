{
    "id": 178065283,
    "contestId": 917,
    "creationTimeSeconds": 1666855543,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 917,
        "index": "E",
        "name": "Upside Down",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 3400,
        "tags": [
            "data structures",
            "string suffix structures",
            "strings",
            "trees"
        ]
    },
    "author": {
        "contestId": 917,
        "members": [
            {
                "handle": "jrxxx"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1517236500
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 118,
    "timeConsumedMillis": 951,
    "memoryConsumedBytes": 154828800,
    "source": "//test\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define TIME 1e3 * clock() / CLOCKS_PER_SEC\r\nusing ll = long long;\r\nusing uint = unsigned int;\r\n// using lll = __int128;\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing ull = unsigned long long;\r\ninline ll read() {\r\n  ll x = 0, sgn = 0;\r\n  char s = getchar();\r\n  while(!isdigit(s)) sgn |= s == '-', s = getchar();\r\n  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();\r\n  return sgn ? -x : x;\r\n}\r\ninline void print(ll x) {\r\n  if(x < 0) return putchar('-'), print(-x);\r\n  if(x >= 10) print(x / 10);\r\n  putchar(x % 10 + '0');\r\n}\r\nbool Mbe;\r\nconstexpr int K = 18;\r\nconstexpr int N = 2e5 + 5;\r\nconstexpr int S = 26;\r\nconstexpr int mod = 1004535809;\r\nconstexpr int base = 131;\r\nstring s[N];\r\nint n, m, q, pw[N];\r\nint u[N], v[N], ulcp[N], vlcp[N], uarg[N], varg[N], d[N], k[N], ans[N];\r\nnamespace tree {\r\n  vector<pii> e[N];\r\n  int lg, dep[N], hsh[N], fch[N], anc[K][N];\r\n  int get(int u, int v) {\r\n    assert(dep[u] <= dep[v]);\r\n    return (hsh[v] + mod - 1ll * hsh[u] * pw[dep[v] - dep[u]] % mod) % mod;\r\n  }\r\n  void dfs(int id, int ff) {\r\n    dep[id] = dep[anc[0][id] = ff] + 1;\r\n    for(pii _ : e[id]) {\r\n      int it = _.first;\r\n      if(it == ff) continue;\r\n      hsh[it] = (1ll * hsh[id] * base + _.second) % mod;\r\n      fch[it] = _.second, dfs(it, id);\r\n    }\r\n  }\r\n  void build() {\r\n    lg = 31 - __builtin_clz(n);\r\n    dfs(1, 0);\r\n    for(int i = 1; i <= lg; i++)\r\n      for(int j = 1; j <= n; j++)\r\n        anc[i][j] = anc[i - 1][anc[i - 1][j]];\r\n  }\r\n  int kth(int u, int k) {\r\n    for(int i = lg; ~i; i--) if(k >> i & 1) u = anc[i][u];\r\n    return u;\r\n  }\r\n  int lca(int u, int v) {\r\n    if(dep[u] < dep[v]) swap(u, v);\r\n    u = kth(u, dep[u] - dep[v]);\r\n    if(u == v) return u;\r\n    for(int i = lg; ~i; i--) if(anc[i][u] != anc[i][v]) u = anc[i][u], v = anc[i][v];\r\n    return anc[0][u];\r\n  }\r\n}\r\nstruct BIT {\r\n  int c[N];\r\n  void add(int x, int v) {while(x < N) c[x] += v, x += x & -x;}\r\n  void add(int l, int r, int v) {add(l, v), add(r + 1, -v);}\r\n  int query(int x) {int s = 0; while(x) s += c[x], x -= x & -x; return s;}\r\n  int query(int l, int r) {return query(r) - query(l - 1);}\r\n};\r\nstruct acam {\r\n  int node, son[N][S], fa[N], ed[N];\r\n  void ins(string s, int id) {\r\n    int p = 0;\r\n    for(char it : s) {\r\n      if(!son[p][it - 'a']) son[p][it - 'a'] = ++node;\r\n      p = son[p][it - 'a'];\r\n    }\r\n    ed[id] = p;\r\n  }\r\n  int dn, dfn[N], sz[N];\r\n  vector<int> e[N], buc[N];\r\n  void dfs(int id) {\r\n    dfn[id] = ++dn, sz[id] = 1;\r\n    for(int it : e[id]) dfs(it), sz[id] += sz[it];\r\n  }\r\n  void build() {\r\n    queue<int> q;\r\n    for(int i = 0; i < S; i++) if(son[0][i]) q.push(son[0][i]);\r\n    while(!q.empty()) {\r\n      int t = q.front(); q.pop();\r\n      e[fa[t]].push_back(t);\r\n      for(int i = 0; i < S; i++)\r\n        if(son[t][i]) q.push(son[t][i]), fa[son[t][i]] = son[fa[t]][i];\r\n        else son[t][i] = son[fa[t]][i];\r\n    }\r\n    dfs(0);\r\n  }\r\n  BIT tr;\r\n  void solve(int id, int ff, int cur) {\r\n    if(cur) tr.add(dfn[cur], 1);\r\n    for(int it : buc[id]) {\r\n      int id = abs(it), c = id / it;\r\n      int x = ed[k[id]], l = dfn[x], r = dfn[x] + sz[x] - 1;\r\n      ans[id] += tr.query(l, r) * c;\r\n    }\r\n    for(pii _ : tree::e[id]) {\r\n      int it = _.first;\r\n      if(it != ff) solve(it, id, son[cur][_.second - 'a']);\r\n    }\r\n    if(cur) tr.add(dfn[cur], -1);\r\n  }\r\n} A, AR;\r\nstruct border {\r\n  int lg, dn, dfn[N], sz[N], nxt[N], anc[K][N];\r\n  vector<int> e[N];\r\n  void dfs(int id) {\r\n    dfn[id] = ++dn, sz[id] = 1;\r\n    for(int it : e[id]) dfs(it), sz[id] += sz[it];\r\n  }\r\n  void build(int n, int *s) {\r\n    dn = 0;\r\n    for(int i = 0; i <= n; i++) e[i].clear();\r\n    for(int i = 2, j = 0; i <= n; i++) {\r\n      while(j && s[j + 1] != s[i]) j = nxt[j];\r\n      anc[0][i] = nxt[i] = j += s[j + 1] == s[i];\r\n    }\r\n    for(int i = 1; i <= n; i++) e[nxt[i]].push_back(i);\r\n    dfs(0), lg = 31 - __builtin_clz(dn);\r\n    for(int i = 1; i <= lg; i++)\r\n      for(int j = 0; j <= dn; j++)\r\n        anc[i][j] = anc[i - 1][anc[i - 1][j]];\r\n  }\r\n  int binary(int x, int lim) {\r\n    if(x <= lim) return x;\r\n    for(int i = lg; ~i; i--) if(anc[i][x] > lim) x = anc[i][x];\r\n    return anc[0][x];\r\n  }\r\n} ori, rev;\r\nnamespace combine {\r\n  vector<int> buc[N];\r\n  BIT tr;\r\n  void dfs(int n, int id) {\r\n    int l = rev.dfn[n - id], r = l + rev.sz[n - id] - 1;\r\n    if(id && id < n) tr.add(l, r, 1);\r\n    for(int it : buc[id]) ans[it] += tr.query(rev.dfn[varg[it]]);\r\n    for(int it : ori.e[id]) dfs(n, it);\r\n    if(id && id < n) tr.add(l, r, -1);\r\n  }\r\n  void solve(int n, vector<int> &qu) {\r\n    for(int i = 1; i <= n; i++) buc[i].clear();\r\n    for(int it : qu) {\r\n      uarg[it] = ori.binary(uarg[it], ulcp[it]);\r\n      varg[it] = rev.binary(varg[it], vlcp[it]);\r\n      if(uarg[it] + varg[it] < n) continue;\r\n      buc[uarg[it]].push_back(it);\r\n    }\r\n    dfs(n, 0);\r\n  }\r\n}\r\nnamespace sa {\r\n  int n, s[N];\r\n  vector<int> qu[N];\r\n  int sa[N], rk[N], ork[N], buc[N], id[N], hsh[N];\r\n  int get(int l, int r) {return l--, (hsh[r] + mod - 1ll * hsh[l] * pw[r - l] % mod) % mod;}\r\n  bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}\r\n  void build() {\r\n    int m = 1 << 7, p = 0;\r\n    memset(rk, 0, n + 5 << 2);\r\n    memset(buc, 0, m + 5 << 2);\r\n    for(int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;\r\n    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];\r\n    for(int i = n; i; i--) sa[buc[rk[i]]--] = i;\r\n    for(int w = 1; ; w <<= 1, m = p, p = 0) {\r\n      for(int i = n - w + 1; i <= n; i++) id[++p] = i;\r\n      for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;\r\n      memset(buc, 0, m + 5 << 2);\r\n      memcpy(ork, rk, n + 5 << 2);\r\n      p = 0;\r\n      for(int i = 1; i <= n; i++) buc[rk[i]]++;\r\n      for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];\r\n      for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];\r\n      for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;\r\n      if(p == n) break;\r\n    }\r\n  }\r\n  pair<int, pii> lcp(int id, int d, int u) \r\n  {\r\n    assert(u != d);\r\n    auto chk = [&](int p) \r\n    {\r\n      int dis = tree::dep[p] - tree::dep[d];\r\n      if(id + dis - 1 > n) return false; // add this line\r\n      return tree::get(d, p) == get(id, id + dis - 1);\r\n    };\r\n    for(int i = tree::lg; ~i; i--) \r\n    {\r\n      int x = tree::anc[i][u];\r\n      if(tree::dep[x] <= tree::dep[d]) continue;\r\n      if(!chk(x)) u = x;\r\n    }\r\n    int nct = 0;\r\n    if(!chk(u)) nct = tree::fch[u], u = tree::anc[0][u];\r\n    int L = tree::dep[u] - tree::dep[d];\r\n    return {L, {s[id + L], nct}};\r\n  }\r\n  void solve() \r\n  {\r\n    for(int i = 1; i <= m; i++) \r\n    {\r\n      if(qu[i].empty()) continue;\r\n      n = ::s[i].size(), s[n + 1] = 0;\r\n      for(int j = 1; j <= n; j++) s[j] = ::s[i][n - j];\r\n      auto calc = [&](border &T, int *u, int *L, int *arg) \r\n      {\r\n        for(int j = 1; j <= n; j++) hsh[j] = (1ll * hsh[j - 1] * base + s[j]) % mod;\r\n        build(), T.build(n, s);\r\n        for(int it : qu[i]) \r\n        {\r\n          int l = 0, r = n;\r\n          while(l < r) \r\n          {\r\n            int m = l + r + 2 >> 1;\r\n            pii dat = lcp(sa[m], d[it], u[it]).second;\r\n            if(dat.first < dat.second) l = m;\r\n            else r = m - 1;\r\n          }\r\n          if(l) \r\n          {\r\n            int tmp = lcp(sa[l], d[it], u[it]).first;\r\n            if(tmp > L[it]) L[it] = tmp, arg[it] = sa[l];\r\n          }\r\n          if(l < n) \r\n          {\r\n            int tmp = lcp(sa[l + 1], d[it], u[it]).first;\r\n            if(tmp > L[it]) L[it] = tmp, arg[it] = sa[l + 1];\r\n          }\r\n          if(!L[it]) continue; // add this line\r\n          arg[it] = n - arg[it] + 1; // add this line\r\n        }\r\n      };\r\n      calc(rev, u, ulcp, uarg), reverse(s + 1, s + n + 1);\r\n      calc(ori, v, vlcp, varg), combine::solve(n, qu[i]);\r\n    }\r\n  }\r\n}\r\nbool Med;\r\nint main() {\r\n  fprintf(stderr, \"%.3lf MB\\n\", (&Mbe - &Med) / 1048576.0);\r\n  #ifdef ALEX_WEI\r\n    FILE* IN = freopen(\"1.in\", \"r\", stdin);\r\n    FILE* OUT = freopen(\"1.out\", \"w\", stdout);\r\n  #endif\r\n  cin >> n >> m >> q;\r\n  for(int i = pw[0] = 1; i < N; i++) pw[i] = 1ll * pw[i - 1] * base % mod;\r\n  for(int i = 1; i < n; i++) {\r\n    int x = read(), y = read();\r\n    char ch;\r\n    cin >> ch;\r\n    tree::e[x].push_back({y, ch});\r\n    tree::e[y].push_back({x, ch});\r\n  }\r\n  tree::build();\r\n  for(int i = 1; i <= m; i++) {\r\n    cin >> s[i], A.ins(s[i], i);\r\n    reverse(s[i].begin(), s[i].end()), AR.ins(s[i], i);\r\n    reverse(s[i].begin(), s[i].end());\r\n  }\r\n  A.build(), AR.build();\r\n  for(int i = 1; i <= q; i++) {\r\n    u[i] = read(), v[i] = read(), k[i] = read();\r\n    int L = s[k[i]].size();\r\n    if(L > n) continue;\r\n    d[i] = tree::lca(u[i], v[i]);\r\n    int du = tree::dep[u[i]] - tree::dep[d[i]];\r\n    if(du >= L) {\r\n      int anc = tree::kth(u[i], du - L + 1);\r\n      AR.buc[anc].push_back(-i);\r\n      AR.buc[u[i]].push_back(i);\r\n      u[i] = anc, du = L - 1;\r\n    }\r\n    int dv = tree::dep[v[i]] - tree::dep[d[i]];\r\n    if(dv >= L) {\r\n      int anc = tree::kth(v[i], dv - L + 1);\r\n      A.buc[anc].push_back(-i);\r\n      A.buc[v[i]].push_back(i);\r\n      v[i] = anc, dv = L - 1;\r\n    }\r\n    if(u[i] != d[i] && v[i] != d[i] && du + dv >= L) sa::qu[k[i]].push_back(i);\r\n  }\r\n  A.solve(1, 0, 0);\r\n  AR.solve(1, 0, 0);\r\n  sa::solve();\r\n  for(int i = 1; i <= q; i++) print(ans[i]), putchar('\\n');\r\n  cerr << TIME << \" ms\\n\";\r\n  return 0;\r\n}\r\n/*\r\n2022/9/30\r\nauthor: Alex_Wei\r\nstart coding at 8:01\r\nfinish debugging at 11:21\r\n*/"
}