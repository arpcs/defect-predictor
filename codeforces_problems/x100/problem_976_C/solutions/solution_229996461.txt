{
    "id": 229996461,
    "contestId": 976,
    "creationTimeSeconds": 1698403893,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 976,
        "index": "C",
        "name": "Nested Segments",
        "type": "PROGRAMMING",
        "rating": 1500,
        "tags": [
            "greedy",
            "implementation",
            "sortings"
        ]
    },
    "author": {
        "contestId": 976,
        "members": [
            {
                "handle": "Francesco4203"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1525099200
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 122,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 3584000,
    "source": "\ufeff#include <bits/stdc++.h>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <random>\r\n#include <chrono>\r\nusing namespace std;\r\n\r\n#define rp(i,n) for (int i=0;i<(int)n;i++)\r\n#define x first\r\n#define y second\r\n#define pii pair<int, int> \r\n#define pli pair<long long, int>\r\n#define pil pair<int, long long>\r\n#define pll pair<long long, long long>\r\n#define ll long long\r\n#define pdd pair<double, double>\r\n#define ld long double\r\n//#include <ext/pb_ds/assoc_container.hpp>\r\n//using namespace __gnu_pbds;\r\n//typedef tree<int, null_type, less<long long>, rb_tree_tag, tree_order_statistics_node_update>\r\n//ordered_set;\r\n//typedef tree<int, null_type, greater<long long>, rb_tree_tag, tree_order_statistics_node_update>\r\n//ordered_set_big;\r\n\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nvoid speedthefuckup() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n}\r\ndouble const epsilon = 1e-9;\r\ndouble const pi_number = 3.14159265359;\r\nll const mod = 1e9 + 7;\r\nint double_cmp(double x, double y) {\r\n    return (x < y - epsilon) ? -1 : (x > y + epsilon);\r\n}\r\nstruct point {\r\n    double x, y;\r\n    point(double xx = 0, double yy = 0) {\r\n        x = xx, y = yy;\r\n    }\r\n    int double_cmp(const point& p) const {\r\n        if (x != p.x) return ::double_cmp(x, p.x);\r\n        return ::double_cmp(y, p.y);\r\n    }\r\n    bool operator==(const point& p) {\r\n        return double_cmp(x) == 0;\r\n    }\r\n    bool operator!=(const point& p) {\r\n        return double_cmp(x) != 0;\r\n    }\r\n    point operator+(const point& p) const {\r\n        return point(x + p.x, y + p.y);\r\n    }\r\n    point operator-(const point& p) const {\r\n        return point(x - p.x, y - p.y);\r\n    }\r\n    point operator*(double k) const {\r\n        return point(x * k, y * k);\r\n    }\r\n    point operator/(double k) const {\r\n        return point(x / k, y / k);\r\n    }\r\n    double norm() {\r\n        return x * x + y * y;\r\n    }\r\n    double len() {\r\n        return sqrt(norm());\r\n    }\r\n    double dot(const point& p) const {\r\n        return x * p.x + y * p.y;\r\n    }\r\n    double dot(const point& a, const point& b) const {\r\n        return a.x * b.x + a.y * b.y;\r\n    }\r\n    double cross(const point& p) const {\r\n        return x * p.y - y * p.x;\r\n    }\r\n    double cross(const point& a, const point& b) const {\r\n        return a.x * b.y - a.y * b.x;\r\n    }\r\n    double dis_sq(const point& p) const {\r\n        return (p - *this).norm();\r\n    }\r\n    double dis_sq(const point& a, const point& b) const {\r\n        return a.dis_sq(b);\r\n    }\r\n    double dis(const point& p) const {\r\n        return (p - *this).len();\r\n    }\r\n    double dis(const point& a, const point& b) const {\r\n        return a.dis(b);\r\n    }\r\n    double mandis(const point& p) const {\r\n        return abs(x - p.x) + abs(y - p.y);\r\n    }\r\n    double mandis(const point& a, const point& b) const {\r\n        return a.mandis(b);\r\n    }\r\n    point rotate_anticlockwise(double alpha) {\r\n        double cosa = cos(alpha), sina = sin(alpha);\r\n        return point(x * cosa - y * sina, x * sina + y * cosa);\r\n    }\r\n};\r\nstruct line {\r\n    double a, b, c;\r\n    point A, B;\r\n    line(double a, double b, double c) {\r\n        this->a = a, this->b = b, this->c = c;\r\n    }\r\n    line(point A, point B) {\r\n        this->A = A;\r\n        this->B = B;\r\n        a = B.y - A.y;\r\n        b = A.x - B.x;\r\n        c = -(a * A.x + b * A.y);\r\n    }\r\n    line(point p, double k) {\r\n        a = -k;\r\n        b = 1;\r\n        c = k * p.x - p.y;\r\n    }\r\n    double f(point A) {\r\n        return a * A.x + b * A.y + c;\r\n    }\r\n};\r\nbool parallel(line a, line b) {\r\n    return double_cmp(a.a * b.b, a.b * b.a) == 0;\r\n}\r\nbool sameline(line a, line b) {\r\n    return parallel(a, b) && double_cmp(a.c * b.a, b.c * a.a) == 0\r\n        && double_cmp(a.c * b.b, a.b * b.c) == 0;\r\n}\r\nbool line_intersection(line a, line b, point& p) {\r\n    if (parallel(a, b)) return false;\r\n    double dx = a.b * b.c - b.b * a.c;\r\n    double dy = a.c * b.a - b.c * a.a;\r\n    double d = a.a * b.b - b.a * a.b;\r\n    p = point(dx / d, dy / d);\r\n    return true;\r\n}\r\ndouble point_to_line(line lin, point p) {\r\n    return abs(p.x * lin.a + p.y * lin.b + lin.c) / sqrt(lin.a * lin.a + lin.b * lin.b);\r\n}\r\ndouble point_to_line(point p, point a, point b, point& inter) {\r\n    point ap = p - a, ab = b - a;\r\n    double k = ap.dot(ab) / ab.norm();\r\n    inter = a + (ab * k);\r\n    return (p - inter).len();\r\n}\r\n\r\nstruct circle : point {\r\n    double r;\r\n    circle(double x = 0, double y = 0, double r = 0) : point(x, y), r(r) {}\r\n    circle(point p, double r) : point(p), r(r) {}\r\n    bool contains(point p) {\r\n        return (*this - p).len() <= r + epsilon;\r\n    }\r\n};\r\nvector<point> line_circle_intersection(line l, circle cir) {\r\n    double r = cir.r;\r\n    double a = l.a, b = l.b, c = l.c + l.a * cir.x + l.b * cir.y;\r\n    vector<point> res;\r\n    double x0 = -a * c / (a * a + b * b);\r\n    double y0 = -b * c / (a * a + b * b);\r\n    if (c * c > r * r * (a * a + b * b) + epsilon) return res;\r\n    else if (fabs(c * c - r * r * (a * a + b * b)) < epsilon) {\r\n        res.push_back(point(x0, y0) + point(cir.x, cir.y));\r\n        return res;\r\n    }\r\n    double d = r * r - c * c / (a * a + b * b);\r\n    double mult = sqrt(d / (a * a + b * b));\r\n    double ax, ay, bx, by;\r\n    ax = x0 + b * mult;\r\n    bx = x0 - b * mult;\r\n    ay = y0 - a * mult;\r\n    by = y0 + a * mult;\r\n    res.push_back(point(ax, ay) + point(cir.x, cir.y));\r\n    res.push_back(point(bx, by) + point(cir.x, cir.y));\r\n    return res;\r\n}\r\nvector<point> circle_intersection(circle a, circle b) {\r\n    circle x(0, 0, a.r);\r\n    double x0 = b.x - a.x;\r\n    double y0 = b.y - a.y;\r\n    line y(-2 * x0, -2 * y0, x0 * x0 + y0 * y0 + a.r * a.r - b.r * b.r);\r\n    vector<point> pts = line_circle_intersection(y, x);\r\n    for (int i = 0; i < pts.size(); i++) pts[i].x += a.x, pts[i].y += a.y;\r\n    return pts;\r\n}\r\n\r\nint ccw(point a, point b, point c) {\r\n    return double_cmp((b - a).cross(c - a), 0);\r\n}\r\npoint pivot;\r\nbool convex_compare(const point& p, const point& q) {\r\n    int tmp = ccw(pivot, p, q);\r\n    if (tmp > 0) return true;\r\n    return (tmp == 0 && (p - pivot).norm() < (q - pivot).norm());\r\n}\r\nvector<point> convex_hull(vector<point>& pts) {\r\n    if (pts.size() <= 2) return pts;\r\n    pivot = pts[0];\r\n    // take down leftmost\r\n    rp(i, pts.size()) {\r\n        if (pivot.y > pts[i].y\r\n            || (pivot.y == pts[i].y && pivot.x > pts[i].x)) {\r\n            pivot = pts[i];\r\n        }\r\n    }\r\n    sort(pts.begin(), pts.end(), convex_compare);\r\n    //pts.erase(unique(pts.begin(), pts.end()), pts.end());\r\n    vector<point> ans = vector<point>();\r\n    if (pts.size() < 3) return ans;\r\n    rp(i, pts.size()) {\r\n        while (ans.size() > 1 && ccw(ans[ans.size() - 2], ans.back(), pts[i]) <= 0) ans.pop_back();\r\n        ans.push_back(pts[i]);\r\n    }\r\n    return ans;\r\n}\r\nbool in_triangle(const point& a, const point& b, const point& c, point x) {\r\n    double a1, a2, a3;\r\n    double aa = abs((a - b).cross(a - c)) + abs((b - c).cross(b - a)) + abs((c - a).cross(c - b));\r\n    a1 = abs((x - b).cross(x - c)) + abs((b - c).cross(b - x)) + abs((c - x).cross(c - b));\r\n    a2 = abs((a - x).cross(a - c)) + abs((x - c).cross(x - a)) + abs((c - a).cross(c - x));\r\n    a3 = abs((a - b).cross(a - x)) + abs((b - x).cross(b - a)) + abs((x - a).cross(x - b));\r\n    return double_cmp(a1 + a2 + a3, aa) == 0;\r\n}\r\nbool in_polygon(vector<point>& polygon, point x) {\r\n    int l = 1, r = polygon.size() - 1;\r\n    while (l < r) {\r\n        int mid = (l + r) / 2;\r\n        if (ccw(polygon[0], x, polygon[mid]) == 1) r = mid;\r\n        else l = mid + 1;\r\n    }\r\n    bool ans = in_triangle(polygon[0], polygon[l], polygon[l - 1], x);\r\n    // if strictly in the polygon\r\n    /*if (l - 1 == 1) {\r\n        line tmp(polygon[0], polygon[1]);\r\n        ans &= double_cmp(point_to_line(tmp, x), 0);\r\n    }\r\n    if (l == polygon.size() - 1) {\r\n        line tmp(polygon[0], polygon.back());\r\n        ans &= double_cmp(point_to_line(tmp, x), 0);\r\n    }\r\n    line tmp(polygon[l], polygon[l - 1]);\r\n    ans &= double_cmp(point_to_line(tmp, x), 0);*/\r\n    return ans;\r\n}\r\nstruct matrix {\r\n    vector<vector<ll>> a;\r\n    int n, m;\r\n    matrix(int n = 0, int m = 0, ll val = 0) :n(n), m(m) {\r\n        a = vector<vector<ll>>(n, vector<ll>(m, val));\r\n    }\r\n    void readInput() {\r\n        rp(i, n) {\r\n            rp(j, m) {\r\n                cin >> a[i][j];\r\n            }\r\n        }\r\n    }\r\n    void print() {\r\n        rp(i, n) {\r\n            rp(j, m) cout << a[i][j] << ' ';\r\n            cout << '\\n';\r\n        }\r\n    }\r\n};\r\nmatrix operator*(const matrix& a, const matrix& b) {\r\n    matrix c(a.n, b.m);\r\n    rp(i, a.n) {\r\n        rp(j, b.m) {\r\n            rp(k, a.m) {\r\n                c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j] % mod) % mod;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmatrix power(matrix a, ll k) {\r\n    matrix ans(a.n, a.n, 0);\r\n    rp(i, a.n) ans.a[i][i] = 1;\r\n    while (k) {\r\n        if (k & 1) {\r\n            ans = ans * a;\r\n        }\r\n        a = a * a;\r\n        k >>= 1;\r\n    }\r\n    return ans;\r\n}\r\nstruct Dinic {\r\n    ll flow_inf = 1e18;\r\n    struct FlowEdge {\r\n        int v, u;\r\n        ll cap, flow = 0;\r\n        FlowEdge(int v, int u, ll cap) : v(v), u(u), cap(cap) {}\r\n    };\r\n\r\n    vector<FlowEdge> edges;\r\n    vector<vector<int>> adj;\r\n    int n, m = 0;\r\n    int s, t;\r\n    vector<int> level, ptr;\r\n    queue<int> q;\r\n\r\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\r\n        adj.resize(n);\r\n        level.resize(n);\r\n        ptr.resize(n);\r\n    }\r\n\r\n    void add_edge(int v, int u, ll cap) {\r\n        edges.emplace_back(v, u, cap);\r\n        edges.emplace_back(u, v, 0);\r\n        adj[v].push_back(m);\r\n        adj[u].push_back(m + 1);\r\n        m += 2;\r\n    }\r\n\r\n    bool bfs() {\r\n        while (!q.empty()) {\r\n            int v = q.front();\r\n            q.pop();\r\n            for (int id : adj[v]) {\r\n                if (edges[id].cap - edges[id].flow < 1)\r\n                    continue;\r\n                if (level[edges[id].u] != -1)\r\n                    continue;\r\n                level[edges[id].u] = level[v] + 1;\r\n                q.push(edges[id].u);\r\n            }\r\n        }\r\n        return level[t] != -1;\r\n    }\r\n\r\n    ll dfs(int v, ll pushed) {\r\n        if (pushed == 0)\r\n            return 0;\r\n        if (v == t)\r\n            return pushed;\r\n        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {\r\n            int id = adj[v][cid];\r\n            int u = edges[id].u;\r\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\r\n                continue;\r\n            ll tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\r\n            if (tr == 0)\r\n                continue;\r\n            edges[id].flow += tr;\r\n            edges[id ^ 1].flow -= tr;\r\n            return tr;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    ll solve() {\r\n        ll f = 0;\r\n        while (true) {\r\n            fill(level.begin(), level.end(), -1);\r\n            level[s] = 0;\r\n            q.push(s);\r\n            if (!bfs())\r\n                break;\r\n            fill(ptr.begin(), ptr.end(), 0);\r\n            while (ll pushed = dfs(s, flow_inf)) {\r\n                f += pushed;\r\n            }\r\n        }\r\n        return f;\r\n    }\r\n};\r\nsigned main() {\r\n    //freopen(\"input.txt\", \"r\", stdin);\r\n    //freopen(\"output.txt\", \"w\", stdout);\r\n    speedthefuckup();\r\n    srand(time(NULL));\r\n    int test = 1;\r\n    //cin >> test;\r\n    rp(cas, test) {\r\n        int n;\r\n        cin >> n;\r\n        vector<pair<pii, int>> v(n);\r\n        rp(i, n) cin >> v[i].x.x >> v[i].x.y, v[i].y = i + 1;\r\n        sort(v.begin(), v.end(), [&](pair<pii, int> a, pair<pii, int> b) {\r\n            if (a.x.x == b.x.x) return a.x.y > b.x.y;\r\n            return a.x.x < b.x.x;\r\n            });\r\n        pii ax = { 0, 0 };\r\n        for (int i = 0; i < n; i++) {\r\n            if (v[i].x.y <= ax.x) {\r\n                cout << v[i].y << ' ' << ax.y << '\\n';\r\n                return 0;\r\n            }\r\n            ax = max(ax, { v[i].x.y, v[i].y });\r\n        }\r\n        cout << -1 << ' ' << -1 << '\\n';\r\n    }\r\n    return 0;\r\n}"
}