{
    "id": 194295886,
    "contestId": 1335,
    "creationTimeSeconds": 1676854001,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1335,
        "index": "E1",
        "name": "Three Blocks Palindrome (easy version)",
        "type": "PROGRAMMING",
        "rating": 1700,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1335,
        "members": [
            {
                "handle": "Eslam_Ahmed"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1586788500
    },
    "programmingLanguage": "Java 17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 217,
    "memoryConsumedBytes": 409600,
    "source": "\r\nimport java.io.*;\r\nimport java.math.BigInteger;\r\nimport java.util.*;\r\n\r\n/**\r\n *\r\n * @author eslam\r\n */\r\npublic class Solution {\r\n\r\n    // Beginning of the solution\r\n    static Reader input = new Reader();\r\n    static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\r\n    static ArrayList<ArrayList<Integer>> powerSet = new ArrayList<>();\r\n    static ArrayList<LinkedList<Integer>> allprem = new ArrayList<>();\r\n    static ArrayList<LinkedList<String>> allprems = new ArrayList<>();\r\n    static ArrayList<Long> luc = new ArrayList<>();\r\n    static long mod = (long) (1e9 + 7);\r\n    static int grid[][] = {{0, 0, 1, -1, 1, 1, -1, -1}, {1, -1, 0, 0, 1, -1, 1, -1}};\r\n    static int dp[][];\r\n    static boolean vis[][];\r\n    static double cmp = 1e-7;\r\n    static final double pi = 3.14159265359;\r\n    static long MO = 998244353;\r\n    // static long mod = 998244353;\r\n    static long seg[], lazy[];\r\n    static boolean ca = false;\r\n\r\n    public static void main(String[] args) throws IOException {\r\n//        Reader input = new Reader(\"lis.in\");\r\n//        BufferedWriter log = new BufferedWriter(new FileWriter(f));\r\n\r\n        int test = input.nextInt();\r\n        loop:\r\n        for (int co = 1; co <= test; co++) {\r\n            int n = input.nextInt();\r\n            int a[] = new int[n];\r\n            int fre[] = new int[27];\r\n             int res = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = input.nextInt();\r\n                fre[a[i]]++;\r\n                res = Math.max(res, fre[a[i]]);\r\n            }\r\n            dp = new int[n][4];\r\n           \r\n            for (int i = 1; i <= 26; i++) {\r\n                for (int j = 1; j <= 26; j++) {\r\n                    for (int k = 0; k < n; k++) {\r\n                        Arrays.fill(dp[k], -1);\r\n                    }\r\n                    res = Math.max(res, solve(0, 0, i, j, a));\r\n                }\r\n            }\r\n            log.write(res + \"\\n\");\r\n        }\r\n        log.flush();\r\n    }\r\n\r\n    static int solve(int idx, int state, int i, int j, int a[]) {\r\n        if (idx == a.length) {\r\n            if (state == 3) {\r\n                return 0;\r\n            } else {\r\n                return (int) -1e8;\r\n            }\r\n        }\r\n        if (dp[idx][state] == -1) {\r\n            dp[idx][state] = solve(idx + 1, state, i, j, a);\r\n            if (state == 0 && a[idx] == i) {\r\n                dp[idx][state] = Math.max(dp[idx][state], 1 + solve(idx + 1, state, i, j, a));\r\n                dp[idx][state] = Math.max(dp[idx][state], 1 + solve(idx + 1, 1, i, j, a));\r\n            } else if (state == 1 && a[idx] == j) {\r\n                dp[idx][state] = Math.max(dp[idx][state], 1 + solve(idx + 1, state, i, j, a));\r\n                dp[idx][state] = Math.max(dp[idx][state], 1 + solve(idx + 1, 2, i, j, a));\r\n            } else if ((state == 2||state==3 )&& a[idx] == i) {\r\n                dp[idx][state] = Math.max(dp[idx][state], 1 + solve(idx + 1, 3, i, j, a));\r\n            }\r\n        }\r\n        return dp[idx][state];\r\n    }\r\n\r\n    static void build(int idx, int s, int e, long a[]) {\r\n        if (s == e) {\r\n            seg[idx] = a[s];\r\n            return;\r\n        }\r\n        build(idx * 2, s, (s + e) / 2, a);\r\n        build(idx * 2 + 1, (s + e) / 2 + 1, e, a);\r\n        seg[idx] = seg[idx * 2] + seg[idx * 2 + 1];\r\n\r\n    }\r\n\r\n    static void process(int idx, int s, int e) {\r\n        if (lazy[idx] % 2 == 1) {\r\n            seg[idx] = (e - s + 1) - (seg[idx]);\r\n        }\r\n        if (s < e) {\r\n            lazy[idx * 2] += lazy[idx];\r\n            lazy[idx * 2 + 1] += lazy[idx];\r\n        }\r\n        lazy[idx] = 0;\r\n    }\r\n\r\n    static void updateRange(int idx, int s, int e, int l, int r, long val) {\r\n        process(idx, s, e);\r\n        if ((l > e) || s > r) {\r\n            return;\r\n        }\r\n        if (s >= l && e <= r) {\r\n            lazy[idx] += val;\r\n            process(idx, s, e);\r\n            return;\r\n        }\r\n        updateRange(idx * 2, s, (s + e) / 2, l, r, val);\r\n        updateRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r, val);\r\n        seg[idx] = (seg[idx * 2] + seg[idx * 2 + 1]);\r\n    }\r\n\r\n    static long sumInRange(int idx, int s, int e, int l, int r) {\r\n        process(idx, s, e);\r\n        if ((l > e) || s > r) {\r\n            return 0;\r\n        }\r\n        if (s >= l && e <= r) {\r\n            return seg[idx];\r\n        }\r\n        return (sumInRange(idx * 2, s, (s + e) / 2, l, r) + sumInRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r));\r\n    }\r\n\r\n    public static boolean isPalindrome(String w) {\r\n        for (int i = 0; i < w.length() / 2; i++) {\r\n            if (w.charAt(i) != w.charAt(w.length() - i - 1)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static long mod(long a, long b) {\r\n        long r = a % b;\r\n        return r < 0 ? r + b : r;\r\n    }\r\n\r\n    static long fast_pow(long a, long p, long mod) {\r\n        long res = 1;\r\n        while (p > 0) {\r\n            if (p % 2 == 0) {\r\n                a = (a * a) % mod;\r\n                p /= 2;\r\n            } else {\r\n                res = (res * a) % mod;\r\n                p--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static Comparator<pair> cmpPair() {\r\n        Comparator<pair> c = new Comparator<pair>() {\r\n            @Override\r\n            public int compare(pair o1, pair o2) {\r\n                if (o1.x > o2.x) {\r\n                    return 1;\r\n                } else if (o1.x < o2.x) {\r\n                    return -1;\r\n                } else {\r\n                    if (o1.y > o2.y) {\r\n                        return 1;\r\n                    } else if (o1.y < o2.y) {\r\n                        return -1;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return c;\r\n\r\n    }\r\n\r\n    public static boolean isValid(int i, int j, int n, int m) {\r\n        return (i > -1 && i < n) && (j > -1 && j < m);\r\n\r\n    }\r\n\r\n    static class pair {\r\n\r\n        int x;\r\n        int y;\r\n\r\n        public pair(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return x + \" \" + y;\r\n        }\r\n    }\r\n\r\n    static class tri {\r\n\r\n        int x, y;\r\n        int z;\r\n\r\n        public tri(int x, int y, int z) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return x + \" \" + y + \" \" + z;\r\n        }\r\n    }\r\n\r\n//    public static pair[] dijkstra(int node, ArrayList<pair> a[]) {\r\n//        PriorityQueue<tri> q = new PriorityQueue<>(new Comparator<tri>() {\r\n//            @Override\r\n//            public int compare(tri o1, tri o2) {\r\n//                if (o1.y > o2.y) {\r\n//                    return 1;\r\n//                } else if (o1.y < o2.y) {\r\n//                    return -1;\r\n//                } else {\r\n//                    return 0;\r\n//                }\r\n//            }\r\n//        });\r\n//        q.add(new tri(node, 0, -1));\r\n//        pair distance[] = new pair[a.length];\r\n//        while (!q.isEmpty()) {\r\n//            tri p = q.poll();\r\n//            int cost = p.y;\r\n//            if (distance[p.x] != null) {\r\n//                continue;\r\n//            }\r\n//            distance[p.x] = new pair(p.z, cost);\r\n//            ArrayList<pair> nodes = a[p.x];\r\n//            for (pair node1 : nodes) {\r\n//                if (distance[node1.x] == null) {\r\n//                    tri pa = new tri(node1.x, cost + node1.y, p.x);\r\n//                    q.add(pa);\r\n//                }\r\n//            }\r\n//        }\r\n//        return distance;\r\n//    }\r\n    public static int countPrimeInRange(int n, boolean isPrime[]) {\r\n        int cnt = 0;\r\n        Arrays.fill(isPrime, true);\r\n        isPrime[0] = false;\r\n        isPrime[1] = false;\r\n        for (int i = 2; i * i <= n; i++) {\r\n            if (isPrime[i]) {\r\n                for (int j = i * 2; j <= n; j += i) {\r\n                    isPrime[j] = false;\r\n                }\r\n            }\r\n        }\r\n        for (int i = 2; i <= n; i++) {\r\n            if (isPrime[i]) {\r\n                cnt++;\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    static pai absSub(pai a, pai b) {\r\n        doWork(a, b);\r\n        pai c = new pai(Math.abs(a.x - b.x), a.y);\r\n        simplifyFraction(b);\r\n        return c;\r\n    }\r\n\r\n    static int compare(pai a, pai b) {\r\n        doWork(a, b);\r\n        if (a.x < b.x) {\r\n            return -1;\r\n        } else {\r\n            return (int) Math.min(1, a.x - b.x);\r\n        }\r\n    }\r\n\r\n    static void doWork(pai a, pai b) {\r\n        simplifyFraction(a);\r\n        simplifyFraction(b);\r\n        long c = a.y;\r\n        a.y *= b.y;\r\n        a.x *= b.y;\r\n        b.y *= c;\r\n        b.x *= c;\r\n    }\r\n\r\n    static void simplifyFraction(pai b) {\r\n        long g = GCD(b.x, b.y);\r\n        b.x /= g;\r\n        b.y /= g;\r\n\r\n    }\r\n\r\n    public static boolean isSortedInc(long[] a, int l, int r) {\r\n        for (int i = l; i <= r; i++) {\r\n            if (a[i] > a[i + 1]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isSortedDec(long[] a, int l, int r) {\r\n        for (int i = l; i <= r; i++) {\r\n            if (a[i] < a[i + 1]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static long f(long x) {\r\n        return (long) ((x * (x + 1) / 2) % mod);\r\n    }\r\n\r\n    static long Sub(long x, long y) {\r\n        long z = x - y;\r\n        if (z < 0) {\r\n            z += mod;\r\n        }\r\n        return z;\r\n    }\r\n\r\n    static long add(long a, long b) {\r\n        a += b;\r\n        if (a >= mod) {\r\n            a -= mod;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    static long mul(long a, long b) {\r\n        return (long) ((long) a * b % mod);\r\n    }\r\n\r\n    static long modinv(long x) {\r\n        return fast_pow(x, mod - 2, mod);\r\n    }\r\n\r\n    static long Div(long x, long y) {\r\n        return mul(x, modinv(y));\r\n    }\r\n\r\n    static void floodFill(int r, int c, int a[][], boolean vi[][], int w[][], int d) {\r\n        vi[r][c] = true;\r\n        for (int i = 0; i < 4; i++) {\r\n            int nr = grid[0][i] + r;\r\n            int nc = grid[1][i] + c;\r\n            if (isValid(nr, nc, a.length, a[0].length)) {\r\n                if (Math.abs(a[r][c] - a[nr][nc]) <= d && !vi[nr][nc]) {\r\n                    floodFill(nr, nc, a, vi, w, d);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static boolean isdigit(char ch) {\r\n        return ch >= '0' && ch <= '9';\r\n    }\r\n\r\n    static boolean lochar(char ch) {\r\n        return ch >= 'a' && ch <= 'z';\r\n    }\r\n\r\n    static boolean cachar(char ch) {\r\n        return ch >= 'A' && ch <= 'Z';\r\n\r\n    }\r\n\r\n    static class Pa {\r\n\r\n        long x;\r\n        long y;\r\n\r\n        public Pa(long x, long y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n    }\r\n\r\n    static long sqrt(long v) {\r\n        long max = (long) 4e9;\r\n        long min = 0;\r\n        long ans = 0;\r\n        while (max >= min) {\r\n            long mid = (max + min) / 2;\r\n            if (mid * mid > v) {\r\n                max = mid - 1;\r\n            } else {\r\n                ans = mid;\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static long cbrt(long v) {\r\n        long max = (long) 3e6;\r\n        long min = 0;\r\n        long ans = 0;\r\n        while (max >= min) {\r\n            long mid = (max + min) / 2;\r\n            if (mid * mid > v) {\r\n                max = mid - 1;\r\n            } else {\r\n                ans = mid;\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static void prefixSum2D(long arr[][]) {\r\n        for (int i = 0; i < arr.length; i++) {\r\n            prefixSum(arr[i]);\r\n        }\r\n        for (int i = 0; i < arr[0].length; i++) {\r\n            for (int j = 1; j < arr.length; j++) {\r\n                arr[j][i] += arr[j - 1][i];\r\n            }\r\n        }\r\n    }\r\n\r\n    public static long baseToDecimal(String w, long base) {\r\n        long r = 0;\r\n        long l = 0;\r\n        for (int i = w.length() - 1; i > -1; i--) {\r\n            long x = (w.charAt(i) - '0') * (long) Math.pow(base, l);\r\n            r = r + x;\r\n            l++;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    static int bs(int v, ArrayList<Integer> a) {\r\n        int max = a.size() - 1;\r\n        int min = 0;\r\n        int ans = 0;\r\n        while (max >= min) {\r\n            int mid = (max + min) / 2;\r\n            if (a.get(mid) >= v) {\r\n                ans = a.size() - mid;\r\n                max = mid - 1;\r\n            } else {\r\n                min = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    static Comparator<tri> cmpTri() {\r\n        Comparator<tri> c = new Comparator<tri>() {\r\n            @Override\r\n            public int compare(tri o1, tri o2) {\r\n                if (o1.x > o2.x) {\r\n                    return 1;\r\n                } else if (o1.x < o2.x) {\r\n                    return -1;\r\n                } else {\r\n                    if (o1.y > o2.y) {\r\n                        return 1;\r\n                    } else if (o1.y < o2.y) {\r\n                        return -1;\r\n                    } else {\r\n                        if (o1.z > o2.z) {\r\n                            return 1;\r\n                        } else if (o1.z < o2.z) {\r\n                            return -1;\r\n                        } else {\r\n                            return 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return c;\r\n    }\r\n\r\n    static Comparator<pair> cmpPair2() {\r\n        Comparator<pair> c = new Comparator<pair>() {\r\n            @Override\r\n            public int compare(pair o1, pair o2) {\r\n                if (o1.y > o2.y) {\r\n                    return 1;\r\n                } else if (o1.y < o2.y) {\r\n                    return -1;\r\n                } else {\r\n                    if (o1.x > o2.x) {\r\n                        return -1;\r\n                    } else if (o1.x < o2.x) {\r\n                        return 1;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return c;\r\n\r\n    }\r\n\r\n    static class rec {\r\n\r\n        long x1;\r\n        long x2;\r\n        long y1;\r\n        long y2;\r\n\r\n        public rec(long x1, long y1, long x2, long y2) {\r\n            this.x1 = x1;\r\n            this.y1 = y1;\r\n            this.x2 = x2;\r\n            this.y2 = y2;\r\n        }\r\n\r\n        public long getArea() {\r\n            return (x2 - x1) * (y2 - y1);\r\n        }\r\n    }\r\n\r\n    static long sumOfRange(int x1, int y1, int x2, int y2, long a[][]) {\r\n        return (a[x2][y2] - a[x1 - 1][y2] - a[x2][y1 - 1]) + a[x1 - 1][y1 - 1];\r\n    }\r\n\r\n//    public static int[][] bfs(int i, int j, String w[]) {\r\n//        Queue<pair> q = new ArrayDeque<>();\r\n//        q.add(new pair(i, j));\r\n//        int dis[][] = new int[w.length][w[0].length()];\r\n//        for (int k = 0; k < w.length; k++) {\r\n//            Arrays.fill(dis[k], -1);\r\n//        }\r\n//        dis[i][j] = 0;\r\n//        while (!q.isEmpty()) {\r\n//            pair p = q.poll();\r\n//            int cost = dis[p.x][p.y];\r\n//            for (int k = 0; k < 4; k++) {\r\n//                int nx = p.x + grid[0][k];\r\n//                int ny = p.y + grid[1][k];\r\n//                if (isValid(nx, ny, w.length, w[0].length())) {\r\n//                    if (dis[nx][ny] == -1 && w[nx].charAt(ny) == '.') {\r\n//                        q.add(new pair(nx, ny));\r\n//                        dis[nx][ny] = cost + 1;\r\n//                    }\r\n//                }\r\n//            }\r\n//        }\r\n//        return dis;\r\n//    }\r\n    public static void graphRepresintion(ArrayList<Integer>[] a, int q) throws IOException {\r\n        for (int i = 0; i < a.length; i++) {\r\n            a[i] = new ArrayList<>();\r\n        }\r\n        while (q-- > 0) {\r\n            int x = input.nextInt();\r\n            int y = input.nextInt();\r\n            a[x].add(y);\r\n            a[y].add(x);\r\n        }\r\n    }\r\n\r\n    // present in the left and right indices\r\n    public static int[] swap(int data[], int left, int right) {\r\n\r\n        // Swap the data\r\n        int temp = data[left];\r\n        data[left] = data[right];\r\n        data[right] = temp;\r\n\r\n        // Return the updated array\r\n        return data;\r\n    }\r\n\r\n    // Function to reverse the sub-array\r\n    // starting from left to the right\r\n    // both inclusive\r\n    public static int[] reverse(int data[], int left, int right) {\r\n\r\n        // Reverse the sub-array\r\n        while (left < right) {\r\n            int temp = data[left];\r\n            data[left++] = data[right];\r\n            data[right--] = temp;\r\n        }\r\n\r\n        // Return the updated array\r\n        return data;\r\n    }\r\n\r\n    // Function to find the next permutation\r\n    // of the given integer array\r\n    public static boolean findNextPermutation(int data[]) {\r\n\r\n        // If the given dataset is empty\r\n        // or contains only one element\r\n        // next_permutation is not possible\r\n        if (data.length <= 1) {\r\n            return false;\r\n        }\r\n\r\n        int last = data.length - 2;\r\n\r\n        // find the longest non-increasing suffix\r\n        // and find the pivot\r\n        while (last >= 0) {\r\n            if (data[last] < data[last + 1]) {\r\n                break;\r\n            }\r\n            last--;\r\n        }\r\n\r\n        // If there is no increasing pair\r\n        // there is no higher order permutation\r\n        if (last < 0) {\r\n            return false;\r\n        }\r\n\r\n        int nextGreater = data.length - 1;\r\n\r\n        // Find the rightmost successor to the pivot\r\n        for (int i = data.length - 1; i > last; i--) {\r\n            if (data[i] > data[last]) {\r\n                nextGreater = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Swap the successor and the pivot\r\n        data = swap(data, nextGreater, last);\r\n\r\n        // Reverse the suffix\r\n        data = reverse(data, last + 1, data.length - 1);\r\n\r\n        // Return true as the next_permutation is done\r\n        return true;\r\n    }\r\n\r\n    public static String revs(String w) {\r\n        String ans = \"\";\r\n        for (int i = w.length() - 1; i > -1; i--) {\r\n            ans += w.charAt(i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static void getPowerSet(Queue<Integer> a) {\r\n        int n = a.poll();\r\n        if (!a.isEmpty()) {\r\n            getPowerSet(a);\r\n        }\r\n        int s = powerSet.size();\r\n        for (int i = 0; i < s; i++) {\r\n            ArrayList<Integer> ne = new ArrayList<>();\r\n            ne.add(n);\r\n            for (int j = 0; j < powerSet.get(i).size(); j++) {\r\n                ne.add(powerSet.get(i).get(j));\r\n            }\r\n\r\n            powerSet.add(ne);\r\n        }\r\n        ArrayList<Integer> p = new ArrayList<>();\r\n        p.add(n);\r\n        powerSet.add(p);\r\n    }\r\n\r\n    public static long ceil(long a, long b) {\r\n        return (a + b - 1) / b;\r\n    }\r\n\r\n    public static long round(long a, long b) {\r\n        if (a < 0) {\r\n            return (a - b / 2) / b;\r\n        }\r\n        return (a + b / 2) / b;\r\n    }\r\n\r\n    public static void allPremutationsst(LinkedList<String> l, boolean visited[], ArrayList<String> st) {\r\n        if (l.size() == st.size()) {\r\n            allprems.add(l);\r\n        }\r\n        for (int i = 0; i < st.size(); i++) {\r\n            if (!visited[i]) {\r\n                visited[i] = true;\r\n                LinkedList<String> nl = new LinkedList<>();\r\n                for (String x : l) {\r\n                    nl.add(x);\r\n                }\r\n                nl.add(st.get(i));\r\n                allPremutationsst(nl, visited, st);\r\n                visited[i] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void allPremutations(LinkedList<Integer> l, boolean visited[], int a[]) {\r\n        if (l.size() == a.length) {\r\n            allprem.add(l);\r\n        }\r\n        for (int i = 0; i < a.length; i++) {\r\n            if (!visited[i]) {\r\n                visited[i] = true;\r\n                LinkedList<Integer> nl = new LinkedList<>();\r\n                for (Integer x : l) {\r\n                    nl.add(x);\r\n                }\r\n                nl.add(a[i]);\r\n                allPremutations(nl, visited, a);\r\n                visited[i] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static int binarySearch(long[] a, long value) {\r\n        int l = 0;\r\n        int r = a.length - 1;\r\n        while (l <= r) {\r\n            int m = (l + r) / 2;\r\n            if (a[m] == value) {\r\n                return m;\r\n            } else if (a[m] > value) {\r\n                r = m - 1;\r\n            } else {\r\n                l = m + 1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public static void reverse(int l, int r, char ch[]) {\r\n        for (int i = 0; i < r / 2; i++) {\r\n            char c = ch[i];\r\n            ch[i] = ch[r - i - 1];\r\n            ch[r - i - 1] = c;\r\n        }\r\n    }\r\n\r\n    public static long logK(long v, long k) {\r\n        long ans = 0;\r\n        while (v > 1) {\r\n            ans++;\r\n            v /= k;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static long power(long a, long p) {\r\n        long res = 1;\r\n        while (p > 0) {\r\n            if (p % 2 == 0) {\r\n                a = (a * a);\r\n                p /= 2;\r\n            } else {\r\n                res = (res * a);\r\n                p--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public static int log2(double n) {\r\n        int cnt = 0;\r\n        while (n > 1) {\r\n            n /= 2;\r\n            cnt++;\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    public static int[] bfs(int node, ArrayList<Integer> a[]) {\r\n        Queue<Integer> q = new LinkedList<>();\r\n        q.add(node);\r\n        int distances[] = new int[a.length];\r\n        Arrays.fill(distances, -1);\r\n        distances[node] = 0;\r\n        while (!q.isEmpty()) {\r\n            int parent = q.poll();\r\n            ArrayList<Integer> nodes = a[parent];\r\n            int cost = distances[parent];\r\n            for (Integer node1 : nodes) {\r\n                if (distances[node1] == -1) {\r\n                    q.add(node1);\r\n                    distances[node1] = cost + 1;\r\n                }\r\n            }\r\n        }\r\n        return distances;\r\n    }\r\n\r\n    public static void primeFactors(int n, HashMap<Integer, ArrayList<Integer>> h, int ind) {\r\n        boolean ca = true;\r\n        while (n % 2 == 0) {\r\n            if (ca) {\r\n                if (h.get(2) == null) {\r\n                    h.put(2, new ArrayList<>());\r\n                }\r\n                h.get(2).add(ind);\r\n                ca = false;\r\n            }\r\n            n /= 2;\r\n        }\r\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\r\n            ca = true;\r\n            while (n % i == 0) {\r\n                if (ca) {\r\n                    if (h.get(i) == null) {\r\n                        h.put(i, new ArrayList<>());\r\n                    }\r\n                    h.get(i).add(ind);\r\n                    ca = false;\r\n                }\r\n                n /= i;\r\n            }\r\n            if (n < i) {\r\n                break;\r\n            }\r\n        }\r\n        if (n > 2) {\r\n            if (h.get(n) == null) {\r\n                h.put(n, new ArrayList<>());\r\n            }\r\n            h.get(n).add(ind);\r\n\r\n        }\r\n\r\n    }\r\n\r\n// end of solution\r\n    public static BigInteger ff(long n) {\r\n        if (n <= 1) {\r\n            return BigInteger.ONE;\r\n        }\r\n        long t = n - 1;\r\n        BigInteger b = new BigInteger(t + \"\");\r\n        BigInteger ans = new BigInteger(n + \"\");\r\n        while (t > 1) {\r\n            ans = ans.multiply(b);\r\n            b = b.subtract(BigInteger.ONE);\r\n            t--;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static long factorial(long n) {\r\n        if (n <= 1) {\r\n            return 1;\r\n        }\r\n        long t = n - 1;\r\n        while (t > 1) {\r\n            n = mod((mod(n, mod) * mod(t, mod)), mod);\r\n            t--;\r\n        }\r\n        return n;\r\n    }\r\n\r\n    public static long rev(long n) {\r\n        long t = n;\r\n        long ans = 0;\r\n        while (t > 0) {\r\n            ans = ans * 10 + t % 10;\r\n            t /= 10;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public static boolean isPalindrome(int n) {\r\n        int t = n;\r\n        int ans = 0;\r\n        while (t > 0) {\r\n            ans = ans * 10 + t % 10;\r\n            t /= 10;\r\n        }\r\n        return ans == n;\r\n\r\n    }\r\n\r\n    static boolean isPrime(long num) {\r\n        if (num == 1) {\r\n            return false;\r\n        }\r\n        if (num == 2) {\r\n            return true;\r\n        }\r\n        if (num % 2 == 0) {\r\n            return false;\r\n        }\r\n        if (num == 3) {\r\n            return true;\r\n        }\r\n        for (long i = 3; i * i <= num; i += 2) {\r\n            if (num % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static void prefixSum(long[] a) {\r\n        for (int i = 1; i < a.length; i++) {\r\n            a[i] = a[i] + a[i - 1];\r\n        }\r\n    }\r\n\r\n    public static void suffixSum(long[] a) {\r\n        for (int i = a.length - 2; i > -1; i--) {\r\n            a[i] = a[i] + a[i + 1];\r\n        }\r\n    }\r\n\r\n    public static long binaryToDecimal(String w) {\r\n        long r = 0;\r\n        long l = 0;\r\n        for (int i = w.length() - 1; i > -1; i--) {\r\n            long x = (w.charAt(i) - '0') * (long) Math.pow(2, l);\r\n            r = r + x;\r\n            l++;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    public static String decimalToBinary(long n) {\r\n        String w = \"\";\r\n        while (n > 0) {\r\n            w = n % 2 + w;\r\n            n /= 2;\r\n        }\r\n        return w;\r\n    }\r\n\r\n    public static void print(int[] a) throws IOException {\r\n        for (int i = 0; i < a.length; i++) {\r\n            log.write(a[i] + \" \");\r\n        }\r\n        log.write(\"\\n\");\r\n    }\r\n\r\n    public static void read(int[] a) {\r\n        for (int i = 0; i < a.length; i++) {\r\n            a[i] = input.nextInt();\r\n\r\n        }\r\n    }\r\n\r\n    static class pai {\r\n\r\n        long x;\r\n        long y;\r\n\r\n        public pai(long x, long y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return x + \" \" + y;\r\n        }\r\n    }\r\n\r\n    public static long LCM(long x, long y) {\r\n        return x / GCD(x, y) * y;\r\n    }\r\n\r\n    public static long GCD(long x, long y) {\r\n        if (y == 0) {\r\n            return x;\r\n        }\r\n        return GCD(y, x % y);\r\n    }\r\n\r\n    public static void simplifyTheFraction(int a, int b) {\r\n        long GCD = GCD(a, b);\r\n        System.out.println(a / GCD + \" \" + b / GCD);\r\n\r\n    }\r\n\r\n    static class Reader extends PrintWriter {\r\n\r\n        private BufferedReader r;\r\n        private StringTokenizer st;\r\n        // standard input\r\n\r\n        public Reader() {\r\n            this(System.in, System.out);\r\n        }\r\n\r\n        public Reader(InputStream i, OutputStream o) {\r\n            super(o);\r\n            r = new BufferedReader(new InputStreamReader(i));\r\n        }\r\n        // USACO-style file input\r\n\r\n        public Reader(String problemName) throws IOException {\r\n            super(problemName + \".out\");\r\n            r = new BufferedReader(new FileReader(problemName));\r\n        }\r\n\r\n        // returns null if no more input\r\n        String nextLine() {\r\n            String str = \"\";\r\n            try {\r\n                str = r.readLine();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n\r\n        public String next() {\r\n            try {\r\n                while (st == null || !st.hasMoreTokens()) {\r\n                    st = new StringTokenizer(r.readLine());\r\n                }\r\n                return st.nextToken();\r\n            } catch (Exception e) {\r\n            }\r\n            return null;\r\n        }\r\n\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        public long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n}\r\n"
}