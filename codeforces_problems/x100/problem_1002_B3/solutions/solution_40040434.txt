{
    "id": 40040434,
    "contestId": 1002,
    "creationTimeSeconds": 1530900892,
    "relativeTimeSeconds": 8092,
    "problem": {
        "contestId": 1002,
        "index": "B3",
        "name": "Distinguish four 2-qubit states",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": []
    },
    "author": {
        "contestId": 1002,
        "members": [
            {
                "handle": "OgieKako"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "startTimeSeconds": 1530892800
    },
    "programmingLanguage": "Q#",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 280,
    "memoryConsumedBytes": 0,
    "source": "namespace Solution\r\n{\r\n    open Microsoft.Quantum.Canon;\r\n    open Microsoft.Quantum.Primitive;\r\n    open Microsoft.Quantum.Extensions.Diagnostics;\r\n    open Microsoft.Quantum.Extensions.Testing;\r\n\r\n    operation SolveB (qs : Qubit[], index : Int) : ()\r\n    {\r\n        body\r\n        {\r\n            if (index % 2 == 1) {\r\n                Set(One, qs[0]);\r\n            }\r\n            if (index / 2 == 1) {\r\n                Set(One, qs[1]);\r\n            }\r\n            H(qs[0]);\r\n            CNOT(qs[0], qs[1]);\r\n        }\r\n    }\r\n    operation SolveC (qs : Qubit[]) : ()\r\n    {\r\n        body\r\n        {\r\n            H(qs[0]);\r\n            for(i in 1..Length(qs) - 1) {\r\n                CNOT(qs[i-1], qs[i]);\r\n            }\r\n        }\r\n    }   \r\n    operation SolveD (q : Qubit) : Int\r\n    {\r\n        body\r\n        {\r\n            H(q);\r\n            if(M(q) == Zero) {\r\n                return 1;\r\n            } else {\r\n                return -1;\r\n            }\r\n        }\r\n    }\r\n    operation SolveE (qs : Qubit[]) : Int\r\n    {\r\n        body\r\n        {\r\n            CNOT(qs[0], qs[1]);\r\n            H(qs[0]);\r\n            mutable res = 0;\r\n            if (M(qs[0]) == One) {\r\n               set res = res + 1;\r\n            }\r\n            if (M(qs[1]) == One) {\r\n                set res = res + 2;\r\n            }\r\n            return res;\r\n        }\r\n    }    \r\n    operation SolveF (qs : Qubit[], bits0 : Bool[], bits1 : Bool[]) : Int\r\n    {\r\n        body\r\n        {\r\n            for(i in 0..Length(qs)-1) {\r\n                if ((M(qs[i]) == One) != bits0[i]) {\r\n                    return 1;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n    }    \r\n    operation SolveG (x : Qubit[], y : Qubit, k : Int) : ()\r\n    {\r\n        body\r\n        {\r\n            CNOT(x[k], y);\r\n        }\r\n    }\r\n    operation SolveH (x : Qubit[], y : Qubit) : ()\r\n    {\r\n        body\r\n        {\r\n            for(i in 0..Length(x)-1) {\r\n                CNOT(x[i], y);\r\n            }\r\n        }\r\n    }    \r\n    operation SolveA1 (qs : Qubit[]) : ()\r\n    {\r\n        body\r\n        {\r\n            for(i in 0..Length(qs)-1) {\r\n                H(qs[i]);\r\n            }\r\n        }\r\n    }\r\n    operation SolveA2 (qs : Qubit[], bits : Bool[]) : ()\r\n    {\r\n        body\r\n        {\r\n            mutable prev = -1;\r\n            for(i in 0..Length(qs)-1) {\r\n                if (bits[i]) {\r\n                    if (prev < 0) {\r\n                        H(qs[i]);\r\n                    } else {\r\n                        CNOT(qs[prev], qs[i]);\r\n                    }\r\n                    set prev = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    operation SolveA3 (qs : Qubit[], bits0 : Bool[], bits1: Bool[]) : ()\r\n    {\r\n        body\r\n        {\r\n            mutable bits = new Bool[Length(bits1)];\r\n            for (i in 0..Length(bits1)-1) {\r\n                if (bits0[i] != bits1[i]) {\r\n                    set bits[i] = true;\r\n                }\r\n            }\r\n            SolveA2(qs, bits);\r\n            for (i in 0..Length(bits0)-1) {\r\n                if (bits0[i]) {\r\n                    X(qs[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    operation SolveA4 (qs : Qubit[]) : ()\r\n    {\r\n        body\r\n        {\r\n            mutable k = -1;\r\n            mutable N = 1;\r\n            for (i in 0..4) {\r\n                if (N == Length(qs)) {\r\n                    if (k == -1) {\r\n                        set k = i;\r\n                    }\r\n                } else {\r\n                    set N = N * 2;\r\n                }\r\n            }\r\n            if (k == 0) {\r\n                X(qs[0]);\r\n            } else {\r\n                AssertBoolEqual(k > 0, true, \"!?\");\r\n                using (ps = Qubit[k]) {    \r\n                    SolveA1(ps);        \r\n                    for (i in 0..N-1) {\r\n                        for (j in 0..k-1) {\r\n                            let jj = 2 ^ (j);\r\n                            if ((i &&& jj) > 0) {\r\n                                X(ps[j]);\r\n                            }\r\n                        }\r\n                        (Controlled X) (ps, qs[i]);   \r\n                        for (j in 0..k-1) {\r\n                            let jj = 2 ^ (j);\r\n                            if ((i &&& jj) > 0) {\r\n                                X(ps[j]);\r\n                            }\r\n                        }\r\n                    }      \r\n                    SolveA1(ps);          \r\n                    ResetAll(ps);\r\n                }\r\n            }\r\n        }\r\n    }   \r\n    \r\n    operation SolveB1 (qs : Qubit[]) : Int\r\n    {\r\n        body\r\n        {\r\n            mutable res = 0;\r\n            for (i in 0..Length(qs)-1) {\r\n                if (M(qs[i]) == One) {\r\n                    set res = 1;\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n    operation SolveB2 (qs : Qubit[]) : Int\r\n    {\r\n        body\r\n        {\r\n            mutable count = 0;\r\n            for (i in 0..Length(qs)-1) {\r\n                if (M(qs[i]) == One) {\r\n                    set count = count + 1;\r\n                }\r\n            }\r\n            if (count == 1) {\r\n                return 1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    operation Solve (qs : Qubit[]) : Int\r\n    {\r\n        body\r\n        {\r\n            mutable res = 0;\r\n            for (i in 0..Length(qs) - 1) {\r\n                Z(qs[i]);\r\n                H(qs[i]);\r\n                if (M(qs[i]) == One) {\r\n                    set res = res + (2 ^ i);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n\r\n    operation Set (desired: Result, q1: Qubit) : ()\r\n    {\r\n        body\r\n        {\r\n            let current = M(q1);\r\n            if (desired != current)\r\n            {\r\n                X(q1);\r\n            }\r\n        }\r\n    }\r\n    operation SolveTest () : ()\r\n    {\r\n        // DumpMachine\r\n        body\r\n        {\r\n            using (qs = Qubit[2]) {\r\n                // AssertIntEqual(Solve(qs), 0, \"fail\");\r\n                // for (i in 0..Length(qs)-1) {\r\n                //     X(qs[i]);\r\n                // }\r\n                // AssertIntEqual(Solve(qs), 0, \"fail\");\r\n                // ResetAll(qs);\r\n                // SolveA4(qs);\r\n                // AssertIntEqual(Solve(qs), 1, \"fail\");\r\n\r\n                H(qs[0]); H(qs[1]);\r\n                Z(qs[0]); Z(qs[1]);\r\n                AssertIntEqual(Solve(qs), 0, \"fail\");\r\n\r\n                X(qs[1]);\r\n                H(qs[0]); H(qs[1]);\r\n                Z(qs[0]); Z(qs[1]);\r\n                AssertIntEqual(Solve(qs), 2, \"fail\");\r\n\r\n                ResetAll(qs);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
}