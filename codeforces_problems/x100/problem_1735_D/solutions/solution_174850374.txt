{
    "id": 174850374,
    "contestId": 1735,
    "creationTimeSeconds": 1665058492,
    "relativeTimeSeconds": 7612,
    "problem": {
        "contestId": 1735,
        "index": "D",
        "name": "Meta-set",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "combinatorics",
            "data structures",
            "hashing",
            "math"
        ]
    },
    "author": {
        "contestId": 1735,
        "members": [
            {
                "handle": "nishu2002"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1665050880
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 54,
    "timeConsumedMillis": 249,
    "memoryConsumedBytes": 512000,
    "source": "#define _USE_MATH_DEFINES\r\n#pragma GCC optimize(\"Ofast\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nconst  int  n1=998244353;\r\n#define miv map<int,vector<int>>\r\n#define ld long double\r\n#define inf 5e18\r\n#define mlv map<ll,vector<ll>>\r\n#define mip map<int,pair<int,int>>\r\n#define mii map<int,int>\r\n#define mll map<ll,ll>\r\n#define umip unordered_map<int,pair<int,int>>\r\n#define umii unordered_map<int,int>\r\n#define vi vector<int>\r\n#define vll vector<ll>\r\n#define vvll vector<vector<ll>>\r\n#define vvi vector<vector<int>>\r\n#define ll long long\r\n#define pii pair<int,int>\r\n#define pll pair<ll,ll>\r\n#define vpii vector<pii>\r\n#define vpll vector<pll>\r\n#define pb push_back\r\n#define f first\r\n#define s second\r\n#define all(x) x.begin(),x.end()\r\n#define pi = 3.1415926535897932384626\r\n#define INF LLONG_MAX\r\n#define yes cout<<\"YES\"<<endl\r\n#define no cout<<\"NO\"<<endl\r\n#define input(a,x,n); for(int i=x;i<n;i++){cin>>a[i];}\r\n#define output(b,x,n);  for(int i=x;i<n;i++){cout<<b[i]<<\" \";}\r\n#define umill unordered_map <int,ll>\r\n#define  pvi pair<vector<int>,int>\r\n#define  piv pair<int,vector<int>>\r\n#define  fst find_first_of\r\n#define lst find_last_of\r\n#define in(i,x,n) for(int i=x;i<n;i++)\r\n#define inl(i,x,n) for(ll i=x;i<n;i++)\r\n#define de(i,x,n) for(int i=n;i>=x;i--)\r\n#define del(i,x,n) for(ll i=n;i>=x;i--)\r\n#define trav(it,m) for(auto it=m.begin();it!=m.end();it++)\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\ntypedef tree<pll, null_type, less<pll>,\r\n            rb_tree_tag, tree_order_statistics_node_update> ordered_set;\r\nstruct compare {\r\n    inline bool operator()(const std::string& first,\r\n            const std::string& second) const\r\n    {\r\n        return first.size() < second.size();\r\n    }\r\n};\r\n\r\nvll factorial(ll n)\r\n{\r\n    vll fct(n+1);\r\n    fct[0]=1;\r\n    fct[1]=1;\r\n    inl(i,2,n+1)\r\n    {\r\n        fct[i]=((fct[i-1%n1])*(i%n1))%n1;\r\n    }\r\n    return fct;\r\n}\r\nvll factorial(ll n,ll m)\r\n{\r\n    vll fct(n+1);\r\n    fct[0]=1;\r\n    fct[1]=1;\r\n    inl(i,2,n+1)\r\n    {\r\n        fct[i]=((fct[i-1]%m)*(i%m))%m;\r\n    }\r\n    return fct;\r\n}\r\n\r\n long long power(long long x,ll y)\r\n{\r\n    long long res = 1;\r\n     ll p=n1;\r\n    x = x % p;\r\n\r\n\r\n    while (y > 0)\r\n    {\r\n\r\n\r\n        if (y & 1)\r\n            res = ((res%p) * (x%p)) % p;\r\n\r\n\r\n        y = y >> 1;\r\n        x = ((x%p) * (x%p)) % p;\r\n    }\r\n    return res;\r\n}\r\nlong long modInverse(long long n)\r\n{\r\n    return power(n, n1 - 2);\r\n}\r\nvector<bool> SieveOfEratosthenes(ll n){\r\nvector<bool> prime(n + 1, 1); for (ll p = 2; p * p <= n; p++)\r\nif (prime[p] == true) for (ll i = p * p; i <= n; i += p)\r\nprime[i] = false; return prime;}\r\n\r\nll ncr(ll n,ll r,vll &fct)\r\n{\r\n\r\n    return 1ll*(((((fct[n]%n1)*(modInverse(fct[r])%n1))%n1)*(modInverse(fct[n-r])%n1))%n1);\r\n\r\n}\r\n\r\n\r\n\r\n//   char a[400][400];\r\n\r\n ll cnt(int r1,int r2,int c1,int c2,vvll &pre)\r\n {\r\n      ll cnt=0;\r\n      if(r1>0&&c1>0)\r\n      {\r\n          cnt=pre[r2][c2]-pre[r2][c1-1]-pre[r1-1][c2]+pre[r1-1][c1-1];\r\n      }\r\n      else if(r1>0)\r\n      {\r\n          cnt=pre[r2][c2]-pre[r1-1][c2];\r\n      }\r\n      else if(c1>0)\r\n      {\r\n          cnt=pre[r2][c2]-pre[r2][c1-1];\r\n      }\r\n      else\r\n      {\r\n          cnt=pre[r2][c2];\r\n      }\r\n      return cnt;\r\n\r\n }\r\n //ll dp[500][500];\r\nll ans1;\r\nvoid dfs1(ordered_set &st,vll &sa,vll &sb,vll &vis,ll node,vvll &adj,vll &r)\r\n{\r\n    st.insert({sb[node],node});\r\n    vis[node]=1;\r\n    int val=sa[node]+1;\r\n    r[node]=st.order_of_key({val,-1});\r\n    /*cout<<node<<endl;\r\n    trav(it,st)\r\n    {\r\n        cout<<(*it)<<\" \";\r\n    }\r\n    cout<<endl;*/\r\n\r\n    for(auto&i:adj[node])\r\n    {\r\n        if(!vis[i])\r\n        {\r\n            dfs1(st,sa,sb,vis,i,adj,r);\r\n        }\r\n\r\n    }\r\n    st.erase(st.find({sb[node],node}));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\nll dfs(vvll &adj, ll node,ll m,ll &val,ll p)\r\n{\r\n    ll sz=1;\r\n    for(auto &i:adj[node])\r\n    {\r\n        if(i!=p)\r\n        {\r\n           sz=max( dfs(adj,i,m,val,node)+1,sz);\r\n        }\r\n    }\r\n    if(sz==m and p!=1 and node!=1)\r\n    {\r\n        val++;\r\n        return 0;\r\n    }\r\n    return sz;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\nvoid build(ll l,ll r,vll &a,vll &seg,ll idx)\r\n{\r\n    if(l==r)\r\n    {\r\n        seg[idx]=a[l];\r\n        return;\r\n    }\r\n\r\n    ll mid=(l+r)/2;\r\n    build(l,mid,a,seg,2*idx+1);\r\n     build(mid+1,r,a,seg,2*idx+2);\r\n     seg[idx]=min(seg[2*idx+1],seg[2*idx+2]);\r\n     return ;\r\n}\r\nvoid build1(ll l,ll r,vll &a,vll &seg,ll idx)\r\n{\r\n    if(l==r)\r\n    {\r\n        seg[idx]=a[l];\r\n        return;\r\n    }\r\n    ll mid=(l+r)/2;\r\n    build1(l,mid,a,seg,2*idx+1);\r\n     build1(mid+1,r,a,seg,2*idx+2);\r\n     seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\r\n     return ;\r\n}\r\nll query1(ll l,ll r,ll low,ll high,ll idx,vll &seg)\r\n{\r\n    if(low>=l and high<=r)\r\n    return seg[idx];\r\n    if(low>r or high<l)\r\n        return -1*inf;\r\n    ll mid=(low+high)/2;\r\n    ll x=query1(l,r,low,mid,2*idx+1,seg);\r\n    ll y=query1(l,r,mid+1,high,2*idx+2,seg);\r\n    return max(x,y);\r\n\r\n\r\n}\r\nll query(ll l,ll r,ll low,ll high,ll idx,vll &seg)\r\n{\r\n    if(low>=l and high<=r)\r\n    return seg[idx];\r\n    if(low>r or high<l)\r\n        return inf;\r\n    ll mid=(low+high)/2;\r\n    ll x=query(l,r,low,mid,2*idx+1,seg);\r\n    ll y=query(l,r,mid+1,high,2*idx+2,seg);\r\n    return min(x,y);\r\n\r\n\r\n}\r\nvoid update(ll l,ll r,vll &seg, ll idx,ll val,ll index,mll &st)\r\n{\r\n    if(l==r)\r\n    {\r\n        ll x=seg[idx];\r\n        if(l==0)\r\n        {\r\n            st[x]--;\r\n            if(st[x]<=0)\r\n                st.erase(x);\r\n            seg[idx]-=val;\r\n            st[seg[idx]]++;\r\n\r\n\r\n\r\n        }\r\n        else\r\n        {\r\n            seg[idx]-=val;\r\n\r\n        }\r\n        return;\r\n\r\n    }\r\n    ll mid=(l+r)/2;\r\n    if(index>=l and index<=mid)\r\n    {\r\n        update(l,mid,seg,2*idx+1,val,index,st);\r\n    }\r\n    else\r\n    {\r\n        update(mid+1,r,seg,2*idx+2,val,index,st);\r\n    }\r\n    ll x=seg[idx];\r\n    seg[idx]=min(seg[2*idx+1],seg[2*idx+2]);\r\n    if(l==0)\r\n    {\r\n        st[x]--;\r\n        if(st[x]<=0)\r\n            st.erase(x);\r\n\r\n        st[seg[idx]]++;\r\n\r\n\r\n    }\r\n    return;\r\n\r\n}\r\n vll kmp(string str)\r\n {\r\n     vll v(str.size());\r\n     v[0]=0;\r\n     in(i,1,str.size())\r\n     {\r\n         ll j=v[i-1];\r\n         while(j>0 and str[i]!=str[j])\r\n         {\r\n             j=v[j-1];\r\n         }\r\n         if(str[i]==str[j])\r\n         {\r\n             j++;\r\n         }\r\n         v[i]=j;\r\n     }\r\n     return v;\r\n\r\n }\r\n\r\nvoid fun(vector<int>&A)\r\n{\r\n\r\n    int n=A.size();\r\n   int num1=1e9;\r\n   int num2=1e9;\r\n   int c1=0;\r\n   int c2=0;\r\n   for(int i=0;i<n;i++)\r\n   {\r\n\r\n       if(A[i]==num1)\r\n       {\r\n           c1++;\r\n       }\r\n       else if(A[i]==num2)\r\n       {\r\n           c2++;\r\n       }\r\n       else if(c1==0)\r\n       {\r\n           num1=A[i];\r\n           c1++;\r\n       }\r\n       else if(c2==0)\r\n       {\r\n           num2=A[i];\r\n           c2++;\r\n       }\r\n       else\r\n       {\r\n           c1--;\r\n           c2--;\r\n       }\r\n   }\r\n   c1=0;\r\n   c2=0;\r\n   for(int i=0;i<n;i++)\r\n   {\r\n       if(A[i]==num1)\r\n       {\r\n           c1++;\r\n       }\r\n       if(A[i]==num2)\r\n       {\r\n           c2++;\r\n       }\r\n   }\r\n   cout<<num1<<\" \"<<num2<<endl;\r\n   if(c1>(n/3))\r\n   {\r\n       cout<<num1;\r\n   }\r\n  else if(c2>(n/3))\r\n   {\r\n       cout<<num2;\r\n   }\r\n   else\r\n   {\r\n\r\n       cout<<-1;\r\n   }\r\n   cout<<endl;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*ll spf[10000001];\r\nvoid sieve()\r\n{\r\n    spf[1]=1;\r\n    in(i,2,1e7+1)\r\n    {\r\n        spf[i]=i;\r\n    }\r\n    for(int i=4;i<=1e7+1;i+=2)\r\n    {\r\n        spf[i]=2;\r\n    }\r\n    for(int i=3;i*i<=1e7+1;i++)\r\n    {\r\n        if(spf[i]==i)\r\n        {\r\n            for(int j=i*i;j<=1e7+1;j+=i)\r\n            {\r\n                if(spf[j]==j)\r\n                {\r\n                    spf[j]=i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}*/\r\nbool check(ll mid,vvll &adj,ll n,ll k)\r\n{\r\n    ll val;\r\n    if(mid>1)\r\n    {\r\n        val=0;\r\n        dfs(adj,1,mid,val,0);\r\n    }\r\n    else\r\n    {\r\n        val=n-1-adj[1].size();\r\n    }\r\n    return val<=k;\r\n}\r\nint main()\r\n{\r\nios_base::sync_with_stdio(false);\r\ncin.tie(NULL);cout.tie(NULL);\r\nll tt=1;\r\n//cin>>tt;\r\nwhile(tt--)\r\n{\r\n   ll n,k;\r\n   cin>>n>>k;\r\n   ll ans=0;\r\n   vvll a;\r\n   vll cnt(n,0);\r\n   map<vll,ll>mp;\r\n   in(i,0,n)\r\n   {\r\n       vll v(k);\r\n       input(v,0,k);\r\n       a.pb(v);\r\n       mp[v]=i;\r\n\r\n   }\r\n   //cout<<\"start\"<<endl;\r\n   in(i,0,n)\r\n   {\r\n       in(j,i+1,n)\r\n       {\r\n           vll v(k);\r\n           in(x,0,k)\r\n           {\r\n               if(a[i][x]==a[j][x])\r\n               {\r\n                   v[x]=a[i][x];\r\n                   continue;\r\n               }\r\n               ll done[3]={0};\r\n               done[a[i][x]]=1;\r\n               done[a[j][x]]=1;\r\n               in(l,0,3)\r\n               {\r\n                   if(!done[l])\r\n                   {\r\n                       v[x]=l;\r\n                       break;\r\n                   }\r\n               }\r\n\r\n           }\r\n           if(mp.count(v) and mp[v]>j)\r\n               {\r\n                   //cout<<i<<\" \"<<j<<\" \"<<mp[v]<<endl;\r\n                   cnt[i]++;\r\n                   cnt[j]++;\r\n                   cnt[mp[v]]++;\r\n               }\r\n       }\r\n   }\r\n\r\n   in(i,0,n)\r\n   {\r\n       ans+=(cnt[i]*(cnt[i]-1))/2;\r\n       //cout<<ans<<endl;\r\n   }\r\n   cout<<ans<<endl;\r\n\r\n\r\n}\r\nreturn 0;\r\n}\r\n"
}