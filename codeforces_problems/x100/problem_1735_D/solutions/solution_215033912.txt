{
    "id": 215033912,
    "contestId": 1735,
    "creationTimeSeconds": 1690024279,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1735,
        "index": "D",
        "name": "Meta-set",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 1700,
        "tags": [
            "brute force",
            "combinatorics",
            "data structures",
            "hashing",
            "math"
        ]
    },
    "author": {
        "contestId": 1735,
        "members": [
            {
                "handle": "rtlgmofrpm"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1664721300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 54,
    "timeConsumedMillis": 139,
    "memoryConsumedBytes": 38502400,
    "source": "//#pragma GCC optimize(\"O3\")\r\n//#pragma GCC optimize(\"Ofast\")\r\n//#pragma GCC target(\"avx,avx2,fma\")\r\n#include <bits/stdc++.h>\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\ntemplate<class t>\r\nusing ordered_set=tree<t,null_type,less<t>,rb_tree_tag,tree_order_statistics_node_update>;\r\n\r\n//https://codeforces.com/blog/entry/62393\r\nstruct custom_hash {\r\n\tstatic uint64_t splitmix64(uint64_t x) {\r\n\t\t// http://xorshift.di.unimi.it/splitmix64.c\r\n\t\tx += 0x9e3779b97f4a7c15;\r\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n\t\treturn x ^ (x >> 31);\r\n\t}\r\n  \r\n\tsize_t operator()(uint64_t x) const {\r\n\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n\t\treturn splitmix64(x + FIXED_RANDOM);\r\n\t}\r\n\r\n\tsize_t operator()(pair<int,int> x)const{\r\n\t\treturn operator()(uint64_t(x.first)<<32|x.second);\r\n\t}\r\n};\r\n\r\ntemplate<class t,class u>\r\nusing hash_table=gp_hash_table<t,u,custom_hash>;\r\n\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\r\n#define all(v) v.begin(),v.end()\r\n#define mod1 1000000007\r\n#define YES cout<<\"YES\"<<nline\r\n#define NO cout<<\"NO\"<<nline\r\n#define mod2 998244353\r\n#define ll long long\r\n#define lld long double\r\n#define ull unsigned long long\r\n#define nline \"\\n\"\r\n#define maxbit(n) 31-__builtin_clz(n)\r\n#define maxbitll(n) 63-__builtin_clzll(n)\r\n#define minbit(n) __builtin_ctz(n) \r\n#define minbitll(n) __builtin_ctzll(n) \r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(deque <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(deque <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\nint m_svsize=1;\r\nint svsize=1;\r\nvector<int> sv(svsize);\r\nvector<vector<int>> m_sv(m_svsize,{1});\r\n\r\ntemplate<class T>\r\nT lcm(T a, T b)\r\n{\r\n    return (a / __gcd(a, b)) * b;\r\n}\r\n\r\ntemplate <class T,class U,class X>\r\nT modpow(T base, X exp, U modulus) {\r\n  base %= modulus;\r\n  T result = 1;\r\n  while (exp > 0) {\r\n    if (exp & 1) result = (result * base) % modulus;\r\n    base = (base * base) % modulus;\r\n    exp >>= 1;\r\n  }\r\n  return result;\r\n}\r\n\r\nvoid sieve()\r\n{\r\n    //seive of eratosthanos\r\n    sv[1] = 1;\r\n    int n=sv.size();\r\n    for (int i=2; i<n-1; i++)\r\n        sv[i] = i;\r\n    for (int i=4; i<n-1; i+=2)\r\n        sv[i] = 2;\r\n\r\n    for (int i=3; i*i<n-1; i++)\r\n    {\r\n        if (sv[i] == i)\r\n        {\r\n            for (int j=i*i; j<n-1; j+=i)\r\n                if (sv[j]==j)\r\n                    sv[j] = i;\r\n        }\r\n    }\r\n}\r\nvoid masked_sieve()\r\n{\r\n    for (int i=2; i<m_sv.size(); i++)\r\n    {\r\n        if(m_sv[i].size()>1){\r\n            continue;\r\n        }\r\n        for(int j=i;j<m_sv.size();j+=i){\r\n            int n=m_sv[j].size();\r\n            for(int k=0;k<n;k++){\r\n                m_sv[j].push_back(-m_sv[j][k]*i);\r\n            }\r\n        }\r\n    }\r\n}\r\nlong long int coprime(long long a,long long N){\r\n    long long ans=0;\r\n    for(auto i:m_sv[a]){\r\n        ans+=N/i;\r\n    }\r\n    return ans;\r\n}\r\n\r\n\r\nvoid lcs(string X, string Y,vector<vector<int>> &L)\r\n{\r\n\r\n    /* Following steps build L[m+1][n+1] in bottom up fashion. Note\r\n        that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */\r\n    for (int i = 0; i <= X.size(); i++)\r\n    {\r\n        for (int j = 0; j <= Y.size(); j++)\r\n        {\r\n            if (i == 0 || j == 0)\r\n                L[i][j] = max(i,j);\r\n\r\n            else if (X[i - 1] == Y[j - 1])\r\n                L[i][j] = L[i - 1][j - 1];\r\n\r\n            else\r\n                L[i][j] = min(min(L[i - 1][j]+1, L[i][j - 1]+1),L[i-1][j-1]+1);\r\n        }\r\n    }\r\n\r\n}\r\nll setKthBit(ll n, ll k)\r\n{\r\n    return ((1LL << k) | n);\r\n}\r\nll unsetKthBit(ll n, ll k)\r\n{\r\n    return (n & (~(1LL << (k ))));\r\n}\r\n\r\nll isKthBitSet(ll n,ll k)\r\n{\r\n    if ((n >> k) & 1LL){\r\n        return 1LL;\r\n    }\r\n    else{\r\n        return 0LL;\r\n    }\r\n}\r\n\r\n\r\n\r\ntemplate <class T,class V>\r\nT modInverse(T A,V M)\r\n{\r\n    T m0 = M;\r\n    T y = 0, x = 1;\r\n\r\n    if (M == 1)\r\n        return 0;\r\n\r\n    while (A > 1) {\r\n        // q is quotient\r\n        T q = A / M;\r\n        T t = M;\r\n\r\n        // m is remainder now, process same as\r\n        // Euclid's algo\r\n        M = A % M, A = t;\r\n        t = y;\r\n\r\n        // Update y and x\r\n        y = x - q * y;\r\n        x = t;\r\n    }\r\n\r\n    // Make x positive\r\n    if (x < 0)\r\n        x += m0;\r\n\r\n    return x;\r\n}\r\n\r\nbool ans(string a,string b,int i,int c,int d){\r\n    if (i==-1){\r\n        return true;\r\n    }\r\n    if(a[i]==b[c] &&a[i]==b[d]){\r\n        return ans(a,b,i-1,c+1,d)||ans(a,b,i-1,c,d-1);\r\n    }\r\n    else if (a[i]==b[c]){\r\n        return ans(a,b,i-1,c+1,d);\r\n    }\r\n    else if (a[i]==b[d]){\r\n        return ans(a,b,i-1,c,d-1);\r\n    }\r\n    else{\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nint dfs(int v, int par, int h, vector<int> &d,vector<vector<int>> &G,vector<int> &sr) {\r\n\r\n    d[v] = h;\r\n\r\n    for (int i=0;i<G[v].size();i++) {\r\n        if (G[v][i]!=par) {\r\n            sr[v]+=dfs(G[v][i], v, h + 1, d,G,sr);\r\n        }\r\n    }\r\n    return sr[v];\r\n}\r\n\r\nvoid bfs2(deque<int>&d,vector<int> &fr,int t,vector<vector<int>> &G) {\r\n    for(int i=0;i<t;i++){\r\n        int n=d.size();\r\n        if(n==0){\r\n            return;\r\n        }\r\n        for(int k=0;k<n;k++){\r\n            int v=d[0];\r\n            d.pop_front();\r\n            for (int j=0;j<G[v].size();j++) {\r\n                if (fr[G[v][j]]==0) {\r\n\r\n                    fr[G[v][j]]=1;\r\n                    d.push_back(G[v][j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ntemplate<class T,class V,class S,class V1,class V2,class V3>\r\nbool isValid(T& screen,S& screen2,V n,V1 m, V2 x,V3 y) \r\n{\r\n    if(x < 0 || x >= n || y < 0 || y >= m || screen[x][y] == '#'\r\n       || screen2[x][y]>= 0)\r\n        return false;\r\n    return true;\r\n}\r\n \r\n \r\n// FloodFill function\r\nstruct tripl{\r\nll a,b,c;\r\n};\r\ntemplate<class T,class V,class S>\r\nvoid floodFill(T & screen,S& screen2,V sr,V sc,\r\n               V n, V m,V ans,V w)\r\n{\r\n    deque<tripl> queue;\r\n\r\n    queue.push_back({sr,sc,ans});\r\n\r\n    screen2[sr][sc] = ans;\r\n\r\n    while(queue.size() > 0)\r\n    {\r\n        tripl currPixel = queue[0];\r\n        int posX = currPixel.a;    \r\n        int posY = currPixel.b;\r\n        long long int prevC = currPixel.c;\r\n        screen2[posX][posY] = prevC;    \r\n        queue.pop_front();\r\n        if(isValid(screen,screen2, n, m,  posX+ 1, posY))\r\n        {\r\n            queue.push_back({posX+1, posY, prevC+w });\r\n            screen2[posX+1][posY] = prevC+w;\r\n        }\r\n \r\n        if(isValid(screen,screen2, n,m, posX-1, posY))\r\n        {\r\n            queue.push_back({posX-1, posY, prevC+w });\r\n            screen2[posX-1][posY] = prevC+w;\r\n        }\r\n \r\n        if(isValid(screen,screen2, n, m, posX, posY + 1))\r\n        {\r\n            queue.push_back({posX, posY+1, prevC+w });\r\n            screen2[posX][posY+1] = prevC+w;  \r\n        }\r\n \r\n        if(isValid(screen,screen2, n, m, posX, posY-1))\r\n        {\r\n            queue.push_back({posX, posY-1, prevC+w});\r\n            screen2[posX][posY-1] = prevC+w;\r\n        }\r\n    }\r\n}\r\n\r\nvoid dfs_cycle(int u, int p, vector<int> &color, vector<int> &par, int& cyclenumber,vector<vector<int>> &G,vector<vector<int>> &cycles)\r\n{\r\n    if (color[u] == 2) {\r\n        return;\r\n    }\r\n    if (color[u] == 1) {\r\n        vector<int> v;\r\n        cyclenumber++;\r\n\r\n        int cur = p;\r\n          v.push_back(cur);\r\n        while (cur != u) {\r\n            cur = par[cur];\r\n              v.push_back(cur);\r\n        }\r\n          cycles.push_back(v);\r\n        return;\r\n    }\r\n    par[u] = p;\r\n    color[u] = 1;\r\n    for (int v : G[u]) {\r\n        if (v == par[u]) {\r\n            continue;\r\n        }\r\n        dfs_cycle(v, u, color, par, cyclenumber,G,cycles);\r\n    }\r\n    color[u] = 2;\r\n}\r\n\r\nint numdistinctpf(int a){\r\n    set<int>ss;\r\n    while(a>1){\r\n        ss.insert(sv[a]);\r\n        a/=sv[a];\r\n    }\r\n    int as=ss.size();\r\n    return as;\r\n}\r\n\r\n\r\n\r\nlong long int bruteforce(vector<long long int> &v,long long a,long long b,long long i){\r\n    if (i==v.size()){\r\n        return max(b-a,a-b);\r\n    }\r\n    return min(bruteforce(v,a+v[i],b,i+1),bruteforce(v,a,b+v[i],i+1));\r\n}\r\n\r\n\r\n\r\nstruct Job\r\n{\r\n    int i1, i2, w;\r\n};\r\n\r\nbool jobsort(Job s1, Job s2)\r\n{\r\n    return (s1.i2 < s2.i2);\r\n}\r\n\r\nint binarySearch(vector<Job> &jobs, int index)\r\n{\r\n    int lo = 0, hi = index - 1;\r\n    while (lo <= hi)\r\n    {\r\n        int mid = (lo + hi) / 2;\r\n        if (jobs[mid].i2 < jobs[index].i1)\r\n        {\r\n            if (jobs[mid + 1].i2 < jobs[index].i1)//change <= to < for no equality\r\n                lo = mid + 1;\r\n            else\r\n                return mid;\r\n        }\r\n        else\r\n            hi = mid - 1;\r\n    }\r\n    return -1;\r\n}\r\n\r\nint jobschedule(vector<Job> arr)\r\n{\r\n    int n=arr.size();\r\n    if(n==0){\r\n        return 0;\r\n    }\r\n    sort(all(arr), jobsort);\r\n\r\n    // Create an array to store solutions of subproblems.  table[i]\r\n    // stores the profit for jobs till arr[i] (including arr[i])\r\n    vector<int> table(n,0);\r\n    table[0] = arr[0].w;\r\n\r\n    // Fill entries in table[] using recursive property\r\n    for (int i=1; i<n; i++)\r\n    {\r\n        // Find profit including the current job\r\n        int inclProf = arr[i].w;\r\n        int l = binarySearch(arr, i);\r\n        if (l != -1)\r\n            inclProf += table[l];\r\n\r\n        // Store maximum of including and excluding\r\n        table[i] = max(inclProf, table[i-1]);\r\n    }\r\n\r\n    int result = table[n-1];\r\n\r\n    return result;\r\n}\r\n\r\n\r\nbool comparator(pair<vector<int>,int> i1, pair<vector<int>,int> i2)\r\n{\r\n    int c=0;\r\n    for(int i=0;i<5;i++){\r\n        if(i1.first[i]<i2.first[i]){\r\n            c++;\r\n        }\r\n    }\r\n    if(c>=3){\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nmt19937_64 rng((unsigned long long) chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nint dfsx(int v, int par, int &ans,int k,vector<vector<int>> &G) {\r\n    if(G[v].size()==0){\r\n        return 1;\r\n    }\r\n    int t=0;\r\n    for (int i=0;i<G[v].size();i++) {\r\n        if (G[v][i]!=par) {\r\n            t=max(t,dfsx(G[v][i], v, ans,k,G));\r\n        }\r\n    }\r\n    if(t>=k){\r\n        ans++;\r\n    }\r\n    return t+1;\r\n}\r\n\r\nvector<int> nck(int n,int k){\r\n    int nck=1;\r\n    vector<int> v;\r\n    for(int i=0;i<=k;i++){\r\n        v.push_back(nck);\r\n        nck=(nck*1LL*modInverse(i+1,mod1))%mod1;\r\n        nck=(nck*1LL*(n-i))%mod1;\r\n    }\r\n    return v;\r\n}\r\nstruct treenode{\r\n    int node,subtree,depth;\r\n};\r\nbool cmp(tripl i1, tripl i2)\r\n{\r\n    if(i1.a==i2.a){\r\n        if(i1.b==i2.b){\r\n            return i1.c<i2.c;\r\n        }\r\n        return i1.b<i2.b;\r\n    }\r\n    return i1.a>i2.a;\r\n}\r\n\r\nvoid bfstree(deque<int>&d,vector<int> &fr,int t,vector<set<int>> &ufn,vector<vector<int>> &G) {\r\n    for(int i=0;i<t;i++){\r\n        int n=d.size();\r\n        if(n==0){\r\n            return;\r\n        }\r\n        for(int k=0;k<n;k++){\r\n            int v=d[0];\r\n            d.pop_front();\r\n            for (int j=0;j<G[v].size();j++) {\r\n                ufn[G[v][j]].erase(v);\r\n                ufn[v].erase(G[v][j]);\r\n                if (fr[G[v][j]]==0 &&ufn[G[v][j]].size()<=1) {\r\n\r\n                    fr[G[v][j]]=1;\r\n                    d.push_back(G[v][j]);\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\nvector<int> eulerCircuit(vector< vector<int> > adj)\r\n{\r\n    // adj represents the adjacency list of\r\n    // the directed graph\r\n    // edge_count represents the number of edges\r\n    // emerging from a vertex\r\n    unordered_map<int,int> edge_count;\r\n \r\n    for (int i=0; i<adj.size(); i++)\r\n    {\r\n        //find the count of edges to keep track\r\n        //of unused edges\r\n        edge_count[i] = adj[i].size();\r\n    }\r\n    // vector to store final circuit\r\n    vector<int> circuit;\r\n    if (!adj.size())\r\n        return circuit; //empty graph\r\n \r\n    // Maintain a stack to keep vertices\r\n    stack<int> curr_path;\r\n\r\n    // start from any vertex\r\n    curr_path.push(0);\r\n    int curr_v = 0; // Current vertex\r\n \r\n    while (!curr_path.empty())\r\n    {\r\n        // If there's remaining edge\r\n        if (edge_count[curr_v])\r\n        {\r\n            // Push the vertex\r\n            curr_path.push(curr_v);\r\n \r\n            // Find the next vertex using an edge\r\n            int next_v = adj[curr_v].back();\r\n \r\n            // and remove that edge\r\n            edge_count[curr_v]--;\r\n            adj[curr_v].pop_back();\r\n \r\n            // Move to next vertex\r\n            curr_v = next_v;\r\n        }\r\n \r\n        // back-track to find remaining circuit\r\n        else\r\n        {\r\n            circuit.push_back(curr_v);\r\n \r\n            // Back-tracking\r\n            curr_v = curr_path.top();\r\n            curr_path.pop();\r\n        }\r\n    }\r\n \r\n    // we've got the circuit, now print it in reverse\r\n    return circuit;\r\n}\r\n\r\nvoid build(vector<int> &t,vector<int> &a, int v, int tl, int tr) {\r\n    if (tl == tr) {\r\n        t[v] = a[tl];\r\n    } else {\r\n        int tm = (tl + tr) / 2;\r\n        build(t,a, v*2, tl, tm);\r\n        build(t,a, v*2+1, tm+1, tr);\r\n        t[v] = 0;\r\n    }\r\n}\r\n\r\nvoid update(vector<int> &t,vector<int> &a,int v, int tl, int tr, int l, int r, int add) {\r\n    if (l > r)\r\n        return;\r\n    if (l == tl && r == tr) {\r\n        t[v] += add;\r\n    } else {\r\n        int tm = (tl + tr) / 2;\r\n        update(t,a,v*2, tl, tm, l, min(r, tm), add);\r\n        update(t,a,v*2+1, tm+1, tr, max(l, tm+1), r, add);\r\n    }\r\n}\r\n\r\nint get(vector<int> &t,int v, int tl, int tr, int pos) {\r\n    if (tl == tr)\r\n        return t[v];\r\n    int tm = (tl + tr) / 2;\r\n    if (pos <= tm)\r\n        return t[v] + get(t,v*2, tl, tm, pos);\r\n    else\r\n        return t[v] + get(t,v*2+1, tm+1, tr, pos);\r\n}\r\n\r\nvoid push(int v,vector<int>&t,vector<int>&lazy) {\r\n    t[v*2] += lazy[v];\r\n    lazy[v*2] += lazy[v];\r\n    t[v*2+1] += lazy[v];\r\n    lazy[v*2+1] += lazy[v];\r\n    lazy[v] = 0;\r\n}\r\n\r\nvoid updateadd(vector<int> &t,vector<int>& lazy,int v, int tl, int tr, int l, int r, int addend) {\r\n    if (l > r) \r\n        return;\r\n    if (l == tl && tr == r) {\r\n        t[v] += addend;\r\n        lazy[v] += addend;\r\n    } else {\r\n        push(v,t,lazy);\r\n        int tm = (tl + tr) / 2;\r\n        update(t,lazy,v*2, tl, tm, l, min(r, tm), addend);\r\n        update(t,lazy,v*2+1, tm+1, tr, max(l, tm+1), r, addend);\r\n        t[v] = max(t[v*2], t[v*2+1]);\r\n    }\r\n}\r\n\r\nint query_maximum(vector<int> &t,vector<int> &lazy,int v, int tl, int tr, int l, int r) {\r\n    if (l > r)\r\n        return INT_MIN;\r\n    if (l == tl && tr == r)\r\n        return t[v];\r\n    push(v,t,lazy);\r\n    int tm = (tl + tr) / 2;\r\n    return max(query_maximum(t,lazy,v*2, tl, tm, l, min(r, tm)), \r\n               query_maximum(t,lazy,v*2+1, tm+1, tr, max(l, tm+1), r));\r\n}\r\n\r\nint dfss(int v, int par,int h, vector<treenode> &d,vector<vector<int>> &G) {\r\n    if(G[v].size()==1 && G[v][0]==par){\r\n        d[v].subtree=1;\r\n        d[v].depth=h;\r\n        return 1;\r\n    }\r\n    d[v].subtree=0;\r\n    d[v].depth=h;\r\n    for (int i=0;i<G[v].size();i++) {\r\n        if (G[v][i]!=par) {\r\n            d[v].subtree+=dfss(G[v][i], v,h+1, d,G);\r\n        }\r\n    }\r\n    d[v].subtree++;\r\n    return d[v].subtree;\r\n}\r\n\r\n\r\nstruct seg{\r\n\tint l, r;\r\n};\r\n\r\nbool operator <(const seg &a, const seg &b){\r\n\tif(a.l-a.r==b.l-b.r){\r\n        return a.l<b.l;\r\n    }\r\n    return a.r-a.l>b.r-b.l; \r\n}\r\n\r\ntemplate<class T,class V,class X>\r\nT kxorminus(T a,V b,X k){\r\n    T ans=0;\r\n    T exp=1;\r\n    while(a>0 || b>0){\r\n        ans+=exp*((a%k-b%k+k)%k);\r\n        a/=k;\r\n        b/=k;\r\n        exp*=k;\r\n    }\r\n    return ans;\r\n}\r\ntemplate<class T,class V,class X>\r\nT kxorplus(T a,V b,X k){\r\n    T ans=0;\r\n    T exp=1;\r\n    while(a>0 || b>0){\r\n        ans+=exp*((a%k+b%k+k)%k);\r\n        a/=k;\r\n        b/=k;\r\n        exp*=k;\r\n    }\r\n    return ans;\r\n}\r\nint intval(int i,vector<int>&v){\r\n    if (v[i - 1]<v[i] && v[i]>v[i+1]){\r\n\t\treturn 1;\r\n    }\r\n    if(v[i]<v[i-1] && v[i]<v[i+1]){\r\n        return 2;\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid brute(vector<int>&v,vector<int>dp,int & c){\r\n    if(dp.size()==v.size()){\r\n        vector<int>d(5,0);\r\n        for(int i=0;i<v.size();i++){\r\n            d[dp[i]]+=v[i];\r\n        }\r\n        int t=1;\r\n        int ans=d[1];\r\n        for(int i=2;i<5;i++){\r\n            if(d[i]!=d[i-1]){\r\n                t=0;\r\n                break;\r\n            }\r\n        }\r\n        if(t==1){\r\n            c=max(c,ans);\r\n        }\r\n        return;\r\n    }\r\n    for(int i=0;i<5;i++){\r\n        dp.push_back(i);\r\n        brute(v,dp,c);\r\n        dp.pop_back();\r\n    }\r\n}   \r\n\r\nvoid solve(){\r\n\r\n    //hash_table<pair<int,int>, int> mp;\r\n    //auto x=rng();\r\n    /*auto itr=mp.find({j,d});\r\n    if(itr!=mp.end()){\r\n        ans+=itr->second;\r\n        //do this or memory issues for hash_table\r\n    }*/\r\n    //LLONG_MAX, INT_MAX\r\n    /*\r\n    map<int, string> m{ {10, \"potato\"}, {1, \"banana\"} };\r\n    auto nodeHandler = m.extract(10);\r\n    nodeHandler.key() = 2;\r\n    m.insert(move(nodeHandler)); // { { 1, \"banana\" }, { 2, \"potato\" } }\r\n    */\r\n    ll n,k,c;\r\n    cin>>n>>k;\r\n    vector<vector<int>>v(n);    \r\n    for(int i=0;i<n;i++){\r\n        for(int j=0;j<k;j++){\r\n            cin>>c;\r\n            v[i].push_back(c);\r\n        }\r\n    }\r\n    hash_table<ll, ll> mp;\r\n    ll ans=0;\r\n    for(int i=0;i<n;i++){\r\n        for(int j=i+1;j<n;j++){\r\n            ll hsh=0;\r\n            for(int l=0;l<k;l++){\r\n                hsh*=3;\r\n                if(v[i][l]==v[j][l]){\r\n                    hsh+=v[i][l];\r\n                }\r\n                else{\r\n                    hsh+=3-v[i][l]-v[j][l];\r\n                }\r\n            }\r\n            mp[hsh]++;\r\n        }\r\n    }\r\n    for(int i =0;i<n;i++){\r\n        ll hsh=0;\r\n        for(int j=0;j<k;j++){\r\n            hsh*=3;\r\n            hsh+=v[i][j];\r\n        }\r\n        if(mp.find(hsh)!=mp.end()){\r\n            ll x=mp[hsh];\r\n            ans+=(x*(x-1LL))/(2LL);\r\n        }\r\n    }\r\n    cout<<ans<<nline;\r\n\t\r\n\r\n    /*vector<long long int> v(n);\r\n    vector<long long int> ps(n+1,0);\r\n    for(int i=0;i<n;i++){\r\n        cin>>v[i];\r\n        ps[i+1]=ps[i]+v[i];\r\n        ps[i+1]%=mod1;\r\n    }\r\n\r\n    string s;\r\n    cin>>s;\r\n    vector<vector<vector<long long int>>>dp(k+1,vector<vector<long long int>>(n+2,vector<long long int>(n+2,0)));\r\n    dp[0][1][n]=1;\r\n    vector<int> dp3(1000,0);\r\n    for(int i=1;i<1000;i++){\r\n        dp3[i]=modInverse(i,mod1);\r\n    }\r\n    for(int kk=1;kk<=min(n-1,k);kk++){\r\n        if(s[kk-1]=='L'){\r\n            for(int l=1;l<=n;l++){\r\n                for(int r=n;r>=l;r--){\r\n                    if(l==r){\r\n                        dp[kk][l][r]=dp[kk][l][r+1]+dp[kk-1][l][r+1]+dp[kk-1][l][r];\r\n                    }\r\n                    else{\r\n                        dp[kk][l][r]=dp[kk][l][r+1]+(dp[kk-1][l][r+1]*dp3[r+1-l])%mod1;\r\n                    }\r\n                    dp[kk][l][r]%=mod1;\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            for(int r=1;r<=n;r++){\r\n                for(int l=1;l<=r;l++){\r\n                    if(l==r){\r\n                        dp[kk][l][r]=dp[kk][l-1][r]+dp[kk-1][l-1][r]+dp[kk-1][l][r];\r\n                    }\r\n                    else{\r\n                        dp[kk][l][r]=dp[kk][l-1][r]+(dp[kk-1][l-1][r]*dp3[r+1-l])%mod1;\r\n                    }\r\n                    dp[kk][l][r]%=mod1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    long long ans=0;\r\n    for(int l=1;l<=n;l++){\r\n        for(int r=l;r<=n;r++){\r\n            ans+=((ps[r]-ps[l-1])*dp[min(n-1,k)][l][r])%mod1;\r\n            ans%=mod1;\r\n        }\r\n    }\r\n    cout<<ans<<nline;*/\r\n    //next_permutation(arr, arr + 3); // c++ inbuilt permutation generator\r\n\r\n    //vector<vector<vector<bool>>>dp(n+1,vector<vector<bool>>(m+1,vector<bool>(r+1,true)));\r\n\r\n\r\n    /*string s;\r\n    cin>>s;\r\n    int c=0;\r\n    int l=0;\r\n    int r=0;\r\n    while(r<n &&c!=k){\r\n        c+=(s[r]=='1');\r\n        r++;\r\n    }\r\n    while(r<n){\r\n\r\n    }*/\r\n\r\n    //int x=min(int(max_element(v.begin(),v.end())-v.begin()),int(min_element(v.begin(),v.end())-v.begin()));\r\n\r\n\r\n    /*\r\n    int n,m,k;\r\n    cin>>n>>k;\r\n    vector<int> v(n);\r\n    for (int i=0;i<n;i++){\r\n        cin>>v[i];\r\n    }\r\n    vector<int> dp(64,0);\r\n    for (int i=0;i<n;i++){\r\n        vector<int> dp2(64,0);\r\n        dp2[v[i]]+=1;\r\n        //debug(v[i]);\r\n        //debug(dp2[v[i]]);\r\n        for (int j=0;j<64;j++){\r\n            dp2[j&v[i]]+=dp[j];\r\n            dp2[j&v[i]]%=1000000007;\r\n        }\r\n        for (int j=0;j<64;j++){\r\n            dp[j]+=dp2[j];\r\n            dp[j]%=1000000007;\r\n        }\r\n    }\r\n    int ans=0;\r\n    for (int j=0;j<64;j++){\r\n        int c=j;\r\n        int bc=0;\r\n        while (c!=0){\r\n            bc+=c%2;\r\n            c/=2;\r\n        }\r\n        if (bc==k){\r\n            ans+=dp[j];\r\n            ans%=1000000007;\r\n        }\r\n    }\r\n    cout<<ans<<nline;\r\n    */\r\n}\r\nint32_t main()\r\n{\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    cout << setprecision(30) << fixed;\r\n    //freopen(\"speed.in\", \"r\", stdin);\r\n\t//freopen(\"speed.out\", \"w\", stdout);\r\n    ll t=1;\r\n    //cin>>t;\r\n\r\n    //sieve();\r\n    //masked_sieve();\r\n    /*vector<int>primes;\r\n    for(int i=2;i<sv.size();i++){\r\n        if(sv[i]==i){\r\n            primes.insert(i);\r\n        }\r\n    }*/\r\n    for(int i=0;i<t;i++){\r\n       solve();\r\n    }\r\n    return 0;\r\n}"
}