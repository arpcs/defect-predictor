{
    "id": 212355519,
    "contestId": 1519,
    "creationTimeSeconds": 1688646373,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1519,
        "index": "D",
        "name": "Maximum Sum of Products",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "math",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1519,
        "members": [
            {
                "handle": "NanuG"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1619706900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 28,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 20992000,
    "source": "#include <bits/stdc++.h>\r\n#pragma GCC target(\"avx2,bmi,bmi2,popcnt,lzcnt\")\r\n#pragma GCC optimization (\"O3\")\r\n#pragma GCC optimization (\"unroll-loops\")\r\nusing namespace std;\r\n#define M 1000000007\r\n#define INFL 1000000000000000000\r\n#define INF 1000000000\r\n#define pi 3.141592653589793238462643383279\r\n// #define maxn 100000\r\n#define forn(i, n) for (int i = 0; i < int(n); i++)\r\n#define mp make_pair\r\n#define pb push_back\r\n#define popb pop_back\r\n#define GCD(x, y) __gcd(x, y)\r\n#define all(x) x.begin(), x.end()\r\n#define fix(n) std::fixed<<std::setprecision(n)\r\ntypedef long long int ll;\r\ntypedef long double ld;\r\ntypedef vector<int> vi;\r\ntypedef vector<long long> vll;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<long long, long long> pll;\r\ntypedef vector<pair<int, int>> vpi;\r\ntypedef vector<vector<int>> vvi;\r\ntypedef vector<vector<ll>> vvl;\r\ntypedef vector<pair<long long, long long>> vpll;\r\ntypedef map<ll,ll> mpll;\r\ntypedef map<int,int> mpii;\r\nvoid __print(int x) { cerr << x; }\r\nvoid __print(long x) { cerr << x; }\r\nvoid __print(long long x) { cerr << x; }\r\nvoid __print(unsigned x) { cerr << x; }\r\nvoid __print(unsigned long x) { cerr << x; }\r\nvoid __print(unsigned long long x) { cerr << x; }\r\nvoid __print(float x) { cerr << x; }\r\nvoid __print(double x) { cerr << x; }\r\nvoid __print(long double x) { cerr << x; }\r\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\r\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\r\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\r\nvoid __print(bool x) { cerr << (x == 1); }\r\ntemplate <typename T, typename V>\r\nvoid __print(const pair<T, V> &x)\r\n{\r\n    cerr << '{';_print(x.first);cerr << ',';_print(x.second);cerr << '}';\r\n}\r\ntemplate <typename T>\r\nvoid __print(const T &x)\r\n{\r\n    int f = 0;cerr << '{';\r\n      for (auto &i : x)\r\n        cerr << (f++ ? \",\" : \"\"), __print(i);\r\n    cerr << \"}\";\r\n}\r\nvoid _print() { cerr << \"]\\n\"; }\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v)\r\n{\r\n    __print(t);\r\n    if (sizeof...(v))\r\n        cerr << \",\";\r\n    _print(v...);\r\n}\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x...)               \\\r\n    cerr << \"[\" << #x << \"] = [\"; \\\r\n    _print(x);\r\n#else\r\n#define debug(x...) ;\r\n#endif\r\n \r\n// this returns the max value less than x//\r\nint bin_s(int a[], int n, int x)\r\n{\r\n      int i = 0;\r\n      int j = n - 1;\r\n      while (i < j)\r\n      {\r\n            if (x < a[(i + j) / 2])\r\n                  j = (i + j) / 2;\r\n            else\r\n                  i = (i + j) / 2;\r\n            if (j - i == 1)\r\n            {\r\n                  if (a[j] <= x)\r\n                        return j;\r\n                  else\r\n                        return i;\r\n            }\r\n      }\r\n      return 0;\r\n}\r\n \r\n//---binary exponentiation---//\r\nll expon(ll a, ll n)\r\n{\r\n      ll ans = 1;\r\n      while (n)\r\n      {\r\n            if (n & 1)\r\n            ans = (ans * a) % M;\r\n            a = (a * a) % M;\r\n            n >>= 1;\r\n      }\r\n      return ans;\r\n}\r\n \r\n//-----NUMBER THEORY-----//\r\nbool isprime(int x)\r\n{\r\n      if(x&1)\r\n      {\r\n            for(int i = 3; i*i <= x; i+=2)\r\n            {\r\n                  if(x%i == 0)\r\n                  {\r\n                        return 0;\r\n                  }\r\n            }\r\n            return 1;\r\n      }\r\n      return 0;\r\n}\r\n \r\nll gcdExtended(ll a, ll b, ll *x, ll *y);\r\n \r\n// Function to find modulo inverse of a\r\n// ll modInverse(ll a)\r\n// {\r\n//       ll x, y;\r\n//       ll g = gcdExtended(a, M, &x, &y);\r\n//       // if (g != 1)\r\n//       //     cout << \"Inverse doesn't exist\";\r\n//       // else\r\n//       // {\r\n \r\n//       // m is added to handle negative x\r\n//       ll res = (x % M + M) % M;\r\n//       // cout << \"Modular multiplicative inverse is \" << res;\r\n//       return res;\r\n//       // }\r\n// }\r\n \r\n// Function for extended Euclidean Algorithm\r\nll gcdExtended(ll a, ll b, ll *x, ll *y)\r\n{\r\n \r\n      // Base Case\r\n      if (a == 0)\r\n      {\r\n            *x = 0, *y = 1;\r\n            return b;\r\n      }\r\n \r\n      // To store results of recursive call\r\n      ll x1, y1;\r\n      ll gcd = gcdExtended(b % a, a, &x1, &y1);\r\n \r\n      // Update x and y using results of recursive\r\n      // call\r\n      *x = y1 - (b / a) * x1;\r\n      *y = x1;\r\n \r\n      return gcd;\r\n}\r\n \r\n//-------sieve--------//\r\n// const ll maxn = 10000000;\r\n// vll prim;\r\n// ll lpf[maxn+5] = {0};\r\n// void sieve()\r\n// {\r\n//       lpf[2] = 2;\r\n//       prim.pb(2);\r\n//       for(ll i = 2; i <= maxn; i+=2)\r\n//       {\r\n//             lpf[i] = 2;\r\n//       }  \r\n//       for(ll i = 3; i*i <= maxn; i+=2)\r\n//       {\r\n//             if(lpf[i] == 0)\r\n//             {\r\n//                   lpf[i] = i;\r\n//                   for(ll j = 2*i; j <= maxn; j+=i)\r\n//                         lpf[j] = i;\r\n//                   prim.pb(i);\r\n \r\n//             }\r\n//       }\r\n//       for(ll i = sqrt(maxn); i <= maxn; i++)\r\n//       {\r\n//             if(lpf[i])\r\n//                   continue;\r\n//             else \r\n//             {\r\n//                   lpf[i] = i;\r\n//                   prim.pb(i);\r\n//             }\r\n//       }\r\n// }\r\n \r\n// // use maps when necessary else use array\r\n// bool valid(string &t)\r\n// {\r\n//       stack<char> st;\r\n//       st.push(t[0]);\r\n//       if(t[0] == ')')\r\n//             return false;\r\n//       for(int i = 1; i < t.size(); i++)\r\n//       {\r\n//             if(t[i] == ')')\r\n//             {\r\n//                   if(st.empty())\r\n//                         return false;\r\n//                   else st.pop();\r\n//             }\r\n//             else st.push('(');\r\n//       }\r\n//       if(st.empty())\r\n//       return true;\r\n//       else return false;\r\n// }\r\n \r\n// function to print arr of long long------------------\r\n \r\nvoid shoar(vector<ll> arr){\r\n    for(auto st: arr){\r\n        cout<<st<<\" \";\r\n    }\r\n    cout<<endl;\r\n}\r\n \r\n//------------------------------------------------------\r\n \r\n \r\n// const ll p =998244353;\r\n \r\n \r\n//seg tree----------------------------------------------\r\n \r\n \r\nconst int N = 200001;\r\n \r\nll a[N];\r\nll t[4 * N];\r\nll mult[4 * N];\r\nll addn[4 * N] = { 0 };\r\n \r\n \r\nvoid build(int v, int tl, int tr) {\r\n      if (tl == tr) {\r\n            t[v] = a[tl];\r\n            mult[v] = 1;\r\n      }\r\n      else {\r\n            int tm = (tl + tr) / 2;\r\n            build(v * 2, tl, tm);\r\n            build(v * 2 + 1, tm + 1, tr);\r\n            t[v] = max(t[2 * v] , t[2 * v + 1]);\r\n            mult[v] = 1;\r\n      }\r\n} \r\nvoid push(int v, int tl, int tm, int tr) {\r\n \r\n      t[2 * v] *= mult[v];\r\n      t[2 * v + 1] *= mult[v];\r\n      mult[2 * v] *= mult[v];\r\n      mult[2 * v + 1] *= mult[v];\r\n      addn[2 * v] *= mult[v];\r\n      addn[2 * v + 1] *= mult[v];\r\n      mult[v] = 1;\r\n      t[2 * v] += (tm - tl + 1) * addn[v];\r\n      t[2 * v + 1] += (tr - tm) * addn[v];\r\n      addn[2 * v] += addn[v];\r\n      addn[2 * v + 1] += addn[v];\r\n      addn[v] = 0;\r\n}\r\n \r\nvoid update(int v, int tl, int tr, int l, int r, ll p, ll q) {\r\n      \r\n      if (l > r)\r\n            return;\r\n      if (tl==l && tr==r) {\r\n            t[v] *= p;\r\n            t[v] += (tr - tl + 1) * q;\r\n            mult[v] *= p;\r\n            addn[v] *= p;\r\n            addn[v] += q;\r\n            return;\r\n      }\r\n      int tm = (tl + tr) / 2;\r\n      push(v, tl, tm, tr);\r\n      update(2 * v, tl, tm, l, min(tm, r), p, q);\r\n      update(2 * v + 1, tm + 1, tr, max(tm + 1, l), r, p, q);\r\n      t[v] = t[2 * v] + t[2 * v + 1];\r\n}\r\n \r\n \r\nll query(int v, int tl, int tr, int l, int r) {\r\n \r\n      if (l > r)\r\n            return 0;\r\n      if (l == tl && r == tr)\r\n            return t[v];\r\n      int tm = (tl + tr) / 2;\r\n      push(v, tl, tm, tr);\r\n      return max(query(2 * v, tl, tm, l, min(r, tm)) , query(2 * v + 1, tm + 1, tr, max(tm + 1, l), r));\r\n}\r\n// //-----------------------------------------------------\r\n \r\n \r\n//DSU--------------------------------------------\r\n// class DisjointSet{ public:\r\n//     vector<int> parent;\r\n//     DisjointSet(int n): parent(n) {\r\n//          for(int i=0; i<n; i++) parent[i] = i; \r\n//     }\r\n//     void join(int a, int b){\r\n//         parent[find(b)] = find(a); \r\n//     }\r\n//     int find(int a){ \r\n//         return a == parent[a] ? a : parent[a] = find(parent[a]); \r\n//     }\r\n//     bool is_same(int a, int b){ \r\n//         return find(a) == find(b); \r\n//     }\r\n// };\r\n \r\n//------------------------------------------------------ \r\n\r\nvoid solve(){\r\n      ll n;cin>>n;\r\n      vll a(n+1);\r\n      vll b(n+1);\r\n      forn(i,n+1){\r\n            if(i!=0){\r\n                  cin>>a[i];\r\n            }\r\n      }\r\n      forn(i,n+1){\r\n            if(i!=0){\r\n                  cin>>b[i];\r\n            }\r\n      }\r\n      vll pre(n+1);\r\n      pre[0]=0;\r\n      pre[1]=a[1]*b[1];\r\n      for(int i=1;i<=n;i++){pre[i]=pre[i-1]+a[i]*b[i];}\r\n      ll ans=pre[n];\r\n      for(int i=1;i<=n;i++){\r\n            ll lo=i-1,hi=i+1;\r\n            ll temp =a[i]*b[i];\r\n\r\n            while(lo>0 && hi<=n){\r\n                  temp+=a[lo]*b[hi]+b[lo]*a[hi];\r\n                  ll damp= temp;\r\n                  damp+=(pre[lo-1]+pre[n]-pre[hi]);\r\n                  ans=max(ans,damp);\r\n                  lo--;\r\n                  hi++;\r\n            }\r\n      }\r\n      for(int i=2;i<=n;i++){\r\n            ll lo=i-2,hi=i+1;\r\n            ll temp =a[i-1]*b[i];\r\n            temp+=a[i]*b[i-1];\r\n            if(hi!=n+1){\r\n                  ans = max(ans,temp+pre[lo]+pre[hi]-pre[i]);\r\n            }\r\n            else{ \r\n                  // cout<<temp<<endl;\r\n                  // cout<<lo<<endl;\r\n                  // cout<<pre[lo]<<endl;\r\n                  ans = max(ans,temp+pre[lo]);\r\n            }\r\n            while(lo>0 && hi<=n){\r\n                  temp+=a[lo]*b[hi]+b[lo]*a[hi];\r\n                  ll damp= temp;\r\n                  damp+=(pre[lo-1]+pre[n]-pre[hi]);\r\n                  ans=max(ans,damp);\r\n                  lo--;\r\n                  hi++;\r\n            }\r\n      }\r\n      cout<<ans<<endl;\r\n}\r\n\r\n \r\n \r\n \r\n \r\n \r\nint main()\r\n{\r\n      #ifndef ONLINE_JUDGE\r\n            freopen(\"input.txt\", \"r\" , stdin);\r\n            freopen(\"output.txt\", \"w\", stdout);\r\n      #endif\r\n      ios_base::sync_with_stdio(false);\r\n      cin.tie(NULL);\r\n      cout.tie(NULL);\r\n//-----------------------------------------//    \r\n \r\n \r\nint tc=1;\r\n// cin >> tc;\r\n// sieve();\r\nwhile (tc--){\r\n      solve();\r\n      debug(\"endtc\");\r\n}\r\n \r\ncerr << \"time taken : \" << (float)clock() / CLOCKS_PER_SEC << \" secs\" << \"\\n\";\r\nreturn 0;\r\n}\r\n"
}