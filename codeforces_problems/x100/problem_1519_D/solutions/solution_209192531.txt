{
    "id": 209192531,
    "contestId": 1519,
    "creationTimeSeconds": 1686398924,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1519,
        "index": "D",
        "name": "Maximum Sum of Products",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "math",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1519,
        "members": [
            {
                "handle": "k3x9_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1619706900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 30,
    "timeConsumedMillis": 451,
    "memoryConsumedBytes": 200192000,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nusing namespace std::chrono;\r\n\r\n//push_back\r\n#define vec vector\r\n#define read(n) ll n; cin>>n\r\n#define read2(a,b) ll a,b; cin>>a>>b\r\n#define fi(a,b,c) for(int i=a;i<b;i+=c)\r\n#define fori(a,b) for(int i=a;i<b;i++)\r\ntypedef long long ll;\r\n\r\nconst ll N=1000000007;\r\n \r\nbool cmp(pair<ll,ll> a,pair<ll,ll> b){\r\n\tif(a.first != b.first) return a.first<b.first;\r\n\treturn a.second > b.second;\r\n}\r\nbool cmp2(pair<ll,ll> a,pair<ll,ll> b){\r\n\treturn a.second > b.second;\r\n}\r\nbool cmp3(ll a,ll b){\r\n\treturn a>b;\r\n}\r\nbool cmp4(pair<ll,ll> a,pair<ll,ll> b){\r\n\tif(a.second != b.second) return a.second > b.second;\r\n\treturn a.first > b.first;\r\n}\r\n\r\nstruct node{\r\n\tstruct node* left = NULL;\r\n\tstruct node* right = NULL;\r\n};\r\n\r\nvoid print_vec(vector<ll> &v){\r\n\tfor(auto i : v){\r\n\t\tcout<<i<<\" \";\r\n\t}\r\n\t// cout<<\"\\n\";\r\n}\r\n\r\nclass btrie{\r\npublic:\r\n\tnode* head = new node;\r\n\tvoid insert(int x){\r\n\t\tvector<int> v = binary(x);\r\n\t\tnode* temp = head;\r\n\t\tfor(int i=0;i<v.size();i++){\r\n\t\t\tif(v[i] == 0){\r\n\t\t\t\tif(temp->left == NULL){\r\n\t\t\t\t\tnode* n = new node;\r\n\t\t\t\t\ttemp->left = n;\r\n\t\t\t\t\ttemp = n;\r\n\t\t\t\t}\r\n\t\t\t\telse temp = temp->left;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(temp->right == NULL){\r\n\t\t\t\t\tnode* n = new node;\r\n\t\t\t\t\ttemp->right = n;\r\n\t\t\t\t\ttemp = n;\r\n\t\t\t\t}\r\n\t\t\t\telse temp = temp->right;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvector<int> binary(int x){\r\n\t\tvector<int> ans;\r\n\t\twhile(x){\r\n\t\t\tans.push_back(x%2);\r\n\t\t\tx /= 2;\r\n\t\t}\r\n\t\tfor(int i=ans.size()+1;i<=18;i++){\r\n\t\t\tans.push_back(0);\r\n\t\t}\r\n\t\treverse(ans.begin(),ans.end());\r\n\t\treturn ans;\r\n\t}\r\n};\r\n\r\nll power(ll a,ll b){\r\n\tif(b==0) return 1;\r\n\tif(b==1) return a%N;\r\n\tll res = power(a,b/2);\r\n\tif(b%2==0){\r\n\t\tll ans = (res%N) * (res%N);\r\n\t\treturn ans%N;\r\n\t}\r\n\tll ans = (res%N)*(res%N);\r\n\tans%=N;\r\n\tans = (ans*(a%N))%N;\r\n\treturn ans%N;\r\n}\r\n\r\n//Fib(2k) = Fib(k)*(2*Fib(k+1) - Fib(k))\r\n//Fib(2k+1) = Fib(k+1)**2 + Fib(k)**2\r\n//pair{Fib(2k) , Fib(2*k+1)}\r\npair<long,long> Fib(long n,vector<long> v){\r\n    if(n==0) return {0,1};\r\n    if(n==1) return {1,1};\r\n    if(v[n] != 0) return {v[n],v[n-1]+v[n]};\r\n    pair<long,long> a = Fib(n/2,v);\r\n    long x = a.first*(2*a.second - a.first);\r\n    long y = a.first*a.first + a.second*a.second;\r\n    if(n%2) return {y,y+x};\r\n    else return {x,y};\r\n}\r\n\r\nvector<ll> sieve(ll n){\r\n\tvector<ll> v(n+1,1);\r\n\tv[0]=0;\r\n\tv[1]=0;\r\n\tfor(ll i=2;i<=n;i++){\r\n\t\tif(v[i] == 1){\r\n\t\t\tfor(ll j=2*i;j<=n;j+=i){\r\n\t\t\t\tv[j]=0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n//Number of llegers from 1 to i that are co prime to i.\r\nvector<ll> euler_totient_1_to_n(ll n){\r\n\tvector<ll> v(n+1);\r\n\tfor(ll i=0;i<=n;i++){\r\n\t\tv[i] = i;\r\n\t}\r\n\tfor(ll i=2;i<=n;i++){\r\n\t\tif(v[i]==i){\r\n\t\t\tv[i] = i-1;\r\n\t\t\tfor(ll j=i*2;j<=n;j+=i){\r\n\t\t\t\tv[j] -= v[j]/i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nll phi(ll n){\t\t\t//phi(n) = n*(1 - 1/p1)*(1 - 1/p2)....*(1 - 1/pk), p1,p2.. are prime factors of n\r\n\tll cnt=n;\r\n\tfor(ll i=2;i*i<=n;i++){\r\n\t\tif(n%i == 0){\r\n\t\t\tcnt -= cnt/i;\r\n\t\t\twhile(n%i==0){\r\n\t\t\t\tn/=i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(n>=2) cnt -= cnt/n;\r\n\treturn cnt;\r\n}\r\n\r\nbool prime_check(ll n){\r\n\tif(n==1) return false;\r\n\tfor(ll i=2;i*i<=n;i++){\r\n\t\tif(n%i == 0) return false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nll check(ll i,ll j,ll n,ll m){\r\n\treturn i>=0 && i<n && j>=0 && j<m;\r\n}\r\n\r\nll lcm(ll a,ll b){\r\n\treturn min(a,b)*(max(a,b)/__gcd(a,b));\r\n}\r\n\r\n\r\nll modInverse(ll A,ll M){\r\n\tll m0 = M;\r\n\tll y=0,x=1;\r\n\tif(M==1){\r\n\t\treturn 0;\r\n\t}\r\n\r\n\twhile(A>1){\r\n\t\tll q = A/M;\r\n\t\tll t=M;\r\n\r\n\t\tM=A%M,A=t;\r\n\t\tt=y;\r\n\r\n\t\ty=x-q*y;\r\n\t\tx=t;\r\n\t}\r\n\tif(x<0) return x+=m0;\r\n\r\n\treturn x;\r\n}\r\n\r\nll find(vector<pair<ll,ll>> &v,ll x){\r\n\tll l=0,h=v.size()-1;\r\n\twhile(h>=l){\r\n\t\tll mid = (l+h)/2;\r\n\t\tll first = v[mid].first;\r\n\t\tif(first == x) return mid;\r\n\t\telse if(first < x) l = mid+1;\r\n\t\telse{\r\n\t\t\tif(mid==0 || x >= v[mid-1].first) return mid;\r\n\t\t\telse h = mid-1;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nvoid print(ll a[],ll l,ll h){\r\n\tfor(ll i=l;i<h;i++){\r\n\t\tcout<<a[i]<<\" \";\r\n\t}\r\n\tcout<<\"\\n\";\r\n}\r\n\r\nvoid print_set(set<ll> s){\r\n\tfor(auto i : s){\r\n\t\tcout<<i<<\" \";\r\n\t}\r\n\tcout<<\"\\n\";\r\n}\r\n\r\nbool palindrome_check(string a){\r\n\tfor(int i=0;2*i<a.size();i++){\r\n\t\tif(a[i] != a[a.size() - i - 1]) return false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nvoid bfs(vector<int> v[],int start_node, int visited[]){\r\n\tqueue<int> q;\r\n\tq.push(start_node);\r\n\tvisited[start_node] = 1;\r\n\twhile(!q.empty()){\r\n\t\tint front = q.front();\r\n\t\tq.pop();\r\n\t\tfor(auto i : v[front]){\r\n\t\t\tif(visited[front] == 0){\r\n\t\t\t\tq.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid dfs(vector<int> v[], int node,int visited[]){\r\n\tfor(auto i : v[node]){\r\n\t\tif(visited[i] == 0){\r\n\t\t\tvisited[i] = 1;\r\n\t\t\tdfs(v, i, visited);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvector<int> prime_factors(int n){\r\n\tvector<int> ans;\r\n\tfor(int i=2;i*i<=n;i++){\r\n\t\twhile(n%i == 0){\r\n\t\t\tans.push_back(i);\r\n\t\t\tn/=i;\r\n\t\t}\r\n\t}\r\n\tif(n>=2) ans.push_back(n);\r\n\treturn ans;\r\n}\r\n\r\n\r\nstring string_add(string a, string b){\r\n\tstring ans = \"\";\r\n\tint index1 = a.size()-1, index2 = b.size()-1;\r\n\tint carry = 0;\r\n\twhile(index1>=0 && index2>=0){\r\n\t\tint h = (a[index1] - '0') + (b[index2] - '0') + carry;\r\n\t\tcarry = h/10;\r\n\t\tchar c = ('0' + (h%10));\r\n\t\tans = c + ans;\r\n\t\tindex1--;\r\n\t\tindex2--;\r\n\t}\r\n\twhile(index1>=0){\r\n\t\tint h = (a[index1] - '0') + carry;\r\n\t\tcarry = h/10;\r\n\t\tchar c = ('0' + (h%10));\r\n\t\tans = c + ans;\r\n\t\tindex1--;\r\n\t}\r\n\twhile(index2>=0){\r\n\t\tint h = (b[index2] - '0') + carry;\r\n\t\tcarry = h/10;\r\n\t\tchar c = ('0' + (h%10));\r\n\t\tans = c + ans;\r\n\t\tindex2--;\r\n\t}\r\n\tif(carry > 0){\r\n\t\tchar c = '0' + carry;\r\n\t\tans = c + ans;\r\n\t}\r\n\treturn ans;\r\n}\r\n\r\nll gcd(ll a, ll b){\r\n\treturn b ? gcd(b,a%b) : a;\r\n}\r\n\r\nll extended_gcd(ll a, ll b, ll& x, ll& y){\r\n\tif(b == 0){\r\n\t\tx = 1;\r\n\t\ty = 0;\r\n\t\treturn a;\r\n\t}\r\n\tll x1=0,y1=0;\r\n\tll g = extended_gcd(b,a%b,x1,y1);\r\n\tx = y1;\r\n\ty = x1 - y1*(a/b);\r\n\treturn g;\r\n}\r\n\r\nbool find_solution(ll &a, ll &b, ll &c, ll &x, ll &y){\r\n\tll g = extended_gcd(abs(a),abs(b),x,y);\r\n\tif(c%extended_gcd(abs(a),abs(b),x,y) != 0) return false;\r\n\tx *= (c/g);\r\n\ty *= (c/g);\r\n\tif(a<0) x *= -1;\r\n\tif(b<0) y *= -1;\r\n\treturn true;\r\n}\r\n\r\nll exponent(ll a, ll b){\r\n\tll cnt = 0;\r\n\tll x = b;\r\n\twhile((a/x) != 0){\r\n\t\tcnt += (a/x);\r\n\t\tx *= b;\r\n\t}\r\n\treturn cnt;\r\n}\r\n\r\nbool adjacent(ll n){\r\n\tll prev = -1;\r\n\twhile(n){\r\n\t\tif(prev == n%10) return false;\r\n\t\tprev = n%10;\r\n\t\tn /= 10;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nvoid solve(){\r\n\tll n;\r\n\tcin>>n;\r\n\tll a[n],b[n];\r\n\tfor(ll i=0;i<n;i++){\r\n\t\tcin>>a[i];\r\n\t}\r\n\tll total = 0;\r\n\tfor(ll i=0;i<n;i++){\r\n\t\tcin>>b[i];\r\n\t\ttotal += a[i]*b[i];\r\n\t}\r\n\tll dp[n+1][n+1] = {};\r\n\tfor(ll i=1;i<=n;i++){\r\n\t\tdp[i][i] = total;\r\n\t}\r\n\tll mmax = total;\r\n\tfor(ll i=1;i<n;i++){\r\n\t\tdp[i][i+1] = total - a[i-1]*b[i-1] - a[i-1+1]*b[i-1+1] + a[i-1]*b[i-1+1] + a[i-1+1]*b[i-1];\r\n\t\tmmax = max(mmax,dp[i][i+1]);\r\n\t}\r\n\tfor(ll sum=2;sum<=n-1;sum++){\r\n\t\tfor(ll i=1;i<=n;i++){\r\n\t\t\tll j = sum + i;\r\n\t\t\tif(j>n) break;\r\n\t\t\tdp[i][j] = dp[i+1][j-1] + a[i-1]*b[j-1] + a[j-1]*b[i-1] - a[i-1]*b[i-1] - a[j-1]*b[j-1];\r\n\t\t\tmmax = max(mmax,dp[i][j]);\r\n\t\t}\r\n\t}\r\n\tcout<<mmax;\r\n}\r\n\r\nint main(){\r\n\tauto start_time = high_resolution_clock::now();\r\n\tios_base::sync_with_stdio(false);\t//Prevents synchronisation of c++ stream from c stream.\r\n\tcin.tie(NULL);\t\t//Method that flush std::cout before std::cin.\r\n\tcout.tie(NULL);\t\t//Method that flush std::cin before std::cout.\r\n\t\r\n\tll tc=1;\r\n\t// cin>>tc;\r\n\twhile(tc--){\r\n\t\tsolve();\r\n\t}\r\n\tauto stop_time = high_resolution_clock::now();\r\n\tauto duration = duration_cast<milliseconds>(stop_time - start_time);\r\n\t// cout<<\"\\nDURATION: \"<<duration.count()<<\"ms\";\r\n}\r\n"
}