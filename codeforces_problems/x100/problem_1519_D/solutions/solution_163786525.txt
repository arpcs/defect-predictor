{
    "id": 163786525,
    "contestId": 1519,
    "creationTimeSeconds": 1657625702,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1519,
        "index": "D",
        "name": "Maximum Sum of Products",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "math",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1519,
        "members": [
            {
                "handle": "gaju_01"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1619706900
    },
    "programmingLanguage": "Java 11",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 171,
    "memoryConsumedBytes": 0,
    "source": "import java.io.*;\r\nimport java.lang.Math;\r\nimport java.util.*;\r\nimport javax.print.attribute.standard.MediaSize.Engineering;\r\n\r\npublic final class Codechef {\r\n\r\n  static BufferedReader br = new BufferedReader(\r\n    new InputStreamReader(System.in)\r\n  );\r\n  static BufferedWriter bw = new BufferedWriter(\r\n    new OutputStreamWriter(System.out)\r\n  );\r\n  static StringTokenizer st;\r\n  static int mod = 1000000000;\r\n\r\n  /*write your constructor and global variables here*/\r\n\r\n  static class sortCond implements Comparator<Pair<Integer, Integer>> {\r\n\r\n    @Override\r\n    public int compare(Pair<Integer, Integer> p1, Pair<Integer, Integer> p2) {\r\n      if (p1.a <= p2.a) {\r\n        return -1;\r\n      } else {\r\n        return 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  static class sortCond1 implements Comparator<Integer> {\r\n\r\n    @Override\r\n    public int compare(Integer p1, Integer p2) {\r\n      if (p1 <= p2) {\r\n        return 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    }\r\n  }\r\n\r\n  static class Rec {\r\n\r\n    int a;\r\n    int b;\r\n    long c;\r\n\r\n    Rec(int a, int b, long c) {\r\n      this.a = a;\r\n      this.b = b;\r\n      this.c = c;\r\n    }\r\n  }\r\n\r\n  static class Pair<f, s> {\r\n\r\n    f a;\r\n    s b;\r\n\r\n    Pair(f a, s b) {\r\n      this.a = a;\r\n      this.b = b;\r\n    }\r\n  }\r\n\r\n  interface modOperations {\r\n    int mod(int a, int b, int mod);\r\n  }\r\n\r\n  static int findBinaryExponentian(int a, int pow, int mod) {\r\n    if (pow == 1) {\r\n      return a;\r\n    } else if (pow == 0) {\r\n      return 1;\r\n    } else {\r\n      int retVal = findBinaryExponentian(a, (int) pow / 2, mod);\r\n      int val = (pow % 2 == 0) ? 1 : a;\r\n      return modMul.mod(modMul.mod(retVal, retVal, mod), val, mod);\r\n    }\r\n  }\r\n\r\n  static int findPow(int a, int b, int mod) {\r\n    if (b == 1) {\r\n      return a % mod;\r\n    } else if (b == 0) {\r\n      return 1;\r\n    } else {\r\n      int res = findPow(a, (int) b / 2, mod);\r\n      return modMul.mod(res, modMul.mod(res, (b % 2 == 1 ? a : 1), mod), mod);\r\n    }\r\n  }\r\n\r\n  static int bleft(int ele, int[] arr) {\r\n    int l = 0;\r\n    int h = arr.length - 1;\r\n    int ans = -1;\r\n    while (l <= h) {\r\n      int mid = l + (int) (h - l) / 2;\r\n      int val = arr[mid];\r\n      if (ele > val) {\r\n        l = mid + 1;\r\n      } else if (ele < val) {\r\n        h = mid - 1;\r\n      } else {\r\n        ans = mid;\r\n        h = mid - 1;\r\n      }\r\n    }\r\n    return ans;\r\n  }\r\n\r\n  static int gcd(int a, int b) {\r\n    int div = b;\r\n    int rem = a % b;\r\n    while (rem != 0) {\r\n      int temp = rem;\r\n      rem = div % rem;\r\n      div = temp;\r\n    }\r\n    return div;\r\n  }\r\n\r\n  static long[] log(long no, long n) {\r\n    long i = 1;\r\n    int cnt = 0;\r\n    long sum = 0l;\r\n    long arr[] = new long[2];\r\n    while (i < no) {\r\n      sum += i;\r\n      cnt++;\r\n      if (sum == n) {\r\n        arr[0] = 1l * cnt;\r\n        arr[1] = sum;\r\n        break;\r\n      }\r\n      i *= 2l;\r\n    }\r\n    if (arr[0] == 0) {\r\n      arr[0] = cnt;\r\n      arr[1] = sum;\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  static modOperations modAdd = (int a, int b, int mod) -> {\r\n    return (a % mod + b % mod) % mod;\r\n  };\r\n  static modOperations modSub = (int a, int b, int mod) -> {\r\n    return (int) ((1l * a % mod - 1l * b % mod + 1l * mod) % mod);\r\n  };\r\n  static modOperations modMul = (int a, int b, int mod) -> {\r\n    return (int) ((1l * (a % mod) * 1l * (b % mod)) % (1l * mod));\r\n  };\r\n  static modOperations modDiv = (int a, int b, int mod) -> {\r\n    return modMul.mod(a, findBinaryExponentian(b, mod - 1, mod), mod);\r\n  };\r\n\r\n  static HashSet<Integer> primeList(int MAXI) {\r\n    int[] prime = new int[MAXI + 1];\r\n    HashSet<Integer> obj = new HashSet<>();\r\n    for (int i = 2; i <= (int) Math.sqrt(MAXI) + 1; i++) {\r\n      if (prime[i] == 0) {\r\n        obj.add(i);\r\n        for (int j = i * i; j <= MAXI; j += i) {\r\n          prime[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    for (int i = (int) Math.sqrt(MAXI) + 1; i <= MAXI; i++) {\r\n      if (prime[i] == 0) {\r\n        obj.add(i);\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  static int[] factorialList(int MAXI, int mod) {\r\n    int[] factorial = new int[MAXI + 1];\r\n    factorial[0] = factorial[1] = 1;\r\n    factorial[2] = 2;\r\n    for (int i = 3; i < MAXI + 1; i++) {\r\n      factorial[i] = modMul.mod(factorial[i - 1], i, mod);\r\n    }\r\n    return factorial;\r\n  }\r\n\r\n  static void put(HashMap<Integer, Integer> cnt, int key) {\r\n    if (cnt.containsKey(key)) {\r\n      cnt.replace(key, cnt.get(key) + 1);\r\n    } else {\r\n      cnt.put(key, 1);\r\n    }\r\n  }\r\n\r\n  static long arrSum(ArrayList<Long> arr) {\r\n    long tot = 0;\r\n    for (int i = 0; i < arr.size(); i++) {\r\n      tot += arr.get(i);\r\n    }\r\n    return tot;\r\n  }\r\n\r\n  static int ord(char b) {\r\n    return (int) b - (int) 'a';\r\n  }\r\n\r\n  static int optimSearch(int[] cnt, int lower_bound, int pow, int n) {\r\n    int l = lower_bound + 1;\r\n    int h = n;\r\n    int ans = 0;\r\n    while (l <= h) {\r\n      int mid = l + (h - l) / 2;\r\n      if (cnt[mid] - cnt[lower_bound] == pow) {\r\n        return mid;\r\n      } else if (cnt[mid] - cnt[lower_bound] < pow) {\r\n        ans = mid;\r\n        l = mid + 1;\r\n      } else {\r\n        h = mid - 1;\r\n      }\r\n    }\r\n    return ans;\r\n  }\r\n\r\n  static Pair<Long, Integer> ret_ans(ArrayList<Integer> ans) {\r\n    int size = ans.size();\r\n    int mini = 1000000000 + 1;\r\n    long tit = 0l;\r\n    for (int i = 0; i < size; i++) {\r\n      tit += 1l * ans.get(i);\r\n      mini = Math.min(mini, ans.get(i));\r\n    }\r\n    return new Pair<>(tit - mini, mini);\r\n  }\r\n\r\n  static int factorList(\r\n    HashMap<Integer, Integer> maps,\r\n    int no,\r\n    int maxK,\r\n    int req\r\n  ) {\r\n    int i = 1;\r\n    while (i * i <= no) {\r\n      if (no % i == 0) {\r\n        if (i != no / i) {\r\n          put(maps, no / i);\r\n        }\r\n        put(maps, i);\r\n        if (maps.get(i) == req) {\r\n          maxK = Math.max(maxK, i);\r\n        }\r\n        if (maps.get(no / i) == req) {\r\n          maxK = Math.max(maxK, no / i);\r\n        }\r\n      }\r\n      i++;\r\n    }\r\n    return maxK;\r\n  }\r\n\r\n  static ArrayList<Integer> getKeys(HashMap<Integer, Integer> maps) {\r\n    ArrayList<Integer> vals = new ArrayList<>();\r\n    for (Map.Entry<Integer, Integer> map : maps.entrySet()) {\r\n      vals.add(map.getKey());\r\n    }\r\n    return vals;\r\n  }\r\n\r\n  static ArrayList<Integer> getValues(HashMap<Integer, Integer> maps) {\r\n    ArrayList<Integer> vals = new ArrayList<>();\r\n    for (Map.Entry<Integer, Integer> map : maps.entrySet()) {\r\n      vals.add(map.getValue());\r\n    }\r\n    return vals;\r\n  }\r\n\r\n  static int getMax(ArrayList<Integer> arr) {\r\n    int max = arr.get(0);\r\n    for (int i = 1; i < arr.size(); i++) {\r\n      if (arr.get(i) > max) {\r\n        max = arr.get(i);\r\n      }\r\n    }\r\n    return max;\r\n  }\r\n\r\n  static int getMin(ArrayList<Integer> arr) {\r\n    int max = arr.get(0);\r\n    for (int i = 1; i < arr.size(); i++) {\r\n      if (arr.get(i) < max) {\r\n        max = arr.get(i);\r\n      }\r\n    }\r\n    return max;\r\n  }\r\n\r\n  static void bitRep(int n, int no) throws IOException {\r\n    int curr = (int) Math.pow(2, n - 1);\r\n    for (int i = n - 1; i >= 0; i--) {\r\n      if ((curr & no) != 0) {\r\n        bw.write(\"1\");\r\n      } else {\r\n        bw.write(\"0\");\r\n      }\r\n      curr /= 2;\r\n    }\r\n    bw.write(\"\\n\");\r\n  }\r\n\r\n  static ArrayList<Integer> retPow(int MAXI) {\r\n    long curr = 1l;\r\n    ArrayList<Integer> arr = new ArrayList<>();\r\n    for (int i = 1; i <= MAXI; i++) {\r\n      curr *= 2l;\r\n      curr = curr % mod;\r\n      arr.add((int) curr);\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  static String is(int no) {\r\n    return Integer.toString(no);\r\n  }\r\n\r\n  static String ls(long no) {\r\n    return Long.toString(no);\r\n  }\r\n\r\n  static int pi(String s) {\r\n    return Integer.parseInt(s);\r\n  }\r\n\r\n  static long pl(String s) {\r\n    return Long.parseLong(s);\r\n  }\r\n\r\n  /*write your  methods and classes here*/\r\n\r\n  public static void main(String[] args) throws IOException {\r\n    int cases = 1, n, i, j;\r\n    int a[] = new int[5000];\r\n    int b[] = new int[5000];\r\n    while (cases-- != 0) {\r\n      n = pi(br.readLine());\r\n      st = new StringTokenizer(br.readLine());\r\n      for (i = 0; i < n; i++) {\r\n        a[i] = pi(st.nextToken());\r\n      }\r\n      st = new StringTokenizer(br.readLine());\r\n      for (i = 0; i < n; i++) {\r\n        b[i] = pi(st.nextToken());\r\n      }\r\n      int low = 1;\r\n      int high = 1;\r\n      long MAXI = 0l;\r\n      for (i = 0; i < n; i++) {\r\n        int l = i;\r\n        int h = i + 1;\r\n        long tot = 0l;\r\n        long tot1 = 0l;\r\n        for (; l >= 0 && h <= n - 1; l--, h++) {\r\n          tot += 1l * (a[l] * b[h]);\r\n          tot += 1l * (a[h] * b[l]);\r\n          tot1 += 1l * (a[l] * b[l]);\r\n          tot1 += 1l * (a[h] * b[h]);\r\n          if (tot - tot1 >= MAXI) {\r\n            low = l;\r\n            high = h;\r\n            MAXI = tot - tot1;\r\n          }\r\n        }\r\n        l = i - 1;\r\n        h = i + 1;\r\n        tot = 1l * a[i] * b[i];\r\n        tot1 = 1l * a[i] * b[i];\r\n        for (; l >= 0 && h <= n - 1; l--, h++) {\r\n          tot += 1l * (a[l] * b[h]);\r\n          tot += 1l * (a[h] * a[l]);\r\n          tot1 += 1l * (a[l] * b[l]);\r\n          tot1 += 1l * (a[h] * b[h]);\r\n          if (tot - tot1 >= MAXI) {\r\n            low = l;\r\n            high = h;\r\n            MAXI = tot - tot1;\r\n          }\r\n        }\r\n      }\r\n      int li = low;\r\n      int hi = high;\r\n      for (li = low, hi = high; li < hi; li++, hi--) {\r\n        int temp = a[li];\r\n        a[li] = a[hi];\r\n        a[hi] = temp;\r\n      }\r\n      long tot = 0l;\r\n      for (i = 0; i < n; i++) {\r\n        tot += 1l * a[i] * b[i];\r\n      }\r\n      bw.write(ls(tot) + \"\\n\");\r\n    }\r\n    bw.flush();\r\n  }\r\n}\r\n"
}