{
    "id": 200574672,
    "contestId": 1519,
    "creationTimeSeconds": 1680531487,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1519,
        "index": "D",
        "name": "Maximum Sum of Products",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "math",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1519,
        "members": [
            {
                "handle": "Amay12"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1619706900
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 77,
    "memoryConsumedBytes": 1228800,
    "source": "from bisect import bisect_left, bisect_right\r\nimport os\r\nfrom operator import indexOf\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nfrom random import randint\r\n \r\nfrom collections import *\r\nfrom heapq import *\r\n \r\nfrom random import getrandbits\r\nimport math \r\nRANDOM = getrandbits(32)\r\nfrom itertools import combinations\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM \r\n \r\n# fast io\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n \r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n#some nice functions \r\ndef inpv():\r\n    return(int(input()))\r\ndef inplt():\r\n    return(list(map(int,input().split())))\r\ndef insr():\r\n    s = input()\r\n    return(list(s[:len(s) ]))\r\ndef invr():\r\n    return(map(int,input().split()))\r\n \r\n \r\nfrom itertools import combinations\r\n \r\ndef dtb(n):\r\n    return format(n, 'b')\r\ndef btd(n):\r\n    return int(n, 2)\r\n \r\n \r\n# Python3 program to find element\r\n# closest to given target using binary search.\r\n \r\n# Returns element closest to target in arr[]\r\nclass FenwickTree:\r\n    def __init__(self, x):\r\n        \"\"\"transform list into BIT\"\"\"\r\n        self.bit = x\r\n        for i in range(len(x)):\r\n            j = i | (i + 1)\r\n            if j < len(x):\r\n                x[j] += x[i]\r\n \r\n    def update(self, idx, x):\r\n        \"\"\"updates bit[idx] += x\"\"\"\r\n        while idx < len(self.bit):\r\n            self.bit[idx] += x\r\n            idx |= idx + 1\r\n \r\n    def query(self, end):\r\n        \"\"\"calc sum(bit[:end])\"\"\"\r\n        x = 0\r\n        while end:\r\n            x += self.bit[end - 1]\r\n            end &= end - 1\r\n        return x\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n# Iterative Binary Search Function\r\n# It returns index of x in given array arr if present,\r\n# else returns -1\r\ndef binary_search(arr, x):\r\n    low = 1\r\n    high = n\r\n    mid = 0\r\n \r\n    while low <= high:\r\n \r\n        mid = (high + low) // 2\r\n \r\n        # If x is greater, ignore left half\r\n        if arr[mid] < x:\r\n            low = mid + 1\r\n \r\n        # If x is smaller, ignore right half\r\n        elif arr[mid] > x:\r\n            high = mid - 1\r\n \r\n        # means x is present at mid\r\n        else:\r\n            return True\r\n \r\n    # If we reach here, then the element was not present\r\n    return False\r\n \r\ndef sfun(a, b, c, d):\r\n   \r\n    # If a is equal to c\r\n    if (a == c):\r\n        return a\r\n \r\n    # If a exceeds c\r\n    if (a > c):\r\n        swap(a, c)\r\n        swap(b, d)\r\n \r\n    first_term_diff = (c - a)\r\n    possible_y = 0\r\n \r\n    \r\n    for possible_y in range(b):\r\n \r\n        \r\n        if ((first_term_diff % b +\r\n             possible_y * d) % b == 0):\r\n            break\r\n \r\n    \r\n    if (possible_y != b):\r\n        return c + possible_y * d\r\n \r\n   \r\n    return -1\r\n \r\n \r\ndef gcd(a,b):\r\n    if a == 0:\r\n        return b\r\n    return gcd(b % a, a)\r\n \r\n# Function to return LCM of two numbers\r\ndef lcm(a,b):\r\n    return (a // gcd(a,b))* b     \r\ndef sub(n):\r\n    if(n==1):\r\n        return 1\r\n    return (n*(n+1))//2 +n \r\n \r\n \r\n \r\ndef subfun(A):\r\n        B=0\r\n        visited = {}\r\n        cpx = 0\r\n        c = 0\r\n        for i in range(len(A)):\r\n            cpx ^= A[i]\r\n            if cpx == B:\r\n                c += 1\r\n            h = cpx ^ B\r\n            if h in visited:\r\n                c += visited[h]\r\n            visited[cpx] = visited.get(cpx, 0) + 1\r\n        return c\r\n \r\n \r\n \r\ndef findRoots(a, b, c):\r\n \r\n    if a == 0:        \r\n        return -1\r\n        \r\n    d = (b*b)-(4*a*c)\r\n    \r\n \r\n    if d >= 0:\r\n        return 0\r\n    \r\n    else:  # d<0\r\n        return 1\r\ndef findClosest(arr, n, target):\r\n \r\n    # Corner cases\r\n    if (target <= arr[0]):\r\n        return arr[0]\r\n    if (target >= arr[n - 1]):\r\n        return arr[n - 1]\r\n \r\n    # Doing binary search\r\n    i = 0; j = n; mid = 0\r\n    while (i < j):\r\n        mid = (i + j) // 2\r\n \r\n        if (arr[mid] == target):\r\n            return arr[mid]\r\n \r\n        # If target is less than array\r\n        # element, then search in left\r\n        if (target < arr[mid]) :\r\n \r\n            # If target is greater than previous\r\n            # to mid, return closest of two\r\n            if (mid > 0 and target > arr[mid - 1]):\r\n                return getClosest(arr[mid - 1], arr[mid], target)\r\n \r\n            # Repeat for left half\r\n            j = mid\r\n         \r\n        # If target is greater than mid\r\n        else :\r\n            if (mid < n - 1 and target < arr[mid + 1]):\r\n                return getClosest(arr[mid], arr[mid + 1], target)\r\n                 \r\n            # update i\r\n            i = mid + 1\r\n         \r\n    # Only single element left after search\r\n    return arr[mid]\r\ndef getClosest(val1, val2, target):\r\n \r\n    if (target - val1 >= val2 - target):\r\n        return val2\r\n    else:\r\n        return val1\r\nfrom itertools import accumulate   \r\nn = inpv()\r\na = inplt()\r\nb = inplt()\r\n \r\n\r\nc = [a[i] * b[i] for i in range(n)] \r\n\r\nans = c[-1] \r\nc=list(accumulate(c, initial = 0))\r\n\r\nfor i in range(n):\r\n    \r\n    cur = a[i] * b[i]\r\n    l, r = i - 1, i + 1\r\n    while l >= 0 and r < n:\r\n        cur += a[l] * b[r]\r\n        cur += a[r] * b[l]\r\n        ans = max(ans, cur + c[l] + (c[n] - c[r + 1]))\r\n        l,r=l-1,r+1    \r\n    cur = 0\r\n    l, r = i, i + 1\r\n    while l >= 0 and r < n:\r\n        cur += a[l] * b[r]\r\n        cur += a[r] * b[l]\r\n        ans = max(ans, cur + c[l] + (c[n] - c[r + 1]))\r\n        l,r=l-1,r+1\r\n \r\nprint(ans)\r\n \r\n \r\n \r\n \r\n \r\n \r\n        \r\n        "
}