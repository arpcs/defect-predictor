{
    "id": 212045018,
    "contestId": 1519,
    "creationTimeSeconds": 1688457148,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1519,
        "index": "D",
        "name": "Maximum Sum of Products",
        "type": "PROGRAMMING",
        "rating": 1600,
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "math",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1519,
        "members": [
            {
                "handle": "ahemjoonie"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1619706900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 8,
    "timeConsumedMillis": 155,
    "memoryConsumedBytes": 268390400,
    "source": "/// ------------------------------------OPTIMIZATIONS--------------------------------------- ///\n \n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n \n \n/// ------------------------------------HEADER-FILES---------------------------------------- ///\n#include <bits/stdc++.h>\n \n/// ------------------------------------NAMESPACES------------------------------------------ ///\nusing namespace std;\n \n/// ------------------------------------DEFINING-MYWAY-------------------------------------- ///\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\ntypedef map<int,int> m32;\ntypedef map<ll,ll> m64;\ntypedef multimap<int,int> mm32;\ntypedef multimap<ll,ll> mm64;\n \n \nll MOD = 998244353;\nll mod = 1000000007;\ndouble eps = 1e-12;\n \ndouble pi = acos(-1);\n \n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e18\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n \n/// ----------------------------------------TRACING------------------------------------- ///\n \n#ifndef ONLINE_JUDGE\n \ntemplate<typename T>\nvoid __p(T a) {\n    cout<<a;\n}\ntemplate<typename T, typename F>\nvoid __p(pair<T, F> a) {\n    cout<<\"{\";\n    __p(a.first);\n    cout<<\",\";\n    __p(a.second);\n    cout<<\"}\";\n}\ntemplate<typename T>\nvoid __p(std::vector<T> a) {\n    cout<<\"{\";\n    for(auto it=a.begin(); it<a.end(); it++)\n        __p(*it),cout<<\",}\"[it+1==a.end()];\n}\ntemplate<typename T>\nvoid __p(std::set<T> a) {\n    cout<<\"{\";\n    for(auto it=a.begin(); it!=a.end();){\n        __p(*it);\n        cout<<\",}\"[++it==a.end()];\n    }\n \n}\ntemplate<typename T>\nvoid __p(std::multiset<T> a) {\n    cout<<\"{\";\n    for(auto it=a.begin(); it!=a.end();){\n        __p(*it);\n        cout<<\",}\"[++it==a.end()];\n    }\n}\ntemplate<typename T, typename F>\nvoid __p(std::map<T,F> a) {\n    cout<<\"{\\n\";\n    for(auto it=a.begin(); it!=a.end();++it)\n    {\n        __p(it->first);\n        cout << \": \";\n        __p(it->second);\n        cout<<\"\\n\";\n    }\n    cout << \"}\\n\";\n}\n \ntemplate<typename T, typename ...Arg>\nvoid __p(T a1, Arg ...a) {\n    __p(a1);\n    __p(a...);\n}\ntemplate<typename Arg1>\nvoid __f(const char *name, Arg1 &&arg1) {\n    cout<<name<<\" : \";\n    __p(arg1);\n    cout<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char *names, Arg1 &&arg1, Args &&... args) {\n    int bracket=0,i=0;\n    for(;; i++)\n        if(names[i]==','&&bracket==0)\n            break;\n        else if(names[i]=='(')\n            bracket++;\n        else if(names[i]==')')\n            bracket--;\n    const char *comma=names+i;\n    cout.write(names,comma-names)<<\" : \";\n    __p(arg1);\n    cout<<\" | \";\n    __f(comma+1,args...);\n}\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \", __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...)\n#define error(...)\n#endif\n \n/// ----------------------------------------- MATHS ------------------------------------- ///\n \nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\n#define SHUF(v) shuffle(all(v), RNG);\n \ntemplate<typename T> T gcd(T a, T b){return(b?__gcd(a,b):a);}\n \n \ntemplate<typename T> T lcm(T a, T b){return(a*(b/gcd(a,b)));}\n \n \nint add(int a, int b, int c = MOD){int res=a+b;return(res>=c?res-c:res);}\n \nint mod_neg(int a, int b, int c = MOD){int res;if(abs(a-b)<c)res=a-b;else res=(a-b)%c;return(res<0?res+c:res);}\n \nint mul(int a, int b, int c = MOD){ll res=(ll)a*b;return(res>=c?res%c:res);}\n \nint muln(int a, int b, int c = MOD){ll res=(ll)a*b;return ((res%c)+c)%c;}\n \nll mulmod(ll a,ll b, ll m = MOD){ll q = (ll)(((ld)a*(ld)b)/(ld)m);ll r=a*b-q*m;if(r>m)r%=m;if(r<0)r+=m;return r;}\n \ntemplate<typename T>T expo(T e, T n){T x=1,p=e;while(n){if(n&1)x=x*p;p=p*p;n>>=1;}return x;}\n \ntemplate<typename T>T power(T e, T n, T m = MOD){T x=1,p=e;while(n){if(n&1)x=mul(x,p,m);p=mul(p,p,m);n>>=1;}return x;}\n \ntemplate<typename T>T extended_euclid(T a, T b, T &x, T &y){T xx=0,yy=1;y=0;x=1;while(b){T q=a/b,t=b;b=a%b;a=t;\\\nt=xx;xx=x-q*xx;x=t;t=yy;yy=y-q*yy;y=t;}return a;}\n \ntemplate<typename T>T mod_inverse(T a, T n = MOD){T x,y,z=0;T d=extended_euclid(a,n,x,y);return(d>1?-1:mod_neg(x,z,n));}\n \nconst int FACSZ = 1; // Make sure to change this\n \nint fact[FACSZ],ifact[FACSZ];\n \nvoid precom(int c = MOD){\n    fact[0] = 1;\n    forsn(i,1,FACSZ) fact[i] = mul(fact[i-1],i,c);\n    ifact[FACSZ-1] = mod_inverse(fact[FACSZ-1],c);\n    forn(i,FACSZ-1){\n        ifact[i] = mul(i+1,ifact[i+1],c);\n    }\n}\n \nint ncr(int n,int r,int c = MOD){\n    return mul(mul(ifact[r],ifact[n-r],c),fact[n],c);\n}\n \n \n/// ----------------------------------------------MATHS----------------------------------------------- ///\n// int main() {\n//     ios_base::sync_with_stdio(false);\n//     cin.tie(nullptr);\n//     int T; cin >> T;\n//     for (auto case_num = 1; case_num <= T; ++ case_num) {\n//         int N; cin >> N;\n//         auto ans = 0;\n//         std::cout >> std::fixed;\n//         cout >> std::setprecision(8);\n//         cout << \"Case #\" << case_num << \": \" << ans << endl;\n//     }\n//     return 0;\n// }\n \n/// ----------------------------------------------KICKSTART----------------------------------------------- ///\nll _mergeSort(int arr[], int temp[], int left, int right);\nll merge(int arr[], int temp[], int left, int mid,\n          int right);\n \n/* This function sorts the\n   input array and returns the\nnumber of inversions in the array */\nll mergeSort(int arr[], int array_size)\n{\n    int temp[array_size];\n    return _mergeSort(arr, temp, 0, array_size - 1);\n}\n \n/* An auxiliary recursive function\n  that sorts the input array and\nreturns the number of inversions in the array. */\nll _mergeSort(int arr[], int temp[], int left, int right)\n{\n    ll mid, inv_count = 0;\n    if (right > left) {\n        /* Divide the array into two parts and\n        call _mergeSortAndCountInv()\n        for each of the parts */\n        mid = (right + left) / 2;\n \n        /* Inversion count will be sum of\n        inversions in left-part, right-part\n        and number of inversions in merging */\n        inv_count += _mergeSort(arr, temp, left, mid);\n        inv_count += _mergeSort(arr, temp, mid + 1, right);\n \n        /*Merge the two parts*/\n        inv_count += merge(arr, temp, left, mid + 1, right);\n    }\n    return inv_count;\n}\n \n/* This funt merges two sorted arrays\nand returns inversion count in the arrays.*/\nll merge(int arr[], int temp[], int left, int mid,\n          int right)\n{\n    ll i, j, k;\n    ll inv_count = 0;\n \n    i = left; /* i is index for left subarray*/\n    j = mid; /* j is index for right subarray*/\n    k = left; /* k is index for resultant merged subarray*/\n    while ((i <= mid - 1) && (j <= right)) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        }\n        else {\n            temp[k++] = arr[j++];\n \n            /* this is tricky -- see above\n            explanation/diagram for merge()*/\n            inv_count = inv_count + (mid - i);\n        }\n    }\n \n    /* Copy the remaining elements of left subarray\n(if there are any) to temp*/\n    while (i <= mid - 1)\n        temp[k++] = arr[i++];\n \n    /* Copy the remaining elements of right subarray\n       (if there are any) to temp*/\n    while (j <= right)\n        temp[k++] = arr[j++];\n \n    /*Copy back the merged elements to original array*/\n    for (i = left; i <= right; i++)\n        arr[i] = temp[i];\n \n    return inv_count;\n}\n\n\n\n\n\nvoid solve()\n{\n    int n;cin>>n;\n    ll a[n],b[n];\n    forn(i,n)cin>>a[i];\n    forn(i,n)cin>>b[i];\n\n    ll dp[n+2][n+2]; // summ ak bk from i to j\n    ll rev[n+2][n+2]; //summ \n\n    memset(dp,0,sizeof(dp));\n    memset(rev,0,sizeof(rev));\n\n    for(int i=1;i<=n;i++){\n        for(int j=i;j<=n;j++){\n            dp[i][j]=dp[i][j-1]+a[j-1]*b[j-1];\n        }\n    } \n\n    for(int di=0;di<=n;di++){\n        for(int i=1;i<=n-di;i++){\n            int j=i+di;\n            if(j>n)continue;\n            if(di==0){\n                rev[i][j]=a[i-1]*b[j-1];\n            }\n            else if(di==1){\n                rev[i][j]=a[i-1]*b[j-1]+a[j-1]*b[i-1];\n            }\n            else\n            rev[i][j]=rev[i+1][j-1]+a[i-1]*b[j-1]+a[j-1]*b[i-1];\n        }\n    } \n\n    ll ma=dp[1][n];\n\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            // cout<<i<<\" \"<<j<<\" \"<<rev[i][j]<<ln;\n            ma=max(ma,dp[1][i-1]+rev[i][j]+dp[j+1][n]);\n        }\n    }\n    cout<<ma;\n\n}\nint main()\n{\n    fast_cin();\n    ll t=1;\n    // cin >> t;\n    for(int it=1;it<=t;it++)\n    {\n        solve();\n    }\n    return 0;\n}"
}