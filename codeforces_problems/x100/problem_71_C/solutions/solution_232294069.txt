{
    "id": 232294069,
    "contestId": 71,
    "creationTimeSeconds": 1699646371,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 71,
        "index": "C",
        "name": "Round Table Knights",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 1600,
        "tags": [
            "dp",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 71,
        "members": [
            {
                "handle": "matheusdacach"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1301410800
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 52,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 819200,
    "source": "// https://codeforces.com/problemset/problem/71/C\npub mod solution {\n\nuse crate::io::input::Input;\nuse crate::io::output::Output;\nuse crate::numbers::primes::factorize::Factorize;\n\ntype PreCalc = ();\n\n// As the polygon must be regular, all of the sides must be of the same length.\n// Because the sides must sum up to N, they must be some divisor of N.\n//\n// There's not many divisors of N (we can use N^1/3 as an upperbound).\n// So if we can solve quickly enough for one given divisor, we are OK.\n//\n// Suppose that you know that each side must be of size K. Then, you must have\n// knight[0] = knight[k] = knight[2k] ... = good\n// But you can also start at other places,\n// knight[1] = knight[k + 1] = knight[2k + 1] = good\n// ...\n// By the cyclic nature of the circle, when you arrive at knight[k] as a starting point, it is\n// exactly the same thing as starting at knight[0].\n//\n// Thus that's our answer:\n// Iterate over all possible divisors of N.\n// For each divisor K, check if all of the knights on the vertices are good, for each starting point\n// in 0..K\n//\n// This last part of checking visits all of the vertices once, and is thus O(N)\n// So the overall time complexity is O(N * divisors(N))\n//\n//\n// My thoughts:\n// Had the idea quickly, didn't see that it was fast enough instantly, but it was OK still.\n// Implementation was OK, Rust is nice.\n// Egor's lib has a very ergonomic way of finding divisors: `n`.divisors(). Pretty neat!\nfn solve(input: &mut Input, out: &mut Output, _test_case: usize, _data: &PreCalc) {\n    let n = input.read_long();\n    let good = input.read_size_vec(n as usize);\n    for d in n.divisors() {\n        if d < 3 {\n            continue;\n        }\n\n        let step_size = n as usize / d as usize;\n\n        for i in 0..(step_size) {\n            let all_good = good.iter().skip(i).step_by(step_size).all(|x| *x == 1);\n            if all_good {\n                out.print_line(\"YES\");\n                return;\n            }\n        }\n    }\n\n    out.print_line(\"NO\");\n}\n\npub(crate) fn run(mut input: Input, mut output: Output) -> bool {\n    let pre_calc = ();\n\n    #[allow(dead_code)]\n    enum TestType {\n        Single,\n        MultiNumber,\n        MultiEof,\n    }\n    let test_type = TestType::Single;\n    match test_type {\n        TestType::Single => solve(&mut input, &mut output, 1, &pre_calc),\n        TestType::MultiNumber => {\n            let t = input.read();\n            for i in 0usize..t {\n                solve(&mut input, &mut output, i + 1, &pre_calc);\n            }\n        }\n        TestType::MultiEof => {\n            let mut i = 1;\n            while input.peek().is_some() {\n                solve(&mut input, &mut output, i, &pre_calc);\n                i += 1;\n            }\n        }\n    }\n    output.flush();\n    input.skip_whitespace();\n    input.peek().is_none()\n}\n\n}\npub mod collections {\npub mod bit_set {\nuse crate::collections::slice_ext::legacy_fill::LegacyFill;\nuse crate::numbers::num_traits::bit_ops::BitOps;\nuse std::ops::{BitAndAssign, BitOrAssign, Index};\n\nconst TRUE: bool = true;\nconst FALSE: bool = false;\n\n#[derive(Clone, Eq, PartialEq)]\npub struct BitSet {\n    data: Vec<u64>,\n    len: usize,\n}\n\nimpl BitSet {\n    pub fn new(len: usize) -> Self {\n        let data_len = if len == 0 {\n            0\n        } else {\n            Self::index(len - 1) + 1\n        };\n        Self {\n            data: vec![0; data_len],\n            len,\n        }\n    }\n    \n    pub fn from_slice(len: usize, set: &[usize]) -> Self {\n        let mut res = Self::new(len);\n        for &i in set {\n            res.set(i);\n        }\n        res\n    }\n\n    pub fn set(&mut self, at: usize) {\n        assert!(at < self.len);\n        self.data[Self::index(at)].set_bit(at & 63);\n    }\n\n    pub fn unset(&mut self, at: usize) {\n        assert!(at < self.len);\n        self.data[Self::index(at)].unset_bit(at & 63);\n    }\n\n    pub fn change(&mut self, at: usize, value: bool) {\n        if value {\n            self.set(at);\n        } else {\n            self.unset(at);\n        }\n    }\n\n    pub fn flip(&mut self, at: usize) {\n        self.change(at, !self[at]);\n    }\n\n    #[allow(clippy::len_without_is_empty)]\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    pub fn fill(&mut self, value: bool) {\n        // 1.43\n        self.data.legacy_fill(if value { std::u64::MAX } else { 0 })\n    }\n\n    pub fn is_superset(&self, other: &Self) -> bool {\n        assert_eq!(self.len, other.len);\n        for i in 0..self.data.len() {\n            if self.data[i] & other.data[i] != other.data[i] {\n                return false;\n            }\n        }\n        true\n    }\n\n    pub fn is_subset(&self, other: &Self) -> bool {\n        other.is_superset(self)\n    }\n\n    pub fn iter(&self) -> impl Iterator<Item = usize> + '_ {\n        self.into_iter()\n    }\n\n    fn index(at: usize) -> usize {\n        at >> 6\n    }\n\n    pub fn count_ones(&self) -> usize {\n        self.data.iter().map(|x| x.count_ones() as usize).sum()\n    }\n}\n\npub struct BitSetIter<'s> {\n    at: usize,\n    inside: usize,\n    set: &'s BitSet,\n}\n\nimpl<'s> Iterator for BitSetIter<'s> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while self.at < self.set.data.len()\n            && (self.inside == 64 || (self.set.data[self.at] >> self.inside) == 0)\n        {\n            self.at += 1;\n            self.inside = 0;\n        }\n        if self.at == self.set.data.len() {\n            None\n        } else {\n            while !self.set.data[self.at].is_set(self.inside) {\n                self.inside += 1;\n            }\n            let res = self.at * 64 + self.inside;\n            if res < self.set.len {\n                self.inside += 1;\n                Some(res)\n            } else {\n                None\n            }\n        }\n    }\n}\n\nimpl<'a> IntoIterator for &'a BitSet {\n    type Item = usize;\n    type IntoIter = BitSetIter<'a>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        BitSetIter {\n            at: 0,\n            inside: 0,\n            set: self,\n        }\n    }\n}\n\nimpl BitOrAssign<&BitSet> for BitSet {\n    fn bitor_assign(&mut self, rhs: &BitSet) {\n        assert_eq!(self.len, rhs.len);\n        for (i, &j) in self.data.iter_mut().zip(rhs.data.iter()) {\n            *i |= j;\n        }\n    }\n}\n\nimpl BitAndAssign<&BitSet> for BitSet {\n    fn bitand_assign(&mut self, rhs: &BitSet) {\n        assert_eq!(self.len, rhs.len);\n        for (i, &j) in self.data.iter_mut().zip(rhs.data.iter()) {\n            *i &= j;\n        }\n    }\n}\n\nimpl Index<usize> for BitSet {\n    type Output = bool;\n\n    fn index(&self, at: usize) -> &Self::Output {\n        assert!(at < self.len);\n        if self.data[Self::index(at)].is_set(at & 63) {\n            &TRUE\n        } else {\n            &FALSE\n        }\n    }\n}\n\nimpl From<Vec<bool>> for BitSet {\n    fn from(data: Vec<bool>) -> Self {\n        let mut res = Self::new(data.len());\n        for (i, &value) in data.iter().enumerate() {\n            res.change(i, value);\n        }\n        res\n    }\n}\n}\npub mod iter_ext {\npub mod collect {\npub trait IterCollect<T>: Iterator<Item = T> + Sized {\n    fn collect_vec(self) -> Vec<T> {\n        self.collect()\n    }\n}\n\nimpl<T, I: Iterator<Item = T> + Sized> IterCollect<T> for I {}\n}\n}\npub mod slice_ext {\npub mod indices {\nuse std::ops::Range;\n\npub trait Indices {\n    fn indices(&self) -> Range<usize>;\n}\n\nimpl<T> Indices for [T] {\n    fn indices(&self) -> Range<usize> {\n        0..self.len()\n    }\n}\n}\npub mod legacy_fill {\n// 1.50\npub trait LegacyFill<T> {\n    fn legacy_fill(&mut self, val: T);\n}\n\nimpl<T: Clone> LegacyFill<T> for [T] {\n    fn legacy_fill(&mut self, val: T) {\n        for el in self.iter_mut() {\n            *el = val.clone();\n        }\n    }\n}\n}\n}\npub mod vec_ext {\npub mod default {\npub fn default_vec<T: Default>(len: usize) -> Vec<T> {\n    let mut v = Vec::with_capacity(len);\n    for _ in 0..len {\n        v.push(T::default());\n    }\n    v\n}\n}\npub mod sorted {\npub trait Sorted {\n    fn sorted(self) -> Self;\n}\n\nimpl<T: Ord> Sorted for Vec<T> {\n    fn sorted(mut self) -> Self {\n        self.sort();\n        self\n    }\n}\n}\n}\n}\npub mod io {\npub mod input {\nuse crate::collections::vec_ext::default::default_vec;\nuse std::io::Read;\n\npub struct Input<'s> {\n    input: &'s mut dyn Read,\n    buf: Vec<u8>,\n    at: usize,\n    buf_read: usize,\n}\n\nmacro_rules! read_impl {\n    ($t: ty, $read_name: ident, $read_vec_name: ident) => {\n        pub fn $read_name(&mut self) -> $t {\n            self.read()\n        }\n\n        pub fn $read_vec_name(&mut self, len: usize) -> Vec<$t> {\n            self.read_vec(len)\n        }\n    };\n\n    ($t: ty, $read_name: ident, $read_vec_name: ident, $read_pair_vec_name: ident) => {\n        read_impl!($t, $read_name, $read_vec_name);\n\n        pub fn $read_pair_vec_name(&mut self, len: usize) -> Vec<($t, $t)> {\n            self.read_vec(len)\n        }\n    };\n}\n\nimpl<'s> Input<'s> {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(input: &'s mut dyn Read) -> Self {\n        Self {\n            input,\n            buf: default_vec(Self::DEFAULT_BUF_SIZE),\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn new_with_size(input: &'s mut dyn Read, buf_size: usize) -> Self {\n        Self {\n            input,\n            buf: default_vec(buf_size),\n            at: 0,\n            buf_read: 0,\n        }\n    }\n\n    pub fn get(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            self.at += 1;\n            if res == b'\\r' {\n                if self.refill_buffer() && self.buf[self.at] == b'\\n' {\n                    self.at += 1;\n                }\n                return Some(b'\\n');\n            }\n            Some(res)\n        } else {\n            None\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<u8> {\n        if self.refill_buffer() {\n            let res = self.buf[self.at];\n            Some(if res == b'\\r' { b'\\n' } else { res })\n        } else {\n            None\n        }\n    }\n\n    pub fn skip_whitespace(&mut self) {\n        while let Some(b) = self.peek() {\n            if !char::from(b).is_whitespace() {\n                return;\n            }\n            self.get();\n        }\n    }\n\n    pub fn next_token(&mut self) -> Option<Vec<u8>> {\n        self.skip_whitespace();\n        let mut res = Vec::new();\n        while let Some(c) = self.get() {\n            if char::from(c).is_whitespace() {\n                break;\n            }\n            res.push(c);\n        }\n        if res.is_empty() {\n            None\n        } else {\n            Some(res)\n        }\n    }\n\n    //noinspection RsSelfConvention\n    pub fn is_exhausted(&mut self) -> bool {\n        self.peek().is_none()\n    }\n\n    pub fn read<T: Readable>(&mut self) -> T {\n        T::read(self)\n    }\n\n    pub fn read_vec<T: Readable>(&mut self, size: usize) -> Vec<T> {\n        let mut res = Vec::with_capacity(size);\n        for _ in 0..size {\n            res.push(self.read());\n        }\n        res\n    }\n\n    pub fn read_char(&mut self) -> char {\n        self.skip_whitespace();\n        self.get().unwrap().into()\n    }\n\n    read_impl!(u32, read_unsigned, read_unsigned_vec);\n    read_impl!(u64, read_u64, read_u64_vec);\n    read_impl!(usize, read_size, read_size_vec, read_size_pair_vec);\n    read_impl!(i32, read_int, read_int_vec, read_int_pair_vec);\n    read_impl!(i64, read_long, read_long_vec, read_long_pair_vec);\n    read_impl!(i128, read_i128, read_i128_vec);\n\n    fn refill_buffer(&mut self) -> bool {\n        if self.at == self.buf_read {\n            self.at = 0;\n            self.buf_read = self.input.read(&mut self.buf).unwrap();\n            self.buf_read != 0\n        } else {\n            true\n        }\n    }\n}\n\npub trait Readable {\n    fn read(input: &mut Input) -> Self;\n}\n\nimpl Readable for char {\n    fn read(input: &mut Input) -> Self {\n        input.read_char()\n    }\n}\n\nimpl<T: Readable> Readable for Vec<T> {\n    fn read(input: &mut Input) -> Self {\n        let size = input.read();\n        input.read_vec(size)\n    }\n}\n\nmacro_rules! read_integer {\n    ($($t:ident)+) => {$(\n        impl Readable for $t {\n            fn read(input: &mut Input) -> Self {\n                input.skip_whitespace();\n                let mut c = input.get().unwrap();\n                let sgn = match c {\n                    b'-' => {\n                        c = input.get().unwrap();\n                        true\n                    }\n                    b'+' => {\n                        c = input.get().unwrap();\n                        false\n                    }\n                    _ => false,\n                };\n                let mut res = 0;\n                loop {\n                    assert!(c.is_ascii_digit());\n                    res *= 10;\n                    let d = (c - b'0') as $t;\n                    if sgn {\n                        res -= d;\n                    } else {\n                        res += d;\n                    }\n                    match input.get() {\n                        None => break,\n                        Some(ch) => {\n                            if ch.is_ascii_whitespace() {\n                                break;\n                            } else {\n                                c = ch;\n                            }\n                        }\n                    }\n                }\n                res\n            }\n        }\n    )+};\n}\n\nread_integer!(i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);\n\nmacro_rules! tuple_readable {\n    ($($name:ident)+) => {\n        impl<$($name: Readable), +> Readable for ($($name,)+) {\n            fn read(input: &mut Input) -> Self {\n                ($($name::read(input),)+)\n            }\n        }\n    }\n}\n\ntuple_readable! {T}\ntuple_readable! {T U}\ntuple_readable! {T U V}\ntuple_readable! {T U V X}\ntuple_readable! {T U V X Y}\ntuple_readable! {T U V X Y Z}\ntuple_readable! {T U V X Y Z A}\ntuple_readable! {T U V X Y Z A B}\ntuple_readable! {T U V X Y Z A B C}\ntuple_readable! {T U V X Y Z A B C D}\ntuple_readable! {T U V X Y Z A B C D E}\ntuple_readable! {T U V X Y Z A B C D E F}\n\nimpl Read for Input<'_> {\n    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {\n        if self.at == self.buf_read {\n            self.input.read(buf)\n        } else {\n            let mut i = 0;\n            while i < buf.len() && self.at < self.buf_read {\n                buf[i] = self.buf[self.at];\n                i += 1;\n                self.at += 1;\n            }\n            Ok(i)\n        }\n    }\n}\n}\npub mod output {\nuse crate::collections::vec_ext::default::default_vec;\nuse std::io::{stderr, Stderr, Write};\n\n#[derive(Copy, Clone)]\npub enum BoolOutput {\n    YesNo,\n    YesNoCaps,\n    PossibleImpossible,\n    Custom(&'static str, &'static str),\n}\n\nimpl BoolOutput {\n    pub fn output(&self, output: &mut Output, val: bool) {\n        (if val { self.yes() } else { self.no() }).write(output);\n    }\n\n    fn yes(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"Yes\",\n            BoolOutput::YesNoCaps => \"YES\",\n            BoolOutput::PossibleImpossible => \"Possible\",\n            BoolOutput::Custom(yes, _) => yes,\n        }\n    }\n\n    fn no(&self) -> &str {\n        match self {\n            BoolOutput::YesNo => \"No\",\n            BoolOutput::YesNoCaps => \"NO\",\n            BoolOutput::PossibleImpossible => \"Impossible\",\n            BoolOutput::Custom(_, no) => no,\n        }\n    }\n}\n\npub struct Output<'s> {\n    output: &'s mut dyn Write,\n    buf: Vec<u8>,\n    at: usize,\n    auto_flush: bool,\n    bool_output: BoolOutput,\n}\n\nimpl<'s> Output<'s> {\n    const DEFAULT_BUF_SIZE: usize = 4096;\n\n    pub fn new(output: &'s mut dyn Write) -> Self {\n        Self {\n            output,\n            buf: default_vec(Self::DEFAULT_BUF_SIZE),\n            at: 0,\n            auto_flush: false,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn new_with_auto_flush(output: &'s mut dyn Write) -> Self {\n        Self {\n            output,\n            buf: default_vec(Self::DEFAULT_BUF_SIZE),\n            at: 0,\n            auto_flush: true,\n            bool_output: BoolOutput::YesNoCaps,\n        }\n    }\n\n    pub fn flush(&mut self) {\n        if self.at != 0 {\n            self.output.write_all(&self.buf[..self.at]).unwrap();\n            self.output.flush().unwrap();\n            self.at = 0;\n        }\n    }\n\n    pub fn print<T: Writable>(&mut self, s: T) {\n        s.write(self);\n        self.maybe_flush();\n    }\n\n    pub fn print_line<T: Writable>(&mut self, s: T) {\n        self.print(s);\n        self.put(b'\\n');\n        self.maybe_flush();\n    }\n\n    pub fn put(&mut self, b: u8) {\n        self.buf[self.at] = b;\n        self.at += 1;\n        if self.at == self.buf.len() {\n            self.flush();\n        }\n    }\n\n    pub fn maybe_flush(&mut self) {\n        if self.auto_flush {\n            self.flush();\n        }\n    }\n\n    pub fn print_per_line<T: Writable>(&mut self, arg: &[T]) {\n        for i in arg {\n            i.write(self);\n            self.put(b'\\n');\n        }\n    }\n\n    pub fn print_iter<T: Writable, I: Iterator<Item = T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n\n    pub fn print_iter_ref<'a, T: 'a + Writable, I: Iterator<Item = &'a T>>(&mut self, iter: I) {\n        let mut first = true;\n        for e in iter {\n            if first {\n                first = false;\n            } else {\n                self.put(b' ');\n            }\n            e.write(self);\n        }\n    }\n\n    pub fn set_bool_output(&mut self, bool_output: BoolOutput) {\n        self.bool_output = bool_output;\n    }\n}\n\nimpl Write for Output<'_> {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let mut start = 0usize;\n        let mut rem = buf.len();\n        while rem > 0 {\n            let len = (self.buf.len() - self.at).min(rem);\n            self.buf[self.at..self.at + len].copy_from_slice(&buf[start..start + len]);\n            self.at += len;\n            if self.at == self.buf.len() {\n                self.flush();\n            }\n            start += len;\n            rem -= len;\n        }\n        self.maybe_flush();\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.flush();\n        Ok(())\n    }\n}\n\npub trait Writable {\n    fn write(&self, output: &mut Output);\n}\n\nimpl Writable for &str {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for String {\n    fn write(&self, output: &mut Output) {\n        output.write_all(self.as_bytes()).unwrap();\n    }\n}\n\nimpl Writable for char {\n    fn write(&self, output: &mut Output) {\n        output.put(*self as u8);\n    }\n}\n\nimpl<T: Writable> Writable for [T] {\n    fn write(&self, output: &mut Output) {\n        output.print_iter_ref(self.iter());\n    }\n}\n\nimpl<T: Writable, const N: usize> Writable for [T; N] {\n    fn write(&self, output: &mut Output) {\n        output.print_iter_ref(self.iter());\n    }\n}\n\nimpl<T: Writable> Writable for &T {\n    fn write(&self, output: &mut Output) {\n        T::write(self, output)\n    }\n}\n\nimpl<T: Writable> Writable for Vec<T> {\n    fn write(&self, output: &mut Output) {\n        self.as_slice().write(output);\n    }\n}\n\nimpl Writable for () {\n    fn write(&self, _output: &mut Output) {}\n}\n\nmacro_rules! write_to_string {\n    ($($t:ident)+) => {$(\n        impl Writable for $t {\n            fn write(&self, output: &mut Output) {\n                self.to_string().write(output);\n            }\n        }\n    )+};\n}\n\nwrite_to_string!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n\nmacro_rules! tuple_writable {\n    ($name0:ident $($name:ident: $id:tt )*) => {\n        impl<$name0: Writable, $($name: Writable,)*> Writable for ($name0, $($name,)*) {\n            fn write(&self, out: &mut Output) {\n                self.0.write(out);\n                $(\n                out.put(b' ');\n                self.$id.write(out);\n                )*\n            }\n        }\n    }\n}\n\ntuple_writable! {T}\ntuple_writable! {T U:1}\ntuple_writable! {T U:1 V:2}\ntuple_writable! {T U:1 V:2 X:3}\ntuple_writable! {T U:1 V:2 X:3 Y:4}\ntuple_writable! {T U:1 V:2 X:3 Y:4 Z:5}\ntuple_writable! {T U:1 V:2 X:3 Y:4 Z:5 A:6}\ntuple_writable! {T U:1 V:2 X:3 Y:4 Z:5 A:6 B:7}\n\nimpl<T: Writable> Writable for Option<T> {\n    fn write(&self, output: &mut Output) {\n        match self {\n            None => (-1).write(output),\n            Some(t) => t.write(output),\n        }\n    }\n}\n\nimpl Writable for bool {\n    fn write(&self, output: &mut Output) {\n        let bool_output = output.bool_output;\n        bool_output.output(output, *self)\n    }\n}\n\nstatic mut ERR: Option<Stderr> = None;\npub fn err() -> Output<'static> {\n    unsafe {\n        if ERR.is_none() {\n            ERR = Some(stderr());\n        }\n        Output::new_with_auto_flush(ERR.as_mut().unwrap())\n    }\n}\n}\n}\npub mod misc {\npub mod random {\nuse crate::collections::slice_ext::indices::Indices;\nuse std::time::SystemTime;\n\nconst NN: usize = 312;\nconst MM: usize = 156;\nconst MATRIX_A: u64 = 0xB5026F5AA96619E9;\nconst UM: u64 = 0xFFFFFFFF80000000;\nconst LM: u64 = 0x7FFFFFFF;\nconst F: u64 = 6364136223846793005;\nconst MAG01: [u64; 2] = [0, MATRIX_A];\n\npub struct Random {\n    mt: [u64; NN],\n    index: usize,\n}\n\nimpl Random {\n    pub fn new(seed: u64) -> Self {\n        let mut res = Self {\n            mt: [0u64; NN],\n            index: NN,\n        };\n        res.mt[0] = seed;\n        for i in 1..NN {\n            res.mt[i] = F\n                .wrapping_mul(res.mt[i - 1] ^ (res.mt[i - 1] >> 62))\n                .wrapping_add(i as u64);\n        }\n        res\n    }\n\n    pub fn gen(&mut self) -> u64 {\n        if self.index == NN {\n            for i in 0..(NN - MM) {\n                let x = (self.mt[i] & UM) | (self.mt[i + 1] & LM);\n                self.mt[i] = self.mt[i + MM] ^ (x >> 1) ^ MAG01[(x & 1) as usize];\n            }\n            for i in (NN - MM)..(NN - 1) {\n                let x = (self.mt[i] & UM) | (self.mt[i + 1] & LM);\n                self.mt[i] = self.mt[i + MM - NN] ^ (x >> 1) ^ MAG01[(x & 1) as usize];\n            }\n            let x = (self.mt[NN - 1] & UM) | (self.mt[0] & LM);\n            self.mt[NN - 1] = self.mt[MM - 1] ^ (x >> 1) ^ MAG01[(x & 1) as usize];\n            self.index = 0;\n        }\n        let mut x = self.mt[self.index];\n        self.index += 1;\n        x ^= (x >> 29) & 0x5555555555555555;\n        x ^= (x << 17) & 0x71D67FFFEDA60000;\n        x ^= (x << 37) & 0xFFF7EEE000000000;\n        x ^= x >> 43;\n        x\n    }\n\n    pub fn next(&mut self, n: u64) -> u64 {\n        self.gen() % n\n    }\n\n    pub fn next_bounds(&mut self, f: u64, t: u64) -> u64 {\n        f + self.next(t - f + 1)\n    }\n}\n\nstatic mut RAND: Option<Random> = None;\n\npub fn random() -> &'static mut Random {\n    unsafe {\n        if RAND.is_none() {\n            RAND = Some(Random::new(\n                (SystemTime::UNIX_EPOCH.elapsed().unwrap().as_nanos() & 0xFFFFFFFFFFFFFFFF) as u64,\n            ));\n        }\n        RAND.as_mut().unwrap()\n    }\n}\n\npub trait Shuffle {\n    fn shuffle(&mut self);\n}\n\nimpl<T> Shuffle for [T] {\n    fn shuffle(&mut self) {\n        for i in self.indices() {\n            let at = (random().gen() % ((i + 1) as u64)) as usize;\n            self.swap(i, at);\n        }\n    }\n}\n}\npub mod recursive_function {\nuse std::marker::PhantomData;\n\nmacro_rules! recursive_function {\n    ($name: ident, $trait: ident, ($($type: ident $arg: ident,)*)) => {\n        pub trait $trait<$($type, )*Output> {\n            fn call(&mut self, $($arg: $type,)*) -> Output;\n        }\n\n        pub struct $name<F, $($type, )*Output>\n        where\n            F: FnMut(&mut dyn $trait<$($type, )*Output>, $($type, )*) -> Output,\n        {\n            f: std::cell::UnsafeCell<F>,\n            $($arg: PhantomData<$type>,\n            )*\n            phantom_output: PhantomData<Output>,\n        }\n\n        impl<F, $($type, )*Output> $name<F, $($type, )*Output>\n        where\n            F: FnMut(&mut dyn $trait<$($type, )*Output>, $($type, )*) -> Output,\n        {\n            pub fn new(f: F) -> Self {\n                Self {\n                    f: std::cell::UnsafeCell::new(f),\n                    $($arg: Default::default(),\n                    )*\n                    phantom_output: Default::default(),\n                }\n            }\n        }\n\n        impl<F, $($type, )*Output> $trait<$($type, )*Output> for $name<F, $($type, )*Output>\n        where\n            F: FnMut(&mut dyn $trait<$($type, )*Output>, $($type, )*) -> Output,\n        {\n            fn call(&mut self, $($arg: $type,)*) -> Output {\n                unsafe { (*self.f.get())(self, $($arg, )*) }\n            }\n        }\n    }\n}\n\nrecursive_function!(RecursiveFunction0, Callable0, ());\nrecursive_function!(RecursiveFunction, Callable, (Arg arg,));\nrecursive_function!(RecursiveFunction2, Callable2, (Arg1 arg1, Arg2 arg2,));\nrecursive_function!(RecursiveFunction3, Callable3, (Arg1 arg1, Arg2 arg2, Arg3 arg3,));\nrecursive_function!(RecursiveFunction4, Callable4, (Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4,));\nrecursive_function!(RecursiveFunction5, Callable5, (Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,));\nrecursive_function!(RecursiveFunction6, Callable6, (Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,));\nrecursive_function!(RecursiveFunction7, Callable7, (Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,));\nrecursive_function!(RecursiveFunction8, Callable8, (Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,));\nrecursive_function!(RecursiveFunction9, Callable9, (Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,));\n}\npub mod value {\nuse std::hash::Hash;\n\npub trait Value<T>: Copy + Eq + Hash {\n    fn val() -> T;\n}\n\npub trait ConstValue<T>: Value<T> {\n    const VAL: T;\n}\n\nimpl<T, V: ConstValue<T>> Value<T> for V {\n    fn val() -> T {\n        Self::VAL\n    }\n}\n\n#[macro_export]\nmacro_rules! value {\n    ($name: ident: $t: ty = $val: expr) => {\n        #[derive(Copy, Clone, Eq, PartialEq, Hash, Ord, PartialOrd, Default)]\n        pub struct $name {}\n\n        impl $crate::misc::value::ConstValue<$t> for $name {\n            const VAL: $t = $val;\n        }\n    };\n}\n\npub trait DynamicValue<T>: Value<T> {\n    //noinspection RsSelfConvention\n    fn set_val(t: T);\n}\n\n#[macro_export]\nmacro_rules! dynamic_value {\n    ($name: ident: $t: ty) => {\n        static mut VAL: Option<$t> = None;\n\n        #[derive(Copy, Clone, Eq, PartialEq, Hash, Default)]\n        struct $name {}\n\n        impl $crate::misc::value::DynamicValue<$t> for $name {\n            fn set_val(t: $t) {\n                unsafe {\n                    VAL = Some(t);\n                }\n            }\n        }\n\n        impl $crate::misc::value::Value<$t> for $name {\n            fn val() -> $t {\n                unsafe { VAL.unwrap() }\n            }\n        }\n    };\n    ($name: ident: $t: ty = $val: expr) => {\n        dynamic_value!($name: $t);\n\n        $name::set_val($val);\n    };\n}\n}\npub mod when {\n#[macro_export]\nmacro_rules! when {\n    {$($cond: expr => $then: expr,)*} => {\n        match () {\n            $(_ if $cond => $then,)*\n            _ => unreachable!(),\n        }\n    };\n    {$($cond: expr => $then: expr,)* else $(=>)? $else: expr,} => {\n        match () {\n            $(_ if $cond => $then,)*\n            _ => $else,\n        }\n    };\n}\n}\n}\npub mod numbers {\npub mod gcd {\nuse crate::numbers::num_traits::add_sub::AddSub;\nuse crate::numbers::num_traits::mul_div_rem::{MulDivRem, Multable};\nuse crate::numbers::num_traits::wideable::Wideable;\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse std::mem::swap;\n\npub fn extended_gcd<T: Copy + ZeroOne + AddSub + MulDivRem + Wideable + PartialEq>(\n    a: T,\n    b: T,\n) -> (T, T::W, T::W)\nwhere\n    T::W: Copy + ZeroOne + AddSub + Multable,\n{\n    if a == T::zero() {\n        (b, T::W::zero(), T::W::one())\n    } else {\n        let (d, y, mut x) = extended_gcd(b % a, a);\n        x -= T::W::from(b / a) * y;\n        (d, x, y)\n    }\n}\n\npub fn gcd<T: Copy + ZeroOne + MulDivRem + PartialEq>(mut a: T, mut b: T) -> T {\n    while b != T::zero() {\n        a %= b;\n        swap(&mut a, &mut b);\n    }\n    a\n}\n\npub fn lcm<T: Copy + ZeroOne + MulDivRem + PartialEq>(a: T, b: T) -> T {\n    (a / gcd(a, b)) * b\n}\n}\npub mod mod_int {\nuse crate::io::input::{Input, Readable};\nuse crate::io::output::{Output, Writable};\nuse crate::misc::value::Value;\nuse crate::numbers::gcd::extended_gcd;\nuse crate::numbers::num_traits::add_sub::AddSub;\nuse crate::numbers::num_traits::as_index::AsIndex;\nuse crate::numbers::num_traits::from_u8::FromU8;\nuse crate::numbers::num_traits::invertable::Invertable;\nuse crate::numbers::num_traits::mul_div_rem::{MulDiv, MulDivRem};\nuse crate::numbers::num_traits::wideable::Wideable;\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse crate::{value, when};\nuse std::collections::HashMap;\nuse std::fmt::{Display, Formatter};\nuse std::hash::Hash;\nuse std::marker::PhantomData;\nuse std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\n\npub trait BaseModInt:\n    AddSub + MulDiv + Neg<Output = Self> + Copy + ZeroOne + PartialEq + Invertable<Output = Self>\n{\n    type W: AddSub + MulDivRem + Copy + ZeroOne + From<Self::T>;\n    type T: AddSub + MulDivRem + Copy + PartialEq + ZeroOne + Wideable<W = Self::W> + Ord;\n\n    fn from(v: Self::T) -> Self;\n    fn module() -> Self::T;\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Default)]\npub struct ModInt<T, V: Value<T>> {\n    n: T,\n    phantom: PhantomData<V>,\n}\n\nimpl<T: Copy, V: Value<T>> ModInt<T, V> {\n    pub fn val(&self) -> T {\n        self.n\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord, V: Value<T>> ModInt<T, V> {\n    unsafe fn unchecked_new(n: T) -> Self {\n        debug_assert!(n >= T::zero() && n < V::val());\n        Self {\n            n,\n            phantom: Default::default(),\n        }\n    }\n\n    unsafe fn maybe_subtract_mod(mut n: T) -> T {\n        debug_assert!(n < V::val() + V::val() && n >= T::zero());\n        if n >= V::val() {\n            n -= V::val();\n        }\n        n\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord + MulDivRem, V: Value<T>> ModInt<T, V> {\n    pub fn new(n: T) -> Self {\n        unsafe { Self::unchecked_new(Self::maybe_subtract_mod(n % (V::val()) + V::val())) }\n    }\n}\n\nimpl<T: Copy + ZeroOne + AddSub + MulDivRem + Wideable + PartialEq + Ord + Hash, V: Value<T>>\n    ModInt<T, V>\nwhere\n    T::W: Copy + ZeroOne + AddSub + MulDivRem,\n{\n    pub fn log(&self, alpha: Self) -> T {\n        let mut base = HashMap::new();\n        let mut exp = T::zero();\n        let mut pow = Self::one();\n        let mut inv = *self;\n        let alpha_inv = alpha.inv().unwrap();\n        while exp * exp < Self::module() {\n            if inv == Self::one() {\n                return exp;\n            }\n            base.insert(inv, exp);\n            exp += T::one();\n            pow *= alpha;\n            inv *= alpha_inv;\n        }\n        let step = pow;\n        let mut i = T::one();\n        loop {\n            if let Some(b) = base.get(&pow) {\n                break exp * i + *b;\n            }\n            pow *= step;\n            i += T::one();\n        }\n    }\n}\n\nimpl<T: Wideable + AddSub + Copy + ZeroOne + Ord, V: Value<T>> ModInt<T, V>\nwhere\n    T::W: MulDivRem,\n{\n    pub fn new_from_wide(n: T::W) -> Self {\n        unsafe {\n            Self::unchecked_new(Self::maybe_subtract_mod(\n                T::downcast(n % (V::val()).into()) + V::val(),\n            ))\n        }\n    }\n}\n\nimpl<T: Copy + ZeroOne + AddSub + MulDivRem + Wideable + PartialEq + Ord, V: Value<T>> Invertable\n    for ModInt<T, V>\nwhere\n    T::W: Copy + ZeroOne + AddSub + MulDivRem,\n{\n    type Output = Self;\n\n    fn inv(&self) -> Option<Self> {\n        let (g, x, _) = extended_gcd(self.n, V::val());\n        if g != T::one() {\n            None\n        } else {\n            Some(Self::new_from_wide(x))\n        }\n    }\n}\n\nimpl<T: AddSub + MulDivRem + Copy + PartialEq + Wideable + ZeroOne + Ord, V: Value<T>> BaseModInt\n    for ModInt<T, V>\nwhere\n    T::W: AddSub + MulDivRem + Copy + ZeroOne,\n{\n    type W = T::W;\n    type T = T;\n\n    fn from(v: Self::T) -> Self {\n        Self::new(v)\n    }\n\n    fn module() -> T {\n        V::val()\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord + MulDivRem, V: Value<T>> From<T> for ModInt<T, V> {\n    fn from(n: T) -> Self {\n        Self::new(n)\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord, V: Value<T>> AddAssign for ModInt<T, V> {\n    fn add_assign(&mut self, rhs: Self) {\n        self.n = unsafe { Self::maybe_subtract_mod(self.n + rhs.n) };\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord, V: Value<T>> Add for ModInt<T, V> {\n    type Output = Self;\n\n    fn add(mut self, rhs: Self) -> Self::Output {\n        self += rhs;\n        self\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord, V: Value<T>> SubAssign for ModInt<T, V> {\n    fn sub_assign(&mut self, rhs: Self) {\n        self.n = unsafe { Self::maybe_subtract_mod(self.n + V::val() - rhs.n) };\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord, V: Value<T>> Sub for ModInt<T, V> {\n    type Output = Self;\n\n    fn sub(mut self, rhs: Self) -> Self::Output {\n        self -= rhs;\n        self\n    }\n}\n\nimpl<T: AddSub + MulDivRem + Copy + Wideable + ZeroOne + Ord, V: Value<T>> MulAssign\n    for ModInt<T, V>\nwhere\n    T::W: MulDivRem + Copy,\n{\n    fn mul_assign(&mut self, rhs: Self) {\n        self.n = T::downcast(T::W::from(self.n) * T::W::from(rhs.n) % T::W::from(V::val()));\n    }\n}\n\nimpl<T: AddSub + MulDivRem + Copy + Wideable + ZeroOne + Ord, V: Value<T>> Mul for ModInt<T, V>\nwhere\n    T::W: MulDivRem + Copy,\n{\n    type Output = Self;\n\n    fn mul(mut self, rhs: Self) -> Self::Output {\n        self *= rhs;\n        self\n    }\n}\n\nimpl<T: AddSub + MulDivRem + Copy + PartialEq + Wideable + ZeroOne + Ord, V: Value<T>> DivAssign\n    for ModInt<T, V>\nwhere\n    T::W: AddSub + MulDivRem + Copy + ZeroOne,\n{\n    #[allow(clippy::suspicious_op_assign_impl)]\n    fn div_assign(&mut self, rhs: Self) {\n        *self *= rhs.inv().unwrap();\n    }\n}\n\nimpl<T: AddSub + MulDivRem + Copy + PartialEq + Wideable + ZeroOne + Ord, V: Value<T>> Div\n    for ModInt<T, V>\nwhere\n    T::W: AddSub + MulDivRem + Copy + ZeroOne,\n{\n    type Output = Self;\n\n    fn div(mut self, rhs: Self) -> Self::Output {\n        self /= rhs;\n        self\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord, V: Value<T>> Neg for ModInt<T, V> {\n    type Output = Self;\n\n    fn neg(mut self) -> Self::Output {\n        self.n = unsafe { Self::maybe_subtract_mod(V::val() - self.n) };\n        self\n    }\n}\n\nimpl<T: Display, V: Value<T>> Display for ModInt<T, V> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        <T as Display>::fmt(&self.n, f)\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord + MulDivRem + Readable, V: Value<T>> Readable\n    for ModInt<T, V>\n{\n    fn read(input: &mut Input) -> Self {\n        Self::new(T::read(input))\n    }\n}\n\nimpl<T: Writable, V: Value<T>> Writable for ModInt<T, V> {\n    fn write(&self, output: &mut Output) {\n        self.n.write(output);\n    }\n}\n\nimpl<T: ZeroOne + MulDivRem + AddSub + Copy + Ord, V: Value<T>> ZeroOne for ModInt<T, V> {\n    fn zero() -> Self {\n        unsafe { Self::unchecked_new(T::zero()) }\n    }\n\n    fn one() -> Self {\n        Self::new(T::one())\n    }\n}\n\nimpl<T, V: Value<T>> Wideable for ModInt<T, V> {\n    type W = Self;\n\n    fn downcast(w: Self::W) -> Self {\n        w\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord + MulDivRem + FromU8, V: Value<T>> FromU8 for ModInt<T, V> {\n    fn from_u8(n: u8) -> Self {\n        Self::new(T::from_u8(n))\n    }\n}\n\nimpl<\n        T: AddSub + MulDivRem + Copy + PartialEq + Wideable + ZeroOne + Ord + Display + FromU8,\n        V: Value<T>,\n    > std::fmt::Debug for ModInt<T, V>\nwhere\n    T::W: AddSub + MulDivRem + Copy + ZeroOne,\n{\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        let max = T::from_u8(100);\n        when! {\n            self.n <= max => write!(f, \"{}\", self.n),\n            self.n >= V::val() - max => write!(f, \"{}\", self.n - V::val()),\n            else => {\n                let mut denominator = T::one();\n                while denominator < max {\n                    let mut num = T::one();\n                    while num < max {\n                        if Self::new(num) / Self::new(denominator) == *self {\n                            return write!(f, \"{}/{}\", num, denominator);\n                        }\n                        if -Self::new(num) / Self::new(denominator) == *self {\n                            return write!(f, \"-{}/{}\", num, denominator);\n                        }\n                        num += T::one();\n                    }\n                    denominator += T::one();\n                }\n                write!(f, \"(?? {} ??)\", self.n)\n            },\n        }\n    }\n}\n\nimpl<T: AddSub + Copy + ZeroOne + Ord + MulDivRem + AsIndex, V: Value<T>> AsIndex for ModInt<T, V> {\n    fn from_index(idx: usize) -> Self {\n        Self::new(T::from_index(idx))\n    }\n\n    fn to_index(self) -> usize {\n        self.n.to_index()\n    }\n}\n\nvalue!(Val7: i32 = 1_000_000_007);\npub type ModInt7 = ModInt<i32, Val7>;\n\nvalue!(Val9: i32 = 1_000_000_009);\npub type ModInt9 = ModInt<i32, Val9>;\n\nvalue!(ValF: i32 = 998_244_353);\npub type ModIntF = ModInt<i32, ValF>;\n}\npub mod num_traits {\npub mod add_sub {\nuse std::ops::{Add, AddAssign, Sub, SubAssign};\n\npub trait Addable: Add<Output = Self> + AddAssign + Copy {}\nimpl<T: Add<Output = Self> + AddAssign + Copy> Addable for T {}\n\npub trait AddSub: Addable + Sub<Output = Self> + SubAssign {}\nimpl<T: Addable + Sub<Output = Self> + SubAssign> AddSub for T {}\n}\npub mod as_index {\npub trait AsIndex {\n    fn from_index(idx: usize) -> Self;\n    fn to_index(self) -> usize;\n}\n\nmacro_rules! from_index_impl {\n    ($($t: ident)+) => {$(\n        impl AsIndex for $t {\n            fn from_index(idx: usize) -> Self {\n                idx as $t\n            }\n\n            fn to_index(self) -> usize {\n                self as usize\n            }\n        }\n    )+};\n}\n\nfrom_index_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize);\n}\npub mod bit_ops {\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse std::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not, RangeInclusive, Shl,};\nuse std::ops::{ShlAssign, Shr, ShrAssign};\n\npub trait BitOps:\n    Copy\n    + BitAnd<Output = Self>\n    + BitAndAssign\n    + BitOr<Output = Self>\n    + BitOrAssign\n    + BitXor<Output = Self>\n    + BitXorAssign\n    + Not<Output = Self>\n    + Shl<usize, Output = Self>\n    + ShlAssign<usize>\n    + Shr<usize, Output = Self>\n    + ShrAssign<usize>\n    + ZeroOne\n    + PartialEq\n{\n    fn bit(at: usize) -> Self {\n        Self::one() << at\n    }\n\n    fn is_set(&self, at: usize) -> bool {\n        (*self >> at & Self::one()) == Self::one()\n    }\n\n    fn set_bit(&mut self, at: usize) {\n        *self |= Self::bit(at)\n    }\n\n    fn unset_bit(&mut self, at: usize) {\n        *self &= !Self::bit(at)\n    }\n\n    #[must_use]\n    fn with_bit(mut self, at: usize) -> Self {\n        self.set_bit(at);\n        self\n    }\n\n    #[must_use]\n    fn without_bit(mut self, at: usize) -> Self {\n        self.unset_bit(at);\n        self\n    }\n\n    fn flip_bit(&mut self, at: usize) {\n        *self ^= Self::bit(at)\n    }\n\n    fn all_bits(n: usize) -> Self {\n        let mut res = Self::zero();\n        for i in 0..n {\n            res.set_bit(i);\n        }\n        res\n    }\n\n    fn iter_all(n: usize) -> RangeInclusive<Self> {\n        Self::zero()..=Self::all_bits(n)\n    }\n}\n\nimpl<\n        T: Copy\n            + BitAnd<Output = Self>\n            + BitAndAssign\n            + BitOr<Output = Self>\n            + BitOrAssign\n            + BitXor<Output = Self>\n            + BitXorAssign\n            + Not<Output = Self>\n            + Shl<usize, Output = Self>\n            + ShlAssign<usize>\n            + Shr<usize, Output = Self>\n            + ShrAssign<usize>\n            + ZeroOne\n            + PartialEq,\n    > BitOps for T\n{\n}\n\npub trait Bits: BitOps {\n    fn bits() -> u32;\n}\n\nmacro_rules! bits_integer_impl {\n    ($($t: ident $bits: expr),+) => {$(\n        impl Bits for $t {\n            fn bits() -> u32 {\n                $bits\n            }\n        }\n    )+};\n}\n\nbits_integer_impl!(i128 128, i64 64, i32 32, i16 16, i8 8, isize 64, u128 128, u64 64, u32 32, u16 16, u8 8, usize 64);\n}\npub mod from_u8 {\npub trait FromU8 {\n    fn from_u8(val: u8) -> Self;\n}\n\nmacro_rules! from_u8_impl {\n    ($($t: ident)+) => {$(\n        impl FromU8 for $t {\n            fn from_u8(val: u8) -> Self {\n                val as $t\n            }\n        }\n    )+};\n}\n\nfrom_u8_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize);\n}\npub mod invertable {\npub trait Invertable: Sized {\n    type Output;\n\n    fn inv(&self) -> Option<Self>;\n}\n}\npub mod mul_div_rem {\nuse std::ops::{Div, DivAssign, Mul, MulAssign, Rem, RemAssign};\n\npub trait Multable: Mul<Output = Self> + MulAssign + Copy {}\nimpl<T: Mul<Output = Self> + MulAssign + Copy> Multable for T {}\n\npub trait MulDiv: Multable + Div<Output = Self> + DivAssign {}\nimpl<T: Multable + Div<Output = Self> + DivAssign> MulDiv for T {}\n\npub trait MulDivRem: MulDiv + Rem<Output = Self> + RemAssign {}\nimpl<T: MulDiv + Rem<Output = Self> + RemAssign> MulDivRem for T {}\n}\npub mod primitive {\npub trait Primitive<T>: Copy {\n    fn to(self) -> T;\n}\n\nmacro_rules! primitive_one {\n    ($t: ident, $($u: ident)+) => {$(\n        impl Primitive<$u> for $t {\n            fn to(self) -> $u {\n                self as $u\n            }\n        }\n    )+};\n}\n\nmacro_rules! primitive {\n    ($($t: ident)+) => {$(\n        primitive_one!($t, u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n    )+}\n}\n\nprimitive!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n}\npub mod wideable {\nuse std::convert::From;\n\npub trait Wideable: Sized {\n    type W: From<Self>;\n\n    fn downcast(w: Self::W) -> Self;\n}\n\nmacro_rules! wideable_impl {\n    ($($t: ident $w: ident),+) => {$(\n        impl Wideable for $t {\n            type W = $w;\n\n            fn downcast(w: Self::W) -> Self {\n                w as $t\n            }\n        }\n    )+};\n}\n\nwideable_impl!(i128 i128, i64 i128, i32 i64, i16 i32, i8 i16, isize isize, u128 u128, u64 u128, u32 u64, u16 u32, u8 u16, usize usize);\n}\npub mod zero_one {\npub trait ZeroOne {\n    fn zero() -> Self;\n    fn one() -> Self;\n}\n\nmacro_rules! zero_one_integer_impl {\n    ($($t: ident)+) => {$(\n        impl ZeroOne for $t {\n            fn zero() -> Self {\n                0\n            }\n\n            fn one() -> Self {\n                1\n            }\n        }\n    )+};\n}\n\nzero_one_integer_impl!(i128 i64 i32 i16 i8 isize u128 u64 u32 u16 u8 usize);\n}\n}\npub mod number_ext {\nuse crate::numbers::num_traits::add_sub::AddSub;\nuse crate::numbers::num_traits::from_u8::FromU8;\nuse crate::numbers::num_traits::mul_div_rem::{MulDiv, MulDivRem, Multable};\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse crate::when;\nuse std::ops::Mul;\n\npub trait Power {\n    #[must_use]\n    fn power<T: ZeroOne + PartialEq + MulDivRem + AddSub + Copy>(&self, exp: T) -> Self;\n}\n\nimpl<S: ZeroOne + Copy + Multable> Power for S {\n    fn power<T: ZeroOne + PartialEq + MulDivRem + AddSub + Copy>(&self, exp: T) -> Self {\n        when! {\n            exp == T::zero() => S::one(),\n            exp % (T::one() + T::one()) == T::zero() => {\n                let res = self.power(exp / (T::one() + T::one()));\n                res * res\n            },\n            else => self.power(exp - T::one()) * (*self),\n        }\n    }\n}\n\npub trait NumDigs {\n    fn num_digs(&self) -> usize;\n}\n\nimpl<S: ZeroOne + FromU8 + MulDiv + Copy + PartialEq> NumDigs for S {\n    fn num_digs(&self) -> usize {\n        let mut copy = *self;\n        let ten = S::from_u8(10);\n        let mut res = 0;\n        while copy != S::zero() {\n            copy /= ten;\n            res += 1;\n        }\n        res\n    }\n}\n\npub trait Square {\n    fn square(self) -> Self;\n}\n\nimpl<T: Mul<Output = T> + Copy> Square for T {\n    fn square(self) -> Self {\n        self * self\n    }\n}\n}\npub mod primes {\npub mod factorize {\nuse crate::collections::vec_ext::sorted::Sorted;\nuse crate::misc::recursive_function::{Callable2, RecursiveFunction2};\nuse crate::numbers::num_traits::as_index::AsIndex;\nuse crate::numbers::num_traits::primitive::Primitive;\nuse crate::numbers::primes::prime::find_divisor;\nuse crate::numbers::primes::sieve::divisor_table;\nuse std::cmp::Ordering;\nuse std::ops::Mul;\n\npub trait Factorize {\n    fn prime_divisors(self) -> Vec<(i64, usize)>;\n    fn divisors(self) -> Vec<i64>;\n    fn max_power(self, p: Self) -> usize;\n}\n\nimpl<T: Primitive<i64>> Factorize for T {\n    fn prime_divisors(self) -> Vec<(i64, usize)> {\n        let n = self.to();\n        assert!(n >= 1);\n        if n == 1 {\n            return Vec::new();\n        }\n        let d = if n > 100 {\n            find_divisor(n)\n        } else {\n            let mut res = n;\n            let mut i = 2;\n            while i * i <= n {\n                if n % i == 0 {\n                    res = i;\n                    break;\n                }\n                i += 1;\n            }\n            res\n        };\n        if d == n {\n            return vec![(d, 1)];\n        }\n        let left = d.prime_divisors();\n        let right = (n / d).prime_divisors();\n        let mut res = Vec::new();\n        let mut i = 0;\n        let mut j = 0;\n        while i < left.len() && j < right.len() {\n            match left[i].0.cmp(&right[j].0) {\n                Ordering::Less => {\n                    res.push(left[i]);\n                    i += 1;\n                }\n                Ordering::Equal => {\n                    res.push((left[i].0, left[i].1 + right[j].1));\n                    i += 1;\n                    j += 1;\n                }\n                Ordering::Greater => {\n                    res.push(right[j]);\n                    j += 1;\n                }\n            }\n        }\n        res.extend_from_slice(&left[i..]);\n        res.extend_from_slice(&right[j..]);\n        res\n    }\n\n    fn divisors(self) -> Vec<i64> {\n        let pd = self.prime_divisors();\n        let mut res = Vec::new();\n        let mut rec = RecursiveFunction2::new(|f, mut d: i64, step: usize| {\n            if step == pd.len() {\n                res.push(d);\n            } else {\n                let (p, e) = pd[step];\n                for i in 0..=e {\n                    f.call(d, step + 1);\n                    if i < e {\n                        d *= p;\n                    }\n                }\n            }\n        });\n        rec.call(1, 0);\n        res.sorted()\n    }\n\n    fn max_power(self, p: Self) -> usize {\n        let mut res = 0;\n        let mut cur = self.to();\n        assert!(cur >= 1);\n        let p = p.to();\n        assert!(p >= 2);\n        while cur % p == 0 {\n            cur /= p;\n            res += 1;\n        }\n        res\n    }\n}\n\npub fn all_divisors<T: AsIndex + PartialEq + Copy + Mul<Output = T> + Ord>(\n    n: usize,\n    sorted: bool,\n) -> Vec<Vec<T>> {\n    let d: Vec<T> = divisor_table(n);\n    let mut res = Vec::with_capacity(n);\n    if n > 0 {\n        res.push(Vec::new());\n    }\n    if n > 1 {\n        res.push(vec![T::from_index(1)]);\n    }\n    for (i, p) in d.into_iter().enumerate().skip(2) {\n        let mut q = 0;\n        let mut c = i;\n        while c % p.to_index() == 0 {\n            c /= p.to_index();\n            q += 1;\n        }\n        let mut cur = Vec::with_capacity(res[c].len() * (q + 1));\n        let mut by = T::from_index(1);\n        for j in 0..=q {\n            cur.extend(res[c].iter().map(|&x| x * by));\n            if j != q {\n                by = by * p;\n            }\n        }\n        if sorted {\n            cur.sort();\n        }\n        res.push(cur);\n    }\n    res\n}\n}\npub mod prime {\nuse crate::misc::random::random;\nuse crate::misc::value::DynamicValue;\nuse crate::numbers::gcd::gcd;\nuse crate::numbers::mod_int::ModInt;\nuse crate::numbers::num_traits::primitive::Primitive;\nuse crate::numbers::num_traits::zero_one::ZeroOne;\nuse crate::numbers::number_ext::Power;\nuse crate::{dynamic_value, when};\n\npub fn is_prime(n: impl Primitive<i64>) -> bool {\n    let n = n.to();\n    if n <= 1 {\n        return false;\n    }\n    let mut s = 0;\n    let mut d = n - 1;\n    while d % 2 == 0 {\n        s += 1;\n        d >>= 1;\n    }\n    if s == 0 {\n        return n == 2;\n    }\n    dynamic_value!(IsPrimeModule: i64 = n);\n    type Mod = ModInt<i64, IsPrimeModule>;\n    for _ in 0..20 {\n        let a = Mod::new(random().next(n as u64) as i64);\n        if a == Mod::zero() {\n            continue;\n        }\n        if a.power(d) == Mod::one() {\n            continue;\n        }\n        let mut dd = d;\n        let mut good = true;\n        for _ in 0..s {\n            if a.power(dd) + Mod::one() == Mod::zero() {\n                good = false;\n                break;\n            }\n            dd *= 2;\n        }\n        if good {\n            return false;\n        }\n    }\n    true\n}\n\npub fn next_prime(mut n: i64) -> i64 {\n    if n <= 2 {\n        return 2;\n    }\n    n += 1 - (n & 1);\n    while !is_prime(n) {\n        n += 2;\n    }\n    n\n}\n\nfn brent(n: i64, x0: i64, c: i64) -> i64 {\n    dynamic_value!(ModVal: i64 = n);\n    type Mod = ModInt<i64, ModVal>;\n    let mut x = Mod::new(x0);\n    let c = Mod::new(c);\n    let mut g = 1;\n    let mut q = Mod::one();\n    let mut xs = Mod::zero();\n    let mut y = Mod::zero();\n    let m = 128i64;\n    let mut l = 1;\n    while g == 1 {\n        y = x;\n        for _ in 1..l {\n            x = x * x + c;\n        }\n        let mut k = 0;\n        while k < l && g == 1 {\n            xs = x;\n            for _ in 0..m.min(l - k) {\n                x = x * x + c;\n                q *= y - x;\n            }\n            g = gcd(q.val(), n);\n            k += m;\n        }\n        l *= 2;\n    }\n    if g == n {\n        loop {\n            xs = xs * xs + c;\n            g = gcd((xs - y).val(), n);\n            if g != 1 {\n                break;\n            }\n        }\n    }\n    g\n}\n\npub fn find_divisor(n: i64) -> i64 {\n    when! {\n        n == 1 => 1,\n        n % 2 == 0 => 2,\n        is_prime(n) => n,\n        else => {\n            loop {\n                let res = brent(\n                    n,\n                    random().next_bounds(2, n as u64 - 1) as i64,\n                    random().next_bounds(1, n as u64 - 1) as i64,\n                );\n                if res != n {\n                    return res;\n                }\n            }\n        },\n    }\n}\n}\npub mod sieve {\nuse crate::collections::bit_set::BitSet;\nuse crate::collections::iter_ext::collect::IterCollect;\nuse crate::numbers::num_traits::as_index::AsIndex;\n\npub fn primality_table(n: usize) -> BitSet {\n    let mut res = BitSet::new(n);\n    res.fill(true);\n    if n > 0 {\n        res.unset(0);\n    }\n    if n > 1 {\n        res.unset(1);\n    }\n    let mut i = 2;\n    while i * i < n {\n        if res[i] {\n            for j in ((i * i)..n).step_by(i) {\n                res.unset(j);\n            }\n        }\n        i += 1;\n    }\n    res\n}\n\npub fn primes<T: AsIndex>(n: usize) -> Vec<T> {\n    primality_table(n)\n        .into_iter()\n        .map(|i| T::from_index(i))\n        .collect_vec()\n}\n\npub fn divisor_table<T: AsIndex + PartialEq>(n: usize) -> Vec<T> {\n    let mut res = (0..n).map(|i| T::from_index(i)).collect_vec();\n    let mut i = 2;\n    while i * i < n {\n        if res[i] == T::from_index(i) {\n            for j in ((i * i)..n).step_by(i) {\n                res[j] = T::from_index(i);\n            }\n        }\n        i += 1;\n    }\n    res\n}\n}\n}\n}\nfn main() {\n    let mut sin = std::io::stdin();\n    let input = if false {\n        crate::io::input::Input::new_with_size(&mut sin, 1)\n    } else {\n        crate::io::input::Input::new(&mut sin)\n    };\n\n    let mut stdout = std::io::stdout();\n    let output = if false {\n        crate::io::output::Output::new_with_auto_flush(&mut stdout)\n    } else {\n        crate::io::output::Output::new(&mut stdout)\n    };\n\n    crate::solution::run(input, output);\n}\n\n"
}