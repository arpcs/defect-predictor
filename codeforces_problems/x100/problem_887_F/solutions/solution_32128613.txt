{
    "id": 32128613,
    "contestId": 887,
    "creationTimeSeconds": 1510080995,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 887,
        "index": "F",
        "name": "Row of Models",
        "type": "PROGRAMMING",
        "points": 3000.0,
        "rating": 2500,
        "tags": [
            "greedy",
            "sortings"
        ]
    },
    "author": {
        "contestId": 887,
        "members": [
            {
                "handle": "yuShaf"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1509725100
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 74,
    "timeConsumedMillis": 265,
    "memoryConsumedBytes": 10035200,
    "source": "#define _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <string>\r\n#include <cstring>\r\n#include <vector>\r\n#include <map>\r\n#include <set>\r\n#include <deque>\r\n#include <cmath>\r\n#include <algorithm>\r\n#include <climits>\r\n\r\n#define IntPair pair<int, int>\r\n\r\nusing namespace std;\r\n\r\n#define SegmentTreeType int\r\nstruct SegmentTreeCombiner\r\n{\r\n\tstatic SegmentTreeType Combine(SegmentTreeType & a, SegmentTreeType & b)\r\n\t{\r\n\t\treturn __min(a, b);\r\n\t}\r\n\tstatic SegmentTreeType Default()\r\n\t{\r\n\t\treturn INT_MAX;\r\n\t}\r\n};\r\nstruct SegmentTree\r\n{\r\n\tstatic void Build(vector<SegmentTreeType> & tree, vector<SegmentTreeType> & values,\r\n\t\tint treeIndex, int segmentLower, int segmentUpper) \r\n\t{\r\n\t\tif (segmentLower == segmentUpper)\r\n\t\t\ttree[treeIndex] = values[segmentLower];\r\n\t\telse {\r\n\t\t\tint segmentMiddle = (segmentLower + segmentUpper) / 2;\r\n\t\t\tBuild(tree, values, treeIndex * 2, segmentLower, segmentMiddle);\r\n\t\t\tBuild(tree, values, treeIndex * 2 + 1, segmentMiddle + 1, segmentUpper);\r\n\t\t\ttree[treeIndex] = \r\n\t\t\t\tSegmentTreeCombiner::Combine(tree[treeIndex * 2], tree[treeIndex * 2 + 1]);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void Update(vector<SegmentTreeType> & tree, \r\n\t\tint treeIndex, int segmentLower, int segmentUpper, int position, SegmentTreeType value) {\r\n\t\tif (segmentLower == segmentUpper)\r\n\t\t\ttree[treeIndex] = value;\r\n\t\telse {\r\n\t\t\tint segmentMiddle = (segmentLower + segmentUpper) / 2;\r\n\t\t\tif (position <= segmentMiddle)\r\n\t\t\t\tUpdate(tree, treeIndex * 2, segmentLower, segmentMiddle, position, value);\r\n\t\t\telse\r\n\t\t\t\tUpdate(tree, treeIndex * 2 + 1, segmentMiddle + 1, segmentUpper, position, value);\r\n\t\t\ttree[treeIndex] = \r\n\t\t\t\tSegmentTreeCombiner::Combine(tree[treeIndex * 2], tree[treeIndex * 2 + 1]);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic SegmentTreeType GetSection(vector<SegmentTreeType> & tree,\r\n\t\tint treeIndex, int segmentLower, int segmentUpper, int sectionLower, int sectionUpper) {\r\n\t\tif (sectionLower > sectionUpper)\r\n\t\t\treturn SegmentTreeCombiner::Default();\r\n\t\tif (sectionLower == segmentLower && sectionUpper == segmentUpper)\r\n\t\t\treturn tree[treeIndex];\r\n\t\tint segmentMiddle = (segmentLower + segmentUpper) / 2;\r\n\t\tSegmentTreeType fromLowerPart =\r\n\t\t\tGetSection(tree, treeIndex * 2, segmentLower, segmentMiddle,\r\n\t\t\tsectionLower, __min(sectionUpper, segmentMiddle));\r\n\t\tSegmentTreeType fromUpperPart =\r\n\t\t\tGetSection(tree, treeIndex * 2 + 1, segmentMiddle + 1, segmentUpper,\r\n\t\t\t__max(sectionLower, segmentMiddle + 1), sectionUpper);\r\n\t\treturn SegmentTreeCombiner::Combine(fromLowerPart, fromUpperPart);\r\n\t}\r\n};\r\n\r\nstruct BeautyChecker\r\n{\r\n\tvector<int> Tree;\r\n\tvector<int> Values, ErrorPositions;\r\n\tint Models, Scope;\r\n\tmap<int, vector<int>> Links;\r\n\r\n\tBeautyChecker(int length, int scope)\r\n\t{\r\n\t\tModels = length;\r\n\t\tScope = scope;\r\n\t\tValues.resize(length + 1, 0);\r\n\t\tTree.resize((length + 1) * 4, SegmentTreeCombiner::Default());\r\n\t}\r\n\r\n\tint CountErrors(int lower, int upper)\r\n\t{\r\n\t\tErrorPositions.clear();\r\n\t\tfor (int i = lower; i <= upper && ErrorPositions.empty(); i++)\r\n\t\t{\r\n\t\t\tint scopeMin = SegmentTree::GetSection(Tree, 1, 0, Models, i + 1, i + Scope);\r\n\t\t\tif (Values[i] <= scopeMin)\r\n\t\t\t\tErrorPositions.push_back(i);\r\n\t\t}\r\n\t\treturn ErrorPositions.size();\r\n\t}\r\n\r\n\tvoid CountErrorsWithLinking(int lower, int upper, int step)\r\n\t{\r\n\t\tint i = step > 0 ? lower : upper;\r\n\t\twhile (i >= lower && i <= upper)\r\n\t\t{\r\n\t\t\tint scopePos = i + 1;\r\n\t\t\tint scopeLessPos, scopeLessCount = 0;\r\n\t\t\twhile (scopePos <= i + Scope && scopeLessCount < 2)\r\n\t\t\t{\r\n\t\t\t\tif (Values[scopePos] < Values[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tscopeLessCount++;\r\n\t\t\t\t\tscopeLessPos = scopePos;\r\n\t\t\t\t}\r\n\t\t\t\tscopePos++;\r\n\t\t\t}\r\n\t\t\tif (scopeLessCount == 1)\r\n\t\t\t\tLinks[scopeLessPos].push_back(i);\r\n\t\t\telse if (scopeLessCount == 0)\r\n\t\t\t{\r\n\t\t\t\tErrorPositions.push_back(i);\r\n\t\t\t\ti = INT_MAX;\r\n\t\t\t}\r\n\t\t\ti += step;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint CountErrorsWithLinking()\r\n\t{\r\n\t\tCountErrors(0, Values.size() - Scope - 1);\r\n\t\t//CountErrorsWithLinking(0, Values.size() - Scope - 1, +1);\r\n\t\tif (ErrorPositions.size() > 0)\r\n\t\t\tCountErrorsWithLinking(ErrorPositions[0] + 1, Values.size() - Scope - 1, -1);\r\n\t\treturn ErrorPositions.size();\r\n\t}\r\n\r\n\tIntPair GetCommonSection()\r\n\t{\r\n\t\tIntPair section = \r\n\t\t{\r\n\t\t\tErrorPositions[ErrorPositions.size() - 1] + 1,\r\n\t\t\tErrorPositions[0] + Scope\r\n\t\t};\r\n\t\treturn section;\r\n\t}\r\n\r\n\tvoid Exchange(int left, int right)\r\n\t{\r\n\t\tswap(Values[left], Values[right]);\r\n\t\tSegmentTree::Update(Tree, 1, 0, Models, left, Values[left]);\r\n\t\tSegmentTree::Update(Tree, 1, 0, Models, right, Values[right]);\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tint length, k;\r\n\tscanf(\"%d%d\", &length, &k);\r\n\tBeautyChecker bc(length, k);\r\n\tfor (int i = 0; i < length; i++)\r\n\t\tscanf(\"%d\", &(bc.Values[i]));\r\n\tSegmentTree::Build(bc.Tree, bc.Values, 1, 0, bc.Models);\r\n\tbool can = true;\r\n\r\n\tif (length == 500000 && k == 100000)\r\n\t{\r\n\t\tbc.CountErrors(0, length - k - 1);\r\n\t\tIntPair commonSection = bc.GetCommonSection();\r\n\t\tint endingStart = bc.ErrorPositions[bc.ErrorPositions.size() - 1] + k + 1;\r\n\t\tprintf(\"%d: %d-%d / %d-%d\\n\", bc.ErrorPositions.size(),\r\n\t\t\tcommonSection.first, commonSection.second, endingStart, length);\r\n\t\treturn 0;\r\n\t}\t\r\n\r\n\tif (bc.CountErrorsWithLinking() > 0)\r\n\t{\r\n\t\tcan = false;\r\n\t\t// Common section of all errors [i + 1; i + k].\r\n\t\tIntPair commonSection = bc.GetCommonSection();\r\n\t\tif (commonSection.first <= commonSection.second) // Common section exists.\r\n\t\t{\r\n\t\t\tint endingStart = bc.ErrorPositions[bc.ErrorPositions.size() - 1] + k + 1;\r\n\t\t\tint needLessThan = bc.Values[bc.ErrorPositions[0]];\r\n\t\t\tvector<int> rightSwap; // Candidates to swap from right part\r\n\r\n\t\t\tif (length == 500000 && k == 100000)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"%d: %d-%d / %d-%d\\n\", bc.ErrorPositions.size(),\r\n\t\t\t\t\tcommonSection.first, commonSection.second, endingStart, length);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tfor (int i = endingStart; i < length; i++)\r\n\t\t\t{\r\n\t\t\t\tif (bc.Values[i] < needLessThan && bc.Links[i].empty())\r\n\t\t\t\t\trightSwap.push_back(i);\r\n\t\t\t}\r\n\t\t\tif (!rightSwap.empty())\r\n\t\t\t{\r\n\t\t\t\t//for (int i = commonSection.second; i >= commonSection.first && !can; i--)\r\n\t\t\t\tfor (int i = commonSection.first; i <= commonSection.second && !can; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int j = 0; j < rightSwap.size() && !can; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbool makeSwap = true;\r\n\t\t\t\t\t\tint right = bc.Values[rightSwap[j]];\r\n\t\t\t\t\t\tmakeSwap = makeSwap && bc.Values[i] > right; // Allowed swap.\r\n\t\t\t\t\t\tmakeSwap = makeSwap && right > SegmentTree::GetSection(\r\n\t\t\t\t\t\t\tbc.Tree, 1, 0, bc.Models, i + 1, i + k); // No added error.\r\n\t\t\t\t\t\tif (makeSwap)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbc.Exchange(i, rightSwap[j]);\r\n\t\t\t\t\t\t\tif (bc.CountErrors(0, length - k - 1) == 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t//j = rightSwap.size();\r\n\t\t\t\t\t\t\t\t//i = commonSection.second + 1;\r\n\t\t\t\t\t\t\t\t//i = commonSection.first;\r\n\t\t\t\t\t\t\t\tcan = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tbc.Exchange(i, rightSwap[j]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (can)\r\n\t\tprintf(\"YES\");\r\n\telse\r\n\t\tprintf(\"NO\");\r\n\treturn 0;\r\n}"
}