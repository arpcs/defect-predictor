{
    "id": 187065181,
    "contestId": 1592,
    "creationTimeSeconds": 1672249394,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1592,
        "index": "F1",
        "name": "Alice and Recoloring 1",
        "type": "PROGRAMMING",
        "points": 1750.0,
        "rating": 2600,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1592,
        "members": [
            {
                "handle": "Benq"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1633271700
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 35,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 102400,
    "source": "#include <algorithm>\r\n#include <array>\r\n#include <bitset>\r\n#include <cassert>\r\n#include <chrono>\r\n#include <cmath>\r\n#include <complex>\r\n#include <cstring>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <map>\r\n#include <numeric>\r\n#include <queue>\r\n#include <random>\r\n#include <set>\r\n#include <vector>\r\n#include <climits>\r\nusing namespace std;\r\n \r\nusing ll = long long;\r\nusing db = long double; // or double, if TL is tight\r\nusing str = string; // yay python! \r\n\r\n// pairs\r\nusing pi = pair<int,int>;\r\nusing pl = pair<ll,ll>;\r\nusing pd = pair<db,db>;\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n\r\n#define tcT template<class T\r\n#define tcTU tcT, class U\r\n// ^ lol this makes everything look weird but I'll try it\r\ntcT> using V = vector<T>; \r\ntcT, size_t SZ> using AR = array<T,SZ>; \r\nusing vi = V<int>;\r\nusing vb = V<bool>;\r\nusing vl = V<ll>;\r\nusing vd = V<db>;\r\nusing vs = V<str>;\r\nusing vpi = V<pi>;\r\nusing vpl = V<pl>;\r\nusing vpd = V<pd>;\r\n\r\n// vectors\r\n// oops size(x), rbegin(x), rend(x) need C++17\r\n#define sz(x) int((x).size())\r\n#define bg(x) begin(x)\r\n#define all(x) bg(x), end(x)\r\n#define rall(x) x.rbegin(), x.rend() \r\n#define sor(x) sort(all(x)) \r\n#define rsz resize\r\n#define ins insert \r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ft front()\r\n#define bk back()\r\n\r\n#define lb lower_bound\r\n#define ub upper_bound\r\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\r\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\r\n\r\n// loops\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define rep(a) F0R(_,a)\r\n#define each(a,x) for (auto& a: x)\r\n\r\nconst int MOD = (int)1e9+7; // 998244353;\r\nconst int MX = (int)2e5+5;\r\nconst ll BIG = 1e18; // not too close to LLONG_MAX\r\nconst db PI = acos((db)-1);\r\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\r\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \r\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\r\n\r\n// bitwise ops\r\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\r\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\r\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\r\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \r\nconstexpr int p2(int x) { return 1<<x; }\r\nconstexpr int msk2(int x) { return p2(x)-1; }\r\n\r\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\r\n\r\ntcT> bool ckmin(T& a, const T& b) {\r\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\r\ntcT> bool ckmax(T& a, const T& b) {\r\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\r\n\r\ntcTU> T fstTrue(T lo, T hi, U f) {\r\n\t++hi; assert(lo <= hi); // assuming f is increasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo)/2;\r\n\t\tf(mid) ? hi = mid : lo = mid+1; \r\n\t} \r\n\treturn lo;\r\n}\r\ntcTU> T lstTrue(T lo, T hi, U f) {\r\n\t--lo; assert(lo <= hi); // assuming f is decreasing\r\n\twhile (lo < hi) { // find first index such that f is true \r\n\t\tT mid = lo+(hi-lo+1)/2;\r\n\t\tf(mid) ? lo = mid : hi = mid-1;\r\n\t} \r\n\treturn lo;\r\n}\r\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\r\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\r\ntcTU> void erase(T& t, const U& u) { // don't erase\r\n\tauto it = t.find(u); assert(it != end(t));\r\n\tt.erase(it); } // element that doesn't exist from (multi)set\r\n\r\n#define tcTUU tcT, class ...U\r\n\r\ninline namespace Helpers {\r\n\t//////////// is_iterable\r\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\r\n\t// this gets used only when we can call begin() and end() on that type\r\n\ttcT, class = void> struct is_iterable : false_type {};\r\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\r\n\t                                  decltype(end(declval<T>()))\r\n\t                                 >\r\n\t                       > : true_type {};\r\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\r\n\r\n\t//////////// is_readable\r\n\ttcT, class = void> struct is_readable : false_type {};\r\n\ttcT> struct is_readable<T,\r\n\t        typename std::enable_if_t<\r\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\r\n\t        >\r\n\t    > : true_type {};\r\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\r\n\r\n\t//////////// is_printable\r\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\r\n\ttcT, class = void> struct is_printable : false_type {};\r\n\ttcT> struct is_printable<T,\r\n\t        typename std::enable_if_t<\r\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\r\n\t        >\r\n\t    > : true_type {};\r\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\r\n}\r\n\r\ninline namespace Input {\r\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\r\n\ttcTUU> void re(T& t, U&... u);\r\n\ttcTU> void re(pair<T,U>& p); // pairs\r\n\r\n\t// re: read\r\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\r\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\r\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\r\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\r\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\r\n\t\teach(x,i) re(x); }\r\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\r\n\r\n\t// rv: resize and read vectors\r\n\tvoid rv(size_t) {}\r\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\r\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\r\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\r\n\t\tt.rsz(N); re(t);\r\n\t\trv(N,u...); }\r\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\r\n\t\trv(N2,u...); }\r\n\r\n\t// dumb shortcuts to read in ints\r\n\tvoid decrement() {} // subtract one from each\r\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\r\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\r\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\r\n}\r\n\r\ninline namespace ToString {\r\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\r\n\r\n\t// ts: string representation to print\r\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\r\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\r\n\t\treturn ss.str(); } // default\r\n\ttcT> str bit_vec(T t) { // bit vector to string\r\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\r\n\t\tres += \"}\"; return res; }\r\n\tstr ts(V<bool> v) { return bit_vec(v); }\r\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\r\n\ttcTU> str ts(pair<T,U> p); // pairs\r\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\r\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\r\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\r\n\t\t// convert container to string w/ separator sep\r\n\t\tbool fst = 1; str res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += sep;\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\r\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\r\n\r\n\t// for nested DS\r\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \r\n\t  ts_lev(const T& v) { return {ts(v)}; }\r\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \r\n\t  ts_lev(const T& v) {\r\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\r\n\t\tvs res;\r\n\t\tfor (const auto& t: v) {\r\n\t\t\tif (sz(res)) res.bk += \",\";\r\n\t\t\tvs tmp = ts_lev<lev-1>(t);\r\n\t\t\tres.ins(end(res),all(tmp));\r\n\t\t}\r\n\t\tF0R(i,sz(res)) {\r\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\r\n\t\t\tres[i] = bef+res[i];\r\n\t\t}\r\n\t\tres.bk += \"}\";\r\n\t\treturn res;\r\n\t}\r\n}\r\n\r\ninline namespace Output {\r\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\r\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\r\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\r\n\t// print w/ no spaces\r\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \r\n\t// print w/ spaces, end with newline\r\n\tvoid ps() { cout << \"\\n\"; }\r\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \r\n\t// debug to cerr\r\n\ttemplate<class ...T> void dbg_out(const T&... t) {\r\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\r\n\tvoid loc_info(int line, str names) {\r\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\r\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\r\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\r\n\t#ifdef LOCAL\r\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\r\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\r\n\t#else // don't actually submit with this\r\n\t\t#define dbg(...) 0\r\n\t\t#define dbgl(lev,x) 0\r\n\t#endif\r\n\r\n\t// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\r\n\tconst auto beg = std::chrono::high_resolution_clock::now();\r\n\tvoid dbg_time() {\r\n\t\tauto duration = chrono::duration<double>(\r\n\t\t\tstd::chrono::high_resolution_clock::now() - beg);\r\n\t\tdbg(duration.count());\r\n\t}\r\n}\r\n\r\ninline namespace FileIO {\r\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\r\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\n\tvoid setIO(str s = \"\") {\r\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\r\n\t\t// cin.exceptions(cin.failbit);\r\n\t\t// throws exception when do smth illegal\r\n\t\t// ex. try to read letter into int\r\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\r\n\t}\r\n}\r\n\r\nint main() {\r\n\t// read read read\r\n\tsetIO();\r\n\tints(N,M);\r\n\tV<vi> parity(N+1, vi(M+1));\r\n\tvs S(N); re(S);\r\n\tF0R(i,N) F0R(j,M) {\r\n\t\tparity[i][j] = S[i][j] == 'B';\r\n\t}\r\n\tF0R(i,N) F0R(j,M) {\r\n\t\tparity[i][j] ^= parity[i+1][j];\r\n\t\tparity[i][j] ^= parity[i][j+1];\r\n\t\tparity[i][j] ^= parity[i+1][j+1];\r\n\t}\r\n\tbool decrease = 0;\r\n\tF0R(i,N-1) F0R(j,M-1) {\r\n\t\tdecrease |= parity[i][j] && parity[i][M-1] && parity[N-1][i] && parity[N-1][M-1];\r\n\t}\r\n\tint sum = 0;\r\n\tF0R(i,N) F0R(j,M) sum += parity[i][j];\r\n\tdbg(sum, decrease);\r\n\tps(sum - decrease);\r\n\t// you should actually read the stuff at the bottom\r\n}\r\n\r\n/* stuff you should look for\r\n\t* int overflow, array bounds\r\n\t* special cases (n=1?)\r\n\t* do smth instead of nothing and stay organized\r\n\t* WRITE STUFF DOWN\r\n\t* DON'T GET STUCK ON ONE APPROACH\r\n*/\r\n"
}