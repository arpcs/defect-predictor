{
    "id": 187465992,
    "contestId": 1627,
    "creationTimeSeconds": 1672504893,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1627,
        "index": "E",
        "name": "Not Escaping",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "shortest paths",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1627,
        "members": [
            {
                "handle": "unratedandpractise"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1642257300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 78,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\n#define int long long\r\n#define pb push_back\r\n#define ff first\r\n#define ss second\r\n#define all(x) (x).begin(), (x).end()\r\n#define rep(i,x,y) for(int i=x; i<y; i++)\r\n#define pii pair<int,int>\r\n#define vii vector<pair<int,int>>\r\n#define vi vector<int>\r\n#define setbits(x) __builtin_popcountll(x)\r\n#define prevzeros(x) __builtin_clzll(x)                 //do 64 minus-x\r\n#define afterzeros(x) __builtin_ctzll(x)\r\n#define mp make_pair\r\nconst int mod = 1e9 + 7;\r\nint mod1 = 998244353;\r\ntypedef long double ld;\r\n// using namespace __gnu_pbds;\r\n// template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\nint inv(int i)\r\n{\r\n    if (i == 1) return 1;\r\n    return (mod1 - ((mod1 / i) * inv(mod1 % i)) % mod1) % mod1;\r\n}\r\n//-----------------------------------------------------//\r\nint power(int a, int b, int p)\r\n{\r\n    if (a == 0)\r\n        return 0;\r\n    int res = 1;\r\n    a %= p;\r\n    while (b > 0)\r\n    {\r\n        if (b & 1)\r\n            res = (res * a) % p;\r\n        b >>= 1;\r\n        a = (a * a) % p;\r\n    }\r\n    return res;\r\n}\r\n//-----------------------------------------------------//\r\nint fact(int n, int m)\r\n{\r\n\r\n    int p = 1;\r\n    if (n == 0)\r\n        return 1;\r\n    else\r\n    {\r\n        for (int i = 1; i <= n; i++)\r\n        {\r\n            p *= i;\r\n            p = p % m;\r\n        }\r\n        return p;\r\n    }\r\n}\r\n//-----------------------------------------------------//\r\n\r\n// int ncr(int n, int r)\r\n// {\r\n//     int ans = 1;\r\n//     rep(i, n - r + 1, n + 1)\r\n//     {\r\n//         ans *= i;\r\n//     }\r\n//     rep(i, 1, r + 1)\r\n//     {\r\n//         ans /= i;\r\n//     }\r\n//     return ans;\r\n// }\r\n//-----------------------------------------------------//\r\n\r\n// int findXOR(int n)\r\n// {\r\n//     int mod = n % 4;\r\n\r\n//     if (mod == 0)\r\n//         return n;\r\n\r\n//     else if (mod == 1)\r\n//         return 1;\r\n\r\n//     else if (mod == 2)\r\n//         return n + 1;\r\n\r\n//     else if (mod == 3)\r\n//         return 0;\r\n//     return 0;\r\n// }\r\n// int findXOR(int l, int r)\r\n// {\r\n//     return (findXOR(l - 1) ^ findXOR(r));\r\n// }\r\n//-----------------------------------------------------//\r\n\r\nint powe(int a, int b)\r\n{\r\n    if (a == 0)\r\n        return 0;\r\n    int res = 1;\r\n    while (b > 0)\r\n    {\r\n        if (b & 1)\r\n            res = (res * a) ;\r\n        b >>= 1;\r\n        a *= a ;\r\n    }\r\n    return res;\r\n}\r\n//-----------------------------------------------------//\r\n\r\n// const int N = 200001;\r\n// int f[N];\r\n// int invf[N];\r\n// int ncr(int n, int r)\r\n// {\r\n//     if (n < 0 || r < 0 || n < r)\r\n//         return 0;\r\n//     int ans = f[n];\r\n//     ans = (ans * invf[n - r]) % mod;\r\n//     ans = (ans * invf[r]) % mod;\r\n//     return ans;\r\n// }\r\n\r\n\r\n// f[0] = 1;\r\n// for (int i = 1; i <= N; i++)\r\n//     f[i] = (f[i - 1] * i) % mod;\r\n// for (int i = 0; i <= N; i++)\r\n//     invf[i] = inv(f[i]);\r\n\r\n\r\n//-----------------------------------------------------//\r\nint inverse(int a, int p)\r\n{\r\n    return power(a, p - 2, p);\r\n}\r\nint nCrmod(int n, int r)\r\n{\r\n    if (n < 0 || r < 0 || r > n)\r\n        return 0;\r\n    if (r == 0)return 1;\r\n    return (((n * nCrmod(n - 1, r - 1)) % mod) * inv(r)) % mod;\r\n}\r\n///////////\r\n// const int N = 200005;\r\n// int spf[N];\r\n// void spfcalc()\r\n// {\r\n//     for (int i = 0; i < N; i++) {\r\n//         spf[i] = i;\r\n//     }\r\n//     for (int i = 2; i * i < N; i++) {\r\n//         if (spf[i] == i) {\r\n//             for (int j = i * i; j < N; j += i) {\r\n//                 if (spf[j] == j) {\r\n//                     spf[j] = i;\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n// vi primes;\r\n// const int N = 101;\r\n// bool isprime[N];\r\n// void primefind()\r\n// {\r\n//     rep(i, 0, N)\r\n//     {\r\n//         isprime[i] = true;\r\n//     }\r\n//     isprime[0] = false;\r\n//     isprime[1] = false;\r\n//     for (int i = 2; i * i <= N; i++)\r\n//     {\r\n//         if (isprime[i])\r\n//         {\r\n//             for (int j = i * i; j <= N; j += i)\r\n//             {\r\n//                 isprime[j] = false;\r\n//             }\r\n//         }\r\n//     }\r\n//     for (int i = 2; i < N; i++)\r\n//     {\r\n//         if (isprime[i])primes.pb(i);\r\n//     }\r\n// }\r\n\r\n//-----------------------KMP---------------------------//\r\n\r\n// vector<int> pi(const string &s) {\r\n//  int n = (int)s.size();\r\n//  vector<int> pi_s(n);\r\n//  for (int i = 1, j = 0; i < n; i++) {\r\n//      while (j > 0 && s[j] != s[i]) {\r\n//          j = pi_s[j - 1];\r\n//      }\r\n//      if (s[i] == s[j]) {\r\n//          j++;\r\n//      }\r\n//      pi_s[i] = j;\r\n//  }\r\n//  return pi_s;\r\n// }\r\n//-----------------------------------------------------//\r\n\r\n//g++ -O2 -std=c++11 -Wall -Wl,--stack=268435456 b.cpp -o a.exe\r\n\r\n\r\nint32_t main()\r\n{\r\n\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"debug.txt\", \"w\" , stderr);\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\r\n\r\n\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\r\n    int t = 1;\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n        int n, m, k;\r\n        cin >> n >> m >> k;\r\n        int a[n];\r\n        rep(i, 0, n)cin >> a[i];\r\n        int b[k][5];\r\n        vector<vector<pair<pii, pii>>>travel(n + 1);\r\n        rep(i, 0, k)\r\n        {\r\n            rep(j, 0, 5)cin >> b[i][j];\r\n        }\r\n        rep(i, 0, k)\r\n        {\r\n            travel[b[i][0]].pb({{b[i][1], b[i][2]}, {b[i][3], b[i][4]}});               //y1,x2,y2,health\r\n        }\r\n        vector<vii>vec(n + 1);\r\n        for (int i = 0; i < n + 1; i++)\r\n        {\r\n            sort(all(travel[i]));\r\n        }\r\n        vec[1].pb({1, 0});                                                          //x1,health\r\n\r\n        for (int i = 1; i < n; i++)\r\n        {\r\n\r\n            sort(all(vec[i]));\r\n            int al = vec[i].size();\r\n            if (al == 0)continue;\r\n\r\n            vii temp;\r\n            for (int j = 0; j < al;)\r\n            {\r\n                int al = vec[i][j].ff;\r\n                int tar = vec[i][j].ss;\r\n                while (vec[i][j].ff == al)\r\n                {\r\n\r\n\r\n                    tar = min(tar, vec[i][j].ss);\r\n                    j++;\r\n                }\r\n                temp.pb({al, tar});\r\n            }\r\n            vec[i].clear();\r\n            for (auto xx : temp)vec[i].pb(xx);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            vii pre(al);\r\n            vii suff(al);\r\n            pre[0] = vec[i][0];\r\n            suff[al - 1] = vec[i][al - 1];\r\n            for (int j = 1; j < al; j++)\r\n            {\r\n                pre[j].ff = vec[i][j].ff;\r\n                pre[j].ss = min(vec[i][j].ss, pre[j - 1].ss + ((vec[i][j].ff - vec[i][j - 1].ff) * a[i - 1]));\r\n            }\r\n            for (int j = al - 2; j >= 0; j--)\r\n            {\r\n                suff[j].ff = vec[i][j].ff;\r\n                suff[j].ss = min(vec[i][j].ss, suff[j + 1].ss + a[i - 1] * (vec[i][j + 1].ff - vec[i][j].ff));\r\n            }\r\n            for (auto x : travel[i])\r\n            {\r\n                int mnhealth = 1e18;\r\n                if (vec[i][0].ff <= x.ff.ff)\r\n                {\r\n                    pii alpha = {x.ff.ff, -1e18};\r\n                    int idx = lower_bound(all(vec[i]), alpha) - vec[i].begin();\r\n                    if (vec[i][idx].ff != x.ff.ff)idx--;\r\n                    mnhealth = min(mnhealth, vec[i][idx].ss + a[i - 1] * (x.ff.ff - vec[i][idx].ff));\r\n                }\r\n                if (vec[i][al - 1].ff >= x.ff.ff)\r\n                {\r\n                    pii alpha = {x.ff.ff, -1e18};\r\n                    int idx = lower_bound(all(vec[i]), alpha) - vec[i].begin();\r\n                    mnhealth = min(mnhealth, vec[i][idx].ss + a[i - 1] * (-x.ff.ff + vec[i][idx].ff));\r\n                }\r\n                vec[x.ff.ss].pb({x.ss.ff, mnhealth - x.ss.ss});\r\n            }\r\n        }\r\n\r\n\r\n        if (vec[n].size() == 0)\r\n        {\r\n            cout << \"NO ESCAPE\\n\";\r\n        }\r\n        else\r\n        {\r\n            int ans = 1e18;\r\n            for (int i = 0; i < vec[n].size(); i++)\r\n            {\r\n                ans = min(ans, vec[n][i].ss + a[n - 1] * (abs(m - vec[n][i].ff)));\r\n            }\r\n            cout << ans << '\\n';\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    return 0;\r\n}"
}