{
    "id": 188159057,
    "contestId": 1627,
    "creationTimeSeconds": 1672975224,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1627,
        "index": "E",
        "name": "Not Escaping",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2200,
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "shortest paths",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1627,
        "members": [
            {
                "handle": "ZrjaK"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1642257300
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 62,
    "timeConsumedMillis": 1138,
    "memoryConsumedBytes": 99942400,
    "source": "import random, sys, os, math, threading, gc\r\nfrom collections import Counter, defaultdict, deque\r\nfrom functools import lru_cache, reduce, cmp_to_key\r\nfrom itertools import accumulate, combinations, permutations, product\r\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush\r\nfrom io import BytesIO, IOBase\r\nfrom copy import deepcopy\r\nfrom bisect import bisect_left, bisect_right\r\nfrom math import factorial, ceil, floor, gcd\r\nfrom operator import mul, xor\r\nfrom types import GeneratorType\r\nfrom fractions import Fraction\r\n# sys.setrecursionlimit(2*10**5)\r\nBUFSIZE = 8192\r\nMOD = 10**9 + 7\r\nMODD = 998244353\r\nINF = float('inf')\r\nD4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\r\nD8 = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]\r\n\r\ndef solve():\r\n    n, m, k = LII()\r\n    cost = LII()\r\n    arr = [[] for _ in range(n)]\r\n    arr[0].append(0)\r\n    arr[n-1].append(m-1)\r\n    lad = [[] for _ in range(n)]\r\n    for _ in range(k):\r\n        a, b, c, d, h = LII()\r\n        a -= 1; b -= 1; c -= 1; d -= 1\r\n        arr[a].append(b)\r\n        arr[c].append(d)\r\n        lad[a].append((b, c, d, h))\r\n    for i in range(n):\r\n        arr[i].sort()\r\n        lad[i].sort()\r\n    dp = [[INF] * len(arr[i]) for i in range(n)]\r\n    dp[0][0] = 0\r\n    arr_inv = [{v: i for i, v in enumerate(arr[i])} for i in range(n)]\r\n    for i in range(n):\r\n        for j in range(1, len(arr[i])):\r\n            dp[i][j] = min(dp[i][j], dp[i][j-1] + cost[i] * (arr[i][j] - arr[i][j-1]))\r\n        for j in range(len(arr[i])-2, -1, -1):\r\n            dp[i][j] = min(dp[i][j], dp[i][j+1] + cost[i] * (arr[i][j+1] - arr[i][j]))\r\n        idx = 0\r\n        for j in range(len(arr[i])):\r\n            if dp[i][j] == INF:\r\n                continue\r\n            while idx < len(lad[i]) and lad[i][idx][0] < arr[i][j]:\r\n                idx += 1\r\n            while idx < len(lad[i]):\r\n                if lad[i][idx][0] == arr[i][j]:\r\n                    _, c, d, h = lad[i][idx]\r\n                    dp[c][arr_inv[c][d]] = min(dp[c][arr_inv[c][d]], dp[i][j] - h)\r\n                    idx += 1\r\n                else:\r\n                    break\r\n    print(dp[-1][-1] if dp[-1][-1] != INF else \"NO ESCAPE\")\r\n    \r\n    \r\n\r\ndef main():\r\n    t = 1\r\n    t = II()\r\n    for _ in range(t):\r\n        solve()\r\n\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\ndef bitcnt(n):\r\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\r\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\r\n    c = (c & 0x0F0F0F0F0F0F0F0F) + ((c >> 4) & 0x0F0F0F0F0F0F0F0F)\r\n    c = (c & 0x00FF00FF00FF00FF) + ((c >> 8) & 0x00FF00FF00FF00FF)\r\n    c = (c & 0x0000FFFF0000FFFF) + ((c >> 16) & 0x0000FFFF0000FFFF)\r\n    c = (c & 0x00000000FFFFFFFF) + ((c >> 32) & 0x00000000FFFFFFFF)\r\n    return c\r\n\r\ndef lcm(x, y):\r\n    return x * y // gcd(x, y)\r\n\r\ndef lowbit(x):\r\n    return x & -x\r\n\r\n@bootstrap\r\ndef exgcd(a: int, b: int):\r\n    if b == 0:\r\n        d, x, y = a, 1, 0\r\n    else:\r\n        (d, p, q) = yield exgcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a // b)\r\n \r\n    yield d, x, y\r\n\r\ndef perm(n, r):\r\n    return factorial(n) // factorial(n - r) if n >= r else 0\r\n \r\ndef comb(n, r):\r\n    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\r\n\r\ndef probabilityMod(x, y, mod):\r\n    return x * pow(y, mod-2, mod) % mod\r\n\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n \r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n \r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n \r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n \r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n \r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n \r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n \r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n \r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n \r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n \r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n \r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n \r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n \r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n \r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n \r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n \r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n \r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n \r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n \r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\n\r\ndef II():\r\n    return int(input())\r\n\r\ndef MI():\r\n    return map(int, input().split())\r\n\r\ndef LI():\r\n    return list(input().split())\r\n\r\ndef LII():\r\n    return list(map(int, input().split()))\r\n\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\ndef LGMI():\r\n    return list(map(lambda x: int(x) - 1, input().split()))\r\n\r\ndef debug(*args):\r\n    print('\\033[92m', end='')\r\n    print(*args)\r\n    print('\\033[0m', end='')\r\n\r\nif __name__ == \"__main__\":\r\n    main()"
}