{
    "id": 161661973,
    "contestId": 1096,
    "creationTimeSeconds": 1656089852,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1096,
        "index": "F",
        "name": "Inversion Expectation",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "dp",
            "math",
            "probabilities"
        ]
    },
    "author": {
        "contestId": 1096,
        "members": [
            {
                "handle": "Mc3X"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1546007700
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 31,
    "memoryConsumedBytes": 3174400,
    "source": "#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n//#include <cstdalign>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n#include <cwchar>\r\n#include <cwctype>\r\n#endif\r\n \r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n \r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\nusing namespace std;\r\nusing i64 = long long;\r\nusing i128 = __int128;\r\n#define MAXN 200005\r\n#define MAXM 200005\r\n#define K 17\r\n#define MAXP 25\r\n#define MAXK 55\r\n#define MAXC 255\r\n#define MAXERR 105\r\n#define MAXLEN 105\r\n#define MDIR 10\r\n#define MAXR 705\r\n#define BASE 102240\r\n#define MAXA 28\r\n#define MAXT 100005\r\n#define LIMIT 86400\r\n#define MAXV 305\r\n#define LEQ 1\r\n#define EQ 0\r\n#define OP 0\r\n#define CLO 1\r\n#define DIG 1\r\n#define C1 0\r\n#define C2 1\r\n#define PLUS 0\r\n#define MINUS 1\r\n#define MUL 2\r\n#define CLO 1\r\n#define VERT 1\r\n#define B 31\r\n#define B2 1007\r\n#define W 1\r\n#define H 18\r\n#define SPEC 1\r\n#define MUL 2\r\n#define CNT 3\r\n#define ITER 1000\r\n#define INF 1e9\r\n#define EPS 1e-9\r\n#define MOD 998244353\r\n#define CONST 998244353\r\n#define FACT 100000000000000\r\n#define PI 3.14159265358979\r\n#define SRC 0\r\n#define pb push_back\r\n#define eb emplace_back\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef pair<int,int> ii;\r\ntypedef pair<ll,ii> pl;\r\ntypedef pair<int,ll> li;\r\ntypedef pair<ll,ll> iv;\r\ntypedef tuple<int,int,int> iii;\r\ntypedef vector<vector<int>> vv;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\n//typedef pair<ld,int> iv;\r\ntypedef vector<ii> vii;\r\ntypedef vector<vector<ll>> vll;\r\n//typedef complex<double> cd;\r\n#define sc second\r\n#define fr first\r\n#define rep(i,x,y) for (int i = (x); i < (y); ++i)\r\n#define rev(i,x,y) for (int i = (x); i >= (y); --i)\r\n#define LSOne(S) (S & (-S))\r\n#define trav(i,v) for (auto &i : v)\r\n#define foreach(it,v) for (auto it = begin(v); it != end(v); ++it)\r\n#define sortarr(v) sort(begin(v), end(v))\r\n\r\nint n;\r\nvector<int> v, zero;\r\nll raise(int b, int p) {\r\n    ll ans = 1, k = b;\r\n    while (p) {\r\n        if (p & 1) ans = (ans * k) % MOD;\r\n        k = (k * k) % MOD;\r\n        p >>= 1;\r\n    }\r\n    return ans;\r\n}\r\n\r\nll inv(int b) {\r\n    return raise(b, MOD - 2);\r\n}\r\n\r\nstruct fenwick {\r\n    vector<int> v;\r\n    int n;\r\n    fenwick(int num) {\r\n        n = num;\r\n        v.resize(n + 5);\r\n    }\r\n    void update(int i){\r\n        for (; i <= n; i += LSOne(i)) v[i]++;\r\n    \r\n    }\r\n    int query(int i) {\r\n        int ans = 0;\r\n        for (; i; i -= LSOne(i)) ans += v[i];\r\n        return ans;\r\n    }\r\n};\r\n\r\nint main() {\r\n    vector<ll> invf(MAXN), fact(MAXN);\r\n    invf[0] = fact[0] = fact[1] = invf[1] = 1LL;\r\n    rep(i,2,MAXN) invf[i] = (invf[i - 1] * inv(i)) % MOD, fact[i] = (fact[i - 1] * (ll)(i)) % MOD;\r\n    //cout << invf[2] << '\\n';\r\n    cin >> n;\r\n    fenwick ft(n);\r\n    vector<bool> used(n, false);\r\n    vector<int> arr;\r\n    int unused = 0;\r\n    rep(i,0,n) {\r\n        int a; cin >> a;\r\n        if (a != -1) {\r\n            used[a - 1] = true;\r\n            arr.eb(a - 1);\r\n        } else zero.eb(i), unused++, arr.eb(-1);\r\n    }\r\n    rep(i,0,n) {\r\n        if (!used[i]) v.eb(i);\r\n    }\r\n    ll ans = 0, pairs = ((ll)(unused) * (ll)(unused - 1)) / 2;\r\n    pairs %= MOD;\r\n    //expected inversions is sum of the probability of each inversion happening\r\n    rev(i,n-1,0) {\r\n        //number of -1's before this current index\r\n        int lft;\r\n        auto it2 = lower_bound(zero.begin(), zero.end(), i);\r\n        if (it2 == zero.begin() || zero.empty()) lft = 0;\r\n        else {\r\n            it2--;\r\n            lft = (int)(it2 - zero.begin()) + 1;\r\n        }\r\n        //cout << i << ' ' << lft << '\\n';\r\n        if (arr[i] != -1) {\r\n            //numbers that are larger but unused\r\n            auto it = lower_bound(v.begin(), v.end(), arr[i]);\r\n            int nlft = -1;\r\n            if (it == v.begin()) nlft = n;\r\n            else {\r\n                it--;\r\n                nlft = n - (int)(it - v.begin()) - 1;\r\n            }\r\n            //inversion with a number in front of this number\r\n            if (unused) {\r\n                ll incr = ((ll)(lft) * (ll)(nlft)) % MOD;\r\n                incr = (fact[unused - 1] * incr) % MOD;\r\n                incr = (incr * invf[unused]);\r\n                ans = (ans + incr) % MOD;\r\n            }\r\n            //compute all fixed inversions here\r\n            ans = (ans + ft.query(arr[i] + 1)) % MOD;\r\n            ft.update(arr[i] + 1);\r\n            \r\n            //fixed number forms an inversion with an index behind it and has a smaller number assigned to it\r\n            int smaller = n - nlft;\r\n            int back = unused - lft;\r\n            //if (arr[i] == 2) cout << smaller << ' ' << back << '\\n';\r\n            if (unused) {\r\n                ll incr = ((ll)(smaller) * (ll)(back)) % MOD;\r\n                incr = (fact[unused - 1] * incr) % MOD;\r\n                incr = (incr * invf[unused]);\r\n                ans = (ans + incr) % MOD;\r\n            }\r\n        } else if (unused - 2 >= 0) {\r\n            ll incr = (ll)(lft) * (pairs) % MOD;\r\n            incr = (fact[unused - 2] * incr) % MOD;\r\n            incr = (invf[unused] * incr) % MOD;\r\n            ans = (ans + incr) % MOD;\r\n        }\r\n    }\r\n    cout << ans;\r\n}"
}