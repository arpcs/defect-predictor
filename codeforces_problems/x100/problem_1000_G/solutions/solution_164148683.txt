{
    "id": 164148683,
    "contestId": 1000,
    "creationTimeSeconds": 1657803256,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1000,
        "index": "G",
        "name": "Two-Paths",
        "type": "PROGRAMMING",
        "rating": 2700,
        "tags": [
            "data structures",
            "dp",
            "trees"
        ]
    },
    "author": {
        "contestId": 1000,
        "members": [
            {
                "handle": "-wicton-"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1530110100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "//\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u6446\u70c2\u5462\uff1f\uff1f\n#include <bits/stdc++.h>\n#define eb emplace_back\n#define pb push_back\nusing namespace std;\nusing LL = long long;\nusing ui = unsigned int;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pli = pair<LL, int>;\nusing pil = pair<int, LL>;\nusing pll = pair<LL, LL>;\ntemplate <class T>\n  using vi = vector<T>;\ntemplate <class T>\n  using bastr = basic_string<T>;\ntemplate <class T>\nbool cmin(T& x, const T& y) {\n    if (x > y) { x = y; return 1; }\n    return 0;\n}\ntemplate <class T>\nbool cmax(T& x, const T& y) {\n    if (x < y) { x = y; return 1; }\n    return 0;\n}\ntemplate <class T>\nint cs(const T& v) {\n    return static_cast<int>(v.size());\n}\ntemplate <int m>\nstruct static_modint {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        assert(_v);\n        return pow(umod() - 2);\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n};\nusing modint998 = static_modint<998244353>;\nusing modint197 = static_modint<1000000007>;\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    unsigned int umod() const { return _m; }\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\ntemplate <int id>\nstruct dynamic_modint {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        return pow(umod() - 2);\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id>\n  barrett dynamic_modint<id>::bt(998244353);\nusing modint = dynamic_modint<-1>;\n// ====== default source ends here ====== //\nint n, Q, a[300100], fa[20][300100], par[300100], dep[300100], up[300100];\nLL dp[300100], dp2[300100], dp3[300100];\n// subtree(i, i) | subtree(fa[i]) \\ subtree(i) | non-limit\nLL pre[300100], pre2[300100], pre3[300100];\n// pre dp2   |   pre points | pre edges\nvi<pii> adj[300100];\nint lca(int x, int y) {\n    if (dep[x] < dep[y]) swap(x, y);\n    for (int i=19; i>=0; --i) {\n        if (dep[fa[i][x]] >= dep[y]) {\n            x = fa[i][x];\n        }\n    }\n    if (x == y) return x;\n    for (int i=19; i>=0; --i) {\n        if (fa[i][x] != fa[i][y]) {\n            x = fa[i][x], y = fa[i][y];\n        }\n    }\n    return par[x];\n}\nint jump(int x, int d) {\n    assert(d >= 0);\n    for (int i=0; i<20; ++i) {\n        if (d&(1<<i)) x = fa[i][x];\n    }\n    return x;\n}\n#define cont(x) max(0LL, dp[x]-2*up[x])\nvoid dfs(int x, int pa) {\n    dep[x] = dep[fa[0][x] = par[x] = pa]+1;\n    for (int i=1; i<20; ++i) {\n        fa[i][x] = fa[i-1][fa[i-1][x]];\n    }\n    for (auto const& e : adj[x]) {\n        int y = e.first;\n        if (y != pa) {\n            up[y] = e.second;\n            dfs(y, x);\n            dp[x] += cont(y);\n        }\n    }\n    for (auto const& e : adj[x]) {\n        int y = e.first;\n        if (y != pa) {\n            dp2[y] = dp[x]-cont(y)-a[x];\n        }\n    }\n}\nvoid dfs2(int x) {\n    if (!par[x]) {\n        dp3[x] = dp[x];\n    }\n    else {\n        dp3[x] = max(0LL, dp3[par[x]]-cont(x)-2*up[x])+dp[x];\n    }\n    for (auto const& e : adj[x]) {\n        if (e.first != par[x]) {\n            dfs2(e.first);\n        }\n    }\n}\nvoid dfs3(int x) {\n    pre[x] = pre[par[x]]+dp2[x];\n    pre2[x] = pre2[par[x]]+a[x];\n    pre3[x] = pre3[par[x]]+up[x];\n    for (auto const& e : adj[x]) {\n        if (e.first != par[x]) {\n            dfs3(e.first);\n        }\n    }\n}\nvoid executer() {\n    cin >> n >> Q;\n    for (int i=1; i<=n; ++i) {\n        cin >> a[i];\n        dp[i] = dp2[i] = a[i];\n    }\n    for (int i=1,x,y,w; i<n; ++i) {\n        cin >> x >> y >> w;\n        adj[x].eb(y, w), adj[y].eb(x, w);\n    }\n    dfs(1, 0), dfs2(1);\n    getpre(1);\n    for (int x,y; Q--;) {\n        cin >> x >> y;\n        if (x == y) {\n            cout << dp3[x] << \"\\n\";\n        }\n        else {\n            int l = lca(x, y);\n            if (l == x || l == y) {\n                if (dep[x] >= dep[y]) {\n                    swap(x, y);\n                }\n                int dt = jump(y, dep[y]-dep[x]-1);\n                LL ans = dp3[x]-cont(dt)+pre2[y]-pre2[x]-2*(pre3[y]-pre3[dt])+dp[y]-a[y]+pre[y]-pre[x]-a[x];\n                cout << ans << \"\\n\";\n            }\n            else {\n            }\n        }\n    }\n}\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int tt = 1;\n    for (; tt--;) {\n        executer();\n    }\n}\n"
}