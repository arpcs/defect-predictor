{
    "id": 118900436,
    "contestId": 1000,
    "creationTimeSeconds": 1623253644,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1000,
        "index": "G",
        "name": "Two-Paths",
        "type": "PROGRAMMING",
        "rating": 2700,
        "tags": [
            "data structures",
            "dp",
            "trees"
        ]
    },
    "author": {
        "contestId": 1000,
        "members": [
            {
                "handle": "codebuster_10"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1530110100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 48,
    "timeConsumedMillis": 2495,
    "memoryConsumedBytes": 253030400,
    "source": "#include <bits/stdc++.h>\r\n\r\nusing namespace std ;\r\n\r\n#define int int64_t //be careful about this \r\n#define endl \"\\n\"\r\n#define f(i,a,b) for(int i=int(a);i<int(b);++i)\r\n\r\n#define pr pair\r\n#define ar array\r\n#define fr first\r\n#define sc second\r\n#define vt vector\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define LB lower_bound  \r\n#define UB upper_bound\r\n#define PQ priority_queue\r\n\r\n#define sz(x) ((int)(x).size())\r\n#define all(a) (a).begin(),(a).end()\r\n#define allr(a) (a).rbegin(),(a).rend()\r\n#define mem(a,b) memset(a, b, sizeof(a))\r\n\r\ntemplate<class A> void rd(vt<A>& v);\r\ntemplate<class T> void rd(T& x){ cin >> x; }\r\ntemplate<class H, class... T> void rd(H& h, T&... t) { rd(h) ; rd(t...) ;}\r\ntemplate<class A> void rd(vt<A>& x) { for(auto& a : x) rd(a) ;}\r\n\r\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\r\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\r\n\r\ntemplate<typename T>\r\nvoid __p(T a) {\r\n  cout<<a; \r\n}\r\ntemplate<typename T, typename F>\r\nvoid __p(pair<T, F> a) {\r\n  cout<<\"{\";\r\n  __p(a.first);\r\n  cout<<\",\";\r\n  __p(a.second);\r\n  cout<<\"}\\n\"; \r\n}\r\ntemplate<typename T>\r\nvoid __p(std::vector<T> a) {\r\n  cout<<\"{\";\r\n  for(auto it=a.begin(); it<a.end(); it++)\r\n    __p(*it),cout<<\",}\\n\"[it+1==a.end()]; \r\n}\r\ntemplate<typename T, typename ...Arg>\r\nvoid __p(T a1, Arg ...a) {\r\n  __p(a1);\r\n  __p(a...);\r\n}\r\ntemplate<typename Arg1>\r\nvoid __f(const char *name, Arg1 &&arg1) {\r\n  cout<<name<<\" : \";\r\n  __p(arg1);\r\n  cout<<endl;\r\n}\r\ntemplate<typename Arg1, typename ... Args>\r\nvoid __f(const char *names, Arg1 &&arg1, Args &&... args) {\r\n  int bracket=0,i=0;\r\n  for(;; i++)\r\n    if(names[i]==','&&bracket==0)\r\n      break;\r\n    else if(names[i]=='(')\r\n      bracket++;\r\n    else if(names[i]==')')\r\n      bracket--;\r\n  const char *comma=names+i;\r\n  cout.write(names,comma-names)<<\" : \";\r\n  __p(arg1);\r\n  cout<<\" | \";\r\n  __f(comma+1,args...);\r\n}\r\n\r\nvoid setIO(string s = \"\") {\r\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); \r\n  cin.exceptions(cin.failbit); \r\n\tcout.precision(15);\tcout << fixed;\r\n  if(sz(s)){\r\n  \tfreopen((s+\".in\").c_str(),\"r\",stdin);\r\n  \tfreopen((s+\".out\").c_str(),\"w\",stdout);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#undef int  \r\nvector< vector<int> > up;\r\n#define int int64_t\r\n\r\n\r\nstruct LCA1 {\r\n  int N, timer = 0, LOG ; \r\n  vector< vector<int> > dis;\r\n  \r\n#undef int  \r\n  vector< vector<array<int,2> > > adj ;\r\n  vector<int> tin, tout, depth ;\r\n#define int int64_t\r\n\r\n  void init(int _N) { \r\n    N = _N ; LOG = log2(N) + 2 ; \r\n    adj.resize(N);\r\n#undef int   \r\n    up.resize(N, vector<int> (LOG)) ;\r\n    tin = tout = depth = vector<int> (N) ; \r\n#define int int64_t\r\n    dis.resize(N, vector<int> (LOG)) ;\r\n  }\r\n \r\n  void ae(int x, int y,int w = 1) { // add edge\r\n    adj[x].push_back({y,w}), adj[y].push_back({x,w}); \r\n  }\r\n \r\n  void dfs(int v, int p, int w){\r\n    tin[v] = ++timer;\r\n    up[v][0] = p;\r\n    dis[v][0] = w ;\r\n    for(int i = 1; i < LOG; i++){\r\n      up[v][i] = up[up[v][i-1]][i-1] ;\r\n      dis[v][i] = dis[v][i-1] + dis[up[v][i-1]][i-1] ;\r\n    } \r\n    for(auto arr:adj[v]){\r\n    \tint u = arr[0], w = arr[1];\r\n    \tif(u != p){\r\n      \tdepth[u] = depth[v] + 1 ; dfs(u,v,w) ;\r\n      }\r\n    }\r\n    tout[v] = ++timer;\r\n  }\r\n \r\n  void gen(int R = 0) { \r\n    depth[R] = 0 ;\r\n    dfs(R,R,0); \r\n  }\r\n \r\n  bool is_ancestor(int u, int v){\r\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\r\n  }\r\n \r\n  int lca(int u, int v){\r\n    if( is_ancestor(u,v) )  return u;\r\n    if( is_ancestor(v,u) )  return v;\r\n    for(int i=LOG-1;i>=0;--i) {\r\n      if( !is_ancestor(up[u][i],v) ){\r\n        u = up[u][i] ;\r\n      } \r\n    }\r\n    return up[u][0];\r\n  }\r\n \r\n  int dist(int u, int v) {\r\n    return depth[u] + depth[v] - 2 * depth[lca(u,v)]; \r\n  }\r\n\t\r\n\tint weighted_dist(int u,int v){\r\n\t\tint temp = lca(u,v);\r\n\t\tint x1 = kth_ancestor_weighted_dist(u,depth[u] - depth[temp]);\r\n\t\tint x2 = kth_ancestor_weighted_dist(v,depth[v] - depth[temp]);\r\n\t\treturn x1 + x2 ;\r\n\t}\r\n\t\r\n  int kth_ancestor(int i,int k){\r\n    if(depth[i] < k) return int(-1) ;\r\n    for(int j = LOG - 1; j >= 0; --j){\r\n      if( (int(1) << j) <= k ){\r\n        k -= (int(1) << j) ; i = up[i][j] ; \r\n      }\r\n    }\r\n    return i ;\r\n  }\r\n  int kth_ancestor_weighted_dist(int i,int k){\r\n  \tif(depth[i] < k) return int(-1) ;\r\n  \tint ans = 0 ;\r\n    for(int j = LOG - 1; j >= 0; --j){\r\n      if( (int(1) << j) <= k ){\r\n        k -= (int(1) << j) ;\r\n        ans += dis[i][j] ;\r\n        i = up[i][j] ; \r\n      }\r\n    }\r\n    return ans ;\r\n  }\r\n  \r\n  \r\n  int d(int i){\r\n  \treturn depth[i];\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct LCA2 {\r\n  int N, timer = 0, LOG ;\r\n  vector< vector<int> >  dis;\r\n  vector< vector<array<int,2> > > adj ;\r\n \r\n  void init(int _N) { \r\n    N = _N ; LOG = log2(N) + 2 ; \r\n    adj.resize(N) ; \r\n    dis.resize(N, vector<int> (LOG)) ; \r\n  }\r\n \r\n  void ae(int x, int y,int w = 1) { // add edge\r\n    adj[x].push_back({y,w}), adj[y].push_back({x,w}); \r\n  }\r\n \r\n  void dfs(int v, int p, int w){\r\n    //up[v][0] = p;\r\n    dis[v][0] = w ;\r\n    for(int i = 1; i < LOG; i++){\r\n      //up[v][i] = up[up[v][i-1]][i-1] ;\r\n      dis[v][i] = dis[v][i-1] + dis[up[v][i-1]][i-1] ;\r\n    } \r\n    for(auto arr:adj[v]){\r\n    \tint u = arr[0], w = arr[1];\r\n    \tif(u != p){\r\n      \tdfs(u,v,w) ;\r\n      }\r\n    }\r\n  }\r\n \r\n  void gen(int R = 0) { \r\n    dfs(R,R,0); \r\n  }\r\n \r\n\r\n\t\r\n\r\n\t\r\n  int kth_ancestor_weighted_dist(int i,int k){\r\n  \tint ans = 0 ;\r\n    for(int j = LOG - 1; j >= 0; --j){\r\n      if( (int(1) << j) <= k ){\r\n        k -= (int(1) << j) ;\r\n        ans += dis[i][j] ;\r\n        i = up[i][j] ; \r\n      }\r\n    }\r\n    return ans ;\r\n  }\r\n  \r\n  \r\n};\r\n\r\n\r\n\r\nLCA1 tree1; // for profit b/w two nodes\r\nLCA2 tree2; // for max added value\r\n\r\n\r\nsigned main(){\r\n  setIO();\r\n  int n,q; rd(n,q);\r\n  tree1.init(n);\r\n  tree2.init(n);\r\n  \r\n#undef int  \r\n  vt<int> a(n);\r\n#define int int64_t\r\n\r\n  rd(a);\r\n\r\n#undef int  \r\n  vt<ar<int,2>> g[n];\r\n#define int int64_t \r\n  \r\n  f(_,0,n-1){\r\n  \tint u,v,w; rd(u,v,w); --u,--v;\r\n  \tg[u].pb({v,w});\r\n  \tg[v].pb({u,w});\r\n  }\r\n  \r\n#undef int  \r\n  vt<int> weight(n,0);\r\n#define int int64_t \r\n\r\n  function<void(int,int)> dfs = [&](int i,int p){\r\n  \tfor(auto [j,w] : g[i]) if(j != p){\r\n  \t\ttree1.ae(j,i,a[j]-w);\r\n  \t\tweight[j] = w;\r\n  \t\tdfs(j,i);\r\n  \t}\r\n  };\r\n  dfs(0,0);\r\n  tree1.gen();\r\n  \r\n  \r\n  \r\n  \r\n   \r\n  \r\n  vt<int> down(n,0);// down from particular node not including that node.\r\n  \r\n  function<void(int,int)> calc_down = [&](int i,int p){\r\n  \tfor(auto [j,w] : g[i]) if(j != p){\r\n  \t\tcalc_down(j,i);\r\n  \t\tdown[i] += max(int(0),down[j] + a[j] - 2 * w);\r\n  \t}\r\n  };\r\n  calc_down(0,0);\r\n  \r\n  \r\n  \r\n  vt<int> edge_down(n);// down from that edge's parent not including that edge\r\n  \r\n  function<void(int,int)> calc_edge_down = [&](int i,int p){\r\n  \tfor(auto [j,w] : g[i]) if(j != p){\r\n  \t\tcalc_edge_down(j,i);\r\n  \t\tedge_down[j] = down[i] - max(int(0),down[j] + a[j] - 2 * w);\r\n  \t\ttree2.ae(j,i,edge_down[j]);\r\n  \t}\r\n  };\r\n  calc_edge_down(0,0);\r\n  tree2.gen();\r\n  \r\n \r\n \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  vt<int> above(n,0);// what we get going above, with len atleast 1\r\n  \r\n  function<void(int,int)> calc_above = [&](int i,int p){\r\n  \t//assuming we have ans for i.\r\n  \tfor(auto [j,w] : g[i]) if(j != p){\r\n  \t\tckmax(above[j],above[i] + edge_down[j] + a[i] - 2 * w);\r\n  \t\tcalc_above(j,i);\r\n  \t}\r\n  };\r\n  calc_above(0,0);\r\n  \r\n  auto initial_profit = [&](int u,int v,int lca) -> int {\r\n  \treturn tree1.weighted_dist(u,v) + a[lca];\r\n  };\r\n  \r\n  \r\n  auto added_profit = [&](int u,int v, int lca) -> int {\r\n  \tint ans = 0;\r\n  \t\r\n  \tans += tree2.kth_ancestor_weighted_dist(u,tree1.d(u) - tree1.d(lca) - 1);\r\n  \tans += tree2.kth_ancestor_weighted_dist(v,tree1.d(v) - tree1.d(lca) - 1);\r\n  \t\r\n  \tint lca_u = tree1.kth_ancestor(u,tree1.d(u) - tree1.d(lca) - 1);\r\n  \tint lca_v = tree1.kth_ancestor(v,tree1.d(v) - tree1.d(lca) - 1);\r\n  \t\r\n  \tans += down[lca];\r\n  \tans -= max(int(0),down[lca_u] + a[lca_u] - 2 * weight[lca_u]);\r\n  \tans -= max(int(0),down[lca_v] + a[lca_v] - 2 * weight[lca_v]);\r\n  \t\r\n  \tans += above[lca];\r\n  \t\r\n  \tans += down[u];\r\n  \tans += down[v];\r\n  \t\r\n  \treturn  ans;\r\n  };\r\n  \r\n  while(q--){\r\n  \tint u,v; rd(u,v); --u,--v;\r\n  \tint lca = tree1.lca(u,v);\r\n  \t\r\n  \tif(u == v){\r\n  \t\tcout << down[u] + a[u] + above[u] << endl;\r\n  \t\tcontinue;\r\n  \t}else if(u == lca || v == lca){\r\n  \t\tif(v == lca) swap(u,v);\r\n  \t\t\r\n  \t\tint ans = initial_profit(u,v,u);\r\n  \t\t\r\n  \t\tans += tree2.kth_ancestor_weighted_dist(v,tree1.d(v) - tree1.d(u) - 1);\r\n  \t\r\n  \t\tans += down[u];\r\n  \t\t\r\n  \t\tint lca_v = tree1.kth_ancestor(v,tree1.d(v) - tree1.d(u) - 1);\r\n  \t\tans -= max(int(0),down[lca_v] + a[lca_v] - 2 * weight[lca_v]);\r\n  \t\r\n  \t\tans += above[u];\r\n  \t\r\n  \t\tans += down[v];\r\n  \t\t\r\n  \t\tcout << ans << endl;\r\n  \t}else{\r\n  \t\tcout << initial_profit(u,v,lca) + added_profit(u,v,lca) << endl;\r\n  \t}\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}