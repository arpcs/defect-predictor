{
    "id": 134902645,
    "contestId": 1406,
    "creationTimeSeconds": 1636557931,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1406,
        "index": "E",
        "name": "Deleting Numbers",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 2600,
        "tags": [
            "interactive",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1406,
        "members": [
            {
                "handle": "abhinash6g"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1599918300
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 3,
    "timeConsumedMillis": 156,
    "memoryConsumedBytes": 2764800,
    "source": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define fast ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)\r\n#define PI (2*acos(0.0))\r\n#define sz(x)           ( (ll) (x).size())\r\n#define setbits(x)      __builtin_popcountll(x)\r\n#define zrobits(x)      __builtin_ctzll(x)\r\n#define pos_rt_stbt(x)   (__builtin_ffsll(x))   // return position of rightmost set bit ( 1 indexing ) pos_rt_stbt(10) = 2 ( 1010 )\r\n#define ps(x,y)         fixed<<setprecision(y)<<x\r\n#define w(test)            int test; cin>>test; while(test--)\r\n#define nl \"\\n\"\r\n#define yes cout<<\"Yes\\n\"\r\n#define no cout<<\"No\\n\"\r\n#define all(v) (v).begin(),(v).end()\r\n#define clr(v) memset(v,0,sizeof(v));\r\n#define sqr(x) ((x) * (x))\r\ntypedef long long int  ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vll;\r\ntypedef vector<vll> vvll;\r\ntypedef vector<string> vs;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<pair<ll, ll>> vpll;\r\ntypedef vector<vpll>vvpll;\r\nconst long long int inf = 1e17;\r\nconst long long int mod = 1e9 + 7;\r\nconst long long int MOD =  998244353;\r\n//----------------------------------------------------------------------------------------------------------------------\r\n#define sim template < class c\r\n#define ris return * this\r\n#define dor > debug & operator <<\r\n#define eni(x) sim > typename enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\r\nsim > struct rge { c b, e; }; sim > rge<c> range(c i, c j) { return rge<c> {i, j}; }\r\nsim > auto dud(c* x) -> decltype(cerr << *x, 0); sim > char dud(...);\r\nstruct debug {\r\n#ifdef ABHI\r\n    eni( != ) cerr << boolalpha << i; ris;\r\n    }\r\n    eni( == ) ris << range(begin(i), end(i));\r\n    }\r\n    sim, class b dor(pair < b, c > d) {ris << \"(\" << d.first << \", \" << d.second << \")\";}\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wstring-plus-int\"\r\n    sim dor(rge<c> d) {*this << \"[\"; for (auto it = d.b; it != d.e; ++it) *this << \", \" + 2 * (it == d.b) << *it; ris << \"]\";}\r\n#pragma clang diagnostic pop\r\n#else\r\n    sim dor(const c&) { ris; }\r\n#endif\r\n};\r\nvector<char*> tokenizer(const char* args) {\r\n    char *token = new char[111]; strcpy(token, args); token = strtok(token, \", \");\r\n    vector<char*> v({token});\r\n    while ((token = strtok(NULL, \", \"))) v.push_back(token);\r\n    return reverse(v.begin(), v.end()), v;\r\n}\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wunused-parameter\"\r\nvoid debugg(vector<char*> args) { cerr << \"\\b\\b \"; }\r\n#pragma clang diagnostic pop\r\ntemplate <typename Head, typename... Tail>\r\nvoid debugg(vector<char*> args, Head H, Tail... T) {\r\n    debug() << \" [\" << args.back() << \": \" << H << \"] \";\r\n    args.pop_back(); debugg(args, T...);\r\n}\r\n#define harg(...) #__VA_ARGS__\r\n#ifdef ABHI\r\n#define deb(...) { debugg(tokenizer(harg(__VA_ARGS__, \\b\\t-->Line)), __VA_ARGS__, __LINE__); cerr << endl;}\r\n#else\r\n#define deb(...) { }\r\n#endif\r\n/// --------------------------------------------------------------------------------------------------------------------\r\n\r\n#define ptvs(v) for(auto &item :v) cout<<item<<\" \";cout<<\"\\n\";\r\n#define pt(x) cout<<((x))<<\"\\n\";\r\n#define pt2(x,y) cout<<(x)<<\" \"<<(y)<<\"\\n\";\r\n#define cinvll(v,start,end) vll v(end+1);for(auto i=start;i<=end;i++) {cin>>v[i];}\r\n//***********************************************************************************************\r\n// Fast Exponentiation power(a,b) ==> a to the power b\r\ntemplate <typename T>\r\nT  power(T  a, T  b) {\r\n    if (b == 0)\r\n        return 1;\r\n    if (b == 1)\r\n        return a;\r\n    else {\r\n        T  res = (power(a, b / 2));\r\n        if (b % 2)\r\n        {\r\n            return (res * 1LL * res * 1LL * a);\r\n        }\r\n        else\r\n        {\r\n            return res * 1LL *  res;\r\n        }\r\n    }\r\n}\r\n\r\n// Fast Modular Exponentiation  power(a,b,m) ==> (a to the power b) modulo m\r\ntemplate <typename T>\r\nlong long power(long long a, long long b, long long m) {\r\n    a %= m;\r\n    long long res = 1;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = res * a % m;\r\n        a = a * a % m;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\n// G C D\r\ntemplate <typename T>\r\nT  gcd(T  a, T  b) {\r\n    if (b == 0)\r\n    {return a;}\r\n    return gcd(b, a % b);\r\n}\r\n\r\ninline ll ceil(ll a, ll b) {    return a / b + (a % b == 0 ? 0 : 1);  }\r\n\r\nvoid factorial(vll &fact, ll n)\r\n{\r\n    fact.resize(n + 1, 1);\r\n    fact[0] = 1;\r\n    fact[1] = 1;\r\n    for (int i = 2; i <= n ; ++i)\r\n    {\r\n        fact[i] = ((fact[i - 1] % mod) * (i % mod)) % mod;\r\n    }\r\n}\r\n\r\nll mod_inv(ll a) {    return (power<ll>(a, mod - 2, mod)) % mod;    }\r\n\r\nll ncr(ll n, ll r, vll &fact)\r\n{\r\n    if (r > n or n < 0 or r < 0) return 0LL;\r\n    return  (((fact[n] % mod) * (mod_inv(fact[n - r]) % mod)) % mod * (mod_inv(fact[r]) % mod)) % mod;\r\n}\r\n\r\nll NCR(ll n, ll r, vll &fact, vll &inv)\r\n{\r\n    if (r > n or n < 0 or r < 0) return 0LL;\r\n    return  (((fact[n] % mod) * (inv[n - r]) )) % mod * (inv[r]) % mod;\r\n}\r\n\r\nvoid modI(vll &inv, ll n, vll &fact)\r\n{\r\n    inv.resize(n + 1, 1);\r\n    inv[n] = mod_inv(fact[n]);\r\n    for (int i = n - 1; i >= 0 ; --i)\r\n    {\r\n        inv[i] = ((inv[i + 1]) % mod * ((i + 1)  % mod)) % mod;\r\n    }\r\n}\r\n\r\ntemplate <int MOD_> struct modnum {\r\n    static constexpr int MOD = MOD_;\r\n    static_assert(MOD_ > 0, \"MOD must be positive\");\r\n\r\nprivate:\r\n    using ll = long long;\r\n\r\n    int v;\r\n    static int minv(int a, int m) {\r\n        a %= m;\r\n        assert(a);\r\n        return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\r\n    }\r\n\r\npublic:\r\n\r\n    modnum() : v(0) {}\r\n    modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\r\n    explicit operator int() const { return v; }\r\n    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\r\n    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\r\n\r\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\r\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\r\n\r\n    modnum pow(modnum a, long long b) {\r\n        assert(b >= 0);\r\n        modnum r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\r\n    }\r\n    modnum inv() const {\r\n        modnum res;\r\n        res.v = minv(v, MOD);\r\n        return res;\r\n    }\r\n    friend modnum inv(const modnum& m) { return m.inv(); }\r\n    modnum neg() const {\r\n        modnum res;\r\n        res.v = v ? MOD - v : 0;\r\n        return res;\r\n    }\r\n    friend modnum neg(const modnum& m) { return m.neg(); }\r\n\r\n    modnum operator- () const {\r\n        return neg();\r\n    }\r\n    modnum operator+ () const {\r\n        return modnum(*this);\r\n    }\r\n\r\n    modnum& operator ++ () {\r\n        v ++;\r\n        if (v == MOD) v = 0;\r\n        return *this;\r\n    }\r\n    modnum& operator -- () {\r\n        if (v == 0) v = MOD;\r\n        v --;\r\n        return *this;\r\n    }\r\n    modnum& operator += (const modnum& o) {\r\n        v -= MOD - o.v;\r\n        v = (v < 0) ? v + MOD : v;\r\n        return *this;\r\n    }\r\n    modnum& operator -= (const modnum& o) {\r\n        v -= o.v;\r\n        v = (v < 0) ? v + MOD : v;\r\n        return *this;\r\n    }\r\n    modnum& operator *= (const modnum& o) {\r\n        v = int(ll(v) * ll(o.v) % MOD);\r\n        return *this;\r\n    }\r\n    modnum& operator /= (const modnum& o) {\r\n        return *this *= o.inv();\r\n    }\r\n\r\n    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\r\n    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\r\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\r\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\r\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\r\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\r\n};\r\nusing mint = modnum<mod>;\r\n\r\n\r\nconst int N=1e5;\r\n\r\nll a(ll x)\r\n{\r\n    cout<<\"A \"<<x<<endl;\r\n    ll d;\r\n    cin>>d;\r\n    return d;\r\n}\r\nll b(ll x)\r\n{\r\n    cout<<\"B \"<<x<<endl;\r\n    ll d;\r\n    cin>>d;\r\n    return d;\r\n}\r\n\r\nint main()\r\n{\r\n    fast;\r\n    ll n;\r\n    cin>>n;\r\n    ll m=0;\r\n    vpll pr;\r\n    vll vis(n+1);\r\n    for (ll i = 2; i <=n; ++i)\r\n    {\r\n        if(vis[i])continue;\r\n        ll cnt=0;\r\n        for (ll j = i; j <=n ;j+=i)\r\n        {\r\n            if(vis[j])continue;\r\n            cnt++;\r\n            vis[j]=1;\r\n        }\r\n        if(i<=n)m++;\r\n        pr.push_back({i,cnt});\r\n    }\r\n    deb(pr);\r\n\r\n    m=sqrt(m)+1;\r\n    deb(m);\r\n    vll f;\r\n    ll lp=-1;\r\n    ll total=n;\r\n    for (int i = 0; i <sz(pr) ;i+=m)\r\n    {\r\n        int br=0;\r\n        for (int j = i; j <i+m and j<sz(pr) ; ++j)\r\n        {\r\n            if(pr[j].first>n)\r\n            {\r\n                br=1;\r\n                break;\r\n            }\r\n            ll d=b(pr[j].first);\r\n            if(d+1==pr[j].second)\r\n            {\r\n                deb(pr[j],d);\r\n                f.push_back(pr[j].first);\r\n            }\r\n            total-=pr[j].second;\r\n\r\n        }\r\n        if(br)break;\r\n        if(lp==-1)\r\n        {\r\n            ll cnt=a(1);\r\n            deb(total,cnt);\r\n            if(cnt!=total)lp=i;\r\n        }\r\n        deb(i,lp);\r\n    }\r\n    deb(lp);\r\n    for (int i = lp; i <lp+m and i<sz(pr) and lp!=-1 ; ++i)\r\n    {\r\n\r\n        ll d=b(pr[i].first);\r\n        if(d)\r\n        {\r\n            f.push_back(pr[i].first);\r\n            break;\r\n        }\r\n    }\r\n    deb(f);\r\n    ll r=1;\r\n    for(auto &i:f)r=r*1L*i;\r\n    assert(r<=n);\r\n    ll x=1;\r\n    for(auto &i:f)\r\n    {\r\n        ll num=i;\r\n        ll largest=num;\r\n        while(num<=n)\r\n        {\r\n            ll d=a(num);\r\n            if(!d)break;\r\n            largest=num;\r\n            num=num*1LL*num;\r\n        }\r\n        x=x*1LL*largest;\r\n    }\r\n    cout<<\"C \"<<x<<endl;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n//   1   5  7    11  13    17  19\r\n\r\n\r\n\r\n"
}