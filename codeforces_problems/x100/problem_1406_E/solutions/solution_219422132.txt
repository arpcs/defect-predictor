{
    "id": 219422132,
    "contestId": 1406,
    "creationTimeSeconds": 1692349222,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1406,
        "index": "E",
        "name": "Deleting Numbers",
        "type": "PROGRAMMING",
        "points": 2750.0,
        "rating": 2600,
        "tags": [
            "interactive",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1406,
        "members": [
            {
                "handle": "cmk666"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1599918300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 102,
    "timeConsumedMillis": 108,
    "memoryConsumedBytes": 921600,
    "source": "/*\r\n * @Author:             cmk666\r\n * @Created time:       2023-08-18 16:05:19\r\n * @Last Modified time: 2023-08-18 16:59:46\r\n */\r\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\r\n#include<bits/stdc++.h>\r\n#ifdef LOCAL\r\n#include\"debug.h\"\r\n#else\r\n#define D(...) ((void)0)\r\n#endif\r\nusing namespace std; using ll = long long;\r\n#define For(i, j, k) for ( int i = (j) ; i <= (k) ; i++ )\r\n#define Fol(i, j, k) for ( int i = (j) ; i >= (k) ; i-- )\r\nnamespace FastIO\r\n{\r\n// ------------------------------\r\n// #define IN_HAS_NEG\r\n// #define OUT_HAS_NEG\r\n// #define CHK_EOF\r\n// #define DISABLE_MMAP\r\n// ------------------------------\r\n#if __cplusplus < 201400\r\n#error Please use C++14 or higher.\r\n#endif\r\n#if __cplusplus > 201700\r\n#define INLINE_V inline\r\n#else\r\n#define INLINE_V\r\n#endif\r\n#if ( defined(LOCAL) || defined(_WIN32) ) && !defined(DISABLE_MMAP)\r\n#define DISABLE_MMAP\r\n#endif\r\n#ifndef DISABLE_MMAP\r\n#include<sys/mman.h>\r\n#endif\r\n#ifdef LOCAL\r\n\tinline char gc() { return getchar(); }\r\n\tinline void pc(char c) { putchar(c); }\r\n#else\r\n#ifdef DISABLE_MMAP\r\n\tINLINE_V constexpr int _READ_SIZE = 1 << 18;\r\n\tINLINE_V static char _read_buffer[_READ_SIZE], *_read_ptr = nullptr, *_read_ptr_end = nullptr;\r\n\tinline char gc()\r\n\t{\r\n\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) )\r\n\t\t{\r\n\t\t\t_read_ptr = _read_buffer;\r\n\t\t\t_read_ptr_end = _read_buffer + fread(_read_buffer, 1, _READ_SIZE, stdin);\r\n#ifdef CHK_EOF\r\n\t\t\tif ( __builtin_expect(_read_ptr == _read_ptr_end, false) ) return EOF;\r\n#endif\r\n\t\t}\r\n\t\treturn *_read_ptr++;\r\n\t}\r\n#else\r\n\tINLINE_V static const char *_read_ptr = (const char *)mmap(nullptr, INT_MAX, 1, 2, 0, 0);\r\n\tinline char gc() { return *_read_ptr++; }\r\n#endif\r\n\tINLINE_V constexpr int _WRITE_SIZE = 1 << 18;\r\n\tINLINE_V static char _write_buffer[_WRITE_SIZE], *_write_ptr = _write_buffer;\r\n\tinline void pc(char c)\r\n\t{\r\n\t\t*_write_ptr++ = c;\r\n\t\tif ( __builtin_expect(_write_buffer + _WRITE_SIZE == _write_ptr, false) )\r\n\t\t{\r\n\t\t\tfwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout);\r\n\t\t\t_write_ptr = _write_buffer;\r\n\t\t}\r\n\t}\r\n\tINLINE_V struct _auto_flush\r\n\t{\r\n\t\tinline ~_auto_flush() { fwrite(_write_buffer, 1, _write_ptr - _write_buffer, stdout); }\r\n\t}\t_auto_flush;\r\n#endif\r\n#ifdef CHK_EOF\r\n\tinline constexpr bool _isdigit(char c) { return ( c & 16 ) && c != EOF; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32 && c != EOF; }\r\n#else\r\n\tinline constexpr bool _isdigit(char c) { return c & 16; }\r\n\tinline constexpr bool _isgraph(char c) { return c > 32; }\r\n#endif\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_integer = numeric_limits < T >::is_integer;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_signed = numeric_limits < T >::is_signed;\r\n\ttemplate < class T >\r\n\tINLINE_V constexpr bool _is_unsigned = _is_integer < T > && !_is_signed < T >;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_integer < __uint128_t > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_signed < __int128 > = true;\r\n\ttemplate <> INLINE_V constexpr bool _is_unsigned < __uint128_t > = true;\r\n#undef INLINE_V\r\n\tinline void read(char &c) { do c = gc(); while ( !_isgraph(c) ); }\r\n\tinline void read_cstr(char *s)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) *s++ = c, c = gc();\r\n\t\t*s = 0;\r\n\t}\r\n\tinline void read(string &s)\r\n\t{\r\n\t\tchar c = gc(); s.clear(); while ( !_isgraph(c) ) c = gc();\r\n\t\twhile ( _isgraph(c) ) s.push_back(c), c = gc();\r\n\t}\r\n#ifdef IN_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); bool f = true; x = 0;\r\n\t\twhile ( !_isdigit(c) ) { if ( c == 45 ) f = false; c = gc(); }\r\n\t\tif ( f ) while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t\telse     while ( _isdigit(c) ) x = x * 10 - ( c & 15 ), c = gc();\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void read(T &x)\r\n\t{\r\n\t\tchar c = gc(); while ( !_isdigit(c) ) c = gc();\r\n\t\tx = 0; while ( _isdigit(c) ) x = x * 10 + ( c & 15 ), c = gc();\r\n\t}\r\n\tinline void write(char c) { pc(c); }\r\n\tinline void write_cstr(const char *s) { while ( *s ) pc(*s++); }\r\n\tinline void write(const string &s) { for ( char c : s ) pc(c); }\r\n#ifdef OUT_HAS_NEG\r\n\ttemplate < class T, enable_if_t < _is_signed < T >, int > = 0 >\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tif ( x >= 0 )  do buffer[digits++] =  ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\telse { pc(45); do buffer[digits++] = -( x % 10 ) | 48, x /= 10; while ( x ); }\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < class T, enable_if_t < _is_unsigned < T >, int > = 0 >\r\n#else\r\n\ttemplate < class T, enable_if_t < _is_integer < T >, int > = 0 >\r\n#endif\r\n\tinline void write(T x)\r\n\t{\r\n\t\tchar buffer[numeric_limits < T >::digits10 + 1]; int digits = 0;\r\n\t\tdo buffer[digits++] = ( x % 10 ) | 48, x /= 10; while ( x );\r\n\t\twhile ( digits ) pc(buffer[--digits]);\r\n\t}\r\n\ttemplate < int N > struct _tuple_io_helper\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_read(x), read(get < N - 1 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x)\r\n\t\t{ _tuple_io_helper < N - 1 >::_write(x), pc(32), write(get < N - 1 > (x)); }\r\n\t};\r\n\ttemplate <> struct _tuple_io_helper < 1 >\r\n\t{\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _read(tuple < T... > &x) { read(get < 0 > (x)); }\r\n\t\ttemplate < class ...T >\r\n\t\tstatic inline void _write(const tuple < T... > &x) { write(get < 0 > (x)); }\r\n\t};\r\n\ttemplate < class ...T >\r\n\tinline void read(tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_read(x); }\r\n\ttemplate < class ...T >\r\n\tinline void write(const tuple < T... > &x) { _tuple_io_helper < sizeof...(T) >::_write(x); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void read(pair < T1, T2 > &x) { read(x.first), read(x.second); }\r\n\ttemplate < class T1, class T2 >\r\n\tinline void write(const pair < T1, T2 > &x) { write(x.first), pc(32), write(x.second); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void read(T1 &x, T2 &...y) { read(x), read(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void read_cstr(char *x, T *...y) { read_cstr(x), read_cstr(y...); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void write(const T1 &x, const T2 &...y) { write(x), write(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void write_cstr(const char *x, const T *...y) { write_cstr(x), write_cstr(y...); }\r\n\ttemplate < class T >\r\n\tinline void print(const T &x) { write(x); }\r\n\tinline void print_cstr(const char *x) { write_cstr(x); }\r\n\ttemplate < class T1, class ...T2 >\r\n\tinline void print(const T1 &x, const T2 &...y) { print(x), pc(32), print(y...); }\r\n\ttemplate < class ...T >\r\n\tinline void print_cstr(const char *x, const T *...y) { print_cstr(x), print_cstr(y...); }\r\n\tinline void println() { pc(10); }\r\n\tinline void println_cstr() { pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println(const T &...x) { print(x...), pc(10); }\r\n\ttemplate < class ...T >\r\n\tinline void println_cstr(const T *...x) { print_cstr(x...), pc(10); }\r\n}\r\nusing namespace FastIO;\r\nbool pr[100009]; int p[100009], pl;\r\ninline void sieve(int n)\r\n{\r\n\tFor(i, 2, n)\r\n\t{\r\n\t\tif ( !pr[i] ) p[++pl] = i;\r\n\t\tFor(j, 1, pl)\r\n\t\t{\r\n\t\t\tif ( i * p[j] > n ) break;\r\n\t\t\tpr[i * p[j]] = true;\r\n\t\t\tif ( !( i % p[j] ) ) break;\r\n\t\t}\r\n\t}\r\n}\r\nint n, b, nw, res = 1, sz;\r\nvector < int > small, big, qry;\r\ninline int qrya(int x) { int z; cout << \"A \" << x << endl, cin >> z; return z; }\r\ninline int qryb(int x) { int z; cout << \"B \" << x << endl, cin >> z; return z; }\r\ninline void ans(int x) { cout << \"C \" << x << endl, exit(0); }\r\nint main()\r\n{\r\n\tcin >> n, sieve(n);\r\n\tFor(i, 1, pl) ( p[i] <= sqrtl(n) ? small : big ).push_back(p[i]);\r\n\tfor ( int i : small )\r\n\t{\r\n\t\tqryb(i), nw = 1;\r\n\t\twhile ( (ll)res * nw * i <= n && qrya(nw * i) ) nw *= i;\r\n\t\tres *= nw;\r\n\t}\r\n\tif ( res > 1 )\r\n\t{\r\n\t\tfor ( int j : big ) if ( (ll)res * j <= n && qrya(res * j) ) ans(res * j);\r\n\t\tans(res);\r\n\t}\r\n\tb = sqrtl(sz = (int)big.size());\r\n\tfor ( int i : big )\r\n\t{\r\n\t\tqryb(i), qry.push_back(i);\r\n\t\tif ( (int)qry.size() == b || i == big.back() )\r\n\t\t{\r\n\t\t\tnw = qrya(1);\r\n\t\t\tif ( sz - nw != (int)qry.size() ) for ( int j : qry ) if ( qrya(j) ) ans(j);\r\n\t\t\tqry.clear(), sz = nw;\r\n\t\t}\r\n\t}\r\n\treturn ans(1), 0;\r\n}\r\n// \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f \u60f3\u4e0aIM\u634f\r\n// \u4f0a\u5a1c\u53ef\u7231\u634f \u4f0a\u5a1c\u8d34\u8d34\u634f"
}