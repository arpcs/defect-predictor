{
    "id": 125877359,
    "contestId": 27,
    "creationTimeSeconds": 1628968791,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 27,
        "index": "B",
        "name": "Tournament",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1300,
        "tags": [
            "bitmasks",
            "brute force",
            "dfs and similar",
            "greedy"
        ]
    },
    "author": {
        "contestId": 27,
        "members": [
            {
                "handle": "abhishek_kira"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1284130800
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 35,
    "timeConsumedMillis": 60,
    "memoryConsumedBytes": 8704000,
    "source": "#include <bits/stdc++.h>\r\n#include <chrono>\r\nusing namespace std;\r\n#define ll long long\r\n#define ull unsigned ll\r\n#define pb push_back\r\n#define mod 1000000007\r\n#define ss second\r\n#define ff first\r\n#define accurate fixed<<setprecision(100)\r\n\r\n// ---------------------------------DEBUG----------------------------------//\r\nvoid __print(int x) {cerr << x;}\r\nvoid __print(long x) {cerr << x;}\r\nvoid __print(long long x) {cerr << x;}\r\nvoid __print(unsigned x) {cerr << x;}\r\nvoid __print(unsigned long x) {cerr << x;}\r\nvoid __print(unsigned long long x) {cerr << x;}\r\nvoid __print(float x) {cerr << x;}\r\nvoid __print(double x) {cerr << x;}\r\nvoid __print(long double x) {cerr << x;}\r\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\r\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\r\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\r\n\r\ntemplate<typename T, typename V>\r\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\r\ntemplate<typename T>\r\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\r\nvoid _print() {cerr << \"]\\n\";}\r\ntemplate <typename T, typename... V>\r\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\r\n#ifndef ONLINE_JUDGE\r\n\r\n#define dbg(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\r\n#else\r\n#define dbg(x...)\r\n#endif\r\n#define time__(d) \\\r\nfor ( \\\r\n    auto blockTime = make_pair(chrono::high_resolution_clock::now(), true); \\\r\n    blockTime.second; \\\r\n    dbg(\"%s: %d ms\\n\", d, (int)chrono::duration_cast<chrono::milliseconds>(chrono::high_resolution_clock::now() - blockTime.first).count()), blockTime.second = false \\\r\n    )\r\n// ---------------------------------DEBUG----------------------------------//\r\nconst int N = 2e5 + 1;\r\n// using u64 = uint64_t;\r\n// using u128 = __uint128_t;\r\nll fact[N], inv[N], invfact[N];\r\nvector<ll>primes;\r\n\r\n\r\n\r\nll mul(long long a,long long b,long long c=mod){\r\n    long long x = 0,y=a%c;\r\n    while(b > 0){\r\n        if(b%2 == 1){\r\n            x = (x+y)%c;\r\n        }\r\n        y = (y*2)%c;\r\n        b /= 2;\r\n    }\r\n    return x%c;\r\n}\r\n\r\nll power(ll x, ll n, const ll MOD=mod)\r\n{\r\n    ll res = 1;\r\n    for (; n > 0; n >>= 1)\r\n    {\r\n        if (n & 1) res = mul(res, x, MOD);\r\n        x = mul(x, x, MOD);\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid sieve(ll maxN)\r\n{\r\n\tvector<ll>ar(maxN + 1 , 0);\r\n\tar[1] = 1;\r\n\tfor(ll i=2;i<=maxN;i++)\r\n\tif(ar[i] == 0)\r\n\t{\r\n\tfor(ll j=2*i;j<=maxN;j+=i)\r\n\tar[j] = 1;\r\n\t}\r\n\r\n\tfor(ll i=1;i<=maxN;i++)\r\n\tif(ar[i] == 0)\r\n\tprimes.pb(i);\r\n}\r\n\r\null binpower(ull base, ull e, ull Mod=mod) {\r\n    ull result = 1;\r\n    base %= Mod;\r\n    while (e) {\r\n        if (e & 1)\r\n            result = (ull)result * base % Mod;\r\n        base = (ull)base * base % Mod;\r\n        e >>= 1LL;\r\n    }\r\n    return result;\r\n}\r\n\r\nbool check_composite(ull n, ull a, ull d, int s) {\r\n    ull x = binpower(a, d, n);\r\n    if (x == 1 || x == n - 1)\r\n        return false;\r\n    for (int r = 1; r < s; r++) {\r\n        x = (ull)x * x % n;\r\n        if (x == n - 1)\r\n            return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nbool miller(ull n) { // returns true if n is prime, else returns false.\r\n    if (n < 2)\r\n        return false;\r\n\r\n    int r = 0;\r\n    ull d = n - 1;\r\n    while ((d & 1) == 0) {\r\n        d >>= 1;\r\n        r++;\r\n    }\r\n\r\n    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\r\n        if (n == a)\r\n            return true;\r\n        if (check_composite(n, a, d, r))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nll div(ll n)\r\n{\r\n\tll ans=1;\r\n\tfor(int i=0;i<primes.size();i++)\r\n\t{\r\n\t\tif(primes[i]*primes[i]*primes[i]>n)break;\r\n\t\tll cnt=1;\r\n\t\twhile(n%primes[i]==0)\r\n\t\t{\r\n\t\t\tn/=primes[i];\r\n\t\t\tcnt++;\r\n\t\t}\r\n\t\tans=ans*cnt;\r\n\t}\r\n\tll x=round(sqrt(n));\r\n\r\n\tif(miller(n))ans*=2;\r\n\telse if(x*x==n)\r\n\t{\r\n\t\tif(miller(x))ans*=3;\r\n\t}\r\n\telse ans*=4;\r\n\treturn ans;\r\n}\r\n\r\nint log_(int a, int b)\r\n{\r\nreturn (a > b - 1)? 1 + log_(a / b, b): 0;\r\n}\r\n\r\n\r\nll add(ll a,ll b,ll Mod=mod) {\r\n\tif ((a += b) >= Mod)\r\n\t\ta -=Mod;\r\n\telse if (a < 0)\r\n\t\ta +=Mod;\r\n\treturn a;\r\n}\r\n\r\nll nCr(int n, int r) {\r\n\tif (r > n)\r\n\t\treturn 0;\r\n\treturn mul(mul(fact[n], invfact[r]), invfact[n - r]);\r\n}\r\n\r\nll gcd(ll a,ll b) { return !b ? a : gcd(b, a % b); }\r\n\r\n\r\nvoid factInverse() {\r\n\tfact[0] = inv[1] = fact[1] = invfact[0] = invfact[1] = 1;\r\n\tfor (long long i = 2; i < N; i++) {\r\n\t\tfact[i] = (fact[i - 1] * i) % mod;\r\n\t\tinv[i] = mod - (inv[mod % i] * (mod / i) % mod);\r\n\t\tinvfact[i] = (inv[i] * invfact[i - 1]) % mod;\r\n\t}\r\n}\r\n\r\nll get(int n)\r\n{\r\n\tint res = 0;\r\n\tfor (int i=n; i>=1; i--)\r\n\t{\r\n\t\t// If i is a power of 2\r\n\t\tif ((i & (i-1)) == 0)\r\n\t\t{\r\n\t\t\tres = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n}\r\nint set1(int n)\r\n{\r\n\t// Position variable initialize with 1\r\n\t// m variable is used to check the set bit\r\n\tint position = 0;\r\n\tint m = 1;\r\n\r\n\twhile (!(n & m)) {\r\n\r\n\t\t// left shift\r\n\t\tm = m << 1;\r\n\t\tposition++;\r\n\t}\r\n\treturn position;\r\n}\r\n\r\nvoid solve(int K)\r\n{\r\n\t// memset(dp,0,sizeof(dp));\r\n\tll n,m,q,z,k;\r\n    // double n,y;\r\n    ll ans=0,cnt=0;\r\n    // ll a,b,c;\r\n    ll x,y;\r\n    ll l{-1},r{-1};\r\n    string s;\r\n    string t;\r\n\tcin>>n;\r\n\tk=(n*(n-1))/2;\r\n\t// vector<ll>a(n);\r\n\tset<pair<ll,ll>>a;\r\n\tdbg(k);\r\n\tmap<ll,ll>mp;\r\n\tfor(int i=0;i<k-1;i++)\r\n\t{\r\n\t\tcin>>x>>y;\r\n\t\tmp[x]++;\r\n\t\tmp[y]++;\r\n\t\ta.insert({x,y});\r\n\t}\r\n\tdbg(a);\r\n\tl=-1;\r\n\tfor(auto x:mp)\r\n\t{\r\n\t\tif(x.ss!=n-1)\r\n\t\t{\r\n\t\t\tif(l==-1)l=x.ff;\r\n\t\t\telse r=x.ff;\r\n\t\t}\r\n\t}\r\n\tdbg(l,r);\r\n\t//l>r\r\n\tfor(auto x:a)\r\n\t{\r\n\t\tif(x.ss==r)\r\n\t\t{\r\n\t\t\tfor(auto y:a)\r\n\t\t\t{\r\n\t\t\t\tif(y.ff==l && y.ss==x.ff)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout<<l<<\" \"<<r;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//r>l\r\n\tfor(auto x:a)\r\n\t{\r\n\t\tif(x.ss==l)\r\n\t\t{\r\n\t\t\tfor(auto y:a)\r\n\t\t\t{\r\n\t\t\t\tif(y.ff==r && y.ss==x.ff)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout<<r<<\" \"<<l;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout<<l<<\" \"<<r;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\r\n\r\n\r\n\r\n\r\n\r\n\t\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\r\n\r\n\r\n\r\n\r\n\r\n\r\nreturn;\r\n}\r\n\r\nint main()\r\n{\r\n\t// sieve(1000009);\r\n\t// factInverse();\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\t\r\n\t#ifndef ONLINE_JUDGE \r\n\tfreopen(\"input.txt\", \"r\", stdin);\r\n\tfreopen(\"debug.txt\", \"w\", stderr);\r\n\t#endif\r\n\t\r\n\tll t,k;\r\n\tk=1;\r\n\tt=1;\r\n\t// cin>>t;\r\n\twhile(t--)\r\n\t{\r\n\t// cout<<\"Case \"<<k<<\":\"<<\" \";\r\n\tsolve(k);\r\n\tk++;\r\n\t}\r\n\tcerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\r\n\tcout<<flush;\r\n\r\n\treturn 0;\r\n}"
}