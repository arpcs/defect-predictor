{
    "id": 197536640,
    "contestId": 27,
    "creationTimeSeconds": 1678895987,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 27,
        "index": "B",
        "name": "Tournament",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 1300,
        "tags": [
            "bitmasks",
            "brute force",
            "dfs and similar",
            "greedy"
        ]
    },
    "author": {
        "contestId": 27,
        "members": [
            {
                "handle": "ashdeepsingh1997"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1284130800
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 35,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 0,
    "source": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.UnknownHostException;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\nimport java.util.Set;\r\nimport java.util.Stack;\r\nimport java.util.StringTokenizer;\r\n\r\npublic class Demo\r\n{\r\n\tstatic class FastReader {\r\n        BufferedReader br;\r\n        StringTokenizer st;\r\n\r\n        public FastReader()\r\n        {\r\n            br = new BufferedReader(\r\n                new InputStreamReader(System.in));\r\n        }\r\n\r\n        String next()\r\n        {\r\n            while (st == null || !st.hasMoreElements()) {\r\n                try {\r\n                    st = new StringTokenizer(br.readLine());\r\n                }\r\n                catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() { return Integer.parseInt(next()); }\r\n \r\n        long nextLong() { return Long.parseLong(next()); }\r\n\r\n        double nextDouble()\r\n        {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        String nextLine()\r\n        {\r\n            String str = \"\";\r\n            try {\r\n                str = br.readLine();\r\n            }\r\n            catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n    }\r\n\t\r\n\tpublic static boolean isPalindrome(String str)\r\n\t{\r\n\t\tint i = 0, j = str.length() - 1;\r\n\t\t \r\n        while (i < j)\r\n        {\r\n            if (str.charAt(i) != str.charAt(j))\r\n                return false;\r\n            i++;\r\n            j--;\r\n        }\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic static long modularExpo(long a, long b, long mod)\r\n\t{\r\n\t\ta = a%mod;\r\n\t\tlong res = 1;\r\n\t\t\r\n\t\twhile(b > 0)\r\n\t\t{\r\n\t\t\tif((b&1) != 0)\r\n\t\t\t{\r\n\t\t\t\tres = (res*a)%mod;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = (a*a)%mod;\r\n\t\t\tb = b>>1;\r\n\t\t}\r\n\t\t\r\n\t\treturn res;\r\n\t}\r\n\t\r\n\tpublic static long fastExpo(long a, long b)\r\n\t{\r\n\t\tlong res = 1;\r\n\t\t\r\n\t\twhile(b > 0)\r\n\t\t{\r\n\t\t\tif( (b&1) != 0 )\r\n\t\t\t{\r\n\t\t\t\tres = res * a;\r\n\t\t\t}\r\n\t\t\ta = a*a;\r\n\t\t\tb = b>>1;\r\n\t\t}\r\n\t\t\r\n\t\treturn res;\r\n\t}\r\n\t\r\n\tpublic static long gcd (long a, long b) {\r\n\t    if (b == 0)\r\n\t        return a;\r\n\t    else\r\n\t        return gcd (b, a % b);\r\n\t}\r\n\t\r\n\tpublic static long lcm (long a, long b) {\r\n\t    return a / gcd(a, b) * b;\r\n\t}\r\n\t\r\n\tpublic static double gcd (double a, double b) {\r\n\t    if (b == 0)\r\n\t        return a;\r\n\t    else\r\n\t        return gcd (b, a % b);\r\n\t}\r\n\t\r\n\tpublic static double lcm (double a, double b) {\r\n\t    return a / gcd(a, b) * b;\r\n\t}\r\n\t\r\n\tstatic boolean isPrime(long n, long k)\r\n    {\r\n    if (n <= 1 || n == 4) return false;\r\n    if (n <= 3) return true;\r\n     \r\n    while (k > 0)\r\n    {\r\n    \tlong a = 2 + (int)(Math.random() % (n - 4));\r\n     \r\n        // Fermat's little theorem\r\n        if (modularExpo(a, n - 1, n) != 1)\r\n            return false;\r\n     \r\n        k--;\r\n    }\r\n     \r\n        return true;\r\n    }\r\n\t\r\n    public static void findnthroot(double x, int n)\r\n    {\r\n    \tdouble low, high;\r\n    \t\r\n    \tif(x >= 0 && x <= 1)\r\n    \t{\r\n    \t\tlow = x;\r\n    \t\thigh = 1;\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tlow = 1; \r\n    \t\thigh = x;\r\n    \t}\r\n    \t\r\n    \tdouble epsilon = 0.00000001;\r\n    \t\r\n    \tdouble guess = (low+high)/2;\r\n    \t\r\n    \twhile(Math.abs(Math.pow(guess, n) - x) >= epsilon )\r\n    \t{\r\n    \t\tif(Math.pow(guess, n) > x)\r\n    \t\t{\r\n    \t\t\thigh = guess;\r\n    \t\t}\r\n    \t\telse\r\n    \t\t{\r\n    \t\t\tlow = guess;\r\n    \t\t}\r\n    \t\tguess = (low + high)/2;\r\n    \t}\r\n    \t\r\n    \tSystem.out.println(String.format(\"%.4f\", guess));\r\n    }\r\n    \r\n    // Function to implement lower_bound\r\n    static int lower_bound(int arr[], int X)\r\n    {\r\n    \tint mid;\r\n    \tint N = arr.length;\r\n    \tint low = 0;\r\n    \tint high = N;\r\n\r\n    \twhile (low < high) {\r\n    \t\tmid = low + (high - low) / 2;\r\n\r\n    \t\tif (X <= arr[mid]) {\r\n    \t\t\thigh = mid;\r\n    \t\t}\r\n\r\n    \t\telse {\r\n    \t\t\tlow = mid + 1;\r\n    \t\t}\r\n    \t}\r\n\r\n    \tif(low < N && arr[low] < X) {\r\n    \tlow++;\r\n    \t}\r\n    \t\r\n    \treturn low;\r\n    }\r\n    \r\n    static long lower_bound(long arr[], long X)\r\n    {\r\n    \tlong mid;\r\n    \tlong N = arr.length;\r\n    \tlong low = 0;\r\n    \tlong high = N;\r\n\r\n    \twhile (low < high) {\r\n    \t\tmid = low + (high - low) / 2;\r\n\r\n    \t\tif (X <= arr[(int) mid]) {\r\n    \t\t\thigh = mid;\r\n    \t\t}\r\n\r\n    \t\telse {\r\n    \t\t\tlow = mid + 1;\r\n    \t\t}\r\n    \t}\r\n\r\n    \tif(low < N && arr[(int) low] < X) {\r\n    \tlow++;\r\n    \t}\r\n    \t\r\n    \treturn low;\r\n    }\r\n    \r\n    // Function to implement upper_bound\r\n    static int upper_bound(int arr[], int X)\r\n    {\r\n    \tint mid;\r\n    \tint N = arr.length;\r\n    \tint low = 0;\r\n    \tint high = N;\r\n\r\n    \twhile (low < high) {\r\n    \t\tmid = low + (high - low) / 2;\r\n\r\n    \t\tif (X >= arr[mid]) {\r\n    \t\t\tlow = mid + 1;\r\n    \t\t}\r\n\r\n    \t\telse {\r\n    \t\t\thigh = mid;\r\n    \t\t}\r\n    \t}\r\n\r\n    \tif(low < N && arr[low] <= X) {\r\n    \tlow++;\r\n    \t}\r\n\r\n    \treturn low;\r\n    }\r\n    \r\n    static long upper_bound(long arr[], long X)\r\n    {\r\n    \tlong mid;\r\n    \tlong N = arr.length;\r\n    \tlong low = 0;\r\n    \tlong high = N;\r\n\r\n    \twhile (low < high) {\r\n    \t\tmid = low + (high - low) / 2;\r\n\r\n    \t\tif (X >= arr[(int) mid]) {\r\n    \t\t\tlow = mid + 1;\r\n    \t\t}\r\n\r\n    \t\telse {\r\n    \t\t\thigh = mid;\r\n    \t\t}\r\n    \t}\r\n\r\n    \tif(low < N && arr[(int) low] <= X) {\r\n    \tlow++;\r\n    \t}\r\n\r\n    \treturn low;\r\n    }\r\n    \r\n    static int[] reverse(int a[])\r\n    {\r\n    \tint n = a.length;\r\n        int i, k, t;\r\n        for (i = 0; i < n / 2; i++) {\r\n            t = a[i];\r\n            a[i] = a[n - i - 1];\r\n            a[n - i - 1] = t;\r\n        }\r\n  \r\n        return a;\r\n    }\r\n    \r\n    static char[] reverse(char a[])\r\n    {\r\n    \tint n = a.length;\r\n        int i, k;\r\n        char t;\r\n        for (i = 0; i < n / 2; i++) {\r\n            t = a[i];\r\n            a[i] = a[n - i - 1];\r\n            a[n - i - 1] = t;\r\n        }\r\n        return a;\r\n    }\r\n    \r\n    public static int mod(long s, int mOD) {\r\n\t\twhile (s < mOD) {\r\n\t\t\ts = s + mOD;\r\n\t\t}\r\n\t\treturn (int) (s % mOD);\r\n\t}\r\n    \r\n    public static boolean isSubstring(String s, String t){\r\n        int n = s.length();\r\n        int m = t.length();\r\n    \tint count = 0;\r\n        boolean[] vis = new boolean[n];\r\n        int prev = -1;\r\n        for(int i = 0; i < m; i++){\r\n            for(int j = 0; j < n; j++){\r\n                if(t.charAt(i) == s.charAt(j) && !vis[j] && prev < j) {\r\n                    vis[j] = true;\r\n                    count++;\r\n                    prev = j;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return count == m;\r\n    }\r\n    \r\n    public static int n;\r\n    public static int m;\r\n    public static int count;\r\n    public static char grid[][];\r\n    public static char grid_temp[][];\r\n    public static boolean vis[][];\r\n    public static int adj[][];\r\n    public static int di[] = {1,-1,0,0,1,-1,1,-1};\r\n    public static int dj[] = {0,0,1,-1,1,-1,-1,1};\r\n    public static int startx,starty,endx,endy;\r\n    public static ArrayList<Integer> path = new ArrayList<Integer>();\r\n    public static StringBuilder input1 = new StringBuilder();\r\n    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\r\n    public static boolean visited[];\r\n    public static int parent[];\r\n    \r\n    public static Set<Long> primes()\r\n    {\r\n    \tboolean[] p=new boolean[1000001];\r\n        p[0]=false;\r\n        p[1]=false;\r\n        p[2]=true;\r\n        for(int i=3;i<p.length;i+=2)p[i]=true;\r\n\r\n        for(int i=3;i<p.length;i+=2){\r\n            if(p[i]){\r\n                for(int j=3*i;j<p.length;j+=2*i)p[j]=false;\r\n            }\r\n        }\r\n        Set<Long> hs=new HashSet<>();\r\n        hs.add(4L);\r\n        for(int i=3;i<p.length;i+=2){\r\n            if(p[i])hs.add((long)i*i);\r\n        }\r\n        \r\n        return hs;\r\n    }\r\n    \r\n    public static long log2(long N)\r\n    {\r\n    \tlong result = (long)(Math.log(N) / Math.log(2));\r\n \r\n        return result;\r\n    }\r\n    \r\n\tpublic static void main(String args[]) throws UnknownHostException, IOException, ClassNotFoundException, SQLException\r\n\t{\r\n\t\tFastReader sc = new FastReader();\r\n\t\t\r\n\t\tPrintWriter out = new PrintWriter(System.out, true);\r\n\t\t\r\n//\t\tint t = sc.nextInt();\r\n\t\tint t = 1;\r\n\t\twhile(t-->0)\r\n\t\t{\r\n\t\t\tint n = sc.nextInt();\r\n\t\t\t\r\n\t\t\tint total = (n*(n-1))/2 - 1;\r\n\t\t\t\r\n\t\t\tint count[] = new int[n+1];\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<n; i++)\r\n\t\t\t{\r\n\t\t\t\tcount[i] = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// n\r\n\t\t\tHashMap<Integer,Integer> hm=new HashMap<>();\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<total; i++)\r\n\t\t\t{\r\n\t\t\t\tint a = sc.nextInt();\r\n\t\t\t\tint b = sc.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tcount[a]++;\r\n\t\t\t\t\r\n\t\t\t\tif(hm.containsKey(a))\r\n\t                hm.put(a,hm.get(a)+1);\r\n\t            else\r\n\t                hm.put(a,1);\r\n\t            if(hm.containsKey(b))\r\n\t                hm.put(b,hm.get(b)+1);\r\n\t            else\r\n\t                hm.put(b,1);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tList<Integer> ls = new ArrayList<>();\r\n\t        for(Map.Entry<Integer,Integer> i:hm.entrySet()){\r\n\t            if(i.getValue()!=(n-1))\r\n\t                ls.add(i.getKey());\r\n\t        }\r\n\t\t\t\r\n\t        if(count[ls.get(0)] > count[ls.get(1)])\r\n\t        \tout.println((ls.get(0)) + \" \" + (ls.get(1)));\r\n\t        else\r\n\t        \tout.println((ls.get(1)) + \" \" + (ls.get(0)));\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tout.close();\r\n\t}\r\n}\r\n\r\nclass Num implements Comparable<Num> {\r\n    int n, b;\r\n\r\n    public Num (int n) {\r\n        this.n = n;\r\n        b = n&(-n);\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Num other) {\r\n        return other.b-this.b;\r\n    }\r\n}\r\n\r\nclass pair implements Comparator<pair>\r\n{\r\n    private int first;\r\n    private int second;\r\n    \r\n    pair(int _v, int _w) { first = _v; second = _w; }\r\n    \r\n    pair() {}\r\n    \r\n    int getfirst() { return first; }\r\n    int getsecond() { return second; }\r\n    \r\n    public int compare(pair pair1, pair pair2) \r\n    { \r\n        if (pair1.second < pair2.second) \r\n            return -1; \r\n        if (pair1.second > pair2.second) \r\n            return 1; \r\n        return 0; \r\n    } \r\n}\r\n\r\nclass Node implements Comparator<Node>\r\n{\r\n    private int v;\r\n    private int weight;\r\n    \r\n    Node(int _v, int _w) { v = _v; weight = _w; }\r\n    \r\n    Node() {}\r\n    \r\n    int getV() { return v; }\r\n    int getWeight() { return weight; }\r\n    \r\n    @Override\r\n    public int compare(Node node1, Node node2) \r\n    { \r\n        if (node1.weight < node2.weight) \r\n            return -1; \r\n        if (node1.weight > node2.weight) \r\n            return 1; \r\n        return 0; \r\n    } \r\n}\r\n\r\nclass NewNode \r\n{\r\n\tprivate int u;\r\n    private int v;\r\n    private int weight;\r\n    \r\n    NewNode(int _u, int _v, int _w) { u = _u; v = _v; weight = _w; }\r\n    \r\n    NewNode() {}\r\n    \r\n    int getV() { return v; }\r\n    int getU() { return u; }\r\n    int getWeight() { return weight; }\r\n\r\n}\r\n\r\nclass Graph\r\n{\r\n\t// sample input tree\r\n\t/*\r\n\t \r\n\t 13 12\r\n\t 1 2\r\n\t 1 3\r\n\t 1 13\r\n\t 2 5\r\n\t 3 4\r\n\t 5 6\r\n\t 5 7\r\n\t 5 8\r\n\t 8 12\r\n\t 4 9\r\n\t 4 10\r\n\t 10 11\r\n\t  \r\n\t */\r\n\t\r\n\t// input\r\n\tstatic class FastReader {\r\n        BufferedReader br;\r\n        StringTokenizer st;\r\n\r\n        public FastReader()\r\n        {\r\n            br = new BufferedReader(\r\n                new InputStreamReader(System.in));\r\n        }\r\n\r\n        String next()\r\n        {\r\n            while (st == null || !st.hasMoreElements()) {\r\n                try {\r\n                    st = new StringTokenizer(br.readLine());\r\n                }\r\n                catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() { return Integer.parseInt(next()); }\r\n \r\n        long nextLong() { return Long.parseLong(next()); }\r\n\r\n        double nextDouble()\r\n        {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        String nextLine()\r\n        {\r\n            String str = \"\";\r\n            try {\r\n                str = br.readLine();\r\n            }\r\n            catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return str;\r\n        }\r\n    }\r\n\t// input end\r\n\tFastReader sc = new FastReader();\r\n\t\r\n\t// graph\r\n    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\r\n    public static int[] arr;\r\n    public static ArrayList<Integer> ls = new ArrayList<Integer>();\r\n    public static int vertex;\r\n    public static int edges;\r\n    public static int[] degree;\r\n    public static int[] depth;\r\n    public static int[] sum;\r\n    public static int[] eve;\r\n    public static int[] height;\r\n    public static int[] parent;\r\n    public static int[] count;\r\n    public static boolean vis[];\r\n    public static int dx[] = {1, -1, 0, 0};\r\n    public static int dy[] = {0, 0, 1, -1};\r\n    public static int dist[];\r\n    ArrayList<NewNode> bellmangraph = new ArrayList<NewNode>();\r\n    public static int matrix[][];\r\n    \r\n    public static int query;\r\n    \r\n    public static ArrayList<ArrayList<Node> > weighted_graph = new ArrayList<ArrayList<Node> >();\r\n    // graph end\r\n    \r\n//    6 7 \r\n//    0 1 5 \r\n//    0 2 10 \r\n//    0 3 100 \r\n//    1 3 50 \r\n//    1 4 200\r\n//    3 4 250\r\n//    4 5 50\r\n    \r\n    public void weighted_input()\r\n    {\r\n    \tvertex = sc.nextInt();\r\n    \t\r\n    \tedges = sc.nextInt();\r\n    \t\r\n    \tparent = new int[vertex];\r\n    \t\r\n    \tArrays.fill(parent, -1);\r\n    \t\r\n    \tfor(int i=0; i<vertex; i++)\r\n\t\t{\r\n\t\t\tweighted_graph.add(new ArrayList<Node>());\r\n\t\t}\r\n    \t\r\n    \tfor(int i=0; i<edges; i++)\r\n\t\t{\r\n\t\t\tint a = sc.nextInt();\r\n\t\t\tint b = sc.nextInt();\r\n\t\t\tint w = sc.nextInt();\r\n\t\t\t\r\n\t\t\ta = a-1;\r\n\t\t\tb = b-1;\r\n\t\t\t\r\n\t\t\tweighted_graph.get(a).add(new Node(b,w));\r\n\t\t\tweighted_graph.get(b).add(new Node(a,w));\r\n\t\t}\r\n    }\r\n    \r\n    public static void shortestPath(int s)\r\n    {\r\n    \tint N = vertex;\r\n    \t\r\n        dist = new int[N];\r\n        \r\n        for(int i = 0;i<N;i++) dist[i] = 100000000;\r\n        dist[s] = 0; \r\n        \r\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(N, new Node());\r\n        pq.add(new Node(s, 0));\r\n        \r\n        while(pq.size() > 0) {\r\n            Node node = pq.poll();\r\n            \r\n            for(Node it: weighted_graph.get(node.getV())) {\r\n                if(dist[node.getV()] + it.getWeight() < dist[it.getV()]) {\r\n                    dist[it.getV()] = dist[node.getV()] + it.getWeight();\r\n                    parent[it.getV()] = node.getV();\r\n                    pq.add(new Node(it.getV(), dist[it.getV()]));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // normal input\r\n\tpublic void input()\r\n\t{\r\n\t\tvertex = sc.nextInt();\r\n\t\t\r\n//\t\tedges = sc.nextInt();\r\n\t\t\r\n\t\tdegree = new int[vertex];\r\n\t\tdepth = new int[vertex];\r\n\t\tsum = new int[vertex];\r\n\t\teve = new int[vertex];\r\n\t\theight = new int[vertex];\r\n\t\tparent = new int[vertex];\r\n\t\tvis = new boolean[vertex];\r\n\t\t\r\n//\t\tweight of vertex\r\n//\t\tfor(int i=0; i<vertex; i++)\r\n//\t\t{\r\n//\t\t\tint f = sc.nextInt();\r\n//\t\t\tls.add(f);\r\n//\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<vertex; i++)\r\n\t\t{\r\n\t\t\tvis[i] = false;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<vertex; i++)\r\n\t\t{\r\n\t\t\tgraph.add(new ArrayList<Integer>());\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<edges; i++)\r\n\t\t{\r\n\t\t\tint a = sc.nextInt();\r\n\t\t\tint b = sc.nextInt();\r\n\t\t\t\r\n\t\t\ta = a-1;\r\n\t\t\tb = b-1;\r\n\t\t\t\r\n\t\t\tgraph.get(a).add(b);\r\n\t\t\tgraph.get(b).add(a);\r\n\t\t\t\r\n\t\t\tdegree[a] = degree[a] + 1;\r\n\t\t\tdegree[b] = degree[b] + 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// normal input\r\n\t\tpublic void tree_input()\r\n\t\t{\r\n\t\t\tvertex = sc.nextInt();\r\n\t\t\t\r\n//\t\t\tedges = sc.nextInt();\r\n\t\t\t\r\n\t\t\tdegree = new int[vertex];\r\n\t\t\tdepth = new int[vertex];\r\n\t\t\tsum = new int[vertex];\r\n\t\t\teve = new int[vertex];\r\n\t\t\theight = new int[vertex];\r\n\t\t\tparent = new int[vertex];\r\n\t\t\tvis = new boolean[vertex];\r\n\t\t\t\r\n//\t\t\tweight of vertex\r\n//\t\t\tfor(int i=0; i<vertex; i++)\r\n//\t\t\t{\r\n//\t\t\t\tint f = sc.nextInt();\r\n//\t\t\t\tls.add(f);\r\n//\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<vertex; i++)\r\n\t\t\t{\r\n\t\t\t\tvis[i] = false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<vertex; i++)\r\n\t\t\t{\r\n\t\t\t\tgraph.add(new ArrayList<Integer>());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<vertex-1; i++)\r\n\t\t\t{\r\n\t\t\t\tint a = sc.nextInt();\r\n\t\t\t\tint b = sc.nextInt();\r\n\t\t\t\t\r\n\t\t\t\ta = a-1;\r\n\t\t\t\tb = b-1;\r\n\t\t\t\t\r\n\t\t\t\tgraph.get(a).add(b);\r\n\t\t\t\tgraph.get(b).add(a);\r\n\t\t\t\t\r\n\t\t\t\tdegree[a] = degree[a] + 1;\r\n\t\t\t\tdegree[b] = degree[b] + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t// normal bfs\r\n\tpublic static ArrayList<Integer> bfs(int v, ArrayList<ArrayList<Integer>> graph, int arr[])\r\n\t{\r\n\t\tArrayList<Integer> bfs = new ArrayList<>();\r\n\t\t\r\n\t\tboolean vis[] = new boolean[v];\r\n\t\tQueue<Integer> q = new LinkedList<>();\r\n\t\t\r\n\t\tq.add(0);\r\n\t\tvis[0] = true;\r\n\t\t\r\n\t\twhile(!q.isEmpty())\r\n\t\t{\r\n\t\t\tInteger node = q.poll();\r\n\t\t\tbfs.add(node);\r\n\t\t\t\r\n\t\t\tfor(Integer it : graph.get(node))\r\n\t\t\t{\r\n\t\t\t\tif(vis[it] == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tvis[it] = true;\r\n\t\t\t\t\tq.add(it);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn bfs;\r\n\t}\r\n\t\r\n\tpublic static void dfs(int v, int par)\r\n\t{\r\n\t\tparent[v] = par;\r\n\t\tfor(int child : graph.get(v))\r\n\t\t{\r\n\t\t\tif(child == par) continue;\r\n\t\t\tdepth[child] = depth[v] + 1;\r\n\t\t\tdfs(child,v);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int getDepth()\r\n\t{\r\n\t\tint max_depth = -1;\r\n\t\tint max_d_node = 0;\r\n\t\t\r\n\t\tfor(int i=0; i<vertex; i++)\r\n\t\t{\r\n\t\t\tif(max_depth < depth[i])\r\n\t\t\t{\r\n\t\t\t\tmax_depth = depth[i];\r\n\t\t\t\tmax_d_node = i;\r\n\t\t\t}\r\n\t\t\tdepth[i] = 0;\r\n\t\t}\r\n\t\t\r\n\t\tdfs(max_d_node,-1);\r\n\t\t\r\n\t\tmax_depth = -1;\r\n\t\t\r\n\t\tfor(int i=0; i<vertex; i++)\r\n\t\t{\r\n\t\t\tif(max_depth < depth[i])\r\n\t\t\t{\r\n\t\t\t\tmax_depth = depth[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn max_depth;\r\n\t}\r\n\t\r\n\tpublic static ArrayList<Integer> path(int v)\r\n\t{\r\n\t\tArrayList<Integer> ans = new ArrayList<Integer>();\r\n\t\t\r\n\t\twhile(v != -1)\r\n\t\t{\r\n\t\t\tans.add(v);\r\n\t\t\tv = parent[v];\r\n\t\t}\r\n\t\t\r\n\t\tCollections.reverse(ans);\r\n\t\t\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static int getLCA(int x, int y)\r\n\t{\r\n\t\tArrayList<Integer> path_x = path(x);\r\n\t\tArrayList<Integer> path_y = path(y);\r\n\t\t\r\n\t\tint mn_ln = Math.min(path_x.size(), path_y.size());\r\n\t\t\r\n\t\tint lca = -1;\r\n\t\tfor(int i=0; i<mn_ln; i++)\r\n\t\t{\r\n\t\t\tif(path_x.get(i) == path_y.get(i))\r\n\t\t\t{\r\n\t\t\t\tlca = path_x.get(i);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn lca;\r\n\t}\r\n\t\r\n\t// normal dfs\r\n\tpublic static ArrayList<Integer> dfs()\r\n\t{\r\n\t\tArrayList<Integer> dfs = new ArrayList<Integer>();\r\n\t\t\r\n\t\tboolean vis[] = new boolean[vertex];\r\n\t\tsum = new int[vertex];\r\n\t\teve = new int[vertex];\r\n\t\t\r\n\t\tArrays.fill(vis, false);\r\n\t\tArrays.fill(depth, 0);\r\n\t\tArrays.fill(sum, 0);\r\n\t\tArrays.fill(eve, 0);\r\n\t\tArrays.fill(height, 0);\r\n\t\t\r\n\t\tfor(int i=0; i<vertex; i++)\r\n\t\t{\r\n\t\t\tif(!vis[i])\r\n\t\t\t{\r\n\t\t\t\tdfsUtil(i, -1, vis, dfs, sum, eve);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(sum[0]);\r\n\t\tSystem.out.println(eve[0]);\r\n\t\tSystem.out.println(depth[8]);\r\n\t\tSystem.out.println(height[4]);\r\n\t\t\r\n\t\treturn dfs;\r\n\t}\r\n\t\r\n\tpublic static  void dfsUtil(int node, int parent, boolean vis[], ArrayList<Integer> dfs, int sum[], int eve[])\r\n\t{\r\n\t\t// take action on vertex after entering vertex\r\n\t\t\r\n//\t\tif(graph.get(node).size() == 1 && graph.get(node).get(0) == parent)\r\n//\t\t{\r\n//\t\t\tleaf node\r\n//\t\t}\r\n\t\tdfs.add(node);\r\n\t\tvis[node] = true;\r\n\t\tsum[node] += (node+1);\r\n\t\tif((node+1) % 2 == 0) eve[node]++;\r\n\t\t\r\n\t\tfor(Integer it : graph.get(node))\r\n\t\t{\r\n\t\t\t// take action on child node before entering child node\r\n\t\t\tif(vis[it] == false)\r\n\t\t\t{\r\n\t\t\t\tdepth[it] = depth[node] + 1;\r\n\t\t\t\t\r\n\t\t\t\tdfsUtil(it, node, vis, dfs, sum, eve);\r\n\t\t\t\t\r\n\t\t\t\t// now child node is exited take action\r\n\t\t\t\t\r\n\t\t\t\theight[node] = Math.max(height[node], height[it]+1);\r\n\t\t\t\tsum[node] = sum[node] + sum[it];\r\n\t\t\t\teve[node] = eve[node] + eve[it];\r\n\t\t\t}\r\n\t\t}\r\n\t\t// take action before exiting vertex\r\n\t}\r\n\t\r\n\tpublic void isCyclic() {\r\n        int topo[] = new int[vertex];\r\n        int indegree[] = new int[vertex];\r\n        \r\n        //finding indegree\r\n        for(int i = 0;i<vertex;i++) {\r\n            for(Integer it: graph.get(i)) {\r\n                indegree[it]++;\r\n            }\r\n        }\r\n        \r\n        Queue<Integer> q = new LinkedList<Integer>();\r\n        for(int i = 0;i<vertex;i++) {\r\n            //adding nodes to queue with indegree = 0\r\n            if(indegree[i] == 0) {\r\n                q.add(i);\r\n            }\r\n        }\r\n        \r\n        int cnt = 0;\r\n        int ind=0;\r\n        \r\n        while(!q.isEmpty()) {\r\n            Integer node = q.poll();\r\n            topo[ind++] = node;\r\n            cnt++;\r\n            //getting neighbour nodes of popped node\r\n            //and decreasing their \r\n            //indegree by1\r\n            for(Integer it: graph.get(node)) {\r\n                indegree[it]--;\r\n                if(indegree[it] == 0) {\r\n                    q.add(it);\r\n                }\r\n            }\r\n        }\r\n        \r\n        //printing topological ordering of nodes\r\n        for (int i=0;i< topo.length;i++){\r\n            System.out.print(topo[i]+\" \");\r\n        }\r\n        \r\n//        checks if graph is cyclic\r\n//        if(cnt == N) return false;\r\n//        return true;\r\n    }\r\n\t\r\n\tstatic void findTopoSort(int node, Stack<Integer> st) {\r\n        vis[node] = true; \r\n        for(Integer it: graph.get(node)) {\r\n            if(vis[it] == false) {\r\n                findTopoSort(it, st); \r\n            } \r\n        }\r\n        st.push(node); \r\n    }\r\n    \r\n\tstatic int[] topoSort() {\r\n        Stack<Integer> st = new Stack<Integer>();  \r\n        \r\n        for(int i = 0;i<vertex;i++) {\r\n            if(vis[i] == false) {\r\n                findTopoSort(i, st);\r\n            }\r\n        }\r\n        \r\n        int topo[] = new int[vertex];\r\n        int ind = 0; \r\n        while(!st.isEmpty()) {\r\n            topo[ind] = st.pop();\r\n            ind++;\r\n        }\r\n//         for(int i = 0;i<N;i++) System.out.println(topo[i] + \" \"); \r\n        return topo; \r\n    }\r\n\t\r\n\tpublic static void primsAlgo()\r\n    {\r\n        int key[] = new int[vertex];\r\n        int parent[] = new int[vertex]; \r\n        boolean mstSet[] = new boolean[vertex]; \r\n        for(int i = 0;i<vertex;i++) {\r\n        \tkey[i] = 100000000; \r\n        \tmstSet[i] = false; \r\n        }\r\n\r\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(vertex, new Node());\r\n\r\n        key[0] = 0;\r\n        parent[0] = -1; \r\n        pq.add(new Node(key[0], 0)); \r\n\t\t// Run the loop till all the nodes have been visited\r\n\t    // because in the brute code we checked for mstSet[node] == false while computing the minimum\r\n\t    // but here we simply take the minimal from the priority queue, so a lot of times a node might be taken twice\r\n\t    // hence its better to keep running till all the nodes have been taken. \r\n\t    // try the following case: \r\n\t    // Credits: Srejan Bera\r\n//\t     6 7 \r\n//\t     0 1 5 \r\n//\t     0 2 10 \r\n//\t     0 3 100 \r\n//\t     1 3 50 \r\n//\t     1 4 200\r\n//\t     3 4 250\r\n//\t     4 5 50 \r\n        while(!pq.isEmpty()) {\r\n        \tint u = pq.poll().getV();\r\n        \tmstSet[u] = true;\r\n        \r\n        \tfor(Node it: weighted_graph.get(u)) {\r\n        \t\tif(mstSet[it.getV()] == false && it.getWeight() < key[it.getV()]) {\r\n        \t\t\tparent[it.getV()] = u; \r\n        \t\t\tkey[it.getV()] = it.getWeight(); \r\n        \t\t\tpq.add(new Node(it.getV(), key[it.getV()]));\r\n        \t\t}\r\n        \t}\r\n        }\r\n\r\n        for(int i = 1;i<vertex;i++) {\r\n        \tSystem.out.println(parent[i] + \" - \" + i); \r\n        }\r\n    }\r\n\t\r\n\tvoid bellmaninput()\r\n\t{\r\n\t\tvertex = sc.nextInt();\r\n\t\t\r\n\t\tedges = sc.nextInt();\r\n\t\t\r\n\t\tfor(int i=0; i<edges; i++)\r\n\t\t{\r\n\t\t\tint a = sc.nextInt();\r\n\t\t\tint b = sc.nextInt();\r\n\t\t\tint w = sc.nextInt();\r\n\t\t\t\r\n\t\t\ta--;\r\n\t\t\tb--;\r\n\t\t\t\r\n\t\t\tbellmangraph.add(new NewNode(a,b,w));\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid bellmanFord(int src)\r\n    {\r\n\t\tArrayList<NewNode> edges = bellmangraph;\r\n\t\tint N = vertex;\r\n\t\t\r\n        dist = new int[N];\r\n        for(int i = 0;i<N;i++) dist[i] = 10000000; \r\n\r\n        dist[src] = 0;\r\n\r\n    \tfor(int i = 1;i<=N-1;i++) {\r\n    \t\tfor(NewNode node : edges) {\r\n    \t\t\tif(dist[node.getU()] + node.getWeight() < dist[node.getV()]) {\r\n    \t\t\t\tdist[node.getV()] = dist[node.getU()] + node.getWeight(); \r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n\r\n    \tint fl = 0; \r\n    \tfor(NewNode node: edges) {\r\n    \t\tif(dist[node.getU()] + node.getWeight() < dist[node.getV()]) {\r\n    \t\t\tfl = 1;\r\n    \t\t\tSystem.out.println(\"Negative Cycle\"); \r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t}\r\n\r\n    \tif(fl == 0) {\r\n    \t\tfor(int i = 0;i<N;i++) {\r\n    \t\t\tSystem.out.println(i + \" \" + dist[i]); \r\n    \t\t}\r\n    \t}\r\n    }\r\n\t\r\n\tpublic void floydWarshall_input()\r\n\t{\r\n\t\tvertex = sc.nextInt();\r\n\t\t\r\n\t\tedges = sc.nextInt();\r\n\t\t\r\n\t\tquery = sc.nextInt();\r\n\t\t\r\n\t\tmatrix = new int[vertex][vertex];\r\n\t\t\r\n\t\tfor (int i = 0; i < vertex; i++) {\r\n            for (int j = 0; j < vertex; j++) {\r\n                matrix[i][j] = -1;\r\n            }\r\n        }\r\n\t\t\r\n\t\tfor(int i=0; i<edges; i++)\r\n\t\t{\r\n\t\t\tint a = sc.nextInt();\r\n\t\t\tint b = sc.nextInt();\r\n\t\t\t\r\n\t\t\tint weight = sc.nextInt();\r\n\t\t\t\r\n\t\t\ta--;\r\n\t\t\tb--;\r\n\t\t\t\r\n\t\t\tmatrix[a][b] = weight;\r\n\t\t\tmatrix[b][a] = weight;\r\n\t\t}\r\n\t\t\r\n\t\tfloyadWarshal_shortest_distance();\r\n\t\t\r\n\t\tfor(int i=0; i<query; i++)\r\n\t\t{\r\n\t\t\tint a = sc.nextInt();\r\n\t\t\tint b = sc.nextInt();\r\n\t\t\t\r\n\t\t\ta--;\r\n\t\t\tb--;\r\n\t\t\t\r\n\t\t\tSystem.out.println(matrix[a][b]);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void floyadWarshal_shortest_distance() {\r\n        int n = matrix.length;\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                if (matrix[i][j] == -1) {\r\n                    matrix[i][j] = (int)(1e9);\r\n                }\r\n                if (i == j) matrix[i][j] = 0;\r\n            }\r\n        }\r\n\r\n        for (int k = 0; k < n; k++) {\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < n; j++) {\r\n                    matrix[i][j] = Math.min(matrix[i][j],\r\n                                            matrix[i][k] + matrix[k][j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                if (matrix[i][j] == (int)(1e9)) {\r\n                    matrix[i][j] = -1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\t\r\n\tpublic static void dfs(int node, int parent, int vis[], int tin[], int low[], ArrayList<ArrayList<Integer>> adj, int timer) {\r\n\t\tvis[node] = 1; \r\n\t\ttin[node] = low[node] = timer++; \r\n\r\n\t\tfor(Integer it: adj.get(node)) {\r\n\t\t\tif(it == parent) continue; \r\n\r\n\t\t\tif(vis[it] == 0) {\r\n\t\t\t\tdfs(it, node, vis, tin, low, adj, timer); \r\n\t\t\t\tlow[node] = Math.min(low[node], low[it]); \r\n\r\n\t\t\t\tif(low[it] > tin[node]) {\r\n\t\t\t\t\tSystem.out.println(it + \" \" +node); \r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tlow[node] = Math.min(low[node], tin[it]); \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n    public static void printBridges(ArrayList<ArrayList<Integer>> adj, int n)\r\n    {\r\n        int vis[] = new int[n]; \r\n        int tin[] = new int[n];\r\n        int low[] = new int[n]; \r\n\r\n        int timer = 0; \r\n        for(int i = 0;i<n;i++) {\r\n        \tif(vis[i] == 0) {\r\n        \t\tdfs(i, -1, vis, tin, low, adj, timer); \r\n        \t}\r\n        }\r\n    }\r\n    \r\n    // articulation point\r\n    private void dfs_art(int node, int parent, int vis[], int tin[], int low[], ArrayList<ArrayList<Integer>> adj, int timer, int isArticulation[]) {\r\n\t\tvis[node] = 1; \r\n\t\ttin[node] = low[node] = timer++; \r\n\t\tint child = 0; \r\n\t\tfor(Integer it: adj.get(node)) {\r\n\t\t\tif(it == parent) continue; \r\n\r\n\t\t\tif(vis[it] == 0) {\r\n\t\t\t\tdfs_art(it, node, vis, tin, low, adj, timer, isArticulation); \r\n\t\t\t\tlow[node] = Math.min(low[node], low[it]); \r\n\r\n\t\t\t\tif(low[it] >= tin[node] && parent != -1) {\r\n\t\t\t\t\tisArticulation[node] = 1;  \r\n\t\t\t\t}\r\n\t\t\t\tchild++; \r\n\t\t\t} else {\r\n\t\t\t\tlow[node] = Math.min(low[node], tin[it]); \r\n\t\t\t}\r\n\t\t}\r\n\t\tif(parent != -1 && child > 1) isArticulation[node] = 1;  \r\n\t}\r\n    void printArticulation(ArrayList<ArrayList<Integer>> adj, int n)\r\n    {\r\n        int vis[] = new int[n]; \r\n        int tin[] = new int[n];\r\n        int low[] = new int[n]; \r\n        \r\n        int isArticulation[] = new int[n];\r\n        \r\n        int timer = 0; \r\n        for(int i = 0;i<n;i++) {\r\n        \tif(vis[i] == 0) {\r\n        \t\tdfs_art(i, -1, vis, tin, low, adj, timer, isArticulation); \r\n        \t}\r\n        }\r\n        \r\n        for(int i = 0;i<n;i++) {\r\n            if(isArticulation[i] == 1) System.out.println(i); \r\n        }\r\n    }\r\n}"
}