{
    "id": 193103811,
    "contestId": 1158,
    "creationTimeSeconds": 1676054147,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1158,
        "index": "D",
        "name": "Winding polygonal line",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2600,
        "tags": [
            "constructive algorithms",
            "geometry",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1158,
        "members": [
            {
                "handle": "_Satoru_"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1557671700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 10035200,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"avx,avx2,fma\")\r\n#pragma GCC optimization (\"unroll-loops\")\r\n\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\n \r\n#define S size()\r\n#define E end()\r\n#define B begin()\r\n#define L length()\r\n \r\n#define endl \"\\n\"\r\n#define cnt count\r\n#define in insert\r\n#define er erase\r\n#define fi first\r\n#define se second\r\n#define fl float\r\n#define ld long double\r\n#define ll long long\r\n\r\n#define gcd __gcd\r\n#define mp make_pair\r\n#define pb push_back\r\n#define popb pop_back()\r\n#define pf push_front\r\n#define popf pop_front()\r\n#define all(v) v.B,v.E\r\n#define acc(v) accumulate(all(v), 0)\r\n#define psum partial_sum\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define bs binary_search\r\n#define np next_permutation\r\n#define maxe *max_element\r\n#define mine *min_element\r\n \r\n#define forl(i,n) for(ll i = 0; i < n; i++)\r\n#define fore(i,m,n) for (ll i = m; i <= n; i++)\r\n#define rforl(i,n) for (ll i = n - 1; i >= 0; i--)\r\n#define rfore(i,m,n) for (ll i = m; i >=n; i--)    \r\n#define iter(s) for(auto it:s)\r\n \r\n\r\n#define prec(n) fixed<<setprecision(n)\r\n#define popcnt(n) __builtin_popcountll(n)\r\n#define parity(n) __builtin_parityll(n)\r\n#define clz(n) __builtin_clzll(n)\r\n#define ctz(n) __builtin_ctzll(n)\r\n\r\n#define sll set<ll>\r\n#define sc set<char>\r\n#define mll map<ll,ll>\r\n#define vll vector<ll>\r\n#define vc vector<char>\r\n#define pll pair<ll,ll>\r\n#define vpll vector<pll>\r\n#define msll multiset<ll,greater<ll>>\r\n#define msc multiset<char,greater<char>>\r\n#define vvll vector<vector<ll>>\r\n#define rev reverse\r\n\r\n#define tc ll q;cin>>q;while(q--)\r\n#define pat ll n;cin>>n\r\n#define pat1 vll a(n);forl(i,n)cin>>a[i]\r\n#define pat2 ll n,k;cin>>n>>k;vll a(n);forl(i,n) cin>>a[i]\r\n#define pats string s;cin>>s\r\n#define yesno if(flag)cout<<\"YES\\n\";else cout<<\"NO\\n\"\r\n#define loop forl(i,n)\r\n\r\n#define p0(a) cout << a << \" \"\r\n#define p1(a) cout << a << endl\r\n#define p2(a,b) cout << a << \" \" << b << endl\r\n#define p3(a,b,c) cout << a << \" \" << b << \" \" << c << endl\r\n#define p4(a,b,c,d) cout << a << \" \" << b << \" \" << c << \" \" << d << endl\r\n \r\n#define MAX LLONG_MAX\r\n#define MIN LLONG_MIN\r\n#define mod1 1000000007\r\n#define mod2 998244353\r\n#define PI 3.1415926535897932384626433832\r\n#define FAST ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\r\n#define oset tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\r\n\r\n//member functions :\r\n//IMPORTANT:Ordered Set is basically a set and doesn't allow duplicates so use pair<ll,ll> to get \r\n//an Ordered Multiset\r\n//1. order_of_key(k) : number of elements strictly lesser than k\r\n//2. find_by_order(k) : k-th element in the set\r\n//random number generator using uniform distribution\r\n//  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n//   randomly  generate index a[uniform_int_distribution<int>(l,r)(rng)];\r\n#define ofk order_of_key\r\n#define fbo find_by_order\r\nusing namespace std;\r\nvoid printarr(ll a[],ll n){\r\n    forl(i,n){\r\n        p0(a[i]);\r\n    }\r\n    cout<<endl;\r\n}\r\nvoid printv(vector<ll>&v){\r\n    forl(i,v.S){\r\n        p0(v[i]);\r\n    }\r\n    cout<<endl;\r\n}\r\nvector<ll> res;\r\nvoid factorize(ll n) {\r\n    for (ll i = 2; i * i <= n; ++i) {\r\n        while (n % i == 0) {\r\n            res.push_back(i);\r\n            n /= i;\r\n        }\r\n    }\r\n    if (n != 1) {\r\n        res.push_back(n);\r\n    }\r\n}\r\nvll divs;\r\nvoid divisor(ll n){\r\n        for(ll i=2;i<=sqrt(n);i++){\r\n            if(n%i==0){\r\n                divs.pb(i);\r\n                if(n/i!=i){\r\n                    divs.pb(n/i);\r\n                }\r\n            }\r\n        }\r\n        divs.pb(1);\r\n        if(n!=1){\r\n            divs.pb(n);\r\n        }\r\n}\r\nvector<ll>prefix_function(string &s) {\r\n    ll n = (ll)s.length();\r\n    vector<ll> pi(n);\r\n    for (ll i = 1; i < n; i++) {\r\n        ll j = pi[i-1];\r\n        while (j > 0 && s[i] != s[j])\r\n            j = pi[j-1];\r\n        if (s[i] == s[j])\r\n            j++;\r\n        pi[i] = j;\r\n    }\r\n    return pi;\r\n}\r\nll modexpo(ll x,ll y)  \r\n{   ll res = 1;\r\n    x = x%mod1; \r\n    if (x == 0) return 0; \r\n    while (y > 0)  \r\n    {   if (y & 1)res = (res*x) % mod1;  \r\n        y = y>>1; \r\n        x = (x*x) % mod1;  \r\n    }  \r\n    return res;  \r\n}  \r\n//DSU-Disjoint Set Union-Find\r\n/*ll parent[200005];\r\nll sz[200005];\r\nvoid MakeSet(ll v){\r\n    parent[v]=v;\r\n    sz[v]=1;\r\n}\r\nll FindSet(ll v){\r\n    if(v==parent[v]){\r\n        return v;\r\n    }\r\n    return parent[v]=FindSet(parent[v]);\r\n}\r\nvoid UnionSet(ll u,ll v){\r\n    u=FindSet(u);\r\n    v=FindSet(v);\r\n    if(u==v){\r\n        //both are already in the same set\r\n    }else{\r\n        if(sz[u]<sz[v]){\r\n            swap(u,v);\r\n        }\r\n        parent[v]=u;\r\n        sz[u]+=sz[v];\r\n    }\r\n}\r\n*/\r\n/* LCA \r\nvll g[200005];\r\nconst ll maxN=log2(200005);\r\nll dp[200005][maxN+1];\r\nll level[200005]={};\r\n//set dp to -1 before use\r\n//dp[i][j]=(2^j)th parent of i\r\nvoid dfslca(ll node,ll par,ll lvl){\r\n    dp[node][0]=par;\r\n    level[node]=lvl;\r\n    for(ll child:g[node]){\r\n        if(child!=par){\r\n            dfslca(child,node,lvl+1);\r\n        }\r\n    }\r\n}\r\nvoid dpfill(ll n){\r\n    dfslca(1,-1,0);\r\n    for(ll j=1;j<=maxN;j++){\r\n        for(ll i=1;i<=n;i++){\r\n            if(dp[i][j-1]!=-1){\r\n            dp[i][j]=dp[dp[i][j-1]][j-1];\r\n            }\r\n        }\r\n    }\r\n}\r\nll LCA(ll a,ll b){\r\n    if(level[a]>level[b]){\r\n        swap(a,b);\r\n    }\r\n    ll d=level[b]-level[a];\r\n    while(d>0){\r\n        ll i=log2(d);\r\n        b=dp[b][i];\r\n        d-=(1<<i);\r\n    }\r\n    if(a==b){\r\n        return a;\r\n    }\r\n    for(ll i=maxN;i>=0;i--){\r\n        if(dp[a][i]!=-1 && (dp[a][i]!=dp[b][i])){\r\n            a=dp[a][i],b=dp[b][i];\r\n        }\r\n    }\r\n    return dp[a][0];\r\n}\r\nll dist(ll a,ll b){\r\n    ll c=LCA(a,b);\r\n    return level[a]+level[b]-2*level[c];\r\n}\r\n*/\r\n/*\r\nPrime factorization sieve MAXlog(MAX) preprocessing and subsequent factorizations in logn time\r\nconst ll MAXM = 15000001;\r\nbool v[MAXM];\r\nll sp[MAXM];\r\n \r\nvoid Sieve(){\r\n    sp[1] = 1;// base case\r\n    for (ll i = 2; i < MAXM; i += 2)    sp[i] = 2;//even numbers have smallest prime factor 2\r\n    for (ll i = 3; i < MAXM; i += 2){\r\n        if (!v[i]){\r\n            sp[i] = i;\r\n            for (ll j = i; (j*i) < MAXM; j += 2){\r\n                if (!v[j*i])    v[j*i] = true, sp[j*i] = i;\r\n            }\r\n        }\r\n    }\r\n} \r\n \r\n\r\n*/\r\n/*\r\n//Lagrange Interpolation \r\n//Used in questions involving summations where no. of terms is very large \r\nlong long int inverse(long long int i,ll MOD){\r\n    if(i==1) return 1;\r\n    return (MOD - ((MOD/i)*inverse(MOD%i,MOD))%MOD+MOD)%MOD;\r\n}  \r\nll normalize(ll x,ll MOD){\r\n    if(x<0){\r\n        return (MOD+x%MOD)%MOD;\r\n    }else{\r\n        return x%MOD;\r\n    }\r\n} \r\nll Interpolate(vll &sum,ll n,ll roots){\r\n    //interpolation of f(x)=sum[x]\r\n       // sum[1] sum[2] sum[3] ........ sum[roots] are the roots points needed for interpolation of the \r\n       // roots-1 degree polynomial which is the summation of n^k\r\n       ll pref[roots+2]={};\r\n       pref[0]=1;\r\n       for(ll i=1;i<=roots;i++){\r\n           pref[i]=(pref[i-1]%mod1*normalize(n-i,mod1))%mod1;\r\n       }\r\n       ll suff[roots]={};\r\n       suff[roots+1]=1;\r\n       for(ll i=roots;i>=1;i--){\r\n           suff[i]=(suff[i+1]%mod1*normalize(n-i,mod1))%mod1;\r\n       }\r\n       ll denom[roots+1]={};\r\n       denom[1]=1;\r\n       for(ll i=2;i<=roots;i++){\r\n           denom[1]=(denom[1]%mod1*normalize(1-i,mod1)%mod1)%mod1;\r\n       }\r\n       for(ll i=2;i<=roots;i++){\r\n           denom[i]=((denom[i-1]%mod1*normalize(i-1,mod1)%mod1)%mod1*inverse((normalize(1-(roots-(i-2)),mod1))%mod1,mod1)%mod1)%mod1;\r\n       }\r\n       ll ans=0;\r\n       for(ll i=1;i<=roots;i++){\r\n           ll prod=1;\r\n           prod=(prod%mod1*sum[i]%mod1)%mod1;\r\n           prod=(prod%mod1*pref[i-1]%mod1)%mod1;\r\n           prod=(prod%mod1*suff[i+1]%mod1)%mod1;\r\n           prod=(prod%mod1*inverse(denom[i],mod1)%mod1)%mod1;\r\n           ans=(ans%mod1+prod)%mod1;\r\n       }\r\n       return ans;\r\n}\r\n*/ \r\n/* MERGE SORT+Counting Inversions\r\nll inversioncnt=0;\r\nvoid Merge(ll a[],ll l,ll m,ll r){\r\n    ll n1=m-l+1;\r\n    ll n2=r-m;\r\n    ll left[n1],right[n2];\r\n    for(ll i=0;i<n1;i++){\r\n        left[i]=a[l+i];\r\n    }\r\n    for(ll i=0;i<n2;i++){\r\n        right[i]=a[m+1+i];\r\n    }\r\n    ll i=0,j=0,k=l;\r\n    while(i<n1 && j<n2){\r\n        if(left[i]<=right[j]){\r\n            a[k]=left[i];\r\n            i++;\r\n            k++;\r\n        }else{\r\n            inversioncnt+=(n1-i);\r\n            a[k]=right[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n    while(i<n1){\r\n        a[k]=left[i];\r\n        i++;\r\n        k++;\r\n    }\r\n    while(j<n2){\r\n        a[k]=right[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\nvoid MergeSort(ll a[],ll l,ll r){\r\n    if(l<r){\r\n        ll mid=l+(r-l)/2;\r\n        MergeSort(a,l,mid);\r\n        MergeSort(a,mid+1,r);\r\n        Merge(a,l,mid,r);\r\n    }\r\n}\r\n*/\r\n/*STRONGLY CONNECTED COMPONENTS \r\nvll g[400005];\r\nvll gt[400005];\r\nll vis[400005];\r\nvll order,component;\r\nvll roots(400005,0);\r\nvll root_nodes;\r\nvll gscc[400005];\r\nvoid addEdge(ll u,ll v){\r\n    //graph\r\n    g[u].pb(v);\r\n    //transposed graph\r\n    gt[v].pb(u);\r\n}\r\n//dfs1 generates all vertices in the order vector in the increasing order of out time\r\n//reverse topological order\r\nvoid dfs1(ll u){\r\n    vis[u]=1;\r\n    for(auto v:g[u]){\r\n        if(!vis[v]){\r\n            dfs1(v);\r\n        }\r\n    }\r\n    order.pb(u);\r\n}\r\n\r\n//dfs2 is done on the inverse graph and it visits only those nodes present in the current strongly connected component\r\nvoid dfs2(ll u){\r\n    vis[u]=1;\r\n    component.pb(u);\r\n    for(auto v:gt[u]){\r\n        if(!vis[v]){\r\n            dfs2(v);\r\n        }\r\n    }\r\n}\r\n//create the condensation graph\r\nvoid condense(ll n,vll &selfloop){\r\n    for(ll i=1;i<=n;i++){\r\n        vis[i]=0;\r\n    }\r\n    //dfs1 generates all vertices in the order vector in the increasing order of out time\r\n    for(ll i=1;i<=n;i++){\r\n        if(!vis[i]){\r\n            dfs1(i);\r\n        }\r\n    }\r\n    //sort on decreasing order of out time\r\n    rev(all(order));\r\n    //dfs2 is done on the inverse graph and it visits only those nodes present in the current strongly connected component\r\n    for(ll i=1;i<=n;i++){\r\n        vis[i]=0;\r\n    }\r\n    for (auto x : order){\r\n            if (!vis[x]) {\r\n                dfs2(x);\r\n                ll root = component.front();\r\n                for(auto u : component) \r\n                {\r\n                    roots[u] = root;\r\n                    selfloop[root] |= selfloop[u];\r\n                }\r\n                root_nodes.push_back(root);\r\n                if(component.S > 1)\r\n                    selfloop[root] = 1;\r\n \r\n                component.clear();\r\n            }\r\n    }\r\n    for (ll u = 1; u <=n; u++){\r\n        for (auto v : g[u]) {\r\n            ll root_u = roots[u];\r\n            ll root_v = roots[v];\r\n            if (root_v != root_u)\r\n                gscc[root_u].pb(root_v);\r\n        }\r\n    }\r\n    for(ll i=1;i<=n;i++){\r\n        vis[i]=0;\r\n    }\r\n}\r\n*/\r\n/* Dijkstra\r\nvpll g[1001];\r\nll dist[1001];\r\nvoid Dijkstra(ll s){\r\n    for(ll i=1;i<=1000;i++){\r\n        dist[i]=MAX/2;\r\n    }\r\n    dist[s]=0;\r\n    set<pll>pq;\r\n    pq.insert({0,s});\r\n    while(pq.size()){\r\n        pll top=*pq.begin();\r\n        pq.erase(pq.begin());\r\n        ll u=top.second;\r\n        ll d=top.first;\r\n        for(auto edge:g[u]){\r\n            ll v=edge.first;\r\n            ll w=edge.second;\r\n            if(d+w<dist[v]){\r\n                pq.erase({dist[v],v});\r\n                dist[v]=d+w;\r\n                pq.insert({dist[v],v});\r\n            }\r\n        }\r\n    }\r\n}\r\n \r\n*/\r\n/* LINKED LIST\r\n   struct ListNode{\r\n    int val;\r\n    ListNode* next;\r\n    ListNode(int x):val(x),next(NULL){}\r\n   }; \r\n \r\n*/\r\n\r\n/*\r\nDFS over the complement graph of the given graph\r\n\r\ng contains the edges that are not present \r\ns is the set of nodes that need to be visited \r\n\r\nvll g[500005];\r\nll vis[500005];\r\nll dfs(ll u,sll &s){\r\n    vis[u]=1;\r\n    ll cnt=1;\r\n    s.erase(u);\r\n    sll temp;\r\n    vector<ll>canbevis;\r\n    for(auto v:g[u]){\r\n        if(s.find(v)!=s.end()){\r\n            s.erase(v);\r\n            temp.insert(v);\r\n        }\r\n    }\r\n    for(auto v:s){\r\n        canbevis.pb(v);\r\n    }\r\n    s.clear();\r\n    for(auto v:temp){\r\n        s.insert(v);\r\n    }\r\n    for(auto v:canbevis){\r\n        if(!vis[v]){\r\n        cnt+=dfs(v,s);\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\n\r\n*/\r\n\r\n/*\r\ntemplate<typename T>\r\nstruct LazySegmentTree{\r\n    vector<T> st;\r\n    void assign(vector<ll> &v1){\r\n        ll n = v1.S;\r\n        st = vector<T> (4 * n + 1);\r\n        build(v1, 1, 0, n - 1);\r\n    }\r\n    ll combine(ll x, ll y){\r\n        return x + y;   // check which opeartion is to be performed\r\n    }\r\n    void build(vector<ll> &v1, ll v, ll tl, ll tr){\r\n        if(tl == tr){\r\n            st[v].sum=v1[tl];     //  check\r\n        }\r\n        else{\r\n            ll mid = (tl + tr) / 2;\r\n            build(v1, 2 * v, tl, mid);\r\n            build(v1, 2 * v + 1, mid + 1, tr);\r\n            st[v].sum = combine(st[2 * v].sum, st[2 * v + 1].sum);\r\n        }\r\n    }\r\n    void prop(ll v,ll tl,ll tr){\r\n        //range assignment\r\n        if(st[v].mark){\r\n            st[v].sum = (tr - tl + 1) * st[v].change;\r\n            //st[v].sum = st[v].change; for min-max query\r\n            // check which opeartion is to be performed\r\n            if(tl != tr){\r\n                st[2 * v].change = st[2 * v + 1].change = st[v].change;\r\n                st[2 * v].mark = st[2 * v + 1].mark = 1;\r\n                st[2 * v].lazy = st[2 * v + 1].lazy = 0;\r\n            }\r\n            st[v].change = st[v].mark = 0;\r\n        }\r\n        \r\n        //range addition\r\n        // if(st[v].lazy != 0){\r\n        //     st[v].sum += (tr - tl + 1) * st[v].lazy;\r\n        //     //st[v].sum +=st[v].lazy; for min-max query\r\n        //     // check which opeartion is to be performed\r\n        //     if(tl != tr){\r\n        //         st[2 * v].lazy += st[v].lazy;\r\n        //         st[2 * v + 1].lazy += st[v].lazy;\r\n        //     }\r\n        //     st[v].lazy = 0;\r\n        //     // if st[v].lazy is != 0 at any point, it means from that vertex onwards we have to make updations\r\n        // }\r\n    }\r\n    ll query(ll v,ll tl,ll tr,ll l,ll r){\r\n        if(tr < l || r < tl){\r\n            return 0; // check which opeartion is to be performed\r\n        }\r\n        prop(v, tl, tr);\r\n        if(l <= tl && tr <= r){\r\n            return st[v].sum;\r\n        }\r\n        ll mid = (tl + tr) / 2;\r\n        return combine(query(2 * v, tl, mid, l, min(r, mid)), query(2 * v + 1, mid + 1, tr, max(l, mid + 1), r));\r\n    }\r\n    \r\n    //range addition\r\n    void update_many(ll v,ll tl,ll tr,ll l,ll r,ll newVal){\r\n        prop(v, tl, tr);\r\n        if(tr < l || r < tl){\r\n            return;\r\n        }\r\n        if(l == tl && r == tr){\r\n            st[v].lazy += newVal;\r\n            prop(v, tl, tr);\r\n            return;\r\n        }else{\r\n            ll mid = (tl + tr) / 2;\r\n            update_many(2 * v, tl, mid, l, min(r, mid), newVal);\r\n            update_many(2 * v + 1, mid + 1, tr, max(l, mid + 1), r, newVal);\r\n            st[v].sum = combine(st[2 * v].sum, st[2 * v + 1].sum);\r\n        }\r\n    }\r\n    \r\n    //range assignment\r\n    void change_many(ll v, ll tl, ll tr, ll l, ll r, ll newVal){\r\n        prop(v, tl, tr);\r\n        if(tr < l || r < tl){\r\n            return;\r\n        }\r\n        if(l == tl && r == tr){\r\n            st[v].lazy = 0;\r\n            st[v].mark = 1;\r\n            st[v].change = newVal;\r\n            prop(v, tl, tr);\r\n            return;\r\n        }else{\r\n            ll mid = (tl + tr) / 2;\r\n            change_many(2 * v, tl, mid, l, min(r, mid), newVal);\r\n            change_many(2 * v + 1, mid + 1, tr, max(l, mid + 1), r, newVal);\r\n            st[v].sum = combine(st[2 * v].sum, st[2 * v + 1].sum);\r\n        }\r\n    }\r\n};\r\nstruct Node{\r\n    ll sum, lazy;\r\n    ll change;\r\n    bool mark;\r\n};\r\nLazySegmentTree<Node> seg;\r\n*/\r\n/*\r\ntemplate<typename T>\r\nstruct SparseTable{\r\n    vector<vector<T>> st;\r\n    void done(){\r\n        st.clear();\r\n    }\r\n    void build(vector<T> &v1){\r\n        int n = v1.S;\r\n        int n1 = __lg(n)+1;\r\n        st = vector<vector<T>> (n1,vector<T>(n));\r\n        forl(i,n1){\r\n            forl(j,n+1-(1<<i)){\r\n                if(!i)  st[0][j] = v1[j];    //  base condition\r\n                else    st[i][j] = __gcd( st[i-1][j], st[i-1][j + (1<<(i-1))] );\r\n                //  check which opeartion is to be performed\r\n            }\r\n            if(n<(1<<i))    break;\r\n        }\r\n    }\r\n    T query(int lo, int hi){\r\n        // 0-indexed\r\n        int x = __lg(hi-lo+1);\r\n        int y = 1<<x;\r\n        return __gcd(st[x][lo], st[x][hi-y+1]);\r\n        //  check which opeartion is to be performed\r\n    }\r\n};\r\nSparseTable<ll> spar;\r\n*/\r\n\r\n/* Binary Trie \r\n\r\n    class TrieNode{\r\n      public:\r\n        ll key;\r\n        TrieNode* child[2];\r\n        TrieNode(){\r\n            key=0;\r\n            child[0]=NULL;\r\n            child[1]=NULL;\r\n        }\r\n    };\r\n    TrieNode* root; // TrieNode* root = new TrieNode(); in main\r\n    void insert(ll x){\r\n        TrieNode* node=root;\r\n        for(ll i=31;i>=0;i--){\r\n            bool bit=(x&(1<<i));\r\n            if(node->child[bit]){\r\n                node=node->child[bit];\r\n            }else{\r\n                node->child[bit]=new TrieNode();\r\n                node=node->child[bit];\r\n            }\r\n        }\r\n        node->key=x;\r\n    }\r\n    ll findmaxxor(ll x){\r\n        TrieNode* node=root;\r\n        for(ll i=31;i>=0;i--){\r\n            bool bit=(x&(1<<i));\r\n            if(node->child[!bit]){\r\n                node=node->child[!bit];\r\n            }else{\r\n                if(node->child[bit]){\r\n                node=node->child[bit];\r\n                }\r\n            }\r\n        }\r\n        return (node->key)^x;\r\n    }\r\n\r\n\r\n*/\r\n\r\n/*DP ON DAG \r\nGenerate the topological sort of the graph \r\n// we can check for cycles in directed graph using toplogical sort \r\n//if there is a cycle then it is guarenteed that there is an edge u->v such that v occurs earlier in topological order\r\n vll g[200005];\r\n ll vis[200005];\r\n vll topological;\r\n void dfs(ll u){\r\n    vis[u]=1;\r\n    for(auto v:g[u]){\r\n        if(!vis[v]){\r\n            dfs(v);\r\n        }\r\n    }\r\n    topological.pb(u);\r\n }\r\n\r\n  reverse(all(topological));\r\n  for(auto u:topological){\r\n      //iterating over the u with least dependencies first i.e. the logical order of finishing tasks\r\n      for(auto v:g[u]){\r\n       //dp[v] = f(dp[u],dp[v])\r\n    }\r\n  }\r\n\r\n*/\r\n/* Finding Bridges\r\nvll g[300005];\r\nbool vis[300005];\r\nvll low(300005,-1);\r\nvll tin(300005,-1);\r\nll timer;\r\nset<pll> bridges;\r\nvoid dfs(ll v,ll p = -1) {\r\n    vis[v] = true;\r\n    tin[v] = low[v] = timer++;\r\n    for (ll to : g[v]) {\r\n        if (to == p) continue;\r\n        if (vis[to]) {\r\n            low[v] = min(low[v], tin[to]);\r\n        } else {\r\n            dfs(to, v);\r\n            low[v] = min(low[v], low[to]);\r\n            if (low[to] > tin[v])\r\n                bridges.insert({v,to});\r\n        }\r\n    }\r\n}\r\n\r\nvoid find_bridges(ll n) {\r\n    timer = 0;\r\n    for(ll i=1;i<=n;i++){\r\n        vis[i] = 0;\r\n        low[i] = -1;\r\n        tin[i] = -1;\r\n    }\r\n    for (int i = 1; i <=n; ++i) {\r\n        if (!vis[i]){\r\n            dfs(i);\r\n        }\r\n    }\r\n}\r\n\r\n*/\r\n\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\n//unordered_map<ll,ll,custom_hash>mp;\r\n//Makes unordered_map faster\r\n//mp.reserve(2*n); Reserves fixed number of buckets at the beginning so no time waste in resizing\r\n//mp.max_load_factor(0.25);\r\n//Pythagorean Triplets-2n+1,2n^2+2n,2n^2+2n+1\r\n//map is faster than multiset\r\n//when erasing from set using iterator make sure to check that the iterator is not s.end() otherwise face RUNTIME ERROR\r\n//ACCESS ARRAYS IN ROW MAJOR ORDER IF YOU DON'T WANT TLE\r\n//Use binary search instead of sqrt function to avoid untold pain and misery\r\n//**********************************\r\n vll g[500005];\r\n ll vis[500005];\r\n vll topological;\r\n void dfs(ll u){\r\n    vis[u]=1;\r\n    for(auto v:g[u]){\r\n        if(!vis[v]){\r\n            dfs(v);\r\n        }\r\n    }\r\n    topological.pb(u);\r\n } \r\n\r\nbool check(vll &v,vll &next){\r\n    vll s;\r\n    ll n = v.S;\r\n    vll nex(n);\r\n    for(ll i=n-1;i>=0;i--){\r\n        if(s.S==0){\r\n            s.pb(i);\r\n            nex[i] = n+1;\r\n        }else{\r\n            while(s.size() && v[s.back()]<v[i]){\r\n                s.popb;\r\n            }\r\n            if(s.S==0){\r\n                s.pb(i);\r\n                nex[i] = n+1;\r\n            }else{\r\n                nex[i] = s.back()+1;\r\n                s.pb(i);\r\n            }\r\n        }\r\n    }\r\n    forl(i,n){\r\n        if(nex[i]!=next[i]){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n} \r\n \r\n \r\n//             Shinzou Wo Sasageyo\r\nint main(){\r\n   FAST;\r\n   tc{\r\n       ll n;\r\n       cin>>n;\r\n       vll next(n);\r\n       forl(i,n){\r\n           cin>>next[i];\r\n           if(next[i]==-1){\r\n               next[i] = i+2;\r\n           }\r\n       }\r\n       forl(i,n+1){\r\n           g[i+1].clear();\r\n           vis[i+1] = 0;\r\n       }\r\n       topological.clear();\r\n       forl(i,n){\r\n          g[next[i]].push_back(i+1);\r\n       }\r\n       forl(i,n){\r\n           if(g[next[i]].S){\r\n           sort(all(g[next[i]]));\r\n           rev(all(g[next[i]]));\r\n           }\r\n       }\r\n       dfs(n+1);\r\n       topological.popb;\r\n       vll ans(n);\r\n       forl(i,n){\r\n          ans[topological[i]-1] = i+1;\r\n       }\r\n      if(check(ans,next)){\r\n          printv(ans); \r\n      }else{\r\n          p1(-1);\r\n      }\r\n   }\r\n  \r\n  \r\n  \r\n  \r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}