{
    "id": 88268499,
    "contestId": 1158,
    "creationTimeSeconds": 1596012964,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1158,
        "index": "D",
        "name": "Winding polygonal line",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2600,
        "tags": [
            "constructive algorithms",
            "geometry",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1158,
        "members": [
            {
                "handle": "st1vdy"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1557671700
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 3686400,
    "source": "#define _CRT_SECURE_NO_WARNINGS\r\n#include <bits/stdc++.h>\r\n#define db double\r\nusing namespace std;\r\nconst db eps = 1e-5;\r\nconst db pi = acos(-1.0);\r\n\r\nint sign(db k) {\r\n\tif (k > eps) return 1;\r\n\telse if (k < -eps) return -1;\r\n\treturn 0;\r\n}\r\nint cmp(db k1, db k2) { return sign(k1 - k2); }\r\n\r\nstruct point {\r\n\tdb x, y;\r\n\tint id;\r\n\tpoint() {}\r\n\tpoint(db x_, db y_) :x(x_), y(y_) {}\r\n\tpoint(db x_, db y_, int id_) :x(x_), y(y_), id(id_) {}\r\n\tpoint operator + (const point& k) const { return point(k.x + x, k.y + y); }\r\n\tpoint operator - (const point& k) const { return point(x - k.x, y - k.y); }\r\n\tpoint operator * (db k) const { return point(x * k, y * k); }\r\n\tpoint operator / (db k1) const { return point(x / k1, y / k1); }\r\n\tpoint turn(db k1) { return point(x * cos(k1) - y * sin(k1), x * sin(k1) + y * cos(k1)); } // \u9006\u65f6\u9488\u65cb\u8f6c\r\n\tpoint turn90() { return point(-y, x); } // \u9006\u65f6\u9488\u65b9\u5411\u65cb\u8f6c 90 \u5ea6\r\n\tdb len() { return sqrt(x * x + y * y); } // \u5411\u91cf\u957f\u5ea6\r\n\tdb len2() { return x * x + y * y; } // \u5411\u91cf\u957f\u5ea6\r\n\tdb dis(point rhs) { return ((*this) - rhs).len(); }\r\n\tpoint unit() { db d = len(); return point(x / d, y / d); }\r\n\tbool operator < (const point& k) const {\r\n\t\treturn x == k.x ? y < k.y : x < k.x;\r\n\t}\r\n\tbool getP() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) == -1); }\r\n}triangleVertex[3];\r\ndb cross(point k1, point k2) { return k1.x * k2.y - k1.y * k2.x; }\r\ndb dot(point k1, point k2) { return k1.x * k2.x + k1.y * k2.y; }\r\ndb rad(point k1, point k2) { return atan2(cross(k1, k2), dot(k1, k2)); }\r\nint compareangle(point k1, point k2) {\r\n\treturn k1.getP() < k2.getP() || (k1.getP() == k2.getP() && sign(cross(k1, k2)) > 0);\r\n}\r\npoint proj(point k1, point k2, point q) { // q \u5230\u76f4\u7ebf k1,k2 \u7684\u6295\u5f71\r\n\tpoint k = k2 - k1; return k1 + k * (dot(q - k1, k) / k.len2());\r\n}\r\npoint reflect(point k1, point k2, point q) { return proj(k1, k2, q) * 2 - q; } // q \u5173\u4e8e\u76f4\u7ebf k1,k2 \u7684\u5bf9\u79f0\u70b9\r\nint clockwise(point k1, point k2, point k3) { // k1 k2 k3 \u9006\u65f6\u94881 \u987a\u65f6\u9488-1 \u5426\u52190\r\n\treturn sign(cross(k2 - k1, k3 - k1));\r\n}\r\nint checkLL(point k1, point k2, point k3, point k4) { // \u6c42\u76f4\u7ebf(L) \u7ebf\u6bb5(S) k1,k2 \u548c k3,k4 \u7684\u4ea4\u70b9\r\n\treturn cmp(cross(k3 - k1, k4 - k1), cross(k3 - k2, k4 - k2)) != 0;\r\n}\r\ndb deg(point k1, point k2) {\r\n\treturn asin(cross(k1, k2) / k1.len() / k2.len());\r\n}\r\n\r\nstruct line {\r\n\tpoint p[2];\r\n\tline() {}\r\n\tline(point k1, point k2) { p[0] = k1, p[1] = k2; }\r\n\tpoint& operator [] (int k) { return p[k]; }\r\n\tpoint dir() { return p[1] - p[0]; }\r\n\tbool include(point k) { return sign(cross(p[1] - p[0], k - p[0])) > 0; }\r\n\tline push(db len) { // \u5411\u5916\uff08\u5de6\u624b\u8fb9\uff09\u5e73\u79fb len \u4e2a\u5355\u4f4d\r\n\t\tpoint delta = (p[1] - p[0]).turn90().unit() * len;\r\n\t\treturn line(p[0] - delta, p[1] - delta);\r\n\t}\r\n}triangle[3];\r\n\r\nbool parallel(line k1, line k2) { return sign(cross(k1.dir(), k2.dir())) == 0; }\r\nbool sameDir(line k1, line k2) { return parallel(k1, k2) && sign(dot(k1.dir(), k2.dir())) == 1; }\r\nbool operator < (line k1, line k2) {\r\n\tif (sameDir(k1, k2)) return k2.include(k1[0]);\r\n\treturn compareangle(k1.dir(), k2.dir());\r\n}\r\npoint getLL(point k1, point k2, point k3, point k4) { // \u4e24\u76f4\u7ebf\u4ea4\u70b9\r\n\tdb w1 = cross(k1 - k3, k4 - k3), w2 = cross(k4 - k3, k2 - k3);\r\n\treturn (k1 * w2 + k2 * w1) / (w1 + w2);\r\n}\r\npoint getLL(line k1, line k2) { return getLL(k1[0], k1[1], k2[0], k2[1]); }\r\nbool checkpos(line k1, line k2, line k3) { return k3.include(getLL(k1, k2)); }\r\n\r\nint main() {\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\tint n; cin >> n;\r\n\tvector<point> p(n);\r\n\tvector<bool> vis(n, false);\r\n\tvector<int> ans;\r\n\tfor (int i = 0; i < n; ++i) cin >> p[i].x >> p[i].y, p[i].id = i;\r\n\tsort(p.begin(), p.end());\r\n\tans.emplace_back(p[0].id);\r\n\tvis[p[0].id] = true;\r\n\tstring s; cin >> s;\r\n\tsort(p.begin() + 1, p.end(), [&](point& i, point& j) {\r\n\t\treturn atan2(i.y - p[0].y, i.x - p[0].x) < atan2(j.y - p[0].y, j.x - p[0].x);\r\n\t});\r\n\t//for (int i = 0; i < n; ++i) cout << p[i].x << ' ' << p[i].y << ' ' << p[i].id << '\\n';\r\n\tpoint pre = p[0], now;\r\n\tif (s[0] == 'L') {\r\n\t\tans.emplace_back(p[1].id);\r\n\t\tvis[p[1].id] = true;\r\n\t\tnow = p[1];\r\n\t}\r\n\telse {\r\n\t\tans.emplace_back(p[n - 1].id);\r\n\t\tvis[p[n - 1].id] = true;\r\n\t\tnow = p[n - 1];\r\n\t}\r\n\tfor (int i = 1; i < s.length(); ++i) {\r\n\t\tif (s[i] == 'L') {\r\n\t\t\tif (s[i - 1] == 'R') {\r\n\t\t\t\tdb angle = 2.0 * pi + 1.0;\r\n\t\t\t\tint id;\r\n\t\t\t\tfor (int j = 1; j < n; ++j) {\r\n\t\t\t\t\tif (vis[p[j].id]) continue;\r\n\t\t\t\t\tdb ta = fabs(rad(pre - now, p[j] - now));\r\n\t\t\t\t\t//cout << i << ' ' << p[j].id + 1 << ' ' << ta << '\\n';\r\n\t\t\t\t\tif (ta < angle) {\r\n\t\t\t\t\t\tangle = ta;\r\n\t\t\t\t\t\tid = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tans.emplace_back(p[id].id);\r\n\t\t\t\tvis[p[id].id] = true;\r\n\t\t\t\tpre = now, now = p[id];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdb angle = 0.0;\r\n\t\t\t\tint id;\r\n\t\t\t\tfor (int j = 1; j < n; ++j) {\r\n\t\t\t\t\tif (vis[p[j].id]) continue;\r\n\t\t\t\t\tdb ta = fabs(rad(pre - now, p[j] - now));\r\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << ta << '\\n';\r\n\t\t\t\t\tif (ta > angle) {\r\n\t\t\t\t\t\tangle = ta;\r\n\t\t\t\t\t\tid = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tans.emplace_back(p[id].id);\r\n\t\t\t\tvis[p[id].id] = true;\r\n\t\t\t\tpre = now, now = p[id];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (s[i - 1] == 'L') {\r\n\t\t\t\tdb angle = 0.0;\r\n\t\t\t\tint id;\r\n\t\t\t\tfor (int j = 1; j < n; ++j) {\r\n\t\t\t\t\tif (vis[p[j].id]) continue;\r\n\t\t\t\t\tdb ta = fabs(rad(pre - now, p[j] - now));\r\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << ta << '\\n';\r\n\t\t\t\t\tif (ta > angle) {\r\n\t\t\t\t\t\tangle = ta;\r\n\t\t\t\t\t\tid = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tans.emplace_back(p[id].id);\r\n\t\t\t\tvis[p[id].id] = true;\r\n\t\t\t\tpre = now, now = p[id];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdb angle = 2.0 * pi + 1.0;\r\n\t\t\t\tint id;\r\n\t\t\t\tfor (int j = 1; j < n; ++j) {\r\n\t\t\t\t\tif (vis[p[j].id]) continue;\r\n\t\t\t\t\tdb ta = fabs(rad(pre - now, p[j] - now));\r\n\t\t\t\t\t//cout << i << ' ' << p[j].id + 1 << ' ' << ta << '\\n';\r\n\t\t\t\t\tif (ta < angle) {\r\n\t\t\t\t\t\tangle = ta;\r\n\t\t\t\t\t\tid = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tans.emplace_back(p[id].id);\r\n\t\t\t\tvis[p[id].id] = true;\r\n\t\t\t\tpre = now, now = p[id];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i < n; ++i) if (!vis[i]) ans.emplace_back(i);\r\n\tfor (auto i : ans) cout << i + 1 << ' ';\r\n\treturn 0;\r\n}"
}