{
    "id": 54041116,
    "contestId": 1158,
    "creationTimeSeconds": 1557676499,
    "relativeTimeSeconds": 4799,
    "problem": {
        "contestId": 1158,
        "index": "D",
        "name": "Winding polygonal line",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2600,
        "tags": [
            "constructive algorithms",
            "geometry",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1158,
        "members": [
            {
                "handle": "riadwaw"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 12,
        "startTimeSeconds": 1557671700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "PRETESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "/**\r\n * code generated by JHelper\r\n * More info: https://github.com/AlexeyDmitriev/JHelper\r\n * @author RiaD\r\n */\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n\r\n#include <iostream>\r\n#include <cassert>\r\n#include <vector>\r\n\r\n\r\n#include <iterator>\r\n\r\n\r\n#include <string>\r\n#include <stdexcept>\r\n\r\n#ifndef SPCPPL_ASSERT\r\n\t#ifdef SPCPPL_DEBUG\r\n\t\t#define SPCPPL_ASSERT(condition) \\\r\n\t\tif(!(condition)) { \\\r\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\r\n\t\t}\r\n\t#else\r\n\t\t#define SPCPPL_ASSERT(condition)\r\n\t#endif\r\n#endif\r\n\r\n\r\n/**\r\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\r\n* it's reference type is not a reference.\r\n*\r\n* It doesn't return reference because\r\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\r\n*   If a and b are both dereferenceable, then a == b if and only if *a and\r\n*   b are bound to the same object.\r\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\r\n*\r\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\r\n* but it's seems to work at least on my implementation.\r\n*\r\n* It's not really useful anywhere except iterating anyway.\r\n*/\r\ntemplate <typename T>\r\nclass IntegerIterator {\r\npublic:\r\n\tusing value_type = T;\r\n\tusing difference_type = std::ptrdiff_t;\r\n\tusing pointer = T*;\r\n\tusing reference = T;\r\n\tusing iterator_category = std::input_iterator_tag;\r\n\r\n\texplicit IntegerIterator(T value): value(value) {\r\n\r\n\t}\r\n\r\n\tIntegerIterator& operator++() {\r\n\t\t++value;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tIntegerIterator operator++(int) {\r\n\t\tIntegerIterator copy = *this;\r\n\t\t++value;\r\n\t\treturn copy;\r\n\t}\r\n\r\n\tIntegerIterator& operator--() {\r\n\t\t--value;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tIntegerIterator operator--(int) {\r\n\t\tIntegerIterator copy = *this;\r\n\t\t--value;\r\n\t\treturn copy;\r\n\t}\r\n\r\n\tT operator*() const {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tbool operator==(IntegerIterator rhs) const {\r\n\t\treturn value == rhs.value;\r\n\t}\r\n\r\n\tbool operator!=(IntegerIterator rhs) const {\r\n\t\treturn !(*this == rhs);\r\n\t}\r\n\r\nprivate:\r\n\tT value;\r\n};\r\n\r\ntemplate <typename T>\r\nclass IntegerRange {\r\npublic:\r\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\r\n\t\tSPCPPL_ASSERT(begin <= end);\r\n\t}\r\n\r\n\tIntegerIterator<T> begin() const {\r\n\t\treturn IntegerIterator<T>(begin_);\r\n\t}\r\n\r\n\tIntegerIterator<T> end() const {\r\n\t\treturn IntegerIterator<T>(end_);\r\n\t}\r\n\r\nprivate:\r\n\tT begin_;\r\n\tT end_;\r\n};\r\n\r\ntemplate <typename T>\r\nclass ReversedIntegerRange {\r\n\tusing IteratorType = std::reverse_iterator<IntegerIterator<T>>;\r\npublic:\r\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\r\n\t\tSPCPPL_ASSERT(begin >= end);\r\n\t}\r\n\r\n\tIteratorType begin() const {\r\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\r\n\t}\r\n\r\n\tIteratorType end() const {\r\n\t\treturn IteratorType(IntegerIterator<T>(end_));\r\n\t}\r\n\r\nprivate:\r\n\tT begin_;\r\n\tT end_;\r\n};\r\n\r\ntemplate <typename T>\r\nIntegerRange<T> range(T to) {\r\n\treturn IntegerRange<T>(0, to);\r\n}\r\n\r\ntemplate <typename T>\r\nIntegerRange<T> range(T from, T to) {\r\n\treturn IntegerRange<T>(from, to);\r\n}\r\n\r\ntemplate <typename T>\r\nIntegerRange<T> inclusiveRange(T to) {\r\n\treturn IntegerRange<T>(0, to + 1);\r\n}\r\n\r\ntemplate <typename T>\r\nIntegerRange<T> inclusiveRange(T from, T to) {\r\n\treturn IntegerRange<T>(from, to + 1);\r\n}\r\n\r\ntemplate <typename T>\r\nReversedIntegerRange<T> downrange(T from) {\r\n\treturn ReversedIntegerRange<T>(from, 0);\r\n}\r\n\r\ntemplate <typename T>\r\nReversedIntegerRange<T> downrange(T from, T to) {\r\n\treturn ReversedIntegerRange<T>(from, to);\r\n}\r\n\r\ntemplate <typename T>\r\nReversedIntegerRange<T> inclusiveDownrange(T from) {\r\n\treturn ReversedIntegerRange<T>(from + 1, 0);\r\n}\r\n\r\ntemplate <typename T>\r\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\r\n\treturn ReversedIntegerRange<T>(from + 1, to);\r\n}\r\n\r\n\r\n\r\n#include <cmath>\r\n#include <tuple>\r\n\r\n\r\n\r\ntemplate <typename T, typename SquareT = T>\r\nstruct Point2D {\r\n\tT x, y;\r\n\r\n\tPoint2D(): x(0), y(0) {\r\n\t}\r\n\r\n\tPoint2D(T x, T y): x(x), y(y) {\r\n\t}\r\n\r\n\tSquareT squaredDist() const {\r\n\t\treturn static_cast<SquareT>(x) * x + static_cast<SquareT>(y) * y;\r\n\t}\r\n\r\n\tauto dist() const -> decltype(sqrt(this->squaredDist())) {\r\n\t\treturn sqrt(squaredDist());\r\n\t}\r\n\r\n\tdouble angle() const {\r\n\t\treturn atan2(y, x);\r\n\t}\r\n\r\n\tPoint2D& operator-=(const Point2D& rhs) {\r\n\t\tx -= rhs.x;\r\n\t\ty -= rhs.y;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPoint2D& operator+=(const Point2D& rhs) {\r\n\t\tx += rhs.x;\r\n\t\ty += rhs.y;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPoint2D& operator*=(T rhs) {\r\n\t\tx *= rhs;\r\n\t\ty *= rhs;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tPoint2D& operator/=(T rhs) {\r\n\t\tx /= rhs;\r\n\t\ty /= rhs;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tT& operator[](std::size_t i) {\r\n\t\tif (i == 0) {\r\n\t\t\treturn x;\r\n\t\t}\r\n\t\tif (i == 1) {\r\n\t\t\treturn y;\r\n\t\t}\r\n\t\tSPCPPL_ASSERT(false);\r\n\t}\r\n\r\n\tconst T& operator[](std::size_t i) const {\r\n\t\tif (i == 0) {\r\n\t\t\treturn x;\r\n\t\t}\r\n\t\tif (i == 1) {\r\n\t\t\treturn y;\r\n\t\t}\r\n\t\tSPCPPL_ASSERT(false);\r\n\t}\r\n\r\n\ttemplate <typename U, typename V = U>\r\n\tPoint2D<U, V> as() {\r\n\t\treturn {U(x), U(y)};\r\n\t}\r\n\r\n\tPoint2D normalized() const {\r\n\t\tstatic_assert(std::is_floating_point<T>::value, \"only implemented for floating point types\");\r\n\t\treturn *this / dist();\r\n\t}\r\n\r\n\tPoint2D rotated(double angle) const {\r\n\t\tstatic_assert(std::is_floating_point<T>::value, \"only implemented for floating point types\");\r\n\t\tdouble co = cos(angle);\r\n\t\tdouble si = sin(angle);\r\n\t\treturn Point2D(x * co - y * si, x * si + y * co);\r\n\t}\r\n};\r\n\r\ntemplate <typename T, typename S>\r\nPoint2D<T, S> operator+(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) {\r\n\treturn Point2D<T, S>(lhs.x + rhs.x, lhs.y + rhs.y);\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nPoint2D<T, S> operator-(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) {\r\n\treturn Point2D<T, S>(lhs.x - rhs.x, lhs.y - rhs.y);\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nPoint2D<T, S> operator*(const Point2D<T, S>& lhs, T rhs) {\r\n\treturn Point2D<T, S>(lhs.x * rhs, lhs.y * rhs);\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nPoint2D<T, S> operator*(T lhs, const Point2D<T, S>& rhs) {\r\n\treturn Point2D<T, S>(lhs * rhs.x, lhs * rhs.y);\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nPoint2D<T, S> operator/(const Point2D<T, S>& lhs, T rhs) {\r\n\treturn Point2D<T, S>(lhs.x / rhs, lhs.y / rhs);\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nS operator*(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) {\r\n\treturn static_cast<S>(lhs.x) * rhs.y - static_cast<S>(rhs.x) * lhs.y;\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nS operator%(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) {\r\n\treturn static_cast<S>(lhs.x) * rhs.x + static_cast<S>(lhs.y) * rhs.y;\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nbool operator==(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) {\r\n\treturn lhs.x == rhs.x && lhs.y == rhs.y;\r\n}\r\n\r\ntemplate <typename T, typename S>\r\nbool operator!=(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) {\r\n\treturn !(lhs == rhs);\r\n}\r\n\r\nstruct LexicograficallyLess {\r\n\ttemplate <typename T, typename S>\r\n\tbool operator()(const Point2D<T, S>& lhs, const Point2D<T, S>& rhs) const {\r\n\t\treturn std::tie(lhs.x, lhs.y) < std::tie(rhs.x, rhs.y);\r\n\t};\r\n};\r\n\r\ntemplate <typename T, typename S = T>\r\nstruct LessByAngle {\r\n\texplicit LessByAngle(const Point2D<T>& center): center(center) {\r\n\t}\r\n\r\n\tbool operator() (Point2D<T, S> lhs, Point2D<T, S> rhs) {\r\n\t\tlhs -= center;\r\n\t\trhs -= center;\r\n\t\tif (upper(lhs) != upper(rhs)) {\r\n\t\t\treturn upper(rhs);\r\n\t\t}\r\n\t\treturn lhs * rhs > 0;\r\n\t}\r\nprivate:\r\n\tbool upper(const Point2D<T>& point) {\r\n\t\treturn point.y > 0 || (point.y == 0 && point.x > 0);\r\n\t}\r\n\tPoint2D<T, S> center;\r\n};\r\n\r\ntemplate <typename T, typename S>\r\ndouble distance_to_segment(const Point2D<T, S>& point, const Point2D<T, S>& b, const Point2D<T, S>& c) {\r\n\tstatic_assert(std::is_floating_point<T>::value, \"only implemented for floating point types\");\r\n\tauto ba = b - point;\r\n\tauto ca = c - point;\r\n\tif ((ba - ca) % ba >= 0 && (ca - ba) % ca >= 0) {\r\n\t\treturn fabs(ba * ca) / (ca - ba).dist();\r\n\t}\r\n\treturn std::min(ba.dist(), ca.dist());\r\n};\r\n\r\ntemplate <typename T, typename S>\r\ndouble distance_to_line(const Point2D<T, S>& point, const Point2D<T, S>& b, const Point2D<T, S>& c) {\r\n\tstatic_assert(std::is_floating_point<T>::value, \"only implemented for floating point types\");\r\n\tauto ba = b - point;\r\n\tauto ca = c - point;\r\n\treturn fabs(ba * ca) / (ca - ba).dist();\r\n};\r\n\r\n//#define PROBLEM \"problem_name.h\"\r\n//#include PROBLEM\r\n//#include <message.h>\r\n//#include <spcppl/dgcj.h>\r\n\r\nusing namespace std;\r\n\r\nclass TaskD {\r\npublic:\r\n\tstatic constexpr int kStressCount = 0;\r\n\tstatic void generateTest(std::ostream& test) {\r\n\t}\r\n\tvoid solve(std::istream& in, std::ostream& out) {\r\n\t\t//static int testnumber = 0;\r\n\t\t//out << \"Case #\" << ++testnumber << \": \";\r\n\r\n\t\tint n;\r\n\t\tin >> n;\r\n\t\tusing P = Point2D<int64_t>;\r\n\r\n\r\n\t\tvector<P> points(n);\r\n\r\n\t\tfor (int i: range(n)) {\r\n\t\t\tin >> points[i].x >> points[i].y;\r\n\t\t}\r\n\r\n\t\tvector<int> indices(n);\r\n\t\tfor (int i: range(n)) {\r\n\t\t\tindices[i] = i;\r\n\t\t}\r\n\r\n\t\tsort(indices.begin(), indices.end(), [&](int l, int r) {\r\n\t\t\treturn make_pair(points[l].x, points[l].y) < make_pair(points[r].x, points[r].y);\r\n\t\t});\r\n\r\n\t\t//P current(1, 0);\r\n\t\tP current_point = points[indices[0]];\r\n\r\n\t\tout << indices[0] + 1;\r\n\r\n\t\tstring s;\r\n\t\tin >> s;\r\n\t\ts = \"L\" + s + \"L\";\r\n\r\n\t\tfor (int i = 1; i < n; ++i) {\r\n\t\t\tsort(indices.begin() + i, indices.end(), [&](int l, int r) {\r\n\t\t\t\treturn (points[l] - current_point) * (points[r] - current_point) > 0;\r\n\t\t\t});\r\n\t\t\tif (s[i] == 'R') {\r\n\t\t\t\treverse(indices.begin() + i, indices.end());\r\n\t\t\t}\r\n\r\n\t\t\tout << \" \" << indices[i] + 1;\r\n\r\n\r\n\t\t\t//for (int t: range(n)) {\r\n\t\t\t//\tcerr << indices[t] << ' ';\r\n\t\t\t//}\r\n\t\t\t//cerr << endl;\r\n\t\t\t//current = points[indices[i]] - current_point;\r\n\t\t\tcurrent_point = points[indices[i]];\r\n\t\t}\r\n \t}\r\n};\r\n\r\n\r\nint main() {\r\n\tstd::ios_base::sync_with_stdio(false);\r\n\tTaskD solver;\r\n\tstd::istream& in(std::cin);\r\n\tstd::ostream& out(std::cout);\r\n\tin.tie(nullptr);\r\n\tout << std::fixed;\r\n\tout.precision(20);\r\n\tsolver.solve(in, out);\r\n\treturn 0;\r\n}\r\n"
}