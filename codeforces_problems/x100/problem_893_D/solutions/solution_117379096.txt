{
    "id": 117379096,
    "contestId": 893,
    "creationTimeSeconds": 1622012279,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 893,
        "index": "D",
        "name": "Credit Card",
        "type": "PROGRAMMING",
        "rating": 1900,
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "implementation"
        ]
    },
    "author": {
        "contestId": 893,
        "members": [
            {
                "handle": "rainier_1"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1511449500
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 79,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 7987200,
    "source": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int MOD = 1e9+7; \r\n// const int MOD = 998244353;\r\n\r\n#pragma region\r\n\r\n\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing db = long double; \r\nusing str = string; \r\n \r\nusing pi = pair<int,int>;\r\nusing pl = pair<ll,ll>;\r\nusing pd = pair<double,double>;\r\n \r\nusing vi = vector<int>;\r\nusing vb = vector<bool>;\r\nusing vl = vector<ll>;\r\nusing vd = vector<double>; \r\nusing vs = vector<string>;\r\nusing vpi = vector<pi>;\r\nusing vpl = vector<pl>; \r\nusing vpd = vector<pd>;\r\n\r\n#define tcT template<class T\r\n#define tcTUU tcT, class ...U\r\n#define tcTU tcT, class U\r\n\r\n#define eb emplace_back \r\n#define mp make_pair\r\n#define ts to_string\r\n#define rsz resize \r\n#define ins insert \r\n#define all(x) (x).begin(), (x).end()\r\n#define sz(v) ((int)(v).size())\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define pb push_back \r\n#define lb lower_bound \r\n#define ub upper_bound \r\n#define fe first\r\n#define se second\r\n#define bs binary_search\r\n#define bk back()\r\n#define pob pop_back()\r\n#define sor(x) sort(all(x))\r\n\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define trav(a,x) for (auto& a: x)\r\n#define rep(a) F0R(_,a)\r\n\r\ntemplate<typename A, typename B>\r\npair<A, B>& operator++(pair<A, B>& a){++a.se;++a.fe;return a;}\r\ntemplate<typename A, typename B>\r\npair<A, B>& operator--(pair<A, B>& a){--a.fe;--a.se;return a;}\r\ntemplate<typename A>\r\nvector<A>& operator++(vector<A>& a){for (auto it = a.begin(); it != a.end(); ++it)\t++* it;return a;}\r\ntemplate<typename A>\r\nvector<A>& operator--(vector<A>& a){for (auto it = a.begin(); it != a.end(); ++it)--* it;return a;}\r\n\r\n//U,R,D,L\r\nconst int di[4]={-1, 0, 1, 0}, dj[4]={0, 1, 0, -1};\r\nconst int di8[8]={-1, -1, 0, 1, 1, 1, 0, -1}, dj8[8]={0, 1, 1, 1, 0, -1, -1, -1};\r\nconst ld PI = acos((ld)-1);\r\nconst ll INF = 1e18;\r\nconst double eps=1e-11;//NOTES:eps\r\n\r\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nll randint(ll a, ll b) { return uniform_int_distribution<ll>(a, b)(rng);}\r\n\r\nusing ul = unsigned long long;\r\nul modMul(ul a, ul b, const ul mod) {ll ret = a*b-mod*(ul)((ld)a*b/mod);return ret+((ret<0)-(ret>=(ll)mod))*mod; }\r\nul modPow(ul a, ul b, const ul mod) {if (b == 0) return 1;ul res = modPow(a,b/2,mod); res = modMul(res,res,mod);return b&1 ? modMul(res,a,mod) : res;}\r\n//bool prime(ul n) { if (n < 2 || n % 6 % 4 != 1) return n-2 < 2;ul A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},s = __builtin_ctzll(n-1), d = n>>s;trav(a,A) {   ul p = modPow(a,d,n), i = s;while (p != 1 && p != n-1 && a%n && i--) p = modMul(p,p,n);if (p != n-1 && i != s) return 0;}return 1;}\r\nbool pow2(int i){ return i&&(i&-i)==i;}\r\nconstexpr int pct(int x) { return __builtin_popcount(x); } \r\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x))\r\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\r\nll half(ll x) { return fdiv(x,2); }\r\nbool inc(ll a,ll b,ll c){return a<=b&&b<=c;}\r\ntemplate<class t>\r\nint lwb(const vector<t>&v,const t&a){\r\n\treturn lower_bound(all(v),a)-v.begin();\r\n}\r\n\r\n#define tol(s) transform(s.begin(),s.end(),s.begin(),::tolower);\r\n#define tou(s) transform(s.begin(),s.end(),s.begin(),::toupper);\r\n\r\ntcT> bool chmin(T& a, const T& b) {\r\n\treturn b < a ? a = b, 1 : 0; } \r\ntcT> bool chmax(T& a, const T& b) {\r\n\treturn a < b ? a = b, 1 : 0; }\r\nvoid TIME(){\r\n\t#ifdef __APPLE__\r\n\t    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\r\n\t#endif\r\n}\r\n\r\ntcT> void remDup(vector<T>& v) { \r\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\r\ntcTU> void remAll(vector<T>& v, U a){\r\n\tv.erase(remove(all(v),a),v.end());\r\n}\r\n\r\ntcTU> T fstTrue(T lo, T hi, U f) {  //smallest\r\n\twhile (lo < hi) {\r\n\t\tT mid = half(lo+hi);\r\n\t\tf(mid) ? hi = mid : lo = mid+1; \r\n\t} \r\n\treturn lo;\r\n}\r\ntcTU> T lstTrue(T lo, T hi, U f) { //largest\r\n\twhile (lo < hi) { \r\n\t\tT mid = half(lo+hi+1);\r\n\t\tf(mid) ? lo = mid : hi = mid-1;\r\n\t} \r\n\treturn lo;\r\n}\r\n\r\ntemplate <typename I> struct _reversed_struct { I &v_; explicit _reversed_struct(I &v) : v_{v} {} typename I::reverse_iterator begin() const { return v_.rbegin(); } typename I::reverse_iterator end() const { return v_.rend(); } };\r\ntemplate <typename I> _reversed_struct<I> reversed(I &v) { return _reversed_struct<I>(v); }\r\n// TO_STRING\r\nstring ts(char c) { return string(1,c); }\r\nstring ts(bool b) { \r\n    #ifdef __APPLE__\r\n\t\treturn b ? \"true\" : \"false\"; \r\n\t#else \r\n\t\treturn ts((int)b);\r\n\t#endif\r\n}\r\nstring ts(const char* s) { return (string)s; }\r\nstring ts(string s) { return s; }\r\ntcT> string ts(complex<T> c) { \r\n\tstringstream ss; ss << c; return ss.str(); }\r\nstring ts(vb v) { \r\n\tstring res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\r\n\tres += \"}\"; return res; }\r\ntemplate<size_t SZ> string ts(bitset<SZ> b) {\r\n\tstring res = \"\"; F0R(i,sz(b)) res += char('0'+b[i]);\r\n\treturn res; }\r\ntcTU> string ts(pair<T,U> p);\r\ntcT> string ts(T v) { // containers with begin(), end()\r\n\t#ifdef __APPLE__\r\n\t\tbool fst = 1; string res = \"{\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \", \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\tres += \"}\"; return res;\r\n\t#else\r\n\t\tbool fst = 1; string res = \"\";\r\n\t\tfor (const auto& x: v) {\r\n\t\t\tif (!fst) res += \" \";\r\n\t\t\tfst = 0; res += ts(x);\r\n\t\t}\r\n\t\treturn res;\r\n\t#endif\r\n}\r\ntcTU> string ts(pair<T,U> p) {\r\n\t#ifdef __APPLE__\r\n\t\treturn \"(\"+ts(p.fe)+\", \"+ts(p.se)+\")\"; \r\n\t#else\r\n\t\treturn ts(p.fe)+\" \"+ts(p.se);\r\n\t#endif\r\n}\r\n\r\n//INPUT  void re(string& d){getline(cin,d) ;getline(cin,d); }\r\n\r\ntcT> void re(complex<T>& c);\r\ntcTU> void re(pair<T,U>& p);\r\ntcT> void re(vector<T>& v);\r\ntcT> void rv(int n, vector<T>& x) { x.rsz(n); re(x); }\r\n\r\ntcT, size_t SZ> void re(array<T,SZ>& a);\r\ntcT> void re(T& x) { cin >> x; }\r\nvoid re(double& d) { string t; re(t); d = stod(t); }\r\nvoid re(ld& d) { string t; re(t); d = stold(t); }\r\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\r\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\r\ntcTU> void re(pair<T,U>& p) { re(p.fe,p.se); }\r\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\r\ntcT, size_t SZ> void re(array<T,SZ>& x) { trav(a,x) re(a); }\r\n// OUTPUT\r\ntcT> void pr(T x) { cout << ts(x); }\r\ntcTUU> void pr(const T& t, const U&... u) { \r\n\tpr(t); pr(u...); }\r\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\r\ntcTUU> void ps(const T& t, const U&... u) { \r\n\tpr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\r\n\r\nstruct chash { // Credits: https://codeforces.com/blog/entry/62393\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n    template<typename L, typename R>\r\n    size_t operator()(pair<L,R> const& Y) const{\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(Y.first * 31 + Y.second + FIXED_RANDOM);\r\n    }\r\n};\r\ntcT> using V = vector<T>; \r\ntcT, size_t SZ> using AR = array<T,SZ>; \r\ntcT> using mpq = priority_queue<T, vector<T>, greater<T>>;\r\ntcT> using pq = priority_queue<T>;\r\ntcT> using ms = multiset<T>;\r\ntcTU> using um = unordered_map<T,U,chash>;\r\ntcT> using us = unordered_set<T, chash>;\r\ntcT> using PR = pair<T,T>;\r\n#define one(x) memset(x,-1,sizeof(x))\r\n#define zero(x) memset(x,0,sizeof(x))\r\n#define MAX(x) memset(x,0x3f,sizeof(x))\r\n#define MIN(x) memset(x,0xc0,sizeof(x))\r\n\r\n\r\n\r\n\r\ntemplate<int MOD, int RT> struct mint {\r\n\tstatic const int mod = MOD;\r\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\r\n\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int\r\n\tmint() { v = 0; }\r\n\tmint(ll _v) { v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\r\n\t\tif (v < 0) v += MOD; }\r\n\tfriend bool operator==(const mint& a, const mint& b) { \r\n\t\treturn a.v == b.v; }\r\n\tfriend bool operator!=(const mint& a, const mint& b) { \r\n\t\treturn !(a == b); }\r\n\tfriend bool operator<(const mint& a, const mint& b) { \r\n\t\treturn a.v < b.v; }\r\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\r\n\tfriend string ts(mint a) { return ts(a.v); }\r\n   \r\n\tmint& operator+=(const mint& m) { \r\n\t\tif ((v += m.v) >= MOD) v -= MOD; \r\n\t\treturn *this; }\r\n\tmint& operator-=(const mint& m) { \r\n\t\tif ((v -= m.v) < 0) v += MOD; \r\n\t\treturn *this; }\r\n\tmint& operator*=(const mint& m) { \r\n\t\tv = (ll)v*m.v%MOD; return *this; }\r\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\r\n\tfriend mint pow(mint a, ll p) {\r\n\t\tmint ans = 1; assert(p >= 0);\r\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\r\n\t\treturn ans; }\r\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \r\n\t\treturn pow(a,MOD-2); }\r\n\t\t\r\n\tmint operator-() const { return mint(-v); }\r\n\tmint& operator++() { return *this += 1; }\r\n\tmint& operator--() { return *this -= 1; }\r\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\r\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\r\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\r\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\r\n};\r\n \r\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\r\ntypedef vector<mi> vmi;\r\ntypedef pair<mi,mi> pmi;\r\ntypedef vector<pmi> vpmi;\r\n \r\nvi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...\r\nvoid genFac(int SZ) {\r\n\tinvs.resize(SZ), fac.resize(SZ), ifac.resize(SZ); \r\n\tinvs[1] = fac[0] = ifac[0] = 1; \r\n\tFOR(i,2,SZ) invs[i] = MOD-(ll)MOD/i*invs[MOD%i]%MOD;\r\n\tFOR(i,1,SZ) {\r\n\t\tfac[i] = (ll)fac[i-1]*i%MOD;\r\n\t\tifac[i] = (ll)ifac[i-1]*invs[i]%MOD;\r\n\t}\r\n}\r\nmi comb(int a, int b) {\r\n\tif (a < b || b < 0) return 0;\r\n\treturn (ll)fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;\r\n} \r\n\r\nll gcd(ll a,ll b) {  return b?gcd(b,a%b):a;}\r\nll lcm(ll a,ll b) {  return (a / gcd(a, b)) * b;}\r\nll ncr(ll a, ll b){ if(a<b) return 0; ll f = 1; FOR(i,1,b+1){ f*=(a+1-i); f/=i; } return f;}\r\n// DEBUG\r\nvoid DBG() { cerr << \"]\" << endl; }\r\ntcTUU> void DBG(const T& t, const U&... u) {\r\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\r\n\tDBG(u...); }\r\n#ifdef __APPLE__ // chk -> fake assert\r\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\r\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\r\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\r\n#else\r\n\t#define dbg(...) 0\r\n\t#define chk(...) 0\r\n#endif\r\n \r\n\r\n\r\n\r\n\r\n\r\nvoid setPrec() { cout << fixed << setprecision(15); }\r\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\r\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\r\nvoid setIO(str s = \"\") {\r\n\tunsyncIO(); setPrec();\r\n\t// cin.exceptions(cin.failbit); \r\n\t// throws exception when do smth illegal\r\n\t// ex. try to read letter into int\r\n\tif (sz(s)) { setIn(s+\".in\");setOut(s+\".out\"); } // for USACO\r\n}\r\n#pragma endregion\r\n\r\n#pragma region\r\n\r\n\r\n\r\nV<vi> reg(int n,int m){\r\n\tV<vi>g(n);\r\n\tF0R(i,m){\r\n\t\tint a,b;\r\n\t\tre(a,b);\r\n\t\ta--;b--;\r\n\t\tg[a].pb(b);\r\n\t\tg[b].pb(a);\r\n\t}\r\n\treturn g;\r\n}\r\nV<vpl> rew(int n,int m){\r\n\tV<vpl>g(n);\r\n\tF0R(i,m){\r\n\t\tll a,b,w;\r\n\t\tre(a,b,w);\r\n\t\ta--;b--;\r\n\t\tg[a].eb(b,w);\r\n\t\tg[b].eb(a,w);\r\n\t}\r\n\treturn g;\r\n}\r\n#pragma endregion\r\n\r\n\r\n// Dont waste time during a contest, keep trying to\r\n// solve that problem !\r\n\r\n// Spend all of the time trying to solve that problem :)\r\n\r\n#define ff dbg(\"RANDOM IM HERE\")\r\n\r\nconst int N = 1e5 + 5;\r\n\r\n\r\n\r\nll b[N];\r\ntemplate <typename num_t> \r\nstruct segtree {\r\n  int n, depth;\r\n  vector<num_t> tree, lazy;\r\n\r\n  void init(int s, long long* arr) {\r\n    n = s;\r\n    tree = vector<num_t>(4 * s, 0);\r\n    lazy = vector<num_t>(4 * s, 0);\r\n    init(0, 0, n - 1, arr);\r\n  }\r\n\r\n  num_t init(int i, int l, int r, long long* arr) {\r\n    if (l == r) return tree[i] = arr[l];\r\n\r\n    int mid = (l + r) / 2;\r\n    num_t a = init(2 * i + 1, l, mid, arr),\r\n          b = init(2 * i + 2, mid + 1, r, arr);\r\n    return tree[i] = a.op(b);\r\n  }\r\n\r\n  void update(int l, int r, num_t v) {\r\n\tif (l > r) return;\r\n    update(0, 0, n - 1, l, r, v);\r\n  }\r\n\r\n  num_t update(int i, int tl, int tr, int ql, int qr, num_t v) {\r\n    eval_lazy(i, tl, tr);\r\n\t\r\n\tif (tr < ql || qr < tl) return tree[i];\r\n    if (ql <= tl && tr <= qr) {\r\n      lazy[i] = lazy[i].val + v.val;\r\n      eval_lazy(i, tl, tr);\r\n      return tree[i];\r\n    }\r\n    \r\n    int mid = (tl + tr) / 2;\r\n    num_t a = update(2 * i + 1, tl, mid, ql, qr, v),\r\n          b = update(2 * i + 2, mid + 1, tr, ql, qr, v);\r\n    return tree[i] = a.op(b);\r\n  }\r\n\r\n  num_t query(int l, int r) {\r\n\tif (l > r) return num_t::null_v;\r\n    return query(0, 0, n-1, l, r);\r\n  }\r\n\r\n  num_t query(int i, int tl, int tr, int ql, int qr) {\r\n    eval_lazy(i, tl, tr);\r\n    \r\n    if (ql <= tl && tr <= qr) return tree[i];\r\n    if (tr < ql || qr < tl) return num_t::null_v;\r\n\r\n    int mid = (tl + tr) / 2;\r\n    num_t a = query(2 * i + 1, tl, mid, ql, qr),\r\n          b = query(2 * i + 2, mid + 1, tr, ql, qr);\r\n    return a.op(b);\r\n  }\r\n\r\n  void eval_lazy(int i, int l, int r) {\r\n    tree[i] = tree[i].lazy_op(lazy[i], (r - l + 1));\r\n    if (l != r) {\r\n      lazy[i * 2 + 1] = lazy[i].val + lazy[i * 2 + 1].val;\r\n      lazy[i * 2 + 2] = lazy[i].val + lazy[i * 2 + 2].val;\r\n    }\r\n\r\n    lazy[i] = num_t();\r\n  }\r\n};\r\n\r\nstruct max_t {\r\n  long long val;\r\n  static const long long null_v = -9223372036854775807LL;\r\n\r\n  max_t(): val(0) {}\r\n  max_t(long long v): val(v) {}\r\n\r\n  max_t op(max_t& other) {\r\n    return max_t(max(val, other.val));\r\n  }\r\n  \r\n  max_t lazy_op(max_t& v, int size) {\r\n    return max_t(val + v.val);\r\n  }\r\n};\r\nvoid f(){\r\n    ps(-1);\r\n    exit(0);\r\n}\r\nsegtree<max_t>mx;\r\n\r\nvoid solve(int tc){\r\n    zero(b);\r\n\r\n    ll n,d,s=0,x=0;\r\n    re(n,d);\r\n    mx.init(n,b);\r\n    vl a(n),v;\r\n    re(a);\r\n    ll p=0;\r\n    F0R(i,n){\r\n        p+=a[i];\r\n        mx.update(i,i,p);\r\n    }\r\n    F0R(i,n){\r\n        s+=a[i];\r\n        if(s>d) f();\r\n        if(!a[i]&&s<0){\r\n            ++x;\r\n            ll v=0;\r\n            if(i<n-1) v=min(d,d-mx.query(i+1,n-1).val);\r\n            if(v<0) f();\r\n            s=v;\r\n        }\r\n        if(i<n-1) mx.update(i+1,n-1,-a[i]);\r\n    }\r\n    ps(x);\r\n    \r\n}\r\nint main() {\r\n\tsetIO(); \r\n\tint T = 1; // re(T);\r\n\tFOR(_,1,T+1) solve(_);\r\n}"
}