{
    "id": 149470831,
    "contestId": 1519,
    "creationTimeSeconds": 1647127758,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1519,
        "index": "A",
        "name": "Red and Blue Beans",
        "type": "PROGRAMMING",
        "rating": 800,
        "tags": [
            "math"
        ]
    },
    "author": {
        "contestId": 1519,
        "members": [
            {
                "handle": "CTRLPLUSC"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1619706900
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n/*                               ,        ,\n                                /(        )`\n                                \\ \\___   / |\n                                /- _  `-/  '\n                               (/\\/ \\ \\   /\\\n                               / /   | `    \\\n                               O O   ) /    |\n                               `-^--'`<     '\n                   TM         (_.)  _  )   /\n|  | |\\  | ~|~ \\ /             `.___/`    /\n|  | | \\ |  |   X                `-----' /\n`__| |  \\| _|_ / \\  <----.     __ / __   \\\n                    <----|====O)))==) \\) /====\n                    <----'    `--' `.__,' \\\n                                 |        |\n                                  \\       /\n                             ______( (_  / \\______\n                           ,'  ,-----'   |        \\\n                           `--{__________)        \\/\n\n\n*/\n\n#define all(x) begin(x),end(x)\n#define rall(x) rbegin(x),rend(x)\n#define bg(x) begin(x);\n#define sz(x) int(x.size())\n#define FAST ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define db double\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_boud\n#define pb push_back\n\ntemplate<class T, class U>\nusing PR  = pair<T,U>;\n\ntemplate<class T> \nusing V = vector<T>;\n\ntemplate<class T>\ninline int lwb(V<T>& a, const T& b){ return (int) lb(all(a), b) - bg(a); }\ntemplate<class T>\ninline int upb(V<T>& a, const T& b){ return (int) ub(all(a), b) - bg(a); }\n\ntemplate<class T>\ninline long long cdiv(const T& a, const T& b){ return a/b+((a^b)>0&&a%b);}\ntemplate<class T>\ninline long long fdiv(const T& a, const T& b){ return a/b-((a^b)<0&&a%b);}\n\ntemplate<class... T> auto add(T ...args){ return (... + args);}\n\nconst long long INF = 1e12 + 10;\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::vector<T>& vec) {\n    if (vec.empty()) {\n        out << \"[]\";\n        return out;\n    }\n    out << '[';\n    for (int i = 0; i < vec.size() - 1; i++) {\n        out << vec[i] << \", \";\n    }\n    return out << vec.back() << ']';\n}\n\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& out, const std::pair<T1, T2>& pair) {\n    return out << '(' << pair.first << \", \" << pair.second << ')';\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::deque<T>& deq) {\n    if (deq.empty()) {\n        out << \"[]\";\n        return out;\n    }\n    out << '[';\n    for (int i = 0; i < deq.size() - 1; i++) {\n        out << deq[i] << \", \";\n    }\n    return out << deq.back() << ']';\n}\n\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& out, const std::unordered_map<T1, T2>& map) {\n    out << '{';\n    for (auto it = map.begin(); it != map.end(); it++) {\n        std::pair<T1, T2> element = *it;\n        out << element.first << \": \" << element.second;\n        if (std::next(it) != map.end()) {\n            out << \", \";   \n        }\n    }\n    return out << '}';\n}\n\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& out, const std::map<T1, T2>& map) {\n    out << '{';\n    for (auto it = map.begin(); it != map.end(); it++) {\n        std::pair<T1, T2> element = *it;\n        out << element.first << \": \" << element.second;\n        if (std::next(it) != map.end()) {\n            out << \", \";   \n        }\n    }\n    return out << '}';\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::unordered_set<T>& set) {\n    out << '{';\n    for (auto it = set.begin(); it != set.end(); it++) {\n        T element = *it;\n        out << element;\n        if (std::next(it) != set.end()) {\n            out << \", \";   \n        }\n    }\n    return out << '}';\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::multiset<T>& set) {\n    out << '{';\n    for (auto it = set.begin(); it != set.end(); it++) {\n        T element = *it;\n        out << element;\n        if (std::next(it) != set.end()) {\n            out << \", \";   \n        }\n    }\n    return out << '}';\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::unordered_multiset<T>& set) {\n    out << '{';\n    for (auto it = set.begin(); it != set.end(); it++) {\n        T element = *it;\n        out << element;\n        if (std::next(it) != set.end()) {\n            out << \", \";   \n        }\n    }\n    return out << '}';\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::set<T>& set) {\n    out << '{';\n    for (auto it = set.begin(); it != set.end(); it++) {\n        T element = *it;\n        out << element;\n        if (std::next(it) != set.end()) {\n            out << \", \";   \n        }\n    }\n    return out << '}';\n}\n\n// Source: https://stackoverflow.com/a/31116392/12128483\ntemplate<typename Type, unsigned N, unsigned Last>\nstruct TuplePrinter {\n    static void print(std::ostream& out, const Type& value) {\n        out << std::get<N>(value) << \", \";\n        TuplePrinter<Type, N + 1, Last>::print(out, value);\n    }\n};\n\ntemplate<typename Type, unsigned N>\nstruct TuplePrinter<Type, N, N> {\n    static void print(std::ostream& out, const Type& value) {\n        out << std::get<N>(value);\n    }\n};\n\ntemplate<typename... Types>\nstd::ostream& operator<<(std::ostream& out, const std::tuple<Types...>& value) {\n    out << '(';\n    TuplePrinter<std::tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value);\n    return out << ')';\n}\n\n\nvoid solve(){\n    long long a,b,c;\n    cin >> a >> b >> c;\n    if(a > b)std::swap(a,b);\n    int queo = b/(c+1);\n    int rem = b%(c+1);\n    a -= queo;\n    if((rem!=0 && a > 0 && abs(a-rem) <= c) || (rem == 0 && a == 0)){\n\t\tcout<<\"YES\"<<endl;\n\t}\n\telse cout<<\"NO\"<<endl;\n}\n\nint main(){\n    FAST;\n    int T;\n    cin >> T;\n    while(T--)\n        solve();\n    return 0;\n}\n\n//NEVER GIVE UPPPPPP.\n"
}