{
    "id": 86946541,
    "contestId": 1307,
    "creationTimeSeconds": 1594852510,
    "relativeTimeSeconds": 7810,
    "problem": {
        "contestId": 1307,
        "index": "G",
        "name": "Cow and Exercise",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3100,
        "tags": [
            "flows",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1307,
        "members": [
            {
                "handle": "victoragnez"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1594844700
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 124,
    "memoryConsumedBytes": 4505600,
    "source": "/* {{{ */ #if __has_include(\".precompiled/my_template.h\") && !defined(MY_IDE)\n#include \".precompiled/my_template.h\"\n#else\n#include <bits/stdc++.h>\n\nnamespace utils{\nusing namespace std;\nconstexpr bool use_stdio = false;\nostream* out = &cout;\nFILE* stdio_out = stdout;\nconst bool __ = [](){ if constexpr(!use_stdio){ ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  cout << fixed; cout << setprecision(12); cerr << fixed; cerr << setprecision(12); } return true; }();\ntemplate<typename ...> using to_void = void;\ntemplate<typename T, typename = void> struct is_container : false_type {};\ntemplate<typename T> struct is_container<T, to_void<decltype(declval<T>().begin()), decltype(declval<T>().end())>> : true_type {};\ntemplate<typename V, typename N> struct resize { V& v; function<N()> n;\n  resize(V& vv, function<N()> nn) : v(vv), n(nn) {} ~resize() { v.resize(n()); } };\n\ninline void rd(int& x) { if constexpr(use_stdio) scanf(\"%d\", &x); else cin >> x; }\ninline void rd(long long& x) { if constexpr(use_stdio) scanf(\"%lld\", &x); else cin >> x; }\ninline void rd(double& x) { if constexpr(use_stdio) scanf(\"%lf\", &x); else cin >> x; }\ninline void rd(long double& x) { if constexpr(use_stdio){ double y; scanf(\"%lf\", &y); x=y; } else cin >> x; }\ninline void rd(char& x) { if constexpr(use_stdio) scanf(\" %c\", &x); else cin >> x; }\ninline void rd(char* x) { if constexpr(use_stdio) scanf(\"%s\", x); else cin >> x; }\ninline void rd(string& x) { if constexpr(use_stdio) assert(false); else cin >> x; }\ntemplate<typename T, typename enable_if<!use_stdio && is_integral<T>::value>::type* = nullptr> inline void rd(T& x) { cin >> x; }\ntemplate<typename T> inline void rd(T* x);\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void rd(T& x);\ntemplate<typename... Ts> inline void rd(tuple<Ts...>& x);\ntemplate<typename V, typename N> inline void rd(const resize<V, N>& x);\ntemplate<typename T, typename U> inline void rd(pair<T, U>& x) { rd(x.first); rd(x.second); }\ntemplate<typename V, typename N> inline void rd(const resize<V, N>& x) { const_cast<V&>(x.v).resize(x.n()); rd(x.v); }\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void rd(T& x) { for(auto& v : x) rd(v); }\ntemplate<typename T, typename U, typename... Ts> inline void rd(T&& t, U&& u, Ts&&... ts) {\n  rd(forward<T>(t)); rd(forward<U>(u), forward<Ts>(ts)...); }\ntemplate<typename... Ts> inline void rd(tuple<Ts...>& x) { static_assert(sizeof...(Ts) > 0);\n  constexpr auto apply_rd = [](auto&&... xs) { rd(xs...); }; apply(apply_rd, x); }\ntemplate<typename T> inline void rd(T* x) { rd(*x); }\n\ninline void prt(const int& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%d\", x); else *out << x; }\ninline void prt(const long long& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%lld\", x); else *out << x; }\ninline void prt(const double& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%.12f\", x); else *out << x; }\ninline void prt(const long double& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%.12f\", (double)x); else *out << x; }\ninline void prt(const char& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%c\", x); else *out << x; }\ninline void prt(const char* x) { if constexpr(use_stdio) fprintf(stdio_out, \"%s\", x); else *out << x; }\ninline void prt(const string &x) { if constexpr(use_stdio) fprintf(stdio_out, \"%s\", x.c_str()); else *out << x; }\ntemplate<typename T, typename enable_if<!use_stdio && is_integral<T>::value>::type* = nullptr> inline void prt(const T& x) { *out << x; }\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void prt(const T& x);\ntemplate<typename... Ts> inline void prt(const tuple<Ts...>& x);\ntemplate<typename T, typename U> inline void prt(const pair<T, U>& x) { prt(x.first); prt(' '); prt(x.second); }\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void prt(const T& x) {\n  if (x.begin() != x.end()) { prt(*x.begin()); for(auto it = x.begin(); ++it != x.end(); ) { prt(' '); prt(*it); } } }\ntemplate<typename T, typename U, typename... Ts> inline void prt(T&& t, U&& u, Ts&&... ts) {\n  prt(forward<T>(t)); prt(' '); prt(forward<U>(u), forward<Ts>(ts)...); }\ntemplate<typename... Ts> inline void prt(const tuple<Ts...>& x ) { static_assert(sizeof...(Ts) > 0);\n  constexpr auto apply_prt = [](auto&&... xs) { prt(xs...); }; apply(apply_prt, x); }\ninline void wt() { prt('\\n'); }\ntemplate<typename... Ts> inline void wt(Ts&&... ts) { prt(forward<Ts>(ts)...); wt(); }\n\n#ifdef MY_DEBUG_FLAG\ninline void enter_db() { if constexpr(use_stdio) stdio_out = stderr; else out = &cerr; }\ninline void leave_db() { if constexpr(use_stdio) stdio_out = stdout; else out = &cout; }\ninline void db() { enter_db(); prt('\\n'); leave_db(); }\ntemplate<typename... Ts> inline void db(Ts&&... ts) { enter_db(); prt(forward<Ts>(ts)...); wt(); leave_db(); }\n#define db(...) utils::db(\"Debug(\", #__VA_ARGS__, \") == (\", __VA_ARGS__, \")\")\n#else\n#define db(...)\n#endif // define(MY_DEBUG_FLAG)\ninline int slen(char*s){ return (int) strlen(s); }\ninline void flush() { if constexpr(use_stdio) fflush(stdout); else cout << std::flush; }\n}\n#endif // __has_include(\".precompiled/my_template.h\")\nusing namespace std; /* }}} */\n\n/* {{{ */ using ll = long long;\n#define int ll\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing utils::rd, utils::prt, utils::wt, utils::slen, utils::flush;\n\n#ifdef MY_DEBUG_FLAG\n#define assertd(...) assert(__VA_ARGS__)\n#else\n#define assertd(...)\n#endif // define(MY_DEBUG_FLAG)\n\n#define pb emplace_back\n#define x first\n#define y second\n#define sz(a) ((int)(a).size())\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define dec(i,n,a) for(int i=(n); i>=(a); i--)\n#define clr(a,v) memset(a, v, sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define resz(v, n) utils::resize<decltype(v), decltype(n)>(v, [&](){ return (n); }) /* }}} */\n\n\nconstexpr int inf = 0x3f3f3f3f;\nconstexpr ld eps = 1e-9;\nconstexpr int maxn = 2e5 + 10;\nconstexpr int logn = 20;\nconstexpr int mod = 1000000007;\n\ntypedef int flowt;\nint vis[55];\nnamespace flow {\n  const int M=5500,N=50;\n  int y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\n  flowt f[M];\n  int S,T,tot,Tn;\n  void init(int s,int t,int tn) {\n    tot=1; assert(tn<N);\n    rep(i,0,tn) fst[i]=0,vis[i]=0;\n    S=s;T=t;Tn=tn;\n  }\n  void add(int u,int v,flowt c1,flowt c2=0) {\n    tot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\n    tot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\n  }\n  flowt sap() {\n    int u=S,t=1;flowt flow=0;\n    rep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\n    q[0]=T;dis[T]=0;pre[S]=0;\n    rep(i,0,t) {\n      int uu = q[i];\n      for (int j = fst[uu]; j; j = nxt[j])\n        if (dis[y[j]] > dis[uu] + 1 && f[j ^ 1])\n          q[t++] = y[j], dis[y[j]] = dis[uu] + 1;\n    }\n    rep(i,0,Tn) gap[dis[i]]++;\n    while (dis[S]<=Tn) {\n      while (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\n      if (c[u]) {\n        pre[y[c[u]]]=c[u]^1;\n        u=y[c[u]];\n        if (u==T) {\n          flowt minf=inf;\n          for (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\n          for (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\n          flow+=minf;u=S;\n        }\n      } else {\n        if (!(--gap[dis[u]])) break;\n        int mind=Tn;\n        c[u]=fst[u];\n        for (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind)\n          mind=dis[y[j]],c[u]=j;\n        dis[u]=mind+1;\n        gap[dis[u]]++;\n        if (u!=S) u=y[pre[u]];\n      }\n    }\n    q[0]=T; vis[T]=1; t=1;\n    rep(i,0,t) {\n      int uu = q[i];\n      for (int j = fst[uu]; j; j = nxt[j])\n        if (!vis[y[j]] && f[j ^ 1])\n          q[t++] = y[j], vis[y[j]] = 1;\n    }\n    return flow;\n  }\n}\n\nint n, m, adj[55][55], dis[55], shortest[55][55];\nvector<tuple<int, int, int> > ans;\nint usd;\n\nvoid dijkstra() {\n  clr(shortest, 0);\n  clr(dis, 0x3f);\n  dis[0] = 0;\n  static int inq[55];\n  clr(inq, 0);\n  inq[0] = 1;\n  while (true) {\n    int v = -1;\n    rep(i,0,n) if (inq[i] && (v == -1 || dis[v] > dis[i])) v = i;\n    inq[v] = 0;\n    if (v == n - 1) break;\n    rep(u,0,n) if (adj[v][u] && dis[u] > dis[v] + adj[v][u]) {\n      dis[u] = dis[v] + adj[v][u];\n      inq[u] = 1;\n    }\n  }\n  rep(v,0,n) rep(u,0,n) if (v != u && adj[v][u] && dis[u] == dis[v] + adj[v][u]) shortest[v][u] = 1;\n}\n\nvoid run_flow() {\n  flow::init(0, n-1, n);\n  rep(i,0,n) rep(j,0,n) if (shortest[i][j]) flow::add(i, j, 1);\n  int k = flow::sap();\n  int minf = inf;\n  rep(i,0,n) rep(j,0,n) if (!vis[i] && vis[j] && adj[i][j] && !shortest[i][j]) {\n    minf = min(minf, dis[i] + adj[i][j] - dis[j]);\n  }\n  rep(i,0,n) rep(j,0,n) if (!vis[i] && vis[j] && adj[i][j] && shortest[i][j]) {\n    adj[i][j] += minf;\n  }\n  ans.pb(usd, dis[n - 1], k);\n  usd += minf * k;\n}\n\nvoid solve() {\n  rd(n, m);\n  rep(i,0,m) {\n    int u, v, c;\n    rd(u, v, c);\n    u--, v--;\n    adj[u][v] = c;\n  }\n  while(ans.empty() || get<0>(ans.back()) <= 100000) {\n    dijkstra();\n    run_flow();\n  }\n  int q;\n  rd(q);\n  while(q--) {\n    int x;\n    rd(x);\n    auto it = upper_bound(all(ans), make_tuple(x, inf, inf));\n    it--;\n    auto [us, md, mf] = *it;\n    wt(md + (ld) (x - us) / (ld) mf);\n  }\n}\n\nint32_t main() {\n  int test_count = 1;\n  // rd(test_count);\n  while (test_count--) solve();\n}\n\n"
}