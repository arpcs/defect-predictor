{
    "id": 86946958,
    "contestId": 1307,
    "creationTimeSeconds": 1594853739,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1307,
        "index": "G",
        "name": "Cow and Exercise",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3100,
        "tags": [
            "flows",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1307,
        "members": [
            {
                "handle": "victoragnez"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1581953700
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 6,
    "timeConsumedMillis": 155,
    "memoryConsumedBytes": 4505600,
    "source": "/* {{{ */ #if __has_include(\".precompiled/my_template.h\") && !defined(MY_IDE)\r\n#include \".precompiled/my_template.h\"\r\n#else\r\n#include <bits/stdc++.h>\r\n\r\nnamespace utils{\r\nusing namespace std;\r\nconstexpr bool use_stdio = false;\r\nostream* out = &cout;\r\nFILE* stdio_out = stdout;\r\nconst bool __ = [](){ if constexpr(!use_stdio){ ios_base::sync_with_stdio(false); cin.tie(nullptr);\r\n  cout << fixed; cout << setprecision(12); cerr << fixed; cerr << setprecision(12); } return true; }();\r\ntemplate<typename ...> using to_void = void;\r\ntemplate<typename T, typename = void> struct is_container : false_type {};\r\ntemplate<typename T> struct is_container<T, to_void<decltype(declval<T>().begin()), decltype(declval<T>().end())>> : true_type {};\r\ntemplate<typename V, typename N> struct resize { V& v; function<N()> n;\r\n  resize(V& vv, function<N()> nn) : v(vv), n(nn) {} ~resize() { v.resize(n()); } };\r\n\r\ninline void rd(int& x) { if constexpr(use_stdio) scanf(\"%d\", &x); else cin >> x; }\r\ninline void rd(long long& x) { if constexpr(use_stdio) scanf(\"%lld\", &x); else cin >> x; }\r\ninline void rd(double& x) { if constexpr(use_stdio) scanf(\"%lf\", &x); else cin >> x; }\r\ninline void rd(long double& x) { if constexpr(use_stdio){ double y; scanf(\"%lf\", &y); x=y; } else cin >> x; }\r\ninline void rd(char& x) { if constexpr(use_stdio) scanf(\" %c\", &x); else cin >> x; }\r\ninline void rd(char* x) { if constexpr(use_stdio) scanf(\"%s\", x); else cin >> x; }\r\ninline void rd(string& x) { if constexpr(use_stdio) assert(false); else cin >> x; }\r\ntemplate<typename T, typename enable_if<!use_stdio && is_integral<T>::value>::type* = nullptr> inline void rd(T& x) { cin >> x; }\r\ntemplate<typename T> inline void rd(T* x);\r\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void rd(T& x);\r\ntemplate<typename... Ts> inline void rd(tuple<Ts...>& x);\r\ntemplate<typename V, typename N> inline void rd(const resize<V, N>& x);\r\ntemplate<typename T, typename U> inline void rd(pair<T, U>& x) { rd(x.first); rd(x.second); }\r\ntemplate<typename V, typename N> inline void rd(const resize<V, N>& x) { const_cast<V&>(x.v).resize(x.n()); rd(x.v); }\r\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void rd(T& x) { for(auto& v : x) rd(v); }\r\ntemplate<typename T, typename U, typename... Ts> inline void rd(T&& t, U&& u, Ts&&... ts) {\r\n  rd(forward<T>(t)); rd(forward<U>(u), forward<Ts>(ts)...); }\r\ntemplate<typename... Ts> inline void rd(tuple<Ts...>& x) { static_assert(sizeof...(Ts) > 0);\r\n  constexpr auto apply_rd = [](auto&&... xs) { rd(xs...); }; apply(apply_rd, x); }\r\ntemplate<typename T> inline void rd(T* x) { rd(*x); }\r\n\r\ninline void prt(const int& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%d\", x); else *out << x; }\r\ninline void prt(const long long& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%lld\", x); else *out << x; }\r\ninline void prt(const double& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%.12f\", x); else *out << x; }\r\ninline void prt(const long double& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%.12f\", (double)x); else *out << x; }\r\ninline void prt(const char& x) { if constexpr(use_stdio) fprintf(stdio_out, \"%c\", x); else *out << x; }\r\ninline void prt(const char* x) { if constexpr(use_stdio) fprintf(stdio_out, \"%s\", x); else *out << x; }\r\ninline void prt(const string &x) { if constexpr(use_stdio) fprintf(stdio_out, \"%s\", x.c_str()); else *out << x; }\r\ntemplate<typename T, typename enable_if<!use_stdio && is_integral<T>::value>::type* = nullptr> inline void prt(const T& x) { *out << x; }\r\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void prt(const T& x);\r\ntemplate<typename... Ts> inline void prt(const tuple<Ts...>& x);\r\ntemplate<typename T, typename U> inline void prt(const pair<T, U>& x) { prt(x.first); prt(' '); prt(x.second); }\r\ntemplate<typename T, typename enable_if<is_container<T>::value>::type* = nullptr> inline void prt(const T& x) {\r\n  if (x.begin() != x.end()) { prt(*x.begin()); for(auto it = x.begin(); ++it != x.end(); ) { prt(' '); prt(*it); } } }\r\ntemplate<typename T, typename U, typename... Ts> inline void prt(T&& t, U&& u, Ts&&... ts) {\r\n  prt(forward<T>(t)); prt(' '); prt(forward<U>(u), forward<Ts>(ts)...); }\r\ntemplate<typename... Ts> inline void prt(const tuple<Ts...>& x ) { static_assert(sizeof...(Ts) > 0);\r\n  constexpr auto apply_prt = [](auto&&... xs) { prt(xs...); }; apply(apply_prt, x); }\r\ninline void wt() { prt('\\n'); }\r\ntemplate<typename... Ts> inline void wt(Ts&&... ts) { prt(forward<Ts>(ts)...); wt(); }\r\n\r\n#ifdef MY_DEBUG_FLAG\r\ninline void enter_db() { if constexpr(use_stdio) stdio_out = stderr; else out = &cerr; }\r\ninline void leave_db() { if constexpr(use_stdio) stdio_out = stdout; else out = &cout; }\r\ninline void db() { enter_db(); prt('\\n'); leave_db(); }\r\ntemplate<typename... Ts> inline void db(Ts&&... ts) { enter_db(); prt(forward<Ts>(ts)...); wt(); leave_db(); }\r\n#define db(...) utils::db(\"Debug(\", #__VA_ARGS__, \") == (\", __VA_ARGS__, \")\")\r\n#else\r\n#define db(...)\r\n#endif // define(MY_DEBUG_FLAG)\r\ninline int slen(char*s){ return (int) strlen(s); }\r\ninline void flush() { if constexpr(use_stdio) fflush(stdout); else cout << std::flush; }\r\n}\r\n#endif // __has_include(\".precompiled/my_template.h\")\r\nusing namespace std; /* }}} */\r\n\r\n/* {{{ */ using ll = long long;\r\n#define int ll\r\nusing ld = long double;\r\nusing pii = pair<int, int>;\r\nusing vi = vector<int>;\r\nusing utils::rd, utils::prt, utils::wt, utils::slen, utils::flush;\r\n\r\n#ifdef MY_DEBUG_FLAG\r\n#define assertd(...) assert(__VA_ARGS__)\r\n#else\r\n#define assertd(...)\r\n#endif // define(MY_DEBUG_FLAG)\r\n\r\n#define pb emplace_back\r\n#define x first\r\n#define y second\r\n#define sz(a) ((int)(a).size())\r\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\r\n#define dec(i,n,a) for(int i=(n); i>=(a); i--)\r\n#define clr(a,v) memset(a, v, sizeof(a))\r\n#define all(a) (a).begin(),(a).end()\r\n#define resz(v, n) utils::resize<decltype(v), decltype(n)>(v, [&](){ return (n); }) /* }}} */\r\n\r\n\r\nconstexpr int inf = 0x3f3f3f3f3f3f3f3fLL;\r\nconstexpr ld eps = 1e-9;\r\nconstexpr int maxn = 2e5 + 10;\r\nconstexpr int logn = 20;\r\nconstexpr int mod = 1000000007;\r\n\r\ntypedef int flowt;\r\nint vis[55];\r\nnamespace flow {\r\n  const int M=5500,N=55;\r\n  int y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\r\n  flowt f[M];\r\n  int S,T,tot,Tn;\r\n  void init(int s,int t,int tn) {\r\n    tot=1; assert(tn<N);\r\n    rep(i,0,tn) fst[i]=0,vis[i]=0;\r\n    S=s;T=t;Tn=tn;\r\n  }\r\n  void add(int u,int v,flowt c1,flowt c2=0) {\r\n    tot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\r\n    tot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\r\n  }\r\n  flowt sap() {\r\n    int u=S,t=1;flowt flow=0;\r\n    rep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\r\n    q[0]=T;dis[T]=0;pre[S]=0;\r\n    rep(i,0,t) {\r\n      int uu = q[i];\r\n      for (int j = fst[uu]; j; j = nxt[j])\r\n        if (dis[y[j]] > dis[uu] + 1 && f[j ^ 1])\r\n          q[t++] = y[j], dis[y[j]] = dis[uu] + 1;\r\n    }\r\n    rep(i,0,Tn) gap[dis[i]]++;\r\n    while (dis[S]<=Tn) {\r\n      while (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\r\n      if (c[u]) {\r\n        pre[y[c[u]]]=c[u]^1;\r\n        u=y[c[u]];\r\n        if (u==T) {\r\n          flowt minf=inf;\r\n          for (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\r\n          for (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\r\n          flow+=minf;u=S;\r\n        }\r\n      } else {\r\n        if (!(--gap[dis[u]])) break;\r\n        int mind=Tn;\r\n        c[u]=fst[u];\r\n        for (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind)\r\n          mind=dis[y[j]],c[u]=j;\r\n        dis[u]=mind+1;\r\n        gap[dis[u]]++;\r\n        if (u!=S) u=y[pre[u]];\r\n      }\r\n    }\r\n    q[0]=T; vis[T]=1; t=1;\r\n    rep(i,0,t) {\r\n      int uu = q[i];\r\n      for (int j = fst[uu]; j; j = nxt[j])\r\n        if (!vis[y[j]] && f[j ^ 1])\r\n          q[t++] = y[j], vis[y[j]] = 1;\r\n    }\r\n    return flow;\r\n  }\r\n}\r\n\r\nint n, m, adj[55][55], dis[55], shortest[55][55];\r\nvector<tuple<int, int, int> > ans;\r\nint usd;\r\n\r\nvoid dijkstra() {\r\n  clr(shortest, 0);\r\n  clr(dis, 0x3f);\r\n  dis[0] = 0;\r\n  static int inq[55];\r\n  clr(inq, 0);\r\n  inq[0] = 1;\r\n  while (true) {\r\n    int v = -1;\r\n    rep(i,0,n) if (inq[i] && (v == -1 || dis[v] > dis[i])) v = i;\r\n    inq[v] = 0;\r\n    if (v == n - 1) break;\r\n    rep(u,0,n) if (adj[v][u] && dis[u] > dis[v] + adj[v][u]) {\r\n      dis[u] = dis[v] + adj[v][u];\r\n      inq[u] = 1;\r\n    }\r\n  }\r\n  rep(v,0,n) rep(u,0,n) if (v != u && adj[v][u] && dis[u] == dis[v] + adj[v][u]) shortest[v][u] = 1;\r\n}\r\n\r\nvoid run_flow() {\r\n  flow::init(0, n-1, n);\r\n  rep(i,0,n) rep(j,0,n) if (shortest[i][j]) flow::add(i, j, 1);\r\n  int k = flow::sap();\r\n  int minf = 0x3f3f3f3f;\r\n  rep(i,0,n) rep(j,0,n) if (!vis[i] && vis[j] && adj[i][j] && !shortest[i][j]) {\r\n    minf = min(minf, dis[i] + adj[i][j] - dis[j]);\r\n  }\r\n  rep(i,0,n) rep(j,0,n) if (!vis[i] && vis[j] && adj[i][j] && shortest[i][j]) {\r\n    adj[i][j] += minf;\r\n  }\r\n  ans.pb(usd, dis[n - 1], k);\r\n  usd += minf * k;\r\n}\r\n\r\nvoid solve() {\r\n  rd(n, m);\r\n  rep(i,0,m) {\r\n    int u, v, c;\r\n    rd(u, v, c);\r\n    u--, v--;\r\n    adj[u][v] = c;\r\n  }\r\n  while(ans.empty() || get<0>(ans.back()) <= 100000) {\r\n    dijkstra();\r\n    run_flow();\r\n  }\r\n  int q;\r\n  rd(q);\r\n  while(q--) {\r\n    int x;\r\n    rd(x);\r\n    auto it = upper_bound(all(ans), make_tuple(x, inf, inf));\r\n    it--;\r\n    auto [us, md, mf] = *it;\r\n    wt(md + (ld) (x - us) / (ld) mf);\r\n  }\r\n}\r\n\r\nint32_t main() {\r\n  int test_count = 1;\r\n  // rd(test_count);\r\n  while (test_count--) solve();\r\n}\r\n\r\n"
}