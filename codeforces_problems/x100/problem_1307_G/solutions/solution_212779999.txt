{
    "id": 212779999,
    "contestId": 1307,
    "creationTimeSeconds": 1688798827,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1307,
        "index": "G",
        "name": "Cow and Exercise",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3100,
        "tags": [
            "flows",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1307,
        "members": [
            {
                "handle": "torisasami"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1581953700
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 358,
    "memoryConsumedBytes": 3379200,
    "source": "// #define _GLIBCXX_DEBUG\r\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define rep(i, n) for (int i = 0; i < int(n); i++)\r\n#define per(i, n) for (int i = (n)-1; 0 <= i; i--)\r\n#define rep2(i, l, r) for (int i = (l); i < int(r); i++)\r\n#define per2(i, l, r) for (int i = (r)-1; int(l) <= i; i--)\r\n#define each(e, v) for (auto& e : v)\r\n#define MM << \" \" <<\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define all(x) begin(x), end(x)\r\n#define rall(x) rbegin(x), rend(x)\r\n#define sz(x) (int)x.size()\r\ntemplate <typename T> void print(const vector<T>& v, T x = 0) {\r\n    int n = v.size();\r\n    for (int i = 0; i < n; i++) cout << v[i] + x << (i == n - 1 ? '\\n' : ' ');\r\n    if (v.empty()) cout << '\\n';\r\n}\r\nusing ll = long long;\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\ntemplate <typename T> bool chmax(T& x, const T& y) {\r\n    return (x < y) ? (x = y, true) : false;\r\n}\r\ntemplate <typename T> bool chmin(T& x, const T& y) {\r\n    return (x > y) ? (x = y, true) : false;\r\n}\r\ntemplate <class T>\r\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\r\ntemplate <class T> using maxheap = std::priority_queue<T>;\r\ntemplate <typename T> int lb(const vector<T>& v, T x) {\r\n    return lower_bound(begin(v), end(v), x) - begin(v);\r\n}\r\ntemplate <typename T> int ub(const vector<T>& v, T x) {\r\n    return upper_bound(begin(v), end(v), x) - begin(v);\r\n}\r\ntemplate <typename T> void rearrange(vector<T>& v) {\r\n    sort(begin(v), end(v));\r\n    v.erase(unique(begin(v), end(v)), end(v));\r\n}\r\n\r\n// __int128_t gcd(__int128_t a, __int128_t b) {\r\n//     if (a == 0)\r\n//         return b;\r\n//     if (b == 0)\r\n//         return a;\r\n//     __int128_t cnt = a % b;\r\n//     while (cnt != 0) {\r\n//         a = b;\r\n//         b = cnt;\r\n//         cnt = a % b;\r\n//     }\r\n//     return b;\r\n// }\r\n\r\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\r\n    if (b == 0) {\r\n        x = 1;\r\n        y = 0;\r\n        return a;\r\n    }\r\n    long long d = extGCD(b, a % b, y, x);\r\n    y -= a / b * x;\r\n    return d;\r\n}\r\n\r\nstruct Union_Find_Tree {\r\n    vector<int> data;\r\n    const int n;\r\n    int cnt;\r\n \r\n    Union_Find_Tree(int n) : data(n, -1), n(n), cnt(n) {}\r\n \r\n    int root(int x) {\r\n        if (data[x] < 0) return x;\r\n        return data[x] = root(data[x]);\r\n    }\r\n \r\n    int operator[](int i) { return root(i); }\r\n \r\n    bool unite(int x, int y) {\r\n        x = root(x), y = root(y);\r\n        if (x == y) return false;\r\n        if (data[x] > data[y]) swap(x, y);\r\n        data[x] += data[y], data[y] = x;\r\n        cnt--;\r\n        return true;\r\n    }\r\n \r\n    int size(int x) { return -data[root(x)]; }\r\n \r\n    int count() { return cnt; };\r\n \r\n    bool same(int x, int y) { return root(x) == root(y); }\r\n \r\n    void clear() {\r\n        cnt = n;\r\n        fill(begin(data), end(data), -1);\r\n    }\r\n};\r\n\r\ntemplate <int mod> struct Mod_Int {\r\n    int x;\r\n\r\n    Mod_Int() : x(0) {}\r\n\r\n    Mod_Int(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\r\n\r\n    static int get_mod() { return mod; }\r\n\r\n    Mod_Int& operator+=(const Mod_Int& p) {\r\n        if ((x += p.x) >= mod) x -= mod;\r\n        return *this;\r\n    }\r\n\r\n    Mod_Int& operator-=(const Mod_Int& p) {\r\n        if ((x += mod - p.x) >= mod) x -= mod;\r\n        return *this;\r\n    }\r\n\r\n    Mod_Int& operator*=(const Mod_Int& p) {\r\n        x = (int)(1LL * x * p.x % mod);\r\n        return *this;\r\n    }\r\n\r\n    Mod_Int& operator/=(const Mod_Int& p) {\r\n        *this *= p.inverse();\r\n        return *this;\r\n    }\r\n\r\n    Mod_Int& operator++() { return *this += Mod_Int(1); }\r\n\r\n    Mod_Int operator++(int) {\r\n        Mod_Int tmp = *this;\r\n        ++*this;\r\n        return tmp;\r\n    }\r\n\r\n    Mod_Int& operator--() { return *this -= Mod_Int(1); }\r\n\r\n    Mod_Int operator--(int) {\r\n        Mod_Int tmp = *this;\r\n        --*this;\r\n        return tmp;\r\n    }\r\n\r\n    Mod_Int operator-() const { return Mod_Int(-x); }\r\n\r\n    Mod_Int operator+(const Mod_Int& p) const { return Mod_Int(*this) += p; }\r\n\r\n    Mod_Int operator-(const Mod_Int& p) const { return Mod_Int(*this) -= p; }\r\n\r\n    Mod_Int operator*(const Mod_Int& p) const { return Mod_Int(*this) *= p; }\r\n\r\n    Mod_Int operator/(const Mod_Int& p) const { return Mod_Int(*this) /= p; }\r\n\r\n    bool operator==(const Mod_Int& p) const { return x == p.x; }\r\n\r\n    bool operator!=(const Mod_Int& p) const { return x != p.x; }\r\n\r\n    Mod_Int inverse() const {\r\n        assert(*this != Mod_Int(0));\r\n        return pow(mod - 2);\r\n    }\r\n\r\n    Mod_Int pow(long long k) const {\r\n        Mod_Int now = *this, ret = 1;\r\n        for (; k > 0; k >>= 1, now *= now) {\r\n            if (k & 1) ret *= now;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& os, const Mod_Int& p) {\r\n        return os << p.x;\r\n    }\r\n\r\n    friend istream& operator>>(istream& is, Mod_Int& p) {\r\n        long long a;\r\n        is >> a;\r\n        p = Mod_Int<mod>(a);\r\n        return is;\r\n    }\r\n};\r\n\r\nll mpow2(ll x, ll n, ll mod) {\r\n    ll ans = 1;\r\n    x %= mod;\r\n    while (n != 0) {\r\n        if (n & 1) ans = ans * x % mod;\r\n        x = x * x % mod;\r\n        n = n >> 1;\r\n    }\r\n    ans %= mod;\r\n    return ans;\r\n}\r\n\r\ntemplate <typename T> T modinv(T a, const T& m) {\r\n    T b = m, u = 1, v = 0;\r\n    while (b > 0) {\r\n        T t = a / b;\r\n        swap(a -= t * b, b);\r\n        swap(u -= t * v, v);\r\n    }\r\n    return u >= 0 ? u % m : (m - (-u) % m) % m;\r\n}\r\n\r\nll divide_int(ll a, ll b) {\r\n    if (b < 0) a = -a, b = -b;\r\n    return (a >= 0 ? a / b : (a - b + 1) / b);\r\n}\r\n\r\nconst int MOD = 1000000007;\r\n// const int MOD = 998244353;\r\nusing mint = Mod_Int<MOD>;\r\n\r\nmint mpow(mint x, ll n) {\r\n    bool rev = n < 0;\r\n    n = abs(n);\r\n    mint ans = 1;\r\n    while (n != 0) {\r\n        if (n & 1) ans *= x;\r\n        x *= x;\r\n        n = n >> 1;\r\n    }\r\n    return (rev ? ans.inverse() : ans);\r\n}\r\n\r\n// ----- library -------\r\ntemplate <typename F>\r\nstruct Dinic {\r\n    struct edge {\r\n        int to;\r\n        F cap;\r\n        int rev;\r\n        edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev) {}\r\n    };\r\n\r\n    vector<vector<edge>> es;\r\n    vector<int> d, pos;\r\n    const F zero_F, INF_F;\r\n    const int n;\r\n\r\n    Dinic(int n, F zero_F = 0, F INF_F = numeric_limits<F>::max() / 2) : es(n), d(n), pos(n), zero_F(zero_F), INF_F(INF_F), n(n) {}\r\n\r\n    void add_edge(int from, int to, F cap, bool directed = true) {\r\n        es[from].emplace_back(to, cap, (int)es[to].size());\r\n        es[to].emplace_back(from, directed ? zero_F : cap, (int)es[from].size() - 1);\r\n    }\r\n\r\n    bool _bfs(int s, int t) {\r\n        fill(begin(d), end(d), -1);\r\n        queue<int> que;\r\n        d[s] = 0;\r\n        que.push(s);\r\n        while (!que.empty()) {\r\n            int i = que.front();\r\n            que.pop();\r\n            for (auto &e : es[i]) {\r\n                if (e.cap > zero_F && d[e.to] == -1) {\r\n                    d[e.to] = d[i] + 1;\r\n                    que.push(e.to);\r\n                }\r\n            }\r\n        }\r\n        return d[t] != -1;\r\n    }\r\n\r\n    F _dfs(int now, int t, F flow) {\r\n        if (now == t) return flow;\r\n        for (int &i = pos[now]; i < (int)es[now].size(); i++) {\r\n            edge &e = es[now][i];\r\n            if (e.cap > zero_F && d[e.to] > d[now]) {\r\n                F f = _dfs(e.to, t, min(flow, e.cap));\r\n                if (f > zero_F) {\r\n                    e.cap -= f;\r\n                    es[e.to][e.rev].cap += f;\r\n                    return f;\r\n                }\r\n            }\r\n        }\r\n        return zero_F;\r\n    }\r\n\r\n    // \u64cd\u4f5c\u5f8c\u306e d \u914d\u5217\u306f\u6700\u5c0f\u30ab\u30c3\u30c8\u306e 1 \u3064\u3092\u8868\u3059 (0 \u4ee5\u4e0a\u306a\u3089 s \u5074\u3001-1 \u306a\u3089 t \u5074)\r\n    F max_flow(int s, int t) {\r\n        F flow = zero_F;\r\n        while (_bfs(s, t)) {\r\n            fill(begin(pos), end(pos), 0);\r\n            F f = zero_F;\r\n            while ((f = _dfs(s, t, INF_F)) > zero_F) flow += f;\r\n        }\r\n        return flow;\r\n    }\r\n};\r\n// ----- library -------\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    std::cin.tie(nullptr);\r\n    cout << fixed << setprecision(15);\r\n\r\n    int n, m;\r\n    cin >> n >> m;\r\n    vector<int> u(m), v(m);\r\n    vector<ll> w(m);\r\n    rep(i, m) cin >> u[i] >> v[i] >> w[i], u[i]--, v[i]--;\r\n    vector<ll> cs, ds;\r\n    const ll INF = 1e18;\r\n    ll val = -1;\r\n    rep(t, 5) {\r\n        vector<vector<pair<int, ll>>> g(n);\r\n        rep(i, m) g[u[i]].eb(v[i], w[i]), g[v[i]].eb(u[i], w[i]);\r\n        vector<ll> d1(n, INF), dn(n, INF);\r\n        minheap<pair<ll, int>> que;\r\n        d1[0] = 0, que.emplace(0, 0);\r\n        while (sz(que)) {\r\n            auto [nd, now] = que.top();\r\n            que.pop();\r\n            if (d1[now] == nd) {\r\n                for (auto [e, co] : g[now]) {\r\n                    if (chmin(d1[e], d1[now] + co))\r\n                        que.emplace(d1[e], e);\r\n                }\r\n            }\r\n        }\r\n        dn[n - 1] = 0, que.emplace(0, n - 1);\r\n        while (sz(que)) {\r\n            auto [nd, now] = que.top();\r\n            que.pop();\r\n            if (dn[now] == nd) {\r\n                for (auto [e, co] : g[now]) {\r\n                    if (chmin(dn[e], dn[now] + co))\r\n                        que.emplace(d1[e], e);\r\n                }\r\n            }\r\n        }\r\n        ll md = d1[n - 1];\r\n        if (val == -1)\r\n            val = md;\r\n        Dinic<int> mf(n);\r\n        rep(i, m) {\r\n            if (d1[u[i]] + dn[u[i]] > md)\r\n                continue;\r\n            if (d1[v[i]] + dn[v[i]] > md)\r\n                continue;\r\n            if (min(d1[u[i]], d1[v[i]]) + w[i] != max(d1[u[i]], d1[v[i]]))\r\n                continue;\r\n            mf.add_edge(u[i], v[i], 1, false);\r\n        }\r\n        int f = mf.max_flow(0, n - 1);\r\n        cs.eb(f);\r\n        vector<int> ls;\r\n        rep(i, m) {\r\n            if (d1[u[i]] + dn[u[i]] > md)\r\n                continue;\r\n            if (d1[v[i]] + dn[v[i]] > md)\r\n                continue;\r\n            if (min(d1[u[i]], d1[v[i]]) + w[i] != max(d1[u[i]], d1[v[i]]))\r\n                continue;\r\n            if ((mf.d[u[i]] >= 0) ^ (mf.d[v[i]] >= 0)) {\r\n                w[i] += INF;\r\n                ls.eb(i);\r\n            }\r\n        }\r\n        assert(sz(ls) == f);\r\n        rep(i, n) g[i].clear();\r\n        rep(i, m) g[u[i]].eb(v[i], w[i]), g[v[i]].eb(u[i], w[i]);\r\n        fill(all(d1), INF);\r\n        d1[0] = 0, que.emplace(0, 0);\r\n        while (sz(que)) {\r\n            auto [nd, now] = que.top();\r\n            que.pop();\r\n            if (d1[now] == nd) {\r\n                for (auto [e, co] : g[now]) {\r\n                    if (chmin(d1[e], d1[now] + co))\r\n                        que.emplace(d1[e], e);\r\n                }\r\n            }\r\n        }\r\n        if (d1[n - 1] == INF) {\r\n            ds.eb(1e12);\r\n            break;\r\n        }\r\n        ll nd = d1[n - 1] - md;\r\n        ds.eb(nd);\r\n        each(e, ls) w[e] += nd - INF;\r\n    }\r\n    int q;\r\n    cin >> q;\r\n    vector<int> x(q);\r\n    rep(i, q) cin >> x[i];\r\n    vector<pii> qs;\r\n    rep(i, q) qs.eb(x[i], i);\r\n    sort(all(qs));\r\n    ll sum = 0;\r\n    int idx = 0;\r\n    vector<double> ans(q);\r\n    for (auto [nx, id] : qs) {\r\n        while (sum + cs[idx] * ds[idx] <= nx)\r\n            sum += cs[idx] * ds[idx], val += ds[idx], idx++;\r\n        ans[id] = (double)(nx - sum) / cs[idx] + val;\r\n    }\r\n    rep(i, q) cout << ans[i] << endl;\r\n}"
}