{
    "id": 92284863,
    "contestId": 1307,
    "creationTimeSeconds": 1599583498,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1307,
        "index": "G",
        "name": "Cow and Exercise",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3100,
        "tags": [
            "flows",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1307,
        "members": [
            {
                "handle": "cwise"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1581953700
    },
    "programmingLanguage": "Java 8",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 25497600,
    "source": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.stream.IntStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            GCowAndExercise solver = new GCowAndExercise();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class GCowAndExercise {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            MakeDistanceFarthest mdf = new MakeDistanceFarthest(n);\n            for (int i = 0; i < m; i++) {\n                mdf.addEdge(in.readInt() - 1, in.readInt() - 1, in.readInt(), 1);\n            }\n            mdf.solve(new LongDijkstraV2MinimumCostFlow(n), 0, n - 1);\n            int q = in.readInt();\n            for (int i = 0; i < q; i++) {\n                int x = in.readInt();\n                double ans = mdf.query(x);\n                out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class LongCostFlowEdge extends LongFlowEdge<LongCostFlowEdge> {\n        public long cost;\n\n        public LongCostFlowEdge(int to, long flow, boolean real, long cost) {\n            super(to, flow, real);\n            this.cost = cost;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static boolean equal(long a, long b) {\n            return a == b;\n        }\n\n    }\n\n    static class DirectedEdge {\n        public int to;\n\n        public DirectedEdge(int to) {\n            this.to = to;\n        }\n\n        public String toString() {\n            return \"->\" + to;\n        }\n\n    }\n\n    static interface LongMinimumCostFlow {\n        long[] apply(List<LongCostFlowEdge>[] net, int s, int t, long send);\n\n    }\n\n    static class MakeDistanceFarthest {\n        private List<LongCostFlowEdge>[] g;\n        MakeDistanceFarthest.LinearFunction[] fs;\n\n        public MakeDistanceFarthest(int n) {\n            g = LongFlow.createCostFlow(n);\n        }\n\n        public void addEdge(int u, int v, long len, long cost) {\n            LongFlow.addCostEdge(g, u, v, cost, len);\n            LongFlow.addCostEdge(g, v, u, cost, len);\n        }\n\n        public void solve(LongAugmentMinimumCostFlow mcf, int s, int t) {\n            List<MakeDistanceFarthest.LinearFunction> list = new ArrayList<>();\n            LongAugmentCallback callback = new LongAugmentCallback() {\n                long sumFlow = 0;\n                long sumCost = 0;\n\n\n                public void callback(long flow, long pathCost) {\n                    sumFlow += flow;\n                    sumCost += flow * pathCost;\n\n                    if (!list.isEmpty() && list.get(list.size() - 1).l == pathCost) {\n                        list.remove(list.size() - 1);\n                    }\n                    MakeDistanceFarthest.LinearFunction func = new MakeDistanceFarthest.LinearFunction(pathCost, sumFlow, -sumCost);\n                    list.add(func);\n                }\n            };\n            mcf.setCallback(callback);\n            mcf.apply(g, s, t, Long.MAX_VALUE / 4);\n            fs = list.toArray(new MakeDistanceFarthest.LinearFunction[0]);\n        }\n\n        public double query(double x) {\n            int l = 0;\n            int r = fs.length - 1;\n            while (l < r) {\n                int mid = (l + r) / 2;\n                boolean valid = mid + 1 >= fs.length ||\n                        fs[mid + 1].getL() > x;\n                if (valid) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            return fs[l].getX(x);\n        }\n\n        private static class LinearFunction {\n            long l;\n            long a;\n            long b;\n\n            public LinearFunction(long l, long a, long b) {\n                this.l = l;\n                this.a = a;\n                this.b = b;\n            }\n\n            long getL() {\n                return a * l + b;\n            }\n\n            double getX(double y) {\n                return (y - b) / a;\n            }\n\n        }\n\n    }\n\n    static class LongFlowEdge<T extends LongFlowEdge<T>> extends DirectedEdge {\n        public long flow;\n        public boolean real;\n        public T rev;\n\n        public LongFlowEdge(int to, long flow, boolean real) {\n            super(to);\n            this.flow = flow;\n            this.real = real;\n        }\n\n        public String toString() {\n            return rev.to + \"-[\" + flow + \"/\" + (flow + rev.flow) + \"]->\" + to;\n        }\n\n    }\n\n    static interface IntegerStack {\n        void addLast(int x);\n\n        boolean isEmpty();\n\n        void clear();\n\n    }\n\n    static interface LongAugmentMinimumCostFlow extends LongMinimumCostFlow {\n        public void setCallback(LongAugmentCallback callback);\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(double c) {\n            cache.append(new BigDecimal(c).toPlainString());\n            return this;\n        }\n\n        public FastOutput println(double c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface LongAugmentCallback {\n        public static LongAugmentCallback NIL = (a, b) -> {\n        };\n\n        public void callback(long flow, long pathCost);\n\n    }\n\n    static class LongFlow {\n        public static <T extends LongFlowEdge> void send(T edge, long flow) {\n            edge.flow += flow;\n            edge.rev.flow -= flow;\n        }\n\n        public static LongCostFlowEdge addCostEdge(List<LongCostFlowEdge>[] g, int s, int t, long cap, long cost) {\n            LongCostFlowEdge real = new LongCostFlowEdge(t, 0, true, cost);\n            LongCostFlowEdge virtual = new LongCostFlowEdge(s, cap, false, -cost);\n            real.rev = virtual;\n            virtual.rev = real;\n            g[s].add(real);\n            g[t].add(virtual);\n            return real;\n        }\n\n        public static List<LongCostFlowEdge>[] createCostFlow(int n) {\n            return createGraph(n);\n        }\n\n        private static List[] createGraph(int n) {\n            return IntStream.range(0, n).mapToObj(i -> new ArrayList<>()).toArray(i -> new List[i]);\n        }\n\n    }\n\n    static class IntegerDequeImpl implements IntegerDeque {\n        private int[] data;\n        private int bpos;\n        private int epos;\n        private static final int[] EMPTY = new int[0];\n        private int n;\n\n        public IntegerDequeImpl(int cap) {\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n            bpos = 0;\n            epos = 0;\n            n = cap;\n        }\n\n        private void expandSpace(int len) {\n            while (n < len) {\n                n = Math.max(n + 10, n * 2);\n            }\n            int[] newData = new int[n];\n            if (bpos <= epos) {\n                if (bpos < epos) {\n                    System.arraycopy(data, bpos, newData, 0, epos - bpos);\n                }\n            } else {\n                System.arraycopy(data, bpos, newData, 0, data.length - bpos);\n                System.arraycopy(data, 0, newData, data.length - bpos, epos);\n            }\n            epos = size();\n            bpos = 0;\n            data = newData;\n        }\n\n        public IntegerIterator iterator() {\n            return new IntegerIterator() {\n                int index = bpos;\n\n\n                public boolean hasNext() {\n                    return index != epos;\n                }\n\n\n                public int next() {\n                    int ans = data[index];\n                    index = IntegerDequeImpl.this.next(index);\n                    return ans;\n                }\n            };\n        }\n\n        public int removeFirst() {\n            int ans = data[bpos];\n            bpos = next(bpos);\n            return ans;\n        }\n\n        public void addLast(int x) {\n            ensureMore();\n            data[epos] = x;\n            epos = next(epos);\n        }\n\n        public void clear() {\n            bpos = epos = 0;\n        }\n\n        private int next(int x) {\n            return x + 1 >= n ? 0 : x + 1;\n        }\n\n        private void ensureMore() {\n            if (next(epos) == bpos) {\n                expandSpace(n + 1);\n            }\n        }\n\n        public int size() {\n            int ans = epos - bpos;\n            if (ans < 0) {\n                ans += data.length;\n            }\n            return ans;\n        }\n\n        public boolean isEmpty() {\n            return bpos == epos;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (IntegerIterator iterator = iterator(); iterator.hasNext(); ) {\n                builder.append(iterator.next()).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class LongDijkstraV2MinimumCostFlow implements LongAugmentMinimumCostFlow {\n        private int m;\n        private long[] lastDist;\n        private long[] curDist;\n        private LongCostFlowEdge[] prev;\n        private boolean[] inq;\n        private IntegerDeque dq;\n        private static final long INF = Long.MAX_VALUE / 4;\n        private List<LongCostFlowEdge>[] g;\n        private LongAugmentCallback callback = LongAugmentCallback.NIL;\n\n        public void setCallback(LongAugmentCallback callback) {\n            this.callback = callback;\n        }\n\n        public LongDijkstraV2MinimumCostFlow(int m) {\n            this.m = m - 1;\n            lastDist = new long[m];\n            curDist = new long[m];\n            prev = new LongCostFlowEdge[m];\n            inq = new boolean[m];\n            dq = new IntegerDequeImpl(m);\n        }\n\n        private void bf(int s) {\n            int n = g.length;\n            dq.clear();\n            for (int i = 0; i < n; i++) {\n                lastDist[i] = INF;\n                inq[i] = false;\n            }\n            lastDist[s] = 0;\n            inq[s] = true;\n            dq.addLast(s);\n            while (!dq.isEmpty()) {\n                int head = dq.removeFirst();\n                inq[head] = false;\n                for (LongCostFlowEdge e : g[head]) {\n                    if (DigitUtils.equal(e.rev.flow, 0) || lastDist[e.to] <= lastDist[head] + e.cost) {\n                        continue;\n                    }\n                    lastDist[e.to] = lastDist[head] + e.cost;\n                    if (!inq[e.to]) {\n                        inq[e.to] = true;\n                        dq.addLast(e.to);\n                    }\n                }\n            }\n        }\n\n        private void dijkstra(int s) {\n            int n = g.length;\n            for (int i = 0; i < n; i++) {\n                curDist[i] = INF;\n                prev[i] = null;\n                inq[i] = false;\n            }\n            curDist[s] = 0;\n\n            for (int i = 0; i < n; i++) {\n                int head = -1;\n                for (int j = 0; j < n; j++) {\n                    if (!inq[j] && (head == -1 || curDist[j] < curDist[head])) {\n                        head = j;\n                    }\n                }\n                if (curDist[head] >= INF) {\n                    break;\n                }\n                inq[head] = true;\n                for (LongCostFlowEdge e : g[head]) {\n                    long dist;\n                    if (e.rev.flow == 0 || curDist[e.to] <= (dist = curDist[head] + e.cost - lastDist[e.to] + lastDist[head])) {\n                        continue;\n                    }\n                    prev[e.to] = e.rev;\n                    curDist[e.to] = dist;\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                lastDist[i] = Math.min(curDist[i] + lastDist[i], INF);\n            }\n        }\n\n        public long[] apply(List<LongCostFlowEdge>[] net, int s, int t, long send) {\n            this.g = net;\n            bf(s);\n            long flow = 0;\n            long cost = 0;\n            while (flow < send) {\n                dijkstra(s);\n                if (prev[t] == null) {\n                    break;\n                }\n                long remain = send - flow;\n                for (LongCostFlowEdge trace = prev[t]; trace != null; trace = prev[trace.to]) {\n                    remain = Math.min(remain, trace.flow);\n                }\n                long sumOfCost = 0;\n                for (LongCostFlowEdge trace = prev[t]; trace != null; trace = prev[trace.to]) {\n                    sumOfCost -= trace.cost;\n                    LongFlow.send(trace, -remain);\n                }\n                cost += sumOfCost * -remain;\n                flow += remain;\n                callback.callback(remain, sumOfCost);\n            }\n            return new long[]{flow, cost};\n        }\n\n    }\n\n    static interface IntegerDeque extends IntegerStack {\n        int removeFirst();\n\n    }\n}\n\n"
}