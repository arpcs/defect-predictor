{
    "id": 118820945,
    "contestId": 1307,
    "creationTimeSeconds": 1623166948,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1307,
        "index": "G",
        "name": "Cow and Exercise",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3100,
        "tags": [
            "flows",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1307,
        "members": [
            {
                "handle": "dnshgyl21"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1581953700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 53,
    "timeConsumedMillis": 202,
    "memoryConsumedBytes": 614400,
    "source": "#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"avx,avx2,fma\")\r\n#include<bits/stdc++.h>\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\n#define pi 3.141592653589793238\r\n#define int long long\r\n#define ll long long\r\n#define ld long double\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\ntemplate <typename T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\r\n\r\n\r\nlong long powm(long long a, long long b,long long mod) {\r\nlong long res = 1;\r\nwhile (b > 0) {\r\n    if (b & 1)\r\n        res = res * a %mod;\r\n    a = a * a %mod;\r\n    b >>= 1;\r\n}\r\nreturn res;\r\n}\r\n\r\nll gcd(ll a, ll b)\r\n{\r\nif (b == 0)\r\n    return a;\r\nreturn gcd(b, a % b);      \r\n}\r\n\r\nvector<int>temp;\r\nconst int INF=1e17;\r\nstruct MinimumCostMaximumFlow {\r\n    typedef int Index;\r\n    typedef int Flow;\r\n    typedef int Cost;\r\n    static const Flow InfCapacity=INF;\r\n    struct Edge {\r\n        Index to;\r\n        Index rev;\r\n        Flow capacity;\r\n        Cost cost;\r\n    };\r\n    vector<vector<Edge> > g;\r\n    void init(Index n) {\r\n        g.assign(n,vector<Edge>());\r\n    }\r\n    void add(Index i, Index j, Flow capacity=InfCapacity, Cost cost=Cost()) {\r\n        Edge e,f;\r\n        e.to=j,f.to=i;\r\n        e.capacity=capacity,f.capacity=0;\r\n        e.cost=cost,f.cost=-cost;\r\n        g[i].push_back(e);\r\n        g[j].push_back(f);\r\n        g[i].back().rev=(Index)g[j].size()-1;\r\n        g[j].back().rev=(Index)g[i].size()-1;\r\n    }\r\n    void addB(Index i, Index j, Flow capacity=InfCapacity, Cost cost=Cost()) {\r\n        add(i,j,capacity,cost);\r\n        add(j,i,capacity,cost);\r\n    }\r\n    pair<Cost, Flow> minimumCostMaximumFlow(Index s, Index t, Flow f=InfCapacity, bool useSPFA=false) {\r\n        int n=g.size();\r\n        vector<Cost> dist(n);\r\n        vector<Index> prev(n);\r\n        vector<Index> prevEdge(n);\r\n        pair<Cost, Flow> total=make_pair(0,0);\r\n        vector<Cost> potential(n);\r\n        while(f>0) {\r\n            fill(dist.begin(),dist.end(),INF);\r\n            if(useSPFA||total.second==0) {\r\n                deque<Index> q;\r\n                q.push_back(s);\r\n                dist[s]=0;\r\n                vector<bool> inqueue(n);\r\n                while(!q.empty()) {\r\n                    Index i=q.front();\r\n                    q.pop_front();\r\n                    inqueue[i]=false;\r\n                    for(Index ei=0; ei<(Index)g[i].size(); ei++) {\r\n                        const Edge &e=g[i][ei];\r\n                        Index j=e.to;\r\n                        Cost d=dist[i]+e.cost;\r\n                        if(e.capacity>0&&d<dist[j]) {\r\n                            if(!inqueue[j]) {\r\n                                inqueue[j]=true;\r\n                                q.push_back(j);\r\n                            }\r\n                            dist[j]=d;\r\n                            prev[j]=i;\r\n                            prevEdge[j]=ei;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                vector<bool> vis(n);\r\n                priority_queue<pair<Cost, Index> > q;\r\n                q.push(make_pair(-0,s));\r\n                dist[s]=0;\r\n                while(!q.empty()) {\r\n                    Index i=q.top().second;\r\n                    q.pop();\r\n                    if(vis[i])\r\n                        continue;\r\n                    vis[i]=true;\r\n                    for(Index ei=0; ei<(Index)g[i].size(); ei++) {\r\n                        const Edge &e=g[i][ei];\r\n                        if(e.capacity<=0)\r\n                            continue;\r\n                        Index j=e.to;\r\n                        Cost d=dist[i]+e.cost+potential[i]-potential[j];\r\n                        if(dist[j]>d) {\r\n                            dist[j]=d;\r\n                            prev[j]=i;\r\n                            prevEdge[j]=ei;\r\n                            q.push(make_pair(-d,j));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(dist[t]==INF)\r\n                break;\r\n            if(!useSPFA)\r\n                for(Index i=0; i<n; i++)\r\n                    potential[i]+=dist[i];\r\n \r\n            Flow d=1;\r\n            Cost distt=0;\r\n            for(Index v=t; v!=s;) {\r\n                Index u=prev[v];\r\n                const Edge &e=g[u][prevEdge[v]];\r\n                d=min(d,e.capacity);\r\n                distt+=e.cost;\r\n                v=u;\r\n            }\r\n            f-=d;\r\n            temp.push_back(distt);\r\n            total.first+=d*distt;\r\n            total.second+=d;\r\n            for(Index v=t; v!=s; v=prev[v]) {\r\n                Edge &e=g[prev[v]][prevEdge[v]];\r\n                e.capacity-=d;\r\n                g[e.to][e.rev].capacity+=d;\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n};\r\n\r\nsigned main()\r\n{\r\n \r\nios_base::sync_with_stdio(false); \r\ncin.tie(NULL);  \r\ncout.tie(0);   \r\n \r\n#ifndef ONLINE_JUDGE\r\n    if(fopen(\"INPUT.txt\",\"r\"))\r\n    {\r\n        freopen(\"INPUT.txt\",\"r\",stdin);\r\n        freopen(\"OUTPUT.txt\",\"w\",stdout);\r\n    }\r\n\r\n#endif          \r\n\r\n\r\n    int n,m;\r\n    cin>>n>>m;\r\n    int x,y;\r\n    MinimumCostMaximumFlow kad;\r\n    kad.init(n+5);\r\n    int z;\r\n    for(int i=0;i<m;i++)\r\n    {\r\n        cin>>x>>y>>z;\r\n        kad.add(x,y,1,z);\r\n    }\r\n\r\n    pair<int,int> fi=kad.minimumCostMaximumFlow(1,n);\r\n    vector<int>naya;\r\n    int sz=temp.size();\r\n    naya.push_back(0);\r\n    vector<int>pre(sz+1,0);\r\n\r\n    for(int i=0;i<sz-1;i++)\r\n    {\r\n        naya.push_back(naya.back()+(temp[i+1]-temp[i])*(i+1));\r\n        pre[i]=temp[i];\r\n        if(i)\r\n            pre[i]+=pre[i-1];\r\n    }\r\n    pre[sz-1]=temp[sz-1];\r\n    if(sz-1)\r\n        pre[sz-1]+=pre[sz-2];\r\n\r\n    int q;\r\n    cin>>q;\r\n\r\n    while(q--)\r\n    {\r\n        cin>>x;\r\n        int l=0,r=sz-1;\r\n        int mx=0;\r\n        while(l<=r)\r\n        {\r\n            int mid=l+(r-l)/2;\r\n            if(x>=naya[mid])\r\n            {\r\n                l=mid+1;\r\n                mx=max(mx,mid);\r\n            }\r\n            else\r\n                r=mid-1;\r\n        }\r\n        long double ans=pre[mx]+x;\r\n        ans/=(mx+1);\r\n        cout<<fixed<<setprecision(10)<<ans<<'\\n';\r\n    }\r\n\r\n}"
}