{
    "id": 149924485,
    "contestId": 1307,
    "creationTimeSeconds": 1647525328,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1307,
        "index": "G",
        "name": "Cow and Exercise",
        "type": "PROGRAMMING",
        "points": 3500.0,
        "rating": 3100,
        "tags": [
            "flows",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 1307,
        "members": [
            {
                "handle": "arvindf232"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1581953700
    },
    "programmingLanguage": "Kotlin 1.5",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 170,
    "memoryConsumedBytes": 0,
    "source": "\r\nimport java.io.BufferedInputStream\r\nimport java.io.File\r\nimport java.io.PrintWriter\r\nimport java.util.*\r\nimport kotlin.system.measureTimeMillis\r\n\r\ninline fun TIME(f:()->Unit){\r\n    val t = measureTimeMillis(){\r\n        f()\r\n    }\r\n    println(\"$t ms\")\r\n}\r\n\r\nobject IO{\r\n    private const val BS = 1 shl 16\r\n    private const val NC = 0.toChar()\r\n    private val buf = ByteArray(BS)\r\n    private var bId = 0\r\n    private var size = 0\r\n    private var c = NC\r\n\r\n    var warningActive = true\r\n    var fakein = StringBuilder()\r\n\r\n    private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)\r\n    val OUT: PrintWriter = PrintWriter(System.out)\r\n\r\n    private val char: Char\r\n        get() {\r\n            while (bId == size) {\r\n                size = IN.read(buf) // no need for checked exceptions\r\n                if (size == -1) return NC\r\n                bId = 0\r\n            }\r\n            return buf[bId++].toChar()\r\n        }\r\n\r\n    fun nextInt(): Int {\r\n        var neg = false\r\n        if (c == NC) c = char\r\n        while (c < '0' || c > '9') {\r\n            if (c == '-') neg = true\r\n            c = char\r\n        }\r\n        var res = 0\r\n        while (c in '0'..'9') {\r\n            res = (res shl 3) + (res shl 1) + (c - '0')\r\n            c = char\r\n        }\r\n        return if (neg) -res else res\r\n    }\r\n    fun nextLong(): Long {\r\n        var neg = false\r\n        if (c == NC) c = char\r\n        while (c < '0' || c > '9') {\r\n            if (c == '-') neg = true\r\n            c = char\r\n        }\r\n        var res = 0L\r\n        while (c in '0'..'9') {\r\n            res = (res shl 3) + (res shl 1) + (c - '0')\r\n            c = char\r\n        }\r\n        return if (neg) -res else res\r\n    }\r\n    fun nextString():String{\r\n        val ret = StringBuilder()\r\n        while (true){\r\n            c = char\r\n            if(!isWhitespace(c)){ break}\r\n        }\r\n        ret.append(c)\r\n        while (true){\r\n            c = char\r\n            if(isWhitespace(c)){ break}\r\n            ret.append(c)\r\n        }\r\n        return ret.toString()\r\n    }\r\n    fun isWhitespace(c:Char):Boolean{\r\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t'\r\n    }\r\n    fun rerouteInput(){\r\n        if(warningActive){\r\n            put(\"You forgot to disable tests you digital dummy!\")\r\n            println(\"You forgot to disable tests you digital dummy!\")\r\n            warningActive = false\r\n        }\r\n        val S = fakein.toString()\r\n        println(\"New Case \")\r\n        println(S.take(80))\r\n        println(\"...\")\r\n        fakein.clear()\r\n        IN = BufferedInputStream(S.byteInputStream(),BS)\r\n    }\r\n    fun takeFile(name:String){\r\n        IN = BufferedInputStream(File(name).inputStream(),BS)\r\n    }\r\n}\r\nfun put(aa:Any){ IO.OUT.println(aa)}\r\nfun done(){ IO.OUT.close() }\r\nfun share(aa:Any){\r\n    if(aa is IntArray){IO.fakein.append(aa.joinToString(\" \"))}\r\n    else if(aa is LongArray){IO.fakein.append(aa.joinToString(\" \"))}\r\n    else if(aa is List<*>){IO.fakein.append(aa.toString())}\r\n    else{IO.fakein.append(aa.toString())}\r\n    IO.fakein.append(\"\\n\")\r\n}\r\n\r\nval getint:Int get() = IO.nextInt()\r\nval getlong:Long get() = IO.nextLong()\r\nval getstr:String get() = IO.nextString()\r\nfun getline(n:Int):IntArray{\r\n    return IntArray(n){getint}\r\n}\r\nfun getlineL(n:Int):LongArray{\r\n    return LongArray(n){getlong}\r\n}\r\nfun getbinary(n:Int, asTrue:Char):BooleanArray{\r\n    val str = getstr\r\n    return BooleanArray(n){str[it] == asTrue}\r\n}\r\n\r\nval List<Char>.ret:String\r\nget() = this.joinToString(\"\")\r\nvar dmark = -1\r\ninfix fun Any.dei(a:Any){\r\n    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators\r\n    dmark++\r\n    var str = \"<${dmark}>   \"\r\n    debug()\r\n    if(this is String){ str += this\r\n    }else if(this is Int){ str += this.toString()\r\n    }else if(this is Long){ str += this.toString()\r\n    }else{ str += this.toString()}\r\n    if(a is List<*>){ println(\"$str : ${a.joinToString(\" \")}\")\r\n    }else if(a is IntArray){ println(\"$str : ${a.joinToString(\" \")}\")\r\n    }else if(a is LongArray){ println(\"$str : ${a.joinToString(\" \")}\")\r\n    }else if(a is BooleanArray){ println(\"$str :${a.map{if(it)'1' else '0'}.joinToString(\" \")}\")\r\n    }else if(a is Array<*>){\r\n        println(\"$str : \")\r\n        for(c in a){if(c is IntArray){println(c.joinToString(\" \"))}\r\n        else if(c is LongArray){println(c.joinToString(\" \"))}\r\n        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(\"\"))\r\n        }\r\n\r\n        }\r\n        println()\r\n    }else{ println(\"$str : $a\")\r\n    }\r\n}\r\nval just = \" \" // usage: just dei x , where x is the debug variable\r\nfun crash(){\r\n    throw Exception(\"Bad programme\")} // because assertion does not work\r\nfun assert(a:Boolean){\r\n    if(!a){\r\n        throw Exception(\"Failed Assertion\")\r\n    }}\r\nenum class solveMode {\r\n    real, rand, tc\r\n}\r\nobject solve{\r\n    var mode:solveMode = solveMode.real\r\n    var tcNum:Int = 0\r\n    var rand:()->Unit = {}\r\n    var TC:MutableMap<Int,()->Unit> = mutableMapOf()\r\n    var answersChecked = 0\r\n    var tn:Long = 0\r\n    fun cases(onecase:()->Unit){\r\n        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount\r\n        //safety checks\r\n        if(pI != 998_244_353 && pI != 1_000_000_007){\r\n            throw Exception(\"Modding a wrong prime!\")\r\n        }\r\n        if(withBruteForce){\r\n            println(\"Brute force is active\")\r\n        }\r\n\r\n        if(t == 1 && mode != solveMode.real){\r\n            tn = System.currentTimeMillis()\r\n        }\r\n        repeat(t){\r\n            if(mode == solveMode.tc){\r\n                TC[tcNum]?.let { it() }\r\n                IO.rerouteInput()\r\n            }else if(mode == solveMode.rand){\r\n                rand()\r\n                IO.rerouteInput()\r\n            }\r\n            onecase()\r\n        }\r\n        if(t == 1 && mode != solveMode.real){\r\n            val dt = System.currentTimeMillis() - tn\r\n            println(\"Time $dt ms \")\r\n        }\r\n    }\r\n    inline fun singleCase(a:solve.()->Unit){\r\n        val t = if(mode != solveMode.rand){1} else randCount\r\n        repeat(t) { a() }\r\n    }\r\n    fun rand(a:()->Unit){\r\n        this.rand = a\r\n    }\r\n    fun tc(id:Int = 0,a:()->Unit){\r\n        TC[id] = a\r\n    }\r\n    fun usetc(a:Int = 0 ){\r\n        this.tcNum = a\r\n        this.mode = solveMode.tc\r\n    }\r\n    fun userand(){\r\n        this.mode = solveMode.rand\r\n    }\r\n}\r\ninline fun<T> T.alsoBrute(cal:() -> T){\r\n    if(!withBruteForce) return\r\n    val also = cal()\r\n    if(this != also){\r\n        println(\"Checking failed: Got ${this} Brute ${also}\")\r\n        crash()\r\n    }\r\n}\r\n// 1. Modded\r\nconst val p = 1000000007L\r\nconst val pI = p.toInt()\r\nfun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }\r\nfun Int.snap():Int{ if(this >= pI){return this - pI} else return this}\r\ninfix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }\r\ninfix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }\r\n// 2. DP initial values\r\nconst val plarge = 1_000_000_727\r\nconst val nlarge = -plarge\r\nconst val phuge = 2_727_000_000_000_000_000L\r\nconst val nhuge = -phuge\r\n// 3. conveniecen conversions\r\nval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function\r\nval Char.code :Int get() = this.toInt() -  'a'.toInt()\r\n//3. hard to write stuff\r\nfun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }\r\nval mint:MutableList<Int> get() = mutableListOf<Int>()\r\nval mong:MutableList<Long> get() = mutableListOf<Long>()\r\n//4. more outputs\r\nfun List<Char>.conca():String = this.joinToString(\"\")\r\nval CharArray.conca :String get() = this.joinToString(\"\")\r\nval IntArray.conca :String get() = this.joinToString(\" \")\r\n@JvmName(\"concaInt\")\r\nfun List<Int>.conca():String = this.joinToString(\" \")\r\nval LongArray.conca:String get() = this.joinToString(\" \")\r\n@JvmName(\"concaLong\")\r\nfun List<Long>.conca():String = this.joinToString(\" \")\r\n//5. Pair of ints\r\nconst val longmask = (1L shl 32) - 1\r\nfun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonly\r\nval Long.first get() = (this ushr 32).toInt()\r\nval Long.second get() = this.toInt()\r\n//6. strings\r\nval String.size get() = this.length\r\nconst val randCount = 100\r\nconst val graphWeighed = true\r\nprivate typealias ei = Int\r\nprivate typealias earr = IntArray\r\n//NOT batle tested\r\nclass fastDeque(val l:Int, val r:Int) {\r\n    val total = r - l + 1\r\n    val st = earr(total)\r\n    var startpointer = 0 - l\r\n    var endpointer = startpointer - 1\r\n    val size: Int get() = endpointer - startpointer + 1\r\n\r\n    fun isEmpty(): Boolean {\r\n        return endpointer < startpointer\r\n    }\r\n    fun isNotEmpty():Boolean{\r\n        return endpointer >= startpointer\r\n    }\r\n    fun first():ei{\r\n        assert(isNotEmpty())\r\n        return st[startpointer]\r\n    }\r\n    fun last():ei{\r\n        assert(isNotEmpty())\r\n        return st[endpointer]\r\n    }\r\n    fun addFirst(v:ei ){\r\n        startpointer --\r\n        st[startpointer]= v\r\n    }\r\n    fun addLast(v:ei){\r\n        endpointer ++\r\n        st[endpointer] = v\r\n    }\r\n    fun removeFirst(): Int {\r\n        assert(isNotEmpty())\r\n        val ret = st[startpointer]\r\n        startpointer ++\r\n        return ret\r\n    }\r\n    fun removeLast(): Int {\r\n        assert(isNotEmpty())\r\n        val ret = st[endpointer]\r\n        endpointer --\r\n        return ret\r\n    }\r\n    fun toArray():earr{\r\n        return st.sliceArray(startpointer..endpointer)\r\n    }\r\n    fun toList():List<ei>{\r\n        return st.slice(startpointer..endpointer)\r\n    }\r\n\r\n    inline fun forEach(act:(v:ei)->Unit){\r\n        for(i in startpointer..endpointer){\r\n            act(st[i])\r\n        }\r\n    }\r\n    inline fun withIndex(act:(i:Int,v:ei)->Unit){\r\n        for(i in startpointer..endpointer){\r\n            act(i-startpointer,st[i])\r\n        }\r\n    }\r\n}\r\nfun fastEmptyList(max:Int):fastDeque{\r\n    return fastDeque(0,max-1)\r\n}\r\ninline fun makegraph(n:Int, m:Int, directed:Boolean, doit: NewGraph.() ->Unit): NewGraph {\r\n    val G = NewGraph(n,m,directed)\r\n    G.doit()\r\n    return G\r\n}\r\nfun makeTree(n:Int): NewGraph {\r\n    val G = makegraph(n,n-1,false){\r\n        repeat(n-1){\r\n            add(getint - 1 , getint - 1 )\r\n        }\r\n    }\r\n    G.treeOrderDFS(true)\r\n    return G\r\n}\r\nclass NewGraph(val n:Int, val m:Int, val directed:Boolean) {\r\n    val maxedge = if (directed) m else m * 2\r\n\r\n    var cnt = -1\r\n\r\n    val edgecount:Int get() = cnt + 1\r\n\r\n    val next = IntArray(maxedge)\r\n    val head = IntArray(n) { -1 }\r\n    val to = IntArray(maxedge)\r\n    val from = IntArray(maxedge)\r\n    val weights = IntArray(if (graphWeighed) m else 0)\r\n    private fun primitive_add(u: Int, v: Int): Int {\r\n        next[++cnt] = head[u]\r\n        head[u] = cnt\r\n        to[cnt] = v\r\n        from[cnt] = u\r\n        return cnt\r\n    }\r\n\r\n    fun add(u: Int, v: Int): Int {\r\n        val e = primitive_add(u, v)\r\n        if (!directed) {\r\n            primitive_add(v, u)\r\n        }\r\n        return if (directed) e else e shr 1\r\n    }\r\n\r\n    fun addWeighted(u: Int, v: Int, w: Int):Int{\r\n        val e = add(u, v)\r\n        weights[e] = w\r\n        return e\r\n    }\r\n\r\n    //Basic Transversals\r\n    inline fun NS(a:Int, act:(Int)->Unit){\r\n        var i= head[a]\r\n        while(i != -1){\r\n            act(to[i])\r\n            i = next[i]\r\n        }\r\n    }\r\n    inline fun NS_E(a:Int, act:(e:Int,v:Int)->Unit){\r\n        var i= head[a]\r\n        while(i != -1){\r\n            act(i,to[i])\r\n            i = next[i]\r\n        }\r\n    }\r\n\r\n    // twice for undirected\r\n    inline fun everyEdge(act:(a:Int, b:Int)->Unit){\r\n        for(e in 0 until edgecount){\r\n            act(from[e], to[e])\r\n        }\r\n    }\r\n\r\n    //2 Basic Transversals\r\n    var root = 0\r\n    var preorder:IntArray = IntArray(0)\r\n    var parent:IntArray = IntArray(0)\r\n    val hasDFSorder:Boolean get() = preorder.size == n\r\n    var parentEdge:IntArray = IntArray(0)\r\n\r\n    var entryTime:IntArray = IntArray(0)\r\n    var exitTime:IntArray = IntArray(0)\r\n\r\n    //stores the order\r\n    fun treeOrderDFS(withEdges:Boolean = false){\r\n        parent = IntArray(n){-1}\r\n        var pt = -1\r\n        preorder = IntArray(n){-1}\r\n        if(withEdges) parentEdge = IntArray(n){-1}\r\n\r\n        val Q = fastDeque(0,n)\r\n        parent[root] = root\r\n        Q.addLast(root)\r\n        while(Q.isNotEmpty()){\r\n            val a = Q.removeLast()\r\n            val p = parent[a]\r\n            preorder[++pt] = a\r\n            NS_E(a){e,v ->\r\n                if(v == p) return@NS_E\r\n                if(withEdges) parentEdge[v] = if(directed) e else (e shr 1)\r\n                parent[v] = a\r\n                Q.addLast(v)\r\n            }\r\n        }\r\n    }\r\n    fun trueOrderDFS(){\r\n\r\n    }\r\n\r\n    //One off, does not store order\r\n    inline fun anyOrderExplore(root:Int?,newroot:(r:Int) ->Unit, act:(form:Int, to:Int, root:Int, e:Int, spanning:Boolean)->Unit) {\r\n        // null -> Exhaust\r\n        parent = IntArray(n){-1}\r\n        val explored = BooleanArray(n)\r\n        val Q = fastDeque(0,n)\r\n        for(i in 0 until n){\r\n            if(explored[i] || (root != null && root != i) ) continue\r\n            newroot(i)\r\n            Q.addLast(i)\r\n            parent[i] = i\r\n            while(Q.isNotEmpty()){\r\n                val a = Q.removeLast()\r\n                NS_E(a) { e,v ->\r\n                    if (v == parent[v]) return@NS_E\r\n                    val newedge = !explored[v]\r\n                    if (newedge) {\r\n                        parent[v] = a\r\n                        Q.addLast(v)\r\n                        explored[v] = true\r\n                    }\r\n                    act(a, v, i, e,newedge)\r\n                }\r\n            }\r\n            if(root != null) break\r\n        }\r\n    }\r\n    fun EulerDoubleOrder(): Pair<IntArray, IntArray> {\r\n        var pointer = 0\r\n        val euler = IntArray(2 * n - 1)\r\n        val entry = IntArray(n)\r\n        fun dfs(v:Int, p:Int) {\r\n            euler[++pointer] = v\r\n            entry[v] = pointer\r\n            NS(v){ w->\r\n                if(w == p) return@NS\r\n                dfs(w,p)\r\n                euler[++pointer] = v\r\n            }\r\n        }\r\n        dfs(root,-1)\r\n        return Pair(euler, entry)\r\n    }\r\n    inline fun BFS(distRoot:Int, reached:(Int, Int)->Unit = {_,_ ->}): IntArray {\r\n        val toDo = fastDeque(0,n)\r\n        val explored = IntArray(n+1){-1} // also store parents\r\n        toDo.addLast(distRoot)\r\n        explored[distRoot] = -2\r\n        val dist = IntArray(n){-1}\r\n        dist[distRoot] = 0\r\n\r\n        while(toDo.size > 0){\r\n            val x = toDo.removeFirst()\r\n            reached(x,explored[x])\r\n            NS(x){ a->\r\n                if(explored[a] == -1){\r\n                    explored[a] = x\r\n                    dist[a] = dist[x] + 1\r\n                    toDo.addLast(a)\r\n                }\r\n            }\r\n        }\r\n        return dist\r\n    }\r\n\r\n\r\n    //standard graph transversal orders\r\n    inline fun leafFirst(act:(Int)->Unit){\r\n        if(!hasDFSorder) treeOrderDFS()\r\n        for(i in preorder.lastIndex downTo 0){\r\n            act(preorder[i])\r\n        }\r\n    }\r\n    inline fun rootFirst(act:(Int)->Unit){\r\n        if(!hasDFSorder) treeOrderDFS()\r\n        for(a in preorder){\r\n            act(a)\r\n        }\r\n    }\r\n    inline fun anyOrder(act:(Int)->Unit){\r\n        for(i in 0 until n){\r\n            act(i)\r\n        }\r\n    }\r\n    inline fun rootFirstEdge(act:(from:Int, to:Int, e:Int)->Unit){\r\n        if(!hasDFSorder) treeOrderDFS()\r\n        for(i in 1 until preorder.size){\r\n            val v = preorder[i]\r\n            act(parent[v],v,parentEdge[v])\r\n        }\r\n    }\r\n\r\n    // Basic invariants maintaining\r\n    fun calculateSizes():IntArray{\r\n        val ret = IntArray(n){1}\r\n        leafFirst { v -> if(v != root) ret[parent[v]] += ret[v] }\r\n        return ret\r\n    }\r\n    fun calculateSubtreeSum(weights:IntArray){\r\n        leafFirst { v -> if(v != root) weights[parent[v]] += weights[v] }\r\n    }\r\n    fun calculateDepth(): IntArray {\r\n        val ret = IntArray(n)\r\n        rootFirst { v -> if(v != root) ret[v] = ret[parent[v]] + 1  }\r\n        return ret\r\n    }\r\n    inline fun subs(v:Int, act:(Int)->Int){\r\n        NS(v){w ->\r\n            if(w != parent[v]) act(w)\r\n        }\r\n    }\r\n    fun calculateDepthWeighted(): LongArray {\r\n        val ret = LongArray(n)\r\n        rootFirstEdge{from,to,e -> ret[to] = ret[from] + weights[e]}\r\n        return ret\r\n    }\r\n    fun outdegree():IntArray{\r\n        val ret = IntArray(n)\r\n        everyEdge { a, b -> ret[a] ++  }\r\n        return ret\r\n    }\r\n    fun indegree():IntArray{\r\n        val ret = IntArray(n)\r\n        everyEdge {a, b -> ret[b] ++}\r\n        return ret\r\n    }\r\n    fun degree():IntArray = outdegree()\r\n\r\n//    init{\r\n//        treeOrderDFS(false)\r\n//    }\r\n\r\n//    val depth = calculateDepth()\r\n\r\n\r\n}\r\nfun NewGraph.denseDijstrak(root:Int): IntArray{\r\n    val d = IntArray(n){Int.MAX_VALUE}\r\n//    val p =\r\n    val u = BooleanArray(n)\r\n    d[root] = 0\r\n    for(i in 0 until n){\r\n        var v = -1\r\n        for(j in 0 until n){\r\n            if(!u[j] && (v == -1 || d[j] < d[v])){\r\n                v = j\r\n            }\r\n        }\r\n        if(d[v] == Int.MAX_VALUE){\r\n            break\r\n        }\r\n        u[v] = true\r\n        NS_E(v){e,w ->\r\n            val dis = weights[e]\r\n            if(d[v] + dis < d[w]){\r\n                d[w] = d[v] + dis\r\n//                p[to] = v\r\n            }\r\n        }\r\n    }\r\n    return d\r\n}\r\nfun debug(){}\r\nconst val withBruteForce = false\r\nconst val singleCase = true\r\n\r\n\r\ninline fun BinarySearchFirstTrue(l:Int,r:Int,isTrue:(Int)->Boolean):Int?{\r\n    //inclusive\r\n    var L = l\r\n    var R = r\r\n    while(L<R){\r\n        val m = (L + R) shr 1\r\n        if(isTrue(m)){\r\n            R = m\r\n        }else{\r\n            L = m + 1\r\n        }\r\n    }\r\n    return if(isTrue(L)){\r\n        L\r\n    }else{\r\n        if(L == r){\r\n            null\r\n        }else{\r\n            L + 1\r\n        }\r\n    }\r\n}\r\n\r\ninline fun BinarySearchLastTrue(l:Int,r:Int,isTrue:(Int)->Boolean):Int?{\r\n    //inclusive\r\n    var L = l\r\n    var R = r\r\n    while(L<R){\r\n       val m = ((L + R) shr 1) + 1\r\n        if(isTrue(m)){ L = m }else{ R = m - 1 }\r\n    }\r\n    return if(isTrue(L)){ L }else{ null }\r\n}\r\nclass DinicEdge(var v1: Int, var v2: Int, var cap: Int, var flow: Int) {\r\n    var rev: DinicEdge? = null\r\n}\r\n\r\nclass Dinic(var n: Int) {\r\n    // Queue for the top level BFS.\r\n    var q:ArrayDeque<Int>\r\n\r\n    // Stores the graph.\r\n    var adj: Array<MutableList<DinicEdge>>\r\n\r\n    // s = source, t = sink\r\n    var s: Int\r\n    var t: Int\r\n\r\n    // For BFS.\r\n    var blocked: BooleanArray\r\n    var dist: IntArray\r\n\r\n    // Just adds an edge and ALSO adds it going backwards.\r\n    fun add(v1: Int, v2: Int, cap: Int, flow: Int) {\r\n        val e = DinicEdge(v1, v2, cap, flow)\r\n        val rev = DinicEdge(v2, v1, 0, 0)\r\n        adj[v1].add(e.also { rev.rev = it })\r\n        adj[v2].add(rev.also { e.rev = it })\r\n    }\r\n\r\n    // Runs other level BFS.\r\n    fun bfs(): Boolean {\r\n\r\n        // Set up BFS\r\n        q.clear()\r\n        Arrays.fill(dist, -1)\r\n        dist[t] = 0\r\n        q.add(t)\r\n\r\n        // Go backwards from sink looking for source.\r\n        // We just care to mark distances left to the sink.\r\n        while (!q.isEmpty()) {\r\n            val node = q.poll()\r\n            if (node == s) return true\r\n            for (e in adj[node]) {\r\n                if (e.rev!!.cap > e.rev!!.flow && dist[e.v2] == -1) {\r\n                    dist[e.v2] = dist[node] + 1\r\n                    q.add(e.v2)\r\n                }\r\n            }\r\n        }\r\n\r\n        // Augmenting paths exist iff we made it back to the source.\r\n        return dist[s] != -1\r\n    }\r\n\r\n    // Runs inner DFS in Dinic's, from node pos with a flow of min.\r\n    fun dfs(pos: Int, min: Int): Int {\r\n\r\n        // Made it to the sink, we're good, return this as our max flow for the augmenting path.\r\n        if (pos == t) return min\r\n        var flow = 0\r\n\r\n        // Try each edge from here.\r\n        for (e in adj[pos]) {\r\n            var cur = 0\r\n\r\n            // If our destination isn't blocked and it's 1 closer to the sink and there's flow, we\r\n            // can go this way.\r\n            if (!blocked[e.v2] && dist[e.v2] == dist[pos] - 1 && e.cap - e.flow > 0) {\r\n\r\n                // Recursively run dfs from here - limiting flow based on current and what's left on this edge.\r\n                cur = dfs(e.v2, Math.min(min - flow, e.cap - e.flow))\r\n\r\n                // Add the flow through this edge and subtract it from the reverse flow.\r\n                e.flow += cur\r\n                e.rev!!.flow = -e.flow\r\n\r\n                // Add to the total flow.\r\n                flow += cur\r\n            }\r\n\r\n            // No more can go through, we're good.\r\n            if (flow == min) return flow\r\n        }\r\n\r\n        // mark if this node is now blocked.\r\n        blocked[pos] = flow != min\r\n\r\n        // This is the flow\r\n        return flow\r\n    }\r\n\r\n    fun flow(): Int {\r\n        clear()\r\n        var ret = 0\r\n\r\n        // Run a top level BFS.\r\n        while (bfs()) {\r\n\r\n            // Reset this.\r\n            Arrays.fill(blocked, false)\r\n\r\n            // Run multiple DFS's until there is no flow left to push through.\r\n            ret += dfs(s, oo)\r\n        }\r\n        return ret\r\n    }\r\n\r\n    // Just resets flow through all edges to be 0.\r\n    fun clear() {\r\n        for (edges in adj) for (e in edges) e.flow = 0\r\n    }\r\n\r\n    companion object {\r\n        const val oo = 1E9.toInt()\r\n    }\r\n    fun getcut():BooleanArray{\r\n        val incut = BooleanArray(n)\r\n        fun dfs(v:Int){\r\n            incut[v] = true\r\n            for(e in adj[v]){\r\n                if(e.flow < e.cap && incut[e.v2]  == false){\r\n                    dfs(e.v2)\r\n                }\r\n            }\r\n        }\r\n        dfs(s)\r\n        return incut\r\n    }\r\n\r\n    // Constructor.\r\n    init {\r\n\r\n        // s is the source, t is the sink, add these as last two nodes.\r\n        s = n++\r\n        t = n++\r\n\r\n        // Everything else is empty.\r\n        blocked = BooleanArray(n)\r\n        dist = IntArray(n)\r\n        q = ArrayDeque()\r\n        adj= Array(n) { mutableListOf<DinicEdge>() }\r\n    }\r\n}\r\n\r\n\r\nfun main(){\r\n    solve.cases{\r\n        val n = getint\r\n        val m = getint\r\n        val G = NewGraph(n,m,true)\r\n\r\n        repeat(m){\r\n            G.addWeighted(getint-1, getint-1, getint )\r\n        }\r\n\r\n        val s = 0\r\n        val t = n-1\r\n        val maxdif = 100\r\n        var used = 0\r\n        val ret = DoubleArray(maxdif)\r\n\r\n        tailrec fun solve(){\r\n            val dist = G.denseDijstrak(s)\r\n            ret[used] = dist[t].toDouble()\r\n            var leastWaste = Int.MAX_VALUE\r\n            val usable = BooleanArray(m){ e ->\r\n                val from = G.from[e]\r\n                val to = G.to[e]\r\n                val w = G.weights[e]\r\n                if(dist[to] == dist[from] + w){\r\n                    true\r\n                }else if(dist[to] > dist[from]){\r\n                    leastWaste = minOf(leastWaste,-(dist[to] - dist[from] - w))\r\n                    false\r\n                }else{\r\n                    false\r\n                }\r\n            }\r\n            val dn = Dinic(G.n)\r\n            dn.add(dn.s,s,10000,0)\r\n            dn.add(t,dn.t,10000,0)\r\n            for(e in 0 until m){\r\n                if(usable[e]){\r\n                    dn.add(G.from[e], G.to[e],1,0)\r\n                }\r\n            }\r\n            val cut = dn.flow()\r\n            val incuts = dn.getcut()\r\n            val alle = mint\r\n            for(e in 0 until m){\r\n                if(!usable[e]) continue\r\n                if(!incuts[G.to[e]] && incuts[G.from[e]]){\r\n                    alle.add(e)\r\n                }\r\n            }\r\n            assert(alle.size == cut)\r\n\r\n            val last = ret[used]\r\n            for(i in 0 until minOf(1L * leastWaste * cut,maxdif.toLong()).toInt()){\r\n                used++\r\n                if(used >= maxdif){\r\n                    return\r\n                }\r\n                ret[used] = last + ((i+1).toDouble() / cut.toDouble())\r\n\r\n            }\r\n\r\n            for(e in alle){\r\n                G.weights[e] += leastWaste\r\n            }\r\n            solve()\r\n        }\r\n\r\n        solve()\r\n//        for((i,v) in ret.withIndex()){\r\n//            i dei v\r\n//        }\r\n        val q = getint\r\n        repeat(q){\r\n            val ask = getint\r\n            put(ret[ask])\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n    done()\r\n}\r\n\r\n/*\r\nRead question wrong\r\ntotally wrong\r\n\r\nat least min cut\r\n\r\nmin cut on critiacl paths !\r\n */\r\n\r\n\r\n"
}