{
    "id": 4519143,
    "contestId": 346,
    "creationTimeSeconds": 1379695715,
    "relativeTimeSeconds": 4715,
    "problem": {
        "contestId": 346,
        "index": "D",
        "name": "Robot Control",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2600,
        "tags": [
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 346,
        "members": [
            {
                "handle": "Egor"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 13,
        "startTimeSeconds": 1379691000
    },
    "programmingLanguage": "Java 7",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 12,
    "timeConsumedMillis": 498,
    "memoryConsumedBytes": 53964800,
    "source": "import java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.io.Writer;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov ([email\u00a0protected])\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tint count = in.readInt();\n\t\tint edgeCount = in.readInt();\n\t\tint[] from = new int[edgeCount];\n\t\tint[] to = new int[edgeCount];\n\t\tIOUtils.readIntArrays(in, from, to);\n\t\tMiscUtils.decreaseByOne(from, to);\n\t\tGraph graph = Graph.createGraph(count, to, from);\n\t\tint[] degree = new int[count];\n\t\tfor (int i : from)\n\t\t\tdegree[i]++;\n\t\tint source = in.readInt() - 1;\n\t\tint destination = in.readInt() - 1;\n\t\tint[] level = new int[count];\n\t\tArrays.fill(level, -1);\n\t\tlevel[destination] = 0;\n\t\tint[] queue = new int[count];\n\t\tint size = 1;\n\t\tqueue[0] = destination;\n\t\tfor (int i = 0; size != 0; i++) {\n\t\t\tIntSet next = new IntHashSet();\n\t\t\tIntSet thisLevel = new IntHashSet();\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint current = queue[j];\n\t\t\t\tfor (int k = graph.firstOutbound(current); k != -1; k = graph.nextOutbound(k)) {\n\t\t\t\t\tint candidate = graph.destination(k);\n\t\t\t\t\tif (level[candidate] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (--degree[candidate] == 0) {\n\t\t\t\t\t\tqueue[size++] = candidate;\n\t\t\t\t\t\tlevel[candidate] = i;\n\t\t\t\t\t\tthisLevel.add(candidate);\n\t\t\t\t\t} else\n\t\t\t\t\t\tnext.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize = 0;\n\t\t\tfor (IntIterator iterator = next.iterator(); iterator.isValid(); iterator.advance()) {\n\t\t\t\tint current = iterator.value();\n\t\t\t\tif (!thisLevel.contains(current)) {\n\t\t\t\t\tlevel[current] = i + 1;\n\t\t\t\t\tqueue[size++] = current;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.printLine(level[source]);\n    }\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n    public void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\t}\n\nclass IOUtils {\n\n\tpublic static void readIntArrays(InputReader in, int[]... arrays) {\n\t\tfor (int i = 0; i < arrays[0].length; i++) {\n\t\t\tfor (int j = 0; j < arrays.length; j++)\n\t\t\t\tarrays[j][i] = in.readInt();\n\t\t}\n\t}\n\n\t}\n\nclass MiscUtils {\n\n    public static void decreaseByOne(int[]...arrays) {\n\t\tfor (int[] array : arrays) {\n\t\t\tfor (int i = 0; i < array.length; i++)\n\t\t\t\tarray[i]--;\n\t\t}\n\t}\n\n\t}\n\nclass Graph {\n\tpublic static final int REMOVED_BIT = 0;\n\n\tprotected int vertexCount;\n\tprotected int edgeCount;\n\n\tprivate int[] firstOutbound;\n\tprivate int[] firstInbound;\n\n\tprivate Edge[] edges;\n\tprivate int[] nextInbound;\n\tprivate int[] nextOutbound;\n\tprivate int[] from;\n\tprivate int[] to;\n\tprivate long[] weight;\n\tprivate long[] capacity;\n\tprivate int[] reverseEdge;\n\tprivate int[] flags;\n\n\tpublic Graph(int vertexCount) {\n\t\tthis(vertexCount, vertexCount);\n\t}\n\n\tpublic Graph(int vertexCount, int edgeCapacity) {\n\t\tthis.vertexCount = vertexCount;\n\t\tfirstOutbound = new int[vertexCount];\n\t\tArrays.fill(firstOutbound, -1);\n\n\t\tfrom = new int[edgeCapacity];\n\t\tto = new int[edgeCapacity];\n\t\tnextOutbound = new int[edgeCapacity];\n\t\tflags = new int[edgeCapacity];\n\t}\n\n\tpublic static Graph createGraph(int vertexCount, int[] from, int[] to) {\n\t\tGraph graph = new Graph(vertexCount, from.length);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addSimpleEdge(from[i], to[i]);\n\t\treturn graph;\n\t}\n\n\tpublic int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {\n\t\tensureEdgeCapacity(edgeCount + 1);\n\t\tif (firstOutbound[fromID] != -1)\n\t\t\tnextOutbound[edgeCount] = firstOutbound[fromID];\n\t\telse\n\t\t\tnextOutbound[edgeCount] = -1;\n\t\tfirstOutbound[fromID] = edgeCount;\n\t\tif (firstInbound != null) {\n\t\t\tif (firstInbound[toID] != -1)\n\t\t\t\tnextInbound[edgeCount] = firstInbound[toID];\n\t\t\telse\n\t\t\t\tnextInbound[edgeCount] = -1;\n\t\t\tfirstInbound[toID] = edgeCount;\n\t\t}\n\t\tthis.from[edgeCount] = fromID;\n\t\tthis.to[edgeCount] = toID;\n\t\tif (capacity != 0) {\n\t\t\tif (this.capacity == null)\n\t\t\t\tthis.capacity = new long[from.length];\n\t\t\tthis.capacity[edgeCount] = capacity;\n\t\t}\n\t\tif (weight != 0) {\n\t\t\tif (this.weight == null)\n\t\t\t\tthis.weight = new long[from.length];\n\t\t\tthis.weight[edgeCount] = weight;\n\t\t}\n\t\tif (reverseEdge != -1) {\n\t\t\tif (this.reverseEdge == null) {\n\t\t\t\tthis.reverseEdge = new int[from.length];\n\t\t\t\tArrays.fill(this.reverseEdge, 0, edgeCount, -1);\n\t\t\t}\n\t\t\tthis.reverseEdge[edgeCount] = reverseEdge;\n\t\t}\n\t\tif (edges != null)\n\t\t\tedges[edgeCount] = createEdge(edgeCount);\n\t\treturn edgeCount++;\n\t}\n\n\tprotected final GraphEdge createEdge(int id) {\n\t\treturn new GraphEdge(id);\n\t}\n\n\tpublic final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {\n\t\tif (capacity == 0) {\n\t\t\treturn addEdge(from, to, weight, 0, -1);\n\t\t} else {\n\t\t\tint lastEdgeCount = edgeCount;\n\t\t\taddEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());\n\t\t\treturn addEdge(from, to, weight, capacity, lastEdgeCount);\n\t\t}\n\t}\n\n\tprotected int entriesPerEdge() {\n\t\treturn 1;\n\t}\n\n\tpublic final int addWeightedEdge(int from, int to, long weight) {\n\t\treturn addFlowWeightedEdge(from, to, weight, 0);\n\t}\n\n\tpublic final int addSimpleEdge(int from, int to) {\n\t\treturn addWeightedEdge(from, to, 0);\n\t}\n\n\tpublic final int firstOutbound(int vertex) {\n\t\tint id = firstOutbound[vertex];\n\t\twhile (id != -1 && isRemoved(id))\n\t\t\tid = nextOutbound[id];\n\t\treturn id;\n\t}\n\n\tpublic final int nextOutbound(int id) {\n\t\tid = nextOutbound[id];\n\t\twhile (id != -1 && isRemoved(id))\n\t\t\tid = nextOutbound[id];\n\t\treturn id;\n\t}\n\n\tpublic final int destination(int id) {\n\t\treturn to[id];\n\t}\n\n\tpublic final boolean flag(int id, int bit) {\n\t\treturn (flags[id] >> bit & 1) != 0;\n\t}\n\n\tpublic final boolean isRemoved(int id) {\n\t\treturn flag(id, REMOVED_BIT);\n\t}\n\n\tprotected void ensureEdgeCapacity(int size) {\n\t\tif (from.length < size) {\n\t\t\tint newSize = Math.max(size, 2 * from.length);\n\t\t\tif (edges != null)\n\t\t\t\tedges = resize(edges, newSize);\n\t\t\tfrom = resize(from, newSize);\n\t\t\tto = resize(to, newSize);\n\t\t\tnextOutbound = resize(nextOutbound, newSize);\n\t\t\tif (nextInbound != null)\n\t\t\t\tnextInbound = resize(nextInbound, newSize);\n\t\t\tif (weight != null)\n\t\t\t\tweight = resize(weight, newSize);\n\t\t\tif (capacity != null)\n\t\t\t\tcapacity = resize(capacity, newSize);\n\t\t\tif (reverseEdge != null)\n\t\t\t\treverseEdge = resize(reverseEdge, newSize);\n\t\t\tflags = resize(flags, newSize);\n\t\t}\n\t}\n\n\tprotected final int[] resize(int[] array, int size) {\n\t\tint[] newArray = new int[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\t\treturn newArray;\n\t}\n\n\tprivate long[] resize(long[] array, int size) {\n\t\tlong[] newArray = new long[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\t\treturn newArray;\n\t}\n\n\tprivate Edge[] resize(Edge[] array, int size) {\n\t\tEdge[] newArray = new Edge[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\t\treturn newArray;\n\t}\n\n\tprotected class GraphEdge implements Edge {\n\t\tprotected int id;\n\n\t\tprotected GraphEdge(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t}\n\n\t}\n\nabstract class IntSet extends IntCollection {\n\t}\n\nclass IntHashSet extends IntSet {\n\tprivate static final Random RND = new Random();\n\tprivate static final int[] SHIFTS = new int[4];\n\tprivate static final byte PRESENT_MASK = 1;\n\n\tstatic {\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tSHIFTS[i] = RND.nextInt(31) + 1;\n\t}\n\n\tprivate int size;\n\tprivate int[] values;\n\tprivate byte[] present;\n\tprivate int step;\n\tprivate int ratio;\n\n\tpublic IntHashSet() {\n\t\tthis(3);\n\t}\n\n\n\tpublic IntHashSet(int capacity) {\n\t\tcapacity = Math.max(capacity, 1);\n\t\tvalues = new int[capacity];\n\t\tpresent = new byte[capacity];\n\t\tratio = capacity;\n\t\tinitStep(capacity);\n\t}\n\n\tprivate void initStep(int capacity) {\n\t\tstep = RND.nextInt(capacity - 2) + 1;\n\t\twhile (IntegerUtils.gcd(step, capacity) != 1)\n\t\t\tstep++;\n\t}\n\n\tpublic IntIterator iterator() {\n\t\treturn new IntIterator() {\n\t\t\tprivate int position = size == 0 ? values.length : -1;\n\n\t\t\tpublic int value() throws NoSuchElementException {\n\t\t\t\tif (position == -1)\n\t\t\t\t\tadvance();\n\t\t\t\tif (position >= values.length)\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\treturn values[position];\n\t\t\t}\n\n\t\t\tpublic void advance() throws NoSuchElementException {\n\t\t\t\tif (position >= values.length)\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\tposition++;\n\t\t\t\twhile (position < values.length && (present[position] & PRESENT_MASK) == 0)\n\t\t\t\t\tposition++;\n\t\t\t}\n\n\t\t\tpublic boolean isValid() {\n\t\t\t\treturn position < values.length;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void add(int value) {\n\t\tensureCapacity((size + 1) * ratio);\n\t\tint current = getHash(value);\n\t\twhile ((present[current] & PRESENT_MASK) != 0) {\n\t\t\tif (values[current] == value)\n\t\t\t\treturn;\n\t\t\tcurrent += step;\n\t\t\tif (current >= values.length)\n\t\t\t\tcurrent -= values.length;\n\t\t}\n\t\tpresent[current] = PRESENT_MASK;\n\t\tvalues[current] = value;\n\t\tsize++;\n\t}\n\n\tprivate int getHash(int value) {\n\t\tint result = value;\n\t\tfor (int i : SHIFTS)\n\t\t\tresult ^= value >> i;\n\t\tresult %= values.length;\n\t\tif (result < 0)\n\t\t\tresult += values.length;\n\t\treturn result;\n\t}\n\n\tprivate void ensureCapacity(int capacity) {\n\t\tif (values.length < capacity) {\n\t\t\tcapacity = Math.max(capacity, 2 * values.length);\n\t\t\trebuild(capacity);\n\t\t}\n\t}\n\n\tprivate void rebuild(int capacity) {\n\t\tinitStep(capacity);\n\t\tint[] oldValues = values;\n\t\tbyte[] oldPresent = present;\n\t\tvalues = new int[capacity];\n\t\tpresent = new byte[capacity];\n\t\tsize = 0;\n\t\tfor (int i = 0; i < oldValues.length; i++) {\n\t\t\tif ((oldPresent[i] & PRESENT_MASK) == PRESENT_MASK)\n\t\t\t\tadd(oldValues[i]);\n\t\t}\n\t}\n\n\tpublic boolean contains(int value) {\n\t\tint current = getHash(value);\n\t\twhile (present[current] != 0) {\n\t\t\tif (values[current] == value && (present[current] & PRESENT_MASK) != 0)\n\t\t\t\treturn true;\n\t\t\tcurrent += step;\n\t\t\tif (current >= values.length)\n\t\t\t\tcurrent -= values.length;\n\t\t}\n\t\treturn false;\n\t}\n\n\n}\n\nabstract class IntCollection {\n\tpublic abstract IntIterator iterator();\n\tpublic abstract void add(int value);\n\n\tpublic boolean contains(int value) {\n\t\tfor (IntIterator iterator = iterator(); iterator.isValid(); iterator.advance()) {\n\t\t\tif (iterator.value() == value)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t}\n\ninterface IntIterator {\n\tpublic int value() throws NoSuchElementException;\n\t/*\n\t * @throws NoSuchElementException only if iterator already invalid\n\t */\n\tpublic void advance() throws NoSuchElementException;\n\tpublic boolean isValid();\n}\n\ninterface Edge {\n\t}\n\nclass IntegerUtils {\n\n    public static int gcd(int a, int b) {\n        a = Math.abs(a);\n        b = Math.abs(b);\n        while (b != 0) {\n            int temp = a % b;\n            a = b;\n            b = temp;\n        }\n        return a;\n    }\n\n    }\n\n"
}