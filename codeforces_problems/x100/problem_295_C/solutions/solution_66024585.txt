{
    "id": 66024585,
    "contestId": 295,
    "creationTimeSeconds": 1575102001,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "its_aks_ulure"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 248,
    "memoryConsumedBytes": 0,
    "source": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CGregAndFriends solver = new CGregAndFriends();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CGregAndFriends {\n        long mod = 1000000007;\n        long INF = (long) 1e18 + 1;\n        PrintWriter out;\n        InputReader in;\n        long[][] nCr = new long[100][100];\n        final Comparator<Tuple> com = new Comparator<Tuple>() {\n            public int compare(Tuple t1, Tuple t2) {\n                if (t1.d != t2.d)\n                    return Long.compare(t1.d, t2.d);\n                else if (t1.x != t2.x)\n                    return Integer.compare(t1.x, t2.x);\n                else if (t2.y != t2.y)\n                    return Integer.compare(t1.y, t2.y);\n                else\n                    return Integer.compare(t1.z, t2.z);\n            }\n        };\n\n        long f(long p, int a, int b, int c, int d) {\n            p *= nCr[a][b];\n            p %= mod;\n            p *= nCr[c][d];\n            p %= mod;\n            return p;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            int K = ni();\n            int cnt1 = 0, cnt2 = 0;\n            int i = 0, j = 0, k = 0;\n            for (i = 0; i < 100; i++) {\n                for (j = 0; j <= i; j++) {\n                    if (j == 0 || j == i)\n                        nCr[i][j] = 1;\n                    else\n                        nCr[i][j] = (nCr[i - 1][j] + nCr[i - 1][j - 1]) % mod;\n                }\n            }\n            for (i = 0; i < n; i++) {\n                if (ni() == 50)\n                    cnt1++;\n                else\n                    cnt2++;\n            }\n            long[][][] dist = new long[200][200][2];\n            long[][][] dp = new long[200][200][2];\n            for (i = 0; i < 200; i++) {\n                for (j = 0; j < 200; j++)\n                    Arrays.fill(dist[i][j], INF);\n            }\n            dist[0][0][0] = 0;\n            dp[0][0][0] = 1;\n            PriorityQueue<Tuple> pq = new PriorityQueue<>(com);\n            pq.add(new Tuple(0, 0, 0, 0));\n            while (pq.size() > 0) {\n                Tuple curr = pq.poll();\n                int x = curr.x;\n                int y = curr.y;\n                int z = curr.z;\n                long d = dist[x][y][z];\n                if (z == 0) {\n                    int rem_x = cnt1 - x;\n                    int rem_y = cnt2 - y;\n                    for (i = 0; i <= rem_x; i++) {\n                        for (j = 0; j <= rem_y; j++) {\n                            if (i + j == 0)\n                                continue;\n                            if (i * 50 + j * 100 > K)\n                                break;\n                            if (dist[i + x][j + y][z ^ 1] >= d + 1) {\n                                if (dist[i + x][j + y][z ^ 1] > d + 1) {\n                                    dist[i + x][j + y][z ^ 1] = d + 1;\n                                    pq.add(new Tuple(dist[i + x][j + y][z ^ 1], i + x, j + y, z ^ 1));\n                                    dp[i + x][j + y][z ^ 1] += f(dp[x][y][z], rem_x, i, rem_y, j);\n                                    dp[i + x][j + y][z ^ 1] %= mod;\n                                } else {\n                                    dp[i + x][j + y][z ^ 1] += f(dp[x][y][z], rem_x, i, rem_y, j);\n                                    dp[i + x][j + y][z ^ 1] %= mod;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    int rem_x = x;\n                    int rem_y = y;\n                    for (i = 0; i <= rem_x; i++) {\n                        for (j = 0; j <= rem_y; j++) {\n                            if (i + j == 0)\n                                continue;\n                            if (i * 50 + j * 100 > K)\n                                break;\n                            if (dist[x - i][y - j][z ^ 1] >= d + 1) {\n                                if (dist[x - i][y - j][z ^ 1] > d + 1) {\n                                    dist[x - i][y - j][z ^ 1] = d + 1;\n                                    pq.add(new Tuple(dist[x - i][y - j][z ^ 1], x - i, y - j, z ^ 1));\n                                    dp[x - i][y - j][z ^ 1] += f(dp[x][y][z], rem_x, i, rem_y, j);\n                                    dp[x - i][y - j][z ^ 1] %= mod;\n                                } else {\n                                    dp[x - i][y - j][z ^ 1] += f(dp[x][y][z], rem_x, i, rem_y, j);\n                                    dp[x - i][y - j][z ^ 1] %= mod;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (dist[cnt1][cnt2][1] == INF)\n                pn(-1);\n            else\n                pn(dist[cnt1][cnt2][1]);\n            pn(dp[cnt1][cnt2][1]);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        class Tuple {\n            long d;\n            int x;\n            int y;\n            int z;\n\n            Tuple(long d, int x, int y, int z) {\n                this.d = d;\n                this.x = x;\n                this.y = y;\n                this.z = z;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
}