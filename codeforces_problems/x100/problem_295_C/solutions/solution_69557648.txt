{
    "id": 69557648,
    "contestId": 295,
    "creationTimeSeconds": 1580030831,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "yan-zp"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 434,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853; \n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int INF = 0x3f3f3f3f;\nint n,k;\nint a=0,b=0;\n\nconst int N = 55; \nmint c[N][N];\nvoid prep() {\n    c[0][0] = 1;\n    for (int i = 1; i < N; i++) {\n        c[i][0] = 1;\n        for (int j = 1; j < N; j++) {\n            c[i][j] = c[i-1][j-1] + c[i-1][j];\n        }\n    }\n}\nbool ok[N][N];\npair<int,mint> dp[N][N];\npair<int,mint> calc(int i, int j) {\n    if (ok[i][j]) return dp[i][j];\n    int mi = INF;\n    mint way = 0;\n    for (int x = 0; x <= i; x++) {\n        for (int y = 0; y <= j && x+2*y <= k; y++) {\n            if (x||y) {\n                if (x+y == i+j) {\n                    mi = 1; way = 1;\n                } else {\n                    mint go = c[i][x] * c[j][y];\n                    int ri = a - (i-x);\n                    int rj = b - (j-y);\n                    for (int _i = 0; _i <= ri; _i++) {\n                        for (int _j = 0; _j <= rj && _i+2*_j < x+2*y; _j++) {\n                            if (_i||_j) {\n                                auto p = calc(i-x+_i, j-y+_j);\n                                if (p.first+2 < mi) {\n                                    mi = p.first + 2;\n                                    way = p.second * go * c[ri][_i] * c[rj][_j];\n                                } else if (p.first+2 == mi) {\n                                    way += p.second * go * c[ri][_i] * c[rj][_j];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ok[i][j] = true;\n    return dp[i][j] = {mi, way};\n}\nvoid solve() {\n    prep();\n    cin >> n >> k; k/=50;\n    for (int _ = 0; _ < n; _++) {\n        int x; cin >> x;\n        assert(x==50||x==100);\n        x==50? a++ : b++;\n    }\n    //n = 50, a = 25, b = 25, k = 3;\n    int ride; mint way;\n    tie(ride, way) = calc(a,b);\n    if (ride < INF) {\n        cout << ride << '\\n' << way;\n    } else {\n        cout << \"-1\\n0\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    return 0;\n}\n"
}