{
    "id": 85597278,
    "contestId": 295,
    "creationTimeSeconds": 1593586234,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "Yui_Yuigahama"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 2457600,
    "source": "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n \n#define fast { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n#define pb push_back\n#define ll long long\n#define ld long double\n#define sz(x) (ll)x.size()\n \n#define vi vector<int>\n#define vl vector<long>\n#define vll vector<long long>\n \n#define infi INT_MAX\n#define infl LONG_LONG_MAX\n#define infd LDBL_MAX\n#define f(i,a,b) for(ll i=a;i<b;i++)\n#define fi(i,a,b) for(ll i=(b-1);i>=a;i--)\n#define F first\n#define S second\n#define G(a,b) get<a>(b)\n#define MP make_pair\n#define MT make_tuple\n#define pll pair<ll,ll>\n//#define endl \"\\n\"\n#define ALL(v) v.begin(),v.end()\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<x;\n#define pr1(x) cout<<x<<\" \";\n#define pr2(x,y) cout<<x<<\" \"<<y;\n#define pr3(x,y,z) cout<<x<<\" \"<<y<<\" \"<<z;\n#define pr4(x,y,z,w) cout<<x<<\" \"<<y<<\" \"<<z<<\" \"<<w;\n#define deb printf(\"***************************************************************************************\\n\");\n#define moshi printf(\"moshi moshi ! \\n\");\n#define hi printf(\"hi ! \\n\");\n#define bye printf(\"bye bye ! \\n\");\n#define o_set(ll) tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>\n#define number_of_set_bits  __builtin_popcountll\nconst ld PI=3.1415926535897932384626433;\n \n//template<typename T>\n//#define o_set(T) tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>\n//member functions :\n//1. order_of_key(k) : number of elements strictly lesser than k\n//2. find_by_order(k) : k-th element in the set\n \n \n//const ll N=1e6+7;\nll p=1e9+7;\n//ll fac[N];\n \nll gcd(ll a, ll b)\n{\n   if (a == 0) return b;\n   return gcd(b % a, a);\n}\n \ninline ll ceil(ll a,ll b)\n{\n   return (a+b-1)/b;\n}\n \nll max(ll x,ll y,ll z)\n{\n   return max(x,max(y,z));\n}\n \nll min(ll x,ll y,ll z)\n{\n   return min(x,min(y,z));\n}\n \n \nll modpro(ll x,ll y,ll z=1)\n{\n   x%=p;\n   y%=p;\n   z%=p;\n   ll res=(x*y)%p;\n   res=(res*z)%p;\n   return res;\n}\n \nll modadd(ll x,ll y,ll z=0)\n{\n   x%=p;\n   y%=p;\n   z%=p;\n   ll res=(x+y)%p;\n   res=(res+z)%p;\n   return res;\n}\n \n \nll pow_mod_p(ll a,ll b)\n{\n   a=a%p;\n   ll res=1;\n   while(b>0)\n   {\n     if(b&1) res=(res*a)%p;\n     b=b>>1;\n     a=(a*a)%p;\n   }\n   return res;\n}\n \ninline ll mod_inv(ll x)\n{\n   return pow_mod_p(x,p-2);\n}\n\nconst ll N=150;\nll fac[N];\n \nvoid set_fac()\n{\n  fac[0]=fac[1]=1;\n  f(i,2,N) fac[i]=(fac[i-1]*i)%p;\n}\n\n// Don't forget to set fac[0]=1\nll nCr(ll x,ll y)\n{\n   if(x<y) return 0;\n   ll res=fac[x];\n   ll den=(fac[y]*fac[x-y])%p;\n   ll deni=mod_inv(den);\n   res=(res*deni)%p;\n   return res;\n}\n \n \nll is_set(ll a,ll i)\n{\n   if( ( a & ((ll)1<<i) ) == 0 ) return 0;\n   else return 1;\n}\n \n \n \n//  Comparator should follow :\n//  1: x<=y or y<=x uniquely\n//  2: Transitivity : a<=b and b<=c implies a<=c\n//  3: Anti-Symmetry: a<=b and b<=a implies a=b\n// return 1 to put x before y in sorted order\ninline bool comp(pll &x,pll &y)\n{\n   if(x.F<y.F) return 1;\n   else if(x.F==y.F)\n   {\n      if(x.S>y.S) return 1;\n      else return 0;\n   }\n   return 0;\n}\n \n \nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n \n// resize : str.resize(new_size)   new size <= old size\n \n// for Vector :\n// lower_bound(starting iterator , iterator next to end , value)  :  iterator to first element greater than or equal to value\n// upper_bound(starting iterator , iterator next to end , value)  :  iterator to first element strictly greater than value\n \n// For Set :      s.lower_bound(value)\n// if no such element exists they return  vector.end() or s.end()\n \n \n// x bits : [x-1 , x-2 , .... , 1(1st bit) , 0(0th bit)] =>   leftmost 1 at 2^(x-1)    max number that can be represented : 2^(x) -1\n// 63 bits is greater than 10^18\n \n// 1<<x  :  2 ^ x  (left shift)\n \n// Min heap :  priority_queue < ll , vector<ll>, greater<ll> > q\n// Max heap :  priority_queue < ll > q\n    // Set in descending order  :   set< ll,greater <ll> >\n \n \n// While debugging :\n// 1 : check if array size is correct  :  It may give unexpected results\n// 2 : check if you have swapped i and j at some part of program\n// 3 : for string check if you are trying to acces  index = -1\n \n \n// Bitwise Tricks :\n// 1 : While using 1<<i  use (ll)1<<i  because in former one \"1\" is considered as int\n// 2 : To flip first k-bits of a number :  x xor (2^k-1)  or x ^ (((ll)1<<k)-1)  : 2^k-1 is the largest number of k bits\n// 3 : To flip k-th bit (0-based)  :  x xor (2^k)  or  x ^ ((ll)1<<k)\n// 4 : To set k-th bit (0-based)   :  x or (2^k)   or  x | ((ll)1<<k)\n// 5 : To un-set k-th bit (0-based)   :  x & (~ ((ll)1<<k) )\n \n \n// To prove Greedy :\n// 1 : Optimal Choice at each step\n// 2 : Exchange Argument\n// 3 : Find a lower or upper bound on answer and then construct an answer for that bound\n// 4 : Find properties which Optimal Solution must satisfy ( This can be useful to deduce form of Optimal answer)\n \n// Erase one occurrence in multiset : it=s.find(element)   s.erase(it)\n// putchar('a'+j) : to print (j+1)th character\n// getline(cin,str) : To input string until newline\n \n \nvoid lps(string &pp,ll *lps)\n{\n   ll xx=pp.length();\n   //ll lps[xx]={};\n   f(i,1,xx)\n   {\n       ll j=lps[i-1];\n       while(j>0 && pp[j]!=pp[i]) j=lps[j-1];\n       if(pp[i]==pp[j]) j++;\n       lps[i]=j;\n   }\n}\n \n \n// Remember to take input string as  getline(cin,s)\nvoid stoi(string &s,vll &v)\n{\n   stringstream str(s);\n   ll x;\n   while(str>>x)\n   {\n       v.pb(x);\n   }\n}\n \n \n \n \nvoid Miden(ll **p1,ll n)\n{\n    ll (*x)[n]=(ll(*)[n]) p1;\n    f(i,0,n)\n    {\n        f(j,0,n)\n        {\n            x[i][j]=0;\n        }\n        x[i][i]=1;\n    }\n    return;\n}\n \nvoid Mmult(ll **p1,ll **p2,ll **ans,ll x,ll y,ll z,ll m)\n{\n    ll (*a)[y]=(ll (*)[y])p1;\n    ll (*b)[z]=(ll (*)[z])p2;\n    ll (*c)[z]=(ll (*)[z])ans;\n    f(i,0,x)\n    {\n        f(j,0,z)\n        {\n            c[i][j]=0;\n            f(k,0,y)\n            {\n                c[i][j]+=a[i][k]*b[k][j];\n                c[i][j]%=m;\n            }\n        }\n    }\n    return;\n}\n \nvoid Mpow(ll **p1,ll **ans,ll n,ll y,ll m)\n{\n    if(y==0)\n    {\n        Miden(ans,n);\n        return;\n    }\n    ll t[n][n];\n    Mpow(p1,(ll **)t,n,y/2,m);\n    ll z[n][n];\n    Mmult((ll **)t,(ll **)t,(ll **)z,n,n,n,m);\n    if(y%2)\n    {\n        Mmult((ll **)z,p1,ans,n,n,n,m);\n    }\n    else\n    {\n        Miden((ll **)t,n);\n        Mmult((ll **)z,(ll **)t,ans,n,n,n,m);\n    }\n    return;\n}\n \n \n \nvoid debg(ll *arr,ll l,ll r)\n{\n  f(i,l,r+1) pr1(arr[i])\n  nl\n}\n \nvoid exit()\n{\n  cout<<\"-1\\n\";\n  exit(0);\n}\n \n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n    template <typename Arg1>\n    void __f(const char* name, Arg1&& arg1){\n        cout << name << \" : \" << arg1 << std::endl;\n        //use cerr if u want to display at the bottom\n    }\n    template <typename Arg1, typename... Args>\n    void __f(const char* names, Arg1&& arg1, Args&&... args){\n        const char* comma = strchr(names + 1, ','); cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n    }\n#else\n#define trace(...)\n#endif\n \n#define endl \"\\n\"\n\n\nll n,k,a,b;\nll dp[52][52];\nll g[52][52][100];\n\nll ways(ll i,ll j,ll moves)\n{\n\tif(moves==1) return 50*i+100*j<=k;\n\t\n\tif(g[i][j][moves]!=-1) return g[i][j][moves];\n\t\n\tll res=0;\n\tf(z,0,i+1)  // number of 50 kg people sent \n\t{\n\t\tf(w,0,j+1) // number of 100 kg people sent\n\t\t{\n\t\t   \tif(50*z+100*w>k) continue;\n\t\t   \tif(z==0 && w==0) continue;\n\t\t   \tll cnt50=a-i+z,cnt100=b-j+w,pp=modpro(nCr(i,z),nCr(j,w));\n\t\t   \tf(x,0,cnt50+1)  // number of 50 kg people who came back  \n\t\t   \t{\n\t\t\t\tf(y,0,cnt100+1)  // number of 100 kg people who came back  \n\t\t\t\t{\n\t\t\t\t\tif(50*x+100*y>k) continue;\n\t\t\t\t\tif(x==0 && y==0 ) continue;\n\t\t\t\t\tif(dp[i-z+x][j-w+y]==moves-2)\n\t\t\t\t\t{\n\t\t\t\t\t\tll qq=modpro(nCr(cnt50,x),nCr(cnt100,y));\n\t\t\t\t\t\tres=modadd(res,modpro(pp,qq,ways(i-z+x,j-w+y,moves-2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn g[i][j][moves]=res;\n}\n\nvoid func()\n{\n  cin>>n>>k;\n  f(i,1,n+1)\n  {\n\t  ll x;\n\t  cin>>x;\n\t  if(x==50) a++;\n\t  else b++;\n  }\n  \n  f(tot,1,a+b+1)       // Total number of People on left\n  {\n\t  f(j,0,min(b,tot)+1)       // Number of 100 kg people on left\n\t  {\n\t\t  ll i=tot-j;  // Number of 50 kg people on left\n\t\t  if(i>a) \n\t\t  {\n\t\t\t  dp[i][j]=infl;\n\t\t\t  continue;\n\t\t  }\n\t\t  \n\t\t  ll mn=infl;\n\t\t  \n\t\t  f(z,0,j+1)  // Number of 100 kg people going on 1st ride\n\t\t  {\n\t\t\t  if(100*z>k) break;\n\t\t\t  ll y=min( (k-100*z)/50 ,i);\n\t\t\t  if(y==i && z==j)\n\t\t\t  {\n\t\t\t\t  mn=1;\n\t\t\t\t  break;\n\t\t\t  }\n\t\t\t  \n\t\t\t  if(z>0 && a-i+y>0 && dp[i-y+1][j-z]!=infl) mn=min(mn,2+dp[i-y+1][j-z]);\n\t\t\t  if(y>1 && dp[i-y+1][j-z]!=infl) mn=min(mn,2+dp[i-y+1][j-z]);\n\t\t\t  if(z>1 && dp[i-y][j-z+1]!=infl) mn=min(mn,2+dp[i-y][j-z+1]);\n\t\t\t   \n\t\t  }\n\t\t  dp[i][j]=mn;\n\t  }\n  }\n   \n  memset(g,-1,sizeof g);\n  \n  if(dp[a][b]==infl)\n  {\n\t  cout<<\"-1\\n0\\n\";\n\t  return;\n  }\t\t     \n  set_fac();\n  cout<<dp[a][b]<<\"\\n\"<<ways(a,b,dp[a][b])<<endl;\n \n}   \n     \n     \n     \nint main() \n{\n    fast\n    //#ifndef ONLINE_JUDGE\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    //#endif // ONLINE_JUDGE\n        \n     \n    ll ntc=1;\n    //cin>>ntc;\n     \n    f(i,1,ntc+1)\n    {\n      //cout<<\"Case #\"<<i<<\": \";\n       func();\n    }\n     \n    return 0;\n}\n"
}