{
    "id": 130311541,
    "contestId": 295,
    "creationTimeSeconds": 1632969216,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "robinz62"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "Java 11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 374,
    "memoryConsumedBytes": 23756800,
    "source": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //   npe, particularly in maps\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int[] nk = ril(2);\n        int n = nk[0];\n        k = nk[1];\n\n        int[] w = ril(n);\n        for (int i = 0; i < n; i++) w[i] = w[i] / 50;\n        k /= 50;\n\n        int count1 = 0;\n        int count2 = 0;\n        for (int wi : w) if (wi == 1) count1++; else count2++;\n\n        choose = new int[n+1][n+1];\n        choose[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            choose[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];\n                if (choose[i][j] >= MOD) choose[i][j] -= MOD;\n            }\n        }\n\n        dp = new int[n+1][n+1][2];\n        ways = new int[n+1][n+1][2];\n        visited = new int[n+1][n+1][2];\n\n        Deque<int[]> q = new ArrayDeque<>();\n        q.addLast(new int[]{count1, count2, 0});\n        visited[count1][count2][0] = 1;\n        ways[count1][count2][0] = 1;\n        int dist = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int[] u = q.removeFirst();\n                int l1 = u[0];\n                int l2 = u[1];\n                int r1 = count1 - l1;\n                int r2 = count2 - l2;\n                int side = u[2];\n                if (l1 == 0 && l2 == 0) {\n                    pw.println(dp[0][0][1]);\n                    pw.println(ways[0][0][1]);\n                    return;\n                }\n                visited[l1][l2][side] = 2;\n\n                if (side == 0) {\n                    for (int take2 = 0; take2 <= l2; take2++) {\n                        if (take2 * 2 > k) break;\n                        for (int take1 = 0; take1 <= l1; take1++) {\n                            if (take1 == 0 && take2 == 0) continue;  // must be nonempty\n                            if (take2 * 2 + take1 > k) break;\n                            if (visited[l1-take1][l2-take2][1] == 2) continue;\n                            if (visited[l1-take1][l2-take2][1] == 0) {\n                                q.addLast(new int[]{l1-take1, l2-take2, 1});\n                                visited[l1-take1][l2-take2][1] = 1;\n                            }\n                            dp[l1-take1][l2-take2][1] = dist+1;\n                            ways[l1-take1][l2-take2][1] += (int) ((long) ways[l1][l2][side] * choose[l1][take1] % MOD * choose[l2][take2] % MOD);\n                            ways[l1-take1][l2-take2][1] %= MOD;\n                        }\n                    }\n                } else {\n                    for (int take2 = 0; take2 <= r2; take2++) {\n                        if (take2 * 2 > k) break;\n                        for (int take1 = 0; take1 <= r1; take1++) {\n                            if (take1 == 0 && take2 == 0) continue;  // must be nonempty\n                            if (take2 * 2 + take1 > k) break;\n                            if (visited[l1+take1][l2+take2][0] == 2) continue;\n                            if (visited[l1+take1][l2+take2][0] == 0) {\n                                q.addLast(new int[]{l1+take1, l2+take2, 0});\n                                visited[l1+take1][l2+take2][0] = 1;\n                            }\n                            dp[l1+take1][l2+take2][0] = dist+1;\n                            ways[l1+take1][l2+take2][0] += (int) ((long) ways[l1][l2][side] * choose[r1][take1] % MOD * choose[r2][take2] % MOD);\n                            ways[l1+take1][l2+take2][0] %= MOD;\n                        }\n                    }\n                }\n\n            }\n            dist++;\n        }\n\n        pw.println(\"-1\");\n        pw.println(\"0\");\n    }\n    // IMPORTANT\n    // DID YOU CHECK THE COMMON MISTAKES ABOVE?\n\n    int k;\n\n    int[][][] dp;\n    int[][][] ways;\n    int[][][] visited;  // 0 = unvisited, 1 = enqueued, 2 = completely done\n\n    int[][] choose;\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n\n    void printDouble(double d) {\n        pw.printf(\"%.16f\", d);\n    }\n}"
}