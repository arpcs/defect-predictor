{
    "id": 80808994,
    "contestId": 295,
    "creationTimeSeconds": 1590012281,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "bleh0.5"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "Java 8",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 372,
    "memoryConsumedBytes": 0,
    "source": "\r\n// Problem : C. Greg and Friends\r\n// Contest : Codeforces - Codeforces Round #179 (Div. 1)\r\n// URL : https://codeforces.com/contest/295/problem/C\r\n// Memory Limit : 256 MB\r\n// Time Limit : 2000 ms\r\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\nimport java.util.stream.*;\r\n\r\npublic class a implements Runnable{\r\n\t\r\n    public static void main(String[] args) {\r\n        new Thread(null, new a(), \"process\", 1<<26).start();\r\n    }\r\n\tpublic void run() {\r\n\t\tFastReader scan = new FastReader();\r\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\r\n\t\t//PrintWriter out = new PrintWriter(\"file.out\");\r\n\t\tTask solver = new Task();\r\n\t\t//int t = scan.nextInt();\r\n\t\tint t = 1;\r\n\t\tfor(int i = 1; i <= t; i++) solver.solve(i, scan, out);\r\n\t\tout.close();\r\n\t}\r\n\r\n\tstatic class Task {\r\n\t\tstatic final int inf = Integer.MAX_VALUE;\r\n\r\n\t\tpublic void solve(int testNumber, FastReader sc, PrintWriter pw) {\r\n\t\t\t//CHECK FOR QUICKSORT TLE\r\n\t\t\t//***********************//\r\n\t\t\t//CHECK FOR INT OVERFLOW\r\n\t\t\t//***********************//\r\n\t\t\tint n = sc.nextInt();\r\n\t\t\tint we = sc.nextInt() / 50;\r\n\t\t\tint[] ppl = new int[n];\r\n\t\t\tint a = 0;\t\r\n\t\t\tint b = 0;\r\n\t\t\tint mod = 1000000007;\r\n\t\t\tfor(int i = 0; i < n; i++) {\r\n\t\t\t\tppl[i] = sc.nextInt() / 50;\r\n\t\t\t\ta += ppl[i] & 1;\r\n\t\t\t\tb += ppl[i] / 2;\r\n\t\t\t}\r\n\t\t\tlong[][] choose = new long[52][52];\r\n\t\t\tfor(int i = 1; i <= 50; i++) {\r\n\t\t\t\tfor(int j = 0; j <= i; j++) {\r\n\t\t\t\t\tchoose[i][j] = choose_mod_one(i, j, mod);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlong[][][] dp = new long[200][52][52]; \r\n\t\t\tdp[0][0][0] = 1;\r\n\t\t\tchoose[0][0] = 1;\r\n\t\t\tfor(int i = 1; i < 200; i ++) {\r\n\t\t\t\tfor(int j = 0; j <= a; j++) {\r\n\t\t\t\t\tfor(int k = 0; k <= b; k++) {\r\n\t\t\t\t\t\tif((i & 1) == 1) {\r\n\t\t\t\t\t\t\tfor(int l = 0; l <= j; l++) {\r\n\t\t\t\t\t\t\t\tfor(int m = 0; m <= k; m++) {\r\n\t\t\t\t\t\t\t\t\tif(l == j && m == k) continue;\r\n\t\t\t\t\t\t\t\t\tint num1s = j - l;\r\n\t\t\t\t\t\t\t\t\tint num2s = k - m;\r\n\t\t\t\t\t\t\t\t\tint left1s = a - l;\r\n\t\t\t\t\t\t\t\t\tint left2s = b - m;\r\n\t\t\t\t\t\t\t\t\tif(num1s * 1 + num2s * 2 > we) continue;\r\n\t\t\t\t\t\t\t\t\tdp[i][j][k] += dp[i - 1][l][m] * choose[left1s][num1s] % mod * \r\n\t\t\t\t\t\t\t\t\t\tchoose[left2s][num2s] % mod;\r\n\t\t\t\t\t\t\t\t\tdp[i][j][k] %= mod;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tfor(int l = j; l <= a; l++) {\r\n\t\t\t\t\t\t\t\tfor(int m = k; m <= b; m++) {\r\n\t\t\t\t\t\t\t\t\tif(l == j && m == k) continue;\r\n\t\t\t\t\t\t\t\t\tint num1s = l - j;\r\n\t\t\t\t\t\t\t\t\tint num2s = m - k;\r\n\t\t\t\t\t\t\t\t\tint left1s = l;\r\n\t\t\t\t\t\t\t\t\tint left2s = m;\r\n\t\t\t\t\t\t\t\t\tif(num1s * 1 + num2s * 2 > we) continue;\r\n\t\t\t\t\t\t\t\t\tdp[i][j][k] += dp[i - 1][l][m] * choose[left1s][num1s] % mod * \r\n\t\t\t\t\t\t\t\t\t\tchoose[left2s][num2s] % mod;\r\n\t\t\t\t\t\t\t\t\tdp[i][j][k] %= mod;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(dp[i][a][b] > 0) break;\r\n\t\t\t}\r\n\t\t\tfor(int i = 0; i < 200; i++) {\r\n\t\t\t\tif(dp[i][a][b] > 0) {\r\n\t\t\t\t\tpw.println(i);\r\n\t\t\t\t\tpw.println(dp[i][a][b]);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpw.println(-1);\r\n\t\t\tpw.println(0);\r\n\t\t}\r\n\t\tlong choose_mod_one(long n, long k, long p)\r\n\t\t{\r\n\t\t    // For small k, no recursion is necessary\r\n\t\t    if (k < p) return choose_mod_two(n,k,p);\r\n\t\t    long q_n, r_n, q_k, r_k, choose;\r\n\t\t    q_n = n / p;\r\n\t\t    r_n = n % p;\r\n\t\t    q_k = k / p;\r\n\t\t    r_k = k % p;\r\n\t\t    choose = choose_mod_two(r_n, r_k, p);\r\n\t\t    choose *= choose_mod_one(q_n, q_k, p);\r\n\t\t    return choose % p;\r\n\t\t}\r\n\t\t\r\n\t\t// Preconditions: 0 <= k <= min(n,p-1); p > 1 prime\r\n\t\tlong choose_mod_two(long n, long k, long p)\r\n\t\t{\r\n\t\t    n %= p;\r\n\t\t    if (n < k) return 0;\r\n\t\t    if (k == 0 || k == n) return 1;\r\n\t\t    if (k > n/2) k = n-k;\r\n\t\t    long num = n, den = 1;\r\n\t\t    for(n = n-1; k > 1; --n, --k)\r\n\t\t    {\r\n\t\t        num = (num * n) % p;\r\n\t\t        den = (den * k) % p;\r\n\t\t    }\r\n\t\t    den = invert_mod(den,p);\r\n\t\t    return (num * den) % p;\r\n\t\t}\r\n\t\tlong invert_mod(long k, long m)\r\n\t\t{\r\n\t\t    if (m == 0) return (k == 1 || k == -1) ? k : 0;\r\n\t\t    if (m < 0) m = -m;\r\n\t\t    k %= m;\r\n\t\t    if (k < 0) k += m;\r\n\t\t    boolean neg = true;\r\n\t\t    long p1 = 1, p2 = 0, k1 = k, m1 = m, q, r, temp;\r\n\t\t    while(k1 > 0) {\r\n\t\t        q = m1 / k1;\r\n\t\t        r = m1 % k1;\r\n\t\t        temp = q*p1 + p2;\r\n\t\t        p2 = p1;\r\n\t\t        p1 = temp;\r\n\t\t        m1 = k1;\r\n\t\t        k1 = r;\r\n\t\t        neg = !neg;\r\n\t\t    }\r\n\t\t    return neg ? m - p2 : p2;\r\n\t\t}\r\n\t}\r\n\tstatic long binpow(long a, long b, long m) {\r\n\t\ta %= m;\r\n\t\tlong res = 1;\r\n\t\twhile (b > 0) {\r\n\t\t\tif ((b & 1) == 1)\r\n\t\t\t\tres = res * a % m;\r\n\t\t\ta = a * a % m;\r\n\t\t\tb >>= 1;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\tstatic void sort(int[] x){\r\n\t\tshuffle(x);\r\n\t\tArrays.sort(x);\r\n\t}\r\n\tstatic void sort(long[] x){\r\n\t\tshuffle(x);\r\n\t\tArrays.sort(x);\r\n\t}\r\n\tstatic class tup implements Comparable<tup>{\r\n\t\tint a, b;\r\n\t\ttup(int a,int b){\r\n\t\t\tthis.a=a;\r\n\t\t\tthis.b=b;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic int compareTo(tup o){\r\n\t\t\treturn Integer.compare(o.b,b);\r\n\t\t}\r\n\t}\r\n\tstatic void shuffle(int[] a) {\r\n\t\tRandom get = new Random();\r\n\t\tfor (int i = 0; i < a.length; i++) {\r\n\t\t\tint r = get.nextInt(i + 1);\r\n\t\t\tint temp = a[i];\r\n\t\t\ta[i] = a[r];\r\n\t\t\ta[r] = temp;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void shuffle(long[] a) {\r\n\t\tRandom get = new Random();\r\n\t\tfor (int i = 0; i < a.length; i++) {\r\n\t\t\tint r = get.nextInt(i + 1);\r\n\t\t\tlong temp = a[i];\r\n\t\t\ta[i] = a[r];\r\n\t\t\ta[r] = temp;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class FastReader {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic FastReader() {\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t}\r\n\r\n\t\tpublic FastReader(String s) throws FileNotFoundException {\r\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\r\n\t\t}\r\n\r\n\t\tString next() {\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n\r\n\t\tlong nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\r\n\t\tdouble nextDouble() {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tString nextLine() {\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n\r\n}"
}