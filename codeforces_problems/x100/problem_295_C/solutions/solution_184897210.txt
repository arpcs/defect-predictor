{
    "id": 184897210,
    "contestId": 295,
    "creationTimeSeconds": 1670850921,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "KoKonuts"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 102400,
    "source": "#include <bits/stdc++.h>\n\n#define rep(a, b) for (num a = 0; a < (b); ++a)\n#define all(a) (a).begin(), (a).end()\n#define many int t; cin >> t; while (t--)\n#define yesno cout << (solve() ? \"YES\" : \"NO\") << '\\n'\n#define print cout << solve() << '\\n'\n#define call solve()\n\nusing namespace std;\n\nusing num = long long int;\nusing seq = vector<num>;\nusing par = pair<num,num>;\nusing Graph = vector<vector<num>>;\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U>& p) { return os << p.first << ' ' << p.second; }\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T,U>& p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { for (auto& e : v) os << e << ' '; return os; }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { for (auto& e : v) is >> e; return is; }\nvoid read(Graph& adj, num m, bool directed = false) { rep(i, m) { num u, v; cin >> u >> v; --u, --v; adj[u].push_back(v); if (!directed) adj[v].push_back(u); } }\n\ntemplate <num Modulo>\nclass modular {\n    static_assert(Modulo > 0, \"Modulo must be positive\");\nprivate:\n    static vector<modular> factorials;\n    num _a;\n    const num _m = Modulo;\n\n    void normalize () {\n        if (_a >= _m || -_a <= _m)\n            _a %= _m;\n        if (_a < 0)\n            _a += _m;\n    }\n\npublic:\n    modular (const modular& m = modular(0)) : _a(m._a) { }\n\n    modular (const num& a)\n            : _a (a)\n    { normalize(); }\n\n    explicit operator num() { return _a; };\n\n    modular& operator = (const modular& m) {\n        _a = m._a;\n        return *this;\n    }\n\n    modular& operator += (const modular& other) {\n        _a += other._a;\n        if (_a >= _m)\n            _a -= _m;\n        return *this;\n    }\n\n    modular& operator -= (const modular& other) {\n        _a -= other._a;\n        if (_a < 0)\n            _a += _m;\n        return *this;\n    }\n\n    modular& operator *= (const modular& other)\n    { return _a *= other._a, normalize(), *this; }\n\n    modular& operator /= (const modular& other)\n    { return *this *= !other; }\n\n    modular& operator ^= (num power) {\n        auto base = *this;\n        *this = 1;\n        while (power > 0) {\n            if (power & 1)\n                *this *= base;\n            base *= base;\n            power >>= 1;\n        }\n        return *this;\n    }\n\n    modular& operator ++ () { return *this += 1; }\n    modular& operator -- () { return *this -= 1; }\n    const modular operator ++ (int) { const modular result (*this); ++*this; return result; }\n    const modular operator -- (int) { const modular result (*this); --*this; return result; }\n\n    modular operator + () const { return *this; }\n    modular operator - () const { return modular(-_a); }\n    // Fermat Inverse, assuming m is prime\n    modular operator ! () const {\n        return *this ^ (_m - 2);\n    }\n\n    static modular factorial(const num& n) {\n        assert(0 <= n);\n        while (factorials.size() <= n)\n            factorials.push_back(factorials.back() * modular(static_cast<const num>(factorials.size())));\n        return factorials[n];\n    }\n\n    static modular binom(const num& n, const num& k) {\n        return factorial(n) / (factorial(k) * factorial(n - k));\n    }\n\n    friend modular operator + (modular self, const modular& other) { return self += other; }\n    friend modular operator - (modular self, const modular& other) { return self -= other; }\n    friend modular operator * (modular self, const modular& other) { return self *= other; }\n    friend modular operator / (modular self, const modular& other) { return self /= other; }\n    friend modular operator ^ (modular self, const num& power) { return self ^= power; }\n\n    friend bool operator == (const modular& left, const modular& right) { return left._a == right._a; }\n    friend bool operator != (const modular& left, const modular& right) { return left._a != right._a; }\n    friend bool operator <= (const modular& left, const modular& right) { return left._a <= right._a; }\n    friend bool operator >= (const modular& left, const modular& right) { return left._a >= right._a; }\n    friend bool operator <  (const modular& left, const modular& right) { return left._a <  right._a; }\n    friend bool operator >  (const modular& left, const modular& right) { return left._a >  right._a; }\n\n    friend bool operator == (const modular& left, const num& right) { return left._a == right; }\n    friend bool operator != (const modular& left, const num& right) { return left._a != right; }\n    friend bool operator <= (const modular& left, const num& right) { return left._a <= right; }\n    friend bool operator >= (const modular& left, const num& right) { return left._a >= right; }\n    friend bool operator <  (const modular& left, const num& right) { return left._a <  right; }\n    friend bool operator >  (const modular& left, const num& right) { return left._a >  right; }\n\n    friend bool operator == (const num& left, const modular& right) { return left == right._a; }\n    friend bool operator != (const num& left, const modular& right) { return left != right._a; }\n    friend bool operator <= (const num& left, const modular& right) { return left <= right._a; }\n    friend bool operator >= (const num& left, const modular& right) { return left >= right._a; }\n    friend bool operator <  (const num& left, const modular& right) { return left <  right._a; }\n    friend bool operator >  (const num& left, const modular& right) { return left >  right._a; }\n\n    friend ostream& operator << (ostream& stream, const modular& m) {\n        return stream << m._a;\n    }\n\n    friend istream& operator >> (istream& stream, modular& m) {\n        stream >> m._a;\n        m.normalize();\n        return stream;\n    }\n};\ntemplate<num modulo> vector<modular<modulo>> modular<modulo>::factorials = {1};\n\nusing mod = modular<1000000007>;\n\nvoid solve() {\n    num n, k;\n    cin >> n >> k;\n    seq a(n);\n    cin >> a;\n    k /= 50;\n    num one = 0, two = 0;\n    for (const auto& x : a)\n        ++(x == 50 ? one : two);\n    vector<vector<vector<num>>> dist(2, vector<vector<num>>(one+1, vector<num>(two+1, -1)));\n    vector<vector<vector<mod>>> ways(2, vector<vector<mod>>(one+1, vector<mod>(two+1, 0)));\n    queue<tuple<bool,num,num>> q;\n    dist[false][0][0] = 0;\n    ways[false][0][0] = 1;\n    q.emplace(false, 0, 0);\n    while (!q.empty()) {\n        auto [b, o, t] = q.front();\n        q.pop();\n        for (num i = 0; i <= (b ? o : one - o); i++) {\n            for (num j = 0; j <= (b ? t : two - t); j++) {\n                if (!i && !j)\n                    continue;\n                if (i + 2 * j > k)\n                    break;\n                num x = o + (b ? -i : i), y = t + (b ? -j : j);\n                if (dist[!b][x][y] == -1)\n                    dist[!b][x][y] = dist[b][o][t] + 1, q.emplace(!b, x, y);\n                if (dist[!b][x][y] == dist[b][o][t] + 1)\n                    ways[!b][x][y] += ways[b][o][t] * mod::binom((b ? o : one - o), i) * mod::binom((b ? t : two - t), j);\n            }\n        }\n    }\n\n    cout << dist[true][one][two] << \"\\n\" << ways[true][one][two];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    srand(time(0));\n    cout << setprecision(20) << fixed;\n    call;\n    return 0;\n}\n"
}