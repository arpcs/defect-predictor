{
    "id": 177380310,
    "contestId": 295,
    "creationTimeSeconds": 1666404553,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "wjli"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 1996,
    "memoryConsumedBytes": 1740800,
    "source": "#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\n#include <iomanip> \r\n#include <math.h>\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <string.h>\r\n#include <queue>\r\n#include <stack>\r\n#include <vector>\r\n#include <map>\r\n#include <set>\r\n#include <functional>\r\n#include <algorithm>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <bitset>\r\n#include <complex>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long LL;\r\ntypedef pair<LL, LL> PL;\r\ntypedef vector<LL> VL;\r\ntypedef vector<PL> VPL;\r\ntypedef vector<VL> VVL;\r\n\r\ntypedef pair<int, int> PI;\r\ntypedef vector<int> VI;\r\ntypedef vector<PI> VPI;\r\ntypedef vector<vector<int>> VVI;\r\ntypedef vector<vector<PI>> VVPI;\r\n\r\ntypedef long double LD;\r\ntypedef pair<LD, LD> PLDLD;\r\n\r\ntypedef complex<double> CD;\r\ntypedef vector<CD> VCD;\r\n\r\ntypedef vector<string> VS;\r\n\r\n#define MP make_pair\r\n#define PB push_back\r\n#define F first\r\n#define S second\r\n#define LB lower_bound\r\n#define UB upper_bound\r\n\r\n#define SZ(x) ((int)x.size())\r\n#define LEN(x) ((int)x.length())\r\n#define ALL(x) begin(x), end(x)\r\n#define RSZ resize\r\n#define ASS assign\r\n#define REV(x) reverse(x.begin(), x.end());\r\n\r\n\r\n\r\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\r\n#define F0R(i, a) for (int i = 0; i < (a); i++)\r\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\r\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\r\n#define trav(a, x) for (auto& a : x)\r\n\r\n\r\nconst LL INF = 1E18;\r\nconst int MAXX = 300005;\r\nconst LD PAI = 4 * atan((LD)1);\r\n\r\ntemplate <typename T>\r\nclass fenwick_tree {\r\npublic:\r\n    vector<T> fenw;\r\n    int n;\r\n\r\n    fenwick_tree(int _n) : n(_n) {\r\n        fenw.resize(n);\r\n    }\r\n\r\n    void update(int x, T v) {\r\n        while (x < n) {\r\n            fenw[x] += v;\r\n            x |= (x + 1);\r\n            //x += (x & (-x));\r\n        }\r\n    }\r\n\r\n    T query(int x) {\r\n        T v{};\r\n        while (x >= 0) {\r\n            v += fenw[x];\r\n            x = (x & (x + 1)) - 1;\r\n        }\r\n        return v;\r\n    }\r\n\r\n    T query_full(int a, int b) {\t\t// range query\r\n        return query(b) - ((a <= 1) ? 0 : query(a - 1));\r\n    }\r\n};\r\n\r\ntemplate <typename T>\r\nvector<T> serialize(vector<T> a, int startvalue = 0) {\r\n    int n = a.size(), i, j, k, ct;\r\n    vector<T> ans(n);\r\n    map<T, T> id;\r\n    for (auto p : a) id[p] = 0;\r\n    ct = startvalue;\r\n    for (auto p : id) id[p.first] = ct++;\r\n    for (i = 0; i < n; i++) ans[i] = id[a[i]];\r\n    return ans;\r\n}\r\n\r\ntemplate <typename T>\r\nclass segment_tree {\r\n    vector<T> t;\r\n    T VERYBIG;\r\n    bool ISMAXRANGE;\r\n    int size;\r\npublic:\r\n    segment_tree(int n, bool range_max = true) {\r\n        if (is_same<T, int>::value) VERYBIG = (1 << 30);\r\n        else if (is_same<T, LL>::value) VERYBIG = (1LL << 60);\r\n        //else if (is_same<T, PII>::value) VERYBIG = PII({ 1E9, 1E9 });\r\n        //else if (is_same<T, PLL>::value) VERYBIG = { 1LL << 60, 1LL << 60 };\r\n\r\n        ISMAXRANGE = range_max;\r\n\r\n        if (ISMAXRANGE) t.assign(4 * n + 1, 0);\r\n        else t.assign(4 * n + 1, VERYBIG);\r\n        size = n;\r\n    }\r\n\r\n    void initialize_array(vector<T>& v) {\r\n        initialize_with_array(1, 0, size - 1, v);\r\n    }\r\n\r\n    void initialize_with_array(int startpos, int l, int r, vector<T>& v) {\r\n        if (l == r) {\r\n            t[startpos] = v[l];\r\n        }\r\n        else {\r\n            int m = (l + r) / 2;\r\n            initialize_with_array(2 * startpos, l, m, v);\r\n            initialize_with_array(2 * startpos + 1, m + 1, r, v);\r\n\r\n            if (ISMAXRANGE == 1) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\r\n            else  t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\r\n        }\r\n    }\r\n\r\n    void update(int index, T val) { // insert val into location index\r\n        update_full(1, 0, size - 1, index, val);\r\n    }\r\n\r\n    void update_full(int startpos, int l, int r, int index, T val) {\r\n        if (l == r) {\r\n            t[startpos] = val;\r\n        }\r\n        else {\r\n            int m = (l + r) / 2;\r\n            if (index <= m) update_full(2 * startpos, l, m, index, val);\r\n            else update_full(2 * startpos + 1, m + 1, r, index, val);\r\n\r\n            if (ISMAXRANGE) t[startpos] = max(t[startpos * 2], t[startpos * 2 + 1]);\r\n            else t[startpos] = min(t[startpos * 2], t[startpos * 2 + 1]);\r\n        }\r\n    }\r\n\r\n    T query(int l, int r) {  // get range min/max between l and r\r\n        if (l > r) {\r\n            if (ISMAXRANGE) return 0;\r\n            else return VERYBIG;\r\n        }\r\n        return query_full(1, 0, size - 1, l, r);\r\n    }\r\n\r\n    T query_full(int startpos, int left, int right, int l, int r) {\t // left/right = current range, l/r = intended query range\r\n        if ((left >= l) && (right <= r)) return t[startpos];\r\n        int m = (left + right) / 2;\r\n        T ans;\r\n        if (ISMAXRANGE) ans = -VERYBIG;\r\n        else ans = VERYBIG;\r\n        if (m >= l) {\r\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2, left, m, l, r));\r\n            else ans = min(ans, query_full(startpos * 2, left, m, l, r));\r\n        }\r\n        if (m + 1 <= r) {\r\n            if (ISMAXRANGE) ans = max(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\r\n            else ans = min(ans, query_full(startpos * 2 + 1, m + 1, right, l, r));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n//#define MOD 1000000007\r\nint MOD = 1, root = 2; // 998244353\r\n\r\ntemplate<class T> T invGeneral(T a, T b) {\r\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\r\n    T x = invGeneral(b, a);\r\n    return x == -1 ? -1 : ((1 - (LL)b * x) / a + b) % b;\r\n}\r\n\r\ntemplate<class T> struct modular {\r\n    T val;\r\n    explicit operator T() const { return val; }\r\n    modular() { val = 0; }\r\n    modular(const LL& v) {\r\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\r\n        if (val < 0) val += MOD;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\r\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\r\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\r\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\r\n\r\n    modular operator-() const { return modular(-val); }\r\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\r\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\r\n    modular& operator*=(const modular& m) { val = (LL)val * m.val % MOD; return *this; }\r\n    friend modular pow(modular a, LL p) {\r\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\r\n        return ans;\r\n    }\r\n    friend modular inv(const modular& a) {\r\n        auto i = invGeneral(a.val, MOD); assert(i != -1);\r\n        return i;\r\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\r\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\r\n\r\n    friend modular operator+(modular a, const modular& b) { return a += b; }\r\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\r\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\r\n\r\n    friend modular operator/(modular a, const modular& b) { return a /= b; }\r\n};\r\n\r\ntypedef modular<int> mi;\r\ntypedef pair<mi, mi> pmi;\r\ntypedef vector<mi> vmi;\r\ntypedef vector<pmi> vpmi;\r\n\r\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\nnamespace vecOp {\r\n    template<class T> vector<T> rev(vector<T> v) { reverse(ALL(v)); return v; }\r\n    template<class T> vector<T> shift(vector<T> v, int x) { v.insert(v.begin(), x, 0); return v; }\r\n\r\n    template<class T> vector<T>& operator+=(vector<T>& l, const vector<T>& r) {\r\n        l.rSZ(max(SZ(l), SZ(r))); F0R(i, SZ(r)) l[i] += r[i]; return l;\r\n    }\r\n    template<class T> vector<T>& operator-=(vector<T>& l, const vector<T>& r) {\r\n        l.rSZ(max(SZ(l), SZ(r))); F0R(i, SZ(r)) l[i] -= r[i]; return l;\r\n    }\r\n    template<class T> vector<T>& operator*=(vector<T>& l, const T& r) { trav(t, l) t *= r; return l; }\r\n    template<class T> vector<T>& operator/=(vector<T>& l, const T& r) { trav(t, l) t /= r; return l; }\r\n\r\n    template<class T> vector<T> operator+(vector<T> l, const vector<T>& r) { return l += r; }\r\n    template<class T> vector<T> operator-(vector<T> l, const vector<T>& r) { return l -= r; }\r\n    template<class T> vector<T> operator*(vector<T> l, const T& r) { return l *= r; }\r\n    template<class T> vector<T> operator*(const T& r, const vector<T>& l) { return l * r; }\r\n    template<class T> vector<T> operator/(vector<T> l, const T& r) { return l /= r; }\r\n\r\n    template<class T> vector<T> operator*(const vector<T>& l, const vector<T>& r) {\r\n        if (min(SZ(l), SZ(r)) == 0) return {};\r\n        vector<T> x(SZ(l) + SZ(r) - 1); F0R(i, SZ(l)) F0R(j, SZ(r)) x[i + j] += l[i] * r[j];\r\n        return x;\r\n    }\r\n    template<class T> vector<T>& operator*=(vector<T>& l, const vector<T>& r) { return l = l * r; }\r\n\r\n    template<class T> vector<T> rem(vector<T> a, vector<T> b) {\r\n        while (SZ(b) && b.back() == 0) b.pop_back();\r\n        assert(SZ(b)); b /= b.back();\r\n        while (SZ(a) >= SZ(b)) {\r\n            a -= a.back() * shift(b, SZ(a) - SZ(b));\r\n            while (SZ(a) && a.back() == 0) a.pop_back();\r\n        }\r\n        return a;\r\n    }\r\n    template<class T> vector<T> interpolate(vector<pair<T, T>> v) {\r\n        vector<T> ret;\r\n        F0R(i, SZ(v)) {\r\n            vector<T> prod = { 1 };\r\n            T todiv = 1;\r\n            F0R(j, SZ(v)) if (i != j) {\r\n                todiv *= v[i].f - v[j].f;\r\n                vector<T> tmp = { -v[j].f,1 }; prod *= tmp;\r\n            }\r\n            ret += prod * (v[i].s / todiv);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\nusing namespace vecOp;\r\n\r\nclass factorial {\r\npublic:\r\n    LL MAXX, MOD;\r\n    VL f, ff;\r\n\r\n    factorial(LL maxx = 200010, LL mod = 998244353) {\r\n        MAXX = maxx;\r\n        MOD = mod;\r\n\r\n        f.RSZ(MAXX);\r\n        ff.RSZ(MAXX);\r\n\r\n        f[0] = 1;\r\n        for (int i = 1; i < MAXX; i++) f[i] = (f[i - 1] * i) % MOD;\r\n        for (int i = 0; i < MAXX; i++) ff[i] = mul_inv(f[i], MOD);\r\n    }\r\n\r\n    long long mul_inv(long long a, long long b)\r\n    {\r\n        long long b0 = b, t, q;\r\n        long long x0 = 0, x1 = 1;\r\n        if (b == 1) return 1;\r\n        while (a > 1) {\r\n            q = a / b;\r\n            t = b, b = a % b, a = t;\r\n            t = x0, x0 = x1 - q * x0, x1 = t;\r\n        }\r\n        if (x1 < 0) x1 += b0;\r\n        return x1;\r\n    }\r\n\r\n    long long division(long long a, long long b) {\t\t// (a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p\r\n        long long ans, inv;\r\n        inv = mul_inv(b, MOD);\r\n        ans = ((a % MOD) * inv) % MOD;\r\n        return ans;\r\n    }\r\n\r\n    LL calcc(LL n, LL a) {\r\n        if (n == a) return 1;\r\n        if (n == 0) return 0;\r\n        if (n < a) return 0;\r\n        LL ans = (f[n] * ff[a]) % MOD;\r\n        ans = (ans * ff[n - a]) % MOD;\r\n        return ans;\r\n    }\r\n\r\n    LL calcp(LL n, LL a) {\r\n        LL ans = (f[n] * ff[n - a]) % MOD;\r\n        return ans;\r\n    }\r\n\r\n    LL exp(LL base, LL n) {\r\n        base %= MOD;\r\n        LL ans = 1, x = base, MAXLEVEL = 60, i;\r\n\r\n        for (i = 0; i < MAXLEVEL; i++) {\r\n            if ((1LL << i) > n) break;\r\n            if ((1LL << i) & n) ans = (ans * x) % MOD;\r\n            x = (x * x) % MOD;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n#ifdef _MSC_VER \r\n//#include <intrin.h>\r\n#endif\r\n\r\nnamespace FFT {\r\n#ifdef _MSC_VER \r\n    int size(int s) {\r\n        if (s == 0) return 0;\r\n        unsigned long index;\r\n        _BitScanReverse(&index, s);\r\n        return index + 1;\r\n    }\r\n#else\r\n    constexpr int size(int s) { return s > 1 ? 32 - __builtin_clz(s - 1) : 0; }\r\n#endif\r\n\r\n    template<class T> bool small(const vector<T>& a, const vector<T>& b) {\r\n        return (LL)SZ(a) * SZ(b) <= 500000;\r\n    }\r\n\r\n    void genRoots(vmi& roots) { // primitive n-th roots of unity\r\n        int n = SZ(roots); mi r = pow(mi(root), (MOD - 1) / n);\r\n        roots[0] = 1; FOR(i, 1, n) roots[i] = roots[i - 1] * r;\r\n    }\r\n    void genRoots(VCD& roots) { // change cd to complex<double> instead?\r\n        int n = SZ(roots); LD ang = 2 * PAI / n;\r\n        F0R(i, n) roots[i] = CD(cos(ang * i), sin(ang * i)); // is there a way to do this more quickly?\r\n    }\r\n\r\n    template<class T> void fft(vector<T>& a, vector<T>& roots) {\r\n        int n = SZ(a);\r\n        for (int i = 1, j = 0; i < n; i++) { // sort by reverse bit representation\r\n            int bit = n >> 1;\r\n            for (; j & bit; bit >>= 1) j ^= bit;\r\n            j ^= bit; if (i < j) swap(a[i], a[j]);\r\n        }\r\n        for (int len = 2; len <= n; len <<= 1)\r\n            for (int i = 0; i < n; i += len)\r\n                F0R(j, len / 2) {\r\n                auto u = a[i + j], v = a[i + j + len / 2] * roots[n / len * j];\r\n                a[i + j] = u + v, a[i + j + len / 2] = u - v;\r\n            }\r\n    }\r\n\r\n    template<class T> vector<T> conv(vector<T> a, vector<T> b) {\r\n        //if (small(a, b)) return a * b;\r\n        int s = SZ(a) + SZ(b) - 1, n = 1 << size(s);\r\n        vector<T> roots(n); genRoots(roots);\r\n\r\n        a.RSZ(n), fft(a, roots); b.RSZ(n), fft(b, roots);\r\n        F0R(i, n) a[i] *= b[i];\r\n        reverse(begin(roots) + 1, end(roots)); fft(a, roots); // inverse FFT\r\n\r\n        T in = T(1) / T(n); trav(x, a) x *= in;\r\n        a.RSZ(s); return a;\r\n    }\r\n\r\n    VL conv(const VL& a, const VL& b) {\r\n        //if (small(a, b)) return a * b;\r\n        VCD X = conv(VCD(ALL(a)), VCD(ALL(b)));\r\n        VL x(SZ(X)); F0R(i, SZ(X)) x[i] = round(X[i].real());\r\n        return x;\r\n    } // ~0.55s when SZ(a)=SZ(b)=1<<19\r\n\r\n    VL conv(const VL& a, const VL& b, LL mod) { // http://codeforces.com/contest/960/submission/37085144\r\n        //if (small(a, b)) return a * b;\r\n        int s = SZ(a) + SZ(b) - 1, n = 1 << size(s);\r\n\r\n        VCD v1(n), v2(n), r1(n), r2(n);\r\n        F0R(i, SZ(a)) v1[i] = CD(a[i] >> 15, a[i] & 32767); // v1(x)=a0(x)+i*a1(x)\r\n        F0R(i, SZ(b)) v2[i] = CD(b[i] >> 15, b[i] & 32767); // v2(x)=b0(x)+i*b1(x)\r\n\r\n        VCD roots(n); genRoots(roots);\r\n        fft(v1, roots), fft(v2, roots);\r\n        F0R(i, n) {\r\n            int j = (i ? (n - i) : i);\r\n            CD ans1 = (v1[i] + conj(v1[j])) * CD(0.5, 0); // a0(x)\r\n            CD ans2 = (v1[i] - conj(v1[j])) * CD(0, -0.5); // a1(x)\r\n            CD ans3 = (v2[i] + conj(v2[j])) * CD(0.5, 0); // b0(x)\r\n            CD ans4 = (v2[i] - conj(v2[j])) * CD(0, -0.5); // b1(x)\r\n            r1[i] = (ans1 * ans3) + (ans1 * ans4) * CD(0, 1); // a0(x)*v2(x)\r\n            r2[i] = (ans2 * ans3) + (ans2 * ans4) * CD(0, 1); // a1(x)*v2(x)\r\n        }\r\n        reverse(begin(roots) + 1, end(roots));\r\n        fft(r1, roots), fft(r2, roots); F0R(i, n) r1[i] /= n, r2[i] /= n;\r\n\r\n        VL ret(n);\r\n        F0R(i, n) {\r\n            LL av = (LL)round(r1[i].real()); // a0*b0\r\n            LL bv = (LL)round(r1[i].imag()) + (LL)round(r2[i].real()); // a0*b1+a1*b0\r\n            LL cv = (LL)round(r2[i].imag()); // a1*b1\r\n            av %= mod, bv %= mod, cv %= mod;\r\n            ret[i] = (av << 30) + (bv << 15) + cv;\r\n            ret[i] = (ret[i] % mod + mod) % mod;\r\n        }\r\n        ret.resize(s);\r\n        return ret;\r\n    } // ~0.8s when SZ(a)=SZ(b)=1<<19\r\n}\r\nusing namespace FFT;\r\n\r\nlong long gcd(long long a, long long b)\r\n{\r\n    while (b != 0) {\r\n        long long t = b;\r\n        b = a % b;\r\n        a = t;\r\n    }\r\n    return a;\r\n}\r\n\r\n\r\n\r\nclass tree {\t\t// implementation of recurvie programming\r\n    int ct;\r\npublic:\r\n    int nn, root;\t\t\t\t// # of nodes, id of root\r\n    vector<int> parent;\t\t\t// parent of each node; -1 if unassigned\r\n    vector<int> depth;\t\t\t// depth of each node\r\n    vector<int> sz;\t\t\t\t// subtree size of each node \r\n    vector<vector<int>> adj;\t// adjacency list from each node\r\n    vector<vector<int>> sons;\t// sons list from each node\r\n\r\n    // for cartesian_decomposition\r\n    vector<int> in, out;\t\t// starting and ending position of a subtree\r\n    vector<int> pos;\t\t\t// inorder of DFS\r\n\r\n    // for LCA sparse table\r\n    vector<vector<int>> pred;\r\n    int MAXLEVEL;\r\n\r\n    tree(int n) {\r\n        nn = n;\r\n        adj.clear();\r\n        adj.resize(n);\r\n    }\r\n\r\n    void add_path(int a, int b) {\r\n        adj[a].push_back(b);\r\n        adj[b].push_back(a);\r\n    }\r\n\r\n    void add_directed_path(int a, int b) {\r\n        adj[a].push_back(b);\r\n    }\r\n\r\n    void dfs_set_root(int id, bool cartesian_decomposition = false) {\t// internal\r\n        if (cartesian_decomposition) {\r\n            in[id] = ct;\r\n            pos[ct] = id;\r\n            ct++;\r\n        }\r\n\r\n        sz[id]++;\r\n\r\n        for (auto p : adj[id]) {\r\n            if (parent[p] == -1) {\r\n                parent[p] = id;\r\n                depth[p] = depth[id] + 1;\r\n                dfs_set_root(p, cartesian_decomposition);\r\n                sz[id] += sz[p];\r\n\r\n                sons[id].push_back(p);\r\n            }\r\n        }\r\n\r\n        if (cartesian_decomposition) out[id] = ct - 1;\r\n    }\r\n\r\n    void set_root(int id, bool cartesian_decomposition = true) {\t\t// set root of the tree and calculate necessary info\r\n        if (cartesian_decomposition) {\r\n            in.resize(nn);\r\n            out.resize(nn);\r\n            pos.resize(nn);\r\n            ct = 0;\r\n        }\r\n\r\n        parent.assign(nn, -1);\r\n        depth.assign(nn, -1);\r\n        sz.assign(nn, 0);\r\n        sons.clear();\r\n        sons.resize(nn);\r\n\r\n        // dfs_set_root(id, cartesian_decomposition);\r\n\r\n\r\n        // set root using stack\r\n        stack<pair<int, int>> st;\t\t// id, # of sons processes\r\n        st.push({ id, 0 });\r\n        parent[id] = 0;\r\n        depth[id] = 0;\r\n\r\n        int ct = 0;\r\n\r\n        while (!st.empty()) {\r\n            int id = st.top().first, x = st.top().second;\r\n\r\n            if (x == 0) {\r\n                in[id] = ct;\r\n                pos[ct] = id;\r\n                sz[id] = 1;\r\n                ct++;\r\n            }\r\n\r\n            if (x >= adj[id].size()) {\r\n                out[id] = ct - 1;\r\n                if (parent[id] != -1) {\r\n                    sz[parent[id]] += sz[id];\r\n                }\r\n                st.pop();\r\n            }\r\n            else {\r\n\r\n                st.top().second++;\r\n\r\n                int p = adj[id][x];\r\n                if (parent[p] == -1) {\r\n                    parent[p] = id;\r\n                    depth[p] = depth[id] + 1;\r\n                    sons[id].push_back(p);\r\n                    st.push({ p, 0 });\r\n                }\r\n            }\r\n        }\r\n\r\n        int i = 0;\r\n    }\r\n\r\n    void eulerian_tour_dfs(int root, vector<int>& ans) {\r\n        ans.push_back(root);\r\n        for (auto p : sons[root]) {\r\n            eulerian_tour_dfs(p, ans);\r\n            ans.push_back(root);\r\n        }\r\n    }\r\n\r\n    vector<int> eulerian_tour(int root) {\r\n        vector<int> ans;\r\n\r\n        eulerian_tour_dfs(root, ans);\r\n\r\n        return ans;\r\n    }\r\n\r\n\r\n    void prep_LCA() {\t\t// prepare the sparse table for LCA calculation\r\n        MAXLEVEL = 1;\r\n        while ((1 << MAXLEVEL) < nn) MAXLEVEL++;\r\n        MAXLEVEL++;\r\n\r\n        pred.assign(MAXLEVEL, vector<int>(nn, 0));\r\n        pred[0] = parent;\r\n\r\n        int i, j, k;\r\n        for (i = 1; i < MAXLEVEL; i++) {\r\n            for (j = 0; j < nn; j++) {\r\n                if (pred[i - 1][j] != -1) pred[i][j] = pred[i - 1][pred[i - 1][j]];\r\n            }\r\n        }\r\n    }\r\n\r\n    int get_p_ancestor(int a, int p) {\t\t// get p-ancestor of node a;  need to call set_root() and prep_LCA() first\r\n        int i;\r\n        for (i = MAXLEVEL - 1; (i >= 0) && (p > 0) && (a != -1); i--) {\r\n            if ((1 << i) & p) {\r\n                p -= (1 << i);\r\n                a = pred[i][a];\r\n            }\r\n        }\r\n        return a;\r\n    }\r\n\r\n    int LCA(int a, int b) {\t\t// get the LCA of a and b, need to call set_root() and prep_LCA() first\r\n        int da = depth[a], db = depth[b];\r\n\r\n        if (da > db) {\r\n            swap(da, db);\r\n            swap(a, b);\r\n        }\r\n\r\n        int i, j, k;\r\n        for (i = MAXLEVEL - 1; i >= 0; i--) {\r\n            if (db - (1 << i) >= da) {\r\n                db -= (1 << i);\r\n                b = pred[i][b];\r\n            }\r\n        }\r\n\r\n        if (a == b) return a;\r\n\r\n        for (i = MAXLEVEL - 1; i >= 0; i--) {\r\n            if (pred[i][a] != pred[i][b]) {\r\n                a = pred[i][a];\r\n                b = pred[i][b];\r\n            }\r\n        }\r\n\r\n        return parent[a];\r\n    }\r\n\r\n    int get_distance(int a, int b) {\t// get distance between a and b, need to call set_root() and prep_LCA() first\r\n        int c = LCA(a, b);\r\n        int ans = depth[a] + depth[b] - 2 * depth[c];\r\n        return ans;\r\n    }\r\n\r\n    int get_diameter() {\r\n        int a, b, c, i, j, k, id, INF = nn + 100, ans;\r\n        vector<int> dist(nn), last(nn);\r\n        queue<int> q;\r\n\r\n        if (nn == 1) return 0;\r\n\r\n        // first pass, start with 1 -- any node\r\n        a = 1;\r\n        dist.assign(nn, INF);\r\n        dist[a] = 0;\r\n        q.push(a);\r\n\r\n        while (!q.empty()) {\r\n            id = q.front();\r\n            q.pop();\r\n\r\n            for (auto p : adj[id]) {\r\n                if (dist[p] == INF) {\r\n                    dist[p] = dist[id] + 1;\r\n                    q.push(p);\r\n                }\r\n            }\r\n        }\r\n\r\n        // second pass, start from the most remote node id, collect last to get ID\r\n        a = id;\r\n        dist.assign(nn, INF);\r\n        last.assign(nn, -1);\r\n        dist[a] = 0;\r\n        q.push(a);\r\n\r\n        while (!q.empty()) {\r\n            id = q.front();\r\n            q.pop();\r\n\r\n            for (auto p : adj[id]) {\r\n                if (dist[p] == INF) {\r\n                    dist[p] = dist[id] + 1;\r\n                    last[p] = id;\r\n                    q.push(p);\r\n                }\r\n            }\r\n        }\r\n\r\n        // a and id forms the diameter\r\n        ans = dist[id];\r\n\r\n        return ans;\r\n\r\n        // construct the path of diamter in path\r\n        vector<int> path;\r\n        b = id;\r\n        c = id;\r\n        do {\r\n            path.push_back(b);\r\n            b = last[b];\r\n        } while (b != -1);\r\n\r\n        return ans;\r\n    }\r\n};\r\n\r\n\r\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\r\n// initialize: UnionFind UF(N)\r\n\r\nclass UnionFind {                                              // OOP style\r\nprivate:\r\n    vector<int> p, rank, setSize;\r\n    // p = path toward the root of disjoint set; p[i] = i means it is root\r\n    // rank = upper bound of the actual height of the tree; not reliable as accurate measure\r\n    // setSize = size of each disjoint set\r\n\r\n    int numSets;\r\npublic:\r\n    UnionFind(int N) {\r\n        setSize.assign(N, 1);\r\n        numSets = N;\r\n        rank.assign(N, 0);\r\n        p.assign(N, 0);\r\n        for (int i = 0; i < N; i++) p[i] = i;\t// each belongs to its own set\r\n    }\r\n\r\n    int findSet(int i) {\r\n        return (p[i] == i) ? i : (p[i] = findSet(p[i]));\t\t// path compression: cut short of the path if possible\r\n    }\r\n\r\n    bool isSameSet(int i, int j) {\r\n        return findSet(i) == findSet(j);\r\n    }\r\n\r\n    void unionSet(int i, int j) {\r\n        if (!isSameSet(i, j)) {\r\n            numSets--;\r\n            int x = findSet(i), y = findSet(j);\r\n            // rank is used to keep the tree short\r\n            if (rank[x] > rank[y]) { p[y] = x; setSize[x] += setSize[y]; }\r\n            else {\r\n                p[x] = y; setSize[y] += setSize[x];\r\n                if (rank[x] == rank[y]) rank[y]++;\r\n            }\r\n        }\r\n    }\r\n\r\n    int numDisjointSets() {\t\t// # of disjoint sets\r\n        return numSets;\r\n    }\r\n\r\n    int sizeOfSet(int i) {\t\t// size of set\r\n        return setSize[findSet(i)];\r\n    }\r\n};\r\n\r\n\r\n#define MAXN 205000\t\t\t// total # of prime numbers\r\n#define MAXP 100100\t\t// highest number to test prime\r\n\r\nint prime[MAXN];\t\t// prime numbers: 2, 3, 5 ...\r\nint lp[MAXP];\t\t// lp[n] = n if n is prime; otherwise smallest prime factor of the number\r\nint phi[MAXP];\t\t\t// phii function\r\n\r\nclass prime_class {\r\npublic:\r\n    long top;\r\n\r\n    prime_class() {\t\t\t// generate all prime under MAXP\r\n        int i, i2, j;\r\n\r\n        top = 0;\r\n        lp[0] = 0;\r\n        lp[1] = 1;\r\n        for (i = 2; i < MAXP; i++) lp[i] = 0;\r\n\r\n        top = 0;\r\n        for (i = 2; i < MAXP; ++i) {\r\n            if (lp[i] == 0) {\r\n                lp[i] = i;\r\n                prime[top++] = i;\r\n            }\r\n            for (j = 0; (j < top) && (prime[j] <= lp[i]) && (i * prime[j] < MAXP); ++j)\r\n                lp[i * prime[j]] = prime[j];\r\n        }\r\n    }\r\n\r\n    bool isprime(long long key)\r\n    {\r\n        if (key < MAXP)\treturn (lp[key] == key) && (key >= 2);\r\n        else {\r\n            int i;\r\n            for (i = 0; (i < top) && (prime[i] * prime[i] <= key); i++)\r\n                if (key % prime[i] == 0) return false;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    unordered_map<int, int> factorize(int key) {\r\n        unordered_map<int, int> ans;\r\n\r\n        while (lp[key] != key) {\r\n            ans[lp[key]]++;\r\n            key /= lp[key];\r\n        }\r\n        if (key > 1) ans[key]++;\r\n\r\n        return ans;\r\n    }\r\n\r\n    vector<int> mobius(int n) {     // generate mobius function of size n\r\n        int i, j, k, ct, curr, cct, x, last;\r\n        vector<int> mobius(n + 1);\r\n        for (i = 1; i <= n; i++) {\r\n            curr = i; ct = 0; last = -1;\r\n\r\n            while (lp[curr] != curr) {\r\n                x = lp[curr];\r\n                if (x != last) {\r\n                    cct = 1;\r\n                    last = x;\r\n                    ct++;\r\n                }\r\n                else {\r\n                    if (++cct >= 2) {\r\n                        mobius[i] = 0;\r\n                        goto outer;\r\n                    }\r\n\r\n                }\r\n                curr /= lp[curr];\r\n            }\r\n            if (curr > 1) {\r\n                x = curr;\r\n                if (x != last) {\r\n                    cct = 1;\r\n                    last = x;\r\n                    ct++;\r\n                }\r\n                else {\r\n                    if (++cct >= 2) {\r\n                        mobius[i] = 0;\r\n                        goto outer;\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            if (ct % 2 == 0) mobius[i] = 1;\r\n            else mobius[i] = -1;\r\n\r\n        outer:;\r\n        }\r\n\r\n        return mobius;\r\n    }\r\n\r\n    int get_phi(int key) {\t// calculate Euler's totient function, also known as phi-function\r\n        int ans = key, last = 0;\r\n\r\n        while (lp[key] != key) {\r\n            if (lp[key] != last) {\r\n                last = lp[key];\r\n                ans -= ans / last;\r\n            }\r\n            key /= lp[key];\r\n        }\r\n        if ((key > 1) && (key != last)) ans -= ans / key;\r\n\r\n        return ans;\r\n    }\r\n\r\n    void calc_all_phi(int n) {\r\n        int i, j, k;\r\n        for (int i = 1; i < n; i++) phi[i] = i;\r\n        for (int i = 2; i < n; i++) {\r\n            if (phi[i] == i) {\r\n                for (int j = i; j < n; j += i) {\r\n                    phi[j] /= i;\r\n                    phi[j] *= i - 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    vector<pair<long long, long long>> factorize_full(long long key) {\t\t// can be used to factorize numbers >= MAXP\r\n        vector<pair<long long, long long>> ans;\r\n\r\n        long i, ct, sq = sqrt(key) + 10;\r\n\r\n        for (i = 0; (i < top) && (prime[i] <= sq); i++)\r\n            if (key % prime[i] == 0) {\r\n                ct = 0;\r\n                while (key % prime[i] == 0) {\r\n                    ct++;\r\n                    key /= prime[i];\r\n                }\r\n                ans.push_back({ prime[i], ct });\r\n            }\r\n        if (key > 1) {\r\n            ans.push_back({ key, 1 });\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    void generate_divisors(int step, int v, vector<pair<int, int>>& fp, vector<int>& ans) {\r\n        if (step < fp.size()) {\r\n            generate_divisors(step + 1, v, fp, ans);\r\n            for (int i = 1; i <= fp[step].second; i++) {\r\n                v *= fp[step].first;\r\n                generate_divisors(step + 1, v, fp, ans);\r\n            }\r\n        }\r\n        else ans.push_back(v);\r\n    }\r\n\r\n    void generate_divisors_full(long long step, long long v, vector<pair<long long, long long>>& fp, vector<long long>& ans) {\r\n        if (step < fp.size()) {\r\n            generate_divisors_full(step + 1, v, fp, ans);\r\n            for (int i = 1; i <= fp[step].second; i++) {\r\n                v *= fp[step].first;\r\n                generate_divisors_full(step + 1, v, fp, ans);\r\n            }\r\n        }\r\n        else ans.push_back(v);\r\n    }\r\n\r\n    vector<int> get_divisors(int key) {\r\n        unordered_map<int, int> f = factorize(key);\r\n        int n = f.size();\r\n        vector<pair<int, int>> fp;\r\n        for (auto p : f) fp.push_back(p);\r\n        vector<int> ans;\r\n        generate_divisors(0, 1, fp, ans);\r\n        return ans;\r\n    }\r\n\r\n    vector<long long> get_divisors_full(long long key) {\r\n        vector<pair<long long, long long>> f = factorize_full(key);\r\n        int n = f.size();\r\n        vector<pair<long long, long long>> fp;\r\n        for (auto p : f) fp.push_back(p);\r\n        vector<long long> ans;\r\n        generate_divisors_full(0, 1, fp, ans);\r\n        return ans;\r\n    }\r\n\r\n\r\n    long long get_divisors_count(long long key) {\r\n        vector<pair<long long, long long>> f = factorize_full(key);\r\n        long long ans = 1;\r\n        for (auto p : f) ans *= (p.second + 1);\r\n        return ans;\r\n    }\r\n\r\n};\r\n\r\n\r\nlong long mul_inv(long long a, long long b)\r\n{\r\n    long long b0 = b, t, q;\r\n    long long x0 = 0, x1 = 1;\r\n    if (b == 1) return 1;\r\n    while (a > 1) {\r\n        q = a / b;\r\n        t = b, b = a % b, a = t;\r\n        t = x0, x0 = x1 - q * x0, x1 = t;\r\n    }\r\n    if (x1 < 0) x1 += b0;\r\n    return x1;\r\n}\r\n\r\nlong long division(long long a, long long b, long long p) {\t\t// (a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p\r\n    long long ans, inv;\r\n    inv = mul_inv(b, p);\r\n    ans = ((a % p) * inv) % p;\r\n    return ans;\r\n}\r\n\r\n\r\n#define MP make_pair\r\n#define PB push_back\r\n#define F first\r\n#define S second\r\n#define LB lower_bound\r\n#define UB upper_bound\r\n\r\n#define SZ(x) ((int)x.size())\r\n#define LEN(x) ((int)x.length())\r\n#define ALL(x) begin(x), end(x)\r\n#define RSZ resize\r\n#define ASS assign\r\n#define REV(x) reverse(x.begin(), x.end());\r\n\r\n#define MAX(x) *max_element(ALL(x))\r\n#define MIN(x) *min_element(ALL(x))\r\n#define FOR(i, n) for (int i = 0; i < n; i++) \r\n#define FOR1(i, n) for (int i = 1; i <= n; i++) \r\n#define SORT(x) sort(x.begin(), x.end())\r\n#define RSORT(x) sort(x.rbegin(), x.rend())\r\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\r\n\r\n\r\n#define IN(x) cin >> x;\r\n#define OUT(x) cout << x << \"\\n\";\r\n#define INV(x, n) FOR(iiii, n) { cin >> x[iiii]; }\r\n#define INV1(x, n) FOR1(iiii, n) { cin >> x[iiii]; }\r\n#define OUTV(x, n) { FOR(iiii, n) { cout << x[iiii] << \" \"; } cout << \"\\n\"; }\r\n#define OUTV1(x, n) { FOR1(iiii, n) { cout << x[iiii] << \" \"; } cout << \"\\n\"; }\r\n#define OUTYN(x) { if (x) cout << \"YES\\n\"; else cout << \"NO\\n\"; }\r\n#define OUTyn(x) { if (x) cout << \"Yes\\n\"; else cout << \"No\\n\"; }\r\n\r\n\r\n#define MOD7 1000000007\r\n#define MOD9 1000000009\r\n#define MOD3 998244353\r\n\r\n\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n\r\n    LL n, i, j, k, x, a, b, aa, bb, d, cc, vv, r1, r2, MOD = MOD7, ans, minn, c1, c2, MAXX;\r\n    cin >> n >> k;\r\n    k /= 50;\r\n\r\n    factorial f(n + 10, MOD);\r\n\r\n    c1 = 0; c2 = 0;\r\n    FOR(i, n) {\r\n        cin >> x;\r\n        if (x == 50) c1++;\r\n        else c2++;\r\n    }\r\n\r\n    if (k == 0) minn = -1;\r\n    else if ((k == 1) && ((c2 > 0) || (c1 > 1))) minn = -1;\r\n    else if ((k == 2) && (c1 == 0)) minn = -1;\r\n    else {\r\n        // dp[c1 on left][c2 on left] = min trip to get there, ship is on left\r\n        // ct[c1 on left][c2 on left] = # of ways for minimal trip\r\n        VVL dp(c1 + 1, VL(c2 + 1, INF)), ct(c1 + 1, VL(c2 + 1, 1));\r\n        dp[c1][c2] = 0;\r\n        ct[c1][c2] = 1;\r\n        priority_queue<tuple<LL, LL, LL>> pq;\r\n        pq.push({ 0, c1, c2 });\r\n\r\n        while (!pq.empty()) {\r\n            tie(d, a, b) = pq.top();\r\n            pq.pop();\r\n            d = -d;\r\n\r\n            if (d != dp[a][b]) continue;\r\n            for (i = 0; i <= a; i++) {\r\n                for (j = 0; j <= b; j++) {\r\n                    if (i + j > 0) {\r\n                        if (i + j * 2 > k) break; \r\n                        // remaining people on the left\r\n                        aa = a - i; \r\n                        bb = b - j;\r\n\r\n                        cc = (f.calcc(a, i) * f.calcc(b, j)) % MOD;\r\n\r\n                        // ride back by r1 + r2\r\n                        for (r1 = 0; r1 <= c1 - aa; r1++) {\r\n                            for (r2 = 0; r2 <= c2 - bb; r2++) {\r\n                                if (r1 + r2 == 0) continue;\r\n                                if (r1 + r2 * 2 > k) break;\r\n\r\n                                vv = (f.calcc(c1 - aa, r1) * f.calcc(c2 - bb, r2)) % MOD;\r\n                                if (dp[aa + r1][bb + r2] > d + 2) {\r\n                                    dp[aa + r1][bb + r2] = d + 2;\r\n                                    ct[aa + r1][bb + r2] = (ct[a][b] * ((cc * vv) % MOD)) % MOD;\r\n                                    pq.push({ -(d + 2), aa + r1, bb + r2 });\r\n                                }\r\n                                else if (dp[aa + r1][bb + r2] == d + 2) {\r\n                                    ct[aa + r1][bb + r2] = (ct[aa + r1][bb + r2] + ct[a][b] * ((cc * vv) % MOD)) % MOD;\r\n                                }\r\n                            }\r\n                            vv = c1 - aa;\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        minn = INF;\r\n        FOR(i, c1 + 1) {\r\n            FOR(j, c2 + 1) {\r\n                if (i + j * 2 <= k) \r\n                    minn = min(minn, dp[i][j]);\r\n            }\r\n        }\r\n\r\n        ans = 0;\r\n        FOR(i, c1 + 1) {\r\n            FOR(j, c2 + 1) {\r\n                if ((i + j * 2 <= k) && (minn == dp[i][j])) ans += ct[i][j];\r\n            }\r\n        }\r\n        ans %= MOD;\r\n\r\n        if (minn >= INF) minn = -1;\r\n        else minn++;\r\n    }\r\n\r\n    if (minn == -1) ans = 0;\r\n\r\n    OUT(minn);\r\n    OUT(ans);\r\n    \r\n    return 0;\r\n}\r\n\r\n"
}