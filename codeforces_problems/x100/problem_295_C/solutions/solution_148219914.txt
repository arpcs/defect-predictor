{
    "id": 148219914,
    "contestId": 295,
    "creationTimeSeconds": 1646325174,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "lokesh_2052"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 44,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 409600,
    "source": "//auto r = s.lower_bound({p , std::numeric_limits<int>::min()});\r\n//https://mzhang2021.github.io/cp-blog/index.html\r\n//https://codeforces.com/bestRatingChanges/6118990\r\n#include<iostream>\r\n#include <bits/stdc++.h>\r\n#include<stdio.h>\r\n#include <string.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define INF 10007\r\n#define MAX 100005\r\n#define EPS 1e-9\r\n#define PI acos(-1.0)\r\n#define nl \"\\n\"\r\n#define F first\r\n#define S second\r\ntypedef pair<ll , ll> pi;\r\ntypedef vector<char> vc;\r\ntypedef vector<bool> vb;\r\ntypedef vector<ll> vi;\r\ntypedef vector< pair<ll , ll> > vpi;\r\n#define fr(i,n) for(i=0;i<n;i++)\r\n#define rep(i,a,n) for(i=a;i<n;i++)\r\n#define yeS(GOOD)      GOOD ? cout<<\"YES\\n\" : cout<<\"NO\\n\"\r\n#define all(a) a.begin() , a.end()\r\n#define pb push_back\r\n#define ar array\r\nll mod = (ll)1e9+7;\r\nll mod_mul(ll a, ll b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}\r\nll mod_add(ll a, ll b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}\r\nll binpow(ll a, ll b,ll mod){ll res=1;a%=mod;while(b>0){if(b&1)res=(res*a)%mod;a=(a*a)%mod;b>>=1;}return res;}\r\nll binmul(ll a, ll b){ll res=0;a%=mod;while(b>0){if(b&1)res=(res + a)%mod;a=(a + a)%mod;b>>=1;}return res;}\r\nll area(pi a, pi b,pi c){return abs(a.F * b.S + b.F * c.S + c.F*a.S - a.S * b.F - b.S * c.F - c.S * a.F);}\r\nll gcd (ll a,ll b){if(b==0)return a;else return gcd (b, a % b);}\r\nll lcm(ll a,ll b){return a / gcd(a,b) * b;}\r\nll min(ll a,ll b){if(a < b){return a;}return b;}\r\nll max(ll a,ll b){if(a > b){return a;}return b;}\r\ndouble intlog(ll n ,ll base){return (double)log(n)/log(base);}\r\nstring bin(ll n){if(n==0)return \"0\";string s;while(n){if(n%2){s='1'+s;}else{s='0'+s;}n/=2;}return s;}\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\nint randNo(int lo, int hi){hi++;return lo + rng() % (hi - lo);}\r\nll t , temp , temp2, k , i , j , u , n,q,v,p,m;\r\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v);\r\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.first << \", \" << p.second << \")\"; }\r\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\r\n    cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\r\n}\r\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\r\n    cin >> p.first;\r\n    return cin >> p.second;\r\n}\r\n\r\n\r\nconst int M=55;\r\n\r\n\r\nint dis[M][M][2];\r\nll ways[M][M][2];\r\nll dp[M][M];\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\" , \"r\" ,stdin);\r\n    freopen(\"output.txt\" , \"w\" , stdout);\r\n#endif\r\n    cin>>n>>k;\r\n    memset(dp,-1,sizeof(dp));\r\n    k/=50;\r\n    map<int,int>mp;\r\n    fr(i,n){\r\n        cin>>p;\r\n        mp[p/50]++;\r\n    }\r\n    struct N{int cnt1,cnt2;bool flag;};\r\n    queue<N>q;\r\n    for(int i=0;i<M;i++){\r\n        for(int j=0;j<M;j++){\r\n            dis[i][j][0]=dis[i][j][1]=INT_MAX;\r\n        }\r\n    }\r\n    dis[mp[1]][mp[2]][0]=0;\r\n    ways[mp[1]][mp[2]][0]=1;\r\n    auto C=[](ll n,ll r,const auto & C)->ll{\r\n        if(n<r)return 0;\r\n        if(r==0)return 1;\r\n        if(dp[n][r]!=-1)return dp[n][r];\r\n        return dp[n][r]=(C(n-1,r-1,C)+C(n-1,r,C))%mod;\r\n    };\r\n    q.push(N{mp[1],mp[2],0});\r\n    ll p = 1000000;\r\n    while(!q.empty()){\r\n        p--;\r\n        assert(p>=0);\r\n        N front=q.front();q.pop();\r\n        int cnt1,cnt2;\r\n        if(front.flag){\r\n            cnt1=mp[1]-front.cnt1;cnt2=mp[2]-front.cnt2;\r\n        }\r\n        else{\r\n            cnt1=front.cnt1;cnt2=front.cnt2;\r\n        }\r\n        assert(cnt1>=0 && cnt2>=0);\r\n        for(int i=0;i<=cnt1;i++){\r\n            for(int j=0;j<=cnt2;j++){\r\n                if(i+2*j<=k){\r\n                    if(i==0&&j==0)continue;\r\n                    if(front.flag){\r\n                        if(dis[front.cnt1+i][front.cnt2+j][!front.flag]>dis[front.cnt1][front.cnt2][front.flag]+1){\r\n                            dis[front.cnt1+i][front.cnt2+j][!front.flag]=dis[front.cnt1][front.cnt2][front.flag]+1;\r\n                            ways[front.cnt1+i][front.cnt2+j][!front.flag]=C(cnt1,i,C)*C(cnt2,j,C)%mod*ways[front.cnt1][front.cnt2][front.flag]%mod;\r\n                            q.push(N{front.cnt1+i,front.cnt2+j,!front.flag});\r\n                        }\r\n                        else if(dis[front.cnt1+i][front.cnt2+j][!front.flag]==dis[front.cnt1][front.cnt2][front.flag]+1){\r\n                            ways[front.cnt1+i][front.cnt2+j][!front.flag]+=C(cnt1,i,C)*C(cnt2,j,C)%mod*ways[front.cnt1][front.cnt2][front.flag]%mod;\r\n                            ways[front.cnt1+i][front.cnt2+j][!front.flag]%=mod;\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(dis[front.cnt1-i][front.cnt2-j][!front.flag]>dis[front.cnt1][front.cnt2][front.flag]+1){\r\n                            dis[front.cnt1-i][front.cnt2-j][!front.flag]=dis[front.cnt1][front.cnt2][front.flag]+1;\r\n                            ways[front.cnt1-i][front.cnt2-j][!front.flag]=C(cnt1,i,C)*C(cnt2,j,C)%mod*ways[front.cnt1][front.cnt2][front.flag]%mod;\r\n                            q.push(N{front.cnt1-i,front.cnt2-j,!front.flag});\r\n                        }\r\n                        else if(dis[front.cnt1-i][front.cnt2-j][!front.flag]==dis[front.cnt1][front.cnt2][front.flag]+1){\r\n                            ways[front.cnt1-i][front.cnt2-j][!front.flag]+=C(cnt1,i,C)*C(cnt2,j,C)%mod*ways[front.cnt1][front.cnt2][front.flag]%mod;\r\n                            ways[front.cnt1-i][front.cnt2-j][!front.flag]%=mod;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if(dis[0][0][1]==INT_MAX)dis[0][0][1]=-1;\r\n    cout<<dis[0][0][1]<<'\\n';\r\n    cout<<ways[0][0][1]<<'\\n';\r\n#ifndef ONLINE_JUDGE\r\n    cout << \"Running Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s .\\n\";\r\n#endif\r\n}\r\n\r\n//   k ^ a >= b + 1\r\n//\r\n//   A  AAAACBAAA   A -> 7 AA -> 5 AAA -> 3 AAAA -> 1 5  AABCA\r\n\r\n\r\n//Try to think every possible test case and then try to implement\r\n//Write Down the equation and try to solve it\r\n//Have done it before then just implement without thinking \r\n//Look deep into your soul, into the dark and foggy mist of your memories\r\n\r\n\r\n//Number Theory  -> could solve the question\r\n//BigManupulation -> can't solve()\r\n//Graph -> similiar problem going to face in graph \r\n// g++ lokesh.cpp -std=gnu++11\r\n\r\n/*\r\n#Sigma Rule :-\r\n        If you are not finding any mistake in code then there is mistake in your logic.\r\n\r\n*/"
}