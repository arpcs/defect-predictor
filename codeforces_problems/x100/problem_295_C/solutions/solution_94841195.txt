{
    "id": 94841195,
    "contestId": 295,
    "creationTimeSeconds": 1601981678,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 295,
        "index": "C",
        "name": "Greg and Friends",
        "type": "PROGRAMMING",
        "points": 1500.0,
        "rating": 2100,
        "tags": [
            "combinatorics",
            "dp",
            "graphs",
            "shortest paths"
        ]
    },
    "author": {
        "contestId": 295,
        "members": [
            {
                "handle": "beedle"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1365694200
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#define pi 3.141592653589793238\r\n#define ll long long\r\n#define rep(i,a,b) for(long long i=a;i<=b;i++)\r\n#define mod 1000000007\r\n#define INF 999999999999999999 \r\n#define pb push_back\r\n#define ff first\r\n#define ss second\r\n\r\n\r\n#if !defined(BOOST_FUNCTIONAL_HASH_HASH_HPP)\r\n#define BOOST_FUNCTIONAL_HASH_HASH_HPP\r\n\r\n#include <boost/functional/hash/hash_fwd.hpp>\r\n#include <functional>\r\n#include <boost/functional/hash/detail/hash_float.hpp>\r\n#include <string>\r\n#include <boost/limits.hpp>\r\n#include <boost/type_traits/is_enum.hpp>\r\n#include <boost/type_traits/is_integral.hpp>\r\n#include <boost/utility/enable_if.hpp>\r\n#include <boost/cstdint.hpp>\r\n\r\n#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)\r\n#include <boost/type_traits/is_pointer.hpp>\r\n#endif\r\n\r\n#if !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)\r\n#include <typeindex>\r\n#endif\r\n\r\n#if defined(BOOST_MSVC)\r\n#pragma warning(push)\r\n\r\n#if BOOST_MSVC >= 1400\r\n#pragma warning(disable:6295) // Ill-defined for-loop : 'unsigned int' values\r\n                              // are always of range '0' to '4294967295'.\r\n                              // Loop executes infinitely.\r\n#endif\r\n\r\n#endif\r\n\r\n#if BOOST_WORKAROUND(__GNUC__, < 3) \\\r\n    && !defined(__SGI_STL_PORT) && !defined(_STLPORT_VERSION)\r\n#define BOOST_HASH_CHAR_TRAITS string_char_traits\r\n#else\r\n#define BOOST_HASH_CHAR_TRAITS char_traits\r\n#endif\r\n\r\n#if defined(_MSC_VER)\r\n#   define BOOST_FUNCTIONAL_HASH_ROTL32(x, r) _rotl(x,r)\r\n#else\r\n#   define BOOST_FUNCTIONAL_HASH_ROTL32(x, r) (x << r) | (x >> (32 - r))\r\n#endif\r\n\r\nnamespace boost\r\n{\r\n    namespace hash_detail\r\n    {\r\n#if defined(_HAS_AUTO_PTR_ETC) && !_HAS_AUTO_PTR_ETC\r\n        template <typename T>\r\n        struct hash_base\r\n        {\r\n            typedef T argument_type;\r\n            typedef std::size_t result_type;\r\n        };\r\n#else\r\n        template <typename T>\r\n        struct hash_base : std::unary_function<T, std::size_t> {};\r\n#endif\r\n\r\n        struct enable_hash_value { typedef std::size_t type; };\r\n\r\n        template <typename T> struct basic_numbers {};\r\n        template <typename T> struct long_numbers;\r\n        template <typename T> struct ulong_numbers;\r\n        template <typename T> struct float_numbers {};\r\n\r\n        template <> struct basic_numbers<bool> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<char> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<unsigned char> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<signed char> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<short> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<unsigned short> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<int> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<unsigned int> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<long> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct basic_numbers<unsigned long> :\r\n            boost::hash_detail::enable_hash_value {};\r\n\r\n#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)\r\n        template <> struct basic_numbers<wchar_t> :\r\n            boost::hash_detail::enable_hash_value {};\r\n#endif\r\n\r\n        // long_numbers is defined like this to allow for separate\r\n        // specialization for long_long and int128_type, in case\r\n        // they conflict.\r\n        template <typename T> struct long_numbers2 {};\r\n        template <typename T> struct ulong_numbers2 {};\r\n        template <typename T> struct long_numbers : long_numbers2<T> {};\r\n        template <typename T> struct ulong_numbers : ulong_numbers2<T> {};\r\n\r\n#if !defined(BOOST_NO_LONG_LONG)\r\n        template <> struct long_numbers<boost::long_long_type> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct ulong_numbers<boost::ulong_long_type> :\r\n            boost::hash_detail::enable_hash_value {};\r\n#endif\r\n\r\n#if defined(BOOST_HAS_INT128)\r\n        template <> struct long_numbers2<boost::int128_type> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct ulong_numbers2<boost::uint128_type> :\r\n            boost::hash_detail::enable_hash_value {};\r\n#endif\r\n\r\n        template <> struct float_numbers<float> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct float_numbers<double> :\r\n            boost::hash_detail::enable_hash_value {};\r\n        template <> struct float_numbers<long double> :\r\n            boost::hash_detail::enable_hash_value {};\r\n    }\r\n\r\n    template <typename T>\r\n    typename boost::hash_detail::basic_numbers<T>::type hash_value(T);\r\n    template <typename T>\r\n    typename boost::hash_detail::long_numbers<T>::type hash_value(T);\r\n    template <typename T>\r\n    typename boost::hash_detail::ulong_numbers<T>::type hash_value(T);\r\n\r\n    template <typename T>\r\n    typename boost::enable_if<boost::is_enum<T>, std::size_t>::type\r\n        hash_value(T);\r\n\r\n#if !BOOST_WORKAROUND(__DMC__, <= 0x848)\r\n    template <class T> std::size_t hash_value(T* const&);\r\n#else\r\n    template <class T> std::size_t hash_value(T*);\r\n#endif\r\n\r\n#if !defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING)\r\n    template< class T, unsigned N >\r\n    std::size_t hash_value(const T (&x)[N]);\r\n\r\n    template< class T, unsigned N >\r\n    std::size_t hash_value(T (&x)[N]);\r\n#endif\r\n\r\n    template <class Ch, class A>\r\n    std::size_t hash_value(\r\n        std::basic_string<Ch, std::BOOST_HASH_CHAR_TRAITS<Ch>, A> const&);\r\n\r\n    template <typename T>\r\n    typename boost::hash_detail::float_numbers<T>::type hash_value(T);\r\n\r\n#if !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)\r\n    std::size_t hash_value(std::type_index);\r\n#endif\r\n\r\n    // Implementation\r\n\r\n    namespace hash_detail\r\n    {\r\n        template <class T>\r\n        inline std::size_t hash_value_signed(T val)\r\n        {\r\n             const unsigned int size_t_bits = std::numeric_limits<std::size_t>::digits;\r\n             // ceiling(std::numeric_limits<T>::digits / size_t_bits) - 1\r\n             const int length = (std::numeric_limits<T>::digits - 1)\r\n                 / static_cast<int>(size_t_bits);\r\n\r\n             std::size_t seed = 0;\r\n             T positive = val < 0 ? -1 - val : val;\r\n\r\n             // Hopefully, this loop can be unrolled.\r\n             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)\r\n             {\r\n                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);\r\n             }\r\n             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);\r\n\r\n             return seed;\r\n        }\r\n\r\n        template <class T>\r\n        inline std::size_t hash_value_unsigned(T val)\r\n        {\r\n             const unsigned int size_t_bits = std::numeric_limits<std::size_t>::digits;\r\n             // ceiling(std::numeric_limits<T>::digits / size_t_bits) - 1\r\n             const int length = (std::numeric_limits<T>::digits - 1)\r\n                 / static_cast<int>(size_t_bits);\r\n\r\n             std::size_t seed = 0;\r\n\r\n             // Hopefully, this loop can be unrolled.\r\n             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)\r\n             {\r\n                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);\r\n             }\r\n             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);\r\n\r\n             return seed;\r\n        }\r\n\r\n        template <typename SizeT>\r\n        inline void hash_combine_impl(SizeT& seed, SizeT value)\r\n        {\r\n            seed ^= value + 0x9e3779b9 + (seed<<6) + (seed>>2);\r\n        }\r\n\r\n        inline void hash_combine_impl(boost::uint32_t& h1,\r\n                boost::uint32_t k1)\r\n        {\r\n            const uint32_t c1 = 0xcc9e2d51;\r\n            const uint32_t c2 = 0x1b873593;\r\n\r\n            k1 *= c1;\r\n            k1 = BOOST_FUNCTIONAL_HASH_ROTL32(k1,15);\r\n            k1 *= c2;\r\n\r\n            h1 ^= k1;\r\n            h1 = BOOST_FUNCTIONAL_HASH_ROTL32(h1,13);\r\n            h1 = h1*5+0xe6546b64;\r\n        }\r\n\r\n\r\n// Don't define 64-bit hash combine on platforms without 64 bit integers,\r\n// and also not for 32-bit gcc as it warns about the 64-bit constant.\r\n#if !defined(BOOST_NO_INT64_T) && \\\r\n        !(defined(__GNUC__) && ULONG_MAX == 0xffffffff)\r\n\r\n        inline void hash_combine_impl(boost::uint64_t& h,\r\n                boost::uint64_t k)\r\n        {\r\n            const boost::uint64_t m = UINT64_C(0xc6a4a7935bd1e995);\r\n            const int r = 47;\r\n\r\n            k *= m;\r\n            k ^= k >> r;\r\n            k *= m;\r\n\r\n            h ^= k;\r\n            h *= m;\r\n\r\n            // Completely arbitrary number, to prevent 0's\r\n            // from hashing to 0.\r\n            h += 0xe6546b64;\r\n        }\r\n\r\n#endif // BOOST_NO_INT64_T\r\n    }\r\n\r\n    template <typename T>\r\n    typename boost::hash_detail::basic_numbers<T>::type hash_value(T v)\r\n    {\r\n        return static_cast<std::size_t>(v);\r\n    }\r\n\r\n    template <typename T>\r\n    typename boost::hash_detail::long_numbers<T>::type hash_value(T v)\r\n    {\r\n        return hash_detail::hash_value_signed(v);\r\n    }\r\n\r\n    template <typename T>\r\n    typename boost::hash_detail::ulong_numbers<T>::type hash_value(T v)\r\n    {\r\n        return hash_detail::hash_value_unsigned(v);\r\n    }\r\n\r\n    template <typename T>\r\n    typename boost::enable_if<boost::is_enum<T>, std::size_t>::type\r\n        hash_value(T v)\r\n    {\r\n        return static_cast<std::size_t>(v);\r\n    }\r\n\r\n    // Implementation by Alberto Barbati and Dave Harris.\r\n#if !BOOST_WORKAROUND(__DMC__, <= 0x848)\r\n    template <class T> std::size_t hash_value(T* const& v)\r\n#else\r\n    template <class T> std::size_t hash_value(T* v)\r\n#endif\r\n    {\r\n#if defined(__VMS) && __INITIAL_POINTER_SIZE == 64\r\n    // for some reason ptrdiff_t on OpenVMS compiler with\r\n    // 64 bit is not 64 bit !!!\r\n        std::size_t x = static_cast<std::size_t>(\r\n           reinterpret_cast<long long int>(v));\r\n#else\r\n        std::size_t x = static_cast<std::size_t>(\r\n           reinterpret_cast<std::ptrdiff_t>(v));\r\n#endif\r\n        return x + (x >> 3);\r\n    }\r\n\r\n#if defined(BOOST_MSVC)\r\n#pragma warning(push)\r\n#if BOOST_MSVC <= 1400\r\n#pragma warning(disable:4267) // 'argument' : conversion from 'size_t' to\r\n                              // 'unsigned int', possible loss of data\r\n                              // A misguided attempt to detect 64-bit\r\n                              // incompatability.\r\n#endif\r\n#endif\r\n\r\n    template <class T>\r\n    inline void hash_combine(std::size_t& seed, T const& v)\r\n    {\r\n        boost::hash<T> hasher;\r\n        return boost::hash_detail::hash_combine_impl(seed, hasher(v));\r\n    }\r\n\r\n#if defined(BOOST_MSVC)\r\n#pragma warning(pop)\r\n#endif\r\n\r\n    template <class It>\r\n    inline std::size_t hash_range(It first, It last)\r\n    {\r\n        std::size_t seed = 0;\r\n\r\n        for(; first != last; ++first)\r\n        {\r\n            hash_combine(seed, *first);\r\n        }\r\n\r\n        return seed;\r\n    }\r\n\r\n    template <class It>\r\n    inline void hash_range(std::size_t& seed, It first, It last)\r\n    {\r\n        for(; first != last; ++first)\r\n        {\r\n            hash_combine(seed, *first);\r\n        }\r\n    }\r\n\r\n#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x551))\r\n    template <class T>\r\n    inline std::size_t hash_range(T* first, T* last)\r\n    {\r\n        std::size_t seed = 0;\r\n\r\n        for(; first != last; ++first)\r\n        {\r\n            boost::hash<T> hasher;\r\n            seed ^= hasher(*first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\r\n        }\r\n\r\n        return seed;\r\n    }\r\n\r\n    template <class T>\r\n    inline void hash_range(std::size_t& seed, T* first, T* last)\r\n    {\r\n        for(; first != last; ++first)\r\n        {\r\n            boost::hash<T> hasher;\r\n            seed ^= hasher(*first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\r\n        }\r\n    }\r\n#endif\r\n\r\n#if !defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING)\r\n    template< class T, unsigned N >\r\n    inline std::size_t hash_value(const T (&x)[N])\r\n    {\r\n        return hash_range(x, x + N);\r\n    }\r\n\r\n    template< class T, unsigned N >\r\n    inline std::size_t hash_value(T (&x)[N])\r\n    {\r\n        return hash_range(x, x + N);\r\n    }\r\n#endif\r\n\r\n    template <class Ch, class A>\r\n    inline std::size_t hash_value(\r\n        std::basic_string<Ch, std::BOOST_HASH_CHAR_TRAITS<Ch>, A> const& v)\r\n    {\r\n        return hash_range(v.begin(), v.end());\r\n    }\r\n\r\n    template <typename T>\r\n    typename boost::hash_detail::float_numbers<T>::type hash_value(T v)\r\n    {\r\n        return boost::hash_detail::float_hash_value(v);\r\n    }\r\n\r\n#if !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)\r\n    inline std::size_t hash_value(std::type_index v)\r\n    {\r\n        return v.hash_code();\r\n    }\r\n#endif\r\n\r\n    //\r\n    // boost::hash\r\n    //\r\n    \r\n    // Define the specializations required by the standard. The general purpose\r\n    // boost::hash is defined later in extensions.hpp if\r\n    // BOOST_HASH_NO_EXTENSIONS is not defined.\r\n    \r\n    // BOOST_HASH_SPECIALIZE - define a specialization for a type which is\r\n    // passed by copy.\r\n    //\r\n    // BOOST_HASH_SPECIALIZE_REF - define a specialization for a type which is\r\n    // passed by const reference.\r\n    //\r\n    // These are undefined later.\r\n\r\n#define BOOST_HASH_SPECIALIZE(type) \\\r\n    template <> struct hash<type> \\\r\n         : public boost::hash_detail::hash_base<type> \\\r\n    { \\\r\n        std::size_t operator()(type v) const \\\r\n        { \\\r\n            return boost::hash_value(v); \\\r\n        } \\\r\n    };\r\n\r\n#define BOOST_HASH_SPECIALIZE_REF(type) \\\r\n    template <> struct hash<type> \\\r\n         : public boost::hash_detail::hash_base<type> \\\r\n    { \\\r\n        std::size_t operator()(type const& v) const \\\r\n        { \\\r\n            return boost::hash_value(v); \\\r\n        } \\\r\n    };\r\n\r\n    BOOST_HASH_SPECIALIZE(bool)\r\n    BOOST_HASH_SPECIALIZE(char)\r\n    BOOST_HASH_SPECIALIZE(signed char)\r\n    BOOST_HASH_SPECIALIZE(unsigned char)\r\n#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)\r\n    BOOST_HASH_SPECIALIZE(wchar_t)\r\n#endif\r\n    BOOST_HASH_SPECIALIZE(short)\r\n    BOOST_HASH_SPECIALIZE(unsigned short)\r\n    BOOST_HASH_SPECIALIZE(int)\r\n    BOOST_HASH_SPECIALIZE(unsigned int)\r\n    BOOST_HASH_SPECIALIZE(long)\r\n    BOOST_HASH_SPECIALIZE(unsigned long)\r\n\r\n    BOOST_HASH_SPECIALIZE(float)\r\n    BOOST_HASH_SPECIALIZE(double)\r\n    BOOST_HASH_SPECIALIZE(long double)\r\n\r\n    BOOST_HASH_SPECIALIZE_REF(std::string)\r\n#if !defined(BOOST_NO_STD_WSTRING) && !defined(BOOST_NO_INTRINSIC_WCHAR_T)\r\n    BOOST_HASH_SPECIALIZE_REF(std::wstring)\r\n#endif\r\n\r\n#if !defined(BOOST_NO_LONG_LONG)\r\n    BOOST_HASH_SPECIALIZE(boost::long_long_type)\r\n    BOOST_HASH_SPECIALIZE(boost::ulong_long_type)\r\n#endif\r\n\r\n#if defined(BOOST_HAS_INT128)\r\n    BOOST_HASH_SPECIALIZE(boost::int128_type)\r\n    BOOST_HASH_SPECIALIZE(boost::uint128_type)\r\n#endif\r\n\r\n#if !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)\r\n    BOOST_HASH_SPECIALIZE(std::type_index)\r\n#endif\r\n\r\n#undef BOOST_HASH_SPECIALIZE\r\n#undef BOOST_HASH_SPECIALIZE_REF\r\n\r\n// Specializing boost::hash for pointers.\r\n\r\n#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)\r\n\r\n    template <class T>\r\n    struct hash<T*>\r\n        : public boost::hash_detail::hash_base<T*>\r\n    {\r\n        std::size_t operator()(T* v) const\r\n        {\r\n#if !BOOST_WORKAROUND(__SUNPRO_CC, <= 0x590)\r\n            return boost::hash_value(v);\r\n#else\r\n            std::size_t x = static_cast<std::size_t>(\r\n                reinterpret_cast<std::ptrdiff_t>(v));\r\n\r\n            return x + (x >> 3);\r\n#endif\r\n        }\r\n    };\r\n\r\n#else\r\n\r\n    // For compilers without partial specialization, we define a\r\n    // boost::hash for all remaining types. But hash_impl is only defined\r\n    // for pointers in 'extensions.hpp' - so when BOOST_HASH_NO_EXTENSIONS\r\n    // is defined there will still be a compile error for types not supported\r\n    // in the standard.\r\n\r\n    namespace hash_detail\r\n    {\r\n        template <bool IsPointer>\r\n        struct hash_impl;\r\n\r\n        template <>\r\n        struct hash_impl<true>\r\n        {\r\n            template <class T>\r\n            struct inner\r\n                : public boost::hash_detail::hash_base<T>\r\n            {\r\n                std::size_t operator()(T val) const\r\n                {\r\n#if !BOOST_WORKAROUND(__SUNPRO_CC, <= 590)\r\n                    return boost::hash_value(val);\r\n#else\r\n                    std::size_t x = static_cast<std::size_t>(\r\n                        reinterpret_cast<std::ptrdiff_t>(val));\r\n\r\n                    return x + (x >> 3);\r\n#endif\r\n                }\r\n            };\r\n        };\r\n    }\r\n\r\n    template <class T> struct hash\r\n        : public boost::hash_detail::hash_impl<boost::is_pointer<T>::value>\r\n            ::BOOST_NESTED_TEMPLATE inner<T>\r\n    {\r\n    };\r\n\r\n#endif\r\n}\r\n\r\n#undef BOOST_HASH_CHAR_TRAITS\r\n#undef BOOST_FUNCTIONAL_HASH_ROTL32\r\n\r\n#if defined(BOOST_MSVC)\r\n#pragma warning(pop)\r\n#endif\r\n\r\n#endif // BOOST_FUNCTIONAL_HASH_HASH_HPP\r\n\r\n// Include this outside of the include guards in case the file is included\r\n// twice - once with BOOST_HASH_NO_EXTENSIONS defined, and then with it\r\n// undefined.\r\n\r\n#if !defined(BOOST_HASH_NO_EXTENSIONS) \\\r\n    && !defined(BOOST_FUNCTIONAL_HASH_EXTENSIONS_HPP)\r\n#include <boost/functional/hash/extensions.hpp>\r\n#endif\r\n\r\n\r\nusing namespace std;\r\n\r\nstd::vector <long long> fac(100+1,0);\r\n\r\nlong long binpow(long long a, long long b, long long m) {\r\n    a %= m;\r\n    long long res = 1;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = res * a % m;\r\n        a = a * a % m;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\nlong long InverseEuler(ll a, ll m)\r\n{return binpow(a,m-2,m);\r\n}\r\n\r\n\r\n\r\nlong long C(ll n, ll r, ll m)\r\n{\r\n    if(n<r)\r\n    return 0;\r\n    \r\n    //if(n==0)\r\n    //return 0;\r\n    \r\n    return (fac[n]*(InverseEuler((fac[n-r]*fac[r])%mod,m)))%m;\r\n}\r\n\r\nusing Key = std::tuple<char, int , int>;\r\n\r\nstruct KeyHash {\r\n    std::size_t operator()(const Key & key) const\r\n    {\r\n        return boost::hash_value(key);\r\n    }\r\n};\r\n\r\n\r\nint main()\r\n{\r\n    fac[0]=1;\r\n    rep(i,1,100)\r\n    fac[i]=(fac[i-1]*i)%mod;\r\n    \r\n    ll n,sboat;\r\n    cin>>n>>sboat;\r\n    \r\n    ll s1=0,s2=0;\r\n    \r\n    rep(i,1,n)\r\n    {\r\n        int a;\r\n        cin>>a;\r\n        if(a==50)\r\n        s1++;\r\n        else\r\n        s2++;\r\n    }\r\n    \r\n    unordered_map <tuple<char,int,int>,int,KeyHash> umap;\r\n    \r\n    int val=0;\r\n    \r\n    rep(i,0,s1)\r\n    rep(j,0,s2)\r\n    {\r\n        umap[make_tuple('a',int(i),int(j))]=val;\r\n        val++;\r\n    }\r\n    \r\n    int source=val-1;\r\n    \r\n    rep(i,0,s1)\r\n    rep(j,0,s2)\r\n    {\r\n        umap[make_tuple('b',int(i),int(j))]=val;\r\n        val++;\r\n    }\r\n    \r\n    int s=val;\r\n    \r\n    int sink=val-1;\r\n    \r\n    vector <pair<ll,ll>> adj[s];\r\n    \r\n    rep(i,0,s1)\r\n    rep(j,0,s2)\r\n    rep(k,0,s1)\r\n    rep(l,0,s2)\r\n    {\r\n        if((-s1+i+k)*50+(-s2+j+l)*100>sboat)\r\n        continue;\r\n        \r\n        if(-s1+i+k<0 || -s2+j+l<0)\r\n        continue;\r\n        \r\n        ll vald=(C(i,i+k-s1,mod)*C(j,l+j-s2,mod))%mod;\r\n        if(vald==0)\r\n        continue;\r\n        \r\n        adj[umap[make_tuple('a',int(i),int(j))]].push_back({umap[make_tuple('b',int(k),int(l))] , vald });\r\n        \r\n    }\r\n    \r\n    rep(i,0,s1)\r\n    rep(j,0,s2)\r\n    rep(k,0,s1)\r\n    rep(l,0,s2)\r\n    {\r\n        if((-s1+i+k)*50+(-s2+j+l)*100>sboat)\r\n        continue;\r\n        \r\n        if(-s1+i+k<0 || -s2+j+l<0)\r\n        continue;\r\n        \r\n        if(-s1+i+k-s2+j+l==0)\r\n        continue;\r\n        \r\n        ll vald=(C(i,i+k-s1,mod)*C(j,l+j-s2,mod))%mod;\r\n        \r\n        if(vald==0)\r\n        continue;\r\n        \r\n        adj[umap[make_tuple('b',int(i),int(j))]].push_back({umap[make_tuple('a',int(k),int(l))] , vald });\r\n        \r\n    }\r\n    \r\n    \r\n    vector <ll> d(s,0);\r\n    vector <ll> depth(s,-1);\r\n    d[source]=1;\r\n    depth[source]=0;\r\n    vector <bool> used(s,false);\r\n    \r\n    std::queue<ll> q;\r\n    used[source]=true;\r\n    q.push(source);\r\n    \r\n    while(!q.empty())\r\n    {\r\n        ll v=q.front();\r\n        q.pop();\r\n        \r\n        for(auto u:adj[v])\r\n        if(!used[u.first])\r\n        {\r\n            used[u.first]=true;\r\n            d[u.first]=(d[v]*u.second)%mod;\r\n            depth[u.first]=depth[v]+1;\r\n            q.push(u.first);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    cout<<depth[sink]<<endl<<d[sink];\r\n    \r\n    //rep(i,0,s-1)\r\n    //cout<<adj[i].size()<<endl;\r\n    \r\n    \r\n    \r\n    \r\n    return 0;\r\n}"
}