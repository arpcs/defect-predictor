{
    "id": 181078823,
    "contestId": 164,
    "creationTimeSeconds": 1668512017,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 164,
        "index": "A",
        "name": "Variable, or There and Back Again",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1700,
        "tags": [
            "dfs and similar",
            "graphs"
        ]
    },
    "author": {
        "contestId": 164,
        "members": [
            {
                "handle": "Aleks5d"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1333897500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 4,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 819200,
    "source": "#pragma optimize(\"SEX_ON_THE_BEACH\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"unroll-all-loops\")\n#pragma GCC optimize(\"O3\")\n \n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"fast-math\")\n//#define _FORTIFY_SOURCE 0 \n#pragma GCC optimize(\"no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\") \n\n#include<bits/stdc++.h>\n#include <x86intrin.h>\n\nusing uint = unsigned int;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing dd = double;\nusing ldd = long double;\nusing pii = std::pair<int, int>;\nusing pll = std::pair<ll, ll>;\nusing pdd = std::pair<dd, dd>;\nusing pld = std::pair<ldd, ldd>;\n\nnamespace fast {\n    template<typename T>\n    T gcd(T a, T b) {\n        return gcd(a, b);\n    }\n\n    template<>\n    unsigned int gcd<unsigned int>(unsigned int u, unsigned int v) {\n        int shift;\n        if (u == 0)\n            return v;\n        if (v == 0)\n            return u;\n        shift = __builtin_ctz(u | v);\n        u >>= __builtin_ctz(u);\n        do {\n            unsigned int m;\n            v >>= __builtin_ctz(v);\n            v -= u;\n            m = (int)v >> 31;\n            u += v & m;\n            v = (v + m) ^ m;\n        } while (v != 0);\n        return u << shift;\n    }\n\n    template<>\n    unsigned long long gcd<unsigned long long>(unsigned long long u, unsigned long long v) {\n        int shift;\n        if (u == 0)\n            return v;\n        if (v == 0)\n            return u;\n        shift = __builtin_ctzll(u | v);\n        u >>= __builtin_ctzll(u);\n        do {\n            unsigned long long m;\n            v >>= __builtin_ctzll(v);\n            v -= u;\n            m = (long long)v >> 63;\n            u += v & m;\n            v = (v + m) ^ m;\n        } while (v != 0);\n        return u << shift;\n    }\n\n    template<size_t N>\n    struct bitset {\n        size_t sz = (N + 63) / 64;\n        ull arr[(N + 63) / 64];\n        ull inv = -1;\n        ull last_item_mask = N % 64 ? ((1ULL << (N % 64)) - 1) : inv;\n\n        bitset() {\n            static_assert(N > 0, \"empty bitset not available\");\n            reset();\n        }\n\n        size_t size() {\n            return N;\n        }\n\n        size_t count() {\n            arr[sz - 1] &= last_item_mask;\n            size_t res = 0;\n            for (size_t i = 0; i < sz; ++i) {\n                res += __builtin_popcountll(arr[i]);\n            }\n            return res;\n        }\n\n        void flip() {\n            for (size_t i = 0; i < sz; ++i) {\n                arr[i] ^= inv;\n            }\n        }\n\n        void flip(size_t l) {\n            size_t lb = l / 64, lp = l % 64;\n            arr[lb] ^= 1ULL << lp;\n        }\n\n        void flip(size_t l, size_t r) {\n            size_t lb = l / 64, lp = l % 64;\n            size_t rb = r / 64, rp = r % 64;\n            arr[lb] ^= (1ULL << lp) - 1;\n            arr[rb] ^= (rp == 63 ? inv : (1ULL << (rp + 1)) - 1);\n            if (lb == rb) return;\n            arr[lb] ^= inv;\n            ++lb;\n            while (lb < rb) {\n                arr[lb++] ^= inv;\n            }\n        }\n\n        bool get(size_t l) {\n            size_t lb = l / 64, lp = l % 64;\n            return (arr[lb] >> lp) & 1;\n        }\n\n        void set() {\n            for (size_t i = 0; i < sz; ++i) {\n                arr[i] = inv;\n            }\n        }\n\n        void set(size_t l) {\n            size_t lb = l / 64, lp = l % 64;\n            arr[lb] |= 1ULL << lp;\n        }\n\n        void set(size_t l, size_t r) {\n            size_t lb = l / 64, lp = l % 64;\n            size_t rb = r / 64, rp = r % 64;\n            if (lb == rb) {\n                arr[lb] |= ((1ULL << (rp - lp + 1)) - 1) << lp;\n                return;\n            }\n            arr[lb] |= inv << lp;\n            arr[rb] |= (rp == 63 ? inv : (1ULL << (rp + 1)) - 1);\n            ++lb;\n            while (lb < rb) {\n                arr[lb++] |= inv;\n            }\n        }\n\n        void reset() {\n            for (int i = 0; i < sz; ++i) {\n                arr[i] = 0ULL;\n            }\n        }\n\n        void reset(size_t l) {\n            size_t lb = l / 64, lp = l % 64;\n            arr[lb] &= inv ^ (1ULL << lp);\n        }\n\n        void reset(size_t l, size_t r) {\n            size_t lb = l / 64, lp = l % 64;\n            size_t rb = r / 64, rp = r % 64;\n            if (lb == rb) {\n                arr[lb] &= inv ^ ((1ULL << (rp - lp + 1) - 1) << lp);\n                return;\n            }\n            arr[lb] &= (1ULL << lp) - 1;\n            arr[rb] &= (rp == 63 ? 0 : (inv << (rp + 1)));\n        }\n\n        bitset& operator|=(bitset<N>& other) {\n            for (size_t i = 0; i < sz; ++i) {\n                arr[i] |= other.arr[i];\n            }\n            return *this;\n        }\n\n        bitset& operator&=(bitset<N>& other) {\n            for (size_t i = 0; i < sz; ++i) {\n                arr[i] &= other.arr[i];\n            }\n            return *this;\n        }\n\n        bitset& operator^=(bitset<N>& other) {\n            for (size_t i = 0; i < sz; ++i) {\n                arr[i] ^= other.arr[i];\n            }\n            return *this;\n        }\n\n        bitset& operator<<=(size_t shift) {\n            size_t sb = shift / 64, sp = shift % 64;\n            //big shift per blocks\n            if (sb) {\n                size_t i;\n                for (i = sz - 1; i >= sb; --i) {\n                    arr[i] = arr[i - sb];\n                }\n                for (; i > 0; --i) {\n                    arr[i] = 0;\n                }\n                arr[0] = 0;\n            }\n            //small shift \n            if (sp) {\n                size_t sp_rev = 64 - sp;\n                for (size_t i = sz - 1; i > 0; --i) {\n                    arr[i] <<= sp;\n                    arr[i] |= arr[i - 1] >> sp_rev;\n                }\n                arr[0] <<= sp;\n            }\n\n            return *this;\n        }\n\n        bitset& operator>>=(size_t shift) {\n            size_t sb = shift / 64, sp = shift % 64;\n            //big shift per blocks\n            if (sb) {\n                size_t i;\n                for (i = 0; i + sb < sz; ++i) {\n                    arr[i] = arr[i + sb];\n                }\n                for (; i < sz; ++i) {\n                    arr[i] = 0;\n                }\n            }\n            //small shift \n            if (sp) {\n                size_t sp_rev = 64 - sp;\n                for (size_t i = 0; i < sz - 1; ++i) {\n                    arr[i] >>= sp;\n                    arr[i] |= (arr[i + 1] & ((1ULL << sp) - 1)) << sp_rev;\n                }\n                arr[sz - 1] >>= sp;\n            }\n\n            return *this;\n        }\n\n        size_t next_zero(size_t l) {\n            arr[sz - 1] |= ~last_item_mask;\n            size_t lb = l / 64, lp = l % 64;\n            if ((~arr[lb]) >> lp) {\n                return lb * 64 + __builtin_ctzll((~arr[lb]) >> lp) + lp;\n            }\n            ++lb;\n            while (lb < sz) {\n                if (~arr[lb]) {\n                    return lb * 64 + __builtin_ctzll(~arr[lb]);\n                }\n                ++lb;\n            }\n            return size();\n        }\n\n        size_t first_zero() {\n            arr[sz - 1] |= ~last_item_mask;\n            for (size_t i = 0; i < sz; ++i) {\n                if (~arr[i]) {\n                    return i * 64 + __builtin_ctzll(~arr[i]);\n                }\n            }\n            return size();\n        }\n\n        size_t next_one(size_t l) {\n            arr[sz] &= last_item_mask;\n            size_t lb = l / 64, lp = l % 64;\n            if (arr[lb] >> lp) {\n                return lb * 64 + __builtin_ctzll(arr[lb] >> lp) + lp;\n            }\n            ++lb;\n            while (lb < sz) {\n                if (arr[lb]) {\n                    return lb * 64 + __builtin_ctzll(arr[lb]);\n                }\n                ++lb;\n            }\n            return size();\n        }\n\n        size_t first_one() {\n            arr[sz] &= last_item_mask;\n            for (size_t i = 0; i < sz; ++i) {\n                if (arr[i]) {\n                    return i * 64 + __builtin_ctzll(arr[i]);\n                }\n            }\n            return size();\n        }\n\n        size_t last_one() {\n            arr[sz - 1] &= last_item_mask;\n            for (size_t i = sz - 1; i > 0; --i) {\n                if (arr[i]) {\n                    return i * 64 + 63 - __builtin_clzll(arr[i]);\n                }\n            }\n            if (arr[0])\n                return 63 - __builtin_clzll(arr[0]);\n            return -1;\n        }\n\n        size_t last_zero() {\n            arr[sz - 1] |= ~last_item_mask;\n            for (size_t i = sz - 1; i > 0; --i) {\n                if (~arr[i]) {\n                    return i * 64 + 63 - __builtin_clzll(~arr[i]);\n                }\n            }\n            if (~arr[0])\n                return 63 - __builtin_clzll(~arr[0]);\n            return -1;\n        }\n    };\n\n    template<size_t N>\n    std::ostream& operator<<(std::ostream& os, bitset<N> other) {\n        for (int i = 0; i < other.size(); ++i) {\n            os << other.get(i);\n        }\n        return os;\n    }\n}\n \nnamespace someUsefull {\n    template<typename T1, typename T2>\n    inline void checkMin(T1& a, T2 b) {\n        if (a > b)\n            a = b;\n    }\n \n    template<typename T1, typename T2>\n    inline void checkMax(T1& a, T2 b) {\n        if (a < b)\n            a = b;\n    }\n\n    template<typename T1, typename T2>\n    inline bool checkMinRes(T1& a, T2 b) {\n        if (a > b) {\n            a = b;\n            return true;\n        }\n        return false;\n    }\n\n    template<typename T1, typename T2>\n    inline bool checkMaxRes(T1& a, T2 b) {\n        if (a < b) {\n            a = b;\n            return true;\n        }\n        return false;\n    }\n}\n \nnamespace operators {\n    template<typename T1, typename T2>\n    std::istream& operator>>(std::istream& in, std::pair<T1, T2>& x) {\n        in >> x.first >> x.second;\n        return in;\n    }\n \n    template<typename T1, typename T2>\n    std::ostream& operator<<(std::ostream& out, std::pair<T1, T2> x) {\n        out << x.first << \" \" << x.second;\n        return out;\n    }\n \n    template<typename T1>\n    std::istream& operator>>(std::istream& in, std::vector<T1>& x) {\n        for (auto& i : x) in >> i;\n        return in;\n    }\n \n    template<typename T1>\n    std::ostream& operator<<(std::ostream& out, std::vector<T1>& x) {\n        for (auto& i : x) out << i << \" \";\n        return out;\n    }\n}\n \n//name spaces\nusing namespace std;\nusing namespace operators;\nusing namespace someUsefull;\n//end of name spaces\n \n//defines\n#define ff first\n#define ss second\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define NO {cout << \"NO\"; return;}\n#define YES {cout << \"YES\"; return;}\n \n//end of defines\n//#undef HOME\n//debug defines\n#ifdef HOME\n    #define debug(x) cerr << #x << \" \" << (x) << endl;\n    #define debug_v(x) {cerr << #x << \" \"; for (auto ioi : x) cerr << ioi << \" \"; cerr << endl;}\n    #define debug_vp(x) {cerr << #x << \" \"; for (auto ioi : x) cerr << '[' << ioi.ff << \" \" << ioi.ss << ']'; cerr << endl;}\n    #define debug_v_v(x) {cerr << #x << \"/*\\n\"; for (auto ioi : x) { for (auto ioi2 : ioi) cerr << ioi2 << \" \"; cerr << '\\n';} cerr << \"*/\" << #x << endl;}\n    int jjj;\n    #define wait() cin >> jjj;\n    #define PO cerr << \"POMELO\" << endl;\n    #define OL cerr << \"OLIVA\" << endl;\n    #define gen_clock(x) cerr << \"Clock \" << #x << \" created\" << endl; ll x = clock(); \n    #define check_clock(x) cerr << \"Time spent in \" << #x << \": \" << clock() - x << endl; x = clock();\n    #define reset_clock(x) x = clock();\n    #define say(x) cerr << x << endl;\n#else\n    #define debug(x) 0;\n    #define debug_v(x) 0;\n    #define debug_vp(x) 0;\n    #define debug_v_v(x) 0;\n    #define wait() 0;\n    #define PO 0;\n    #define OL 0;\n    #define gen_clock(x) 0;\n    #define check_clock(x) 0;\n    #define reset_clock(x) 0;\n    #define say(x) 0;\n#endif // HOME\n\nvector<vector<int>> gr, rgr;\nvector<int> type;\nvector<int> was1, was2;\n\nvoid dfs1(int v) {\n    was1[v] = 1;\n    if (type[v] == 2) return;\n    for (int to : gr[v]) {\n        if (!was1[to]) dfs1(to);\n    }\n}\n\nvoid dfs2(int v) {\n    was2[v] = 1;\n    if (type[v] == 1) return;\n    for (int to : rgr[v]) {\n        if (!was2[to]) dfs2(to);\n    }\n}\n\nvoid solve(int test) {\n    int n, m;\n    cin >> n >> m;\n    gr.resize(n);\n    rgr.resize(n);\n    type.resize(n);\n    cin >> type;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        gr[a - 1].push_back(b - 1);\n        rgr[b - 1].push_back(a - 1);\n    }\n\n    was1.resize(n);\n    for (int i = 0; i < n; ++i) {\n        if (type[i] == 1 && was1[i] == 0) dfs1(i);\n    }\n\n    was2.resize(n);\n    for (int i = 0; i < n; ++i) {\n        if (type[i] == 2 && was2[i] == 0) dfs2(i);\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        cout << (was1[i] & was2[i]) << '\\n';\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cout.tie(0);\n    cin.tie(0);\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n\n    int t = 1;\n    //cin >> t;\n    for (int i = 0; i < t; ++i) {\n        solve(i+1);\n        cout << '\\n';\n        //PO;\n    }\n    return 0;\n}\n/*\n*/"
}