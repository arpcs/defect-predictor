{
    "id": 231538269,
    "contestId": 1895,
    "creationTimeSeconds": 1699245082,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1895,
        "index": "E",
        "name": "Infinite Card Game",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "games",
            "graphs",
            "greedy",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1895,
        "members": [
            {
                "handle": "shorya1835"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1699022100
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<iostream>\r\n#include <forward_list>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<cstring>\r\n#include<cmath>\r\n#include<cctype>\r\n#include <climits>\r\n#include <fstream>\r\n#include <random>\r\n#include<list>\r\n#include<iomanip>\r\n#include<numeric>\r\n#include<map>\r\n#include<bitset>\r\n#include<unordered_map>\r\n#include<string>\r\n#include<set>\r\n#include<stack>\r\n#include<queue>\r\n#include<functional>\r\n#include<deque>\r\n#include<utility>\r\n#include <chrono>\r\nusing namespace std::chrono;\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\ntypedef set<int> si;\r\ntypedef pair<int, int> pi;\r\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\r\n#define fo(i, a, b) for (ll i = a; i < b; i++)\r\n#define F first\r\n#define S second\r\n#define pb push_back\r\n#define mp make_pair\r\n#define no cout << \"No\" << \"\\n\"\r\n#define yes cout << \"Yes\" << \"\\n\"\r\nll p = 1e9 + 7;\r\n#define mod p\r\nvector<ll> primes;\r\nset<ll> primes_set;\r\nvector<ll> fac;\r\nvector<int> pf;\r\nvector<ll> mob;\r\nvector<ll> phi;\r\nvector<bool> prime;\r\nvoid sieve(int n)\r\n{\r\n    prime.resize(n + 1);\r\n    for (int p = 0; p <= n; p++) {\r\n        prime[p] = 1;\r\n    }\r\n    for (int p = 2; p * p <= n; p++) {\r\n        if (prime[p] == true) {\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n    for (int p = 2; p <= n; p++)\r\n        if (prime[p])\r\n            primes.pb(p);\r\n}\r\nvoid sieve_set(int n)\r\n{\r\n    prime.resize(n + 1);\r\n    for (int p = 0; p <= n; p++) {\r\n        prime[p] = 1;\r\n    }\r\n    for (int p = 2; p * p <= n; p++) {\r\n        if (prime[p] == true) {\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n    for (int p = 2; p <= n; p++)\r\n        if (prime[p])\r\n            primes_set.insert(p);\r\n}\r\n\r\n\r\nvoid sievepf(int n)\r\n{\r\n    for (int i = 0; i <= n; ++i) {\r\n        pf.pb(0);\r\n    }\r\n    for (int i = 2; i <= n; ++i) {\r\n        if (pf[i] == 0) {\r\n            pf[i] = i;\r\n            primes.push_back(i);\r\n        }\r\n        for (int j = 0; i * primes[j] <= n; ++j) {\r\n            pf[i * primes[j]] = primes[j];\r\n            if (primes[j] == pf[i]) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid mobius(int n) {\r\n    sievepf(n);\r\n    for (int i = 0; i <= n; ++i) {\r\n        mob.pb(0);\r\n    }\r\n    mob[1] = 1;\r\n    for (int i = 2; i <= n; ++i) {\r\n        if (pf[i] == i)mob[i] = -1;\r\n        else {\r\n            if ((i / pf[i]) % pf[i] == 0)mob[i] = 0;\r\n            else mob[i] = mob[pf[i]] * mob[i / pf[i]];\r\n        }\r\n    }\r\n}\r\nint gcd(int a, int b) {\r\n    if (a == 0)return b;\r\n    else return gcd(b % a, a);\r\n}\r\ninline long long mul(long long x, long long y)\r\n{\r\n    return ((x % mod) * 1ll * (y % mod)) % mod;\r\n}\r\nlong long binpow(long long a, long long b)\r\n{\r\n    long long res = 1;\r\n    a %= mod;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = (res * a) % mod;\r\n        a = (a * a) % mod;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\nll gcd_dio(ll a, ll b, ll& x, ll& y) {\r\n    if (b == 0) {\r\n        x = 1;\r\n        y = 0;\r\n        return a;\r\n    }\r\n    ll x1, y1;\r\n    ll d = gcd_dio(b, a % b, x1, y1);\r\n    x = y1;\r\n    y = x1 - y1 * (a / b);\r\n    return d;\r\n}\r\nll binpow2(ll a, ll b) {\r\n    ll mod1 = mod - 1;\r\n    long long res = 1;\r\n    while (b > 0) {\r\n        if (b & 1)\r\n            res = (res * a) % mod1;\r\n        a = (a * a) % mod1;\r\n        b >>= 1;\r\n    }\r\n    return res;\r\n}\r\nlong long inv(long long x)\r\n{\r\n    return binpow(x % mod, mod - 2);\r\n}\r\n\r\nlong long divide(long long x, long long y)\r\n{\r\n    return mul(x, inv(y));\r\n}\r\ninline long long add(long long x, long long y)\r\n{\r\n    x %= mod;\r\n    y %= mod;\r\n\r\n    return (x + y) % mod;\r\n}\r\n\r\ninline long long sub(long long A, long long B)\r\n{\r\n    A = (A - B) % mod;\r\n    return (A + mod) % mod;\r\n}\r\nvoid fact(long long c) {\r\n    fac.pb(1);\r\n    for (long long i = 1; i <= c; ++i) {\r\n        fac.pb(mul(fac[i - 1], i));\r\n    }\r\n}\r\nll fib(ll n) {\r\n    ll c[4] = { 1,1,1,0 };\r\n    ll ans[4] = { 1,0,0,1 };\r\n    ll base[4];\r\n    base[0] = c[0];\r\n    base[1] = c[1];\r\n    base[2] = c[2];\r\n    base[3] = c[3];\r\n    ll base1[4];\r\n    if (n == 0) {\r\n        return 0;\r\n    }\r\n    if (n == 1 || n == 2) {\r\n        return 1;\r\n    }\r\n    n -= 2;\r\n    while (n > 0) {\r\n        if ((n & 1) == 1) {\r\n            base1[0] = ans[0];\r\n            base1[1] = ans[1];\r\n            base1[2] = ans[2];\r\n            base1[3] = ans[3];\r\n            ans[0] = add(mul(base1[0], base[0]), mul(base1[1], base[2]));\r\n            ans[1] = add(mul(base1[0], base[1]), mul(base1[1], base[3]));\r\n            ans[2] = add(mul(base1[2], base[0]), mul(base1[3], base[2]));\r\n            ans[3] = add(mul(base1[2], base[1]), mul(base1[3], base[3]));\r\n        }\r\n        base1[0] = base[0];\r\n        base1[1] = base[1];\r\n        base1[2] = base[2];\r\n        base1[3] = base[3];\r\n        base[0] = add(mul(base1[0], base1[0]), mul(base1[1], base1[2]));\r\n        base[1] = add(mul(base1[0], base1[1]), mul(base1[1], base1[3]));\r\n        base[2] = add(mul(base1[2], base1[0]), mul(base[3], base1[2]));\r\n        base[3] = add(mul(base1[2], base1[1]), mul(base1[3], base1[3]));\r\n        n >>= 1;\r\n    }\r\n    return add(ans[0], ans[1]);\r\n}\r\nll inverse(ll a, ll m)\r\n{\r\n    ll x, y;\r\n    ll g = gcd_dio(a, m, x, y);\r\n    if (g != 1) {\r\n        return -1;\r\n    }\r\n    else {\r\n        x = (x % m + m) % m;\r\n        return x;\r\n    }\r\n}\r\nstack<pair<ll, ll>> s1, s2;\r\nll getmin() {\r\n    ll minimum;\r\n    if (s1.empty() || s2.empty())\r\n        minimum = s1.empty() ? s2.top().second : s1.top().second;\r\n    else\r\n        minimum = min(s1.top().second, s2.top().second);\r\n    return minimum;\r\n}\r\nvoid addele(ll new_element) {\r\n    ll minimum = s1.empty() ? new_element : min(new_element, s1.top().second);\r\n    s1.push({ new_element, minimum });\r\n}\r\nvoid remove() {\r\n    if (s2.empty()) {\r\n        while (!s1.empty()) {\r\n            ll element = s1.top().first;\r\n            s1.pop();\r\n            ll minimum = s2.empty() ? element : min(element, s2.top().second);\r\n            s2.push({ element, minimum });\r\n        }\r\n    }\r\n    s2.pop();\r\n}\r\nvoid clears() {\r\n    while (!s1.empty())s1.pop();\r\n    while (!s2.empty())s2.pop();\r\n}\r\nstack<pair<ll, ll>> s3, s4;\r\nll getmax() {\r\n    ll maximum;\r\n    if (s3.empty() || s4.empty())\r\n        maximum = s3.empty() ? s4.top().second : s3.top().second;\r\n    else\r\n        maximum = max(s3.top().second, s4.top().second);\r\n    return maximum;\r\n}\r\nvoid addele1(ll new_element) {\r\n    ll maximum = s3.empty() ? new_element : max(new_element, s3.top().second);\r\n    s3.push({ new_element, maximum });\r\n}\r\nvoid remove1() {\r\n    if (s4.empty()) {\r\n        while (!s3.empty()) {\r\n            ll element = s3.top().first;\r\n            s3.pop();\r\n            ll maximum = s4.empty() ? element : max(element, s4.top().second);\r\n            s4.push({ element, maximum });\r\n        }\r\n    }\r\n    s4.pop();\r\n}\r\nvoid clears1() {\r\n    while (!s3.empty())s3.pop();\r\n    while (!s4.empty())s4.pop();\r\n}\r\nvl dsu(1);\r\nvector<list<ll>> dsuset(1);\r\n// first value in list contains size of list\r\nvoid addset(ll x) {\r\n    dsuset.pb(list<ll>({ 1,x }));\r\n    dsu.pb(x);\r\n}\r\nint getset(int x) {\r\n    if (dsu[x] == x)return x;\r\n    else return getset(dsu[x]);\r\n}\r\nvoid joinset(int x, int y) {\r\n    int a = getset(x);\r\n    int b = getset(y);\r\n    if (a != b) {\r\n        if (*dsuset[a].begin() < *dsuset[b].begin()) {\r\n            swap(x, y);\r\n            swap(a, b);\r\n        }\r\n        // x has bigger size set\r\n        dsu[b] = a;\r\n        *dsuset[a].begin() += *dsuset[b].begin();\r\n        dsuset[b].erase(dsuset[b].begin());\r\n        dsuset[a].splice(dsuset[a].end(), dsuset[b]);\r\n    }\r\n}\r\nvector<ll> dist;\r\nvector<bool> vis;\r\n// make sure that vis is clear before using it again and resize it\r\nvector<vi> edges;\r\n// resize edges\r\nvoid bfs_dist(int n, int k) {\r\n    dist.clear();\r\n    dist.resize(n + 1);\r\n    int a;\r\n    queue<int> d;\r\n    d.push(k);\r\n    while (!d.empty()) {\r\n        a = d.front();\r\n        d.pop();\r\n        vis[a] = 1;\r\n        fo(i, 0, edges[a].size()) {\r\n            if (vis[edges[a][i]] == 0) {\r\n                d.push(edges[a][i]);\r\n                dist[edges[a][i]] = dist[a] + 1;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//requires dist amd edges to be cleared and resized, intial call is (Root,root,root,0)\r\nvoid dfs_shortdis(int k, int a, int p, int dep) {\r\n    dist[a] = dep;\r\n    for (auto x : edges[a]) {\r\n        if (x != p) {\r\n            dfs_shortdis(k, x, a, dep + 1);\r\n        }\r\n    }\r\n}\r\nvoid bfs_shortdis(int n, int k) {\r\n    //shortest distance for unweighted graphs from source node,complexity-O(V+E)\r\n    dist.clear();\r\n    dist.resize(n + 1, 1e9);\r\n    int a;\r\n    queue<int> d;\r\n    d.push(k);\r\n    vis[k] = 1;\r\n    dist[k] = 0;\r\n    while (!d.empty()) {\r\n        a = d.front();\r\n        d.pop();\r\n        fo(i, 0, edges[a].size()) {\r\n            if (vis[edges[a][i]] == 0) {\r\n                vis[edges[a][i]] = 1;\r\n                d.push(edges[a][i]);\r\n            }\r\n            if (dist[edges[a][i]] > dist[a] + 1) {\r\n                dist[edges[a][i]] = dist[a] + 1;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid dfs(int k) {\r\n    // template for recursuve dfs functions\r\n    vis[k] = 1;\r\n    fo(i, 0, edges[k].size()) {\r\n        if (vis[edges[k][i]] == 0) {\r\n            dfs(edges[k][i]);\r\n        }\r\n    }\r\n}\r\nvoid dfs_graph(int n) {\r\n    //template to apply dfs to more than 1 connected component graphs\r\n    fo(i, 1, n + 1) {\r\n        if (!vis[i]) {\r\n            dfs(i);\r\n        }\r\n    }\r\n}\r\nbool cycle = 0;\r\nvoid dfs_cycle(int k, int parent) {\r\n    //detect if cycle exists in graph\r\n    vis[k] = 1;\r\n    fo(i, 0, edges[k].size()) {\r\n        if (vis[edges[k][i]] == 0) {\r\n            dfs_cycle(edges[k][i], k);\r\n        }\r\n        else {\r\n            if (edges[k][i] != parent) {\r\n                cycle = 1;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nbool bipap = 1;\r\n// dont forget to resize and clear colors\r\nvector<bool> colors;\r\nvoid dfs_bipap(int k, bool g) {\r\n    vis[k] = 1;\r\n    colors[k] = g;\r\n    fo(i, 0, edges[k].size()) {\r\n        if (vis[edges[k][i]] == 0) {\r\n            dfs_bipap(edges[k][i], !g);\r\n        }\r\n        else {\r\n            if (colors[edges[k][i]] == g)bipap = 0;\r\n        }\r\n    }\r\n}\r\nvi child;\r\n// clear and resize child before reuse\r\nvoid dfs_child(int k) {\r\n    //returns number of nodes below a node in a tree\r\n    vis[k] = 1;\r\n    child[k] = 1;\r\n    fo(i, 0, edges[k].size()) {\r\n        if (vis[edges[k][i]] == 0) {\r\n            dfs_child(edges[k][i]);\r\n            child[k] += child[edges[k][i]];\r\n        }\r\n    }\r\n}\r\n\r\nint dfs_conn(int n) {\r\n    //return no of connected components\r\n    int u = 0;\r\n    fo(i, 1, n + 1) {\r\n        if (!vis[i]) {\r\n            dfs(i);\r\n            u++;\r\n        }\r\n    }\r\n    return u;\r\n}\r\nvector<vi> ancestor;\r\nvi flatten;\r\nvi node_first;// first occurance of node in flatten\r\nvi node_last;\r\nint timer = 0;\r\n// resize and clear before reuse\r\n// ans lca in O(1) if required using sparse table range min queries\r\n// lca is range min query on depth between first occurance of nodes a and b in flatten\r\nvoid dfs_k_ances(int k) {\r\n    //forms array for kth ancestor and also gives depth array\r\n    // also resize and clear dist and flatten and node_first before use\r\n    // also build tree flatten array\r\n    vis[k] = 1;\r\n    flatten.pb(k);\r\n    node_first[k] = timer++;\r\n    if (!ancestor[k].empty()) {\r\n        int i = 0;\r\n        while (ancestor[ancestor[k][i]].size() >= (i + 1)) {\r\n            ancestor[k].pb(ancestor[ancestor[k][i]][i]);\r\n            i++;\r\n        }\r\n    }\r\n    fo(i, 0, edges[k].size()) {\r\n        if (vis[edges[k][i]] == 0) {\r\n            ancestor[edges[k][i]].pb(k);\r\n            dist[edges[k][i]] = dist[k] + 1;\r\n            dfs_k_ances(edges[k][i]);\r\n        }\r\n    }\r\n    node_last[k] = timer++;\r\n    flatten.pb(k);\r\n}\r\nint get_kth_ances(int a, int k) {\r\n    // call dfs_k_ances beforehand, returns -1 if no kth ancestor\r\n    stack<int> d;\r\n    int q = 0;\r\n    while (k > 0) {\r\n        if (k & 1) {\r\n            d.push(q);\r\n        }\r\n        q++;\r\n        k >>= 1;\r\n    }\r\n    q = a;\r\n    while (!d.empty()) {\r\n        if (ancestor[q].size() >= (d.top() + 1)) {\r\n            q = ancestor[q][d.top()];\r\n        }\r\n        else {\r\n            q = -1;\r\n            break;\r\n        }\r\n        d.pop();\r\n    }\r\n    return q;\r\n}\r\nint lca(int a, int b) {\r\n    // call dfs_k_ances beforehand\r\n    if (dist[a] > dist[b])swap(a, b);\r\n    b = get_kth_ances(b, dist[b] - dist[a]);\r\n    if (a == b)return a;\r\n    int k = -1, l = dist[a];\r\n    while (l > 0) {\r\n        l >>= 1;\r\n        k++;\r\n    }\r\n    int at = -2, bt = -1;\r\n    for (int i = k; i >= 0; --i) {\r\n        if (ancestor[a].size() >= (i + 1))at = ancestor[a][i];\r\n        if (ancestor[b].size() >= (i + 1))bt = ancestor[b][i];\r\n        if (at != bt)a = at, b = bt;\r\n    }\r\n    return ancestor[a][0];\r\n}\r\nvoid euler_dfs(int k) {\r\n    vis[k] = 1;\r\n    node_first[k] = timer++;\r\n    for (auto x : edges[k]) {\r\n        if (!vis[x]) {\r\n            euler_dfs(x);\r\n        }\r\n    }\r\n    node_last[k] = timer++;\r\n}\r\nvector<vector<pair<int, ll>>> edges_weight;\r\n//clear and resize vis and edges_weight before using dijkstra and if source is not connected to ith node then dist is 4*1e18\r\nvoid dijkstra(int n, int k) {\r\n    // result in dist\r\n    dist.clear();\r\n    dist.resize(n + 1, 4 * 1e18);\r\n    dist[k] = 0;\r\n    priority_queue<pair<ll, int>> q;\r\n    q.push(mp(0, k));\r\n    int a;\r\n    while (!q.empty()) {\r\n        a = q.top().second;\r\n        q.pop();\r\n        if (vis[a] == 1)continue;\r\n        vis[a] = 1;\r\n        for (auto x : edges_weight[a]) {\r\n            if (!vis[x.F]) {\r\n                if (dist[x.first] > dist[a] + x.second && dist[a] != 4 * 1e18) {\r\n                    dist[x.F] = dist[a] + x.second;\r\n                    q.push(mp(-dist[x.F], x.first));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nvector<vector<ll>> dist_all;\r\n// only need to resize edges_weight for this function,if no path from i to j then then dist_all[i][j] is 4*1e18\r\nvoid floyd_warsh(int n) {\r\n    // resiult in dist_all\r\n    dist_all.clear();\r\n    dist_all.resize(n + 1, vector<ll>((n + 1), 4 * 1e18));\r\n    fo(i, 1, n + 1) {\r\n        for (auto x : edges_weight[i]) {\r\n            dist_all[i][x.first] = min(dist_all[i][x.first], x.second);\r\n        }\r\n    }\r\n    fo(i, 1, n + 1)dist_all[i][i] = 0;\r\n    fo(k, 1, n + 1) {\r\n        fo(i, 1, n + 1) {\r\n            fo(j, 1, n + 1) {\r\n                dist_all[i][j] = min(dist_all[i][k] + dist_all[k][j], dist_all[i][j]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// needs edges_weight to be clear and resized\r\nbool negative_cycle;\r\nvoid bellman_ford(int n, int k) {\r\n    // result in dist and also in bool of negative_cycle\r\n    dist.clear();\r\n    dist.resize(n + 1, 4 * 1e18);\r\n    bool v;\r\n    dist[k] = 0;\r\n    fo(i, 0, n - 1) {\r\n        v = 0;\r\n        fo(j, 1, n + 1) {\r\n            for (auto x : edges_weight[j]) {\r\n                if (dist[x.first] > dist[j] + x.S) {\r\n                    dist[x.F] = dist[j] + x.second;\r\n                    v = 1;\r\n                }\r\n            }\r\n        }\r\n        if (!v) {\r\n            // no relaxation in a round\r\n            break;\r\n        }\r\n    }\r\n    // last loop to detect negative cycle\r\n    negative_cycle = 0;\r\n    fo(j, 1, n + 1) {\r\n        for (auto x : edges_weight[j]) {\r\n            if (dist[x.first] > dist[j] + x.S) {\r\n                dist[x.F] = dist[j] + x.second;\r\n                negative_cycle = 1;\r\n            }\r\n        }\r\n    }\r\n}\r\nvi topo_sorted;\r\nvoid topo_sort(int n) {\r\n    // needs edges vector\r\n    // stores result of topo sort in topo_sorted\r\n    vi a(n + 1);\r\n    queue<int> d;\r\n    fo(i, 1, n + 1) {\r\n        for (auto x : edges[i]) {\r\n            a[x] += 1;\r\n        }\r\n    }\r\n    fo(i, 1, n + 1) {\r\n        if (a[i] == 0)d.push(i);\r\n    }\r\n    while (!d.empty()) {\r\n        topo_sorted.pb(d.front());\r\n        for (auto x : edges[d.front()]) {\r\n            if (a[x] == 1)d.push(x);\r\n            a[x] -= 1;\r\n        }\r\n        d.pop();\r\n    }\r\n}\r\n\r\n// nothing to resize for this func not even edges_weight\r\nvector<pair<pi, ll>> edges1;\r\nvector<vector<pair<int, ll>>> edges_mintree;\r\nvoid kruskal(int n, int m) {\r\n    // n is no of vertices and m is no of edges\r\n    // puts edges of min spanning tree in edges_mintree\r\n    // returns -1 if no spanning tree i.e. graph has > 1 connected components\r\n    edges_mintree.clear();\r\n    edges_mintree.resize(n + 1);\r\n    dsuset.clear();\r\n    dsu.clear();\r\n    dsuset.resize(1);\r\n    dsu.resize(1);\r\n    fo(i, 1, n + 1) {\r\n        addset(i);\r\n    }\r\n    priority_queue<pair<ll, pi>> q;\r\n    ll a, b, c;\r\n    for (auto x : edges1) {\r\n        a = x.F.first;\r\n        b = x.first.second;\r\n        c = x.second;\r\n        q.push(mp(-c, mp(a, b)));\r\n    }\r\n    pair<ll, pi> x;\r\n    while (!q.empty()) {\r\n        x = q.top();\r\n        x.first = -x.first;\r\n        if (getset(x.second.F) != getset(x.second.S)) {\r\n            joinset(x.second.first, x.second.S);\r\n            edges_mintree[x.second.F].pb(mp(x.second.S, x.F));\r\n        }\r\n        q.pop();\r\n    }\r\n}\r\n\r\n//Normal segment tree for associative operations on a position(both)\r\n// mass for associative and commutative operations on segment(add to prev)\r\n// lazy for associative operations on segment(assignment and matrix mul)\r\nvector<ll> segtree;\r\n// stores segtree\r\nvector<ll> segarray;\r\n// input array for segtree\r\nvoid build(int v, int tl, int tr) {\r\n    // resize segtree before use and  resize and take input in segarray\r\n    // inital call is build(1,0,n-1)\r\n    if (tl == tr) {\r\n        segtree[v] = segarray[tl];\r\n    }\r\n    else {\r\n        build(2 * v, tl, (tl + tr) / 2);\r\n        build(2 * v + 1, (tl + tr) / 2 + 1, tr);\r\n        segtree[v] = max(segtree[2 * v],segtree[2 * v + 1]);\r\n    }\r\n}\r\nll query(int v, int tl, int tr, int l, int r) {\r\n    // call it as (1,0,n-1,l,r)\r\n    if (l > r) {\r\n        // in case of min keep this as LLONG_MAX but 0 in case of sum and -LLONG_max in case of max\r\n        return -LLONG_MAX;\r\n    }\r\n    if (l == tl && r == tr) {\r\n        return segtree[v];\r\n    }\r\n    int tm = (tl + tr) / 2;\r\n    return max(query(2 * v, tl, tm, l, min(r, tm)),query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\r\n}\r\nvoid update(int v, int tl, int tr, int pos, ll new_val) {\r\n    // doesnt change segarray\r\n    // call it as (1,0,n-1,pos,new_val)\r\n    if (tl == tr) {\r\n        segtree[v] = new_val;\r\n    }\r\n    else {\r\n        int tm = (tl + tr) / 2;\r\n        if (pos <= tm) {\r\n            update(2 * v, tl, tm, pos, new_val);\r\n        }\r\n        else {\r\n            update(2 * v + 1, tm + 1, tr, pos, new_val);\r\n        }\r\n        segtree[v] = max(segtree[2 * v],segtree[2 * v + 1]);\r\n    }\r\n}\r\nvoid update_mass(int v, int tl, int tr, int l, int r, ll val) {\r\n    // call it as (1,0,n-1,l,r,val)\r\n    if (l <= r) {\r\n        if (l == tl && r == tr) {\r\n\r\n            segtree[v] += val;\r\n        }\r\n        else {\r\n            int tm = (tl + tr) / 2;\r\n            update_mass(2 * v, tl, tm, l, min(r, tm), val);\r\n            update_mass(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, val);\r\n        }\r\n    }\r\n}\r\nll query_mass(int v, int tl, int tr, int pos) {\r\n    // doesnt change segarray\r\n    // call it as (1,0,n-1,pos)\r\n    if (tl == tr) {\r\n        return segtree[v];\r\n    }\r\n    else {\r\n        int tm = (tl + tr) / 2;\r\n        if (pos <= tm) {\r\n            return segtree[v] + query_mass(2 * v, tl, tm, pos);\r\n        }\r\n        else {\r\n            return segtree[v] + query_mass(2 * v + 1, tm + 1, tr, pos);\r\n        }\r\n    }\r\n}\r\nvoid update_lazy(int v, int tl, int tr, int l, int r, ll val) {\r\n    // call it as (1,0,n-1,l,r,val)\r\n    if (l <= r) {\r\n        if (segtree[v] >= 0) {\r\n            segtree[2 * v] = segtree[v];\r\n            segtree[2 * v + 1] = segtree[v];\r\n            segtree[v] = -1;\r\n        }\r\n        if (l == tl && r == tr) {\r\n            segtree[v] = val;\r\n        }\r\n        else {\r\n            int tm = (tl + tr) / 2;\r\n            update_lazy(2 * v, tl, tm, l, min(r, tm), val);\r\n            update_lazy(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, val);\r\n        }\r\n    }\r\n}\r\nll query_lazy(int v, int tl, int tr, int pos) {\r\n    // doesnt change segarray\r\n    // call it as (1,0,n-1,pos)\r\n    if (tl == tr) {\r\n        return segtree[v];\r\n    }\r\n    else {\r\n        int tm = (tl + tr) / 2;\r\n        if (pos <= tm) {\r\n            if (segtree[v] < 0) return query_lazy(2 * v, tl, tm, pos);\r\n            else return segtree[v];\r\n        }\r\n        else {\r\n            if (segtree[v] < 0)return query_lazy(2 * v + 1, tm + 1, tr, pos);\r\n            else return segtree[v];\r\n        }\r\n    }\r\n}\r\nvector<pi> segarray1, segtree1;\r\nvoid build1(int v, int tl, int tr) {\r\n    // resize segtree before use and  resize and take input in segarray\r\n    // inital call is build(1,0,n-1)\r\n    if (tl == tr) {\r\n        segtree1[v] = segarray1[tl];\r\n    }\r\n    else {\r\n        build1(2 * v, tl, (tl + tr) / 2);\r\n        build1(2 * v + 1, (tl + tr) / 2 + 1, tr);\r\n        segtree1[v] = max(segtree1[2 * v], segtree1[2 * v + 1]);\r\n    }\r\n}\r\npair<ll,ll> query1(int v, int tl, int tr, int l, int r) {\r\n    // call it as (1,0,n-1,l,r)\r\n    if (l > r) {\r\n        // in case of min keep this as LLONG_MAX but 0 in case of sum and -LLONG_max in case of max\r\n        return mp(- LLONG_MAX,0);\r\n    }\r\n    if (l == tl && r == tr) {\r\n        return segtree1[v];\r\n    }\r\n    int tm = (tl + tr) / 2;\r\n    return max(query1(2 * v, tl, tm, l, min(r, tm)), query1(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\r\n}\r\nvoid update1(int v, int tl, int tr, int pos, ll new_val) {\r\n    // doesnt change segarray\r\n    // call it as (1,0,n-1,pos,new_val)\r\n    if (tl == tr) {\r\n        segtree1[v].F = new_val;\r\n    }\r\n    else {\r\n        int tm = (tl + tr) / 2;\r\n        if (pos <= tm) {\r\n            update1(2 * v, tl, tm, pos, new_val);\r\n        }\r\n        else {\r\n            update1(2 * v + 1, tm + 1, tr, pos, new_val);\r\n        }\r\n        segtree1[v] = max(segtree1[2 * v], segtree1[2 * v + 1]);\r\n    }\r\n}\r\nvi l, a, b, c, d,v;\r\nvector<pi> q;\r\nvector<pair<pi, int>> w;\r\nint dfs2(int k) {\r\n    vis[k] = 1;\r\n    if (l[k] != 0)return l[k];\r\n    else {\r\n        if (vis[edges[k][0]] == 0) {\r\n            l[k] = dfs2(edges[k][0]);\r\n            return l[k];\r\n        }\r\n    }\r\n}\r\nvoid dfs1(int n) {\r\n    fo(i, 0, n) {\r\n        if (!vis[i])dfs2(i);\r\n    }\r\n}\r\nint main() {\r\n#ifndef ONLINE_JUDGE\r\n    clock_t tm = clock();\r\n#endif\r\n    /*#ifdef ONLINE_JUDGE\r\n        ifstream cin(\"input.txt\");\r\n        ofstream cout(\"output.txt\");\r\n    #endif*/\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    // t*(n-1)+t*no of planets+time saved from boost\r\n    int t, n, m, e, f, g, h;\r\n    cin >> t;\r\n    while (t--) {\r\n        cin >> n;\r\n        l.clear();\r\n        l.resize(n + 1);\r\n        a.clear();\r\n        b.clear();\r\n        c.clear();\r\n        d.clear();\r\n        e = 0;\r\n        f = 0;\r\n        g = 0;\r\n        h = 0;\r\n        a.resize(n);\r\n        b.resize(n);\r\n        c.resize(n);\r\n        d.resize(n);\r\n        fo(i, 0, n) {\r\n            cin >> a[i];\r\n            e = max(e, a[i]);\r\n        }\r\n        fo(i, 0, n) {\r\n            cin >> b[i];\r\n        }\r\n        cin >> m;\r\n        vi c(m), d(m);\r\n        fo(i, 0, m) {\r\n            cin >> c[i];\r\n            f = max(f, c[i]);\r\n        }\r\n        fo(i, 0, m) {\r\n            cin >> d[i];\r\n        }\r\n        fo(i, 0, n) {\r\n            if (b[i] >= f) {\r\n                l[i] = 1;\r\n            }\r\n        }\r\n        f = 0;\r\n        fo(i, 0, m) {\r\n            if (d[i] >= e) {\r\n                f = max(f, c[i]);\r\n            }\r\n        }\r\n        fo(i, 0, n) {\r\n            if (b[i] < f) {\r\n                l[i] = -1;\r\n            }\r\n        }\r\n        // v store health of moves from bicarp\r\n        q.clear();\r\n        q.resize(m);\r\n        fo(i, 0, m) {\r\n            q[i].first = c[i];\r\n            q[i].second = d[i];\r\n        }\r\n        sort(q.begin(), q.end());\r\n        segarray.clear();\r\n        segtree.clear();\r\n        segarray.resize(m);\r\n        segtree.resize(4 * m);\r\n        fo(i, 0, m) {\r\n            segarray[i] = q[i].second;\r\n        }\r\n        build(1, 0, m - 1);\r\n        v.clear();\r\n        v.resize(n);\r\n        fo(i, 0, n) {\r\n            if (l[i] == 0)v[i] = query(1, 0, m - 1, upper_bound(q.begin(), q.end(), mp(b[i], 1e6 + 1)) - q.begin(), m - 1);\r\n            \r\n        }\r\n        edges.clear();\r\n        edges.resize(n);\r\n        segarray1.clear();\r\n        segtree1.clear();\r\n        segarray1.resize(n);\r\n        segtree1.resize(4 * n);\r\n        w.clear();\r\n        w.resize(n);\r\n\r\n        fo(i, 0, n) {\r\n            w[i].F.first = a[i];\r\n            w[i].F.second = b[i];\r\n            w[i].second = i;\r\n        }\r\n        sort(q.begin(), q.end());\r\n        fo(i, 0, n) {\r\n            segarray1[i].F = w[i].F.second;\r\n            segarray1[i].S = w[i].second;\r\n        }\r\n        build1(1, 0, n - 1);\r\n        fo(i, 0, n) {\r\n            if (l[i] == 0) {\r\n                edges[i].pb(query1(1, 0, n - 1, upper_bound(w.begin(), w.end(), mp(mp(b[i], 1e6 + 1), 0)) - w.begin(), n - 1).S);\r\n            }\r\n        }\r\n        vis.clear();\r\n        vis.resize(n);\r\n        dfs1(n);\r\n        h = 0;\r\n        g = 0;\r\n        e = 0;\r\n        fo(i, 0, n) {\r\n            if (l[i] == 1)h++;\r\n            else if (l[i] == -1)g++;\r\n            else e++;\r\n        }\r\n        cout << h << \" \" << e << \" \" << g << \"\\n\";\r\n    }\r\n    /*#ifndef ONLINE_JUDGE\r\n        tm = clock() - tm;\r\n        cout << \"\\nTime Taken - \" << ((float)tm / CLOCKS_PER_SEC);\r\n    #endif*/\r\n    return 0;\r\n}",
    "category_evaluation": {
        "mathematics": 0,
        "dynamic programming": 0,
        "bit manipulation": 0,
        "greedy": 0,
        "brute force": 0,
        "graphs": 0,
        "sortings": 0,
        "search": 0,
        "trees": 0,
        "strings": 0,
        "number theory": 0,
        "combinatorics": 0,
        "two pointers": 0,
        "geometry": 0,
        "shortest paths": 0,
        "divide and conquer": 0,
        "probabilities": 0,
        "data structures": 0,
        "game theory": 0,
        "2d, 3d": 0,
        "recursive": 0,
        "well-commented": 100,
        "self-documenting": 100,
        "complex": 0,
        "readable": 0,
        "well-named": 0,
        "efficient": 100,
        "reusable": 0,
        "documented": 0,
        "good error-handling": 0,
        "good solution": 0,
        "compilation error": 0,
        "runtime error": 0
    },
    "defect_evaluation": {
        "good solution": 100,
        "compilation error": 0,
        "runtime error": 0
    },
    "defect_evaluation_gpt_4": {
        "good solution": 0,
        "compilation error": 100,
        "runtime error": 0
    },
    "defect_evaluation_v1": {
        "good solution": 90,
        "compilation error": 10,
        "runtime error": 0
    }
}