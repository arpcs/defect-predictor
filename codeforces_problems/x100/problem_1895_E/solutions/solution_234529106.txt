{
    "id": 234529106,
    "contestId": 1895,
    "creationTimeSeconds": 1701054064,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1895,
        "index": "E",
        "name": "Infinite Card Game",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "games",
            "graphs",
            "greedy",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1895,
        "members": [
            {
                "handle": "Hanx16"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1699022100
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 51,
    "timeConsumedMillis": 140,
    "memoryConsumedBytes": 57241600,
    "source": "// Cirno is not baka!\r\n#include <bits/stdc++.h>\r\n#define For(i, a, b) for (int i = (a); i <= (int)(b); ++i)\r\n#define Rof(i, a, b) for (int i = (a); i >= (int)(b); --i)\r\n#define Debug(...) { \\\r\n    fprintf(stderr, \"Function{%s},line[%d]:\\t\", __FUNCTION__, __LINE__); \\\r\n    fprintf(stderr, __VA_ARGS__); \\\r\n    fprintf(stderr, \"\\n\"); \\\r\n}\r\n#define FILE(filename) { \\\r\n    freopen(#filename \".in\", \"r\", stdin); \\\r\n    freopen(#filename \".out\", \"w\", stdout); \\\r\n}\r\n#define All(x) x.begin(), x.end()\r\n#define rAll(x) x.rbegin(), x.rend()\r\n#define pii pair<int, int>\r\n#define fi first\r\n#define se second\r\n#define i64 long long\r\n#define mkp make_pair\r\n// #define int long long\r\n#define epb emplace_back\r\nusing namespace std;\r\n\r\nnamespace FastIO {\r\n    const int MaxBuf = 1e6;\r\n    using namespace std;\r\n    class Istream {\r\n    private:\r\n        char buffer[MaxBuf + 5], *p1 = buffer, *p2 = buffer;\r\n        inline char getchar() {\r\n            if (p1 == p2) {\r\n                p1 = buffer;\r\n                p2 = buffer + fread(buffer, 1, MaxBuf, stdin);\r\n            }\r\n            if (p1 == p2) return EOF;\r\n            else return *p1++;\r\n        }\r\n        template<typename Type>\r\n        Type getInteger() {\r\n            Type x = 0;\r\n            bool isNagetive = false;\r\n            char buf = getchar();\r\n            while (buf < '0' || buf > '9') {\r\n                isNagetive = buf == '-' ? true : false;\r\n                buf = getchar();\r\n            }\r\n            while (buf >= '0' && buf <= '9') {\r\n                x = x * 10 + (buf ^ 48);\r\n                buf = getchar();\r\n            }\r\n            return isNagetive ? -x : x;\r\n        }\r\n        template<typename Type>\r\n        Type getFloat() {\r\n            Type left = 0, right = 0;\r\n            bool isNagetive = false;\r\n            char buf = getchar();\r\n            while (buf < '0' || buf > '9') {\r\n                isNagetive = buf == '-' ? true : false;\r\n                buf = getchar();\r\n            }\r\n            while (buf >= '0' && buf <= '9') {\r\n                left = left * 10 + (buf ^ 48);\r\n                buf = getchar();\r\n            }\r\n            if (buf == '.') {\r\n                buf = getchar();\r\n                while (buf >= '0' && buf <= '9') {\r\n                    right = (right + (buf ^ 48)) / 10.;\r\n                    buf = getchar();\r\n                }\r\n            }\r\n            return isNagetive ? -left - right : left + right;\r\n        }\r\n        char getChar() {\r\n            char buf = getchar();\r\n            while (isspace(buf))\r\n                buf = getchar();\r\n            return buf;\r\n        }\r\n        string getString() {\r\n            static char str[MaxBuf + 5], buf, *p;\r\n            string result;\r\n            p = str;\r\n            buf = getchar();\r\n            while (isspace(buf))\r\n                buf = getchar();\r\n            while (!isspace(buf)) {\r\n                *p++ = buf, buf = getchar();\r\n                if (p == str + MaxBuf) {\r\n                    *p = 0;\r\n                    result.append(str);\r\n                    p = str;\r\n                }\r\n            }\r\n            *p = 0;\r\n            result.append(str);\r\n            return result;\r\n        }\r\n    public:\r\n        Istream() {}\r\n        ~Istream() {}\r\n        template<typename Type>\r\n        inline Istream &operator >> (Type &x) {\r\n            if (is_same<Type, char>::value)\r\n                x = getChar();\r\n            else if (is_integral<Type>::value ||\r\n                is_same<Type, __int128_t>::value ||\r\n                is_same<Type, __uint128_t>::value)\r\n                x = getInteger<Type>();\r\n            else if (is_floating_point<Type>::value)\r\n                x = getFloat<Type>();\r\n            return *this;\r\n        }\r\n        inline Istream operator >> (string &x) {\r\n            x = getString();\r\n            return *this;\r\n        }\r\n    };\r\n    class Ostream {\r\n    private:\r\n        char buffer[MaxBuf + 5], *p1 = buffer;\r\n        unsigned precision;\r\n        void putchar(const char c) {\r\n            if (p1 - buffer == MaxBuf) {\r\n                fwrite(buffer, 1, MaxBuf, stdout);\r\n                p1 = buffer;\r\n            }\r\n            *p1++ = c;\r\n        }\r\n        template<typename Type>\r\n        void putInteger(Type x) {\r\n            if (x < 0)\r\n                putchar('-'), x = -x;\r\n            static char buf[50], *p;\r\n            p = buf;\r\n            do *p++ = x % 10, x /= 10; while(x);\r\n            do putchar((*--p) ^ 48); while (p != buf);\r\n        }\r\n        template<typename Type>\r\n        void putFloat(Type x) {\r\n            if (x < 0)\r\n                putchar('-'), x = -x;\r\n            double left = floor(x), right = x - left;\r\n            static char buf[MaxBuf + 5], *p;\r\n            p = buf;\r\n            do {\r\n                *p++ = left - (floor(left / 10) * 10);\r\n                left /= 10;\r\n            } while (round(left) != 0);\r\n            do putchar((*--p) ^ 48); while (p != buf);\r\n            putchar('.');\r\n            for (unsigned i = 0; i < precision; ++i) {\r\n                right *= 10;\r\n                putchar((int)(floor(right)) ^ 48);\r\n                right -= floor(right);\r\n            }\r\n        }\r\n        void putString(string str) {\r\n            int len = str.length();\r\n            for (int i = 0; i < len; ++i)\r\n                putchar(str[i]);\r\n        }\r\n    public:\r\n        Ostream() {precision = 4;}\r\n        ~Ostream() {}\r\n        inline void flush() {\r\n            fwrite(buffer, 1, p1 - buffer, stdout);\r\n        }\r\n        inline void setprecision(unsigned newprecision) {\r\n            precision = newprecision;\r\n        }\r\n        template<typename Type>\r\n        inline Ostream &operator << (const Type x) {\r\n            if (is_same<Type, char>::value)\r\n                putchar(x);\r\n            else if (is_integral<Type>::value ||\r\n                is_same<Type, __int128_t>::value ||\r\n                is_same<Type, __uint128_t>::value)\r\n                putInteger(x);\r\n            return *this;\r\n        }\r\n        inline Ostream &operator << (const float x) {\r\n            return putFloat(x), *this;\r\n        }\r\n        inline Ostream &operator << (const double x) {\r\n            return putFloat(x), *this;\r\n        }\r\n        inline Ostream &operator << (const long double x) {\r\n            return putFloat(x), *this;\r\n        }\r\n        inline Ostream &operator << (const char *x) {\r\n            return putString(x), *this;\r\n        }\r\n        inline Ostream &operator << (const string x) {\r\n            return putString(x), *this;\r\n        }\r\n    };\r\n    Istream fin;\r\n    Ostream fout;\r\n}\r\nusing FastIO::fin;\r\nusing FastIO::fout;\r\n\r\nconst int _N = 1e6 + 5, mod = 1e9 + 7, inf = 1e9;\r\ntemplate<typename T> void Max(T &x, T y) {x = max(x, y);}\r\ntemplate<typename T> void Min(T &x, T y) {x = min(x, y);}\r\ntemplate<typename T1, typename T2>\r\nvoid Addmod(T1 &x, T2 y) {x += y; x >= mod ? x -= mod : x;}\r\ntemplate<typename T1, typename T2>\r\nT1 Add(T1 x, T2 y) {x += y; return x >= mod ? x - mod : x;}\r\n\r\nnamespace BakaCirno {\r\n    int N, M;\r\n    struct Node {int atk, def, id;} A[_N], B[_N];\r\n    int fa[_N], cnt[_N];\r\n    int flag[_N];\r\n    int Find(int x) {return fa[x] == x ? x : fa[x] = Find(fa[x]);}\r\n    void Merge(int x, int y) {\r\n        x = Find(x), y = Find(y);\r\n        if (x == y) return ;\r\n        cnt[x] += cnt[y], fa[y] = fa[x];\r\n    }\r\n    #define AA A + 1, A + N + 1\r\n    #define AB B + 1, B + M + 1\r\n    void Connect() {\r\n        int p, mx, pos;\r\n        auto cmp1 = [](const Node &i, const Node &j) {\r\n            return i.atk < j.atk;\r\n        };\r\n        auto cmp2 = [](const Node &i, const Node &j) {\r\n            return i.def < j.def;\r\n        };\r\n        sort(AA, cmp2), sort(AB, cmp1);\r\n        p = M, mx = 0, pos = 0;\r\n        Rof(i, N, 1) {\r\n            while (p && B[p].atk > A[i].def) {\r\n                if (B[p].def > mx) mx = B[p].def, pos = B[p].id;\r\n                --p;\r\n            }\r\n            if (pos) Merge(A[i].id, pos + N);\r\n            else flag[A[i].id] = 1;\r\n        }\r\n        sort(AA, cmp1), sort(AB, cmp2);\r\n        p = N, mx = 0, pos = 0;\r\n        Rof(i, M, 1) {\r\n            while (p && A[p].atk > B[i].def) {\r\n                if (A[p].def > mx) mx = A[p].def, pos = A[p].id;\r\n                --p;\r\n            }\r\n            if (pos) Merge(pos, B[i].id + N);\r\n            else flag[B[i].id + N] = 1;\r\n        }\r\n    }\r\n    void Init() {\r\n        iota(fa + 1, fa + N + M + 1, 1);\r\n        fill(cnt + 1, cnt + N + 1, 1);\r\n        fill(cnt + N + 1, cnt + N + M + 1, 0);\r\n        fill(flag + 1, flag + N + M + 1, 0);\r\n    }\r\n    void Solve() {\r\n        For(i, 1, N + M) if (flag[i])\r\n            flag[Find(i)] = (i > N) + 1;\r\n        int ans[3] = {0, 0, 0};\r\n        For(i, 1, N + M) if (i == Find(i))\r\n            ans[flag[i]] += cnt[i];\r\n        fout << ans[1] << ' ' << ans[0] << ' ' << ans[2] << '\\n';\r\n    }\r\n    void _() {\r\n        fin >> N;\r\n        For(i, 1, N) fin >> A[i].atk;\r\n        For(i, 1, N) fin >> A[i].def;\r\n        fin >> M;\r\n        For(i, 1, M) fin >> B[i].atk;\r\n        For(i, 1, M) fin >> B[i].def;\r\n        For(i, 1, N) A[i].id = i;\r\n        For(i, 1, M) B[i].id = i;\r\n        Init();\r\n        Connect();\r\n        Solve();\r\n    }\r\n}\r\n\r\nsigned main() {\r\n    // FILE(t);\r\n    cin.tie(0)->sync_with_stdio(0); int T = 1;\r\n    fin >> T;\r\n    while (T--) BakaCirno::_();\r\n    fout.flush();\r\n}"
}