{
    "id": 231633010,
    "contestId": 1895,
    "creationTimeSeconds": 1699295992,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1895,
        "index": "E",
        "name": "Infinite Card Game",
        "type": "PROGRAMMING",
        "rating": 2300,
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "games",
            "graphs",
            "greedy",
            "sortings",
            "two pointers"
        ]
    },
    "author": {
        "contestId": 1895,
        "members": [
            {
                "handle": "Khozhaev"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1699022100
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "RUNTIME_ERROR",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 186,
    "memoryConsumedBytes": 80384000,
    "source": "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <set>\r\n#include <map>\r\n#include <utility>\r\n#include <unordered_set>\r\n#include <unordered_map>\r\n#include <cstdlib>\r\n#include <iomanip>\r\n#include <cassert>\r\n#include <deque>\r\n#include <cmath>\r\n#include <random>\r\n\r\nusing namespace std;\r\n//#define FAST_ALLOCATOR_MEMORY 200000000\r\n#ifdef FAST_ALLOCATOR_MEMORY\r\nsize_t allocator_pos = 0;\r\nchar allocator_memory[(int)FAST_ALLOCATOR_MEMORY];\r\ninline void * operator new ( size_t n ) {\r\n    char *res = allocator_memory + allocator_pos;\r\n    allocator_pos += n;\r\n    assert(allocator_pos <= (int)FAST_ALLOCATOR_MEMORY);\r\n    return (void *)res;\r\n}\r\ninline void operator delete ( void * ) noexcept { }\r\n//inline void * operator new [] ( size_t ) { assert(0); }\r\n//inline void operator delete [] ( void * ) { assert(0); }\r\n#endif\r\n\r\n#define int int64_t\r\n#define ui32 uint32_t\r\n#define ui64 uint64_t\r\n#define i64 int64_t\r\n#define i32 int32_t\r\n#define i16 int16_t\r\n#define u16 int16_t\r\n#define i8 int8_t\r\n#define ui8 uint8_t\r\n#define i128 __int128_t\r\n\r\n#define ld long double\r\n#define pb push_back\r\n#define all(x) x.begin(), x.end()\r\n#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n#define vi vector<int>\r\n#define vvi vector<vi>\r\n#define pii pair<int, int>\r\n\r\n\r\nconst int inf = 1e9 + 7;\r\nconst int64_t linf = 1e18 + 1;\r\n\r\ntemplate<typename T>\r\nusing V = vector<T>;\r\n\r\ntemplate<typename T = int>\r\nT nxt() {\r\n    T x;\r\n    cin >> x;\r\n    return x;\r\n}\r\n\r\ntemplate<typename T = int>\r\nvoid read(vector<T>& x) {\r\n    for (T& i: x)\r\n        cin >> i;\r\n}\r\n\r\ntemplate<typename T>\r\nistream& operator>>(istream& in, V<T>& v) {\r\n    for (auto& x: v) {\r\n        in >> x;\r\n    }\r\n    return in;\r\n}\r\n\r\ntemplate<typename T>\r\nostream& operator>>(ostream& out, V<T>& v) {\r\n    for (auto& x: v) {\r\n        out << x << \" \";\r\n    }\r\n    out << endl;\r\n    return out;\r\n}\r\n\r\nvoid hash_combine(size_t& seed, const size_t& v) {\r\n    seed ^= v + 0x9e3779b9 + (seed << 6) + (seed >> 2);\r\n}\r\n\r\nstd::random_device hm_rd;\r\nstd::mt19937 hm_twister;\r\n\r\ntemplate<typename T, typename BHasher = std::hash<T>>\r\nclass Hasher {\r\npublic:\r\n    BHasher h;\r\n    size_t v;\r\n    Hasher() : v(hm_twister()) {}\r\n\r\n    size_t operator()(const T& x) const {\r\n        size_t seed = h(x);\r\n        hash_combine(seed, v);\r\n        return seed;\r\n    }\r\n};\r\n\r\ntemplate<typename T, typename H = std::hash<T>, typename E = std::equal_to<T>>\r\nusing HashSet = std::unordered_set<T, Hasher<T, H>, E>;\r\n\r\ntemplate<typename K, typename V, typename H = std::hash<K>, typename E = std::equal_to<K>>\r\nusing HashMap = std::unordered_map<K, V, Hasher<K, H>, E>;\r\n\r\nstruct Node {\r\n    int key;\r\n    int val;\r\n    int id;\r\n    int m_val;\r\n    int m_id;\r\n    int prior;\r\n    Node* left = nullptr;\r\n    Node* right = nullptr;\r\n    Node(int k, int v, int i) : key(k), val(v), id(i), m_val(v), m_id(i) {\r\n        prior = (rand() < 16) | rand();\r\n\r\n    }\r\n};\r\n\r\nvoid upd(Node* root) {\r\n    root->m_val = root->val;\r\n    root->m_id = root->id;\r\n    if (root->left) {\r\n        if (root->left->m_val > root->m_val) {\r\n            root->m_val = root->left->m_val;\r\n            root->m_id = root->left->m_id;\r\n        }\r\n    }\r\n    if (root->right) {\r\n        if (root->right->m_val > root->m_val) {\r\n            root->m_val = root->right->m_val;\r\n            root->m_id = root->right->m_id;\r\n        }\r\n    }\r\n}\r\nNode* merge(Node* l, Node* r) {\r\n    if (!l) {\r\n        return r;\r\n    }\r\n    if (!r) {\r\n        return l;\r\n    }\r\n    if (l->prior < r->prior) {\r\n        l->right = merge(l->right, r);\r\n        upd(l);\r\n        return l;\r\n    } else {\r\n        r->left = merge(l, r->left);\r\n        upd(r);\r\n        return r;\r\n    }\r\n}\r\n\r\npair<Node*, Node*> Split(Node* root, int key) {\r\n    if (!root) return {nullptr, nullptr};\r\n    if (root->val > key) {\r\n        auto p = Split(root->left, key);\r\n        root->left = p.second;\r\n        upd(root);\r\n        return {p.first, root};\r\n    } else {\r\n        auto p = Split(root->right, key);\r\n        root->right = p.first;\r\n        upd(root);\r\n        return {root, p.second};\r\n    }\r\n}\r\n\r\nNode* Insert(Node* root, Node* v) {\r\n    if (!root) {\r\n        return v;\r\n    }\r\n    auto p = Split(root, v->key);\r\n    return merge(merge(p.first, root), p.second);\r\n}\r\n\r\nvoid dfs(int v, vi& prev, vi& used, vvi& circles, vi& g) {\r\n    used[v] = 1;\r\n    int u = g[v];\r\n    if (u == -1) {\r\n        used[v] = 2;\r\n        return;\r\n    }\r\n    if (!used[u]) {\r\n        prev[u] = v;\r\n        dfs(u, prev, used, circles, g);\r\n    } if (used[u] == 1) {\r\n        int w = v;\r\n        vi circle;\r\n        circle.push_back(w);\r\n        while(w != u) {\r\n            w = prev[w];\r\n            circle.push_back(w);\r\n        }\r\n        circles.push_back(move(circle));\r\n    }\r\n\r\n    used[v] = 2;\r\n}\r\n\r\nvoid dfs2(int v, vi& used, vi& is_win, vi& is_circle, vi& g) {\r\n    used[v] = 1;\r\n    int u = g[v];\r\n    if (u == -1) {\r\n        is_win[v] = -1;\r\n        return;\r\n    }\r\n    if (is_circle[u]) {\r\n        is_win[v] = 2;\r\n        return;\r\n    }\r\n    if (!used[u]) {\r\n        dfs2(u, used, is_win, is_circle, g);\r\n    }\r\n    if (is_win[u] == 2) {\r\n        is_win[v] = 2;\r\n    } else if (is_win[u] == -1) {\r\n        is_win[v] = 1;\r\n    } else if (is_win[u] == 1) {\r\n        is_win[u] = -1;\r\n    } else {\r\n        while (true){};\r\n    }\r\n}\r\n\r\npair<V<pii>, map<int, int>> Read(int n) {\r\n    vi X(n);\r\n    vi Y(n);\r\n    cin >> X;\r\n    cin >> Y;\r\n    V<pii> a(n);\r\n    for (int  i = 0; i < n; ++i) {\r\n        a[i].first = X[i];\r\n        a[i].second = Y[i];\r\n    }\r\n    sort(all(a));\r\n    int cur_max = -inf;\r\n    map<int, int> A;\r\n    for (int i = n - 1; i >= 0; --i) {\r\n        cur_max = max(a[i].second, cur_max);\r\n        A[a[i].first] = cur_max;\r\n    }\r\n    return {a, A};\r\n}\r\nvoid Solve() {\r\n    int n;\r\n    cin >> n;\r\n    auto [a, A] = Read(n);\r\n    int m;\r\n    cin >> m;\r\n    auto [b, B] = Read(m);\r\n    const int N = 1e6 + 5;\r\n    vi g(2 * N, -1);\r\n    vi is_win(2 * N, 0);\r\n    for (int i = 0; i < n; ++i) {\r\n        int Y = a[i].second;\r\n        auto it = B.upper_bound(Y);\r\n        if (it != B.end()) {\r\n            g[Y] = N + it->second;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        int Y = b[i].second;\r\n        auto it = A.upper_bound(Y);\r\n        if (it != A.end()) {\r\n            g[Y + N] = it->second;\r\n        }\r\n    }\r\n    vvi circles;\r\n    vi is_circle(2 * N);\r\n    vi prev(2 * N);\r\n    vi used(2 * N);\r\n    for (int i = 0; i < 2 * N; ++i) {\r\n        if (!used[i]) {\r\n            dfs(i, prev, used, circles, g);\r\n        }\r\n    }\r\n    for (auto& c : circles) {\r\n        for (auto v : c) {\r\n            is_circle[v] = 1;\r\n        }\r\n    }\r\n    fill(all(used), 0);\r\n    for (int i = 0; i < 2 * N; ++i) {\r\n        if (!used[i] && !is_circle[i]) {\r\n            dfs2(i, used, is_win, is_circle, g);\r\n        } else if (is_circle[i]) {\r\n            is_win[i] = 2;\r\n        }\r\n    }\r\n    int ans1 = 0;\r\n    int ans2 = 0;\r\n    int ans3 = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        int x = a[i].second;\r\n        if (is_win[x] == 2) {\r\n            ans2++;\r\n        } else if (is_win[x] == 1) {\r\n            ans3++;\r\n        } else if (is_win[x] == -1) {\r\n            ans1++;\r\n        } else {\r\n            throw 1;\r\n        }\r\n    }\r\n    cout << ans1 << \" \" << ans2 << \" \" << ans3 << endl;\r\n\r\n}\r\n\r\nsigned main() {\r\n    FAST;\r\n    int t = nxt();\r\n    while (t--) Solve();\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n"
}