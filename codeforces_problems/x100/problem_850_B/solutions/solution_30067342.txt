{
    "id": 30067342,
    "contestId": 850,
    "creationTimeSeconds": 1504538859,
    "relativeTimeSeconds": 3159,
    "problem": {
        "contestId": 850,
        "index": "B",
        "name": "Arpa and a list of numbers",
        "type": "PROGRAMMING",
        "points": 1000.0,
        "rating": 2100,
        "tags": [
            "implementation",
            "number theory"
        ]
    },
    "author": {
        "contestId": 850,
        "members": [
            {
                "handle": "giraffeh"
            }
        ],
        "participantType": "CONTESTANT",
        "ghost": false,
        "room": 3,
        "startTimeSeconds": 1504535700
    },
    "programmingLanguage": "GNU C++14",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 20,
    "timeConsumedMillis": 1123,
    "memoryConsumedBytes": 32051200,
    "source": "///      That's a Cigarette Day, my Sun\r\n\r\n#include <bits/stdc++.h>\r\n#include <quadmath.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\n#ifdef LOCAL\r\n    #define deb if(1)\r\n#else\r\n    #define deb if(0)\r\n#endif // LOCAL\r\n\r\n#pragma pack(1)\r\n#pragma GCC optimize(\"O3\")\r\n\r\n#define pb push_back\r\n#define mp make_pair\r\n#define fi first\r\n#define prev asfansjfansjabfasjlbfa\r\n#define se second\r\n#define I \"%d\"\r\n#define II \"%d%d\"\r\n#define III \"%d%d%d\"\r\n#define elif else if\r\n#define out_files freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout)\r\n#define all(x) (x).begin(), (x).end()\r\n#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\n#define y1 asnflainflawnfaw\r\n#define y0 snalfklawnfasdaspqw\r\n#define BLEAT cout << \"bleat!!!\\n\"\r\n#define files(x) ((x != \"\") ? freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout) : 0)\r\n#define files_dat_sol(x)  ((x != \"\") ? freopen(x\".dat\", \"r\", stdin), freopen(x\".sol\", \"w\", stdout) : 0)\r\n#define next askfnlabfae\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\ntypedef std::vector <int> vi;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef unsigned long long ull;\r\ntypedef std::pair <int, int> pii;\r\ntypedef std::vector <pii> vii;\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\r\n\r\n#ifdef WIN32\r\n    #define I64 \"%I64d\"\r\n#else\r\n    #define I64 \"%lld\"\r\n#endif // WIN32\r\n\r\nconst int inf = 1000000000;\r\nconst ll INF = 1LL*inf*inf;\r\nconst long double eps = 1e-9;\r\nconst int md = 1e9 + 7;\r\nconst int md1 = 1e9 + 9;\r\nconst long double EPS = 1e-5;\r\nconst ll maxll = std::numeric_limits<ll>::max();\r\nconst long double PI = acos(-1.0);\r\n\r\ntemplate <typename name> inline name sqr(name x)\r\n{\r\n    return x*x;\r\n}\r\n\r\nld log(ld base, ld n)\r\n{\r\n    return log(n) / log(base);\r\n}\r\n\r\ninline ll multmod(ll a, ll b, ll md)\r\n{\r\n    if (!a) return 0;\r\n    if (a % 2 == 1)\r\n        return (multmod(a-1, b, md) + b) % md;\r\n    else\r\n        return sqr(multmod(a/2, b, md)) % md;\r\n}\r\n\r\ntemplate <typename name> inline name bpow(const name& base, ll exp, const ll& md = maxll)\r\n{\r\n    if (exp == 1) return base;\r\n    if (exp % 2 == 1)\r\n        return (bpow<name>(base, exp-1, md) * base) % md;\r\n    else\r\n    {\r\n        name k = bpow<name>(base, exp/2, md);\r\n        return (k*k)%md;\r\n    }\r\n}\r\n\r\nunsigned char ccc;\r\n\r\ninline bool read(int &n)\r\n{\r\n    n = 0;\r\n    bool _minus = false;\r\n    while (true) {\r\n        ccc = getchar();\r\n        if (ccc == ' ' || ccc == '\\n')\r\n            break;\r\n        if (ccc == '-') {\r\n            _minus = true;\r\n            continue;\r\n        }\r\n        n = n * 10 + ccc - '0';\r\n    }\r\n    if (_minus)\r\n        n *= -1;\r\n    return 1;\r\n}\r\n\r\ninline void read(int &n, int& m)\r\n{\r\n    read(n);\r\n    read(m);\r\n}\r\n\r\ninline void read(int &n, int &m, int &k)\r\n{\r\n    read(n);\r\n    read(m);\r\n    read(k);\r\n}\r\n\r\ninline void read(std::string &s)\r\n{\r\n    s = \"\";\r\n    while (true)\r\n    {\r\n        ccc = getchar();\r\n        if (ccc == ' ' || ccc == '\\n')\r\n            break;\r\n        s += ccc;\r\n    }\r\n}\r\n\r\ntemplate<int N, int M> struct Matr\r\n{\r\n    ll a[N][M];\r\n    Matr()\r\n    {\r\n        for (int i=0; i<N; i++)\r\n            for (int j=0; j<M; j++)\r\n                a[i][j] = 0;\r\n    }\r\n    Matr(const Matr& cp)\r\n    {\r\n        for (int i=0; i<N; i++)\r\n            for (int j=0; j<M; j++)\r\n                a[i][j] = cp.a[i][j];\r\n    }\r\n    void clear()\r\n    {\r\n        for (int i=0; i<N; i++)\r\n            for (int j=0; j<M; j++)\r\n                a[i][j] = 0;\r\n        for (int i=0; i<min(N, M); i++)\r\n            a[i][i] = 1;\r\n    }\r\n};\r\n\r\ntemplate<int N, int M, int K> const Matr<N, M> operator*(Matr<N, K>& lhs, Matr<K, M>& rhs)\r\n{\r\n    Matr<N, M> res;\r\n    for (int i=0; i<N; i++)\r\n        for (int j=0; j<M; j++)\r\n            for (int k=0; k<K; k++)\r\n            {\r\n                res.a[i][j] += (1ll * lhs.a[i][k] * rhs.a[k][j]) % md;\r\n                res.a[i][j] += md;\r\n                res.a[i][j] %= md;\r\n            }\r\n    return res;\r\n}\r\n\r\ntemplate<int N> Matr<N, N> pow_(Matr<N, N> base, ll exp)\r\n{\r\n    Matr<N, N> ans;\r\n    ans.clear();\r\n    while (exp)\r\n    {\r\n        if (exp % 2)\r\n            ans = ans * base;\r\n        base = base * base;\r\n        exp /= 2ll;\r\n    }\r\n    return ans;\r\n}\r\n\r\ntemplate<int N, int M> ostream& operator << (ostream& os, Matr<N, M>& rhs)\r\n{\r\n    for (int i=0; i<N; i++)\r\n        for (int j=0; j<M; j++)\r\n            os << rhs.a[i][j] << (j == M-1 ? \"\\n\" : \" \");\r\n    return os;\r\n}\r\n\r\ntemplate<typename T1, typename T2> inline T1 min(const T1 x, const T2 y)\r\n{\r\n    return (x > y ? y : x);\r\n}\r\n\r\ntemplate<typename T1, typename T2> inline T1 max(const T1 x, const T2 y)\r\n{\r\n    return (x < y ? y : x);\r\n}\r\n\r\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& rhs)\r\n{\r\n    os << rhs.fi << \" \" << rhs.se;\r\n    return os;\r\n}\r\n\r\ntemplate<typename T1> ostream& operator<<(ostream& os, const vector<T1>& rhs)\r\n{\r\n    for (int i=0; i<(int)rhs.size(); i++)\r\n        cout << rhs[i] << (i == (int)rhs.size() - 1 ? \"\" : \" \");\r\n    return os;\r\n}\r\n\r\ntemplate<typename T> inline void minimize(T& value, const T& relax_value)\r\n{\r\n    value = min(value, relax_value);\r\n}\r\n\r\ntemplate<typename T> inline void maximize(T& value, const T& relax_value)\r\n{\r\n    value = max(value, relax_value);\r\n}\r\n\r\ntemplate<typename T> const pair<T, T> operator + (const pair<T, T>& lhs, const T& rhs)\r\n{\r\n    return mp(lhs.fi + rhs, lhs.se + rhs);\r\n}\r\n\r\ntemplate<typename T> const vector<T> operator + (const vector<T>& lhs, const T& rhs)\r\n{\r\n    vector<T> buff = lhs;\r\n    for (auto &x : buff)\r\n        x += rhs;\r\n    return buff;\r\n}\r\n\r\n///-------------------------End of Template-------------------------///\r\n\r\nconst int MAXN = 2e6 + 10;\r\nconst int BASE = 43;\r\n\r\nint n, x, y, a[MAXN], cnt[MAXN];\r\nll sum[MAXN];\r\n\r\nmain()\r\n{\r\n    #ifdef LOCAL\r\n        freopen(\"input.txt\", \"r\", stdin);\r\n        freopen(\"output.txt\", \"w\", stdout);\r\n        freopen(\"debug.txt\", \"w\", stderr);\r\n    #else\r\n        files_dat_sol(\"\");\r\n    #endif // LOCAL\r\n\r\n    scanf(III, &n, &x, &y);\r\n    for (int i=0; i<n; i++)\r\n        scanf(I, &a[i]);\r\n    sort(a, a + n);\r\n    for (int i=1, j=0; i<=2e6; i++)\r\n    {\r\n        sum[i] = sum[i-1];\r\n        cnt[i] = cnt[i-1];\r\n        while (a[j] == i)\r\n            cnt[i]++, sum[i]+=i, j++;\r\n    }\r\n    ll ans = INF;\r\n    for (int i=2; i<=2e6; i++)\r\n    {\r\n        ll cur = 0;\r\n        for (int j=i; j<=2e6; j+=i)\r\n        {\r\n            int d = (x / y);\r\n            int mid = j - d - 1, l = j - i + 1;\r\n            mid = max(mid, l - 1);\r\n            cur += 1ll * x * (cnt[mid] - cnt[l-1]);\r\n            if (mid == l - 1) mid++;\r\n            cur += 1ll * (1ll * (cnt[j] - cnt[mid - 1]) * j - (sum[j] - sum[mid - 1])) * y;\r\n\r\n            //cout << l << \" \" << mid << \" \" << j << \" \" << \" \" << cur << \"\\n\";\r\n        }\r\n        ans = min(ans, cur);\r\n    }\r\n    cout << ans;\r\n\r\n    return 0;\r\n}\r\n"
}