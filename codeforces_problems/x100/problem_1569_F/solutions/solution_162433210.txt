{
    "id": 162433210,
    "contestId": 1569,
    "creationTimeSeconds": 1656677815,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1569,
        "index": "F",
        "name": "Palindromic Hamiltonian Path",
        "type": "PROGRAMMING",
        "rating": 3000,
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "graphs",
            "hashing"
        ]
    },
    "author": {
        "contestId": 1569,
        "members": [
            {
                "handle": "heno239"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1631111700
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#pragma GCC optimize(\"O3\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#include<iostream>\r\n#include<string>\r\n#include<cstdio>\r\n#include<vector>\r\n#include<cmath>\r\n#include<algorithm>\r\n#include<functional>\r\n#include<iomanip>\r\n#include<queue>\r\n#include<ciso646>\r\n#include<random>\r\n#include<map>\r\n#include<set>\r\n#include<bitset>\r\n#include<stack>\r\n#include<unordered_map>\r\n#include<unordered_set>\r\n#include<utility>\r\n#include<cassert>\r\n#include<complex>\r\n#include<numeric>\r\n#include<array>\r\n#include<chrono>\r\nusing namespace std;\r\n\r\n//#define int long long\r\ntypedef long long ll;\r\n\r\ntypedef unsigned long long ul;\r\ntypedef unsigned int ui;\r\nconstexpr ll mod = 998244353;\r\n//constexpr ll mod = 1000000007;\r\nconst ll INF = mod * mod;\r\ntypedef pair<int, int>P;\r\n\r\n#define rep(i,n) for(int i=0;i<n;i++)\r\n#define per(i,n) for(int i=n-1;i>=0;i--)\r\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\r\n#define rep1(i,n) for(int i=1;i<=n;i++)\r\n#define per1(i,n) for(int i=n;i>=1;i--)\r\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\r\n#define all(v) (v).begin(),(v).end()\r\ntypedef pair<ll, ll> LP;\r\n\r\ntemplate<typename T>\r\nvoid chmin(T& a, T b) {\r\n\ta = min(a, b);\r\n}\r\ntemplate<typename T>\r\nvoid chmax(T& a, T b) {\r\n\ta = max(a, b);\r\n}\r\ntemplate<typename T>\r\nvoid cinarray(vector<T>& v) {\r\n\trep(i, v.size())cin >> v[i];\r\n}\r\ntemplate<typename T>\r\nvoid coutarray(vector<T>& v) {\r\n\trep(i, v.size()) {\r\n\t\tif (i > 0)cout << \" \"; cout << v[i];\r\n\t}\r\n\tcout << \"\\n\";\r\n}\r\nll mod_pow(ll x, ll n, ll m = mod) {\r\n\tif (n < 0) {\r\n\t\tll res = mod_pow(x, -n, m);\r\n\t\treturn mod_pow(res, m - 2, m);\r\n\t}\r\n\tif (abs(x) >= m)x %= m;\r\n\tif (x < 0)x += m;\r\n\t//if (x == 0)return 0;\r\n\tll res = 1;\r\n\twhile (n) {\r\n\t\tif (n & 1)res = res * x % m;\r\n\t\tx = x * x % m; n >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\nstruct modint {\r\n\tint n;\r\n\tmodint() :n(0) { ; }\r\n\tmodint(ll m) {\r\n\t\tif (m < 0 || mod <= m) {\r\n\t\t\tm %= mod; if (m < 0)m += mod;\r\n\t\t}\r\n\t\tn = m;\r\n\t}\r\n\toperator int() { return n; }\r\n};\r\nbool operator==(modint a, modint b) { return a.n == b.n; }\r\nbool operator<(modint a, modint b) { return a.n < b.n; }\r\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\r\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\r\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\r\nmodint operator+(modint a, modint b) { return a += b; }\r\nmodint operator-(modint a, modint b) { return a -= b; }\r\nmodint operator*(modint a, modint b) { return a *= b; }\r\nmodint operator^(modint a, ll n) {\r\n\tif (n == 0)return modint(1);\r\n\tmodint res = (a * a) ^ (n / 2);\r\n\tif (n % 2)res = res * a;\r\n\treturn res;\r\n}\r\n\r\nll inv(ll a, ll p) {\r\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\r\n}\r\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\r\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\r\nconst int max_n = 1 << 20;\r\nmodint fact[max_n], factinv[max_n];\r\nvoid init_f() {\r\n\tfact[0] = modint(1);\r\n\tfor (int i = 0; i < max_n - 1; i++) {\r\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\r\n\t}\r\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\r\n\tfor (int i = max_n - 2; i >= 0; i--) {\r\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\r\n\t}\r\n}\r\nmodint comb(int a, int b) {\r\n\tif (a < 0 || b < 0 || a < b)return 0;\r\n\treturn fact[a] * factinv[b] * factinv[a - b];\r\n}\r\nmodint combP(int a, int b) {\r\n\tif (a < 0 || b < 0 || a < b)return 0;\r\n\treturn fact[a] * factinv[a - b];\r\n}\r\n\r\nll gcd(ll a, ll b) {\r\n\ta = abs(a); b = abs(b);\r\n\tif (a < b)swap(a, b);\r\n\twhile (b) {\r\n\t\tll r = a % b; a = b; b = r;\r\n\t}\r\n\treturn a;\r\n}\r\ntypedef long double ld;\r\ntypedef pair<ld, ld> LDP;\r\nconst ld eps = 1e-8;\r\nconst ld pi = acosl(-1.0);\r\ntemplate<typename T>\r\nvoid addv(vector<T>& v, int loc, T val) {\r\n\tif (loc >= v.size())v.resize(loc + 1, 0);\r\n\tv[loc] += val;\r\n}\r\n/*const int mn = 100005;\r\nbool isp[mn];\r\nvector<int> ps;\r\nvoid init() {\r\n\tfill(isp + 2, isp + mn, true);\r\n\tfor (int i = 2; i < mn; i++) {\r\n\t\tif (!isp[i])continue;\r\n\t\tps.push_back(i);\r\n\t\tfor (int j = 2 * i; j < mn; j += i) {\r\n\t\t\tisp[j] = false;\r\n\t\t}\r\n\t}\r\n}*/\r\n\r\n//[,val)\r\ntemplate<typename T>\r\nauto prev_itr(set<T>& st, T val) {\r\n\tauto res = st.lower_bound(val);\r\n\tif (res == st.begin())return st.end();\r\n\tres--; return res;\r\n}\r\n\r\n//[val,)\r\ntemplate<typename T>\r\nauto next_itr(set<T>& st, T val) {\r\n\tauto res = st.lower_bound(val);\r\n\treturn res;\r\n}\r\nusing mP = pair<modint, modint>;\r\nmP operator+(mP a, mP b) {\r\n\treturn { a.first + b.first,a.second + b.second };\r\n}\r\nmP operator+=(mP& a, mP b) {\r\n\ta = a + b; return a;\r\n}\r\nmP operator-(mP a, mP b) {\r\n\treturn { a.first - b.first,a.second - b.second };\r\n}\r\nmP operator-=(mP& a, mP b) {\r\n\ta = a - b; return a;\r\n}\r\n\r\nmt19937 mt(time(0));\r\n\r\nconst string drul = \"DRUL\";\r\nstring senw = \"SENW\";\r\n//DRUL,or SENW\r\nint dx[4] = { 1,0,-1,0 };\r\nint dy[4] = { 0,1,0,-1 };\r\n//-----------------------------------------\r\n\r\nvoid expr() {\r\n\tint n = 12;\r\n\tint s = 6;\r\n\tint cur = 0;\r\n\tint sum = 0;\r\n\tvector<int> col(n);\r\n\tvector<int> cnt(n);\r\n\tfunction<void(int)> dfs = [&](int d) {\r\n\t\tif (d == n) {\r\n\t\t\tbool valid = true;\r\n\t\t\trep(i, cur) {\r\n\t\t\t\tif (cnt[i]%2)valid = false;\r\n\t\t\t}\r\n\t\t\tif (valid) {\r\n\t\t\t\tsum++;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trep(i, cur) {\r\n\t\t\tcol[d] = i;\r\n\t\t\tcnt[i]++;\r\n\t\t\tdfs(d + 1);\r\n\t\t\tcnt[i]--;\r\n\t\t}\r\n\t\tcol[d] = cur;\r\n\t\tcnt[cur]++;\r\n\t\tcur++; \r\n\t\tdfs(d+1);\r\n\t\tcur--;\r\n\t\tcnt[cur]--;\r\n\t};\r\n\tdfs(0);\r\n\tcout << sum << \"\\n\";\r\n}\r\n\r\nbool exi[12][12];\r\nll t12[12];\r\nvoid solve() {\r\n\tt12[0] = 1;\r\n\trep(i, 11)t12[i + 1] = t12[i] * 12;\r\n\tint n, m, k; cin >> n >> m >> k;\r\n\trep(i, m) {\r\n\t\tint a, b; cin >> a >> b; a--; b--;\r\n\t\texi[a][b] = exi[b][a] = true;\r\n\t}\r\n\tint tmp = 0;\r\n\tvector<bool> used(n);\r\n\tll cur = 0;\r\n\r\n\tvector<ll> vs;\r\n\tfunction<void(int)> dfs = [&](int d) {\r\n\t\tif (d == n) {\r\n\t\t\t//check later\r\n\t\t\tvs.push_back(cur);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (used[d])dfs(d + 1);\r\n\t\tfor (int i = d + 1; i < n; i++)if (!used[i]) {\r\n\t\t\tll ad = t12[tmp] * d + t12[tmp + 1] * i;\r\n\t\t\tcur += ad; tmp += 2; used[d] = true; used[i] = true;\r\n\t\t\tdfs(d + 1);\r\n\t\t\tcur -= ad; tmp -= 2; used[d] = false; used[i] = false;\r\n\t\t}\r\n\t};\r\n\tdfs(0);\r\n\t{\r\n\t\tvector<ll> nvs;\r\n\t\tfor (ll val : vs) {\r\n\t\t\tvector<int> v;\r\n\t\t\tll cop = val;\r\n\t\t\trep(i, n) {\r\n\t\t\t\tv.push_back(cop % 12); cop /= 12;\r\n\t\t\t}\r\n\t\t\tvector<P> ps;\r\n\t\t\trep(i, n / 2) {\r\n\t\t\t\tps.push_back({ v[2 * i],v[2 * i + 1] });\r\n\t\t\t}\r\n\t\t\tint sz = ps.size();\r\n\t\t\tvector<vector<bool>> can(sz, vector<bool>(sz,false));\r\n\t\t\trep(i, sz)rep(j, sz) {\r\n\t\t\t\tif (exi[ps[i].first][ps[j].first] && exi[ps[i].second][ps[j].second])can[i][j] = true;\r\n\t\t\t\tif (exi[ps[i].first][ps[j].second] && exi[ps[i].second][ps[j].first])can[i][j] = true;\r\n\t\t\t}\r\n\t\t\tvector<vector<bool>> dp(1 << sz, vector<bool>(sz));\r\n\t\t\trep(i, sz) {\r\n\t\t\t\tif (exi[ps[i].first][ps[i].second]) {\r\n\t\t\t\t\tdp[(1 << i)][i] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trep(i, (1 << sz))rep(j, sz) {\r\n\t\t\t\tif (!dp[i][j])continue;\r\n\t\t\t\trep(k, sz) {\r\n\t\t\t\t\tif (i & (1 << k))continue;\r\n\t\t\t\t\tif (!can[j][k])continue;\r\n\t\t\t\t\tdp[i | (1 << k)][k] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbool valid = false;\r\n\t\t\trep(i, sz)if (dp[(1 << sz) - 1][i])valid = true;\r\n\t\t\tif (valid) {\r\n\t\t\t\tnvs.push_back(val);\r\n\t\t\t}\r\n\t\t}\r\n\t\tswap(vs, nvs);\r\n\t}\r\n\t//cout << \"?? \" << vs.size() << \"\\n\";\r\n\tunordered_map<ll, int> mp;\r\n\tfor (ll val : vs)mp[val] = true;\r\n\ttmp = 0;\r\n\tvector<int> col(n);\r\n\tvector<int> cnt(n + 1);\r\n\tfunction<void(int)> coldfs = [&](int d) {\r\n\t\tif (d == n) {\r\n\t\t\t//check\r\n\t\t\tvector<int> num(tmp);\r\n\t\t\trep(i, n)num[col[i]]++;\r\n\t\t\tbool isret = false;\r\n\t\t\trep(i, tmp)if (num[i] % 2)isret = true;\r\n\t\t\tif (isret)return;\r\n\t\t\tint tmp = 0;\r\n\t\t\tvector<bool> used(n);\r\n\t\t\tll cur = 0;\r\n\t\t\tbool valid = false;\r\n\t\t\tfunction<void(int)> sdfs = [&](int d) {\r\n\t\t\t\tif (d == n) {\r\n\t\t\t\t\tif (mp[cur])valid = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (used[d])sdfs(d + 1);\r\n\t\t\t\tfor (int i = d + 1; i < n; i++)if (!used[i]&&col[d]==col[i]) {\r\n\t\t\t\t\tll ad = t12[tmp] * d + t12[tmp + 1] * i;\r\n\t\t\t\t\tcur += ad; tmp += 2; used[d] = true; used[i] = true;\r\n\t\t\t\t\tdfs(d + 1);\r\n\t\t\t\t\tcur -= ad; tmp -= 2; used[d] = false; used[i] = false;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tsdfs(0);\r\n\t\t\tif (valid) {\r\n\t\t\t\tcnt[tmp]++;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trep(i, tmp) {\r\n\t\t\tcol[d] = i;\r\n\t\t\tcoldfs(d + 1);\r\n\t\t}\r\n\t\tcol[d] = tmp; tmp++;\r\n\t\tcoldfs(d + 1);\r\n\t\ttmp--;\r\n\t};\r\n\tcoldfs(0);\r\n\tll ans = 0;\r\n\trep(i, n + 1) {\r\n\t\tans += (ll)combP(k, i) * cnt[i];\r\n\t}\r\n\tcout << ans << \"\\n\";\r\n}\r\n\r\nsigned main() {\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\t//cout << fixed << setprecision(10);\r\n\tinit_f();\r\n\t//init();\r\n\t//expr();\r\n\t//while(true)\r\n\t//int t; cin >> t;rep(i,t)\r\n\tsolve();\r\n\treturn 0;\r\n}\r\nmemo"
}