{
    "id": 195132777,
    "contestId": 1362,
    "creationTimeSeconds": 1677505156,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1362,
        "index": "A",
        "name": "Johnny and Ancient Computer",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 1000,
        "tags": [
            "implementation"
        ]
    },
    "author": {
        "contestId": 1362,
        "members": [
            {
                "handle": "yl_neo"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1591281300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\n#include<iostream>\r\n#include<stdlib.h>\r\n#include<cmath>\r\n#include <algorithm>\r\n#include<numeric>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef pair<int, int> pii;\r\ntypedef vector<int> vi;\r\ntypedef vector<vi> vvi;\r\ntypedef vector<pair<int, int> > vpii;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<ll> vll;\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define trav(a,x) for (auto& a: x)\r\n#define fr(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>=(b); i+=(s))\r\n#define mp make_pair\r\n#define pb push_back\r\n#define sz(x) int(x.size())\r\n#define all(x) begin(x), end(x)\r\n#define rall(x) rbegin(x), rend(x)\r\n#define in insert\r\n#define yes cout<<\"YES\\n\"\r\n#define no cout<<\"NO\\n\"\r\n#define out(x) cout<<x<<'\\n'\r\nint dx[4] = { -1, 0, 1, 0 };\r\nint dy[4] = { 0, 1, 0, -1 };\r\n\r\ndouble pi = 3.141592;\r\nvoid xd(string str)\r\n{\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tif (str != \"\")\r\n\t{\r\n\t\t//freopen((str + \".in\").c_str(), \"r\", stdin);\r\n\t\t//freopen((str + \".out\").c_str(), \"w\", stdout);\r\n\t}\r\n}\r\ntemplate <typename T>\r\nT inverse(T a, T m) {\r\n\tT u = 0, v = 1;\r\n\twhile (a != 0) {\r\n\t\tT t = m / a;\r\n\t\tm -= t * a; swap(a, m);\r\n\t\tu -= t * v; swap(u, v);\r\n\t}\r\n\tassert(m == 1);\r\n\treturn u;\r\n}\r\n\r\ntemplate <typename T>\r\nclass Modular {\r\npublic:\r\n\tusing Type = typename decay<decltype(T::value)>::type;\r\n\r\n\tconstexpr Modular() : value() {}\r\n\ttemplate <typename U>\r\n\tModular(const U& x) {\r\n\t\tvalue = normalize(x);\r\n\t}\r\n\r\n\ttemplate <typename U>\r\n\tstatic Type normalize(const U& x) {\r\n\t\tType v;\r\n\t\tif (-mod() <= x && x < mod()) v = static_cast<Type>(x);\r\n\t\telse v = static_cast<Type>(x % mod());\r\n\t\tif (v < 0) v += mod();\r\n\t\treturn v;\r\n\t}\r\n\r\n\tconst Type& operator()() const { return value; }\r\n\ttemplate <typename U>\r\n\texplicit operator U() const { return static_cast<U>(value); }\r\n\tconstexpr static Type mod() { return T::value; }\r\n\r\n\tModular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\r\n\tModular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\r\n\ttemplate <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\r\n\ttemplate <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\r\n\tModular& operator++() { return *this += 1; }\r\n\tModular& operator--() { return *this -= 1; }\r\n\tModular operator++(int) { Modular result(*this); *this += 1; return result; }\r\n\tModular operator--(int) { Modular result(*this); *this -= 1; return result; }\r\n\tModular operator-() const { return Modular(-value); }\r\n\r\n\ttemplate <typename U = T>\r\n\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\r\n\t\treturn *this;\r\n\t}\r\n\ttemplate <typename U = T>\r\n\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n\t\tint64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\r\n\t\tvalue = normalize(value * rhs.value - q * mod());\r\n\t\treturn *this;\r\n\t}\r\n\ttemplate <typename U = T>\r\n\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\r\n\t\tvalue = normalize(value * rhs.value);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tModular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\r\n\r\n\ttemplate <typename U>\r\n\tfriend const Modular<U>& abs(const Modular<U>& v) { return v; }\r\n\r\n\ttemplate <typename U>\r\n\tfriend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\r\n\r\n\ttemplate <typename U>\r\n\tfriend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\r\n\r\n\ttemplate <typename U>\r\n\tfriend std::istream& operator>>(std::istream& stream, Modular<U>& number);\r\n\r\nprivate:\r\n\tType value;\r\n};\r\n\r\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\r\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\r\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\r\n\r\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\r\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r\n\r\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\r\n\r\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r\n\r\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r\n\r\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r\n\r\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\r\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r\n\r\ntemplate<typename T, typename U>\r\nModular<T> power(const Modular<T>& a, const U& b) {\r\n\tassert(b >= 0);\r\n\tModular<T> x = a, res = 1;\r\n\tU p = b;\r\n\twhile (p > 0) {\r\n\t\tif (p & 1) res *= x;\r\n\t\tx *= x;\r\n\t\tp >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\ntemplate <typename T>\r\nbool IsZero(const Modular<T>& number) {\r\n\treturn number() == 0;\r\n}\r\n\r\ntemplate <typename T>\r\nstring to_string(const Modular<T>& number) {\r\n\treturn to_string(number());\r\n}\r\n\r\ntemplate <typename T>\r\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\r\n\treturn stream << number();\r\n}\r\n\r\ntemplate <typename T>\r\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\r\n\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;\r\n\tstream >> x;\r\n\tnumber.value = Modular<T>::normalize(x);\r\n\treturn stream;\r\n}\r\n\r\n/*\r\nusing ModType = int;\r\n\r\nstruct VarMod { static ModType value; };\r\nModType VarMod::value;\r\nModType& md = VarMod::value;\r\nusing Mint = Modular<VarMod>;\r\n*/\r\n\r\nconstexpr int md = int(1e9+7);\r\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\r\n\r\nvector<Mint> fact(1, 1);\r\nvector<Mint> inv_fact(1, 1);\r\n\r\nMint C(int n, int k) {\r\n\tif (k < 0 || k > n) {\r\n\t\treturn 0;\r\n\t}\r\n\twhile ((int)fact.size() < n + 1) {\r\n\t\tfact.push_back(fact.back() * (int)fact.size());\r\n\t\tinv_fact.push_back(1 / fact.back());\r\n\t}\r\n\treturn fact[n] * inv_fact[k] * inv_fact[n - k];\r\n}\r\n\r\nint add(int a, int b, int mod) { return (((a % mod) + (b % mod)) + mod) % mod; }\r\nint sub(int a, int b, int mod) { return (((a % mod) - (b % mod)) + mod) % mod; }\r\nint mul(int a, int b, int mod) { return (((a % mod) * (b % mod)) + mod) % mod; }\r\nint bin(int a, int b, int mod) { int ans = 1; while (b) { if (b & 1) ans = mul(ans, a, mod); a = mul(a, a, mod); b >>= 1; }return ans; }\r\nint inverse(int a, int mod) { return bin(a, mod - 2, mod); }\r\nint divi(int a, int b, int mod) {\r\n\treturn mul(a, inverse(b, mod), mod);\r\n}\r\nll add(ll a, ll b, ll mod) { return (((a % mod) + (b % mod)) + mod) % mod; }\r\nll sub(ll a, ll b, ll mod) { return (((a % mod) - (b % mod)) + mod) % mod; }\r\nll mul(ll a, ll b, ll mod) { return (((a % mod) * (b % mod)) + mod) % mod; }\r\nll bin(ll a, ll b, ll mod) { ll ans = 1; while (b) { if (b & 1) ans = mul(ans, a, mod); a = mul(a, a, mod); b >>= 1; }return ans; }\r\nll inverse(ll a, ll mod) { return bin(a, mod - 2, mod); }\r\nll divi(ll a, ll b, ll mod) {\r\n\treturn mul(a, inverse(b, mod), mod);\r\n}\r\nll ex(int base, int power, int modulo)\r\n{\r\n\tif (power == 0)\r\n\t\treturn 1;\r\n\tll result = ex(base, power / 2, modulo);\r\n\tif (power % 2 == 1)\r\n\t\treturn(((result * result) % modulo) * base) % modulo;\r\n\telse return (result * result) % modulo;\r\n}\r\nint gcd(int a, int b) {\r\n\tif (b == 0)return a;\r\n\telse return gcd(b, a % b);\r\n}\r\nint lcm(int a, int b) {\r\n\treturn a * b / gcd(a, b);\r\n}\r\nll gcd(ll a, ll b) {\r\n\tif (b == 0)return a;\r\n\telse return gcd(b, a % b);\r\n}\r\nll lcm(ll a, ll b) {\r\n\treturn a * b / gcd(a, b);\r\n}\r\nll fac(int x, ll mod) {\r\n\tll factorial = 1;\r\n\tfor (ll i = 1; i <= x; ++i) {\r\n\t\tfactorial = mul(factorial, i, mod);\r\n\t}\r\n\treturn factorial % mod;\r\n}\r\nll npr(int x, int c, ll mod) {\r\n\tif (x < c) return 0;\r\n\tif (x == c) return fac(x, mod);\r\n\telse return divi(fac(x, mod), (fac(x - c, mod)), mod);\r\n}\r\nll ncr(int x, int c, ll mod) {\r\n\tif (x < c) return 0;\r\n\tif (x == c) return 1;\r\n\telse return divi(fac(x, mod), mul((fac(x - c, mod)), fac(c, mod), mod), mod);\r\n}\r\nvoid bton(string s) { stoll(s, nullptr, 2); }\r\nbool isPrime(int n)\r\n{\r\n\tif (n == 2 || n == 3)\r\n\t\treturn true;\r\n\r\n\tif (n <= 1 || n % 2 == 0 || n % 3 == 0)\r\n\t\treturn false;\r\n\tfor (int i = 5; i * i <= n; i += 6) {\r\n\t\tif (n % i == 0 || n % (i + 2) == 0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\nint ceil_int(int first_number, int divider) {\r\n\tif (first_number % divider == 0) return first_number / divider;\r\n\telse return first_number / divider + 1;\r\n}\r\nll ceil_ll(ll first_number, ll divider) {\r\n\tif (first_number % divider == 0) return first_number / divider;\r\n\telse return first_number / divider + 1LL;\r\n}\r\nll chinese(vll num, vll rem) {\r\n\tvll pp; pp.clear();\r\n\tll prod = 1LL;\r\n\tFOR(i, 0, sz(num))prod *= num[i];\r\n\tFOR(i, 0, sz(num))pp.push_back(prod / num[i]);\r\n\tvll inv; inv.clear();\r\n\tFOR(i, 0, sz(pp)) {\r\n\t\tinv.push_back(ex(pp[i], num[i] - 2, num[i]));\r\n\t}\r\n\tll ans = 0LL;\r\n\tFOR(i, 0, sz(pp)) {\r\n\t\tans = ans % prod + (((rem[i] * pp[i]) % prod) * (inv[i] % prod)) % prod;\r\n\t\tans %= prod;\r\n\t}\r\n\treturn ans;\r\n}\r\n//ncr(n+k-1,k-1) where a[i]>=0 need to consider the condition where a[i] is positive int or odd or whatever(on this n will change)\r\nvector<int> smallest_factor;\r\nvector<bool> prime;\r\nvector<int> primes;\r\n// Note: this sieve is O(n), but the constant factor is worse than the O(n log log n) sieve due to the multiplication.\r\nvoid sieve(int maximum) {\r\n\tmaximum = max(maximum, 1);\r\n\tsmallest_factor.assign(maximum + 1, 0);\r\n\tprime.assign(maximum + 1, true);\r\n\tprime[0] = prime[1] = false;\r\n\tprimes = {};\r\n\r\n\tfor (int i = 2; i <= maximum; i++) {\r\n\t\tif (prime[i]) {\r\n\t\t\tsmallest_factor[i] = i;\r\n\t\t\tprimes.push_back(i);\r\n\t\t}\r\n\r\n\t\tfor (int p : primes) {\r\n\t\t\tif (p > smallest_factor[i] || int64_t(i) * p > maximum)\r\n\t\t\t\tbreak;\r\n\t\t\tprime[i * p] = false;\r\n\t\t\tsmallest_factor[i * p] = p;\r\n\t\t}\r\n\t}\r\n}\r\nlong long query_ask(int a, int b) {\r\n\tcout << \"? \" << a << ' ' << b << endl;\r\n\tlong long x; cin >> x;\r\n\treturn x;\r\n}\r\nvoid query_ans(long long a) {\r\n\tcout << \"! \" << a << endl;\r\n\treturn;\r\n}\r\nint computeXOR(int n)// from 0 to n-1\r\n{\r\n\tif (n % 4 == 0)\r\n\t\treturn n;\r\n\tif (n % 4 == 1)\r\n\t\treturn 1;\r\n\tif (n % 4 == 2)\r\n\t\treturn n + 1;\r\n\treturn 0;\r\n}\r\nint digit_sum(int g) {\r\n\tint cnt = 0;\r\n\twhile (g > 0) {\r\n\t\tcnt += g % 10;\r\n\t\tg /= 10;\r\n\t}\r\n\treturn cnt;\r\n}\r\nvoid solve()\r\n{\r\n\tll n, m; cin >> n >> m;\r\n\tif (n == m) cout << \"0\\n\";\r\n\telse {\r\n\t\tif ((max(n, m) / min(n, m)) % 2 == 1) cout << \"-1\\n\";\r\n\t\telse {\r\n\t\t\tll steps = (max(n, m) / min(n, m));\r\n\t\t\tll cnt = 0;\r\n\t\t\twhile (steps>=8) {\r\n\t\t\t\tsteps /= 8;\r\n\t\t\t\tcnt++;\r\n\t\t\t}\r\n\t\t\tif (steps == 1) cout << cnt << '\\n';\r\n\t\t\telse if (steps == 4 || steps == 2) cout << cnt + 1 << '\\n';\r\n\t\t\telse cout << cnt + 2 << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\nint main()\r\n{\r\n\txd(\"\");\r\n\tint t = 1; cin >> t;\r\n\twhile (t--) {\r\n\t\tsolve();\r\n\t}\r\n\treturn 0;\r\n}"
}