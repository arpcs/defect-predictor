{
    "id": 190615445,
    "contestId": 1780,
    "creationTimeSeconds": 1674712160,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1780,
        "index": "A",
        "name": "Hayato and School",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1780,
        "members": [
            {
                "handle": "anikethend1234"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1674657300
    },
    "programmingLanguage": "Java 17",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 264,
    "memoryConsumedBytes": 307200,
    "source": "import static java.lang.Math.max;\r\nimport static java.lang.Math.min;\r\nimport static java.lang.Math.abs;\r\nimport static java.lang.System.out;\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\npublic class Codechef {\r\n    public static void main(String aniket[]) throws Exception {\r\n        // BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\r\n        // StringTokenizer st = new StringTokenizer(infile.readLine());\r\n        // int N = Integer.parseInt(st.nextToken());\r\n        // int M = Integer.parseInt(st.nextTokinten());\r\n\r\n        // int T = Integer.parseInt(st.nextToken());\r\n        // StringBuilder sb = new StringBuilder();\r\n        // while (T-- > 0) {\r\n        // st = new StringTokenizer(infile.readLine());\r\n        // int N = Integer.parseInt(st.nextToken());\r\n        // int[] arr = readArr(N, infile, st);\r\n        // }\r\n\r\n        // BufferedReader infile = new BufferedReader(new FileReader(\"input.txt\"));\r\n        // System.setOut(new PrintStream(new File(\"output.txt\")));\r\n\r\n        IO sc = new IO();\r\n\r\n        int T = sc.nextInt();\r\n\r\n        while (T-- > 0) {\r\n            int n=sc.nextInt();\r\n\r\n            int a[]=new int[n];\r\n            \r\n            for(int i=0;i<n;i++){\r\n                a[i]=sc.nextInt();\r\n            }\r\n\r\n            ArrayList<Integer> lo=new ArrayList<>();\r\n            ArrayList<Integer> le=new ArrayList<>();\r\n\r\n            for(int i=0;i<n;i++){\r\n                if(a[i]%2==0){\r\n                    le.add(i+1);\r\n                }\r\n                else{\r\n                    lo.add(i+1);\r\n                }\r\n            }\r\n\r\n            int o=lo.size();\r\n            int e=le.size();\r\n\r\n            if(n>2){\r\n                if(o>=1 && e!=1){\r\n                    System.out.println(\"YES\");\r\n\r\n                    if(o>=3){\r\n                        System.out.println((long)lo.get(0)+\" \"+(long)lo.get(1)+\" \"+(long)lo.get(2));\r\n                    }\r\n                    else if(o<3 && e>1){\r\n                        System.out.println((long)lo.get(0)+\" \"+(long)le.get(0)+\" \"+(long)le.get(1));\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"NO\");\r\n                }\r\n            }\r\n            else{\r\n                System.out.println(\"NO\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception {\r\n        int[] arr = new int[N];\r\n        st = new StringTokenizer(infile.readLine());\r\n        for (int i = 0; i < N; i++) {\r\n            arr[i] = Integer.parseInt(st.nextToken());\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    public static void print(int[] arr) {\r\n        // for debugging only\r\n        for (int x : arr) {\r\n            out.print(x + \" \");\r\n        }\r\n        out.println();\r\n    }\r\n\r\n    public int gcd(int a, int b) {\r\n        BigInteger b1 = BigInteger.valueOf(a);\r\n        BigInteger b2 = BigInteger.valueOf(b);\r\n\r\n        BigInteger gcd = b1.gcd(b2);\r\n        BigInteger lcm = b1.nextProbablePrime();\r\n        System.out.println(lcm.intValue());\r\n        return gcd.intValue();\r\n    }\r\n\r\n    public long gcd(long a, long b) {\r\n        BigInteger b1 = BigInteger.valueOf(a);\r\n        BigInteger b2 = BigInteger.valueOf(b);\r\n        BigInteger gcd = b1.gcd(b2);\r\n        return gcd.longValue();\r\n    }\r\n\r\n    // input shenanigans\r\n    /*\r\n     * Random stuff to try when stuck:\r\n     * -if it's 2C then it's dp\r\n     * -for combo/probability problems, expand the given form we're interested in\r\n     * -make everything the same then build an answer (constructive, make everything\r\n     * 0 then do something)\r\n     * -something appears in parts of 2 --> model as graph\r\n     * -assume a greedy then try to show why it works\r\n     * -find way to simplify into one variable if multiple exist\r\n     * -treat it like fmc (note any passing thoughts/algo that could be used so you\r\n     * can revisit them)\r\n     * -find lower and upper bounds on answer\r\n     * -figure out what ur trying to find and isolate it\r\n     * -see what observations you have and come up with more continuations\r\n     * -work backwards (in constructive, go from the goal to the start)\r\n     * -turn into prefix/suffix sum argument (often works if problem revolves around\r\n     * adjacent array elements)\r\n     * -instead of solving for answer, try solving for complement (ex, find n-(min)\r\n     * instead of max)\r\n     * -draw something\r\n     * -simulate a process\r\n     * -dont implement something unless if ur fairly confident its correct\r\n     * -after 3 bad submissions move on to next problem if applicable\r\n     * -do something instead of nothing and stay organized\r\n     * -write stuff down\r\n     * Random stuff to check when wa:\r\n     * -if code is way too long/cancer then reassess\r\n     * -switched N/M\r\n     * -int overflow\r\n     * -switched variables\r\n     * -wrong MOD\r\n     * -hardcoded edge case incorrectly\r\n     * Random stuff to check when tle:\r\n     * -continue instead of break\r\n     * -condition in for/while loop bad\r\n     * Random stuff to check when rte:\r\n     * -switched N/M\r\n     * -long to int/int overflow\r\n     * -division by 0\r\n     * -edge case for empty list/data structure/N=1\r\n     */\r\n    public static long[] readArr2(int N, BufferedReader infile, StringTokenizer st) throws Exception {\r\n        long[] arr = new long[N];\r\n        st = new StringTokenizer(infile.readLine());\r\n        for (int i = 0; i < N; i++)\r\n            arr[i] = Long.parseLong(st.nextToken());\r\n        return arr;\r\n    }\r\n\r\n    public static boolean isPrime(long n) {\r\n        if (n < 2)\r\n            return false;\r\n        if (n == 2 || n == 3)\r\n            return true;\r\n        if (n % 2 == 0 || n % 3 == 0)\r\n            return false;\r\n        long sqrtN = (long) Math.sqrt(n) + 1;\r\n        for (long i = 6L; i <= sqrtN; i += 6) {\r\n            if (n % (i - 1) == 0 || n % (i + 1) == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static long totient(long n) {\r\n        long result = n;\r\n        for (int p = 2; p * p <= n; ++p)\r\n            if (n % p == 0) {\r\n                while (n % p == 0)\r\n                    n /= p;\r\n                result -= result / p;\r\n            }\r\n        if (n > 1)\r\n            result -= result / n;\r\n        return result;\r\n        /*\r\n         * find phi(i) from 1 to N fast\r\n         * O(N*loglogN)\r\n         * long[] arr = new long[N+1];\r\n         *\r\n         * for(int i=1; i <= N; i++)\r\n         * arr[i] = i;\r\n         * for(int v=2; v <= N; v++)\r\n         * if(arr[v] == v)\r\n         * for(int a=v; a <= N; a+=v)\r\n         * arr[a] -= arr[a]/v;\r\n         */\r\n    }\r\n\r\n    /* Divisors of N */\r\n    public static ArrayList<Integer> findDiv(int N) {\r\n        // gens all divisors of N\r\n        ArrayList<Integer> ls1 = new ArrayList<Integer>();\r\n        ArrayList<Integer> ls2 = new ArrayList<Integer>();\r\n        for (int i = 1; i <= (int) (Math.sqrt(N) + 0.00000001); i++)\r\n            if (N % i == 0) {\r\n                ls1.add(i);\r\n                ls2.add(N / i);\r\n            }\r\n        Collections.reverse(ls2);\r\n        for (int b : ls2)\r\n            if (b != ls1.get(ls1.size() - 1))\r\n                ls1.add(b);\r\n        return ls1;\r\n    }\r\n\r\n    public static void sort(int[] arr) {\r\n        // because Arrays.sort() uses quicksort which is dumb\r\n        // Collections.sort() uses merge sort\r\n        ArrayList<Integer> ls = new ArrayList<Integer>();\r\n        for (int x : arr)\r\n            ls.add(x);\r\n        Collections.sort(ls);\r\n        for (int i = 0; i < arr.length; i++)\r\n            arr[i] = ls.get(i);\r\n    }\r\n\r\n    public static void revsort(int[] arr) {\r\n        // because Arrays.sort() uses quicksort which is dumb\r\n        // Collections.sort() uses merge sort\r\n        ArrayList<Integer> ls = new ArrayList<Integer>();\r\n        for (int x : arr)\r\n            ls.add(x);\r\n        Collections.sort(ls, Comparator.reverseOrder());\r\n        for (int i = 0; i < arr.length; i++)\r\n            arr[i] = ls.get(i);\r\n    }\r\n\r\n    public static long power(long x, long y, long p) {\r\n        // 0^0 = 1\r\n        long res = 1L;\r\n        x = x % p;\r\n        while (y > 0) {\r\n            if ((y & 1) == 1)\r\n                res = (res * x) % p;\r\n            y >>= 1;\r\n            x = (x * x) % p;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // custom multiset (replace with HashMap if needed)\r\n    public static void push(TreeMap<Integer, Integer> map, int k, int v) {\r\n        // map[k] += v;\r\n        if (!map.containsKey(k))\r\n            map.put(k, v);\r\n        else\r\n            map.put(k, map.get(k) + v);\r\n    }\r\n\r\n    public static void pull(TreeMap<Integer, Integer> map, int k, int v) {\r\n        // assumes map[k] >= v\r\n        // map[k] -= v\r\n        int lol = map.get(k);\r\n        if (lol == v)\r\n            map.remove(k);\r\n        else\r\n            map.put(k, lol - v);\r\n    }\r\n\r\n    public static int[] compress(int[] arr) {\r\n        ArrayList<Integer> ls = new ArrayList<Integer>();\r\n        for (int x : arr)\r\n            ls.add(x);\r\n        Collections.sort(ls);\r\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n        int boof = 1; // min value\r\n        for (int x : ls)\r\n            if (!map.containsKey(x))\r\n                map.put(x, boof++);\r\n        int[] brr = new int[arr.length];\r\n        for (int i = 0; i < arr.length; i++)\r\n            brr[i] = map.get(arr[i]);\r\n        return brr;\r\n    }\r\n\r\n    public static long[][] multiply(long[][] left, long[][] right) {\r\n        long MOD = 1000000007L;\r\n        int N = left.length;\r\n        int M = right[0].length;\r\n        long[][] res = new long[N][M];\r\n        for (int a = 0; a < N; a++)\r\n            for (int b = 0; b < M; b++)\r\n                for (int c = 0; c < left[0].length; c++) {\r\n                    res[a][b] += (left[a][c] * right[c][b]) % MOD;\r\n                    if (res[a][b] >= MOD)\r\n                        res[a][b] -= MOD;\r\n                }\r\n        return res;\r\n    }\r\n\r\n    public static long[][] power(long[][] grid, long pow) {\r\n        long[][] res = new long[grid.length][grid[0].length];\r\n        for (int i = 0; i < res.length; i++)\r\n            res[i][i] = 1L;\r\n        long[][] curr = grid.clone();\r\n        while (pow > 0) {\r\n            if ((pow & 1L) == 1L)\r\n                res = multiply(curr, res);\r\n            pow >>= 1;\r\n            curr = multiply(curr, curr);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\nclass SegTree {\r\n    int N;\r\n    int[] tree;\r\n\r\n    SegTree(int[] ar) {\r\n        N = 1;\r\n        while (N < ar.length) {\r\n            N <<= 1;\r\n        }\r\n\r\n        tree = new int[(N << 1) - 1];\r\n        \r\n        for (int n = 0; n < ar.length; ++n) {\r\n            tree[n + N - 1] = ar[n];\r\n        }\r\n        \r\n        for (int n = tree.length - 1; n > 0; --n) {\r\n            tree[(n - 1) >> 1] = Math.max(tree[(n - 1) >> 1], tree[n]);\r\n        }\r\n    }\r\n\r\n    int rangeQuery(int n, int l, int r, int ql, int qr) {\r\n        int mid = (l + r) >> 1, i2 = n << 1;\r\n        if (l > qr || r < ql)\r\n            return -7;\r\n        else if (l >= ql && r <= qr)\r\n            return tree[n];\r\n        else\r\n            return Math.max(rangeQuery(i2 + 1, l, mid, ql, qr), rangeQuery(i2 + 2, mid + 1, r, ql, qr));\r\n    }\r\n}\r\n\r\nclass SegmentTree {\r\n    // iterative implementation = low constant runtime factor\r\n    // range query, non lazy\r\n    final int[] val;\r\n    final int treeFrom;\r\n    final int length;\r\n\r\n    public SegmentTree(int treeFrom, int treeTo) {\r\n        this.treeFrom = treeFrom;\r\n        int length = treeTo - treeFrom + 1;\r\n        int l;\r\n        for (l = 0; (1 << l) < length; l++)\r\n            ;\r\n        val = new int[1 << (l + 1)];\r\n        this.length = 1 << l;\r\n    }\r\n\r\n    public void update(int index, int delta) {\r\n        // replaces value\r\n        int node = index - treeFrom + length;\r\n        val[node] = delta;\r\n        for (node >>= 1; node > 0; node >>= 1)\r\n            val[node] = comb(val[node << 1], val[(node << 1) + 1]);\r\n    }\r\n\r\n    public int query(int from, int to) {\r\n        // inclusive bounds\r\n        if (to < from)\r\n            return 0; // 0 or 1?\r\n        from += length - treeFrom;\r\n        to += length - treeFrom + 1;\r\n        // 0 or 1?\r\n        int res = 0;\r\n        for (; from + (from & -from) <= to; from += from & -from)\r\n            res = comb(res, val[from / (from & -from)]);\r\n        for (; to - (to & -to) >= from; to -= to & -to)\r\n            res = comb(res, val[(to - (to & -to)) / (to & -to)]);\r\n        return res;\r\n    }\r\n\r\n    public int comb(int a, int b) {\r\n        // change this\r\n        return Math.max(a, b);\r\n    }\r\n}\r\n\r\nclass LazySegTree {\r\n    // definitions\r\n    private int NULL = -1;\r\n    private int[] tree;\r\n    private int[] lazy;\r\n    private int length;\r\n\r\n    public LazySegTree(int N) {\r\n        length = N;\r\n        int b;\r\n        for (b = 0; (1 << b) < length; b++)\r\n            ;\r\n        tree = new int[1 << (b + 1)];\r\n        lazy = new int[1 << (b + 1)];\r\n    }\r\n\r\n    public int query(int left, int right) {\r\n        // left and right are 0-indexed\r\n        return get(1, 0, length - 1, left, right);\r\n    }\r\n\r\n    private int get(int v, int currL, int currR, int L, int R) {\r\n        if (L > R)\r\n            return NULL;\r\n        if (L <= currL && currR <= R)\r\n            return tree[v];\r\n        propagate(v);\r\n        int mid = (currL + currR) / 2;\r\n        return comb(get(v * 2, currL, mid, L, Math.min(R, mid)),\r\n                get(v * 2 + 1, mid + 1, currR, Math.max(L, mid + 1), R));\r\n    }\r\n\r\n    public void update(int left, int right, int delta) {\r\n        add(1, 0, length - 1, left, right, delta);\r\n    }\r\n\r\n    private void add(int v, int currL, int currR, int L, int R, int delta) {\r\n        if (L > R)\r\n            return;\r\n        if (currL == L && currR == R) {\r\n            // exact covering\r\n            tree[v] += delta;\r\n            lazy[v] += delta;\r\n            return;\r\n        }\r\n        propagate(v);\r\n        int mid = (currL + currR) / 2;\r\n        add(v * 2, currL, mid, L, Math.min(R, mid), delta);\r\n        add(v * 2 + 1, mid + 1, currR, Math.max(L, mid + 1), R, delta);\r\n        tree[v] = comb(tree[v * 2], tree[v * 2 + 1]);\r\n    }\r\n\r\n    private void propagate(int v) {\r\n        // tree[v] already has lazy[v]\r\n        if (lazy[v] == 0)\r\n            return;\r\n        tree[v * 2] += lazy[v];\r\n        lazy[v * 2] += lazy[v];\r\n        tree[v * 2 + 1] += lazy[v];\r\n        lazy[v * 2 + 1] += lazy[v];\r\n        lazy[v] = 0;\r\n    }\r\n\r\n    private int comb(int a, int b) {\r\n        return Math.max(a, b);\r\n    }\r\n}\r\n\r\nclass RangeBit {\r\n    // FenwickTree and RangeBit are faster than LazySegTree by constant factor\r\n    final int[] value;\r\n    final int[] weightedVal;\r\n\r\n    public RangeBit(int treeTo) {\r\n        value = new int[treeTo + 2];\r\n        weightedVal = new int[treeTo + 2];\r\n    }\r\n\r\n    private void updateHelper(int index, int delta) {\r\n        int weightedDelta = index * delta;\r\n        for (int j = index; j < value.length; j += j & -j) {\r\n            value[j] += delta;\r\n            weightedVal[j] += weightedDelta;\r\n        }\r\n    }\r\n\r\n    public void update(int from, int to, int delta) {\r\n        updateHelper(from, delta);\r\n        updateHelper(to + 1, -delta);\r\n    }\r\n\r\n    private int query(int to) {\r\n        int res = 0;\r\n        int weightedRes = 0;\r\n        for (int j = to; j > 0; j -= j & -j) {\r\n            res += value[j];\r\n            weightedRes += weightedVal[j];\r\n        }\r\n        return ((to + 1) * res) - weightedRes;\r\n    }\r\n\r\n    public int query(int from, int to) {\r\n        if (to < from)\r\n            return 0;\r\n        return query(to) - query(from - 1);\r\n    }\r\n}\r\n\r\nclass IO {\r\n    // I don't understand how this works lmao\r\n    private int BS = 1 << 16;\r\n    private char NC = (char) 0;\r\n    private byte[] buf = new byte[BS];\r\n    private int bId = 0, size = 0;\r\n    private char c = NC;\r\n    private double cnt = 1;\r\n    private BufferedInputStream in;\r\n\r\n    public IO() {\r\n        in = new BufferedInputStream(System.in, BS);\r\n    }\r\n\r\n    public IO(String s) {\r\n        try {\r\n            in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\r\n        } catch (Exception e) {\r\n            in = new BufferedInputStream(System.in, BS);\r\n        }\r\n    }\r\n\r\n    private char getChar() {\r\n        while (bId == size) {\r\n            try {\r\n                size = in.read(buf);\r\n            } catch (Exception e) {\r\n                return NC;\r\n            }\r\n            if (size == -1)\r\n                return NC;\r\n            bId = 0;\r\n        }\r\n        return (char) buf[bId++];\r\n    }\r\n\r\n    public int nextInt() {\r\n        return (int) nextLong();\r\n    }\r\n\r\n    public int[] nextInts(int N) {\r\n        int[] res = new int[N];\r\n        for (int i = 0; i < N; i++) {\r\n            res[i] = (int) nextLong();\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public long[] nextLongs(int N) {\r\n        long[] res = new long[N];\r\n        for (int i = 0; i < N; i++) {\r\n            res[i] = nextLong();\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public long nextLong() {\r\n        cnt = 1;\r\n        boolean neg = false;\r\n        if (c == NC)\r\n            c = getChar();\r\n        for (; (c < '0' || c > '9'); c = getChar()) {\r\n            if (c == '-')\r\n                neg = true;\r\n        }\r\n        long res = 0;\r\n        for (; c >= '0' && c <= '9'; c = getChar()) {\r\n            res = (res << 3) + (res << 1) + c - '0';\r\n            cnt *= 10;\r\n        }\r\n        return neg ? -res : res;\r\n    }\r\n\r\n    public double nextDouble() {\r\n        double cur = nextLong();\r\n        return c != '.' ? cur : cur + nextLong() / cnt;\r\n    }\r\n\r\n    public double[] nextDoubles(int N) {\r\n        double[] res = new double[N];\r\n        for (int i = 0; i < N; i++) {\r\n            res[i] = nextDouble();\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public String next() {\r\n        StringBuilder res = new StringBuilder();\r\n        while (c <= 32)\r\n            c = getChar();\r\n        while (c > 32) {\r\n            res.append(c);\r\n            c = getChar();\r\n        }\r\n        return res.toString();\r\n    }\r\n\r\n    public String nextLine() {\r\n        StringBuilder res = new StringBuilder();\r\n        while (c <= 32)\r\n            c = getChar();\r\n        while (c != '\\n') {\r\n            res.append(c);\r\n            c = getChar();\r\n        }\r\n        return res.toString();\r\n    }\r\n\r\n    public boolean hasNext() {\r\n        if (c > 32)\r\n            return true;\r\n        while (true) {\r\n            c = getChar();\r\n            if (c == NC)\r\n                return false;\r\n            else if (c > 32)\r\n                return true;\r\n        }\r\n    }\r\n}"
}