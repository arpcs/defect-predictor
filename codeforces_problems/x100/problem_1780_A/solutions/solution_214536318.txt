{
    "id": 214536318,
    "contestId": 1780,
    "creationTimeSeconds": 1689798283,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1780,
        "index": "A",
        "name": "Hayato and School",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1780,
        "members": [
            {
                "handle": "bipro_coder100"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1674657300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 12,
    "timeConsumedMillis": 139,
    "memoryConsumedBytes": 0,
    "source": "#pragma GCC optimize(\"O3\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long int\r\n//bool prime[1000005];\r\n//vector<int> fact(15);\r\n#define INF 1e9;\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr<< #x <<\"= \"; _print(x);cerr<<endl;\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\n#define reverse(v) reverse(v.begin(),v.end());\r\n#define ascending(v) sort(v.begin(),v.end());\r\n#define descending(v) sort(v.rbegin(),v.rend());\r\nvoid _print(string a) {cerr << a;} void _print(int a) {cerr << a;} void _print(char a) {cerr << a;}\r\nvoid _print(bool a) {cerr << a;} void _print(double a) {cerr << a;} void _print(float a) {cerr << a;}\r\ntemplate<class T, class V> void _print(unordered_map<T, V> m)\r\n{\r\n    cerr << \"\\n\";\r\n    for (auto &pr : m)\r\n    {\r\n        cerr << pr.first << \"->\";\r\n        cerr << pr.second << \"\\n\";\r\n    }\r\n}\r\ntemplate<class T, class V> void _print(map<T, vector<V>> m)\r\n{\r\n    cerr << \"\\n\";\r\n    for (auto &pr : m)\r\n    {\r\n        cerr << pr.first << \"->\";\r\n        for (auto i : pr.second)\r\n        {\r\n            _print(i);\r\n            cerr << \" \";\r\n        }\r\n        cerr << \"\\n\";\r\n    }\r\n}\r\n\r\ntemplate<class T, class V> void _print(map<T, set<V>> m)\r\n{\r\n    cerr << \"\\n\";\r\n    for (auto &pr : m)\r\n    {\r\n        cerr << pr.first << \"->\";\r\n        for (auto i : pr.second)\r\n        {\r\n            _print(i);\r\n            cerr << \" \";\r\n        }\r\n        cerr << \"\\n\";\r\n    }\r\n}\r\n\r\ntemplate<class T, class V> void _print(map<T, V> m)\r\n{\r\n    cerr << \"\\n\";\r\n    for (auto &pr : m)\r\n    {\r\n        _print(pr.first);\r\n        cerr << \"->\";\r\n        _print(pr.second);\r\n        cerr << \"\\n\";\r\n    }\r\n}\r\ntemplate<class T> void _print(vector<T> v1)\r\n{\r\n    cerr << \"[\";\r\n    for (T i : v1)\r\n    {\r\n        _print(i);\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\ntemplate<class T, class V> void _print(vector<pair<T, V>> v1)\r\n{\r\n    cerr << \"[\";\r\n    for (auto &pr : v1)\r\n    {\r\n        cerr << \"{\";\r\n        _print(pr.first);\r\n        cerr << \" \";\r\n        _print(pr.second);\r\n        cerr << \"}\";\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\n\r\ntemplate<class T> void _print(vector<vector<T>> v1)\r\n{\r\n    cerr << \"\\n\";\r\n    for (auto &vec : v1)\r\n    {\r\n        for (T i : vec)\r\n        {\r\n            _print(i);\r\n            cerr << \" \";\r\n        }\r\n        cerr << \"\\n\";\r\n    }\r\n}\r\n\r\ntemplate<class T, class V> void _print(vector<vector<pair<T, V>>> v1)\r\n{\r\n    cerr << \"\\n\";\r\n    for (auto &vec : v1)\r\n    {\r\n        for (auto i : vec)\r\n        {\r\n            cerr << \"{\";\r\n            _print(i.first);\r\n            cerr << \",\";\r\n            _print(i.second);\r\n            cerr << \"} \";\r\n        }\r\n        cerr << \"\\n\";\r\n    }\r\n}\r\ntemplate<class T> void _print(vector<set<T>> v1)\r\n{\r\n    for (auto &vec : v1)\r\n    {\r\n        for (T i : vec)\r\n        {\r\n            _print(i);\r\n            cerr << \" \";\r\n        }\r\n        cerr << \"\\n\";\r\n    }\r\n}\r\ntemplate<class T> void _print(set<T> s1)\r\n{\r\n    cerr << \"[\";\r\n    for (T i : s1)\r\n    {\r\n        _print(i);\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\ntemplate<class T> void _print(multiset<T> s1)\r\n{\r\n    cerr << \"[\";\r\n    for (T i : s1)\r\n    {\r\n        _print(i);\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\ntemplate<class T> void _print(queue<T> q1)\r\n{\r\n    cerr << \"[\";\r\n    while (!q1.empty())\r\n    {\r\n        T i = q1.front();\r\n        q1.pop();\r\n        cerr << i;\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\ntemplate<class T, class V> void _print(queue<pair<T, V>> q1)\r\n{\r\n    cerr << \"[\";\r\n    while (!q1.empty())\r\n    {\r\n        T i = q1.front().first;\r\n        V j = q1.front().second;\r\n        q1.pop();\r\n        cerr << \"{\";\r\n        cerr << i;\r\n        cerr << \",\";\r\n        cerr << j;\r\n        cerr << \"}\";\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\ntemplate<class T> void _print(stack<T> st1)\r\n{\r\n    cerr << \"[\";\r\n    while (!st1.empty())\r\n    {\r\n        _print(st1.top());\r\n        st1.pop();\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\ntemplate<class T> void _print(list<T> lis1)\r\n{\r\n    cerr << \"[\";\r\n    for (T i : lis1)\r\n    {\r\n        _print(i);\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\ntemplate<class T> void _print(deque<T> lis1)\r\n{\r\n    cerr << \"[\";\r\n    for (T i : lis1)\r\n    {\r\n        _print(i);\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\ntemplate<class T, class V> void _print(deque<pair<T, V>> lis1)\r\n{\r\n    cerr << \"[\";\r\n    for (auto i : lis1)\r\n    {\r\n        cerr << \"{\";\r\n        _print(i.first);\r\n        cerr << \" \";\r\n        _print(i.second);\r\n        cerr << \"}\";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\ntemplate<class T> void _print(priority_queue<T> pq1)\r\n{\r\n    cerr << \"[\";\r\n    while (!pq1.empty())\r\n    {\r\n        _print(pq1.top());\r\n        pq1.pop();\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\n\r\ntemplate<class T> void _print(priority_queue<T, vector<T>, greater<T>> pq1)\r\n{\r\n    cerr << \"[\";\r\n    while (!pq1.empty())\r\n    {\r\n        _print(pq1.top());\r\n        pq1.pop();\r\n        cerr << \" \";\r\n    }\r\n    cerr << \"]\";\r\n}\r\n\r\ntemplate<class T, class V> void _print(pair<T, V> p)\r\n{\r\n    cerr << \"[\";\r\n    _print(p.first);\r\n    cerr << \",\";\r\n    _print(p.second);\r\n    cerr << \"]\";\r\n}\r\nint moduloMultiplication(int a, int b,\r\n                         int  mod)\r\n{\r\n\r\n    // Initialize result\r\n    int  res = 0;\r\n\r\n    // Update a if it is more than\r\n    // or equal to mod\r\n    a %= mod;\r\n\r\n    while (b) {\r\n\r\n        // If b is odd, add a with result\r\n        if (b & 1)\r\n            res = (res + a) % mod;\r\n\r\n        // Here we assume that doing 2*a\r\n        // doesn't cause overflow\r\n        a = (2 * a) % mod;\r\n        b >>= 1; // b = b / 2\r\n    }\r\n    return res;\r\n}\r\nint modpower(int x, int y, int p)\r\n{\r\n    int res = 1;     // Initialize result\r\n\r\n    x = x % p; // Update x if it is more than or\r\n    // equal to p\r\n\r\n    if (x == 0) return 0; // In case x is divisible by p;\r\n\r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result\r\n        if (y & 1)\r\n            res = (res * x) % p;\r\n\r\n        // y must be even now\r\n        y = y >> 1; // y = y/2\r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\nint power(int x, int y)\r\n{\r\n    int res = 1;     // Initialize result\r\n\r\n    if (x == 0) return 0; // In case x is divisible by p;\r\n\r\n    while (y > 0)\r\n    {\r\n        if (y & 1)\r\n            res = (res * x);\r\n\r\n        // y must be even now\r\n        y = y >> 1; // y = y/2\r\n        x = (x * x);\r\n    }\r\n    return res;\r\n}\r\n// C++ function for extended Euclidean Algorithm\r\nint gcdExtended(int a, int b,\r\n                int* x,\r\n                int* y);\r\n\r\n// Function to find modulo inverse of b. It returns\r\n// -1 when inverse doesn't exists\r\nint modInverse( int b,  int m)\r\n{\r\n\r\n    int x, y; // used in extended GCD algorithm\r\n    int g = gcdExtended(b, m, &x, &y);\r\n\r\n    // Return -1 if b and m are not co-prime\r\n    if (g != 1)\r\n        return -1;\r\n\r\n    // m is added to handle negative x\r\n    return (x % m + m) % m;\r\n}\r\n\r\n// C function for extended Euclidean Algorithm (used to\r\n// find modular inverse.\r\nint gcdExtended(int a, int b,\r\n                int* x,\r\n                int* y)\r\n{\r\n\r\n    // Base Case\r\n    if (a == 0) {\r\n        *x = 0, *y = 1;\r\n        return b;\r\n    }\r\n\r\n    // To store results of recursive call\r\n    int x1, y1;\r\n\r\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\r\n\r\n    // Update x and y using results of recursive\r\n    // call\r\n    *x = y1 - (b / a) * x1;\r\n    *y = x1;\r\n    return gcd;\r\n}\r\n\r\n// Function to compute a/b under modlo m\r\nint modDivide( int a,  int b,\r\n               int m)\r\n{\r\n\r\n    a = a % m;\r\n    int inv = modInverse(b, m);\r\n    if (inv == -1)\r\n        // cout << \"Division not defined\";\r\n        return 0;\r\n    else\r\n        return (inv * a) % m;\r\n}\r\n\r\n// Function to calculate nCr % p\r\n// int nCr(int n, int r, int p)\r\n// {\r\n//     int calc1 = fact[n];\r\n//     int calc2 = ((fact[n - r] % p) * (fact[r] % p)) % p;\r\n\r\n//     return modDivide(calc1, calc2, p);\r\n// }\r\n\r\n// void SieveOfEratosthenes(int n)\r\n// {\r\n//     // Create a boolean array\r\n//     // \"prime[0..n]\" and initialize\r\n//     // all entries it as true.\r\n//     // A value in prime[i] will\r\n//     // finally be false if i is\r\n//     // Not a prime, else true.\r\n//     memset(prime, true, sizeof(prime));\r\n\r\n//     for (int p = 2; p * p <= n; p++)\r\n//     {\r\n//         // If prime[p] is not changed,\r\n//         // then it is a prime\r\n//         if (prime[p] == true)\r\n//         {\r\n//             // Update all multiples\r\n//             // of p greater than or\r\n//             // equal to the square of it\r\n//             // numbers which are multiple\r\n//             // of p and are less than p^2\r\n//             // are already been marked.\r\n//             for (int i = p * p; i <= n; i += p)\r\n//                 prime[i] = false;\r\n//         }\r\n//     }\r\n// }\r\nint binarySearch(int arr[], int l, int r, int x)\r\n{\r\n    if (r >= l) {\r\n        int mid = l + (r - l) / 2;\r\n\r\n        // If the element is present at the middle\r\n        // itself\r\n        if (arr[mid] == x)\r\n            return mid;\r\n\r\n        // If element is smaller than mid, then\r\n        // it can only be present in left subarray\r\n        if (arr[mid] > x)\r\n            return binarySearch(arr, l, mid - 1, x);\r\n\r\n        // Else the element can only be present\r\n        // in right subarray\r\n        return binarySearch(arr, mid + 1, r, x);\r\n    }\r\n\r\n    // We reach here when element is not\r\n    // present in array\r\n    return -1;\r\n}\r\n// void factorial(int p)\r\n// {\r\n//     fact[0] = 1;\r\n//     fact[1] = 1;\r\n//     for (int i = 2; i < fact.size(); i++)\r\n//     {\r\n//         fact[i] = (i * fact[i - 1]) % p;\r\n//     }\r\n// }\r\nint gcd(int a, int b)\r\n{\r\n    // Everything divides 0\r\n    if (a == 0)\r\n        return b;\r\n    if (b == 0)\r\n        return a;\r\n\r\n    // base case\r\n    if (a == b)\r\n        return a;\r\n\r\n    // a is greater\r\n    if (a > b)\r\n        return gcd(a - b, b);\r\n    return gcd(a, b - a);\r\n}\r\nint ceil(int a, int x)\r\n{\r\n    if (a % x == 0)\r\n        return a / x;\r\n    else\r\n        return a / x + 1;\r\n}\r\nint countBits(int n)\r\n{\r\n    int count = 0;\r\n    while (n)\r\n    {\r\n        count++;\r\n        n >>= 1;\r\n    }\r\n    return count;\r\n}\r\nbool isPower(int x, int y)\r\n{\r\n    int res1 = log2(y) / log2(x);\r\n    double res2 = log2(y) / log2(x);\r\n\r\n    // compare to the result1 or result2 both are equal\r\n    return (res1 == res2);\r\n}\r\nbool isPerfectSquare(int x)\r\n{\r\n    // Find floating point value of\r\n    // square root of x.\r\n    if (x >= 0) {\r\n\r\n        int sr = sqrt(x);\r\n\r\n        // if product of square root\r\n        //is equal, then\r\n        // return T/F\r\n        return (sr * sr == x);\r\n    }\r\n    // else return false if n<0\r\n    return false;\r\n}\r\n//--------------------------------------------------------------------------------------------------------------------------------------------\r\nconst int mod = 998244353;\r\nconst int M = 1e9 + 7;\r\nconst int inf = 1e18;\r\n\r\n\r\n// bool helper(int l1, int r1, int l2, int r2, vector<vector<int>> &prefix)\r\n// {\r\n\r\n// }\r\n\r\n\r\nvoid solve()\r\n{\r\n    int n;\r\n    cin >> n;\r\n\r\n    vector<int> odd, even;\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        int x;\r\n        cin >> x;\r\n        if (x % 2)\r\n            odd.push_back(i);\r\n        else\r\n            even.push_back(i);\r\n    }\r\n\r\n    if (odd.size() >= 3)\r\n    {\r\n        cout << \"YES\" << \"\\n\";\r\n        cout << odd[0] + 1 << \" \" << odd[1] + 1 << \" \" << odd[2] + 1 << \"\\n\";\r\n        return;\r\n    }\r\n    else if (even.size() >= 2 && odd.size() >= 1)\r\n    {\r\n        cout << \"YES\" << \"\\n\";\r\n        cout << even[0] + 1 << \" \" << even[1] + 1 << \" \" << odd[0] + 1 << \"\\n\";\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        cout << \"NO\" << \"\\n\";\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n    freopen(\"Error2.txt\", \"w\", stderr);\r\n#endif//ONLINE_JUDGE\r\n    int T = 1;\r\n    cin >> T;\r\n    int t = 1;\r\n    //SieveOfEratosthenes(1000005);\r\n    // debug(primes);\r\n    //cout << (char)('z' - 25) << \"\\n\";\r\n    //factorial(inf);\r\n    //debug(fact);\r\n\r\n    //generatePrimeFactors();\r\n    while (T--)\r\n    {\r\n        //debug(T)\r\n        cerr << T << \"____________________________________\" << \"\\n\";\r\n        //cout << \"Case #\" << t << \": \";\r\n        solve();\r\n        t++;\r\n    }\r\n\r\n}"
}