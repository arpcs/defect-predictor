{
    "id": 192231416,
    "contestId": 1780,
    "creationTimeSeconds": 1675573826,
    "relativeTimeSeconds": 1466,
    "problem": {
        "contestId": 1780,
        "index": "A",
        "name": "Hayato and School",
        "type": "PROGRAMMING",
        "points": 500.0,
        "rating": 800,
        "tags": [
            "constructive algorithms",
            "greedy"
        ]
    },
    "author": {
        "contestId": 1780,
        "members": [
            {
                "handle": "SrvstvRajat"
            }
        ],
        "participantType": "VIRTUAL",
        "ghost": false,
        "startTimeSeconds": 1675572360
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 12,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 0,
    "source": "#include<bits/stdc++.h>\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n#define MOD 1000000007\r\n#define FASITO ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)\r\n#define pb(x) push_back(x)\r\n#define nl \"\\n\"\r\n#define sz size\r\n#define ff first\r\n#define ss second\r\n#define mp make_pair\r\n#define all(x) x.begin(),x.end()\r\n#define rep(i,a,b) for(ll i=a;i<b;i++)\r\n#define pii pair<ll , ll>\r\n#define all(x) x.begin(),x.end()\r\n#define rall(x) x.rbegin(),x.rend()\r\n#define ump unordered_map\r\n#define bipc   __builtin_popcount\r\n#define bipcll   __builtin_popcountll   //set bits of no.\r\nusing namespace std;\r\nusing namespace chrono;\r\n\r\n\r\nvoid init()\r\n{\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"inputf.txt\", \"r\", stdin);\r\n    freopen(\"outputf.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nvoid error() {\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"error.txt\", \"w\", stderr);\r\n#endif\r\n}\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr << #x <<\" = \"; _print(x); cerr << endl;\r\n#else\r\n#define debug(x);\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\nvoid google(int t) {cout << \"Case #\" << t << \": \";}\r\n\r\nstring upper(string s)\r\n{\r\n    transform(s.begin(), s.end(), s.begin(), ::toupper);\r\n    return s;\r\n}\r\n\r\nbool isPrime(int n)\r\n{\r\n    if (n <= 1)\r\n        return false;\r\n    if (n <= 3)\r\n        return true;\r\n    if (n % 2 == 0 || n % 3 == 0)\r\n        return false;\r\n    for (int i = 5; i * i <= n; i = i + 6)\r\n        if (n % i == 0 || n % (i + 2) == 0)\r\n            return false;\r\n    return true;\r\n}\r\n/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\nll round_up(ll a, ll b) {return (a + b - 1) / b;} //  round_up(a/b)\r\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\r\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\r\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\r\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\r\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\r\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\r\n\r\n\r\n/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\nbool cmp(const pair<int, int> &a, const pair<int, int> &b) { return (a.second < b.second);}\r\nll modInverse(ll a, ll m) {ll m0 = m; ll y = 0, x = 1; if (m == 1)return 0; while (a > 1) { ll q = a / m; ll t = m; m = a % m, a = t; t = y; y = x - q * y; x = t;} if (x < 0)x += m0; return x;}\r\nvector<ll> sieve(ll n) {ll*arr = new ll[n + 1](); vector<ll> vect; for (ll i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\r\nset<ll> primeFactors(ll n) {set<ll> s; while (n % 2 == 0) { s.insert(2); n = n / 2; } for (ll i = 3; i <= sqrt(n); i = i + 2) {  while (n % i == 0) {s.insert(i); n = n / i; } } if (n > 2) s.insert(n); return s;}\r\nll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))\r\nvoid sort(string &s) { sort(s.begin(), s.end()); }\r\nbool comp(pair<pair<int, int>, int> &a, pair<pair<int, int>, int>&b) {return a.ss < b.ss;}\r\nbool isPalindrome(string S) {for (ll i = 0; i < S.length() / 2; i++) {if (S[i] != S[S.length() - i - 1]) {return false;}} return true;}\r\nll msb(ll n) {return 64 - __builtin_clzll(n);}\r\nll lsb(ll n) {return __builtin_ctz(n) + 1;}\r\nvector<ll>fact; void computefact(ll n, ll m) {fact.resize(n + 1); fact[0] = 1; for (ll i = 1; i <= n; i++) {fact[i] = (fact[i - 1] * i) % m;}}\r\nll ncr(ll n, ll r, ll m) {if (n < r)return 0; if (r == 0)return 1; return fact[n] * modInverse(fact[r], m) % m * modInverse(fact[n - r], m) % m;}\r\n\r\n/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\nll binMultiply(ll a, ll b)\r\n{\r\n    ll ans = 0;\r\n    while (b)\r\n    {\r\n        if (b & 1)\r\n            ans = (ans + a) % MOD;\r\n        a = (a + a) % MOD;\r\n        b >>= 1;\r\n    }\r\n    return ans ;\r\n}\r\nll binExpo(ll a, ll b)\r\n{\r\n    ll ans = 1;\r\n    while (b)\r\n    {\r\n        if (b & 1)\r\n            ans = binMultiply(ans, a);\r\n        a = binMultiply(a, a);\r\n        b = b >> 1;\r\n    }\r\n    return ans ;\r\n}\r\n\r\nvoid bin(string& x, unsigned n)\r\n{\r\n    if (n > 1)\r\n        bin(x, n / 2);\r\n    if (n % 2)\r\n        x = x + \"1\";\r\n    else\r\n        x = x + \"0\";\r\n}\r\n/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\n/*Tree*/\r\nclass Tree\r\n{\r\npublic:\r\n    char val;\r\n    Tree *left;\r\n    Tree *right;\r\n    Tree(int r)\r\n    {\r\n        this->val = r;\r\n        left = NULL;\r\n        right = NULL;\r\n    }\r\n};\r\n\r\nvoid print(Tree *root)\r\n{\r\n    if (root == NULL)\r\n        return ;\r\n    cout << root->val << \" \";\r\n    if (root->left)\r\n        print(root->left);\r\n    if (root->right)\r\n        print(root->right);\r\n}\r\n/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\nstruct SegmentTree\r\n{\r\n    ll N;\r\n    vector<ll> tree;\r\n    void init(ll n) {\r\n        N = n;\r\n        tree.assign(2 * N + 1, 0); //initialising vector tree with size n +1\r\n    }\r\n    void init(vector<ll>&v) {\r\n        N = v.size();\r\n        tree.assign(2 * N + 1, 0); //initialising vector tree with size n +1\r\n        for (ll i = N; i < 2 * N; i++) {\r\n            tree[i] = v[i - N];\r\n        }\r\n    }\r\n    void build() {\r\n        //size is 2*n so we have filled from n to 2n-1\r\n        for (ll i = N - 1; i >= 1; i--) {\r\n            //if i is parent then it's left child is 2*i and it's right child is 2*i+1\r\n            tree[i] = (tree[2 * i] + tree[2 * i + 1]);\r\n        }\r\n    }\r\n    ll query(ll l, ll r)\r\n    {\r\n        l += N;\r\n        r += N;\r\n        ll sum = 0;\r\n        while (l <= r)\r\n        {\r\n            if (l & 1)\r\n            {\r\n                sum = (sum + tree[l]);\r\n                l++;\r\n            }\r\n            if (!(r & 1))\r\n            {\r\n                sum = ( sum + tree[r]);\r\n                r--;\r\n            }\r\n            l = l >> 1; //l=l/2;\r\n            r = r >> 1; //r=r/2;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    void update(ll in, ll value)\r\n    {\r\n        in += N;\r\n        tree[in] = value;\r\n        //for root in=1\r\n        while (in > 1)\r\n        {\r\n            in = in >> 1; //in=in/2;\r\n            //in=1\r\n            tree[in] = tree[in * 2] + tree[in * 2 + 1];\r\n        }\r\n        return;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nint findParent(int src, int parent[])\r\n{\r\n    if (src == parent[src])\r\n        return src;\r\n    return parent[src] = findParent(parent[src], parent);\r\n}\r\n\r\n\r\n\r\nvoid rec(stack<int> &s, stack<int> &d)\r\n{\r\n    if (s.size() == 0)\r\n        return ;\r\n    int k = s.top();\r\n    s.pop();\r\n    rec(s, d);\r\n    d.push(k);\r\n}\r\n\r\n\r\n\r\nint query(int s, int e)\r\n{\r\n    cout << \"? \" << s << \" \" << e << endl;\r\n    int k;\r\n    cin >> k;\r\n    cout << endl;\r\n    return k;\r\n}\r\n\r\n\r\nll rec(ll &k)\r\n{\r\n    if (k >= 0 && k <= 9)\r\n        return k;\r\n    else\r\n    {\r\n        ll ans = 0;\r\n        while (k > 0)\r\n        {\r\n            ans += k % 10;\r\n            k /= 10;\r\n        }\r\n        // cout << ans << nl;\r\n        return (ans);\r\n    }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    init();\r\n    error();\r\n    FASITO;\r\n    ll t = 1;\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n        ll n;\r\n        cin >> n;\r\n        ll a[n];\r\n        ll o = 0, e = 0;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            cin >> a[i];\r\n            if (a[i] & 1)\r\n                o++;\r\n            else\r\n                e++;\r\n        }\r\n        if (e == n || (e == 1 && o == 2))\r\n            cout << \"NO\" << nl;\r\n        else\r\n        {\r\n            cout << \"Yes\" << nl;\r\n            if (o >= 3)\r\n            {\r\n                ll k = 0;\r\n                for (int i = 0; i < n; i++)\r\n                {\r\n                    if (k == 3)\r\n                        break;\r\n                    if (a[i] & 1)\r\n                    {\r\n                        k++;\r\n                        cout << i + 1 << \" \";\r\n                    }\r\n                }\r\n                cout << nl;\r\n            }\r\n            else\r\n            {\r\n                ll aa = 0, b = 0;\r\n                for (int i = 0; i < n; i++)\r\n                {\r\n                    if (aa == 1 && b == 2)\r\n                        break;\r\n                    if (a[i] & 1 && aa < 1)\r\n                    {\r\n                        aa++;\r\n                        cout << i + 1 << \" \";\r\n                    }\r\n                    else if (!(a[i] & 1) && b < 2)\r\n                    {\r\n                        b++;\r\n                        cout << i + 1 << \" \";\r\n                    }\r\n                }\r\n                cout << nl;\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}