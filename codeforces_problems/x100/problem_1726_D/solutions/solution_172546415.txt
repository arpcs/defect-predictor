{
    "id": 172546415,
    "contestId": 1726,
    "creationTimeSeconds": 1663496671,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "D",
        "name": "Edge Split",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "probabilities",
            "trees"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "mocobeta"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "Rust 2021",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 2,
    "timeConsumedMillis": 764,
    "memoryConsumedBytes": 14028800,
    "source": "use std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::{\n    any::Any,\n    cmp,\n    collections::{BinaryHeap, HashMap, HashSet, VecDeque},\n    hash::Hash,\n    io::{self, BufWriter, Read, StdoutLock, Write},\n    str::Lines,\n};\n\n#[allow(unused_mut, unused_variables)]\nfn main() -> io::Result<()> {\n    let mut input = String::new();\n    io::stdin().lock().read_to_string(&mut input).unwrap();\n    let mut input = input.lines();\n\n    let out = io::stdout();\n    let mut out = BufWriter::new(out.lock());\n\n    let t = next_line_as_u64(&mut input);\n    for _ in 0..t {\n        // main loop\n        let line = next_line_as_u64_vec(&mut input);\n        let n = line[0] as usize;\n        let m = line[1] as usize;\n\n        let mut edges = Vec::<Edge>::new();\n        for _ in 0..m {\n            let line = next_line_as_u64_vec(&mut input);\n            let u = line[0];\n            let v = line[1];\n            edges.push(Edge::new(u, v, 1));\n        }\n\n        let graph = Graph::new_undirected(&edges);\n        let paths = graph.mst(edges[0].u);\n        let paths: HashSet<Edge> = paths.into_iter().collect();\n        let mut red_edges = Vec::<Edge>::new();\n        for path in paths.iter() {\n            let edge = Edge::new(path.u, path.v, path.cost);\n            if edges.contains(&edge) {\n                red_edges.push(edge);\n            } else {\n                let edge = Edge::new(path.v, path.u, path.cost);\n                red_edges.push(edge);\n            }\n        }\n\n        let mut blue_edges: Vec<Edge> = HashSet::<&Edge>::from_iter(edges.iter())\n            .difference(&HashSet::from_iter(red_edges.iter()))\n            .map(|&e| e.clone())\n            .collect();\n\n        //println!(\"Red edges = {:?}\", red_edges);\n        //println!(\"Blue edges = {:?}\", blue_edges);\n        //let graph2 = Graph::new_undirected(&blue_edges);\n        //let cycles = graph2.detect_cycle();\n        /*if !cycles.is_empty() {\n            //println!(\"Found cycle: {:?}\", cycles);\n            // can be optimized by removing cycle\n            let u = cycles[cycles.len() - 2];\n            let v = cycles[cycles.len() - 1];\n            // find edge that should be moved from blue to red\n            let p = blue_edges\n                .iter()\n                .position(|e| (e.u == u && e.v == v) || (e.v == u && e.u == v))\n                .unwrap();\n            let swap_edge1 = blue_edges.get(p).unwrap().clone();\n            blue_edges.remove(p);\n            red_edges.push(swap_edge1);\n            // find edge that should be moved from red to blue\n            let p = red_edges.iter().position(|e| e.u == v || e.u == v).unwrap();\n            let swap_edge2 = red_edges.get(p).unwrap().clone();\n            red_edges.remove(p);\n            blue_edges.push(swap_edge2);\n        }*/\n\n        let red_edges_set: HashSet<Edge> = red_edges.into_iter().collect();\n        let mut answer = String::new();\n        for edge in edges {\n            if red_edges_set.contains(&edge) {\n                answer.push('1');\n            } else {\n                answer.push('0');\n            }\n        }\n        write_answer(&answer, &mut out);\n    }\n\n    Ok(())\n}\n\npub type Vertex = u64;\n\n#[derive(PartialEq, Eq, Clone, Debug, Hash)]\npub struct Edge {\n    u: Vertex,\n    v: Vertex,\n    cost: u64,\n}\n\n#[allow(dead_code)]\nimpl Edge {\n    pub fn new(u: Vertex, v: Vertex, cost: u64) -> Self {\n        Edge { u, v, cost }\n    }\n}\nimpl PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.cost.partial_cmp(&other.cost)\n    }\n}\n\nimpl Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        other.partial_cmp(self).unwrap()\n    }\n}\n\n#[allow(dead_code)]\npub struct Graph {\n    edges: HashMap<Vertex, Vec<Edge>>,\n}\n\n#[allow(dead_code)]\nimpl Graph {\n    pub fn new_directed(all_edges: Vec<Edge>) -> Self {\n        let mut edges = HashMap::<Vertex, Vec<Edge>>::new();\n        for edge in all_edges {\n            edges.entry(edge.u).or_insert(vec![]).push(edge);\n        }\n        Graph { edges }\n    }\n\n    pub fn new_undirected(all_edges: &Vec<Edge>) -> Self {\n        let mut edges = HashMap::<Vertex, Vec<Edge>>::new();\n        for edge in all_edges {\n            edges.entry(edge.u).or_insert(vec![]).push(edge.clone());\n            edges\n                .entry(edge.v)\n                .or_insert(vec![])\n                .push(Edge::new(edge.v, edge.u, edge.cost));\n        }\n        Graph { edges }\n    }\n\n    pub fn mst(&self, start: Vertex) -> Vec<Edge> {\n        assert!(\n            self.edges.contains_key(&start),\n            \"Graph does not contain vertex {}\",\n            start\n        );\n\n        let graph_size = self.edges.len();\n        // initialize MST\n        let mut tree = HashSet::<Vertex>::new();\n        let mut costs = BinaryHeap::<Edge>::new();\n        let mut paths = Vec::<Edge>::new();\n\n        tree.insert(start);\n        if let Some(edges) = self.edges.get(&start) {\n            for edge in edges {\n                costs.push(edge.clone());\n            }\n        }\n\n        'outer: while tree.len() < graph_size && !costs.is_empty() {\n            let min_edge: Edge;\n            loop {\n                if let Some(edge) = costs.pop() {\n                    if tree.contains(&edge.u) && tree.contains(&edge.v) {\n                        // already visited\n                        continue;\n                    }\n                    min_edge = edge;\n                    break;\n                } else {\n                    break 'outer;\n                }\n            }\n            if !tree.contains(&min_edge.u) {\n                tree.insert(min_edge.u);\n                if let Some(edges) = self.edges.get(&min_edge.u) {\n                    for edge in edges {\n                        if tree.contains(&edge.v) {\n                            // already visited\n                            continue;\n                        }\n                        costs.push(edge.clone());\n                    }\n                }\n                paths.push(min_edge);\n            } else if !tree.contains(&min_edge.v) {\n                tree.insert(min_edge.v);\n                if let Some(edges) = self.edges.get(&min_edge.v) {\n                    for edge in edges {\n                        if tree.contains(&edge.v) {\n                            // already visited\n                            continue;\n                        }\n                        costs.push(edge.clone());\n                    }\n                }\n                paths.push(min_edge);\n            }\n        }\n        paths\n    }\n\n    pub fn detect_cycle(&self) -> Vec<u64> {\n        for (k, _) in self.edges.iter() {\n            let visited = vec![*k];\n            let cycle = self.detect_cycle_dfs(visited);\n            if !cycle.is_empty() {\n                return cycle;\n            }\n        }\n        return vec![];\n    }\n\n    fn detect_cycle_dfs(&self, visited: Vec<Vertex>) -> Vec<Vertex> {\n        assert!(!visited.is_empty());\n        if visited.len() == self.edges.len() {\n            return vec![];\n        }\n        let u = visited.last().unwrap();\n        for edges in self.edges.get(u) {\n            for edge in edges {\n                if visited.len() > 1 && edge.v == visited[visited.len() - 2] {\n                    // bakclink to the previous node\n                    continue;\n                }\n                let mut visited = visited.clone();\n                visited.push(edge.v);\n                if visited[0..visited.len() - 2].contains(&edge.v) {\n                    return visited;\n                } else {\n                    return self.detect_cycle_dfs(visited);\n                }\n            }\n        }\n        return vec![];\n    }\n}\n\n#[allow(dead_code)]\nfn next_line(input: &mut Lines) -> String {\n    input.next().unwrap().to_string()\n}\n\n#[allow(dead_code)]\nfn next_line_as_u64(input: &mut Lines) -> u64 {\n    let s = input.next().unwrap();\n    let n: u64 = s.parse().unwrap();\n    n\n}\n\n#[allow(dead_code)]\nfn next_line_as_i64(input: &mut Lines) -> i64 {\n    let s = input.next().unwrap();\n    let n: i64 = s.parse().unwrap();\n    n\n}\n\n#[allow(dead_code)]\nfn next_line_as_string_vec(input: &mut Lines) -> Vec<String> {\n    let s = input.next().unwrap();\n    let a = s.split(\" \").collect::<Vec<&str>>();\n    a.iter().map(|&s| s.to_string()).collect()\n}\n\n#[allow(dead_code)]\nfn next_line_as_char_vec(input: &mut Lines) -> Vec<char> {\n    let s = input.next().unwrap();\n    let a: Vec<char> = s.chars().collect();\n    a\n}\n\n#[allow(dead_code)]\nfn next_line_as_u64_vec(input: &mut Lines) -> Vec<u64> {\n    let s = input.next().unwrap();\n    let a: Vec<u64> = s.split(\" \").map(|s| s.parse().unwrap()).collect();\n    a\n}\n\n#[allow(dead_code)]\nfn next_line_as_i64_vec(input: &mut Lines) -> Vec<i64> {\n    let s = input.next().unwrap();\n    let a: Vec<i64> = s.split(\" \").map(|s| s.parse().unwrap()).collect();\n    a\n}\n\n#[allow(dead_code)]\nfn write_bool_answer(answer: bool, out: &mut BufWriter<StdoutLock>) {\n    if answer {\n        writeln!(out, \"yes\").unwrap();\n    } else {\n        writeln!(out, \"no\").unwrap();\n    }\n}\n\n#[allow(dead_code)]\nfn write_answer(answer: &dyn Any, out: &mut BufWriter<StdoutLock>) {\n    if let Some(v) = answer.downcast_ref::<String>() {\n        writeln!(out, \"{}\", v).unwrap();\n    } else if let Some(v) = answer.downcast_ref::<&str>() {\n        writeln!(out, \"{}\", v).unwrap();\n    } else if let Some(v) = answer.downcast_ref::<u64>() {\n        writeln!(out, \"{}\", v).unwrap();\n    } else if let Some(v) = answer.downcast_ref::<i64>() {\n        writeln!(out, \"{}\", v).unwrap();\n    } else if let Some(v) = answer.downcast_ref::<usize>() {\n        writeln!(out, \"{}\", v).unwrap();\n    } else if let Some(ary) = answer.downcast_ref::<Vec<String>>() {\n        writeln!(out, \"{}\", ary.join(\" \")).unwrap();\n    } else if let Some(ary) = answer.downcast_ref::<Vec<u64>>() {\n        if ary.len() > 0 {\n            for i in 0..ary.len() - 1 {\n                write!(out, \"{} \", ary[i]).unwrap();\n            }\n            writeln!(out, \"{}\", ary.last().unwrap()).unwrap();\n        }\n    } else if let Some(ary) = answer.downcast_ref::<Vec<i64>>() {\n        if ary.len() > 0 {\n            for i in 0..ary.len() - 1 {\n                write!(out, \"{} \", ary[i]).unwrap();\n            }\n            writeln!(out, \"{}\", ary.last().unwrap()).unwrap();\n        }\n    } else {\n        panic!(\"Not printable type: {:?}\", answer.type_id());\n    }\n}\n"
}