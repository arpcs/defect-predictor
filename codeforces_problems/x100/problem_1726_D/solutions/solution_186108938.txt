{
    "id": 186108938,
    "contestId": 1726,
    "creationTimeSeconds": 1671544032,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1726,
        "index": "D",
        "name": "Edge Split",
        "type": "PROGRAMMING",
        "points": 2000.0,
        "rating": 2000,
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "probabilities",
            "trees"
        ]
    },
    "author": {
        "contestId": 1726,
        "members": [
            {
                "handle": "kelvin_0179"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1662474900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 15,
    "memoryConsumedBytes": 5120000,
    "source": "#include <bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\n\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n// using namespace __gnu_pbds;\r\n#define MODS 100005\r\n#define MOD 1000000007\r\n#define all(x) (x).begin(), (x).end()\r\n#define ll long long\r\n#define ld long double\r\n#define bigint int64_t\r\n#define vll vector<ll>\r\n#define vpll vector<pair<ll,ll>>\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define pb push_back\r\n#define pf push_front\r\n#define pbb pop_back\r\n#define pff pop_front\r\n#define test ll t;read(t);while(t--)\r\n#define pll pair<ll,ll>\r\n#define vvll vector<vector<ll>>\r\n#define fst first\r\n#define scd second\r\n#define ins insert\r\n#define line \"\\n\"\r\n#define yes \"YES\"\r\n#define no \"NO\"\r\n#define arrlen(x) (ll)x.size()\r\n#define tup tuple<ll,ll,ll>\r\n\r\n#define debug1(x)  cerr << #x <<\"=\"<<x<<line;\r\n#define debug2(x,y)  cerr << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<line;\r\n#define debug3(x,y,z)cerr << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<line;\r\n#define debug4(x,y,z,a)cerr << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<\" \"<<#a<<\"=\"<<a<<line;\r\n#define forn(i,n) for(ll (i) = 0 ; (i) < (n) ; ++(i))\r\n#define for1(i,n) for(ll (i) = 1 ; (i) <= (n) ; ++(i))\r\n#define forr(i,n) for(ll (i) = (n)-1 ; (i)>=0 ; --(i))\r\n#define forab(i,a,b,c) for(ll (i) = a ; (i) <= (b) ; (i)+=(c))\r\n#define forba(i,b,a,c) for(ll (i) = b ; (i) >= (a) ; (i)+=(c))\r\n\r\n// #define pbds tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x)    cerr << #x <<\"=\"; _print(x); cerr << line;\r\n#else\r\n#define debug(x)\r\n#endif\r\n\r\nstruct myhash\r\n{\r\n    static uint64_t fxn(uint64_t x)\r\n    {\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n \r\n    size_t operator ()(uint64_t x) const\r\n    {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return fxn(x + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\ntemplate <typename T>                                           void read(T &x){cin >> x;}\r\ntemplate <typename T , typename T0>                             void read(T &x,T0 &y){cin >> x >> y;}\r\ntemplate <typename T , typename T0 , typename T1>               void read(T &x,T0 &y,T1 &z){cin >> x >> y >> z;}\r\ntemplate <typename T , typename T0 , typename T1 , typename T2> void read(T &x,T0 &y,T1 &z,T2 &w){cin >> x >> y >> z >> w;}\r\ntemplate <typename T , typename T0>                             void read(pair< T , T0 > &p){cin >> p.fst >>p.scd;}\r\ntemplate <typename T>                                           void read(vector< T > &oneD,ll n){forn(i,n){T x;read(x);oneD.push_back(x);}}\r\ntemplate <typename T>                                           void read(T oneD[] , ll n){for(ll i=0;i<n;i++){read(oneD[i]);}}\r\ntemplate <typename T>                                           void write(T x){cout << x << \" \";}\r\ntemplate <typename T>                                           void wrtline(T x){cout << x << line;}\r\ntemplate <typename T , typename T0>                             void write(T x,T0 y){cout << x << \" \" << y << \"\\n\";}\r\ntemplate <typename T , typename T0 , typename T1>               void write(T x,T0 y,T1 z){cout << x << \" \" << y << \" \" << z << \"\\n\";}\r\ntemplate <typename T , typename T0 , typename T1 , typename T2> void write(T x,T0 y,T1 z,T2 w){cout << x << \" \" << y << \" \" << z << \" \" << w << \"\\n\";}\r\ntemplate <typename T , typename T0>                             void write(pair< T , T0 > &p){write(p.fst);write(p.scd);cout << line;}\r\ntemplate <typename T>                                           void write(vector< T > &oneD,ll n){for(ll i=0;i<n;i++){cout<<oneD[i]<<\" \";}cout << line;}\r\ntemplate <typename T>                                           void write(T oneD[] ,int n){for(ll i=0;i<n;i++){write(oneD[i]);}cout <<line;}\r\ntemplate <typename T , typename T0>                             void write(map< T , T0 > &mpp){for(auto it : mpp){write(it.fst);cout << \": \";write(it.scd);cout << \"\\n\";}cout<<line;}\r\ntemplate <typename T>                                           void write(vector<vector<T>> &rc,ll n,ll m,ll w){forn(i,n){forn(j,m){cerr<<setw(w)<<rc[i][j]<<\" \";}cerr<<line;}}\r\ntemplate <typename T>                                           void _print(T &t) {cerr << t;}\r\ntemplate <class T, class V>                                     void _print(pair <T, V> &p);\r\ntemplate <class T>                                              void _print(vector <T> &v);\r\ntemplate <class T>                                              void _print(set <T> &v);\r\ntemplate <class T, class V>                                     void _print(map <T, V> &v);\r\ntemplate <class T>                                              void _print(multiset <T> &v);\r\ntemplate <class T>                                              void _print(set <T, greater<T>> &v);\r\ntemplate <class T, class V>                                     void _print(map <T, V, greater<T>> &v);\r\ntemplate <class T>                                              void _print(multiset <T, greater<T>> &v);\r\ntemplate <class T, class V>                                     void _print(unordered_map <T, V> &v);\r\ntemplate <class T, class V>                                     void _print(unordered_map <T, V, myhash> &v);\r\ntemplate <class T>                                              void _print(stack<T> st);\r\ntemplate <class T>                                              void _print(queue<T> q);\r\ntemplate <class T>                                              void _print(deque<T> dq);\r\ntemplate <class T>                                              void _print(priority_queue<T> pq);\r\ntemplate <class T>                                              void _print(priority_queue<T,vector<T>,greater<T>> pq);\r\ntemplate <class T, class V>                                     void _print(pair <T, V> &p) {cerr << \"{\"; _print(p.fst); cerr << \",\"; _print(p.scd); cerr << \"}\";}\r\ntemplate <class T>                                              void _print(vector <T> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(set <T> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(set <T, greater<T>> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(priority_queue <T> pq) {cerr << \"[ \"; while(!pq.empty()) {T temp=pq.top(); pq.pop(); _print(temp); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(priority_queue <T,vector<T>,greater<T>> pq) {cerr << \"[ \"; while(!pq.empty()) {T temp=pq.top(); pq.pop(); _print(temp); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(stack <T> st) {cerr << \"[ \"; while(!st.empty()) {T temp=st.top(); st.pop(); _print(temp); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(queue <T> q) {cerr << \"[ \"; while(!q.empty()) {T temp=q.front(); q.pop(); _print(temp); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(deque <T> dq) {cerr << \"[ \"; while(!dq.empty()) {T temp=dq.front(); dq.pop_front(); _print(temp); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(multiset <T> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T>                                              void _print(multiset <T, greater<T>> &v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V>                                     void _print(map <T, V> &v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V>                                     void _print(map <T, V, greater<T>> &v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V>                                     void _print(unordered_map <T, V> &v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V>                                     void _print(unordered_map <T, V, myhash> &v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\n\r\n\r\nclass UnionFind {\r\n    public :\r\n   ll size2;\r\n   vector<ll> sz,id;\r\n   ll numComponents;\r\n\r\n  UnionFind(ll size1) {\r\n\r\n    if (size1 <= 0)\r\n    {\r\n        cout<<\"Not Allowed\";\r\n        return;\r\n    }\r\n\r\n    size2 = size1;\r\n    numComponents=size1;\r\n\r\n    for (ll i = 0; i <= size1; i++) {\r\n      id.push_back(i);// Link to itself (self root)\r\n      sz.push_back(1); // Each component is originally of size one\r\n    }\r\n  }\r\n\r\n   ll find1(ll p) {\r\n\r\n    // Find the root of the component/set\r\n    ll root = p;\r\n    while (root != id[root]) root = id[root];\r\n\r\n    // Compress the path leading back to the root.\r\n    // Doing this operation is called \"path compression\"\r\n    // and is what gives us amortized time complexity.\r\n    while (p != root) {\r\n      ll next = id[p];\r\n      id[p] = root;\r\n      p = next;\r\n    }\r\n\r\n    return root;\r\n  }\r\n\r\n \r\n   bool connected(ll p,ll q) {\r\n    return find1(p) == find1(q);\r\n  }\r\n\r\n   ll componentSize(ll p) {\r\n    return sz[find1(p)];\r\n  }\r\n\r\n   ll sizecom() {\r\n    return size2;\r\n  }\r\n\r\n  // Returns the number of remaining components/sets\r\n   ll components() {\r\n    return numComponents;\r\n  }\r\n\r\n   bool unify(ll p, ll q) {\r\n    ll root1 = find1(p);\r\n    ll root2 = find1(q);\r\n    // These elements are already in the same group!\r\n    if (root1 == root2){\r\n        // debug1(\"NO\")\r\n        return 0;\r\n    }\r\n\r\n    // Merge smaller component/set into the larger one.\r\n    if (sz[root1] < sz[root2]) {\r\n      sz[root2] += sz[root1];\r\n      id[root1] = root2;\r\n      sz[root1]=1;\r\n    } else {\r\n      sz[root1] += sz[root2];\r\n      id[root2] = root1;\r\n      sz[root2]=1;\r\n    }\r\n\r\n    // Since the roots found are different we know that the\r\n    // number of components/sets has decreased by one\r\n    numComponents--;\r\n    // debug1(numComponents)\r\n    return 1;\r\n  }\r\n};\r\nvll graph[(ll)2e5+5];\r\nvoid dfs(ll par,ll curr,ll id[],ll lowLink[],vvll &bridge,ll &ct){\r\n    if(id[curr]!=INT_MAX){\r\n        return;\r\n    }\r\n    lowLink[curr]=id[curr]=ct;\r\n    ct++;\r\n    for(auto it: graph[curr]){\r\n        if(it!=par){\r\n            dfs(curr,it,id,lowLink,bridge,ct);\r\n            lowLink[curr]=min(lowLink[curr],lowLink[it]);\r\n            if(id[curr]<lowLink[it]){\r\n                bridge.pb({min(curr,it),max(curr,it)});\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid graphBuilder(vvll &edges,ll n,ll m,string &ans){\r\n    for1(i,n){\r\n        graph[i].clear();\r\n    }\r\n    forn(i,m){\r\n        if(ans[i]=='1'){\r\n            graph[edges[i][0]].pb(edges[i][1]);\r\n            graph[edges[i][1]].pb(edges[i][0]);\r\n        }\r\n    }\r\n}\r\nvoid solve()\r\n{\r\n    ll n,m;\r\n    read(n,m);\r\n    vvll edges;\r\n    forn(i,m){\r\n        ll x,y;\r\n        read(x,y);\r\n        edges.pb({min(x,y),max(x,y)});\r\n    }\r\n    // debug(edges)\r\n    ll id[n+1],lowLink[n+1];\r\n    vvll bridge;\r\n    ll ct=1;\r\n    UnionFind ob(n);\r\n    string ans(m,'1');\r\n    forn(i,m-n+1){\r\n        // debug1(i)\r\n        graphBuilder(edges,n,m,ans);\r\n        dfs(-1,1,id,lowLink,bridge,ct);\r\n        sort(all(bridge));\r\n        forn(j,m){\r\n            // debug(edges[j])\r\n            if(ans[j]=='1' and !binary_search(all(bridge),edges[j]) and ob.unify(edges[j][0],edges[j][1])){\r\n                ans[j]='0';\r\n                break;\r\n            }\r\n        }\r\n        ct=1;\r\n        for1(i,n){\r\n            id[i]=lowLink[i]=INT_MAX;\r\n        }\r\n        // debug(bridge)\r\n        bridge.clear();\r\n        // debug(ans)\r\n    }\r\n    wrtline(ans);\r\n}\r\nint main() {\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stderr);\r\n#endif\r\nios_base::sync_with_stdio(false);\r\ncin.tie(NULL);\r\n//*******************************************************//\r\ntest\r\nsolve();\r\n\r\nreturn 0;\r\n}"
}