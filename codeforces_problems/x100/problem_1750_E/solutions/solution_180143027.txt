{
    "id": 180143027,
    "contestId": 1750,
    "creationTimeSeconds": 1667949308,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1750,
        "index": "E",
        "name": "Bracket Cost",
        "type": "PROGRAMMING",
        "points": 2250.0,
        "rating": 2400,
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "strings"
        ]
    },
    "author": {
        "contestId": 1750,
        "members": [
            {
                "handle": "rqi"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1667745300
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 29,
    "timeConsumedMillis": 108,
    "memoryConsumedBytes": 15872000,
    "source": "#ifndef _GLIBCXX_NO_ASSERT\r\n#include <cassert>\r\n#endif\r\n#include <cctype>\r\n#include <cerrno>\r\n#include <cfloat>\r\n#include <ciso646>\r\n#include <climits>\r\n#include <clocale>\r\n#include <cmath>\r\n#include <csetjmp>\r\n#include <csignal>\r\n#include <cstdarg>\r\n#include <cstddef>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n#include <cwchar>\r\n#include <cwctype>\r\n\r\n#if __cplusplus >= 201103L\r\n#include <ccomplex>\r\n#include <cfenv>\r\n#include <cinttypes>\r\n// #include <cstdalign>\r\n#include <cstdbool>\r\n#include <cstdint>\r\n#include <ctgmath>\r\n// #include <cuchar>\r\n#endif\r\n\r\n// C++\r\n#include <algorithm>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <vector>\r\n\r\n#if __cplusplus >= 201103L\r\n#include <array>\r\n#include <atomic>\r\n#include <chrono>\r\n// #include <codecvt>\r\n#include <condition_variable>\r\n#include <forward_list>\r\n#include <future>\r\n#include <initializer_list>\r\n#include <mutex>\r\n#include <random>\r\n#include <ratio>\r\n#include <regex>\r\n#include <scoped_allocator>\r\n#include <system_error>\r\n#include <thread>\r\n#include <tuple>\r\n#include <typeindex>\r\n#include <type_traits>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#endif\r\n\r\n#if __cplusplus >= 201402L\r\n#include <shared_mutex>\r\n#endif\r\n\r\n#if __cplusplus >= 201703L\r\n#include <any>\r\n#include <charconv>\r\n// #include <execution>\r\n#include <filesystem>\r\n#include <optional>\r\n// #include <memory_resource>\r\n#include <string_view>\r\n#include <variant>\r\n#endif\r\n\r\n#if __cplusplus > 201703L\r\n#include <barrier>\r\n#include <bit>\r\n#include <compare>\r\n#include <concepts>\r\n#if __cpp_impl_coroutine\r\n# include <coroutine>\r\n#endif\r\n#include <latch>\r\n#include <numbers>\r\n#include <ranges>\r\n#include <span>\r\n#include <stop_token>\r\n#include <semaphore>\r\n#include <source_location>\r\n#include <syncstream>\r\n#include <version>\r\n#endif\r\n\r\nusing namespace std;\r\n \r\nusing ll = long long;\r\nusing db = long double; // or double, if TL is tight\r\nusing str = string; // yay python! \r\n\r\n// pairs\r\nusing pi = pair<int,int>;\r\nusing pl = pair<ll,ll>;\r\nusing pd = pair<db,db>;\r\n#define mp make_pair\r\n#define f first\r\n#define s second\r\n\r\n#define tcT template<class T\r\n#define tcTU tcT, class U\r\n// ^ lol this makes everything look weird but I'll try it\r\ntcT> using V = vector<T>; \r\ntcT, size_t SZ> using AR = array<T,SZ>; \r\nusing vi = V<int>;\r\nusing vb = V<bool>;\r\nusing vl = V<ll>;\r\nusing vd = V<db>;\r\nusing vs = V<str>;\r\nusing vpi = V<pi>;\r\nusing vpl = V<pl>;\r\nusing vpd = V<pd>;\r\n\r\n// vectors\r\n// oops size(x), rbegin(x), rend(x) need C++17\r\n#define sz(x) int((x).size())\r\n#define bg(x) begin(x)\r\n#define all(x) bg(x), end(x)\r\n#define rall(x) x.rbegin(), x.rend() \r\n#define sor(x) sort(all(x)) \r\n#define rsz resize\r\n#define ins insert \r\n#define pb push_back\r\n#define eb emplace_back\r\n#define ft front()\r\n#define bk back()\r\n\r\n#define lb lower_bound\r\n#define ub upper_bound\r\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\r\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\r\n\r\n// loops\r\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\r\n#define F0R(i,a) FOR(i,0,a)\r\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\r\n#define R0F(i,a) ROF(i,0,a)\r\n#define rep(a) F0R(_,a)\r\n#define each(a,x) for (auto& a: x)\r\n\r\nconst int MOD = 1e9+7; // 998244353;\r\nconst int MX = 2e5+5;\r\nconst ll BIG = 1e18; // not too close to LLONG_MAX\r\nconst db PI = acos((db)-1);\r\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\r\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \r\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\r\n\r\n// bitwise ops\r\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\r\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\r\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\r\n    return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \r\nconstexpr int p2(int x) { return 1<<x; }\r\nconstexpr int msk2(int x) { return p2(x)-1; }\r\n\r\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\r\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\r\n\r\ntcT> bool ckmin(T& a, const T& b) {\r\n    return b < a ? a = b, 1 : 0; } // set a = min(a,b)\r\ntcT> bool ckmax(T& a, const T& b) {\r\n    return a < b ? a = b, 1 : 0; } // set a = max(a,b)\r\n\r\ntcTU> T fstTrue(T lo, T hi, U f) {\r\n    ++hi; assert(lo <= hi); // assuming f is increasing\r\n    while (lo < hi) { // find first index such that f is true \r\n        T mid = lo+(hi-lo)/2;\r\n        f(mid) ? hi = mid : lo = mid+1; \r\n    } \r\n    return lo;\r\n}\r\ntcTU> T lstTrue(T lo, T hi, U f) {\r\n    --lo; assert(lo <= hi); // assuming f is decreasing\r\n    while (lo < hi) { // find first index such that f is true \r\n        T mid = lo+(hi-lo+1)/2;\r\n        f(mid) ? lo = mid : hi = mid-1;\r\n    } \r\n    return lo;\r\n}\r\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\r\n    sort(all(v)); v.erase(unique(all(v)),end(v)); }\r\ntcTU> void erase(T& t, const U& u) { // don't erase\r\n    auto it = t.find(u); assert(it != end(t));\r\n    t.erase(it); } // element that doesn't exist from (multi)set\r\n\r\n#define tcTUU tcT, class ...U\r\n\r\ninline namespace Helpers {\r\n    //////////// is_iterable\r\n    // https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\r\n    // this gets used only when we can call begin() and end() on that type\r\n    tcT, class = void> struct is_iterable : false_type {};\r\n    tcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\r\n                                      decltype(end(declval<T>()))\r\n                                     >\r\n                           > : true_type {};\r\n    tcT> constexpr bool is_iterable_v = is_iterable<T>::value;\r\n\r\n    //////////// is_readable\r\n    tcT, class = void> struct is_readable : false_type {};\r\n    tcT> struct is_readable<T,\r\n            typename std::enable_if_t<\r\n                is_same_v<decltype(cin >> declval<T&>()), istream&>\r\n            >\r\n        > : true_type {};\r\n    tcT> constexpr bool is_readable_v = is_readable<T>::value;\r\n\r\n    //////////// is_printable\r\n    // // https://nafe.es/posts/2020-02-29-is-printable/\r\n    tcT, class = void> struct is_printable : false_type {};\r\n    tcT> struct is_printable<T,\r\n            typename std::enable_if_t<\r\n                is_same_v<decltype(cout << declval<T>()), ostream&>\r\n            >\r\n        > : true_type {};\r\n    tcT> constexpr bool is_printable_v = is_printable<T>::value;\r\n}\r\n\r\ninline namespace Input {\r\n    tcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\r\n    tcTUU> void re(T& t, U&... u);\r\n    tcTU> void re(pair<T,U>& p); // pairs\r\n\r\n    // re: read\r\n    tcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\r\n    tcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\r\n    tcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\r\n    tcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\r\n    tcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\r\n        each(x,i) re(x); }\r\n    tcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\r\n\r\n    // rv: resize and read vectors\r\n    void rv(size_t) {}\r\n    tcTUU> void rv(size_t N, V<T>& t, U&... u);\r\n    template<class...U> void rv(size_t, size_t N2, U&... u);\r\n    tcTUU> void rv(size_t N, V<T>& t, U&... u) {\r\n        t.rsz(N); re(t);\r\n        rv(N,u...); }\r\n    template<class...U> void rv(size_t, size_t N2, U&... u) {\r\n        rv(N2,u...); }\r\n\r\n    // dumb shortcuts to read in ints\r\n    void decrement() {} // subtract one from each\r\n    tcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\r\n    #define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\r\n    #define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\r\n}\r\n\r\ninline namespace ToString {\r\n    tcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\r\n\r\n    // ts: string representation to print\r\n    tcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\r\n        stringstream ss; ss << fixed << setprecision(15) << v;\r\n        return ss.str(); } // default\r\n    tcT> str bit_vec(T t) { // bit vector to string\r\n        str res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\r\n        res += \"}\"; return res; }\r\n    str ts(V<bool> v) { return bit_vec(v); }\r\n    template<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\r\n    tcTU> str ts(pair<T,U> p); // pairs\r\n    tcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\r\n    tcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\r\n    tcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\r\n        // convert container to string w/ separator sep\r\n        bool fst = 1; str res = \"\";\r\n        for (const auto& x: v) {\r\n            if (!fst) res += sep;\r\n            fst = 0; res += ts(x);\r\n        }\r\n        return res;\r\n    }\r\n    tcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\r\n        return \"{\"+ts_sep(v,\", \")+\"}\"; }\r\n\r\n    // for nested DS\r\n    template<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \r\n      ts_lev(const T& v) { return {ts(v)}; }\r\n    template<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \r\n      ts_lev(const T& v) {\r\n        if (lev == 0 || !sz(v)) return {ts(v)};\r\n        vs res;\r\n        for (const auto& t: v) {\r\n            if (sz(res)) res.bk += \",\";\r\n            vs tmp = ts_lev<lev-1>(t);\r\n            res.ins(end(res),all(tmp));\r\n        }\r\n        F0R(i,sz(res)) {\r\n            str bef = \" \"; if (i == 0) bef = \"{\";\r\n            res[i] = bef+res[i];\r\n        }\r\n        res.bk += \"}\";\r\n        return res;\r\n    }\r\n}\r\n\r\ninline namespace Output {\r\n    template<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\r\n    template<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\r\n        pr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\r\n    // print w/ no spaces\r\n    template<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \r\n    // print w/ spaces, end with newline\r\n    void ps() { cout << \"\\n\"; }\r\n    template<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \r\n    // debug to cerr\r\n    template<class ...T> void dbg_out(const T&... t) {\r\n        pr_sep(cerr,\" | \",t...); cerr << endl; }\r\n    void loc_info(int line, str names) {\r\n        cerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\r\n    template<int lev, class T> void dbgl_out(const T& t) {\r\n        cerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\r\n    #ifdef LOCAL\r\n        #define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\r\n        #define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\r\n    #else // don't actually submit with this\r\n        #define dbg(...) 0\r\n        #define dbgl(lev,x) 0\r\n    #endif\r\n\r\n    const clock_t beg = clock();\r\n    #define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\r\n}\r\n\r\ninline namespace FileIO {\r\n    void setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\r\n    void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\r\n    void setIO(str s = \"\") {\r\n        cin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\r\n        // cin.exceptions(cin.failbit);\r\n        // throws exception when do smth illegal\r\n        // ex. try to read letter into int\r\n        if (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\r\n    }\r\n}\r\n\r\n\r\nvoid solve(){\r\n    int n; cin >> n;\r\n    string s; cin >> s;\r\n    vl csum(n+1, 0);\r\n    for(int i = 1; i <= n; i++){\r\n        csum[i] = csum[i-1];\r\n        if(s[i-1] == '('){\r\n            csum[i]++;\r\n        }\r\n        else{\r\n            csum[i]--;\r\n        }\r\n    }\r\n\r\n    ll ans = 0;\r\n    // for(int L = 0; L < sz(csum); L++){\r\n    //     ll cur_min = csum[L];\r\n    //     for(int R = L; R < sz(csum); R++){\r\n    //         ckmin(cur_min, csum[R]);\r\n    //         ans+=max(csum[L], csum[R])-cur_min;\r\n    //     }\r\n    // }\r\n\r\n    \r\n\r\n    vector<pair<ll, int>> vals;\r\n    for(int i = 0; i < sz(csum); i++){\r\n        vals.pb(mp(csum[i], i));\r\n    }\r\n    sor(vals);\r\n\r\n    set<int> poses;\r\n    for(int i = 0; i < sz(vals); i++){\r\n        //when is this the max element?\r\n        ans+=ll(i+1)*vals[i].f;\r\n        //when's it the min element?\r\n        int L = 0;\r\n        int R = sz(vals)-1;\r\n\r\n        int pos = vals[i].s;\r\n        auto it = poses.lb(pos);\r\n        if(it != poses.end()){\r\n            ckmin(R, (*it)-1);\r\n        }\r\n        if(it != poses.begin()){\r\n            ckmax(L, (*(prev(it)))+1);\r\n        }\r\n\r\n        ans-=ll(R-pos+1)*ll(pos-L+1)*vals[i].f;\r\n\r\n        poses.insert(pos);\r\n    }\r\n\r\n    ps(ans);\r\n}\r\n\r\nint main() {\r\n    setIO();\r\n    //min(L, R)-min\r\n    //max(L, R)-min(L, R)\r\n    int T;\r\n    cin >> T;\r\n    for(int t = 1; t <= T; t++){\r\n        solve();\r\n    }\r\n    // you should actually read the stuff at the bottom\r\n}\r\n\r\n/* stuff you should look for\r\n    * int overflow, array bounds\r\n    * special cases (n=1?)\r\n    * do smth instead of nothing and stay organized\r\n    * WRITE STUFF DOWN\r\n    * DON'T GET STUCK ON ONE APPROACH\r\n*/\r\n"
}