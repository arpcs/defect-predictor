{
    "id": 24022818,
    "contestId": 280,
    "creationTimeSeconds": 1485060453,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 280,
        "index": "E",
        "name": "Sequence Transformation",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 280,
        "members": [
            {
                "handle": "tqyaaaaaaaang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362929400
    },
    "programmingLanguage": "GNU C++",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 1,
    "timeConsumedMillis": 30,
    "memoryConsumedBytes": 3584000,
    "source": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#ifndef ONLINE_JUDGE\r\n#pragma comment ( linker, \"/STACK:10240000\" )\r\n#endif\r\n\r\n#define LL long long\r\n#define LD long double\r\n#define SC(t,x) static_cast<t>(x)\r\n#define AR(t) vector < t >\r\n#define PII pair < int, int >\r\n#define PLL pair < LL, LL >\r\n#define PIL pair < int, LL >\r\n#define PLI pair < LL, int >\r\n#define PDD pair < double, double >\r\n#define MP make_pair\r\n#define PB push_back\r\n#define PF push_front\r\n#define POB pop_back\r\n#define POF pop_front\r\n#define PRF first\r\n#define PRS second\r\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\r\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\r\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\r\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\r\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\r\n#define qmax(a,b) (((a)>(b))?(a):(b))\r\n#define qmin(a,b) (((a)<(b))?(a):(b))\r\n#define qabs(a) (((a)>=0)?(a):(-(a)))\r\n#define qsqr(a) ((a)*(a))\r\n\r\nconst int INF = 0x3fffffff;\r\nconst int SINF = 0x7fffffff;\r\nconst long long LINF = 0x3fffffffffffffff;\r\nconst long long SLINF = 0x7fffffffffffffff;\r\nconst double DINF = 1e100;\r\nconst int MAXN = 6007;\r\nconst int MAXL = 15007;\r\nconst double EPS = 1e-12;\r\n\r\nint n, q, a, b;\r\nint xx[MAXN];\r\n\r\nclass fT\r\n{\r\npublic:\r\n\tfT () : kk ( 0 ) {}\r\n\r\n\tvoid setd ( int _k, int _b, int _l, int _r )\r\n\t{\r\n\t\tk[0] = _k, b[0] = _b, bn[0] = _l, bn[1] = _r, kk = 1;\r\n\t}\r\n\r\n\tvoid operator += ( const fT &x )\r\n\t{\r\n\t\t( *this ) = ( *this ) + x;\r\n\t}\r\n\r\n\tfT operator + ( const fT &x ) const\r\n\t{\r\n\t\tfT ans;\r\n\r\n\t\tdouble ll = qmax ( bn[0], x.bn[0] ), rr = qmin ( bn[kk], x.bn[x.kk] );\r\n\r\n\t\tint i1 = 0, i2 = 0;\r\n\t\twhile ( i1 <= kk && i2 <= x.kk ){\r\n\t\t\tif ( i1 <= kk && bn[i1] < x.bn[i2] ){\r\n\t\t\t\tif ( ( !ans.kk || bn[i1] != ans.bn[ans.kk-1] ) && ( bn[i1] >= ll && bn[i1] <= rr ) ) ans.bn[ans.kk++] = bn[i1];\r\n\t\t\t\t++i1;\r\n\t\t\t}else{\r\n\t\t\t\tif ( ( !ans.kk || x.bn[i2] != ans.bn[ans.kk-1] ) && ( x.bn[i2] >= ll && x.bn[i2] <= rr ) ) ans.bn[ans.kk++] = x.bn[i2];\r\n\t\t\t\t++i2;\r\n\t\t\t}\r\n\t\t}\r\n\t\t--ans.kk;\r\n\r\n\t\tif ( !ans.kk ) ++ans.kk, ans.bn[ans.kk] = ans.bn[ans.kk-1];\r\n\r\n\t\tint id1 = 0, id2 = 0;\r\n\t\tlp ( i, 0, ans.kk ){\r\n\t\t\twhile ( id1 + 1 < kk && bn[id1+1] <= ans.bn[i] ) ++id1;\r\n\t\t\twhile ( id2 + 1 < x.kk && x.bn[id2+1] <= ans.bn[i] ) ++id2;\r\n\t\t\tans.k[i] = k[id1] + x.k[id2];\r\n\t\t\tans.b[i] = b[id1] + x.b[id2];\r\n\t\t}\r\n\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tvoid move ( int ll, int rr )\r\n\t{\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tbn[i] += ll;\r\n\t\t\tif ( k[i] ) b[i] -= k[i] * ll;\r\n\t\t}\r\n\t\tbn[kk] += ll;\r\n\t\tminp += ll;\r\n\r\n\t\tif ( rr - ll ){\r\n\t\t\tlp ( i, 0, kk ){\r\n\t\t\t\tif ( minp >= bn[i] && minp <= bn[i+1] ){\r\n\t\t\t\t\tif ( minp - bn[i] > EPS ){\r\n\t\t\t\t\t\tbn[kk+1] = bn[kk];\r\n\t\t\t\t\t\tlpd ( j, kk, i )\r\n\t\t\t\t\t\t\tbn[j] = bn[j-1], k[j] = k[j-1], b[j] = b[j-1];\r\n\t\t\t\t\t\t++kk;\r\n\t\t\t\t\t\tbn[i+1] = minp;\r\n\t\t\t\t\t}else --i;\r\n\t\t\t\t\tdouble del = rr - ll;\r\n\t\t\t\t\tbn[kk+1] = bn[kk] + del;\r\n\t\t\t\t\tlpd ( j, kk, i+1 )\r\n\t\t\t\t\t\tbn[j] = bn[j-1] + del, k[j] = k[j-1], b[j] = b[j-1] - k[j-1] * del;\r\n\t\t\t\t\t++kk;\r\n\t\t\t\t\tbn[i+2] = minp + del;\r\n\t\t\t\t\tk[i+1] = 0;\r\n//\t\t\t\t\tb[i+1] = vmin;\r\n\t\t\t\t\tb[i+1] = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdouble f ( double x, int bid )\r\n\t{\r\n\t\treturn ( k[bid] * x + b[bid] );\r\n\t}\r\n\r\n\tdouble calcmin ()\r\n\t{\r\n/*\t\tminp = bn[kk];\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tif ( k[i] > 0 ){\r\n\t\t\t\tminp = bn[i];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}*/\r\n\r\n/*\t\tif ( ( vmin = f ( bn[0], 0 ) ) >= 0 ) minp = bn[0];\r\n\t\telse if ( ( vmin = f ( bn[kk], kk-1 ) ) <= 0 ) minp = bn[kk];\r\n\t\telse{\r\n\t\t\tlp ( i, 0, kk ){\r\n\t\t\t\tif ( f ( bn[i+1], i ) > 0 ){\r\n\t\t\t\t\tif ( k[i] ) minp = - b[i] / k[i];\r\n\t\t\t\t\telse minp = bn[i];\r\n\t\t\t\t\tvmin = f ( minp, i );\r\n//\t\t\t\t\tassert ( !f ( minp, i ) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}*/\r\n\r\n\t\tdouble v1, v2;\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tv1 = f ( bn[i], i ), v2 = f ( bn[i+1], i );\r\n\t\t\tif ( v1 > 0 ){\r\n\t\t\t\tif ( v1 < qabs ( vmin ) ) minp = bn[i], vmin = v1;\r\n\t\t\t}else if ( v2 < 0 ){\r\n\t\t\t\tif ( qabs ( v2 ) < qabs ( vmin ) ) minp = bn[i+1], vmin = v2;\r\n\t\t\t}else{\r\n\t\t\t\tif ( k[i] ) minp = - b[i] / k[i];\r\n\t\t\t\telse minp = bn[i];\r\n\t\t\t\tvmin = 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn minp;\r\n\t}\r\n\r\n\tvoid print ()\r\n\t{\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tif ( b[i] >= 0 ) printf ( \"x=[%.6lf][%.6lf]: y=%.6lfx+%.6lf   R=[%.6lf][%.6lf]\\n\", bn[i], bn[i+1], k[i], b[i], f ( bn[i], i ), f ( bn[i+1], i ) );\r\n\t\t\telse printf ( \"x=[%.6lf][%.6lf]: y=%.6lfx%.6lf   R=[%.6lf][%.6lf]\\n\", bn[i], bn[i+1], k[i], b[i], f ( bn[i], i ), f ( bn[i+1], i ) );\r\n\t\t}\r\n\t\tprintf ( \"minp=%.6lf   f(minp)=%.6lf\\n\", minp, vmin );\r\n\t}\r\n\r\nprivate:\r\n\tint kk;\r\n\tdouble k[MAXL], b[MAXL], bn[MAXL], minp, vmin;\r\n}func1, func2, tmp;\r\n\r\ndouble mp[MAXN];\r\n\r\nvoid init ();\r\nvoid input ();\r\nvoid work ();\r\n\r\ndouble getmin ( int lev, double nx );\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tinit();\r\n\tinput();\r\n\twork();\r\n}\r\n\r\n\r\n\r\nvoid init ()\r\n{\r\n\t// Init Everything Here\r\n\t\r\n\tios::sync_with_stdio ( false );\r\n}\r\n\r\nvoid input ()\r\n{\r\n\t// input method\r\n\r\n\tscanf ( \"%d%d%d%d\", &n, &q, &a, &b );\r\n\tlpi ( i, 1, n ) scanf ( \"%d\", &xx[i] );\r\n}\r\n\r\nvoid work ()\r\n{\r\n\t// main work\r\n\r\n/*\tfT *func = &func1, *la = &func2, *t;\r\n\tla->setd ( 1, xx[1], 0, 1, q );\r\n\tla->calcmin ();\r\n\tmp[1] = xx[1];\r\n\tlpi ( i, 2, n ){\r\n\t\t*func = *la;\r\n\t\tfunc->move ( b - a, a );\r\n\t\ttmp.setd ( 1, xx[i], 0, 1, q );\r\n\t\t*func += tmp;\r\n\r\n\t\tfunc->cut ();\r\n\t\tfunc->calcmin ();\r\n\t\tmp[i] = func->getmp ();\r\n\r\n\t\tt = func;\r\n\t\tfunc = la;\r\n\t\tla = t;\r\n\t}*/\r\n\r\n\tfT *func = &func1, *la = &func2, *t;\r\n\tla->setd ( 2, - 2 * xx[1], 1, q );\r\n\tla->calcmin ();\r\n\tmp[1] = xx[1];\r\n//\tprintf ( \"lev=1:\\n\" );\r\n//\tla->print ();\r\n\tlpi ( i, 2, n ){\r\n\t\t*func = *la;\r\n\t\tfunc->move ( a, b );\r\n//\t\tprintf ( \"\\nlev=%d\\n\", i );\r\n//\t\tprintf ( \"After move:\\n\" );\r\n//\t\tfunc->print ();\r\n\t\ttmp.setd ( 2, -2 * xx[i], a*(i-1)+1, q );\r\n//\t\tprintf ( \"Add:\\n\" );\r\n//\t\ttmp.print ();\r\n\t\t*func += tmp;\r\n\r\n\t\tmp[i] = func->calcmin ();\r\n\r\n//\t\tprintf ( \"\\nlev=%d\\n\", i );\r\n//\t\tfunc->print ();\r\n\t\t\r\n\t\tt = func;\r\n\t\tfunc = la;\r\n\t\tla = t;\r\n\t}\r\n\r\n//\tPDD ans = la->getmin ( a*(n-1)+1, q );\r\n//\tans.first = getmin ( n, ans.second );\r\n\r\n//\tprintf ( \"%.9lf\\n%.9lf\\n\", ans.second, ans.first );\r\n\r\n\tdouble ans = getmin ( n, mp[n] );\r\n\tprintf ( \"%.9lf\\n%.9lf\\n\", mp[n], ans );\r\n}\r\n\r\n\r\n\r\ndouble getmin ( int lev, double nx )\r\n{\r\n\tif ( lev == 1 ) return qsqr ( nx - xx[1] );\r\n\r\n\tdouble tl = nx - b, tr = nx - a, cho;\r\n//\ttl = qmax( tl, 1 ), tr = qmax ( tr, 1 );\r\n//\ttl = qmax ( tl, 1 );\r\n\ttl = qmax ( tl, 1LL * a * ( lev - 2 ) + 1 );\r\n//\tif ( tl > tr ) return LINF;\r\n\tdouble ans = qsqr ( nx - xx[lev] );\r\n\tif ( tl > mp[lev-1] ) ans += getmin ( lev-1, tl ), cho = tl;\r\n\telse if ( tr < mp[lev-1] ) ans += getmin ( lev-1, tr ), cho = tr;\r\n\telse ans += getmin ( lev-1, mp[lev-1] ), cho = mp[lev-1];\r\n\r\n\tprintf ( \"%.9lf \", cho );\r\n\r\n\treturn ans;\r\n}"
}