{
    "id": 3327597,
    "contestId": 280,
    "creationTimeSeconds": 1363465486,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 280,
        "index": "E",
        "name": "Sequence Transformation",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 280,
        "members": [
            {
                "handle": "MinakoKojima"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362929400
    },
    "programmingLanguage": "GNU C++0x",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 101,
    "timeConsumedMillis": 218,
    "memoryConsumedBytes": 1228800,
    "source": "/** Micro Mezz  o Macro Flation -- Overheated Economy ., Last Update: Mar. 3th 2013 **/ //{\r\n\r\n/** Header .. **/ //{\r\n#define LOCAL\r\n\r\n#include <functional>\r\n#include <algorithm>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <iomanip>\r\n#include <numeric>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <string>\r\n#include <vector>\r\n#include <bitset>\r\n#include <queue>\r\n#include <stack>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <list>\r\n#include <set>\r\n#include <map>\r\n\r\n#include <tr1/unordered_set>\r\n#include <tr1/unordered_map>\r\n//#include <array>\r\n\r\nusing namespace std;\r\n\r\n#define REP(i, n) for (int i=0;i<int(n);++i)\r\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\r\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\r\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\r\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\r\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\r\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\r\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\r\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\r\n#define REP_N(i, n) for (i=0;i<int(n);++i)\r\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\r\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\r\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\r\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\r\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\r\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\r\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\r\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\r\n#define REP_C_N(i, n) for (int n____=(i=0,int(n));i<n____;++i)\r\n#define FOR_C_N(i, a, b) for (int b____=(i=0,int(b);i<b____;++i)\r\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,int(a));i>=a____;--i)\r\n#define REP_1_C_N(i, n) for (int n____=(i=1,int(n));i<=n____;++i)\r\n#define FOR_1_C_N(i, a, b) for (int b____=(i=1,int(b);i<=b____;++i)\r\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,int(a));i>=a____;--i)\r\n\r\n#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\r\n#define REP_S(i, str) for (char*i=str;*i;++i)\r\n#define REP_L(i, hd, nxt) for (int i=hd;i;i=nxt[i])\r\n#define REP_G(i, u) REP_L(i,hd[u],suc)\r\n#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )\r\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\r\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\r\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\r\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\r\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\r\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\r\n\r\n#define ALL(A) A.begin(), A.end()\r\n#define LLA(A) A.rbegin(), A.rend()\r\n#define CPY(A, B) memcpy(A, B, sizeof(A))\r\n#define INS(A, P, B) A.insert(A.begin() + P, B)\r\n#define ERS(A, P) A.erase(A.begin() + P)\r\n#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())\r\n#define CTN(T, x) (T.find(x) != T.end())\r\n#define SZ(A) int((A).size())\r\n#define PB push_back\r\n#define MP(A, B) make_pair(A, B)\r\n#define PTT pair<T, T>\r\n#define fi first\r\n#define se second\r\n\r\n#define Rush for(int ____T=RD(); ____T--;)\r\n\r\n#define Display(A, n, m) {                      \\\r\n\tREP(i, n){\t\t                            \\\r\n        REP(j, m) cout << A[i][j] << \" \";       \\\r\n        cout << endl;\t\t\t\t            \\\r\n\t}\t\t\t\t\t\t                    \\\r\n}\r\n\r\n#define Display_1(A, n, m) {\t\t\t\t    \\\r\n\tREP_1(i, n){\t\t                        \\\r\n        REP_1(j, m) cout << A[i][j] << \" \";     \\\r\n\t\tcout << endl;\t\t            \t\t\\\r\n\t}\t\t\t\t\t\t                    \\\r\n}\r\n\r\n#pragma comment(linker, \"/STACK:36777216\")\r\n//#pragma GCC optimize (\"O2\")\r\n\r\nstring __file__(){\r\n    string res = __FILE__;\r\n    int r = SZ(res) - 1; while (res[r] !=  '.') --r;\r\n    int l = r - 1; while (res[l] != '\\\\') --l; ++l;\r\n    return res.substr(l, r-l);\r\n}\r\n\r\nvoid Exec(string a, string b, string c){\r\n    if (b.empty()) b = __file__();\r\n    string cmd = a + ' ' + b + '.' + c;\r\n    system(cmd.c_str());\r\n}\r\n\r\nvoid Ruby(string file = \"\"){Exec(\"ruby\", file, \"rb\");}\r\nvoid Python(string file = \"\"){Exec(\"python\", file, \"py\");}\r\nvoid Haskell(string file = \"\"){Exec(\"runghc\", file, \"hs\");}\r\nvoid Pascal(string file = \"\"){Exec(\"pascal\", file, \"pas\");}\r\n\r\ntypedef long long LL;\r\n//typedef long double DB;\r\ntypedef double DB;\r\ntypedef unsigned UINT;\r\ntypedef unsigned long long ULL;\r\n\r\ntypedef vector<int> VI;\r\ntypedef vector<char> VC;\r\ntypedef vector<string> VS;\r\ntypedef vector<LL> VL;\r\ntypedef vector<DB> VF;\r\ntypedef set<int> SI;\r\ntypedef set<string> SS;\r\ntypedef map<int, int> MII;\r\ntypedef map<string, int> MSI;\r\ntypedef pair<int, int> PII;\r\ntypedef pair<LL, LL> PLL;\r\ntypedef vector<PII> VII;\r\ntypedef vector<VI> VVI;\r\ntypedef vector<VII> VVII;\r\n\r\ntemplate<class T> inline T& RD(T &);\r\ntemplate<class T> inline void OT(const T &);\r\n//inline int RD(){int x; return RD(x);}\r\ninline LL RD(){LL x; return RD(x);}\r\ninline DB& RF(DB &);\r\ninline DB RF(){DB x; return RF(x);}\r\ninline char* RS(char *s);\r\ninline char& RC(char &c);\r\ninline char RC();\r\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\r\ninline char RC(){char c; return RC(c);}\r\n//inline char& RC(char &c){c = getchar(); return c;}\r\n//inline char RC(){return getchar();}\r\n\r\ntemplate<class T> inline T& RDD(T &x){\r\n    char c; for (c = getchar(); c < '-'; c = getchar());\r\n    if (c == '-'){x = '0' - getchar(); for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + '0' - c;}\r\n    else {x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';}\r\n    return x;\r\n}\r\n\r\ninline LL RDD(){LL x; return RDD(x);}\r\n\r\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\r\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\r\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\r\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\r\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\r\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\r\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\r\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\r\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\r\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\r\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\r\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\r\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\r\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\r\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\r\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\r\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\r\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\r\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\r\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\r\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\r\ntemplate<class T0,class T1>inline void RDD(const T0&a, const T1&b){RDD(a),RDD(b);}\r\ntemplate<class T0,class T1,class T2>inline void RDD(const T0&a, const T1&b, const T2&c){RDD(a),RDD(b),RDD(c);}\r\n\r\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\r\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\r\ntemplate<class T> inline void CLR(T &A){A.clear();}\r\n\r\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\r\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\r\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\r\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\r\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\r\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\r\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\r\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\r\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\r\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\r\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\r\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\r\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\r\n\r\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\r\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\r\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\r\ntemplate<class T> inline T& UNQ(T &A){A.resize(unique(ALL(SRT(A)))-A.begin());return A;}\r\n\r\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\r\n\r\n//}\r\n\r\n/** Constant List .. **/ //{\r\n\r\nconst int MOD = int(1e9) + 7;\r\n//int MOD = 99990001;\r\nconst int INF = 0x3f3f3f3f;\r\nconst LL INFF = 1LL << 60;\r\nconst DB EPS = 1e-9;\r\nconst DB OO = 1e20;\r\nconst DB PI = acos(-1.0); //M_PI;\r\n\r\nconst int dx[] = {-1, 0, 1, 0};\r\nconst int dy[] = {0, 1, 0, -1};\r\n\r\n//}\r\n\r\n/** Add On .. **/ //{\r\n// <<= '0. Nichi Joo ., //{\r\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\r\ntemplate<class T> inline void checkMax(T &a,const T b){if (a<b) a=b;}\r\ntemplate<class T> inline void checkMin(T &a, T &b, const T x){checkMin(a, x), checkMin(b, x);}\r\ntemplate<class T> inline void checkMax(T &a, T &b, const T x){checkMax(a, x), checkMax(b, x);}\r\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\r\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\r\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\r\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\r\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\r\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\r\ntemplate<class T> inline T sqr(T a){return a*a;}\r\ntemplate<class T> inline T cub(T a){return a*a*a;}\r\ninline int ceil(int x, int y){return (x - 1) / y + 1;}\r\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\r\ninline int sgn(DB x, DB y){return sgn(x - y);}\r\n\r\ninline DB cot(DB x){return (DB)1/tan(x);};\r\ninline DB sec(DB x){return (DB)1/cos(x);};\r\ninline DB csc(DB x){return (DB)1/sin(x);};\r\n\r\n//}\r\n// <<= '1. Bitwise Operation ., //{\r\nnamespace BO{\r\n\r\ninline bool _1(int x, int i){return bool(x&1<<i);}\r\ninline bool _1(LL x, int i){return bool(x&1LL<<i);}\r\ninline LL _1(int i){return 1LL<<i;}\r\ninline LL _U(int i){return _1(i) - 1;};\r\n\r\ninline int reverse_bits(int x){\r\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\r\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\r\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\r\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\r\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\r\n    return x;\r\n}\r\n\r\ninline LL reverse_bits(LL x){\r\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\r\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\r\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\r\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\r\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\r\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\r\n    return x;\r\n}\r\n\r\ntemplate<class T> inline bool odd(T x){return x&1;}\r\ntemplate<class T> inline bool even(T x){return !odd(x);}\r\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\r\ntemplate<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\r\ntemplate<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\r\ntemplate<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\r\n\r\ninline int clz(int x){return __builtin_clz(x);}\r\ninline int clz(LL x){return __builtin_clzll(x);}\r\ninline int ctz(int x){return __builtin_ctz(x);}\r\ninline int ctz(LL x){return __builtin_ctzll(x);}\r\ninline int lg2(int x){return !x ? -1 : 31 - clz(x);}\r\ninline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\r\ninline int low_idx(int x){return !x ? -1 : ctz(x);}\r\ninline int low_idx(LL x){return !x ? -1 : ctz(x);}\r\ninline int high_idx(int x){return lg2(x);}\r\ninline int high_idx(LL x){return lg2(x);}\r\ninline int parity(int x){return __builtin_parity(x);}\r\ninline int parity(LL x){return __builtin_parityll(x);}\r\ninline int count_bits(int x){return __builtin_popcount(x);}\r\ninline int count_bits(LL x){return __builtin_popcountll(x);}\r\n\r\n} using namespace BO;//}\r\n// <<= '2. Number Theory .,//{\r\nnamespace NT{\r\ninline LL __lcm(LL a, LL b){return a*b/__gcd(a,b);}\r\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\r\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\r\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\r\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\r\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\r\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\r\n\r\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\r\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\r\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\r\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\r\n\r\ninline int pow(int a, int b){\r\n    int c(1); while (b){\r\n        if (b&1) MUL(c, a);\r\n        MUL(a, a), b >>= 1;\r\n    }\r\n    return c;\r\n}\r\n\r\ninline int pow(int a, LL b){\r\n    int c(1); while (b){\r\n        if (b&1) MUL(c, a);\r\n        MUL(a, a), b >>= 1;\r\n    }\r\n    return c;\r\n}\r\n\r\ntemplate<class T> inline T pow(T a, LL b){\r\n    T c(1); while (b){\r\n        if (b&1) c *= a;\r\n        a *= a, b >>= 1;\r\n    }\r\n    return c;\r\n}\r\n\r\ninline int _I(int b){\r\n    int a = MOD, x1 = 0, x2 = 1, q;\r\n    while (true){\r\n        q = a / b, a %= b;\r\n        if (!a) return (x2 + MOD) % MOD;\r\n        DEC(x1, pdt(q, x2));\r\n\r\n        q = b / a, b %= a;\r\n        if (!b) return (x1 + MOD) % MOD;\r\n        DEC(x2, pdt(q, x1));\r\n    }\r\n}\r\n\r\ninline void DIV(int &a, int b){MUL(a, _I(b));}\r\ninline int qtt(int a, int b){return pdt(a, _I(b));}\r\n\r\ninline int phi(int n){\r\n    int res = n; for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\r\n        DEC(res, qtt(res, i));\r\n        do{n /= i;} while(!(n%i));\r\n    }\r\n    if (n != 1)\r\n        DEC(res, qtt(res, n));\r\n    return res;\r\n}\r\n\r\n} using namespace NT;//}\r\n// <<= '7. Matrix Theory .,//{\r\nnamespace MT{\r\n\r\n    const int N = 100;\r\n    int n = 0;\r\n\r\n    typedef int rec;\r\n\r\n    struct matrix{\r\n        rec d[N][N];\r\n\r\n        void init(rec e = 0){RST(d); if(e) REP(i, n) d[i][i] = e;}\r\n        matrix(rec e = 0){init(e);}\r\n\r\n        matrix operator *(const matrix &rhs) const{\r\n            matrix res; //REP_3(i, j, k, n, n, n) res.d[i][j] += d[i][k] * rhs.d[k][j];\r\n            REP_2(i, j, n, n){\r\n                LL tmp = 0; REP(k, n) tmp += (LL) d[i][k] * rhs.d[k][j];\r\n                res.d[i][j] = tmp % MOD;\r\n            }\r\n            return res;\r\n        }\r\n\r\n        matrix& operator *=(const matrix& rhs){(*this) = (*this) * rhs;}\r\n\r\n        inline int res(){\r\n            int res = 0;\r\n            REP(i, n) INC(res, d[0][i]);\r\n            //REP_2(i, j, n, n) INC(res, d[i][j]);\r\n            return res;\r\n        }\r\n    };\r\n\r\n    /*inline matrix pow_sum(const matrix& a, ULL nn){\r\n        if (nn == 1) return matrix(1);\r\n        matrix t; REP_2(i, j, n, n) t.d[i][j] = t.d[i][j+n] = a.d[i][j];\r\n        FOR_C(i, n, n*2) t.d[i][i] = 1; n <<= 1; t = pow(t, nn), n >>= 1;\r\n        REP_2(i, j, n, n) t.d[i][j] = t.d[i][j+n];\r\n        return t;\r\n    }*/\r\n\r\n    inline matrix pow_sum(const matrix& a, ULL nn){\r\n        if (nn == 1) return matrix(1);\r\n        matrix t; REP_2(i, j, n, n) t.d[i][j] = a.d[i][j];\r\n        REP(i, n) t.d[i][i+n] = t.d[i+n][i+n] = 1; n <<= 1; t = pow(t, nn), n >>= 1;\r\n        REP_2(i, j, n, n) t.d[i][j] = t.d[i][j+n];\r\n        return t;\r\n    }\r\n\r\n    template<class T> T pow_sum(T a, ULL nn){\r\n        int _n = n; n = 1; matrix t; t.d[0][0] = a;\r\n        t = pow_sum(t, nn), n = _n;\r\n        return t.d[0][0];\r\n    }\r\n\r\n} // using namespace MT;//}\r\n// <<= '8. Stringology .,//{\r\nnamespace SL{\r\n    namespace KMP{\r\n\r\n        void calc_pi(const char *P, int n, int *pi){\r\n            for (int i = 1, j = pi[0] = -1; i < n; ++i){\r\n                while (j >= 0 && P[i] != P[j+1]) j = pi[j];\r\n                if (P[i] == P[j+1]) ++j;\r\n                pi[i] = j;\r\n            }\r\n            //REP(i, n) cout << pi[i] << \" \"; cout << endl;\r\n        }\r\n\r\n        bool run(const char *T, int n, const char *P, int m, const int *pi){\r\n            for (int i = 0, j = -1; i < n; ++i){\r\n                while (j >= 0 && T[i] != P[j+1]) j = pi[j];\r\n                if (T[i] == P[j+1]) ++j;\r\n                if (j == m - 1) return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n    } //using namespace KMP;\r\n\r\n    namespace Z{\r\n        void calc_z(const char *P, int n, int *z){\r\n\r\n            z[0] = n;\r\n\r\n            for (int i = 1, l = 0, r = 0; i < n; ++i){\r\n                if (i > r){\r\n                    for(l = r = i; r < n && P[r] == P[r - l];) ++r;\r\n                    z[i] = r - l, --r;\r\n                }\r\n                else {\r\n                    if (z[i - l] < r - i + 1) z[i] = z[i - l];\r\n                    else {\r\n                        for (l = i;r < n && P[r] == P[r - l];) ++r;\r\n                        z[i] = r - l, --r;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //REP(i, n) cout << z[i] << \" \"; cout << endl;\r\n        }\r\n\r\n        int run(const char *T, int n, const char *P, int m, const int *z){\r\n\r\n            int ex; REP_C_N(ex, min(n, m)) if (T[ex] != P[ex]) break;\r\n\r\n            int res = ex == m;\r\n\r\n            for (int i = 1, l = 0, r = 0; i < n; ++i){\r\n                if (i > r){\r\n                    for (l = r = i; r < n && T[r] == P[r - l];) ++r;\r\n                    ex = r - l, --r;\r\n                }\r\n                else {\r\n                    if (z[i - l] < r - i + 1) ex = z[i - l];\r\n                    else {\r\n                        for (l = i; r < n && T[r] == P[r - l];) ++r;\r\n                        ex = r - l, --r;\r\n                    }\r\n                }\r\n                if (ex == m) ++res;\r\n            }\r\n\r\n            return res;\r\n        }\r\n    } //using namespace Z;\r\n\r\n    void Manacher(char s[], int n, int p[]){\r\n        const int NN = 0;\r\n        static char ss[NN*2+2]; int nn = 2*n+2;\r\n        ss[0] = '$', ss[nn-1] = '#', ss[nn] = 0;\r\n        REP(i, n) ss[i*2+1] ='#', ss[i*2+2] = s[i];\r\n        int mx = 0, id = 0; FOR(i, 1, nn){\r\n            p[i] = mx > i ? min(p[2*id-i], mx - i) : 1;\r\n            while (ss[i+p[i]] == ss[i-p[i]]) ++p[i];\r\n            if (i + p[i] > mx) mx = i + p[i], id = i;\r\n        }\r\n    }\r\n\r\n} //using namespace SL;//}\r\n// <<= '9. Comutational Geometry .,//{\r\nnamespace CG{\r\n\r\nstruct Po; struct Line; struct Seg;\r\n\r\nstruct Po{\r\n    DB x, y; Po(DB _x=0, DB _y=0):x(_x), y(_y){}\r\n    friend istream& operator >>(istream& in, Po &p){return in >> p.x >> p.y;}\r\n    friend ostream& operator <<(ostream& out, Po p){return out << \"(\" << p.x << \", \" << p.y << \")\";}\r\n    bool operator ==(const Po& r)const{return !sgn(x-r.x) && !sgn(y-r.y);};\r\n    bool operator !=(const Po& r)const{return sgn(x-r.x) || sgn(y-r.y);}\r\n    Po operator +(const Po& r)const{return Po(x+r.x, y+r.y);}\r\n    Po operator -(const Po& r)const{return Po(x-r.x, y-r.y);}\r\n    Po operator *(DB k)const{return Po(x*k,y*k);}\r\n    Po operator /(DB k)const{return Po(x/k,y/k);}\r\n    DB operator *(const Po&) const;\r\n    DB operator ^(const Po&) const;\r\n\r\n    bool operator <(const Po &r) const{return sgn(x,r.x)<0||!sgn(x,r.x)&&sgn(y,r.y)<0;}\r\n    Po operator -()const{return Po(-x,-y);}\r\n    Po& operator +=(const Po &r){x+=r.x,y+=r.y;return *this;}\r\n    Po& operator -=(const Po &r){x-=r.x,y-=r.y;return *this;}\r\n    Po& operator *=(DB k){x*=k,y*=k;return*this;}\r\n    Po& operator /=(DB k){x/=k,y/=k;return*this;}\r\n\r\n    DB length_sqr()const{return sqr(x)+sqr(y);}\r\n    DB length()const{return sqrt(length_sqr());}\r\n    Po unit()const{return *this/length();}\r\n    bool dgt()const{return !sgn(x)&&!sgn(y);}\r\n    DB atan()const{return atan2(y,x);}\r\n    void rotate(DB alpha, const Po& o = Po()){\r\n        x -= o.x, y -= o.y;\r\n        (*this) = Po(x * cos(alpha) - y * sin(alpha), y * cos(alpha) + x * sin(alpha)) + o;\r\n    }\r\n\r\n    void input(){RF(x,y);}\r\n};\r\n\r\nPo operator *(DB k, Po a){return a * k;}\r\n\r\n#define innerProduct dot\r\n#define scalarProduct dot\r\n#define outerProduct det\r\n#define crossProduct det\r\n\r\ninline DB dot(const DB &x1, const DB &y1, const DB &x2, const DB &y2){return x1 * x2 + y1 * y2;}\r\ninline DB dot(const Po &a, const Po &b){return dot(a.x, a.y, b.x, b.y);}\r\ninline DB dot(const Po &p0, const Po &p1, const Po &p2){return dot(p1 - p0, p2 - p0);}\r\n\r\ninline DB det(const DB &x1, const DB &y1, const DB &x2, const DB &y2){return x1 * y2 - x2 * y1;}\r\ninline DB det(const Po &a, const Po &b){return det(a.x, a.y, b.x, b.y);}\r\ninline DB det(const Po &p0, const Po &p1, const Po &p2){return det(p1 - p0, p2 - p0);}\r\n\r\ntemplate<class T1, class T2> inline int dett(const T1 &x, const T2 &y){return sgn(det(x, y));}\r\ntemplate<class T1, class T2> inline int dott(const T1 &x, const T2 &y){return sgn(dot(x, y));}\r\ntemplate<class T1, class T2, class T3> inline int dett(const T1 &x, const T2 &y, const T3 &z){return sgn(det(x, y, z));}\r\ntemplate<class T1, class T2, class T3> inline int dott(const T1 &x, const T2 &y, const T3 &z){return sgn(dot(x, y, z));}\r\ntemplate<class T1, class T2, class T3, class T4> inline int dett(const T1 &x, const T2 &y, const T3 &z, const T4 &w){return sgn(det(x, y, z, w));}\r\ntemplate<class T1, class T2, class T3, class T4> inline int dott(const T1 &x, const T2 &y, const T3 &z, const T4 &w){return sgn(dot(x, y, z, w));}\r\n\r\ninline DB dist_sqr(const DB &x, const DB &y){return sqr(x) + sqr(y);}\r\ninline DB dist_sqr(const DB &x, const DB &y, const DB &z){return sqr(x) + sqr(y) + sqr(z);}\r\ninline DB dist_sqr(const Po &a, const Po &b){return sqr(a.x - b.x) + sqr(a.y - b.y);}\r\n\r\ntemplate<class T1, class T2> inline DB dist(const T1 &x, const T2 &y){return sqrt(dist_sqr(x, y));}\r\ntemplate<class T1, class T2, class T3> inline DB dist(const T1 &x, const T2 &y, const T3 &z){return sqrt(dist_sqr(x, y, z));}\r\n\r\nDB Po::operator *(const Po &r)const{return dot(*this, r);}\r\nDB Po::operator ^(const Po &r)const{return det(*this, r);}\r\n\r\nstruct Line{\r\n    Po a, b;\r\n\r\n    Line(DB x0=0, DB y0=0, DB x1=0, DB y1=0):a(Po(x0, y0)), b(Po(x1, y1)){}\r\n    Line(const Po &a, const Po &b):a(a), b(b){}\r\n    Line(const Line &l):a(l.a), b(l.b){}\r\n\r\n    friend ostream& operator <<(ostream& out, Line p){return out << p.a << \"-\" << p.b;}\r\n    Line operator +(Po x)const{return Line(a + x, b + x);}\r\n    DB length()const{return (b-a).length();}\r\n    bool dgt()const{return (b-a).dgt();}\r\n    void input(){a.input(), b.input();}\r\n\r\n    int side(const Po& p){return dett(a, b, p);}\r\n    bool same_side(const Po& p1, const Po& p2){return side(p1) == side(p2);}\r\n    void getequation(DB& A, DB& B, DB& C) const{A = a.y - b.y, B = b.x - a.x, C = det(a, b);}\r\n};\r\n\r\nstruct Seg: Line{\r\n};\r\n\r\ninline DB dot(const Line &l1, const Line &l2){return dot(l1.b - l1.a, l2.b - l2.a);}\r\ninline DB det(const Line &l1, const Line &l2){return det(l1.b - l1.a, l2.b - l2.a);}\r\n\r\ninline DB dist_sqr(const Po &p, const Line &l){Po v0 = l.b - l.a, v1 = p - l.a; return sqr(fabs(det(v0, v1))) / v0.length_sqr();}\r\ninline DB dist_sqr(const Po &p, const Seg &l){\r\n    Po v0 = l.b - l.a, v1 = p - l.a, v2 = p - l.b;\r\n    if (sgn(dot(v0, v1)) * sgn(dot(v0, v2)) <= 0) return dist_sqr(p, Line(l));\r\n    else return min(v1.length_sqr(), v2.length_sqr());\r\n}\r\ninline DB dist_sqr(Line l, Po p){return dist_sqr(p, l);}\r\ninline DB dist_sqr(Seg l, Po p){return dist_sqr(p, l);}\r\ninline DB dist_sqr(Line l1, Line l2){\r\n    if (sgn(det(l1, l2)) != 0) return 0;\r\n    return dist_sqr(l1.a, l2);\r\n}\r\ninline DB dist_sqr(Line l1, Seg l2){\r\n    Po v0 = l1.b - l1.a, v1 = l2.a - l1.a, v2 = l2.b - l1.a; DB c1 = det(v0, v1), c2 = det(v0, v2);\r\n    return sgn(c1) != sgn(c2) ? 0 : sqr(min(fabs(c1), fabs(c2))) / v0.length_sqr();\r\n}\r\n\r\nbool isIntersect(Seg l1, Seg l2){\r\n\r\n    if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b) return true;\r\n\r\n    return\r\n        min(l1.a.x, l1.b.x) <= max(l2.a.x, l2.b.x) &&\r\n        min(l2.a.x, l2.b.x) <= max(l1.a.x, l1.b.x) &&\r\n        min(l1.a.y, l1.b.y) <= max(l2.a.y, l2.b.y) &&\r\n        min(l2.a.y, l2.b.y) <= max(l1.a.y, l1.b.y) &&\r\n    sgn( det(l1.a, l2.a, l2.b) ) * sgn( det(l1.b, l2.a, l2.b) ) <= 0 &&\r\n    sgn( det(l2.a, l1.a, l1.b) ) * sgn( det(l2.b, l1.a, l1.b) ) <= 0;\r\n\r\n}\r\n\r\ninline DB dist_sqr(Seg l1, Seg l2){\r\n    if (isIntersect(l1, l2)) return 0;\r\n    else return min(dist_sqr(l1.a, l2), dist_sqr(l1.b, l2), dist_sqr(l2.a, l1), dist_sqr(l2.b, l1));\r\n}\r\n\r\ninline bool isOnSide(const Po &p, const Seg &l){\r\n    return p == l.a || p == l.b;\r\n}\r\n\r\ninline bool isOnSeg(const Po &p, const Seg &l){\r\n    return sgn(det(p, l.a, l.b)) == 0 &&\r\n        sgn(l.a.x, p.x) * sgn(l.b.x, p.x) <= 0 && sgn(l.a.y, p.y) * sgn(l.b.y, p.y) <= 0;\r\n}\r\n\r\ninline bool isOnSegg(const Po &p, const Seg &l){\r\n    return sgn(det(p, l.a, l.b)) == 0 &&\r\n        sgn(l.a.x, p.x) * sgn(l.b.x, p.x) < 0 && sgn(l.a.y, p.y) * sgn(l.b.y, p.y) < 0;\r\n}\r\n\r\ninline Po intersect(const Line &l1, const Line &l2){\r\n    return l1.a + (l1.b - l1.a) * (det(l2.a, l1.a, l2.b) / det(l2, l1));\r\n}\r\n\r\n// perpendicular foot\r\ninline Po intersect(const Po & p, const Line &l){\r\n    return intersect(Line(p, p + Po(l.a.y - l.b.y, l.b.x - l.a.x)), l);\r\n}\r\n\r\ninline Po rotate(Po p, DB alpha, const Po &o = Po()){\r\n    p.rotate(alpha, o);\r\n    return p;\r\n}\r\n\r\n} using namespace CG;//}\r\n//}\r\n\r\n/** I/O Accelerator Interface .. **/ //{\r\ntemplate<class T> inline T& RD(T &x){\r\n    //cin >> x;\r\n    //scanf(\"%d\", &x);\r\n    char c; for (c = getchar(); c < '0'; c = getchar()); x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';\r\n    //char c; c = getchar(); x = c - '0'; for (c = getchar(); c >= '0'; c = getchar()) x = x * 10 + c - '0';\r\n    return x;\r\n}\r\n\r\ninline DB& RF(DB &x){\r\n    //cin >> x;\r\n    scanf(\"%lf\", &x);\r\n    /*char t; while ((t=getchar())==' '||t=='\\n'); x = t - '0';\r\n    while ((t=getchar())!=' '&&t!='\\n'&&t!='.')x*=10,x+=t-'0';\r\n    if (t=='.'){DB l=1; while ((t=getchar())!=' '&&t!='\\n')l*=0.1,x += (t-'0')*l;}*/\r\n    return x;\r\n}\r\n\r\ninline char* RS(char *s){\r\n    //gets(s);\r\n    scanf(\"%s\", s);\r\n    return s;\r\n}\r\n\r\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\r\n    //printf(\"Case %d: %d\\n\", ++Case, x);\r\n    printf(\"%lld \", x);\r\n    //printf(\"%d\\n\", x);\r\n    //cout << x << endl;\r\n    //last_ans = x;\r\n}\r\n//}\r\n\r\n//}/* .................................................................................................................................. */\r\n\r\nconst int N = int(6e3) + 9;\r\n\r\n#define eps EPS\r\n\r\nint n, Q, A, B;\r\nDB Y[N], ans;\r\n\r\n/*struct point{\r\n\tdouble x, y;\r\n\tinline point(){x=y=0;}\r\n\tinline point(double _x,double _y){x=_x;y=_y;}\r\n\tinline bool operator<(const point a)const{return y < a.y;}\r\n}; */\r\n\r\ntypedef pair<DB, DB> point;\r\n\r\n\r\ntypedef vector<point>vp;\r\nvp D;//Derivative\r\nvp::iterator a, b;\r\n\r\n// Inorder to find the minimum point ...\r\n// We need to run a binary search on the derived function .. .\r\n//Then easy to find (x,0)\r\n\r\ninline double get_min_point(){\r\n\tb = lower_bound(ALL(D), point(0, -OO)), a = b - 1;\r\n\treturn(b->fi * a->se - b->se * a->fi) / (b->fi - a->fi);\r\n}\r\n\r\n\r\ndouble solve(int i){\r\n\r\n\r\n    /*\r\n    cout << i << \":\";\r\n    for(vp::iterator it=D.begin();it!=D.end();it++){\r\n            cout << \"(\" << it->se << \", \" << it->fi << \") \";\r\n        //cout << it->x << \" \" it->y << \", \";\r\n\t}\r\n\tcout << endl;\r\n\t*/\r\n\r\n\r\n\tif (i == n) return min(get_min_point(), (double)Q);\r\n\r\n\tDB Xi, &Yi = Y[i]; RF(Xi);\r\n\r\n\t//(x - xi) ^2\r\n\t//x^2 - 2xix + xi^2...\r\n\t//2(x-xi)\r\n\r\n\tif (i==0){\r\n\t\tD.PB(point(-OO, 1));\r\n\t\tD.PB(point(2.0*(1-Xi), 1));\r\n\t\tD.PB(point(2.0*(Q-Xi), Q));\r\n\t\tYi = solve(i+1);\r\n\t\tans += sqr(Xi - Yi);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tDB min_point = get_min_point();\r\n\tvp::iterator pos = D.begin();\r\n\r\n\tif(A!=B){\r\n\t\t//if(fabs(up->y)<=eps)pos=D.insert(up,*up);\r\n\t\t//else{\r\n\t\t\tpos=D.insert(b,point(0, min_point));\r\n\t\t\tpos=D.insert(pos,point(0, min_point));\r\n\t\t//}\r\n\t}\r\n\r\n\tfor(vp::iterator it=D.begin();it!=D.end();){\r\n\r\n        it->se += it <= pos ? A : B; //Partition\r\n\t\tit->fi += 2 * (it->se - Xi); //Plus a linear function\r\n\r\n\t\t/*if (it->x > 8){\r\n            vp::iterator jt = it; it++;\r\n            D.erase(jt);\r\n\t\t}\r\n\t\telse {\r\n            it++;\r\n\t\t}*/\r\n\t\tit++;\r\n\t}\r\n\r\n\tYi = solve(i+1); ans += sqr(Xi - Yi);\r\n\treturn Yi < min_point + A ? Yi - A : Yi > min_point + B ? Yi - B : min_point;\r\n}\r\n\r\n\r\nint main(){\r\n\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    //freopen(\"out1.txt\", \"w\", stdout);\r\n#endif\r\n\r\n    RD(n, Q, A, B); solve(0);\r\n\r\n    REP(i, n) printf(\"%lf \", Y[i]);\r\n    printf(\"\\n%lf\",ans);\r\n}\r\n"
}