{
    "id": 23936266,
    "contestId": 280,
    "creationTimeSeconds": 1484803042,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 280,
        "index": "E",
        "name": "Sequence Transformation",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 280,
        "members": [
            {
                "handle": "tqyaaaaaaaang"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362929400
    },
    "programmingLanguage": "MS C++",
    "verdict": "WRONG_ANSWER",
    "testset": "TESTS",
    "passedTestCount": 9,
    "timeConsumedMillis": 2244,
    "memoryConsumedBytes": 4505600,
    "source": "// I/O stream\r\n#include <iostream>\r\n#include <iomanip>\r\n\r\n// Algorithms & Maths\r\n#include <cmath>\r\n#include <numeric>\r\n#include <algorithm>\r\n\r\n// C headers\r\n#include <cstdlib>\r\n#include <cstdio>\r\n\r\n// String\r\n#include <string>\r\n#include <cstring>\r\n\r\n// STL\r\n#include <vector>\r\n#include <deque>\r\n#include <list>\r\n#include <stack>\r\n#include <queue>\r\n#include <set>\r\n#include <map>\r\n#include <bitset>\r\n\r\n// Exeption\r\n#include <exception>\r\n#include <stdexcept>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\n\r\n#ifndef ONLINE_JUDGE\r\n#pragma comment ( linker, \"/STACK:10240000\" )\r\n#endif\r\n\r\n#define LL long long\r\n#define LD long double\r\n//#define double long double\r\n#define SC(t,x) static_cast<t>(x)\r\n#define AR(t) vector < t >\r\n#define PII pair < int, int >\r\n#define PLL pair < LL, LL >\r\n#define PIL pair < int, LL >\r\n#define PLI pair < LL, int >\r\n#define PDD pair < double, double >\r\n#define MP make_pair\r\n#define PB push_back\r\n#define PF push_front\r\n#define POB pop_back\r\n#define POF pop_front\r\n#define PRF first\r\n#define PRS second\r\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\r\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\r\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\r\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\r\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\r\n#define qmax(a,b) (((a)>(b))?(a):(b))\r\n#define qmin(a,b) (((a)<(b))?(a):(b))\r\n#define qabs(a) (((a)>=0)?(a):(-(a)))\r\n#define qsqr(a) ((a)*(a))\r\n\r\nconst int INF = 0x3fffffff;\r\nconst int SINF = 0x7fffffff;\r\nconst long long LINF = 0x3fffffffffffffff;\r\nconst long long SLINF = 0x7fffffffffffffff;\r\nconst double DINF = 1e100;\r\nconst int MAXN = 6007;\r\nconst int MAXL = 15007;\r\n\r\nint n, q, a, b;\r\nint xx[MAXN];\r\n\r\nclass fT\r\n{\r\npublic:\r\n\tfT () : kk ( 0 )\r\n\t{\r\n\t\tINIT ( bn, 0 );\r\n\t\tINIT ( a, 0 );\r\n\t\tINIT ( b, 0 );\r\n\t\tINIT ( c, 0 );\r\n\t}\r\n\r\n\tvoid setd ( int _a, int _b, int _c, int _l, int _r )\r\n\t{\r\n\t\tkk = 1, a[0] = _a, b[0] = _b, c[0] = _c, bn[0] = _l, bn[1] = _r;\r\n//\t\tcut ();\r\n//\t\tcalcmin ();\r\n\t}\r\n\r\n\tvoid operator += ( const fT &x )\r\n\t{\r\n\t\t( *this ) = ( *this ) + x;\r\n\t}\r\n\r\n\tfT operator + ( const fT &x ) const\r\n\t{\r\n\t\tfT ans;\r\n//\t\tset < double > s;\r\n//\t\tlp ( i, 0, kk+1 ) s.insert ( bn[i] );\r\n//\t\tlp ( i, 0, x.kk+1 ) s.insert ( x.bn[i] );\r\n\t\tint ll = qmax ( bn[0], x.bn[0] ), rr = qmin ( bn[kk], x.bn[x.kk] );\r\n\r\n//\t\tfor ( set < double > ::iterator it = s.begin (); it != s.end (); ++it )\r\n//\t\t\tif ( *it >= ll && *it <= rr ) ans.bn[ans.kk++] = *it;\r\n//\t\t--ans.kk;\r\n\r\n\t\tint i1 = 0, i2 = 0;\r\n\t\twhile ( i1 <= kk && i2 <= x.kk ){\r\n\t\t\tif ( i1 <= kk && bn[i1] < x.bn[i2] ){\r\n\t\t\t\tif ( ( !ans.kk || bn[i1] != ans.bn[ans.kk-1] ) && ( bn[i1] >= ll && bn[i1] <= rr ) ) ans.bn[ans.kk++] = bn[i1];\r\n\t\t\t\t++i1;\r\n\t\t\t}else{\r\n\t\t\t\tif ( ( !ans.kk || x.bn[i2] != ans.bn[ans.kk-1] ) && ( x.bn[i2] >= ll && x.bn[i2] <= rr ) ) ans.bn[ans.kk++] = x.bn[i2];\r\n\t\t\t\t++i2;\r\n\t\t\t}\r\n\t\t}\r\n\t\t--ans.kk;\r\n\r\n\t\tif ( !ans.kk ) ++ans.kk, ans.bn[ans.kk] = ans.bn[ans.kk-1];\r\n\r\n\t\tint id1 = 0, id2 = 0;\r\n\t\tlp ( i, 0, ans.kk ){\r\n\t\t\tif ( bn[id1+1] <= ans.bn[i] ) ++id1;\r\n\t\t\tif ( x.bn[id2+1] <= ans.bn[i] ) ++id2;\r\n\t\t\tans.a[i] = a[id1] + x.a[id2];\r\n\t\t\tans.b[i] = ( a[id1] * b[id1] + x.a[id2] * x.b[id2] ) / ans.a[i];\r\n\t\t\tans.c[i] = a[id1] * b[id1] * b[id1] + c[id1] + x.a[id2] * x.b[id2] * x.b[id2] + x.c[id2] - ans.a[i] * ans.b[i] * ans.b[i];\r\n\t\t}\r\n\r\n//\t\tans.cut ();\r\n//\t\tans.calcmin ();\r\n\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tvoid move ( int del, int rr )\r\n\t{\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tbn[i] += rr;\r\n\t\t\tif ( a[i] ) b[i] += rr;\r\n\t\t}\r\n\t\tbn[kk] += rr;\r\n\t\tminp += rr;\r\n\r\n\t\tif ( del ){\r\n\t\t\tlp ( i, 0, kk ){\r\n\t\t\t\tif ( bn[i] <= minp && bn[i+1] >= minp ){\r\n\t\t\t\t\tlpd ( j, kk, i ){\r\n\t\t\t\t\t\tbn[j+1] = bn[j];\r\n\t\t\t\t\t\ta[j] = a[j-1], b[j] = b[j-1], c[j] = c[j-1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t++kk;\r\n\t\t\t\t\tbn[i+1] = minp;\r\n\t\t\t\t\tlpd ( j, kk, i ){\r\n\t\t\t\t\t\tbn[j+1] = bn[j] + del;\r\n\t\t\t\t\t\ta[j] = a[j-1], b[j] = b[j-1] + del, c[j] = c[j-1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t++kk;\r\n//\t\t\t\t\tbn[i+2] = bn[i+1] + del;\r\n\t\t\t\t\tbn[i+2] = bn[i+1] + del;\r\n\t\t\t\t\ta[i+1] = b[i+1] = 0;\r\n\t\t\t\t\tc[i+1] = vmin;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n//\t\tcut ();\r\n//\t\tcalcmin ();\r\n\t}\r\n\r\n\tdouble f ( double x )\r\n\t{\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tif ( bn[i] <= x && x <= bn[i+1] ) return ( a[i] * qsqr ( x - b[i] ) + c[i] );\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tdouble f ( double x, int bck )\r\n\t{\r\n\t\treturn ( a[bck] * qsqr ( x - b[bck] ) + c[bck] );\r\n\t}\r\n\r\n\tvoid cut ()\r\n\t{\r\n\t\tlpi ( i, 0, kk ){\r\n\t\t\tif ( bn[i] > q ){\r\n\t\t\t\tbn[i] = q;\r\n\t\t\t\tkk = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tPDD getmin ( int l, int r )\r\n\t{\r\n\t\tif ( minp < l ) return MP ( f ( l ), l );\r\n\t\telse if ( minp > r ) return MP ( f ( r ), r );\r\n\t\telse return MP ( vmin, minp );\r\n\t}\r\n\r\n\tvoid calcmin ()\r\n\t{\r\n\t\tvmin = DINF, minp = -1;\r\n\t\tdouble now, np;\r\n\t\tlp ( i, 0, kk ){\r\n\t\t\tif ( !a[i] ) np = bn[i];\r\n\t\t\telse if ( b[i] < bn[i] ) np = bn[i];\r\n\t\t\telse if ( b[i] > bn[i+1] ) np = bn[i+1];\r\n\t\t\telse np = b[i];\r\n\t\t\tnow = f ( np, i );\r\n\t\t\tif ( now < vmin ){\r\n\t\t\t\tvmin = now, minp = np;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdouble getmp ()\r\n\t{\r\n\t\treturn minp;\r\n\t}\r\n\r\nprivate:\r\n\tint kk;\r\n\tdouble bn[MAXL], a[MAXL], b[MAXL], c[MAXL], minp, vmin;\r\n}func1, func2, tmp;\r\n\r\ndouble mp[MAXN];\r\n\r\nvoid init ();\r\nvoid input ();\r\nvoid work ();\r\n\r\ndouble getmin ( int lev, double nx );\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tinit();\r\n\tinput();\r\n\twork();\r\n}\r\n\r\n\r\n\r\nvoid init ()\r\n{\r\n\t// Init Everything Here\r\n\t\r\n\tios::sync_with_stdio ( false );\r\n}\r\n\r\nvoid input ()\r\n{\r\n\t// input method\r\n\r\n\tscanf ( \"%d%d%d%d\", &n, &q, &a, &b );\r\n\tlpi ( i, 1, n ) scanf ( \"%d\", &xx[i] );\r\n}\r\n\r\nvoid work ()\r\n{\r\n\t// main work\r\n\r\n\tfT *func = &func1, *la = &func2, *t;\r\n\tla->setd ( 1, xx[1], 0, 1, q );\r\n\tla->calcmin ();\r\n\tmp[1] = xx[1];\r\n\tlpi ( i, 2, n ){\r\n\t\t*func = *la;\r\n\t\tfunc->move ( b - a, a );\r\n\t\ttmp.setd ( 1, xx[i], 0, 1, q );\r\n\t\t*func += tmp;\r\n\r\n\t\tfunc->cut ();\r\n\t\tfunc->calcmin ();\r\n\t\tmp[i] = func->getmp ();\r\n\r\n\t\tt = func;\r\n\t\tfunc = la;\r\n\t\tla = t;\r\n\t}\r\n\r\n//\tPDD ans = la->getmin ( a*(n-1)+1, q );\r\n//\tans.first = getmin ( n, ans.second );\r\n\r\n//\tprintf ( \"%.9lf\\n%.9lf\\n\", ans.second, ans.first );\r\n\r\n\tdouble ans = getmin ( n, mp[n] );\r\n\tprintf ( \"%.9lf\\n%.9lf\\n\", mp[n], ans );\r\n}\r\n\r\n\r\n\r\ndouble getmin ( int lev, double nx )\r\n{\r\n\tif ( lev == 1 ) return qsqr ( nx - xx[1] );\r\n\r\n\tdouble tl = nx - b, tr = nx - a, cho;\r\n//\ttl = qmax( tl, 1 ), tr = qmax ( tr, 1 );\r\n\ttl = qmax ( tl, a * ( lev - 2 ) + 1 );\r\n//\tif ( tl > tr ) return LINF;\r\n\tdouble ans = qsqr ( nx - xx[lev] );\r\n\tif ( tl > mp[lev-1] ) ans += getmin ( lev-1, tl ), cho = tl;\r\n\telse if ( tr < mp[lev-1] ) ans += getmin ( lev-1, tr ), cho = tr;\r\n\telse ans += getmin ( lev-1, mp[lev-1] ), cho = mp[lev-1];\r\n\r\n\tprintf ( \"%.9lf \", cho );\r\n\r\n\treturn ans;\r\n}"
}