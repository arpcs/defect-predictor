{
    "id": 120417989,
    "contestId": 280,
    "creationTimeSeconds": 1624516718,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 280,
        "index": "E",
        "name": "Sequence Transformation",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 3000,
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math"
        ]
    },
    "author": {
        "contestId": 280,
        "members": [
            {
                "handle": "MonkeyKing"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1362929400
    },
    "programmingLanguage": "GNU C++17",
    "verdict": "COMPILATION_ERROR",
    "testset": "TESTS",
    "passedTestCount": 0,
    "timeConsumedMillis": 0,
    "memoryConsumedBytes": 0,
    "source": "//Original Code:\r\n//#include <self/utility>\r\n//#include <self/debug>\r\n//using namespace std;\r\n//int n,q,a,b;\r\n//int x[6005];\r\n//double ans[6005];\r\n//\r\n//struct F\r\n//{\r\n//\tdouble a,b,c;\r\n//\tdouble minPlace(const double &l,const double &r)const\r\n//\t{\r\n//\t\tif((r-l)<=eps) return l;\r\n//\t\tif(a==0 && b==0) return l;\r\n//\t\tif(a==0) return (b>0?l:r);\r\n//\t\tif(a>0)\r\n//\t\t{\r\n//\t\t\tdouble t=-b/a/2;\r\n//\t\t\tif(t<l) t=l;\r\n//\t\t\tif(t>r) t=r;\r\n//\t\t\treturn t;\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tdouble t=-b/a/2;\r\n//\t\t\treturn mabs(t-l)>mabs(t-r)?l:r;\r\n//\t\t}\r\n//\t}\r\n//\tdouble operator () (const double &pos)const\r\n//\t{\r\n//\t\treturn a*pos*pos+b*pos+c;\r\n//\t}\r\n//\tF shift(double xs)const{\r\n//\t\treturn F({a,-2*a*xs+b,xs*xs*a-b*xs+c});\r\n//\t}\r\n//};\r\n//F f[12005];\r\n//double w[12005];\r\n//int len;\r\n//char tr[12005][12005];\r\n//int sz[12005];\r\n//int key[12005];\r\n//\r\n//int main()\r\n//{\r\n//\tfreopen(\"input.txt\",\"r\",stdin);\r\n//\tcin>>n>>q>>a>>b;\r\n//\tfor(int i=0;i<n;i++) scanf(\"%d\",x+i);\r\n//\tf[len++]=F({0,0,0});\r\n//\tw[0]=1;\r\n//\tw[1]=q;\r\n//\tfor(int i=0;i<n;i++)\r\n//\t{\r\n//\t\tfor(int j=0;j<len;j++)\r\n//\t\t{\r\n//\t\t\tf[j].a++;\r\n//\t\t\tf[j].b-=(x[i]<<1);\r\n//\t\t\tf[j].c+=1LL*x[i]*x[i];\r\n//\t\t}\r\n//\t\tif(i==n-1) break;\r\n//\r\n//\t\t//todo: cut the function f\r\n//\t\tpair<double,int> o=mp(INFINITY,0);\r\n//\t\tfor(int j=0;j<len;j++)\r\n//\t\t{\r\n//\t\t\tdouble p=f[j].minPlace(w[j],w[j+1]);\r\n//\t\t\tchmin(o,mp(f[j](p),j));\r\n//\t\t}\r\n//\t\tint pos=o.second;\r\n//\t\tdouble xm=f[pos].minPlace(w[pos],w[pos+1]);\r\n//\t\t// assert(xm>=w[pos] && xm<=w[pos+1]);\r\n//\t\tfor(int j=len+1;j>pos+1;j--)\r\n//\t\t{\r\n//\t\t\tf[j]=f[j-2].shift(b-a);\r\n//\t\t\ttr[i][j]=-2;\r\n//\t\t\tw[j+1]=w[j-1]+(b-a);\r\n//\t\t}\r\n//\t\tw[pos+1]=xm;\r\n//\t\tw[pos+2]=xm+(b-a);\r\n//\t\tf[pos+1]=F({0,0,f[pos](xm)});\r\n//\t\ttr[i][pos+1]=-1;\r\n//\t\tlen+=2;\r\n//\t\tfor(int j=0;j<=len;j++) w[j]+=a;\r\n//\t\tfor(int j=0;j<len;j++) f[j]=f[j].shift(a);\r\n//\t\tsz[i]=len;\r\n//\t\tkey[i]=pos;\r\n//\t\twhile(w[len-1]>q) len--;\r\n//\t}\r\n//\tpair<double,pair<double,int> > res=mp(INFINITY,mp(0.0,0));\r\n//\tfor(int i=0;i<len;i++)\r\n//\t{\r\n//\t\tif(w[i]>q) break;\r\n//\t\tchmin(res,mp(f[i](f[i].minPlace(w[i],min(w[i+1],(double)q))),mp(f[i].minPlace(w[i],min(w[i+1],(double)q)),i)));\r\n//\t}\r\n//\tint pos=res.second.second;\r\n//\tans[n-1]=res.second.first;\r\n//\tfor(int i=n-2;i>=0;i--)\r\n//\t{\r\n//\t\tif(tr[i][pos]==-2)\r\n//\t\t{\r\n//\t\t\tpos-=2;\r\n//\t\t\tans[i]=ans[i+1]-b;\r\n//\t\t}\r\n//\t\telse if(tr[i][pos]==-1)\r\n//\t\t{\r\n//\t\t\tpos-=1;\r\n//\t\t\tans[i]=xm[i];\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tans[i]=ans[i+1]-a;\r\n//\t\t}\r\n//\t}\r\n//\tfor(int i=0;i<n;i++)\r\n//\t{\r\n//\t\tprintf(\"%.10f \",ans[i]);\r\n//\t}\r\n//\tcout<<endl;\r\n//\tcout.precision(10);\r\n//\tcout<<fixed;\r\n//\tcout<<res.first<<endl;\r\n//\treturn 0;\r\n//}\r\n\r\n//substituted with C++ Inliner\r\n#ifndef _SELF_UTILITY\r\n#define _SELF_UTILITY 1\r\n#include <numeric>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <vector>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <string>\r\n#include <string.h>\r\n#include <stack>\r\n#include <assert.h>\r\n#include <bitset>\r\n#include <time.h>\r\n#define Endl endl\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define ll long long \r\n#define ull unsigned long long\r\n#define pii pair<int,int>\r\n#define over(A) {cout<<A<<endl;exit(0);}\r\n#define all(A) A.begin(),A.end()\r\n#define quickcin ios_base::sync_with_stdio(false);\r\n#ifdef __TAKE_MOD\r\nint mod;\r\n#else\r\n#ifdef __TAKE_CONST_MOD\r\nconst int mod=__TAKE_CONST_MOD;\r\n#else\r\nconst int mod=1000000007;\r\n#endif\r\n#endif\r\nconst int gmod=3;\r\nconst int inf=1039074182;\r\n#ifdef __TAKE_CONST_EPS\r\nconst double eps=__TAKE_CONST_EPS;\r\n#else\r\nconst double eps=1e-9;\r\n#endif\r\nconst double pi=3.141592653589793238462643383279;\r\nconst ll llinf=2LL*inf*inf;\r\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\r\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\r\ninline void chadd(int &x,int b) {x+=b-mod;x+=(x>>31 & mod);}\r\ntemplate <typename T1,typename T2> inline void chadd(T1 &x,T2 b) {x+=b;if(x>=mod) x-=mod;}\r\ntemplate <typename T1,typename T2> inline void chmul(T1 &x,T2 b) {x=1LL*x*b%mod;}\r\ntemplate <typename T1,typename T2> inline void chmod(T1 &x,T2 b) {x%=b,x+=b;if(x>=b) x-=b;}\r\ntemplate <typename T> inline T mabs(T x) {return (x<0?-x:x);}\r\nusing namespace std;\r\n#endif\r\n#ifndef _SELF_DEBUG\r\n#define _SELF_DEBUG 1\r\n#ifndef _SELF_OPERATOR\r\n#define _SELF_OPERATOR 1\r\nusing namespace std;\r\ntemplate <typename T>\r\nostream & operator<<(ostream &cout, const vector<T> &vec)\r\n{\r\n\tcout << \"{\";\r\n\tfor (int i = 0; i < (int)vec.size(); i++)\r\n\t{\r\n\t\tcout << vec[i];\r\n\t\tif (i != (int)vec.size() - 1)\r\n\t\t\tcout << ',';\r\n\t}\r\n\tcout << \"}\";\r\n\treturn cout;\r\n}\r\n\r\ntemplate <typename T1, typename T2>\r\nostream &operator<<(ostream &cout, pair<T1, T2> p)\r\n{\r\n\tcout << \"(\" << p.first << ',' << p.second << \")\";\r\n\treturn cout;\r\n}\r\n\r\ntemplate <typename T, typename T2>\r\nostream &operator<<(ostream &cout, set<T, T2> s)\r\n{\r\n\tvector<T> t;\r\n\tfor (auto x : s)\r\n\t\tt.push_back(x);\r\n\tcout << t;\r\n\treturn cout;\r\n}\r\n\r\ntemplate <typename T, typename T2>\r\nostream &operator<<(ostream &cout, multiset<T, T2> s)\r\n{\r\n\tvector<T> t;\r\n\tfor (auto x : s)\r\n\t\tt.push_back(x);\r\n\tcout << t;\r\n\treturn cout;\r\n}\r\n\r\ntemplate <typename T>\r\nostream &operator<<(ostream &cout, queue<T> q)\r\n{\r\n\tvector<T> t;\r\n\twhile (q.size())\r\n\t{\r\n\t\tt.push_back(q.front());\r\n\t\tq.pop();\r\n\t}\r\n\tcout << t;\r\n\treturn cout;\r\n}\r\n\r\ntemplate <typename T1, typename T2, typename T3>\r\nostream &operator<<(ostream &cout, map<T1, T2, T3> m)\r\n{\r\n\tfor (auto &x : m)\r\n\t{\r\n\t\tcout << \"Key: \" << x.first << ' ' << \"Value: \" << x.second << endl;\r\n\t}\r\n\treturn cout;\r\n}\r\n\r\ntemplate <typename T1, typename T2>\r\nvoid operator+=(pair<T1, T2> &x,const pair<T1, T2> y)\r\n{\r\n\tx.first += y.first;\r\n\tx.second += y.second;\r\n}\r\ntemplate <typename T1,typename T2>\r\npair<T1,T2> operator + (const pair<T1,T2> &x,const pair<T1,T2> &y)\r\n{\r\n\treturn make_pair(x.first+y.first,x.second+y.second);\r\n}\r\n\r\ntemplate <typename T1,typename T2>\r\npair<T1,T2> operator - (const pair<T1,T2> &x,const pair<T1,T2> &y)\r\n{\r\n\treturn mp(x.first-y.first,x.second-y.second);\r\n}\r\n\r\ntemplate <typename T1, typename T2>\r\npair<T1, T2> operator-(pair<T1, T2> x)\r\n{\r\n\treturn make_pair(-x.first, -x.second);\r\n}\r\n\r\ntemplate <typename T>\r\nvector<vector<T>> operator~(vector<vector<T>> vec)\r\n{\r\n\tvector<vector<T>> v;\r\n\tint n = vec.size(), m = vec[0].size();\r\n\tv.resize(m);\r\n\tfor (int i = 0; i < m; i++)\r\n\t{\r\n\t\tv[i].resize(n);\r\n\t}\r\n\tfor (int i = 0; i < m; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < n; j++)\r\n\t\t{\r\n\t\t\tv[i][j] = vec[j][i];\r\n\t\t}\r\n\t}\r\n\treturn v;\r\n}\r\n#endif\r\n#include <sstream>\r\nvoid print0x(int x)\r\n{\r\n\tstd::vector <int> vec;\r\n\twhile(x)\r\n\t{\r\n\t\tvec.push_back(x&1);\r\n\t\tx>>=1;\r\n\t}\r\n\tstd::reverse(vec.begin(),vec.end());\r\n\tfor(int i=0;i<(int)vec.size();i++)\r\n\t{\r\n\t\tstd::cout<<vec[i];\r\n\t}\r\n\tstd::cout<<' ';\r\n}\r\n\r\ntemplate <typename T>\r\nvoid print0x(T x,int len)\r\n{\r\n\tstd::vector <int> vec;\r\n\twhile(x)\r\n\t{\r\n\t\tstd::cout<<(x&1);\r\n\t\tx>>=1;\r\n\t\tlen--;\r\n\t\t// vec.push_back(x&1);\r\n\t\t// x>>=1;\r\n\t}\r\n\twhile(len--) cout<<0;\r\n\t// reverse(vec.begin(),vec.end());\r\n\t// for(int i=(int)vec.size();i<len;i++)\r\n\t// {\r\n\t// \tputchar('0');\r\n\t// }\r\n\t// for(size_t i=0;i<vec.size();i++)\r\n\t// {\r\n\t// \tstd::cout<<vec[i];\r\n\t// }\r\n\t// std::cout<<' ';\r\n}\r\nvector<string> vec_splitter(string s) {\r\n\ts += ',';\r\n\tvector<string> res;\r\n\twhile(!s.empty()) {\r\n\t\tres.push_back(s.substr(0, s.find(',')));\r\n\t\ts = s.substr(s.find(',') + 1);\r\n\t}\r\n\treturn res;\r\n}\r\nvoid debug_out(\r\nvector<string> __attribute__ ((unused)) args,\r\n__attribute__ ((unused)) int idx, \r\n__attribute__ ((unused)) int LINE_NUM) { cerr << endl; } \r\ntemplate <typename Head, typename... Tail>\r\nvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\r\n\tif(idx > 0) cerr << \", \"; else cerr << \"Line(\" << LINE_NUM << \") \";\r\n\tstringstream ss; ss << H;\r\n\tcerr << args[idx] << \" = \" << ss.str();\r\n\tdebug_out(args, idx + 1, LINE_NUM, T...);\r\n}\r\n#define debug(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)\r\n#endif\r\nusing namespace std;\r\nint n,q,a,b;\r\nint x[6005];\r\ndouble ans[6005];\r\n\r\nstruct F\r\n{\r\n\tdouble a,b,c;\r\n\tdouble minPlace(const double &l,const double &r)const\r\n\t{\r\n\t\tif((r-l)<=eps) return l;\r\n\t\tif(a==0 && b==0) return l;\r\n\t\tif(a==0) return (b>0?l:r);\r\n\t\tif(a>0)\r\n\t\t{\r\n\t\t\tdouble t=-b/a/2;\r\n\t\t\tif(t<l) t=l;\r\n\t\t\tif(t>r) t=r;\r\n\t\t\treturn t;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdouble t=-b/a/2;\r\n\t\t\treturn mabs(t-l)>mabs(t-r)?l:r;\r\n\t\t}\r\n\t}\r\n\tdouble operator () (const double &pos)const\r\n\t{\r\n\t\treturn a*pos*pos+b*pos+c;\r\n\t}\r\n\tF shift(double xs)const{\r\n\t\treturn F({a,-2*a*xs+b,xs*xs*a-b*xs+c});\r\n\t}\r\n};\r\nF f[12005];\r\ndouble w[12005];\r\nint len;\r\nchar tr[12005][12005];\r\nint sz[12005];\r\nint key[12005];\r\n\r\nint main()\r\n{\r\n//\tfreopen(\"input.txt\",\"r\",stdin);\r\n\tcin>>n>>q>>a>>b;\r\n\tfor(int i=0;i<n;i++) scanf(\"%d\",x+i);\r\n\tf[len++]=F({0,0,0});\r\n\tw[0]=1;\r\n\tw[1]=q;\r\n\tfor(int i=0;i<n;i++)\r\n\t{\r\n\t\tfor(int j=0;j<len;j++)\r\n\t\t{\r\n\t\t\tf[j].a++;\r\n\t\t\tf[j].b-=(x[i]<<1);\r\n\t\t\tf[j].c+=1LL*x[i]*x[i];\r\n\t\t}\r\n\t\tif(i==n-1) break;\r\n\r\n\t\t//todo: cut the function f\r\n\t\tpair<double,int> o=mp(INFINITY,0);\r\n\t\tfor(int j=0;j<len;j++)\r\n\t\t{\r\n\t\t\tdouble p=f[j].minPlace(w[j],w[j+1]);\r\n\t\t\tchmin(o,mp(f[j](p),j));\r\n\t\t}\r\n\t\tint pos=o.second;\r\n\t\tdouble xm=f[pos].minPlace(w[pos],w[pos+1]);\r\n\t\t// assert(xm>=w[pos] && xm<=w[pos+1]);\r\n\t\tfor(int j=len+1;j>pos+1;j--)\r\n\t\t{\r\n\t\t\tf[j]=f[j-2].shift(b-a);\r\n\t\t\ttr[i][j]=-2;\r\n\t\t\tw[j+1]=w[j-1]+(b-a);\r\n\t\t}\r\n\t\tw[pos+1]=xm;\r\n\t\tw[pos+2]=xm+(b-a);\r\n\t\tf[pos+1]=F({0,0,f[pos](xm)});\r\n\t\ttr[i][pos+1]=-1;\r\n\t\tlen+=2;\r\n\t\tfor(int j=0;j<=len;j++) w[j]+=a;\r\n\t\tfor(int j=0;j<len;j++) f[j]=f[j].shift(a);\r\n\t\tsz[i]=len;\r\n\t\tkey[i]=pos;\r\n\t\twhile(w[len-1]>q) len--;\r\n\t}\r\n\tpair<double,pair<double,int> > res=mp(INFINITY,mp(0.0,0));\r\n\tfor(int i=0;i<len;i++)\r\n\t{\r\n\t\tif(w[i]>q) break;\r\n\t\tchmin(res,mp(f[i](f[i].minPlace(w[i],min(w[i+1],(double)q))),mp(f[i].minPlace(w[i],min(w[i+1],(double)q)),i)));\r\n\t}\r\n\tint pos=res.second.second;\r\n\tans[n-1]=res.second.first;\r\n\tfor(int i=n-2;i>=0;i--)\r\n\t{\r\n\t\tif(tr[i][pos]==-2)\r\n\t\t{\r\n\t\t\tpos-=2;\r\n\t\t\tans[i]=ans[i+1]-b;\r\n\t\t}\r\n\t\telse if(tr[i][pos]==-1)\r\n\t\t{\r\n\t\t\tpos-=1;\r\n\t\t\tans[i]=xm[i];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tans[i]=ans[i+1]-a;\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<n;i++)\r\n\t{\r\n\t\tprintf(\"%.10f \",ans[i]);\r\n\t}\r\n\tcout<<endl;\r\n\tcout.precision(10);\r\n\tcout<<fixed;\r\n\tcout<<res.first<<endl;\r\n\treturn 0;\r\n}\r\n"
}