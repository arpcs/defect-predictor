{
    "id": 214370763,
    "contestId": 1822,
    "creationTimeSeconds": 1689692446,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1822,
        "index": "G2",
        "name": "Magic Triples (Hard Version)",
        "type": "PROGRAMMING",
        "rating": 2200,
        "tags": [
            "brute force",
            "data structures",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1822,
        "members": [
            {
                "handle": "gentoopenguinbird"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682346900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 71,
    "timeConsumedMillis": 1606,
    "memoryConsumedBytes": 73523200,
    "source": "#include <bits/stdc++.h>\r\n\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\n#define int int64_t\r\n#define ALL(x) (x).begin(), (x).end()\r\n\r\nusing i32 = int32_t;\r\nusing i64 = int64_t;\r\nusing i128 = __int128_t;\r\n\r\nusing u32 = uint32_t;\r\nusing u64 = uint64_t;\r\nusing u128 = __uint128_t;\r\n\r\nusing namespace std;\r\nusing vi = vector<int>;\r\nusing vvi = vector<vector<int>>;\r\nusing pii = pair<int, int>;\r\nusing vpii = vector<pii>;\r\ntemplate <typename K, typename V, typename Hash = std::hash<K>>\r\nusing umap = unordered_map<K, V, Hash>;\r\ntemplate <typename K, typename Hash = std::hash<K>>\r\nusing uset = unordered_set<K, Hash>;\r\n\r\nusing namespace __gnu_pbds;\r\ntemplate <typename K, typename V>\r\nusing ordmap = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\r\ntemplate <typename K>\r\nusing ordset = ordmap<K, null_type>;\r\n// use pair of ints for multiset, the second element needs to be unique (e.g. just use a counter).\r\n\r\ntemplate <typename... Ts>\r\nstruct Overload : Ts... {\r\n  using Ts::operator()...;\r\n};\r\ntemplate <class... Ts>\r\nOverload(Ts...) -> Overload<Ts...>;\r\n\r\n// helpers\r\nnamespace {\r\n\r\nstring InStr(int n = 0) {\r\n  (void)n;\r\n  string a;\r\n  cin >> a;\r\n  return a;\r\n}\r\n\r\nint InInt() {\r\n  int a;\r\n  cin >> a;\r\n  return a;\r\n}\r\n\r\nvi InVec(int n) {\r\n  vi a(n);\r\n  for (int i = 0; i < n; i++) a[i] = InInt();\r\n  return a;\r\n}\r\n\r\nint PosInf() { return numeric_limits<int>::max(); }\r\nint NegInf() { return numeric_limits<int>::min(); }\r\n\r\nvoid OutSln(bool b) { cout << (b ? \"YES\" : \"NO\"); }\r\nvoid OutSln(int x) { cout << x; }\r\ntemplate <typename T1, typename T2>\r\nvoid OutSln(pair<T1, T2> p) {\r\n  OutSln(p.first);\r\n  cout << \" \";\r\n  OutSln(p.second);\r\n}\r\ntemplate <typename T>\r\nvoid OutSln(const vector<T>& v) {\r\n  for (int i = 0; i < ssize(v); i++) {\r\n    OutSln(v[i]);\r\n    if (i < ssize(v) - 1) cout << \"\\n\";\r\n  }\r\n}\r\n\r\nint PowInt(int base, int exp) {\r\n  if (exp == 0) return 1;\r\n  if (exp == 1) return base;\r\n  int tmp = PowInt(base, exp / 2);\r\n  return (tmp * tmp) * (exp % 2 == 0 ? 1 : base);\r\n}\r\n\r\n// ostream\r\nnamespace {\r\n\r\ntemplate <typename A, typename B>\r\nostream& operator<<(ostream& os, const pair<A, B>& p) {\r\n  return os << '(' << p.first << \", \" << p.second << ')';\r\n}\r\ntemplate <typename T>\r\nostream& OutputCollection(ostream& os, const T& collection, char s, char e) {\r\n  os << s;\r\n  string separator;\r\n  for (const auto& x : collection) {\r\n    os << separator << x;\r\n    separator = \", \";\r\n  }\r\n  return os << e;\r\n}\r\n\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const vector<T>& v) {\r\n  return OutputCollection(os, v, '[', ']');\r\n}\r\ntemplate <typename T, size_t size>\r\nostream& operator<<(ostream& os, const array<T, size>& arr) {\r\n  return OutputCollection(os, arr, '[', ']');\r\n}\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const set<T>& s) {\r\n  return OutputCollection(os, s, '{', '}');\r\n}\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const unordered_set<T>& s) {\r\n  return OutputCollection(os, s, '{', '}');\r\n}\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const multiset<T>& s) {\r\n  return OutputCollection(os, s, '{', '}');\r\n}\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const unordered_multiset<T>& s) {\r\n  return OutputCollection(os, s, '{', '}');\r\n}\r\ntemplate <typename K, typename V>\r\nostream& operator<<(ostream& os, const map<K, V>& m) {\r\n  return OutputCollection(os, m, '{', '}');\r\n}\r\ntemplate <typename K, typename V>\r\nostream& operator<<(ostream& os, const unordered_map<K, V>& m) {\r\n  return OutputCollection(os, m, '{', '}');\r\n}\r\n\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const priority_queue<T>& pq) {\r\n  priority_queue<T> copy = pq;\r\n  vector<T> v;\r\n  while (!copy.empty()) {\r\n    v.push_back(copy.top());\r\n    copy.pop();\r\n  }\r\n  return os << v;\r\n}\r\n\r\n}  // namespace\r\n\r\n// hashing\r\nnamespace {\r\n\r\ntemplate <class T>\r\ninline void HashCombine(std::size_t& seed, const T& v) {\r\n  seed ^= std::hash<T>{}(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\r\n}\r\n\r\ntemplate <typename T, size_t N>\r\nstruct ArrayHash {\r\n  size_t operator()(const array<T, N>& a) const {\r\n    size_t seed = 0;\r\n    for (auto e : a) HashCombine(seed, e);\r\n    return seed;\r\n  }\r\n};\r\n\r\nstruct PairHash {\r\n  size_t operator()(const pii& a) const {\r\n    size_t seed = 0;\r\n    HashCombine(seed, a.first);\r\n    HashCombine(seed, a.second);\r\n    return seed;\r\n  }\r\n};\r\n\r\n}  // namespace\r\n\r\n// permutations and combinations, factorials, primes\r\nnamespace {\r\n\r\n// DON'T FORGET TO CHANGE_THIS\r\nconstexpr int kThePrime = 1000000007LL;\r\n\r\n// x*y mod prime\r\n[[nodiscard]] int mul_mod(int x, int y) { return (x * y) % kThePrime; }\r\n// 1/x mod prime\r\n[[nodiscard]] int inv_mod(int x) {\r\n  auto binpow = [](int x, int y) {\r\n    int z = 1;\r\n    while (y) {\r\n      if (y % 2 == 1) z = mul_mod(z, x);\r\n      x = mul_mod(x, x);\r\n      y /= 2;\r\n    }\r\n    return z;\r\n  };\r\n  return binpow(x, kThePrime - 2);\r\n}\r\n// x/y mod prime\r\n[[nodiscard]] int div_mod(int x, int y) { return mul_mod(x, inv_mod(y)); }\r\n\r\n[[nodiscard]] int nChoosek(int n, int k) {\r\n  if (k > n) return 0;\r\n  if (k == 0 || k == n) return 1;\r\n\r\n  if (k > n - k) k = n - k;\r\n  int ret = 1;\r\n  for (int i = 0; i < k; i++) {\r\n    ret *= n - i;\r\n    ret /= i + 1;\r\n  }\r\n  return ret;\r\n}\r\n\r\n[[nodiscard]] int nChoosek_mod(int n, int k) {\r\n  if (k > n) return 0;\r\n  if (k == 0 || k == n) return 1;\r\n\r\n  if (k > n - k) k = n - k;\r\n  int ret = 1;\r\n  for (int i = 0; i < k; i++) {\r\n    ret = mul_mod(ret, n - i);\r\n    ret = div_mod(ret, i + 1);\r\n  }\r\n  return ret;\r\n}\r\n\r\n[[nodiscard]] int fact(int n) {\r\n  int ret = 1;\r\n  for (int i = 1; i <= n; i++) ret *= i;\r\n  return ret;\r\n}\r\n\r\n// Compute n! % prime\r\n[[nodiscard]] int fact_mod(int n) {\r\n  if (n >= kThePrime) return 0;\r\n  int ret = 1;\r\n  for (int i = 1; i <= n; i++) ret = mul_mod(ret, i);\r\n  return ret;\r\n}\r\n\r\n// https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html\r\nconstexpr int kMaxPrime = 31623;  // largest number you want to check primality\r\n\r\nvector<bool> is_prime = vector<bool>(kMaxPrime + 1, true);\r\nvector<i32> primes;\r\nvector<pair<i32, i32>> factorization;\r\nvector<i32> factors;\r\n\r\nstruct Primes {\r\n  Primes() {\r\n    is_prime[0] = is_prime[1] = false;\r\n    for (i32 i = 2; i <= kMaxPrime; i++) {\r\n      if (!is_prime[i]) continue;\r\n      primes.push_back(i);\r\n      for (i32 j = i * i; j <= kMaxPrime; j += i) is_prime[j] = false;\r\n    }\r\n  }\r\n\r\n  // https://cp-algorithms.com/algebra/factorization.html#wheel-factorization\r\n  // Must have n < kMaxPrime^2\r\n  static vector<pair<i32, i32>>& PrimeFactorize(i32 n) {\r\n    factorization.clear();\r\n    for (i32 p : primes) {\r\n      if (p * p > (i32)n) break;\r\n      if (n % p == 0) factorization.emplace_back(p, 0);\r\n      while (n % p == 0) {\r\n        factorization.back().second++;\r\n        n /= p;\r\n      }\r\n    }\r\n    if (n > 1) factorization.emplace_back(n, 1);\r\n    return factorization;\r\n  }\r\n\r\n  // Return all integers that divide n, include 1 and n.\r\n  // Factors will NOT be in sorted order.\r\n  static vector<i32>& GetAllFactors(i32 n) {\r\n    auto& prime_factors = PrimeFactorize(n);\r\n    factors.clear();\r\n    GetAllFactorsHelper(prime_factors, 0, 1);\r\n    return factors;\r\n  }\r\n\r\n private:\r\n  static void GetAllFactorsHelper(const vector<pair<i32, i32>>& prime_factors, i32 i, i32 cur) {\r\n    if (i == ssize(prime_factors)) {\r\n      factors.push_back((i32)cur);\r\n      return;\r\n    }\r\n    for (int j = 0; j <= prime_factors[i].second; j += 1) {\r\n      GetAllFactorsHelper(prime_factors, i + 1, cur);\r\n      cur *= prime_factors[i].first;\r\n    }\r\n  }\r\n};\r\n\r\n}  // namespace\r\n\r\n// Bits\r\nnamespace {\r\n\r\n[[nodiscard]] bool IsBitSet(u64 a, u64 bit) { return ((a >> bit) & 1ULL) != 0; }\r\n[[nodiscard]] u64 SetBit(u64 a, u64 bit) { return a | 1ULL << bit; }\r\n[[nodiscard]] u64 ClrBit(u64 a, u64 bit) { return a & ~(1ULL << bit); }\r\n// Undefined for v=0 since it has no most significant bit.\r\n[[nodiscard]] u64 Msb(u64 v) { return 63ULL - __builtin_clzll(v); }\r\n[[nodiscard]] bool IsPow2(int x) { return x > 0 && !(x & (x - 1LL)); }\r\n[[nodiscard]] u64 NextPow2(u64 x) { return x == 1 ? 1 : 1 << (64ULL - __builtin_clzll(x - 1ULL)); }\r\n\r\n}  // namespace\r\n\r\n// Aho string matching.\r\n\r\nnamespace {\r\n\r\nstruct Aho {\r\n  struct Node {\r\n    Node(int i, int parent, int curchar, const string& str)\r\n        : i(i), parent(parent), curchar(curchar), pathview(str.data(), (size_t)(i + 1)) {\r\n      fill(ALL(next), -1);\r\n    }\r\n\r\n    Node* Next(vector<Node>& aho_nodes, int c) {\r\n      if (c == -1) return nullptr;\r\n      return &aho_nodes[next[c]];\r\n    }\r\n    Node* Parent(vector<Node>& aho_nodes) {\r\n      if (parent == -1) return nullptr;\r\n      return &aho_nodes[parent];\r\n    }\r\n    Node* SuffixLink(vector<Node>& aho_nodes) {\r\n      if (suffix_link == -1) return nullptr;\r\n      return &aho_nodes[suffix_link];\r\n    }\r\n    Node* DictSuffixLink(vector<Node>& aho_nodes) {\r\n      if (dict_suffix_link == -1) return nullptr;\r\n      return &aho_nodes[dict_suffix_link];\r\n    }\r\n\r\n    array<int, 26> next;\r\n\r\n    const int i;\r\n    const int parent;\r\n    const int curchar;\r\n    const string_view pathview;  // only valid if you keep all the original strings alive\r\n\r\n    int suffix_link = -1;\r\n    int dict_suffix_link = -1;\r\n\r\n    bool word_ends_here = false;\r\n  };\r\n\r\n  vector<Node> nodes;\r\n  Node* root = nullptr;\r\n\r\n  explicit Aho(int max_nodes) {\r\n    nodes.reserve(max_nodes);\r\n    nodes.emplace_back(0, -1, -1, \"\");  // add a root node\r\n    root = nodes.data();\r\n  }\r\n\r\n  int Insert(const string& str) {\r\n    Node* n = root;\r\n    for (int i = 0; i < ssize(str); i++) {\r\n      int c = str[i] - 'a';\r\n      if (n->next[c] == -1) {\r\n        nodes.emplace_back(nodes.size(), n->i, c, str);\r\n        n->next[c] = nodes.back().i;\r\n      }\r\n      n = n->Next(nodes, c);\r\n    }\r\n    n->word_ends_here = true;\r\n    return n->i;\r\n  }\r\n\r\n  void SetSuffixLinks() {\r\n    queue<Node*> q;\r\n    for (int node : root->next) {\r\n      if (node != -1) q.push(&nodes[node]);\r\n    }\r\n\r\n    for (int c = 0; c < 26; c++) {\r\n      if (root->next[c] == -1) root->next[c] = root->i;\r\n    }\r\n\r\n    while (!q.empty()) {\r\n      Node* n = q.front();\r\n      q.pop();\r\n\r\n      for (int child : n->next) {\r\n        if (child != -1) q.push(&nodes[child]);\r\n      }\r\n\r\n      if (n->Parent(nodes)->suffix_link == -1)\r\n        n->suffix_link = root->i;\r\n      else\r\n        n->suffix_link = n->Parent(nodes)->SuffixLink(nodes)->next[n->curchar];\r\n\r\n      for (int c = 0; c < 26; c++) {\r\n        if (n->next[c] == -1) {\r\n          if (n->suffix_link != -1)\r\n            n->next[c] = n->SuffixLink(nodes)->next[c];\r\n          else\r\n            n->next[c] = root->i;\r\n        }\r\n      }\r\n\r\n      if (n->suffix_link != -1 && n->SuffixLink(nodes)->word_ends_here)\r\n        n->dict_suffix_link = n->suffix_link;\r\n      else if (n->suffix_link != -1)\r\n        n->dict_suffix_link = n->SuffixLink(nodes)->dict_suffix_link;\r\n    }\r\n  }\r\n};\r\n}  // namespace\r\n\r\nstruct UnionFind {\r\n  vi parent;\r\n  vi size;\r\n\r\n  explicit UnionFind(int n) : parent(n), size(n, 1) {\r\n    for (int i = 0; i < n; i++) parent[i] = i;\r\n  }\r\n\r\n  int FindRoot(int i) {\r\n    if (i == parent[i]) return i;\r\n    parent[i] = FindRoot(parent[i]);\r\n    return parent[i];\r\n  }\r\n\r\n  void MergeSets(int a, int b) {\r\n    a = FindRoot(a);\r\n    b = FindRoot(b);\r\n    if (a == b) return;\r\n\r\n    if (size[a] < size[b]) swap(a, b);\r\n    parent[b] = a;\r\n    size[a] += size[b];\r\n  }\r\n\r\n  bool IsFullyMerged() {\r\n    int i = 0;\r\n    while (parent[i] != i) i = parent[i];\r\n    return size[i] == ssize(size);\r\n  }\r\n};\r\n\r\n// StrongComponents\r\nnamespace {\r\n\r\nvoid dfs1(const vvi& adj, int v, vector<bool>& visited, vi& order) {\r\n  if (visited[v]) return;\r\n  visited[v] = true;\r\n  for (int u : adj[v]) dfs1(adj, u, visited, order);\r\n  order.push_back(v);\r\n}\r\n\r\nbool dfs2(const vvi& adj_rev, int v, int c, vi& component) {\r\n  if (component[v] != -1) return false;\r\n  component[v] = c;\r\n  for (auto u : adj_rev[v]) dfs2(adj_rev, u, c, component);\r\n  return true;\r\n}\r\n\r\nvvi AdjRev(const vvi& adj) {\r\n  vvi adj_rev(adj.size());\r\n  for (int i = 0; i < ssize(adj); i++) {\r\n    for (int v : adj[i]) adj_rev[v].push_back(i);\r\n  }\r\n  return adj_rev;\r\n}\r\n\r\n// Returns a vector the same size as the number of nodes in the graph. The number at each index in the returned vector is the\r\n// component of that graph node. The component numbers are just sequential.\r\nvi StrongComponents(const vvi& adj) {\r\n  vi reverse_order = [&adj]() {\r\n    vector<bool> visited(adj.size(), false);\r\n    vi order;\r\n    for (int i = 0; i < ssize(adj); i++) dfs1(adj, i, visited, order);\r\n    reverse(ALL(order));\r\n    return order;\r\n  }();\r\n\r\n  vvi adj_rev = AdjRev(adj);\r\n  vi component(adj.size(), -1);\r\n  int c = 0;\r\n  for (int v : reverse_order) c += dfs2(adj_rev, v, c, component);\r\n  return component;\r\n}\r\n\r\n}  // namespace\r\n\r\n// https://cp-algorithms.com/graph/bipartite-check.html#algorithm\r\nbool IsBipartite(const vvi& adj) {\r\n  int n = ssize(adj);\r\n  vector<int> side(n, -1);\r\n  bool is_bipartite = true;\r\n  queue<int> q;\r\n  for (int st = 0; st < n; ++st) {\r\n    if (side[st] == -1) {\r\n      q.push(st);\r\n      side[st] = 0;\r\n      while (!q.empty()) {\r\n        int v = q.front();\r\n        q.pop();\r\n        for (int u : adj[v]) {\r\n          if (side[u] == -1) {\r\n            side[u] = side[v] ^ 1;\r\n            q.push(u);\r\n          } else {\r\n            is_bipartite &= side[u] != side[v];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return is_bipartite;\r\n}\r\n\r\n// This assumes that the path exists.\r\nvi EulerTrailOrCircuitHelper(int start, const vvi& input_adj, bool is_directed) {\r\n  vector<unordered_multiset<int>> adj(input_adj.size());\r\n  for (int i = 0; i < ssize(input_adj); ++i) adj[i] = {input_adj[i].begin(), input_adj[i].end()};\r\n\r\n  stack<int> st;\r\n  st.push(start);\r\n  vi ans;\r\n  ans.reserve(adj.size());\r\n\r\n  while (!st.empty()) {\r\n    int v = st.top();\r\n    if (adj[v].empty()) {\r\n      ans.push_back(v);\r\n      st.pop();\r\n    } else {\r\n      int x = *adj[v].begin();\r\n      adj[v].erase(adj[v].find(x));\r\n      if (!is_directed) adj[x].erase(adj[x].find(v));\r\n      st.push(x);\r\n    }\r\n  }\r\n  // TODO why is this necessary???\r\n  if (is_directed) reverse(ALL(ans));\r\n\r\n  return ans;\r\n}\r\n\r\n// If we find a circuit instead of a trail we will use circuit_start_point as the start of the circuit.\r\n// A trail will always have a defined start point, so we ignore circuit_start_point.\r\n// For undirected graphs, we may return a partial cycle. The caller should call again with the start point of a remaining vertex\r\n// to get another partial cycle until the whole graph is coverted.\r\noptional<vi> EulerTrailOrCircuit(const vvi& adj, int circuit_start_point, bool is_directed) {\r\n  optional<int> start;\r\n  optional<int> end;\r\n\r\n  if (is_directed) {\r\n    vvi rev_adj(adj.size());\r\n    for (int i = 0; i < ssize(adj); ++i) {\r\n      for (int x : adj[i]) rev_adj[x].push_back(i);\r\n    }\r\n\r\n    for (int i = 0; i < ssize(adj); ++i) {\r\n      int outdeg = ssize(adj[i]);\r\n      int indeg = ssize(rev_adj[i]);\r\n\r\n      if (outdeg == indeg) continue;\r\n\r\n      if (outdeg - indeg == 1) {\r\n        if (start.has_value()) return nullopt;\r\n        start = i;\r\n      } else if (indeg - outdeg == 1) {\r\n        if (end.has_value()) return nullopt;\r\n        end = i;\r\n      } else {\r\n        return nullopt;\r\n      }\r\n    }\r\n  } else {\r\n    for (int i = 0; i < ssize(adj); ++i) {\r\n      if (adj[i].size() % 2 == 0) continue;\r\n      if (start.has_value() && end.has_value()) return nullopt;\r\n\r\n      if (!start.has_value()) {\r\n        start = i;\r\n      } else {\r\n        end = i;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check if we have a circuit\r\n  if (!start.has_value() && !end.has_value() && !is_directed) {\r\n    return EulerTrailOrCircuitHelper(circuit_start_point, adj, is_directed);\r\n  }\r\n  if (!start.has_value() && !end.has_value()) {\r\n    start = circuit_start_point;\r\n    end = circuit_start_point;\r\n    // intentionally fall through to the below condition to check that the circuit covers the whole graph.\r\n  }\r\n\r\n  if (start.has_value() && end.has_value()) {\r\n    // https://math.stackexchange.com/questions/1871065/euler-path-for-directed-graph\r\n    // step 4: Check if the printed cycle has sufficient number of edges included or not. If not then the original graph might be\r\n    // disconnected and Euler Path can't exist in this case.\r\n    vvi adj_copy = adj;\r\n    if (start != end) {\r\n      if (is_directed) {\r\n        adj_copy[*end].push_back(*start);\r\n      } else {\r\n        adj_copy[*end].push_back(*start);\r\n        adj_copy[*start].push_back(*end);\r\n      }\r\n    }\r\n    vi circuit = EulerTrailOrCircuitHelper(*start, adj_copy, true);\r\n\r\n    vector<bool> found(adj.size(), false);\r\n    for (int x : circuit) found[x] = true;\r\n    for (bool b : found) {\r\n      if (!b) return nullopt;\r\n    }\r\n    return EulerTrailOrCircuitHelper(*start, adj, true);\r\n  }\r\n\r\n  return nullopt;\r\n}\r\n\r\ntemplate <typename Sum>\r\nclass SegTree {\r\n  using Container = typename Sum::ContainerType;\r\n  using ValType = typename Sum::ValType;\r\n\r\n public:\r\n  struct Node {\r\n    int first = -1;\r\n    int last = -1;\r\n\r\n    Sum sum;\r\n\r\n    Node* l = nullptr;\r\n    Node* r = nullptr;\r\n  };\r\n\r\n  Node* root = nullptr;\r\n\r\n  explicit SegTree(const Container& c) {\r\n    nodes_.reserve(2 * c.size());\r\n    root = Build(0, c.size() - 1, c);\r\n  }\r\n\r\n  void Update(int k, ValType val) { UpdateHelper(root, k, val); }\r\n\r\n  Sum GetSum(int first, int last) { return GetSumHelper(root, first, last); }\r\n\r\n private:\r\n  vector<Node> nodes_;\r\n\r\n  void UpdateHelper(Node* node, int k, ValType val) {\r\n    if (k == node->first && k == node->last) {\r\n      node->sum = Sum::Init(val);\r\n      return;\r\n    }\r\n    if (k <= node->l->last)\r\n      UpdateHelper(node->l, k, val);\r\n    else\r\n      UpdateHelper(node->r, k, val);\r\n\r\n    node->sum = Sum::Combine(node->l->sum, node->r->sum);\r\n  }\r\n\r\n  Sum GetSumHelper(Node* node, int first, int last) {\r\n    if (node->first == first && node->last == last) return node->sum;\r\n\r\n    if (first >= node->r->first) return GetSumHelper(node->r, first, last);\r\n    if (last <= node->l->last) return GetSumHelper(node->l, first, last);\r\n\r\n    return Sum::Combine(GetSumHelper(node->l, first, node->l->last), GetSumHelper(node->r, node->r->first, last));\r\n  }\r\n\r\n  Node* Build(int first, int last, const Container& c) {\r\n    nodes_.emplace_back();\r\n    Node* node = &nodes_.back();\r\n    node->first = first;\r\n    node->last = last;\r\n\r\n    int sz = last - first + 1;\r\n\r\n    if (sz == 1) {\r\n      node->sum = Sum::Init(c[first]);\r\n      return node;\r\n    }\r\n\r\n    int lsz = (sz + 1) / 2;\r\n    int rsz = sz / 2;\r\n\r\n    node->l = Build(first, first + lsz - 1, c);\r\n    node->r = Build(first + lsz, first + lsz + rsz - 1, c);\r\n\r\n    node->sum = Sum::Combine(node->l->sum, node->r->sum);\r\n\r\n    return node;\r\n  }\r\n};\r\n\r\nstruct MergeSortSeg {\r\n  using ContainerType = vi;\r\n  using ValType = ContainerType::value_type;\r\n\r\n  vi nums;\r\n\r\n  static MergeSortSeg Init(ValType a) {\r\n    MergeSortSeg node;\r\n    node.nums.push_back(a);\r\n    return node;\r\n  }\r\n\r\n  static MergeSortSeg Combine(const MergeSortSeg& l, const MergeSortSeg& r) {\r\n    MergeSortSeg s;\r\n    s.nums = vi(l.nums.size() + r.nums.size());\r\n    merge(ALL(l.nums), ALL(r.nums), s.nums.begin());\r\n    return s;\r\n  }\r\n};\r\n\r\nusing MergeSortTree = SegTree<MergeSortSeg>;\r\n\r\nint CountSmaller(MergeSortTree::Node* node, int first, int last, int x) {\r\n  if (node->first == first && node->last == last) return lower_bound(ALL(node->sum.nums), x) - node->sum.nums.begin();\r\n\r\n  if (first >= node->r->first) return CountSmaller(node->r, first, last, x);\r\n  if (last <= node->l->last) return CountSmaller(node->l, first, last, x);\r\n\r\n  return CountSmaller(node->l, first, node->l->last, x) + CountSmaller(node->r, node->r->first, last, x);\r\n}\r\n\r\n// grid neighbors, north, south, east, west.\r\narray<pii, 4> neighbors(int x, int y) { return {pii{x, y + 1}, {x, y - 1}, {x + 1, y}, {x - 1, y}}; }\r\n\r\n// works for positive numbers only\r\nint DivCeil(int p, int q) { return p / q + (p % q != 0); }\r\n\r\n//-------------------------------------------------------------------------------------------------------------------------------\r\n\r\nvector<complex<double>> FftHelper(const vector<complex<double>>& p, bool inverse_fft) {\r\n  using cd = complex<double>;\r\n\r\n  int n = ssize(p);\r\n  if (n == 1) return p;\r\n\r\n  vector<cd> pe;\r\n  vector<cd> po;\r\n  pe.reserve(n / 2);\r\n  po.reserve(n / 2);\r\n  for (int j = 0; j < n; j += 2) {\r\n    pe.push_back(p[j]);\r\n    po.push_back(p[j + 1]);\r\n  }\r\n  auto ye = FftHelper(pe, inverse_fft);\r\n  auto yo = FftHelper(po, inverse_fft);\r\n\r\n  vector<cd> y(n);\r\n  double ang = 2 * numbers::pi / (double)n * (inverse_fft ? -1 : 1);\r\n  const cd w(cos(ang), sin(ang));\r\n  cd w_j(1);\r\n  for (int j = 0; j < n / 2; ++j) {\r\n    y[j] = ye[j] + w_j * yo[j];\r\n    y[j + n / 2] = ye[j] - w_j * yo[j];\r\n    if (inverse_fft) {\r\n      y[j] /= 2;\r\n      y[j + n / 2] /= 2;\r\n    }\r\n    w_j *= w;\r\n  }\r\n  return y;\r\n}\r\n\r\nvector<complex<double>> Fft(const vector<complex<double>>& p) { return FftHelper(p, /*inverse_fft=*/false); }\r\nvector<complex<double>> FftInverse(const vector<complex<double>>& p) { return FftHelper(p, /*inverse_fft=*/true); }\r\n\r\nvi PolynomialMultiply(const vi& a, const vi& b) {\r\n  using cd = complex<double>;\r\n  vector<cd> fa(a.begin(), a.end());\r\n  vector<cd> fb(b.begin(), b.end());\r\n  int poly_sz = ssize(fa) + ssize(fb);\r\n  if (!IsPow2(poly_sz)) poly_sz = (int)(1ULL << (1ULL + Msb(poly_sz)));\r\n  fa.resize(poly_sz);\r\n  fb.resize(poly_sz);\r\n  fa = Fft(fa);\r\n  fb = Fft(fb);\r\n  vector<cd> fab(fa.size());\r\n  for (int i = 0; i < ssize(fa); i++) fab[i] = fa[i] * fb[i];\r\n  fab = FftInverse(fab);\r\n\r\n  vector<int> result(fab.size());\r\n  for (int i = 0; i < ssize(fab); i++) result[i] = (int)std::round(fab[i].real());\r\n  return result;\r\n}\r\n\r\nenum class BinarySearchDirection {\r\n  kLowerIsBetter,\r\n  kHigherIsBetter,\r\n};\r\n// Find the optimium value in the range [l, r] where works_fn returns true\r\noptional<int> BinarySearchOptimize(int l, int r, BinarySearchDirection direction, const std::function<bool(int)>& works_fn) {\r\n  optional<int> best;\r\n\r\n  while (r >= l) {\r\n    const int mid = midpoint(l, r);\r\n    const bool works = works_fn(mid);\r\n    if (works) best = mid;\r\n    const bool go_left = (works && (direction == BinarySearchDirection::kLowerIsBetter)) ||\r\n                         (!works && (direction == BinarySearchDirection::kHigherIsBetter));\r\n    if (go_left)\r\n      r = mid - 1;\r\n    else\r\n      l = mid + 1;\r\n  }\r\n\r\n  return best;\r\n}\r\n\r\n}  // namespace\r\n\r\nPrimes* p;\r\ni32 a[200000];\r\n\r\nint Solve() {\r\n  int n;\r\n  cin >> n;\r\n  map<i32, i32> aa;\r\n  for (int i = 0; i < n; i++) {\r\n    cin >> a[i];\r\n    aa[a[i]]++;\r\n  }\r\n\r\n  int ans = 0;\r\n\r\n  for (int i = 0; i < n; i++) {\r\n    i32 x = a[i];\r\n\r\n    Primes::GetAllFactors(x);\r\n\r\n    for (i32 ff : factors) {\r\n      i32 f = (i32)sqrt(ff);\r\n      if (f * f != ff || ff == 1) continue;\r\n      ans += (int)(aa[x / f] * aa[x / ff]);\r\n    }\r\n  }\r\n\r\n  for (const auto& [x_i, count_i] : aa) {\r\n    int count = count_i;\r\n    ans += count * (count - 1) * (count - 2);\r\n  }\r\n\r\n  return ans;\r\n}\r\n\r\nvoid TestCase(int test_num) {\r\n  (void)test_num;\r\n\r\n  // int n = InInt();\r\n  // vi a = InVec(n);\r\n\r\n  auto sv = Solve();\r\n  OutSln(sv);\r\n  cout << \"\\n\";\r\n}\r\n\r\ni32 main() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(nullptr);\r\n  cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n  (void)freopen(\"in.txt\", \"r\", stdin);\r\n#endif\r\n\r\n  Primes pp;\r\n  p = &pp;\r\n\r\n  int t = InInt();\r\n  for (int i = 0; i < t; ++i) TestCase(i);\r\n}"
}