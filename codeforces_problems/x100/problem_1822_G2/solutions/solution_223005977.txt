{
    "id": 223005977,
    "contestId": 1822,
    "creationTimeSeconds": 1694462137,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1822,
        "index": "G2",
        "name": "Magic Triples (Hard Version)",
        "type": "PROGRAMMING",
        "rating": 2200,
        "tags": [
            "brute force",
            "data structures",
            "math",
            "number theory"
        ]
    },
    "author": {
        "contestId": 1822,
        "members": [
            {
                "handle": "the_last_smilodon"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1682346900
    },
    "programmingLanguage": "PyPy 3-64",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 71,
    "timeConsumedMillis": 3961,
    "memoryConsumedBytes": 35737600,
    "source": "# \ufdfd\r\nimport sys\r\nimport heapq \r\nfrom heapq import *\r\nfrom math import log2,ceil,floor,gcd,sqrt,log,factorial\r\nfrom random import randrange\r\nfrom bisect import bisect_left \r\nfrom collections import defaultdict, Counter, deque, OrderedDict\r\nfrom functools import lru_cache, reduce\r\nfrom bisect import bisect_left, bisect_right\r\nfrom types import GeneratorType\r\n\r\ninput = lambda: sys.stdin.buffer.readline().decode().rstrip()\r\n\r\n\r\n\r\nclass dict_(dict):\r\n    RANDOM = randrange(2 ** 62)\r\n \r\n    def __init__(self, dd):\r\n        super().__init__({k ^ self.RANDOM: v for k, v in dd.items()})\r\n \r\n    def __missing__(self, key):\r\n        return 0\r\n \r\n    def __setitem__(self, key, value):\r\n        super().__setitem__(key ^ self.RANDOM, value)\r\n \r\n    def __getitem__(self, item):\r\n        return super().__getitem__(item ^ self.RANDOM)\r\n \r\n    def __contains__(self, item):\r\n        return super().__contains__(item ^ self.RANDOM)\r\n \r\n    def items(self):\r\n        for k, v in super().items():\r\n            yield (k ^ self.RANDOM, v)\r\n \r\n    def keys(self):\r\n        for k in super().keys():\r\n            yield k ^ self.RANDOM\r\n \r\n    def __repr__(self):\r\n        return '{0}'.format({k ^ self.RANDOM: v for k, v in super().items()})\r\n\r\n###############################################################################\r\n# GRAPHS :\r\n\r\ndef add_edge(node1,node2,graph):\r\n\r\n    if node1 not in graph:\r\n        graph[node1] = []\r\n    if node2 not in graph:\r\n        graph[node2] = []\r\n    graph[node1].append(node2)\r\n    graph[node2].append(node1)\r\n\r\nclass disjointset:\r\n    def __init__(self, n):\r\n        self.rank, self.parent = array('i', [0] * (n + 1)), array('i', [i for i in range(n + 1)])\r\n        self.n, self.even = n, array('b', [0] * (n + 1))\r\n \r\n    def find(self, x):\r\n        xcopy = x\r\n        while x != self.parent[x]: x = self.parent[x]\r\n        while xcopy != x:\r\n            self.parent[xcopy], xcopy = x, self.parent[xcopy]\r\n        return x\r\n \r\n    def union(self, x, y):\r\n        xpar, ypar = self.find(x), self.find(y)\r\n \r\n        if xpar == ypar: return 1\r\n \r\n        par, child = xpar, ypar\r\n        if self.rank[xpar] < self.rank[ypar]:\r\n            par, child = ypar, xpar\r\n \r\n        elif self.rank[xpar] == self.rank[ypar]:\r\n            self.rank[xpar] += 1\r\n \r\n        self.parent[child] = par\r\n        self.even[par] |= self.even[child]\r\n        self.n -= 1\r\n        return 0\r\n\r\n\r\ndef dijkstra(graph, start1):\r\n    distances = {node: float('inf') for node in graph}  # Initialize distances to infinity\r\n    distances[start1] = 0  # Distance from start1 to start1 is 0\r\n    heap = [(0, start1,[start1])]  # Priority queue to store nodes and their distances\r\n    paths = [-1 for i in range(n+1)]\r\n    while heap:\r\n        current_distance, current_node , path = heapq.heappop(heap)  # Get node with smallest distance\r\n        \r\n        if current_distance > distances[current_node]:\r\n            continue  # Skip if distance is already greater than the known distance\r\n\r\n        for neighbor, weight in graph[current_node]:\r\n            distance = current_distance + weight  # Calculate tentative distance\r\n\r\n            if distance < distances[neighbor]:\r\n                lst = path \r\n                lst.append(neighbor)\r\n                paths[neighbor] = current_node\r\n                distances[neighbor] = distance  # Update distance if shorter\r\n                heapq.heappush(heap, (distance, neighbor, lst))  # Add neighbor to the heap\r\n\r\n    return distances , paths\r\n\r\n\r\n\r\n###############################################################################\r\ndef mergeSort(arr, n):\r\n    # A temp_arr is created to store\r\n    # sorted array in merge function\r\n    temp_arr = [0]*n\r\n    return _mergeSort(arr, temp_arr, 0, n-1)\r\n \r\n# This Function will use MergeSort to count inversions\r\n \r\n \r\ndef _mergeSort(arr, temp_arr, left, right):\r\n \r\n    # A variable inv_count is used to store\r\n    # inversion counts in each recursive call\r\n \r\n    inv_count = 0\r\n \r\n    # We will make a recursive call if and only if\r\n    # we have more than one elements\r\n \r\n    if left < right:\r\n \r\n        # mid is calculated to divide the array into two subarrays\r\n        # Floor division is must in case of python\r\n \r\n        mid = (left + right)//2\r\n \r\n        # It will calculate inversion\r\n        # counts in the left subarray\r\n \r\n        inv_count += _mergeSort(arr, temp_arr,\r\n                                left, mid)\r\n \r\n        # It will calculate inversion\r\n        # counts in right subarray\r\n \r\n        inv_count += _mergeSort(arr, temp_arr,\r\n                                mid + 1, right)\r\n \r\n        # It will merge two subarrays in\r\n        # a sorted subarray\r\n \r\n        inv_count += merge(arr, temp_arr, left, mid, right)\r\n    return inv_count\r\n \r\n# This function will merge two subarrays\r\n# in a single sorted subarray\r\n \r\n \r\ndef merge(arr, temp_arr, left, mid, right):\r\n    i = left     # Starting index of left subarray\r\n    j = mid + 1  # Starting index of right subarray\r\n    k = left     # Starting index of to be sorted subarray\r\n    inv_count = 0\r\n \r\n    # Conditions are checked to make sure that\r\n    # i and j don't exceed their\r\n    # subarray limits.\r\n \r\n    while i <= mid and j <= right:\r\n \r\n        # There will be no inversion if arr[i] <= arr[j]\r\n \r\n        if arr[i] <= arr[j]:\r\n            temp_arr[k] = arr[i]\r\n            k += 1\r\n            i += 1\r\n        else:\r\n            # Inversion will occur.\r\n            temp_arr[k] = arr[j]\r\n            inv_count += (mid-i + 1)\r\n            k += 1\r\n            j += 1\r\n \r\n    # Copy the remaining elements of left\r\n    # subarray into temporary array\r\n    while i <= mid:\r\n        temp_arr[k] = arr[i]\r\n        k += 1\r\n        i += 1\r\n \r\n    # Copy the remaining elements of right\r\n    # subarray into temporary array\r\n    while j <= right:\r\n        temp_arr[k] = arr[j]\r\n        k += 1\r\n        j += 1\r\n \r\n    # Copy the sorted subarray into Original array\r\n    for loop_var in range(left, right + 1):\r\n        arr[loop_var] = temp_arr[loop_var]\r\n \r\n    return inv_count\r\n###############################################################################\r\n\r\n\r\ndef Divisors(n) :\r\n    num = n \r\n    if n == 1 :\r\n        return []\r\n    lst = []\r\n    i = 2\r\n    while i <= (sqrt(num)) :\r\n        if (num % i == 0) :\r\n            # If divisors are equal, print only one\r\n            if ( num / i == i) :\r\n                lst.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                lst.extend([i,num//i])\r\n        i = i + 1\r\n    if not lst or  lst[-1] != n  and n != 1:\r\n        lst.append(n)\r\n    return lst\r\n\r\ndef binpow(a, b):\r\n    if b==0:\r\n        return 1\r\n    res = binpow(a,b//2)\r\n    res = pow(res,2,MOD)\r\n    if b%2:\r\n        return (res*a)%MOD\r\n    return res\r\n \r\ndef mod_inverse(a):\r\n    return binpow(a,MOD-2)\r\n \r\ndef factors(n): \r\n    if n==0:\r\n        return set()   \r\n    return set(reduce(list.__add__, \r\n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\r\n \r\n# factors = [factors(i) for i in range(MAX)]\r\n \r\n# factorial and inverse factorial\r\n \r\n# fact = [1]*MAX\r\n# invfact = [1]*MAX\r\n# for i in range(1,MAX):\r\n#     fact[i] = (fact[i-1]*i)%MOD\r\n#     invfact[i] = (invfact[i-1]*mod_inverse(i))%MOD\r\n\r\ndef inverse_mod(num):\r\n    a = mod-2\r\n    result = 1\r\n    result=pow(num,a,mod)\r\n    return result \r\n\r\ndef mex(arr, N):\r\n    # Sort the array\r\n    arr1 = arr.copy()\r\n    arr1.sort()\r\n    mex = 0\r\n    for idx in range(N):\r\n        if arr1[idx] == mex:\r\n            # Increment mex\r\n            mex += 1\r\n    # return mex as answer\r\n    return mex\r\n###############################################################################\r\n    \r\ndef mergeDictionary(dict_1, dict_2):\r\n   dict_3 = {**dict_1, **dict_2}\r\n   for key, value in dict_3.items():\r\n       if key in dict_1 and key in dict_2:\r\n               dict_3[key] = value + dict_1[key]\r\n   return dict_3\r\n   \r\ndef rindex(lst, value):\r\n    lst.reverse()\r\n    i = lst.index(value)\r\n    lst.reverse()\r\n    return len(lst) - i - 1\r\n    \r\n    \r\ndef prefix_sum(arr, length_arr, prefix_sum):\r\n    prefix_sum[0] = arr[0] \r\n\r\n    for i in range(1, length_arr): # 1, 2, 3, 4\r\n        prefix_sum[i] =  prefix_sum[i-1]+ arr[i]\r\n        \r\ndef suffix_sum(arr, length_arr, suffix_sum):\r\n    suffix_sum[length_arr-1] = arr[length_arr-1] \r\n\r\n    for i in reversed(range(length_arr-1)): # 3, 2, 1, 0\r\n        suffix_sum[i] = suffix_sum[i+1] + arr[i]\r\n\r\n    \r\nletters = [\r\n    'a','b','c','d','e','f',\r\n    'g','h','i','j','k','l',\r\n    'm','n','o','p','q','r',\r\n    's','t','u','v','w','x',\r\n    'y','z']\r\n\r\n \r\n# recursion limit fix decorator, change 'return' to 'yield' and add 'yield' before calling the function\r\ndef bootstrap(f):  \r\n    stack = []\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\n###############################################################################\r\n###############################################################################\r\n###############################################################################\r\nmod = 10**9 + 7\r\nimport random\r\ndef solve():\r\n    n = int(input())\r\n    arr = list(map(int,input().split())) \r\n    random.shuffle(arr)\r\n    c = ({i:0 for i in arr})\r\n    for i in arr :\r\n        c[i] += 1 \r\n    m = max(arr) \r\n    limit = int(m**(2/3)) \r\n    till = int(m**(1/3))\r\n    ans = 0 \r\n    # print(limit)\r\n    for aj in list(c.keys()) : \r\n        # print(aj)\r\n        cnt = c[aj]\r\n        ans += cnt*(cnt-1)*(cnt-2)\r\n        if aj <= limit : \r\n            for b in Divisors(aj) : \r\n                if aj*b in c and aj//b in c :\r\n                    ans += cnt*c[aj*b]*c[aj//b] \r\n        else: \r\n            for b in range(min(till,int(sqrt(aj)))): \r\n                # print(ans,aj)\r\n                b += 2 \r\n                if aj%b == 0 :\r\n                    if aj*b in c and aj//b in c :\r\n                        ans += cnt*c[aj*b]*c[aj//b]\r\n\r\n    print(ans)\r\n\r\n\r\n###############################################################################\r\n###############################################################################\r\n###############################################################################\r\n \r\nfor t in range(int(input())):\r\n    # case(t+1)\r\n    solve()\r\n"
}