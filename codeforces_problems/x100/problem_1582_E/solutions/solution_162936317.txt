{
    "id": 162936317,
    "contestId": 1582,
    "creationTimeSeconds": 1657053879,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 1582,
        "index": "E",
        "name": "Pchelyonok and Segments",
        "type": "PROGRAMMING",
        "points": 2500.0,
        "rating": 2000,
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "math"
        ]
    },
    "author": {
        "contestId": 1582,
        "members": [
            {
                "handle": "memoryallocator"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1635069900
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 26,
    "timeConsumedMillis": 420,
    "memoryConsumedBytes": 379699200,
    "source": "#pragma clang diagnostic push\r\n#pragma ide diagnostic ignored \"modernize-use-emplace\"\r\n#pragma ide diagnostic ignored \"misc-no-recursion\"\r\n#pragma ide diagnostic ignored \"modernize-use-bool-literals\"\r\n#pragma ide diagnostic ignored \"bugprone-easily-swappable-parameters\"\r\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"\r\n#ifdef DEBUG\r\n#include <bits/extc++.h>\r\n#else\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n#endif\r\n\r\nusing namespace __gnu_pbds;\r\nusing namespace std;\r\nconst auto& npos = string::npos;\r\n\r\n#define itn int\r\n#define int int64_t\r\n#define str string\r\n#define vec vector\r\n#define vi vec<int>\r\n#define v2d vec<vi>\r\n#define v3d vec<v2d>\r\n#define vtri vec<tri>\r\n#define let auto\r\n#define ret return\r\n#define cont continue\r\n#define elif else if\r\n#define eilf elif\r\n#define elfi elif\r\n#define loop while(true)\r\n#define opt optional\r\n#define cint const int\r\n#define cvi const vi\r\n#define clet const let\r\n#define cst const\r\n#define cv2d cst v2d\r\n#define cpi cst pi\r\n#define popcnt(x) popcount(uintmax_t(x))\r\n#define cvpi cst vpi\r\n#define bakc back\r\n#define cvec cst vec\r\n#define cvtri cst vtri\r\n#define citn cst itn\r\n#define celt clet\r\n#define nl endl\r\n#define eb emplace_back\r\n\r\n#define CONCAT(a, b) CONCAT_INNER(a,b)\r\n#define CONCAT_INNER(a, b) a ## b\r\n#define ITER_CNT CONCAT(CONCAT(iter_cnt, __LINE__), _)\r\n#define INTERNAL_FOR(N, v) for (int v = 0; (v) < int(N); ++(v)) // NOLINT(bugprone-macro-parentheses)\r\n#define forn(v, n) INTERNAL_FOR(n,v)\r\n#define forc(x, a) for (const let &x: (a)) // NOLINT(bugprone-macro-parentheses)\r\n#define fi(N) INTERNAL_FOR(N,i)\r\n#define fj(N) INTERNAL_FOR(N,j)\r\n#define fk(N) INTERNAL_FOR(N,k)\r\n#define SET unordered_set\r\n#define MAP unordered_map\r\n\r\nusing tri = array<int, 3>;\r\nusing pii = pair<int, int>;\r\nusing pi = pii;\r\nusing vpi = vec<pi>;\r\nusing spi = set<pi>;\r\nusing pvv = pair<vec<int>, vec<int>>;\r\nusing vtr = vec<tri>;\r\n\r\n#define ordered_set(T, cmp) tree<T, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update> // NOLINT(bugprone-macro-parentheses)\r\n\r\ncint MOD = 1e9 + 7;\r\n#define INF (numeric_limits<int>::max() / 2)\r\n#define INFP pair{INF, INF}\r\n#define PINF INFP\r\n\r\nnamespace std {\r\ntemplate<>\r\nstruct hash<pi> {\r\n  size_t operator()(const pi& x) const {\r\n      return ((hash<int>()(x.first)\r\n          ^ (hash<int>()(x.second) << 1)) >> 1);\r\n  }\r\n};\r\n}\r\n\r\nnamespace std {\r\ntemplate<>\r\nstruct hash<tri> {\r\n  size_t operator()(const tri& x) const {\r\n      return hash<pi>()(pi{\r\n          x[0], x[1]\r\n      }) ^ (hash<int>()(x[2]) << 1);\r\n  }\r\n};\r\n}\r\n\r\nauto min(cst intmax_t a, cst intmax_t b) {\r\n    ret a < b ? a : b;\r\n}\r\n\r\nauto max(cst intmax_t a, cst intmax_t b) {\r\n    ret a > b ? a : b;\r\n}\r\n\r\ntemplate<typename T>\r\nvec<T>& operator+=(vec<T>& lhs, cvec<T>& rhs) {\r\n    lhs.insert(lhs.end(), rhs.cbegin(), rhs.cend());\r\n    ret lhs;\r\n}\r\n\r\ntemplate<typename T>\r\nvec<T> operator+(cvec<T>& lhs, cvec<T>& rhs) {\r\n    vec<T> res = lhs;\r\n    ret res += rhs;\r\n}\r\n\r\nvi mm1(vi v) {\r\n    for (let& el: v) {\r\n        el--;\r\n    }\r\n    ret v;\r\n}\r\n\r\nvpi mm1(vpi v) {\r\n    for (let& [f, s]: v) {\r\n        f--, s--;\r\n    }\r\n    ret v;\r\n}\r\n\r\nvi rd_vi(cint n) {\r\n    vi res(n);\r\n    for (let& el: res) {\r\n        cin >> el;\r\n    }\r\n    ret res;\r\n}\r\n\r\nistream& operator>>(istream& is, pi& p) {\r\n    ret is >> p.first >> p.second;\r\n}\r\n\r\nvpi rd_vpi(cint n) {\r\n    vpi res(n);\r\n    for (let& p: res) {\r\n        cin >> p;\r\n    }\r\n    ret res;\r\n}\r\n\r\nistream& operator>>(istream& is, tri& t) {\r\n    for (let& x: t) {\r\n        is >> x;\r\n    }\r\n    ret is;\r\n}\r\n\r\nvtri rd_vtri(cint n) {\r\n    vtri res(n);\r\n    for (let& el: res) {\r\n        cin >> el;\r\n    }\r\n    ret res;\r\n}\r\n\r\nv2d rd_v2d(cint n, int m = -1) {\r\n    if (m == -1) {\r\n        m = n;\r\n    }\r\n    v2d res(n);\r\n    for (let& l: res) {\r\n        l = rd_vi(m);\r\n    }\r\n    ret res;\r\n}\r\n\r\npi Inc(pi p) {\r\n    ++p.first, ++p.second;\r\n    ret p;\r\n}\r\n\r\n/*struct cmp_pos_end_pos_and_id {\r\n  template<class T, class U>\r\n  constexpr bool operator()(T&& lhs, U&& rhs) const {\r\n      if (lhs.front() == rhs.front()) {\r\n          if (lhs[1] == rhs[1]) {\r\n              ret lhs.back() > rhs.back();\r\n          }\r\n          ret lhs[1] > rhs[1];\r\n      }\r\n      ret lhs.front() < rhs.front();\r\n  }\r\n};*/\r\n\r\n/*vi z_function(string_view s) {\r\n    cint n = s.size(); // NOLINT(cppcoreguidelines-narrowing-conversions)\r\n    vi z(n);\r\n    z[0] = 0;\r\n    int l = 0, r = 0;\r\n    for (int i = 1; i < n; ++i) {\r\n        if (i <= r) {\r\n            z[i] = min(r - i + 1, z[i - l]);\r\n        }\r\n        while (z[i] + i < n && s[z[i]] == s[z[i] + i]) {\r\n            z[i]++;\r\n        }\r\n        if (z[i] + i - 1 > r) {\r\n            l = i;\r\n            r = i + z[i] - 1;\r\n        }\r\n    }\r\n    ret z;\r\n}*/\r\n\r\n/*vi dsu_parent;\r\nvi dsu_rank;\r\n\r\nvoid make_dsu_set(cint v) {\r\n    dsu_parent[v] = v;\r\n    dsu_rank[v] = 0;\r\n}\r\n\r\nint find_dsu_set(cint v) {\r\n    if (v == dsu_parent[v]) {\r\n        return v;\r\n    }\r\n    return dsu_parent[v] = find_dsu_set(dsu_parent[v]);\r\n}\r\n\r\nvoid union_dsu_sets(int a, int b) {\r\n    a = find_dsu_set(a);\r\n    b = find_dsu_set(b);\r\n    if (a != b) {\r\n        if (dsu_rank[a] < dsu_rank[b]) {\r\n            swap(a, b);\r\n        }\r\n        dsu_parent[b] = a;\r\n        if (dsu_rank[a] == dsu_rank[b]) {\r\n            ++dsu_rank[a];\r\n        }\r\n    }\r\n}*/\r\n\r\n/*class DynamicMaxSubarraySum {\r\n private:\r\n  struct Node {\r\n    int prf;\r\n    int suf;\r\n    int val;\r\n    int sum;\r\n\r\n    explicit Node(cint same) : prf(same), suf(same), val(same), sum(same) {\r\n    }\r\n\r\n    Node(cint prf, cint suf, cint val, cint sum) : prf(prf), suf(suf), val(val), sum(sum) {\r\n    }\r\n\r\n    Node() = default;\r\n  };\r\n\r\n  cint n;\r\n  cint neutral;\r\n  vec<Node> data;\r\n\r\n  static Node merge(cst Node& lhs, cst Node& rhs) {\r\n      Node res{};\r\n      res.prf = max(lhs.prf, lhs.sum + rhs.prf);\r\n      res.suf = max(rhs.suf, rhs.sum + lhs.suf);\r\n      res.val = max({lhs.val, rhs.val, lhs.suf + rhs.prf});\r\n      res.sum = lhs.sum + rhs.sum;\r\n      ret res;\r\n  }\r\n\r\n  void build(cint v, cint l, cint r) {\r\n      if (l > r) {\r\n          ret;\r\n      }\r\n      if (l == r) {\r\n          data[v] = Node(neutral);\r\n          ret;\r\n      }\r\n\r\n      cint m = l + (r - l) / 2;\r\n      build(2 * v, l, m);\r\n      build(2 * v + 1, m + 1, r);\r\n      data[v] = merge(data[2 * v], data[2 * v + 1]);\r\n  }\r\n\r\n  void modif(cint v, cint l, cint r, cint pos, cint val) {\r\n      if (l > pos || r < pos) {\r\n          ret;\r\n      }\r\n      if (l == pos && r == pos) {\r\n          data[v] = Node(val);\r\n          ret;\r\n      }\r\n\r\n      cint m = l + (r - l) / 2;\r\n      modif(2 * v, l, m, pos, val);\r\n      modif(2 * v + 1, m + 1, r, pos, val);\r\n      data[v] = merge(data[2 * v], data[2 * v + 1]);\r\n  }\r\n\r\n  Node query(cint v, cint l, cint r, cint ql, cint qr) {\r\n      if (l > ql || r < qr) {\r\n          ret {};\r\n      }\r\n      if (l >= ql && r <= qr) {\r\n          ret data[v];\r\n      }\r\n      cint m = l + (r - l) / 2;\r\n      ret merge(query(2 * v, l, m, ql, qr), query(2 * v + 1, m + 1, r, ql, qr));\r\n  }\r\n\r\n  Node query(cint l, cint r) {\r\n      ret query(1, 0, n - 1, l, r);\r\n  }\r\n\r\n public:\r\n  explicit DynamicMaxSubarraySum(cint n, cint neutral) : n(n), neutral(neutral) {\r\n      data.resize(4 * n);\r\n      build(1, 0, n - 1);\r\n  }\r\n\r\n  void modif(cint pos, cint val) {\r\n      modif(1, 0, n - 1, pos, val);\r\n  }\r\n\r\n  void reset(cint pos) {\r\n      modif(pos, neutral);\r\n  }\r\n\r\n  Node query() {\r\n      ret query(0, n - 1);\r\n  }\r\n};*/\r\n\r\n/*class SparseTable {\r\n private:\r\n  static cint K = 30;\r\n  vec<array<int, K + 1>> data;\r\n\r\n public:\r\n  explicit SparseTable(cvi& a) {\r\n      cint n = a.size();\r\n      data.resize(n);\r\n      forn(i, n) {\r\n          data[i][0] = a[i];\r\n      }\r\n\r\n      for (int j = 1; j <= K; ++j) {\r\n          for (int i = 0; i + (1 << j) <= n; ++i) {\r\n              data[i][j] = data[i][j - 1] + data[i + (1 << (j - 1))][j - 1];\r\n          }\r\n      }\r\n  }\r\n\r\n  int get(int l, cint r) {\r\n      if (l > r) {\r\n          ret 0;\r\n      }\r\n      int sum = 0;\r\n      for (int j = K; j >= 0; j--) {\r\n          if ((1 << j) <= r - l + 1) {\r\n              sum += data[l][j];\r\n              l += 1 << j;\r\n          }\r\n      }\r\n      ret sum;\r\n  }\r\n};*/\r\n\r\n/*class SegTree {\r\n public:\r\n  explicit SegTree(cvpi& a) : sz(a.size()) {\r\n      cint n = a.size();\r\n      data.resize(n * 4);\r\n      build(a, 1, 0, n - 1);\r\n  }\r\n\r\n  explicit SegTree(cint n) : SegTree(vpi(n)) {\r\n  }\r\n\r\n  pi get(cint l, cint r) {\r\n      ret get(1, 0, sz - 1, l, r);\r\n  }\r\n\r\n  void add(cint l, cint r, cint add) {\r\n      this->add(1, 0, sz - 1, l, r, add);\r\n  }\r\n\r\n  void reset_pos(cint p) {\r\n      // cint cur = get(p, p);\r\n      add(p, p, INF);\r\n  }\r\n\r\n private:\r\n  cint sz;\r\n  vector<pi> data;\r\n\r\n  void build(cvpi& a, cint v, cint tl, cint tr) {\r\n      if (tl > tr) {\r\n          ret;\r\n      }\r\n      if (tl == tr) {\r\n          data[v] = a[tl];\r\n          ret;\r\n      }\r\n\r\n      cint tm = tl + (tr - tl) / 2;\r\n      build(a, v * 2, tl, tm);\r\n      build(a, v * 2 + 1, tm + 1, tr);\r\n\r\n      clet lf = data[v * 2];\r\n      clet rt = data[v * 2 + 1];\r\n      data[v] = min(lf, rt);\r\n  }\r\n\r\n  pi get(cint v, cint tl, cint tr, cint l, cint r) {\r\n      if (l > r) {\r\n          ret INFP;\r\n      }\r\n      if (tl == l && tr == r) {\r\n          ret data[v];\r\n      }\r\n\r\n      cint tm = tl + (tr - tl) / 2;\r\n      ret min(get(v * 2, tl, tm, l, min(tm, r)),\r\n              get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\r\n  }\r\n\r\n  void add(cint v, cint tl, cint tr, cint ql, cint qr, cint add) {\r\n      if (ql > qr || tl > tr) {\r\n          ret;\r\n      }\r\n      if (ql == tl && qr == tr) {\r\n          data[v].first += add;\r\n          ret;\r\n      }\r\n\r\n      cint tm = tl + (tr - tl) / 2;\r\n      cint lrb = min(tm, qr);\r\n      cint rlb = max(tm + 1, ql);\r\n      this->add(v * 2, tl, tm, ql, lrb, add);\r\n      this->add(v * 2 + 1, tm + 1, tr, rlb, qr, add);\r\n      data[v] = min(data[v * 2], data[v * 2 + 1]);\r\n  }\r\n};*/\r\n\r\n// #define INTERACTIVE\r\n\r\n#if !defined(DEBUG) && !defined(INTERACTIVE)\r\n#define endl \"\\n\"\r\n#endif\r\n\r\nvoid solve() {\r\n    itn n;\r\n    cin >> n;\r\n    cvi a = rd_vi(n);\r\n\r\n    vi suf = {0};\r\n    inclusive_scan(a.rbegin(), a.rend(), back_inserter(suf));\r\n\r\n    clet mk = int(ceil(sqrt(2 * n))) + 1;\r\n    v2d dp(a.size() + 1, vi(mk + 1, -INF));\r\n\r\n    {\r\n        let cm = a.back();\r\n        for (int i = 1; i <= n; ++i) {\r\n            cm = max(cm, *(a.rbegin() + i - 1));\r\n            dp[i][1] = cm;\r\n        }\r\n    }\r\n\r\n    for (int i = 1; i <= n; ++i) {\r\n        for (int k = 1; k <= mk; ++k) {\r\n            if (i - k < 0 || i - k >= suf.size()) {\r\n                continue;\r\n            }\r\n            cint re = suf[i] - suf[i - k];\r\n            cint prv = dp[i - 1][k];\r\n            dp[i][k] = max(dp[i][k], prv);\r\n\r\n            clet pk = dp[i - k][k - 1];\r\n            if (pk > -INF && re < pk) {\r\n                dp[i][k] = max(dp[i][k], re);\r\n            }\r\n        }\r\n    }\r\n\r\n    int res = 1;\r\n    for (int k = mk; k >= 1; --k) {\r\n        if (dp[n][k] != -INF) {\r\n            res = k;\r\n            break;\r\n        }\r\n    }\r\n    cout << res;\r\n}\r\n\r\nsigned main() {\r\n    ios::sync_with_stdio(false);\r\n#if !defined(DEBUG) && !defined(INTERACTIVE)\r\n    cin.tie(nullptr);\r\n#endif\r\n    cin.exceptions(istream::failbit | istream::badbit);\r\n    int t = 1;\r\n    cin >> t;\r\n    while (t--) {\r\n        solve();\r\n#ifndef INTERACTIVE\r\n        cout << endl;\r\n#endif\r\n#if defined(INTERACTIVE) || defined(DEBUG)\r\n        cout.flush();\r\n#endif\r\n    }\r\n}\r\n\r\n#pragma clang diagnostic pop"
}