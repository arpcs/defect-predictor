{
    "id": 141471513,
    "contestId": 827,
    "creationTimeSeconds": 1641203218,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 827,
        "index": "B",
        "name": "High Load",
        "type": "PROGRAMMING",
        "points": 750.0,
        "rating": 1800,
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 827,
        "members": [
            {
                "handle": "toomanyalts"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1499791500
    },
    "programmingLanguage": "GNU C++20 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 46,
    "memoryConsumedBytes": 0,
    "source": "#include <bits/stdc++.h>\r\n#include <chrono>\r\nusing namespace std::chrono;\r\n#define ll long long\r\n#define pll pair<ll,ll>\r\n#define umap unordered_map\r\n#define vvll vector<vector<ll>>\r\n#define vvi vector<vector<int>>\r\n#define vvc vector<vector<char>>\r\n#define db double\r\n#define pii pair<int,int>\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define ppf pop_front\r\n#define mpll map<ll, ll>\r\n#define mcll map<char,ll>\r\n#define msll map<string,ll>\r\n#define mpll_p map<ll, pair<ll, ll>>\r\n#define mp_pll map<pair<ll, ll>, ll>\r\n#define vll vector<ll>\r\n#define vpll vector<pair<ll, ll>>\r\n#define vtll vector<tuple<ll,ll,ll>>\r\n#define vs vector<string>\r\n#define vc vector<char>\r\n#define sll set<ll>\r\n#define in insert\r\n#define sc set<char>\r\n#define spll set<pair<ll, ll>>\r\n#define nope string::npos\r\n#define endl \"\\n\"\r\n#define vpii vector<pii>\r\n#define vi vector<int>\r\n#define pll pair<ll,ll>\r\n#define min_pqll priority_queue<ll,vll,greater<ll>>\r\nll mod = 1000000007;\r\nconst ll mod2 = 998244353;\r\nusing namespace std;\r\n\r\ntime_t clock_start,clock_end;\r\n\r\nll numlength(ll n){\r\n\tint cnt=0;\r\n\twhile(n){\r\n\t\tcnt++;\r\n\t\tn/=10;\r\n\t}\r\n\treturn cnt;\r\n}\r\n\r\nvoid start_clock(){\r\n\ttime(&clock_start);\r\n}\r\n\r\nbool check_clock(){\r\n\ttime(&clock_end);\r\n\treturn (db)(clock_end-clock_start)>2;\r\n}\r\n\r\n\r\nvoid fast() {\r\n\tstart_clock();\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n}\r\n\r\n/*\r\nconst int N = 1000005;\r\nll factorialNumInverse[N + 1];\r\nll naturalNumInverse[N + 1];\r\nll fact[N + 1];\r\nvoid InverseofNumber(ll p)\r\n{\r\n\tnaturalNumInverse[0] = naturalNumInverse[1] = 1;\r\n\tfor (int i = 2; i <= N; i++)\r\n\t\tnaturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;\r\n}\r\n\r\nvoid InverseofFactorial(ll p)\r\n{\r\n\tfactorialNumInverse[0] = factorialNumInverse[1] = 1;\r\n\r\n\t// precompute inverse of natural numbers\r\n\tfor (int i = 2; i <= N; i++)\r\n\t\tfactorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;\r\n}\r\n\r\nvoid factorial(ll p)\r\n{\r\n\tfact[0] = 1;\r\n\r\n\t// precompute factorials\r\n\tfor (int i = 1; i <= N; i++) {\r\n\t\tfact[i] = (fact[i - 1] * i) % p;\r\n\t}\r\n}\r\n\r\nll Binomial(ll N, ll R, ll p)\r\n{\r\n\t// n C r = n!*inverse(r!)*inverse((n-r)!)\r\n\tll ans = ((fact[N] * factorialNumInverse[R])\r\n\t          % p * factorialNumInverse[N - R])\r\n\t         % p;\r\n\treturn ans;\r\n}\r\n*/\r\n\r\nbool primecheck(ll n) {\r\n\tif(n==1) return 1;\r\n\tfor (ll i = 2; i*i < (n); i++) {\r\n\t\tif (n % i == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\treturn 1;\r\n}\r\nll power(ll x, ll y, ll c) {\r\n\tll res = 1; // Initialize result\r\n\r\n\twhile (y > 0) {\r\n\t\t// If y is odd, multiply x with result\r\n\t\tif (y & 1)\r\n\t\t\tres = ( res * x) % (c);\r\n\r\n\t\t// n must be even now\r\n\t\ty = y >> 1; // y = y/2\r\n\t\tx = (x * x) % c; // Change x to x^2\r\n\t}\r\n\treturn res % c;\r\n}\r\n\r\nll sumdigit(ll n) {\r\n\tll sum = 0;\r\n\twhile (n)\r\n\t{\r\n\t\tsum += n;\r\n\t\tn /= 10;\r\n\t}\r\n\treturn sum;\r\n}\r\n\r\nll lcm(ll a, ll b) {\r\n\treturn a*(b/__gcd(a,b));\r\n}\r\n\r\nstring dectobin(ll n) {\r\n\tstring str = \"\";\r\n\tfor (ll i = 14; i >= 0; i--) {\r\n\t\tll k = n >> i;\r\n\t\tif (k & 1) {str.pb('1');}\r\n\t\telse {str.pb('0');}\r\n\t}\r\n\treturn str;\r\n}\r\n\r\nint val(char c)\r\n{\r\n\tif (c >= '0' && c <= '9')\r\n\t\treturn (int)c - '0';\r\n\telse\r\n\t\treturn (int)c - 'A' + 10;\r\n}\r\n\r\n// Function to convert a number\r\n// from given base to decimal number\r\nint toDeci(string str, int base) {\r\n\t// Stores the length\r\n\t// of the string\r\n\tint len = str.size();\r\n\r\n\t// Initialize power of base\r\n\tint power = 1;\r\n\r\n\t// Initialize result\r\n\tint num = 0;\r\n\r\n\t// Decimal equivalent is str[len-1]*1\r\n\t// + str[len-2]*base + str[len-3]*(base^2) + ...\r\n\tfor (int i = len - 1; i >= 0; i--) {\r\n\r\n\t\t// A digit in input number must\r\n\t\t// be less than number's base\r\n\t\tif (val(str[i]) >= base) {\r\n\t\t\tprintf(\"Invalid Number\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// Update num\r\n\t\tnum += val(str[i]) * power;\r\n\r\n\t\t// Update power\r\n\t\tpower = power * base;\r\n\t}\r\n\r\n\treturn num;\r\n}\r\n\r\n// Function to return equivalent\r\n// character of a given value\r\nchar reVal(int num) {\r\n\tif (num >= 0 && num <= 9)\r\n\t\treturn (char)(num + '0');\r\n\telse\r\n\t\treturn (char)(num - 10 + 'A');\r\n}\r\n\r\n// Function to convert a given\r\n// decimal number to a given base\r\nstring fromDeci(int base, int inputNum) {\r\n\t// Store the result\r\n\tstring res = \"\";\r\n\r\n\t// Repeatedly divide inputNum\r\n\t// by base and take remainder\r\n\twhile (inputNum > 0) {\r\n\r\n\t\t// Update res\r\n\t\tres += reVal(inputNum % base);\r\n\r\n\t\t// Update inputNum\r\n\t\tinputNum /= base;\r\n\t}\r\n\r\n\t// Reverse the result\r\n\treverse(res.begin(), res.end());\r\n\r\n\treturn res;\r\n}\r\n/*\r\nint par[1001];\r\nint siz[1001];\r\n\r\nint find_set(int v) {\r\n\tif (v == par[v]) {return v;}\r\n\treturn par[v] = find_set(par[v]);\r\n}\r\n\r\nset<pii> s; \r\n\r\nvoid union_sets(int a, int b) {\r\n\ta=find_set(a);\r\n\tb=find_set(b);\r\n\tif (a != b) {\r\n\t\tif (siz[a] < siz[b]) {swap(a, b);}\r\n\t\ts.erase({siz[a],a});\r\n\t\ts.erase({siz[b],b});\r\n\t\tpar[b] = a;\r\n\t\tsiz[a] += siz[b];\r\n\t\tsiz[b]=0;\r\n\t\ts.insert({siz[a],a});\r\n\t}\r\n}\r\n\r\nstruct hash_pair {\r\n\ttemplate <class T1, class T2>\r\n\tsize_t operator()(const pair<T1, T2>& p) const\r\n\t{\r\n\t\tauto hash1 = hash<T1> {}(p.first);\r\n\t\tauto hash2 = hash<T2> {}(p.second);\r\n\t\treturn hash1 ^ hash2;\r\n\t}\r\n};\r\n*/\r\nvoid ONLINE() {\r\n#ifndef ONLINE_JUDGE\r\n\tfreopen(\"input.txt\", \"r\", stdin);\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\n/*\r\nbool prime[1000000 + 10];\r\nvoid SieveOfEratosthenes(int n)\r\n{\r\n    // Create a boolean array\r\n    // \"prime[0..n]\" and initialize\r\n    // all entries it as true.\r\n    // A value in prime[i] will\r\n    // finally be false if i is\r\n    // Not a prime, else true.\r\n    memset(prime, true, sizeof(prime));\r\n \r\n    for (int p = 2; p * p <= n; p++)\r\n    {\r\n        // If prime[p] is not changed,\r\n        // then it is a prime\r\n        if (prime[p] == true)\r\n        {\r\n            // Update all multiples\r\n            // of p greater than or\r\n            // equal to the square of it\r\n            // numbers which are multiple\r\n            // of p and are less than p^2\r\n            // are already been marked.\r\n            for (int i = p * p; i <= n; i += p)\r\n                prime[i] = false;\r\n        }\r\n    }\r\n}\r\n*/ \r\n\r\n\r\n\r\nvoid solve_testcase(){\r\n\tint n,k; cin>>n>>k;\r\n\tint d1=(n-1)/k;\r\n\tint d2=d1+1;\r\n\tint cnt1,cnt2=0;\r\n\tcnt2=(n-1)%k;\r\n\tcnt1=k-cnt2;\r\n\tbool f=((n-1)%k==0);\r\n\tint curr=2;\r\n\tif(cnt2>1) cout<<2*d2<<endl;\r\n\telse if(cnt2==1) cout<<d1+d2<<endl;\r\n\telse cout<<2*d1<<endl;\r\n\tfor(int i=0;i<k;i++){\r\n\t\tif(cnt1){\r\n\t\t\tcnt1--;\r\n\t\t\tint prev=1;\r\n\t\t\tint x=d1;\r\n\t\t\twhile(x--){\r\n\t\t\t\tcout<<curr<<' '<<prev<<endl;\r\n\t\t\t\tprev=curr;\r\n\t\t\t\tcurr++;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcnt2--;\r\n\t\t\tint prev=1;\r\n\t\t\tint x=d2;\r\n\t\t\twhile (x--)\r\n\t\t\t{\r\n\t\t\t\tcout<<curr<<' '<<prev<<endl;\r\n\t\t\t\tprev=curr;\r\n\t\t\t\tcurr++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nint main() {\r\n\tfast(); ONLINE();\r\n\tll t; t=1;\r\n\twhile (t--)\r\n\t{\r\n\t\tsolve_testcase();\r\n\t}\r\n}"
}