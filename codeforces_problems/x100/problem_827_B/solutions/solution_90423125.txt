{
    "id": 90423125,
    "contestId": 827,
    "creationTimeSeconds": 1597877443,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 827,
        "index": "B",
        "name": "High Load",
        "type": "PROGRAMMING",
        "points": 750.0,
        "rating": 1800,
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 827,
        "members": [
            {
                "handle": "kal013"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1499791500
    },
    "programmingLanguage": "GNU C++17 (64)",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 62,
    "memoryConsumedBytes": 4300800,
    "source": "/*/ Author: kal013 /*/\r\n// #pragma GCC optimize (\"O3\")\r\n#include \"bits/stdc++.h\"\r\n#include \"ext/pb_ds/assoc_container.hpp\"\r\n#include \"ext/pb_ds/tree_policy.hpp\"\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\ntemplate<class T> \r\nusing ordered_set = tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\r\n\r\ntemplate<class key, class value, class cmp = std::less<key>>\r\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\r\n// find_by_order(k)  returns iterator to kth element starting from 0;\r\n// order_of_key(k) returns count of elements strictly smaller than k;\r\n\r\ntemplate<class T>\r\nusing min_heap = priority_queue<T,vector<T>,greater<T> >; \r\n\r\nstruct custom_hash { // Credits: https://codeforces.com/blog/entry/62393\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n    size_t operator()(pair<int64_t,int64_t> Y) const{\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(Y.first * 31 + Y.second + FIXED_RANDOM);\r\n    }\r\n};\r\n\r\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\r\n    os << \"[ \";\r\n    for(auto v : V) os << v << \" \";\r\n    return os << \"]\";\r\n}\r\ntemplate<class T> istream& operator>>(istream &is, vector<T>& V) {\r\n    for(auto &e : V)\r\n        is >> e;\r\n    return is;\r\n}\r\n\r\n#ifdef __SIZEOF_INT128__\r\nostream& operator << (ostream &os, __int128 T){\r\n    const static long long N = (1'000'000'000'000'000'000);\r\n    if (T < 0){\r\n        os << '-';\r\n        T *= -1;\r\n    }\r\n\r\n    unsigned long long b = T%N;\r\n    T /= N;\r\n    if (T == 0)\r\n        return os << b ;\r\n    unsigned long long a = T % N;\r\n    T /= N;\r\n    if (T == 0){\r\n        os << a;\r\n        __int128 mul = 10;\r\n        int cnt = 0;\r\n        while( mul*b < N && cnt < 17){\r\n            os << '0';\r\n            mul *= 10;\r\n            ++cnt;\r\n        }\r\n        return os << b;\r\n    }\r\n    os << ((long long) T);\r\n    \r\n     __int128 mul = 10;\r\n      int cnt = 0;\r\n    while( mul*a < N && cnt < 17){\r\n        os << '0';\r\n        mul *= 10;\r\n        ++cnt;\r\n    }\r\n    os << a;\r\n    mul = 10;\r\n    cnt = 0;\r\n    while( mul*b < N && cnt < 17){\r\n        os << '0';\r\n        mul *= 10;\r\n        ++cnt;\r\n    }\r\n    return os << b;\r\n\r\n}\r\nistream& operator >> (istream& is, __int128& T){\r\n    string U;\r\n    is >> U;\r\n    T = 0;\r\n    size_t pos = 0;\r\n    int mul = 1;\r\n    if (U[pos] == '-'){\r\n        ++pos;\r\n        mul *= -1;\r\n    }\r\n    for(; pos < U.size(); ++pos){\r\n        T *= 10;\r\n        T += (U[pos] - '0');\r\n    }\r\n    T *= mul;\r\n\r\n    return is;\r\n}\r\n#endif\r\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){\r\n    os << \"{ \";\r\n    for(auto s:S) os<<s<<\" \";\r\n    return os<<\"}\";\r\n}\r\ntemplate<class T> ostream& operator<<(ostream &os, unordered_set<T> S){\r\n    os << \"{ \";\r\n    for(auto s:S) os<<s<<\" \";\r\n    return os<<\"}\";\r\n}\r\ntemplate<class T> ostream& operator << (ostream& os, multiset<T> S){\r\n    os << \"{ \";\r\n    for(auto s:S) os<<s<<\" \";\r\n    return os<<\"}\";\r\n}\r\ntemplate<class T> ostream& operator<<(ostream &os, ordered_set<T> S){\r\n    os << \"{ \";\r\n    for(auto s:S) os<<s<<\" \";\r\n    return os<<\"}\";\r\n}\r\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\r\n    return os << \"(\" << P.first << \",\" << P.second << \")\";\r\n}\r\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\r\n    os << \"{ \";\r\n    for(auto m:M) os<<\"(\"<<m.first<<\":\"<<m.second<<\") \";\r\n    return os<<\"}\";\r\n}\r\ntemplate<class L, class R, class chash = std::hash<R>> ostream& operator<<(ostream &os, unordered_map<L,R,chash> M) {\r\n    os << \"{ \";\r\n    for(auto m:M) os<<\"(\"<<m.first<<\":\"<<m.second<<\") \";\r\n    return os<<\"}\";\r\n}\r\ntemplate<class L, class R, class chash = std::hash<R> > ostream& operator<<(ostream &os, gp_hash_table<L,R,chash> M) {\r\n    os << \"{ \";\r\n    for(auto m:M) os<<\"(\"<<m.first<<\":\"<<m.second<<\") \";\r\n    return os<<\"}\";\r\n}\r\n\r\n#define TRACE\r\n#ifdef TRACE\r\n    #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\r\n    template <typename Arg1>\r\n    void __f(const char* name, Arg1&& arg1){\r\n        cerr << name << \" : \" << arg1 << endl;\r\n    }\r\n    template <typename Arg1, typename... Args>\r\n    void __f(const char* names, Arg1&& arg1, Args&&... args){\r\n        const char* comma = strchr(names + 1, ',');\r\n        cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";\r\n        __f(comma+1, args...);\r\n    }\r\n#else\r\n    #define trace(...) 1\r\n#endif\r\n\r\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n\r\ninline int64_t random_long(long long l,long long r){\r\n    uniform_int_distribution<int64_t> generator(l,r);\r\n    return generator(rng);\r\n}\r\ninline int64_t random_long(){\r\n    uniform_int_distribution<int64_t> generator(LLONG_MIN,LLONG_MAX);\r\n    return generator(rng);\r\n}\r\n\r\n\r\n/*/---------------------------Defines----------------------/*/\r\ntypedef vector<int> vi;\r\ntypedef pair<int,int> pii;\r\n\r\n#define For(i,n) for(int i = 0; i < (int) n; ++i)\r\n#define Rep(i,n) for(int i = 1; i <= (int) n; ++i)\r\n#define ll long long\r\n#define F first\r\n#define S second\r\n#define pb push_back\r\n#define endl \"\\n\"\r\n#define all(v) (v).begin(),(v).end()\r\n/*/-----------------------Modular Arithmetic---------------/*/\r\n\r\nconst int mod=1e9+7;\r\n\r\n/*/-----------------------------Code begins----------------------------------/*/\r\n\r\nvoid solve(){\r\n\tint n, k;\r\n\tcin >> n >> k;\r\n\r\n\tif (k == n - 1){\r\n\t\tcout << 2 << endl;\r\n\t\tfor(int i = 2; i <= n; ++i){\r\n\t\t\tcout << 1 << \" \" << i << endl;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tll dis = 2, use = k + 1;\r\n\r\n\tvector<pair<int,int>> edges;\r\n\tvector<int> leaves;\r\n\r\n\tfor(int i = 2; i <= k + 1; ++i){\r\n\t\tedges.push_back({1, i});\r\n\t\tleaves.push_back(i);\t\t\r\n\t}\r\n\twhile(use < n){\r\n\t\tdis++;\r\n\t\tint cnt = 0;\r\n\t\tfor(int j = use + 1; j <= use + k && j <= n; ++j){\r\n\t\t\tint idx = j - use - 1;\r\n\t\t\t++cnt;\r\n\t\t\tedges.push_back({leaves[idx], j});\r\n\t\t\tleaves[idx] = j;\r\n\t\t}\r\n\t\tif (cnt > 1){\r\n\t\t\t++dis;\r\n\t\t}\r\n\t\tuse += k;\r\n\t}\r\n\r\n\tcout << dis << endl;\r\n\r\n\tfor(auto e: edges){\r\n\t\tcout << e.first << \" \" << e.second << endl;\r\n\t}\r\n}\r\nint main(){\r\n    // Use \"set_name\".max_load_factor(0.25);\"set_name\".reserve(512); with unordered set\r\n    // Or use gp_hash_table<X,null_type>\r\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\r\n    cout<<fixed<<setprecision(25);\r\n    cerr<<fixed<<setprecision(10);\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n    int t=1;\r\n    //cin >> t;\r\n    while(t--) {\r\n        solve();\r\n    }\r\n    auto stop = std::chrono::high_resolution_clock::now(); \r\n    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start); \r\n    \r\n    // cerr << \"Time taken : \" << ((long double)duration.count())/((long double) 1e9) <<\"s \"<< endl;     \r\n}"
}