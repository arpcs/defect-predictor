{
    "id": 113586029,
    "contestId": 827,
    "creationTimeSeconds": 1618901273,
    "relativeTimeSeconds": 2147483647,
    "problem": {
        "contestId": 827,
        "index": "B",
        "name": "High Load",
        "type": "PROGRAMMING",
        "points": 750.0,
        "rating": 1800,
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "trees"
        ]
    },
    "author": {
        "contestId": 827,
        "members": [
            {
                "handle": "gurharpartapdhaliwal"
            }
        ],
        "participantType": "PRACTICE",
        "ghost": false,
        "startTimeSeconds": 1499791500
    },
    "programmingLanguage": "GNU C++11",
    "verdict": "OK",
    "testset": "TESTS",
    "passedTestCount": 68,
    "timeConsumedMillis": 498,
    "memoryConsumedBytes": 5632000,
    "source": "//</></>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</></>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> </>//</> <\r\n#include<bits/stdc++.h>\r\n\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n\r\n#define ff          first\r\n#define ss          second\r\n#define pb          push_back\r\n#define mp          make_pair\r\n#define pii         pair<int,int>\r\n#define vi          vector <int>\r\n#define mii         map <int,int>\r\n#define mxhi        priority_queue<int>\r\n#define mnhi        priority_queue<int,vi,greater<int> >\r\n#define mod         1000000007\r\n#define setbits(x)  __builtin_popcountll(x)\r\n#define zrobits(x)  __builtin_ctzll(x)   //no of zero bits befor the first set bits\r\n#define inf         1e18\r\n#define ps(x,y)     fixed<<setprecision(y)<<x\r\n#define w(x)        int x; cin>>x; while(x--)\r\n#define int         long long\r\nvector<int> pn;\r\ntemplate<typename T>\r\nclass graph\r\n{\r\n    map<T,list<T> > l;\r\npublic:\r\n    void addedge(T x,T y)\r\n    {\r\n\r\n        l[x].push_back(y);\r\n        l[y].push_back(x);\r\n    }\r\n    void dfs_helper(T src,map <T,bool> &visited,int count=0)   // passing bby address is necessary like 1\r\n    {\r\n\r\n        cout<<src<<\" \";\r\n        visited[src]=true;\r\n        bool ikv=false;\r\n        for(auto x:l[src])\r\n        {\r\n\r\n            if(visited[x]==0)\r\n            {  ikv=true;\r\n\r\n                dfs_helper(x,visited,count+1);\r\n            }\r\n        }\r\n\r\n            \r\n    }\r\n\r\n    void dfs(T src)\r\n    {\r\n\r\n\r\n\r\n        map<T,bool> visited;\r\n        for(auto x:l)\r\n        {\r\n\r\n            visited[x.first]=false;\r\n\r\n        }\r\n        dfs_helper(src,visited);\r\n\r\n\r\n    }\r\n    void bfs(T src)\r\n    {\r\n        queue <T> q;\r\n        map<T,int> m;\r\n        for(auto x:l)\r\n        {\r\n\r\n            m[x.first]=INT_MAX;\r\n        }\r\n        q.push(src);\r\n        m[src]=0;\r\n        while(!q.empty())\r\n        {\r\n\r\n            T top=q.front();\r\n            q.pop();\r\n          //  cout<<top<<\" \";\r\n            for(auto nbr:l[top])\r\n            {\r\n                if(m[nbr]==INT_MAX)\r\n                {\r\n\r\n                    q.push(nbr);\r\n                    m[nbr]=m[top]+1;\r\n                }\r\n\r\n            }\r\n        }\r\n                \r\n\r\n    }\r\nvoid print()\r\n    {\r\n\r\n        for(auto p:l)\r\n        {\r\n\r\n            cout<<p.first<<\"-> \";\r\n            for(auto nbr:l.second)\r\n            {\r\n\r\n                cout<<nbr<<\" \";\r\n            }\r\n            cout<<endl;\r\n        }\r\n    }\r\n\r\n\r\n};\r\n// void calncr()\r\n// {\r\n//      for(int n = 0 ; n <= 2000 ; ++n){\r\n//         for(int r = 0 ; r <= n ;++r){\r\n//             if(n==r){\r\n//                 C[n][r] = 1; \r\n//             }\r\n//             else if(r == 0){\r\n//                 C[n][r] = 1 ; \r\n//             }\r\n//             else if(r == 1){\r\n//                 C[n][r] = n; \r\n//             }\r\n//             else{\r\n//                 C[n][r] = C[n-1][r] + C[n-1][r-1] ; \r\n//             }\r\n//          //   if(n<=10 and r <= 10)\r\n//           //  cout << n << \" \" << r << \" \" << C[n][r] << \"\\n\" ; \r\n//         }\r\n//     }\r\n// }\r\nvoid SieveOfEratosthenes(int n) \r\n{   bool prime[n+1]; \r\n    memset(prime, true, sizeof(prime)); \r\n  \r\n    for (int p=2; p*p<=n; p++) \r\n    { \r\n        \r\n        if (prime[p] == true) \r\n        { \r\n         \r\n        for (int i=p*p; i<=n; i += p) \r\n                prime[i] = false; \r\n        } \r\n    } \r\n    for (int p=2; p<=n; p++) \r\n       if (prime[p]) \r\n         pn.pb(p);\r\n} \r\nint fp(int a,int n)\r\n{\r\n    int ans=1;\r\n    while(n>0)\r\n    {\r\n        bool lb=n&1;\r\n        if(lb)\r\n            ans=(ans*a);\r\n        a=(a*a);\r\n        n=n>>1;\r\n    }\r\n    return ans;\r\n}\r\ntypedef tree<int,null_type,less<int>,rb_tree_tag,\r\n        tree_order_statistics_node_update>\r\n        PBDS;\r\nvoid i_n()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    #ifndef ONLINE_JUDGE\r\n            freopen(\"input.txt\",\"r\",stdin);\r\n            freopen(\"output.txt\",\"w\",stdout);\r\n    #endif\r\n}\r\n\r\nvoid solve()\r\n{\r\n   int n,k;\r\n   cin>>n>>k;\r\n   int arr[k+1];\r\n   int cen=k+1;\r\n   vector <vector <int> > v;\r\n   v.resize(k+1);\r\n   int rem=n-(k+1);\r\n   int cur=k+2;\r\n   int i=1;\r\n   while(rem>0)\r\n   {\r\n   \t\tv[i].pb(cur);\r\n   \t\trem--;\r\n   \t\tcur++;\r\n   \t\ti++;\r\n   \t\tif(i>k)\r\n   \t\t\ti=1;\r\n   }\r\n   for(int i=1;i<=k;i++)\r\n   {\r\n   \tv[i].pb(cen);\r\n   }\r\n   int ans=(int)v[1].size()+(int)v[2].size();\r\n   cout<<ans<<endl;\r\n   for(int i=1;i<=k;i++)\r\n   {\r\n   \tcout<<i<<\" \"<<v[i][0]<<endl;\r\n   \tfor(int j=0;j<(int)v[i].size()-1;j++)\r\n   \t{\r\n   \t\tcout<<v[i][j]<<\" \"<<v[i][j+1]<<endl;\r\n   \t}\r\n   }\r\n\r\n\r\n\r\n\r\n}\r\nmain()\r\n{\r\n    i_n();\r\n    solve();\r\n    \r\n\r\n}\r\n"
}